
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[18:00:56.726] plan(): Setting new future strategy stack:
[18:00:56.727] List of future strategies:
[18:00:56.727] 1. sequential:
[18:00:56.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:56.727]    - tweaked: FALSE
[18:00:56.727]    - call: future::plan("sequential")
[18:00:56.756] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[18:00:56.771] plan(): Setting new future strategy stack:
[18:00:56.771] List of future strategies:
[18:00:56.771] 1. sequential:
[18:00:56.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:56.771]    - tweaked: FALSE
[18:00:56.771]    - call: plan(sequential)
[18:00:56.797] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[18:00:56.797] future_mapply() ...
[18:00:56.799] Generating random seeds ...
[18:00:56.799] Generating random seed streams for 4 elements ...
[18:00:56.800] Generating random seed streams for 4 elements ... DONE
[18:00:56.800] Generating random seeds ... DONE
[18:00:56.800] Will set RNG state on exit: 10407, 636678181, 502178195, 276891767, -1069534784, -723886220, 1423455687
[18:00:56.800] Number of chunks: 1
[18:00:56.801] getGlobalsAndPackagesXApply() ...
[18:00:56.801]  - future.globals: TRUE
[18:00:56.802] getGlobalsAndPackages() ...
[18:00:56.803] Searching for globals...
[18:00:56.812] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[18:00:56.812] Searching for globals ... DONE
[18:00:56.812] Resolving globals: FALSE
[18:00:56.814] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[18:00:56.815] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[18:00:56.815] - globals: [1] ‘FUN’
[18:00:56.815] - packages: [1] ‘stats’
[18:00:56.816] getGlobalsAndPackages() ... DONE
[18:00:56.816]  - globals found/used: [n=1] ‘FUN’
[18:00:56.816]  - needed namespaces: [n=1] ‘stats’
[18:00:56.816] Finding globals ... DONE
[18:00:56.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:56.817] List of 2
[18:00:56.817]  $ ...future.FUN:function (n, min = 0, max = 1)  
[18:00:56.817]  $ MoreArgs     :List of 1
[18:00:56.817]   ..$ min: num 1
[18:00:56.817]  - attr(*, "where")=List of 2
[18:00:56.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:56.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:56.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:56.817]  - attr(*, "resolved")= logi FALSE
[18:00:56.817]  - attr(*, "total_size")= num NA
[18:00:56.826] Packages to be attached in all futures: [n=1] ‘stats’
[18:00:56.826] getGlobalsAndPackagesXApply() ... DONE
[18:00:56.827] Number of futures (= number of chunks): 1
[18:00:56.827] Launching 1 futures (chunks) ...
[18:00:56.831] Chunk #1 of 1 ...
[18:00:56.832]  - Finding globals in '...' for chunk #1 ...
[18:00:56.832] getGlobalsAndPackages() ...
[18:00:56.832] Searching for globals...
[18:00:56.833] 
[18:00:56.833] Searching for globals ... DONE
[18:00:56.834] - globals: [0] <none>
[18:00:56.834] getGlobalsAndPackages() ... DONE
[18:00:56.834]    + additional globals found: [n=0] 
[18:00:56.834]    + additional namespaces needed: [n=0] 
[18:00:56.834]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:56.834]  - seeds: [4] <seeds>
[18:00:56.835]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:56.835] getGlobalsAndPackages() ...
[18:00:56.835] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:56.836] Resolving globals: FALSE
[18:00:56.837] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[18:00:56.838] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[18:00:56.838] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:56.838] - packages: [1] ‘stats’
[18:00:56.838] getGlobalsAndPackages() ... DONE
[18:00:56.840] run() for ‘Future’ ...
[18:00:56.840] - state: ‘created’
[18:00:56.840] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:56.841] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:56.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:56.841]   - Field: ‘label’
[18:00:56.841]   - Field: ‘local’
[18:00:56.842]   - Field: ‘owner’
[18:00:56.842]   - Field: ‘envir’
[18:00:56.842]   - Field: ‘packages’
[18:00:56.842]   - Field: ‘gc’
[18:00:56.842]   - Field: ‘conditions’
[18:00:56.843]   - Field: ‘expr’
[18:00:56.843]   - Field: ‘uuid’
[18:00:56.843]   - Field: ‘seed’
[18:00:56.843]   - Field: ‘version’
[18:00:56.843]   - Field: ‘result’
[18:00:56.844]   - Field: ‘asynchronous’
[18:00:56.844]   - Field: ‘calls’
[18:00:56.844]   - Field: ‘globals’
[18:00:56.844]   - Field: ‘stdout’
[18:00:56.844]   - Field: ‘earlySignal’
[18:00:56.845]   - Field: ‘lazy’
[18:00:56.845]   - Field: ‘state’
[18:00:56.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:56.845] - Launch lazy future ...
[18:00:56.846] Packages needed by the future expression (n = 1): ‘stats’
[18:00:56.847] Packages needed by future strategies (n = 0): <none>
[18:00:56.848] {
[18:00:56.848]     {
[18:00:56.848]         {
[18:00:56.848]             ...future.startTime <- base::Sys.time()
[18:00:56.848]             {
[18:00:56.848]                 {
[18:00:56.848]                   {
[18:00:56.848]                     {
[18:00:56.848]                       base::local({
[18:00:56.848]                         has_future <- base::requireNamespace("future", 
[18:00:56.848]                           quietly = TRUE)
[18:00:56.848]                         if (has_future) {
[18:00:56.848]                           ns <- base::getNamespace("future")
[18:00:56.848]                           version <- ns[[".package"]][["version"]]
[18:00:56.848]                           if (is.null(version)) 
[18:00:56.848]                             version <- utils::packageVersion("future")
[18:00:56.848]                         }
[18:00:56.848]                         else {
[18:00:56.848]                           version <- NULL
[18:00:56.848]                         }
[18:00:56.848]                         if (!has_future || version < "1.8.0") {
[18:00:56.848]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:56.848]                             "", base::R.version$version.string), 
[18:00:56.848]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:56.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:56.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:56.848]                               "release", "version")], collapse = " "), 
[18:00:56.848]                             hostname = base::Sys.info()[["nodename"]])
[18:00:56.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:56.848]                             info)
[18:00:56.848]                           info <- base::paste(info, collapse = "; ")
[18:00:56.848]                           if (!has_future) {
[18:00:56.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:56.848]                               info)
[18:00:56.848]                           }
[18:00:56.848]                           else {
[18:00:56.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:56.848]                               info, version)
[18:00:56.848]                           }
[18:00:56.848]                           base::stop(msg)
[18:00:56.848]                         }
[18:00:56.848]                       })
[18:00:56.848]                     }
[18:00:56.848]                     base::local({
[18:00:56.848]                       for (pkg in "stats") {
[18:00:56.848]                         base::loadNamespace(pkg)
[18:00:56.848]                         base::library(pkg, character.only = TRUE)
[18:00:56.848]                       }
[18:00:56.848]                     })
[18:00:56.848]                   }
[18:00:56.848]                   ...future.strategy.old <- future::plan("list")
[18:00:56.848]                   options(future.plan = NULL)
[18:00:56.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:56.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:56.848]                 }
[18:00:56.848]                 ...future.workdir <- getwd()
[18:00:56.848]             }
[18:00:56.848]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:56.848]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:56.848]         }
[18:00:56.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:56.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:56.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:56.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:56.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:56.848]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:56.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:56.848]             base::names(...future.oldOptions))
[18:00:56.848]     }
[18:00:56.848]     if (FALSE) {
[18:00:56.848]     }
[18:00:56.848]     else {
[18:00:56.848]         if (TRUE) {
[18:00:56.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:56.848]                 open = "w")
[18:00:56.848]         }
[18:00:56.848]         else {
[18:00:56.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:56.848]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:56.848]         }
[18:00:56.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:56.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:56.848]             base::sink(type = "output", split = FALSE)
[18:00:56.848]             base::close(...future.stdout)
[18:00:56.848]         }, add = TRUE)
[18:00:56.848]     }
[18:00:56.848]     ...future.frame <- base::sys.nframe()
[18:00:56.848]     ...future.conditions <- base::list()
[18:00:56.848]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:56.848]     if (FALSE) {
[18:00:56.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:56.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:56.848]     }
[18:00:56.848]     ...future.result <- base::tryCatch({
[18:00:56.848]         base::withCallingHandlers({
[18:00:56.848]             ...future.value <- base::withVisible(base::local({
[18:00:56.848]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:56.848]                 if (!identical(...future.globals.maxSize.org, 
[18:00:56.848]                   ...future.globals.maxSize)) {
[18:00:56.848]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:56.848]                   on.exit(options(oopts), add = TRUE)
[18:00:56.848]                 }
[18:00:56.848]                 {
[18:00:56.848]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:00:56.848]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[18:00:56.848]                       envir = globalenv(), inherits = FALSE)
[18:00:56.848]                     ...future.FUN(...)
[18:00:56.848]                   }
[18:00:56.848]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:00:56.848]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:00:56.848]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:56.848]                     USE.NAMES = FALSE)
[18:00:56.848]                   do.call(mapply, args = args)
[18:00:56.848]                 }
[18:00:56.848]             }))
[18:00:56.848]             future::FutureResult(value = ...future.value$value, 
[18:00:56.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:56.848]                   ...future.rng), globalenv = if (FALSE) 
[18:00:56.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:56.848]                     ...future.globalenv.names))
[18:00:56.848]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:56.848]         }, condition = base::local({
[18:00:56.848]             c <- base::c
[18:00:56.848]             inherits <- base::inherits
[18:00:56.848]             invokeRestart <- base::invokeRestart
[18:00:56.848]             length <- base::length
[18:00:56.848]             list <- base::list
[18:00:56.848]             seq.int <- base::seq.int
[18:00:56.848]             signalCondition <- base::signalCondition
[18:00:56.848]             sys.calls <- base::sys.calls
[18:00:56.848]             `[[` <- base::`[[`
[18:00:56.848]             `+` <- base::`+`
[18:00:56.848]             `<<-` <- base::`<<-`
[18:00:56.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:56.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:56.848]                   3L)]
[18:00:56.848]             }
[18:00:56.848]             function(cond) {
[18:00:56.848]                 is_error <- inherits(cond, "error")
[18:00:56.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:56.848]                   NULL)
[18:00:56.848]                 if (is_error) {
[18:00:56.848]                   sessionInformation <- function() {
[18:00:56.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:56.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:56.848]                       search = base::search(), system = base::Sys.info())
[18:00:56.848]                   }
[18:00:56.848]                   ...future.conditions[[length(...future.conditions) + 
[18:00:56.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:56.848]                     cond$call), session = sessionInformation(), 
[18:00:56.848]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:56.848]                   signalCondition(cond)
[18:00:56.848]                 }
[18:00:56.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:56.848]                 "immediateCondition"))) {
[18:00:56.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:56.848]                   ...future.conditions[[length(...future.conditions) + 
[18:00:56.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:56.848]                   if (TRUE && !signal) {
[18:00:56.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:56.848]                     {
[18:00:56.848]                       inherits <- base::inherits
[18:00:56.848]                       invokeRestart <- base::invokeRestart
[18:00:56.848]                       is.null <- base::is.null
[18:00:56.848]                       muffled <- FALSE
[18:00:56.848]                       if (inherits(cond, "message")) {
[18:00:56.848]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:56.848]                         if (muffled) 
[18:00:56.848]                           invokeRestart("muffleMessage")
[18:00:56.848]                       }
[18:00:56.848]                       else if (inherits(cond, "warning")) {
[18:00:56.848]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:56.848]                         if (muffled) 
[18:00:56.848]                           invokeRestart("muffleWarning")
[18:00:56.848]                       }
[18:00:56.848]                       else if (inherits(cond, "condition")) {
[18:00:56.848]                         if (!is.null(pattern)) {
[18:00:56.848]                           computeRestarts <- base::computeRestarts
[18:00:56.848]                           grepl <- base::grepl
[18:00:56.848]                           restarts <- computeRestarts(cond)
[18:00:56.848]                           for (restart in restarts) {
[18:00:56.848]                             name <- restart$name
[18:00:56.848]                             if (is.null(name)) 
[18:00:56.848]                               next
[18:00:56.848]                             if (!grepl(pattern, name)) 
[18:00:56.848]                               next
[18:00:56.848]                             invokeRestart(restart)
[18:00:56.848]                             muffled <- TRUE
[18:00:56.848]                             break
[18:00:56.848]                           }
[18:00:56.848]                         }
[18:00:56.848]                       }
[18:00:56.848]                       invisible(muffled)
[18:00:56.848]                     }
[18:00:56.848]                     muffleCondition(cond, pattern = "^muffle")
[18:00:56.848]                   }
[18:00:56.848]                 }
[18:00:56.848]                 else {
[18:00:56.848]                   if (TRUE) {
[18:00:56.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:56.848]                     {
[18:00:56.848]                       inherits <- base::inherits
[18:00:56.848]                       invokeRestart <- base::invokeRestart
[18:00:56.848]                       is.null <- base::is.null
[18:00:56.848]                       muffled <- FALSE
[18:00:56.848]                       if (inherits(cond, "message")) {
[18:00:56.848]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:56.848]                         if (muffled) 
[18:00:56.848]                           invokeRestart("muffleMessage")
[18:00:56.848]                       }
[18:00:56.848]                       else if (inherits(cond, "warning")) {
[18:00:56.848]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:56.848]                         if (muffled) 
[18:00:56.848]                           invokeRestart("muffleWarning")
[18:00:56.848]                       }
[18:00:56.848]                       else if (inherits(cond, "condition")) {
[18:00:56.848]                         if (!is.null(pattern)) {
[18:00:56.848]                           computeRestarts <- base::computeRestarts
[18:00:56.848]                           grepl <- base::grepl
[18:00:56.848]                           restarts <- computeRestarts(cond)
[18:00:56.848]                           for (restart in restarts) {
[18:00:56.848]                             name <- restart$name
[18:00:56.848]                             if (is.null(name)) 
[18:00:56.848]                               next
[18:00:56.848]                             if (!grepl(pattern, name)) 
[18:00:56.848]                               next
[18:00:56.848]                             invokeRestart(restart)
[18:00:56.848]                             muffled <- TRUE
[18:00:56.848]                             break
[18:00:56.848]                           }
[18:00:56.848]                         }
[18:00:56.848]                       }
[18:00:56.848]                       invisible(muffled)
[18:00:56.848]                     }
[18:00:56.848]                     muffleCondition(cond, pattern = "^muffle")
[18:00:56.848]                   }
[18:00:56.848]                 }
[18:00:56.848]             }
[18:00:56.848]         }))
[18:00:56.848]     }, error = function(ex) {
[18:00:56.848]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:56.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:56.848]                 ...future.rng), started = ...future.startTime, 
[18:00:56.848]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:56.848]             version = "1.8"), class = "FutureResult")
[18:00:56.848]     }, finally = {
[18:00:56.848]         if (!identical(...future.workdir, getwd())) 
[18:00:56.848]             setwd(...future.workdir)
[18:00:56.848]         {
[18:00:56.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:56.848]                 ...future.oldOptions$nwarnings <- NULL
[18:00:56.848]             }
[18:00:56.848]             base::options(...future.oldOptions)
[18:00:56.848]             if (.Platform$OS.type == "windows") {
[18:00:56.848]                 old_names <- names(...future.oldEnvVars)
[18:00:56.848]                 envs <- base::Sys.getenv()
[18:00:56.848]                 names <- names(envs)
[18:00:56.848]                 common <- intersect(names, old_names)
[18:00:56.848]                 added <- setdiff(names, old_names)
[18:00:56.848]                 removed <- setdiff(old_names, names)
[18:00:56.848]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:56.848]                   envs[common]]
[18:00:56.848]                 NAMES <- toupper(changed)
[18:00:56.848]                 args <- list()
[18:00:56.848]                 for (kk in seq_along(NAMES)) {
[18:00:56.848]                   name <- changed[[kk]]
[18:00:56.848]                   NAME <- NAMES[[kk]]
[18:00:56.848]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:56.848]                     next
[18:00:56.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:56.848]                 }
[18:00:56.848]                 NAMES <- toupper(added)
[18:00:56.848]                 for (kk in seq_along(NAMES)) {
[18:00:56.848]                   name <- added[[kk]]
[18:00:56.848]                   NAME <- NAMES[[kk]]
[18:00:56.848]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:56.848]                     next
[18:00:56.848]                   args[[name]] <- ""
[18:00:56.848]                 }
[18:00:56.848]                 NAMES <- toupper(removed)
[18:00:56.848]                 for (kk in seq_along(NAMES)) {
[18:00:56.848]                   name <- removed[[kk]]
[18:00:56.848]                   NAME <- NAMES[[kk]]
[18:00:56.848]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:56.848]                     next
[18:00:56.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:56.848]                 }
[18:00:56.848]                 if (length(args) > 0) 
[18:00:56.848]                   base::do.call(base::Sys.setenv, args = args)
[18:00:56.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:56.848]             }
[18:00:56.848]             else {
[18:00:56.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:56.848]             }
[18:00:56.848]             {
[18:00:56.848]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:56.848]                   0L) {
[18:00:56.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:56.848]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:56.848]                   base::options(opts)
[18:00:56.848]                 }
[18:00:56.848]                 {
[18:00:56.848]                   {
[18:00:56.848]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:56.848]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:56.848]                     1423455687L), envir = base::globalenv(), 
[18:00:56.848]                       inherits = FALSE)
[18:00:56.848]                     NULL
[18:00:56.848]                   }
[18:00:56.848]                   options(future.plan = NULL)
[18:00:56.848]                   if (is.na(NA_character_)) 
[18:00:56.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:56.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:56.848]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:56.848]                     .init = FALSE)
[18:00:56.848]                 }
[18:00:56.848]             }
[18:00:56.848]         }
[18:00:56.848]     })
[18:00:56.848]     if (TRUE) {
[18:00:56.848]         base::sink(type = "output", split = FALSE)
[18:00:56.848]         if (TRUE) {
[18:00:56.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:56.848]         }
[18:00:56.848]         else {
[18:00:56.848]             ...future.result["stdout"] <- base::list(NULL)
[18:00:56.848]         }
[18:00:56.848]         base::close(...future.stdout)
[18:00:56.848]         ...future.stdout <- NULL
[18:00:56.848]     }
[18:00:56.848]     ...future.result$conditions <- ...future.conditions
[18:00:56.848]     ...future.result$finished <- base::Sys.time()
[18:00:56.848]     ...future.result
[18:00:56.848] }
[18:00:56.852] assign_globals() ...
[18:00:56.852] List of 5
[18:00:56.852]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[18:00:56.852]  $ MoreArgs                 :List of 1
[18:00:56.852]   ..$ min: num 1
[18:00:56.852]  $ ...future.elements_ii    :List of 2
[18:00:56.852]   ..$ n  :List of 4
[18:00:56.852]   .. ..$ : int 1
[18:00:56.852]   .. ..$ : int 2
[18:00:56.852]   .. ..$ : int 3
[18:00:56.852]   .. ..$ : int 4
[18:00:56.852]   ..$ max:List of 4
[18:00:56.852]   .. ..$ : int 2
[18:00:56.852]   .. ..$ : int 3
[18:00:56.852]   .. ..$ : int 4
[18:00:56.852]   .. ..$ : int 5
[18:00:56.852]  $ ...future.seeds_ii       :List of 4
[18:00:56.852]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[18:00:56.852]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[18:00:56.852]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[18:00:56.852]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[18:00:56.852]  $ ...future.globals.maxSize: NULL
[18:00:56.852]  - attr(*, "where")=List of 5
[18:00:56.852]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:56.852]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:56.852]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:56.852]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:56.852]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:56.852]  - attr(*, "resolved")= logi FALSE
[18:00:56.852]  - attr(*, "total_size")= num 2912
[18:00:56.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:56.852]  - attr(*, "already-done")= logi TRUE
[18:00:56.869] - copied ‘...future.FUN’ to environment
[18:00:56.869] - copied ‘MoreArgs’ to environment
[18:00:56.869] - copied ‘...future.elements_ii’ to environment
[18:00:56.870] - copied ‘...future.seeds_ii’ to environment
[18:00:56.870] - copied ‘...future.globals.maxSize’ to environment
[18:00:56.870] assign_globals() ... done
[18:00:56.871] plan(): Setting new future strategy stack:
[18:00:56.871] List of future strategies:
[18:00:56.871] 1. sequential:
[18:00:56.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:56.871]    - tweaked: FALSE
[18:00:56.871]    - call: NULL
[18:00:56.872] plan(): nbrOfWorkers() = 1
[18:00:56.874] plan(): Setting new future strategy stack:
[18:00:56.874] List of future strategies:
[18:00:56.874] 1. sequential:
[18:00:56.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:56.874]    - tweaked: FALSE
[18:00:56.874]    - call: plan(sequential)
[18:00:56.875] plan(): nbrOfWorkers() = 1
[18:00:56.876] SequentialFuture started (and completed)
[18:00:56.876] - Launch lazy future ... done
[18:00:56.877] run() for ‘SequentialFuture’ ... done
[18:00:56.877] Created future:
[18:00:56.877] SequentialFuture:
[18:00:56.877] Label: ‘future_mapply-1’
[18:00:56.877] Expression:
[18:00:56.877] {
[18:00:56.877]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:56.877]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:56.877]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:56.877]         on.exit(options(oopts), add = TRUE)
[18:00:56.877]     }
[18:00:56.877]     {
[18:00:56.877]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:00:56.877]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:00:56.877]                 inherits = FALSE)
[18:00:56.877]             ...future.FUN(...)
[18:00:56.877]         }
[18:00:56.877]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:00:56.877]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:00:56.877]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:56.877]         do.call(mapply, args = args)
[18:00:56.877]     }
[18:00:56.877] }
[18:00:56.877] Lazy evaluation: FALSE
[18:00:56.877] Asynchronous evaluation: FALSE
[18:00:56.877] Local evaluation: TRUE
[18:00:56.877] Environment: R_GlobalEnv
[18:00:56.877] Capture standard output: TRUE
[18:00:56.877] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:56.877] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:56.877] Packages: 1 packages (‘stats’)
[18:00:56.877] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:00:56.877] Resolved: TRUE
[18:00:56.877] Value: 280 bytes of class ‘list’
[18:00:56.877] Early signaling: FALSE
[18:00:56.877] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:56.877] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:56.880] Chunk #1 of 1 ... DONE
[18:00:56.880] Launching 1 futures (chunks) ... DONE
[18:00:56.880] Resolving 1 futures (chunks) ...
[18:00:56.881] resolve() on list ...
[18:00:56.881]  recursive: 0
[18:00:56.882]  length: 1
[18:00:56.882] 
[18:00:56.882] resolved() for ‘SequentialFuture’ ...
[18:00:56.882] - state: ‘finished’
[18:00:56.882] - run: TRUE
[18:00:56.883] - result: ‘FutureResult’
[18:00:56.883] resolved() for ‘SequentialFuture’ ... done
[18:00:56.883] Future #1
[18:00:56.884] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:56.884] - nx: 1
[18:00:56.884] - relay: TRUE
[18:00:56.884] - stdout: TRUE
[18:00:56.885] - signal: TRUE
[18:00:56.885] - resignal: FALSE
[18:00:56.885] - force: TRUE
[18:00:56.885] - relayed: [n=1] FALSE
[18:00:56.885] - queued futures: [n=1] FALSE
[18:00:56.885]  - until=1
[18:00:56.886]  - relaying element #1
[18:00:56.886] - relayed: [n=1] TRUE
[18:00:56.886] - queued futures: [n=1] TRUE
[18:00:56.886] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:56.887]  length: 0 (resolved future 1)
[18:00:56.887] Relaying remaining futures
[18:00:56.887] signalConditionsASAP(NULL, pos=0) ...
[18:00:56.887] - nx: 1
[18:00:56.888] - relay: TRUE
[18:00:56.888] - stdout: TRUE
[18:00:56.888] - signal: TRUE
[18:00:56.888] - resignal: FALSE
[18:00:56.888] - force: TRUE
[18:00:56.888] - relayed: [n=1] TRUE
[18:00:56.889] - queued futures: [n=1] TRUE
 - flush all
[18:00:56.889] - relayed: [n=1] TRUE
[18:00:56.889] - queued futures: [n=1] TRUE
[18:00:56.889] signalConditionsASAP(NULL, pos=0) ... done
[18:00:56.889] resolve() on list ... DONE
[18:00:56.890]  - Number of value chunks collected: 1
[18:00:56.890] Resolving 1 futures (chunks) ... DONE
[18:00:56.890] Reducing values from 1 chunks ...
[18:00:56.890]  - Number of values collected after concatenation: 4
[18:00:56.890]  - Number of values expected: 4
[18:00:56.891] Reducing values from 1 chunks ... DONE
[18:00:56.891] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[18:00:57.223] plan(): Setting new future strategy stack:
[18:00:57.223] List of future strategies:
[18:00:57.223] 1. sequential:
[18:00:57.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.223]    - tweaked: FALSE
[18:00:57.223]    - call: plan(strategy)
[18:00:57.224] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[18:00:57.225] future_mapply() ...
[18:00:57.225] Number of chunks: 1
[18:00:57.225] getGlobalsAndPackagesXApply() ...
[18:00:57.225]  - future.globals: TRUE
[18:00:57.225] getGlobalsAndPackages() ...
[18:00:57.226] Searching for globals...
[18:00:57.227] - globals found: [1] ‘FUN’
[18:00:57.227] Searching for globals ... DONE
[18:00:57.227] Resolving globals: FALSE
[18:00:57.228] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:57.228] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:57.229] - globals: [1] ‘FUN’
[18:00:57.229] 
[18:00:57.229] getGlobalsAndPackages() ... DONE
[18:00:57.229]  - globals found/used: [n=1] ‘FUN’
[18:00:57.229]  - needed namespaces: [n=0] 
[18:00:57.230] Finding globals ... DONE
[18:00:57.230] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.230] List of 2
[18:00:57.230]  $ ...future.FUN:function (x, ...)  
[18:00:57.230]  $ MoreArgs     : NULL
[18:00:57.230]  - attr(*, "where")=List of 2
[18:00:57.230]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.230]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.230]  - attr(*, "resolved")= logi FALSE
[18:00:57.230]  - attr(*, "total_size")= num NA
[18:00:57.235] Packages to be attached in all futures: [n=0] 
[18:00:57.235] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.236] Number of futures (= number of chunks): 1
[18:00:57.236] Launching 1 futures (chunks) ...
[18:00:57.236] Chunk #1 of 1 ...
[18:00:57.236]  - Finding globals in '...' for chunk #1 ...
[18:00:57.236] getGlobalsAndPackages() ...
[18:00:57.237] Searching for globals...
[18:00:57.237] 
[18:00:57.238] Searching for globals ... DONE
[18:00:57.238] - globals: [0] <none>
[18:00:57.238] getGlobalsAndPackages() ... DONE
[18:00:57.238]    + additional globals found: [n=0] 
[18:00:57.238]    + additional namespaces needed: [n=0] 
[18:00:57.238]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.239]  - seeds: <none>
[18:00:57.239]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.239] getGlobalsAndPackages() ...
[18:00:57.239] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.239] Resolving globals: FALSE
[18:00:57.240] The total size of the 5 globals is 504 bytes (504 bytes)
[18:00:57.241] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.242] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.242] 
[18:00:57.242] getGlobalsAndPackages() ... DONE
[18:00:57.243] run() for ‘Future’ ...
[18:00:57.243] - state: ‘created’
[18:00:57.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.244]   - Field: ‘label’
[18:00:57.244]   - Field: ‘local’
[18:00:57.244]   - Field: ‘owner’
[18:00:57.245]   - Field: ‘envir’
[18:00:57.245]   - Field: ‘packages’
[18:00:57.245]   - Field: ‘gc’
[18:00:57.245]   - Field: ‘conditions’
[18:00:57.245]   - Field: ‘expr’
[18:00:57.246]   - Field: ‘uuid’
[18:00:57.246]   - Field: ‘seed’
[18:00:57.246]   - Field: ‘version’
[18:00:57.246]   - Field: ‘result’
[18:00:57.246]   - Field: ‘asynchronous’
[18:00:57.247]   - Field: ‘calls’
[18:00:57.247]   - Field: ‘globals’
[18:00:57.247]   - Field: ‘stdout’
[18:00:57.247]   - Field: ‘earlySignal’
[18:00:57.247]   - Field: ‘lazy’
[18:00:57.247]   - Field: ‘state’
[18:00:57.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.248] - Launch lazy future ...
[18:00:57.248] Packages needed by the future expression (n = 0): <none>
[18:00:57.248] Packages needed by future strategies (n = 0): <none>
[18:00:57.252] {
[18:00:57.252]     {
[18:00:57.252]         {
[18:00:57.252]             ...future.startTime <- base::Sys.time()
[18:00:57.252]             {
[18:00:57.252]                 {
[18:00:57.252]                   {
[18:00:57.252]                     base::local({
[18:00:57.252]                       has_future <- base::requireNamespace("future", 
[18:00:57.252]                         quietly = TRUE)
[18:00:57.252]                       if (has_future) {
[18:00:57.252]                         ns <- base::getNamespace("future")
[18:00:57.252]                         version <- ns[[".package"]][["version"]]
[18:00:57.252]                         if (is.null(version)) 
[18:00:57.252]                           version <- utils::packageVersion("future")
[18:00:57.252]                       }
[18:00:57.252]                       else {
[18:00:57.252]                         version <- NULL
[18:00:57.252]                       }
[18:00:57.252]                       if (!has_future || version < "1.8.0") {
[18:00:57.252]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.252]                           "", base::R.version$version.string), 
[18:00:57.252]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.252]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.252]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.252]                             "release", "version")], collapse = " "), 
[18:00:57.252]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.252]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.252]                           info)
[18:00:57.252]                         info <- base::paste(info, collapse = "; ")
[18:00:57.252]                         if (!has_future) {
[18:00:57.252]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.252]                             info)
[18:00:57.252]                         }
[18:00:57.252]                         else {
[18:00:57.252]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.252]                             info, version)
[18:00:57.252]                         }
[18:00:57.252]                         base::stop(msg)
[18:00:57.252]                       }
[18:00:57.252]                     })
[18:00:57.252]                   }
[18:00:57.252]                   ...future.strategy.old <- future::plan("list")
[18:00:57.252]                   options(future.plan = NULL)
[18:00:57.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.252]                 }
[18:00:57.252]                 ...future.workdir <- getwd()
[18:00:57.252]             }
[18:00:57.252]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.252]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.252]         }
[18:00:57.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.252]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.252]             base::names(...future.oldOptions))
[18:00:57.252]     }
[18:00:57.252]     if (FALSE) {
[18:00:57.252]     }
[18:00:57.252]     else {
[18:00:57.252]         if (TRUE) {
[18:00:57.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.252]                 open = "w")
[18:00:57.252]         }
[18:00:57.252]         else {
[18:00:57.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.252]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.252]         }
[18:00:57.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.252]             base::sink(type = "output", split = FALSE)
[18:00:57.252]             base::close(...future.stdout)
[18:00:57.252]         }, add = TRUE)
[18:00:57.252]     }
[18:00:57.252]     ...future.frame <- base::sys.nframe()
[18:00:57.252]     ...future.conditions <- base::list()
[18:00:57.252]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.252]     if (FALSE) {
[18:00:57.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.252]     }
[18:00:57.252]     ...future.result <- base::tryCatch({
[18:00:57.252]         base::withCallingHandlers({
[18:00:57.252]             ...future.value <- base::withVisible(base::local({
[18:00:57.252]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.252]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.252]                   ...future.globals.maxSize)) {
[18:00:57.252]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.252]                   on.exit(options(oopts), add = TRUE)
[18:00:57.252]                 }
[18:00:57.252]                 {
[18:00:57.252]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.252]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.252]                     USE.NAMES = FALSE)
[18:00:57.252]                   do.call(mapply, args = args)
[18:00:57.252]                 }
[18:00:57.252]             }))
[18:00:57.252]             future::FutureResult(value = ...future.value$value, 
[18:00:57.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.252]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.252]                     ...future.globalenv.names))
[18:00:57.252]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.252]         }, condition = base::local({
[18:00:57.252]             c <- base::c
[18:00:57.252]             inherits <- base::inherits
[18:00:57.252]             invokeRestart <- base::invokeRestart
[18:00:57.252]             length <- base::length
[18:00:57.252]             list <- base::list
[18:00:57.252]             seq.int <- base::seq.int
[18:00:57.252]             signalCondition <- base::signalCondition
[18:00:57.252]             sys.calls <- base::sys.calls
[18:00:57.252]             `[[` <- base::`[[`
[18:00:57.252]             `+` <- base::`+`
[18:00:57.252]             `<<-` <- base::`<<-`
[18:00:57.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.252]                   3L)]
[18:00:57.252]             }
[18:00:57.252]             function(cond) {
[18:00:57.252]                 is_error <- inherits(cond, "error")
[18:00:57.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.252]                   NULL)
[18:00:57.252]                 if (is_error) {
[18:00:57.252]                   sessionInformation <- function() {
[18:00:57.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.252]                       search = base::search(), system = base::Sys.info())
[18:00:57.252]                   }
[18:00:57.252]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.252]                     cond$call), session = sessionInformation(), 
[18:00:57.252]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.252]                   signalCondition(cond)
[18:00:57.252]                 }
[18:00:57.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.252]                 "immediateCondition"))) {
[18:00:57.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.252]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.252]                   if (TRUE && !signal) {
[18:00:57.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.252]                     {
[18:00:57.252]                       inherits <- base::inherits
[18:00:57.252]                       invokeRestart <- base::invokeRestart
[18:00:57.252]                       is.null <- base::is.null
[18:00:57.252]                       muffled <- FALSE
[18:00:57.252]                       if (inherits(cond, "message")) {
[18:00:57.252]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.252]                         if (muffled) 
[18:00:57.252]                           invokeRestart("muffleMessage")
[18:00:57.252]                       }
[18:00:57.252]                       else if (inherits(cond, "warning")) {
[18:00:57.252]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.252]                         if (muffled) 
[18:00:57.252]                           invokeRestart("muffleWarning")
[18:00:57.252]                       }
[18:00:57.252]                       else if (inherits(cond, "condition")) {
[18:00:57.252]                         if (!is.null(pattern)) {
[18:00:57.252]                           computeRestarts <- base::computeRestarts
[18:00:57.252]                           grepl <- base::grepl
[18:00:57.252]                           restarts <- computeRestarts(cond)
[18:00:57.252]                           for (restart in restarts) {
[18:00:57.252]                             name <- restart$name
[18:00:57.252]                             if (is.null(name)) 
[18:00:57.252]                               next
[18:00:57.252]                             if (!grepl(pattern, name)) 
[18:00:57.252]                               next
[18:00:57.252]                             invokeRestart(restart)
[18:00:57.252]                             muffled <- TRUE
[18:00:57.252]                             break
[18:00:57.252]                           }
[18:00:57.252]                         }
[18:00:57.252]                       }
[18:00:57.252]                       invisible(muffled)
[18:00:57.252]                     }
[18:00:57.252]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.252]                   }
[18:00:57.252]                 }
[18:00:57.252]                 else {
[18:00:57.252]                   if (TRUE) {
[18:00:57.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.252]                     {
[18:00:57.252]                       inherits <- base::inherits
[18:00:57.252]                       invokeRestart <- base::invokeRestart
[18:00:57.252]                       is.null <- base::is.null
[18:00:57.252]                       muffled <- FALSE
[18:00:57.252]                       if (inherits(cond, "message")) {
[18:00:57.252]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.252]                         if (muffled) 
[18:00:57.252]                           invokeRestart("muffleMessage")
[18:00:57.252]                       }
[18:00:57.252]                       else if (inherits(cond, "warning")) {
[18:00:57.252]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.252]                         if (muffled) 
[18:00:57.252]                           invokeRestart("muffleWarning")
[18:00:57.252]                       }
[18:00:57.252]                       else if (inherits(cond, "condition")) {
[18:00:57.252]                         if (!is.null(pattern)) {
[18:00:57.252]                           computeRestarts <- base::computeRestarts
[18:00:57.252]                           grepl <- base::grepl
[18:00:57.252]                           restarts <- computeRestarts(cond)
[18:00:57.252]                           for (restart in restarts) {
[18:00:57.252]                             name <- restart$name
[18:00:57.252]                             if (is.null(name)) 
[18:00:57.252]                               next
[18:00:57.252]                             if (!grepl(pattern, name)) 
[18:00:57.252]                               next
[18:00:57.252]                             invokeRestart(restart)
[18:00:57.252]                             muffled <- TRUE
[18:00:57.252]                             break
[18:00:57.252]                           }
[18:00:57.252]                         }
[18:00:57.252]                       }
[18:00:57.252]                       invisible(muffled)
[18:00:57.252]                     }
[18:00:57.252]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.252]                   }
[18:00:57.252]                 }
[18:00:57.252]             }
[18:00:57.252]         }))
[18:00:57.252]     }, error = function(ex) {
[18:00:57.252]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.252]                 ...future.rng), started = ...future.startTime, 
[18:00:57.252]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.252]             version = "1.8"), class = "FutureResult")
[18:00:57.252]     }, finally = {
[18:00:57.252]         if (!identical(...future.workdir, getwd())) 
[18:00:57.252]             setwd(...future.workdir)
[18:00:57.252]         {
[18:00:57.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.252]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.252]             }
[18:00:57.252]             base::options(...future.oldOptions)
[18:00:57.252]             if (.Platform$OS.type == "windows") {
[18:00:57.252]                 old_names <- names(...future.oldEnvVars)
[18:00:57.252]                 envs <- base::Sys.getenv()
[18:00:57.252]                 names <- names(envs)
[18:00:57.252]                 common <- intersect(names, old_names)
[18:00:57.252]                 added <- setdiff(names, old_names)
[18:00:57.252]                 removed <- setdiff(old_names, names)
[18:00:57.252]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.252]                   envs[common]]
[18:00:57.252]                 NAMES <- toupper(changed)
[18:00:57.252]                 args <- list()
[18:00:57.252]                 for (kk in seq_along(NAMES)) {
[18:00:57.252]                   name <- changed[[kk]]
[18:00:57.252]                   NAME <- NAMES[[kk]]
[18:00:57.252]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.252]                     next
[18:00:57.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.252]                 }
[18:00:57.252]                 NAMES <- toupper(added)
[18:00:57.252]                 for (kk in seq_along(NAMES)) {
[18:00:57.252]                   name <- added[[kk]]
[18:00:57.252]                   NAME <- NAMES[[kk]]
[18:00:57.252]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.252]                     next
[18:00:57.252]                   args[[name]] <- ""
[18:00:57.252]                 }
[18:00:57.252]                 NAMES <- toupper(removed)
[18:00:57.252]                 for (kk in seq_along(NAMES)) {
[18:00:57.252]                   name <- removed[[kk]]
[18:00:57.252]                   NAME <- NAMES[[kk]]
[18:00:57.252]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.252]                     next
[18:00:57.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.252]                 }
[18:00:57.252]                 if (length(args) > 0) 
[18:00:57.252]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.252]             }
[18:00:57.252]             else {
[18:00:57.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.252]             }
[18:00:57.252]             {
[18:00:57.252]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.252]                   0L) {
[18:00:57.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.252]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.252]                   base::options(opts)
[18:00:57.252]                 }
[18:00:57.252]                 {
[18:00:57.252]                   {
[18:00:57.252]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.252]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.252]                     1423455687L), envir = base::globalenv(), 
[18:00:57.252]                       inherits = FALSE)
[18:00:57.252]                     NULL
[18:00:57.252]                   }
[18:00:57.252]                   options(future.plan = NULL)
[18:00:57.252]                   if (is.na(NA_character_)) 
[18:00:57.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.252]                     .init = FALSE)
[18:00:57.252]                 }
[18:00:57.252]             }
[18:00:57.252]         }
[18:00:57.252]     })
[18:00:57.252]     if (TRUE) {
[18:00:57.252]         base::sink(type = "output", split = FALSE)
[18:00:57.252]         if (TRUE) {
[18:00:57.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.252]         }
[18:00:57.252]         else {
[18:00:57.252]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.252]         }
[18:00:57.252]         base::close(...future.stdout)
[18:00:57.252]         ...future.stdout <- NULL
[18:00:57.252]     }
[18:00:57.252]     ...future.result$conditions <- ...future.conditions
[18:00:57.252]     ...future.result$finished <- base::Sys.time()
[18:00:57.252]     ...future.result
[18:00:57.252] }
[18:00:57.255] assign_globals() ...
[18:00:57.255] List of 5
[18:00:57.255]  $ ...future.FUN            :function (x, ...)  
[18:00:57.255]  $ MoreArgs                 : NULL
[18:00:57.255]  $ ...future.elements_ii    :List of 2
[18:00:57.255]   ..$ :List of 4
[18:00:57.255]   .. ..$ : int 1
[18:00:57.255]   .. ..$ : int 2
[18:00:57.255]   .. ..$ : int 3
[18:00:57.255]   .. ..$ : int 4
[18:00:57.255]   ..$ :List of 4
[18:00:57.255]   .. ..$ : int 4
[18:00:57.255]   .. ..$ : int 3
[18:00:57.255]   .. ..$ : int 2
[18:00:57.255]   .. ..$ : int 1
[18:00:57.255]  $ ...future.seeds_ii       : NULL
[18:00:57.255]  $ ...future.globals.maxSize: NULL
[18:00:57.255]  - attr(*, "where")=List of 5
[18:00:57.255]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.255]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.255]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.255]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.255]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.255]  - attr(*, "resolved")= logi FALSE
[18:00:57.255]  - attr(*, "total_size")= num 504
[18:00:57.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.255]  - attr(*, "already-done")= logi TRUE
[18:00:57.270] - copied ‘...future.FUN’ to environment
[18:00:57.271] - copied ‘MoreArgs’ to environment
[18:00:57.271] - copied ‘...future.elements_ii’ to environment
[18:00:57.271] - copied ‘...future.seeds_ii’ to environment
[18:00:57.271] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.271] assign_globals() ... done
[18:00:57.272] plan(): Setting new future strategy stack:
[18:00:57.272] List of future strategies:
[18:00:57.272] 1. sequential:
[18:00:57.272]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.272]    - tweaked: FALSE
[18:00:57.272]    - call: NULL
[18:00:57.273] plan(): nbrOfWorkers() = 1
[18:00:57.274] plan(): Setting new future strategy stack:
[18:00:57.275] List of future strategies:
[18:00:57.275] 1. sequential:
[18:00:57.275]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.275]    - tweaked: FALSE
[18:00:57.275]    - call: plan(strategy)
[18:00:57.275] plan(): nbrOfWorkers() = 1
[18:00:57.276] SequentialFuture started (and completed)
[18:00:57.276] - Launch lazy future ... done
[18:00:57.276] run() for ‘SequentialFuture’ ... done
[18:00:57.276] Created future:
[18:00:57.277] SequentialFuture:
[18:00:57.277] Label: ‘future_mapply-1’
[18:00:57.277] Expression:
[18:00:57.277] {
[18:00:57.277]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.277]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.277]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.277]         on.exit(options(oopts), add = TRUE)
[18:00:57.277]     }
[18:00:57.277]     {
[18:00:57.277]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.277]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.277]         do.call(mapply, args = args)
[18:00:57.277]     }
[18:00:57.277] }
[18:00:57.277] Lazy evaluation: FALSE
[18:00:57.277] Asynchronous evaluation: FALSE
[18:00:57.277] Local evaluation: TRUE
[18:00:57.277] Environment: R_GlobalEnv
[18:00:57.277] Capture standard output: TRUE
[18:00:57.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.277] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.277] Packages: <none>
[18:00:57.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.277] Resolved: TRUE
[18:00:57.277] Value: 240 bytes of class ‘list’
[18:00:57.277] Early signaling: FALSE
[18:00:57.277] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.277] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.279] Chunk #1 of 1 ... DONE
[18:00:57.279] Launching 1 futures (chunks) ... DONE
[18:00:57.279] Resolving 1 futures (chunks) ...
[18:00:57.279] resolve() on list ...
[18:00:57.280]  recursive: 0
[18:00:57.280]  length: 1
[18:00:57.280] 
[18:00:57.280] resolved() for ‘SequentialFuture’ ...
[18:00:57.280] - state: ‘finished’
[18:00:57.281] - run: TRUE
[18:00:57.281] - result: ‘FutureResult’
[18:00:57.281] resolved() for ‘SequentialFuture’ ... done
[18:00:57.281] Future #1
[18:00:57.281] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.282] - nx: 1
[18:00:57.282] - relay: TRUE
[18:00:57.282] - stdout: TRUE
[18:00:57.282] - signal: TRUE
[18:00:57.282] - resignal: FALSE
[18:00:57.283] - force: TRUE
[18:00:57.283] - relayed: [n=1] FALSE
[18:00:57.283] - queued futures: [n=1] FALSE
[18:00:57.283]  - until=1
[18:00:57.283]  - relaying element #1
[18:00:57.284] - relayed: [n=1] TRUE
[18:00:57.284] - queued futures: [n=1] TRUE
[18:00:57.284] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.284]  length: 0 (resolved future 1)
[18:00:57.285] Relaying remaining futures
[18:00:57.285] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.285] - nx: 1
[18:00:57.285] - relay: TRUE
[18:00:57.285] - stdout: TRUE
[18:00:57.286] - signal: TRUE
[18:00:57.286] - resignal: FALSE
[18:00:57.286] - force: TRUE
[18:00:57.286] - relayed: [n=1] TRUE
[18:00:57.286] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.287] - relayed: [n=1] TRUE
[18:00:57.287] - queued futures: [n=1] TRUE
[18:00:57.287] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.287] resolve() on list ... DONE
[18:00:57.287]  - Number of value chunks collected: 1
[18:00:57.288] Resolving 1 futures (chunks) ... DONE
[18:00:57.288] Reducing values from 1 chunks ...
[18:00:57.288]  - Number of values collected after concatenation: 4
[18:00:57.288]  - Number of values expected: 4
[18:00:57.288] Reducing values from 1 chunks ... DONE
[18:00:57.289] future_mapply() ... DONE
[18:00:57.289] future_mapply() ...
[18:00:57.289] Number of chunks: 1
[18:00:57.289] getGlobalsAndPackagesXApply() ...
[18:00:57.290]  - future.globals: TRUE
[18:00:57.290] getGlobalsAndPackages() ...
[18:00:57.290] Searching for globals...
[18:00:57.291] - globals found: [1] ‘FUN’
[18:00:57.292] Searching for globals ... DONE
[18:00:57.292] Resolving globals: FALSE
[18:00:57.292] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:57.293] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:57.293] - globals: [1] ‘FUN’
[18:00:57.294] 
[18:00:57.294] getGlobalsAndPackages() ... DONE
[18:00:57.294]  - globals found/used: [n=1] ‘FUN’
[18:00:57.294]  - needed namespaces: [n=0] 
[18:00:57.294] Finding globals ... DONE
[18:00:57.295] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.295] List of 2
[18:00:57.295]  $ ...future.FUN:function (x, ...)  
[18:00:57.295]  $ MoreArgs     : NULL
[18:00:57.295]  - attr(*, "where")=List of 2
[18:00:57.295]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.295]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.295]  - attr(*, "resolved")= logi FALSE
[18:00:57.295]  - attr(*, "total_size")= num NA
[18:00:57.300] Packages to be attached in all futures: [n=0] 
[18:00:57.301] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.301] Number of futures (= number of chunks): 1
[18:00:57.301] Launching 1 futures (chunks) ...
[18:00:57.302] Chunk #1 of 1 ...
[18:00:57.302]  - Finding globals in '...' for chunk #1 ...
[18:00:57.302] getGlobalsAndPackages() ...
[18:00:57.302] Searching for globals...
[18:00:57.303] 
[18:00:57.303] Searching for globals ... DONE
[18:00:57.303] - globals: [0] <none>
[18:00:57.304] getGlobalsAndPackages() ... DONE
[18:00:57.304]    + additional globals found: [n=0] 
[18:00:57.304]    + additional namespaces needed: [n=0] 
[18:00:57.304]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.304]  - seeds: <none>
[18:00:57.304]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.305] getGlobalsAndPackages() ...
[18:00:57.305] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.305] Resolving globals: FALSE
[18:00:57.309] The total size of the 5 globals is 504 bytes (504 bytes)
[18:00:57.310] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.310] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.310] 
[18:00:57.310] getGlobalsAndPackages() ... DONE
[18:00:57.311] run() for ‘Future’ ...
[18:00:57.311] - state: ‘created’
[18:00:57.311] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.312] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.312]   - Field: ‘label’
[18:00:57.312]   - Field: ‘local’
[18:00:57.313]   - Field: ‘owner’
[18:00:57.313]   - Field: ‘envir’
[18:00:57.313]   - Field: ‘packages’
[18:00:57.313]   - Field: ‘gc’
[18:00:57.313]   - Field: ‘conditions’
[18:00:57.314]   - Field: ‘expr’
[18:00:57.314]   - Field: ‘uuid’
[18:00:57.314]   - Field: ‘seed’
[18:00:57.314]   - Field: ‘version’
[18:00:57.314]   - Field: ‘result’
[18:00:57.315]   - Field: ‘asynchronous’
[18:00:57.315]   - Field: ‘calls’
[18:00:57.315]   - Field: ‘globals’
[18:00:57.315]   - Field: ‘stdout’
[18:00:57.315]   - Field: ‘earlySignal’
[18:00:57.316]   - Field: ‘lazy’
[18:00:57.316]   - Field: ‘state’
[18:00:57.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.316] - Launch lazy future ...
[18:00:57.316] Packages needed by the future expression (n = 0): <none>
[18:00:57.317] Packages needed by future strategies (n = 0): <none>
[18:00:57.318] {
[18:00:57.318]     {
[18:00:57.318]         {
[18:00:57.318]             ...future.startTime <- base::Sys.time()
[18:00:57.318]             {
[18:00:57.318]                 {
[18:00:57.318]                   {
[18:00:57.318]                     base::local({
[18:00:57.318]                       has_future <- base::requireNamespace("future", 
[18:00:57.318]                         quietly = TRUE)
[18:00:57.318]                       if (has_future) {
[18:00:57.318]                         ns <- base::getNamespace("future")
[18:00:57.318]                         version <- ns[[".package"]][["version"]]
[18:00:57.318]                         if (is.null(version)) 
[18:00:57.318]                           version <- utils::packageVersion("future")
[18:00:57.318]                       }
[18:00:57.318]                       else {
[18:00:57.318]                         version <- NULL
[18:00:57.318]                       }
[18:00:57.318]                       if (!has_future || version < "1.8.0") {
[18:00:57.318]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.318]                           "", base::R.version$version.string), 
[18:00:57.318]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.318]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.318]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.318]                             "release", "version")], collapse = " "), 
[18:00:57.318]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.318]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.318]                           info)
[18:00:57.318]                         info <- base::paste(info, collapse = "; ")
[18:00:57.318]                         if (!has_future) {
[18:00:57.318]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.318]                             info)
[18:00:57.318]                         }
[18:00:57.318]                         else {
[18:00:57.318]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.318]                             info, version)
[18:00:57.318]                         }
[18:00:57.318]                         base::stop(msg)
[18:00:57.318]                       }
[18:00:57.318]                     })
[18:00:57.318]                   }
[18:00:57.318]                   ...future.strategy.old <- future::plan("list")
[18:00:57.318]                   options(future.plan = NULL)
[18:00:57.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.318]                 }
[18:00:57.318]                 ...future.workdir <- getwd()
[18:00:57.318]             }
[18:00:57.318]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.318]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.318]         }
[18:00:57.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.318]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.318]             base::names(...future.oldOptions))
[18:00:57.318]     }
[18:00:57.318]     if (FALSE) {
[18:00:57.318]     }
[18:00:57.318]     else {
[18:00:57.318]         if (TRUE) {
[18:00:57.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.318]                 open = "w")
[18:00:57.318]         }
[18:00:57.318]         else {
[18:00:57.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.318]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.318]         }
[18:00:57.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.318]             base::sink(type = "output", split = FALSE)
[18:00:57.318]             base::close(...future.stdout)
[18:00:57.318]         }, add = TRUE)
[18:00:57.318]     }
[18:00:57.318]     ...future.frame <- base::sys.nframe()
[18:00:57.318]     ...future.conditions <- base::list()
[18:00:57.318]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.318]     if (FALSE) {
[18:00:57.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.318]     }
[18:00:57.318]     ...future.result <- base::tryCatch({
[18:00:57.318]         base::withCallingHandlers({
[18:00:57.318]             ...future.value <- base::withVisible(base::local({
[18:00:57.318]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.318]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.318]                   ...future.globals.maxSize)) {
[18:00:57.318]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.318]                   on.exit(options(oopts), add = TRUE)
[18:00:57.318]                 }
[18:00:57.318]                 {
[18:00:57.318]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.318]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.318]                     USE.NAMES = FALSE)
[18:00:57.318]                   do.call(mapply, args = args)
[18:00:57.318]                 }
[18:00:57.318]             }))
[18:00:57.318]             future::FutureResult(value = ...future.value$value, 
[18:00:57.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.318]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.318]                     ...future.globalenv.names))
[18:00:57.318]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.318]         }, condition = base::local({
[18:00:57.318]             c <- base::c
[18:00:57.318]             inherits <- base::inherits
[18:00:57.318]             invokeRestart <- base::invokeRestart
[18:00:57.318]             length <- base::length
[18:00:57.318]             list <- base::list
[18:00:57.318]             seq.int <- base::seq.int
[18:00:57.318]             signalCondition <- base::signalCondition
[18:00:57.318]             sys.calls <- base::sys.calls
[18:00:57.318]             `[[` <- base::`[[`
[18:00:57.318]             `+` <- base::`+`
[18:00:57.318]             `<<-` <- base::`<<-`
[18:00:57.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.318]                   3L)]
[18:00:57.318]             }
[18:00:57.318]             function(cond) {
[18:00:57.318]                 is_error <- inherits(cond, "error")
[18:00:57.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.318]                   NULL)
[18:00:57.318]                 if (is_error) {
[18:00:57.318]                   sessionInformation <- function() {
[18:00:57.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.318]                       search = base::search(), system = base::Sys.info())
[18:00:57.318]                   }
[18:00:57.318]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.318]                     cond$call), session = sessionInformation(), 
[18:00:57.318]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.318]                   signalCondition(cond)
[18:00:57.318]                 }
[18:00:57.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.318]                 "immediateCondition"))) {
[18:00:57.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.318]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.318]                   if (TRUE && !signal) {
[18:00:57.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.318]                     {
[18:00:57.318]                       inherits <- base::inherits
[18:00:57.318]                       invokeRestart <- base::invokeRestart
[18:00:57.318]                       is.null <- base::is.null
[18:00:57.318]                       muffled <- FALSE
[18:00:57.318]                       if (inherits(cond, "message")) {
[18:00:57.318]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.318]                         if (muffled) 
[18:00:57.318]                           invokeRestart("muffleMessage")
[18:00:57.318]                       }
[18:00:57.318]                       else if (inherits(cond, "warning")) {
[18:00:57.318]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.318]                         if (muffled) 
[18:00:57.318]                           invokeRestart("muffleWarning")
[18:00:57.318]                       }
[18:00:57.318]                       else if (inherits(cond, "condition")) {
[18:00:57.318]                         if (!is.null(pattern)) {
[18:00:57.318]                           computeRestarts <- base::computeRestarts
[18:00:57.318]                           grepl <- base::grepl
[18:00:57.318]                           restarts <- computeRestarts(cond)
[18:00:57.318]                           for (restart in restarts) {
[18:00:57.318]                             name <- restart$name
[18:00:57.318]                             if (is.null(name)) 
[18:00:57.318]                               next
[18:00:57.318]                             if (!grepl(pattern, name)) 
[18:00:57.318]                               next
[18:00:57.318]                             invokeRestart(restart)
[18:00:57.318]                             muffled <- TRUE
[18:00:57.318]                             break
[18:00:57.318]                           }
[18:00:57.318]                         }
[18:00:57.318]                       }
[18:00:57.318]                       invisible(muffled)
[18:00:57.318]                     }
[18:00:57.318]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.318]                   }
[18:00:57.318]                 }
[18:00:57.318]                 else {
[18:00:57.318]                   if (TRUE) {
[18:00:57.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.318]                     {
[18:00:57.318]                       inherits <- base::inherits
[18:00:57.318]                       invokeRestart <- base::invokeRestart
[18:00:57.318]                       is.null <- base::is.null
[18:00:57.318]                       muffled <- FALSE
[18:00:57.318]                       if (inherits(cond, "message")) {
[18:00:57.318]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.318]                         if (muffled) 
[18:00:57.318]                           invokeRestart("muffleMessage")
[18:00:57.318]                       }
[18:00:57.318]                       else if (inherits(cond, "warning")) {
[18:00:57.318]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.318]                         if (muffled) 
[18:00:57.318]                           invokeRestart("muffleWarning")
[18:00:57.318]                       }
[18:00:57.318]                       else if (inherits(cond, "condition")) {
[18:00:57.318]                         if (!is.null(pattern)) {
[18:00:57.318]                           computeRestarts <- base::computeRestarts
[18:00:57.318]                           grepl <- base::grepl
[18:00:57.318]                           restarts <- computeRestarts(cond)
[18:00:57.318]                           for (restart in restarts) {
[18:00:57.318]                             name <- restart$name
[18:00:57.318]                             if (is.null(name)) 
[18:00:57.318]                               next
[18:00:57.318]                             if (!grepl(pattern, name)) 
[18:00:57.318]                               next
[18:00:57.318]                             invokeRestart(restart)
[18:00:57.318]                             muffled <- TRUE
[18:00:57.318]                             break
[18:00:57.318]                           }
[18:00:57.318]                         }
[18:00:57.318]                       }
[18:00:57.318]                       invisible(muffled)
[18:00:57.318]                     }
[18:00:57.318]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.318]                   }
[18:00:57.318]                 }
[18:00:57.318]             }
[18:00:57.318]         }))
[18:00:57.318]     }, error = function(ex) {
[18:00:57.318]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.318]                 ...future.rng), started = ...future.startTime, 
[18:00:57.318]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.318]             version = "1.8"), class = "FutureResult")
[18:00:57.318]     }, finally = {
[18:00:57.318]         if (!identical(...future.workdir, getwd())) 
[18:00:57.318]             setwd(...future.workdir)
[18:00:57.318]         {
[18:00:57.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.318]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.318]             }
[18:00:57.318]             base::options(...future.oldOptions)
[18:00:57.318]             if (.Platform$OS.type == "windows") {
[18:00:57.318]                 old_names <- names(...future.oldEnvVars)
[18:00:57.318]                 envs <- base::Sys.getenv()
[18:00:57.318]                 names <- names(envs)
[18:00:57.318]                 common <- intersect(names, old_names)
[18:00:57.318]                 added <- setdiff(names, old_names)
[18:00:57.318]                 removed <- setdiff(old_names, names)
[18:00:57.318]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.318]                   envs[common]]
[18:00:57.318]                 NAMES <- toupper(changed)
[18:00:57.318]                 args <- list()
[18:00:57.318]                 for (kk in seq_along(NAMES)) {
[18:00:57.318]                   name <- changed[[kk]]
[18:00:57.318]                   NAME <- NAMES[[kk]]
[18:00:57.318]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.318]                     next
[18:00:57.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.318]                 }
[18:00:57.318]                 NAMES <- toupper(added)
[18:00:57.318]                 for (kk in seq_along(NAMES)) {
[18:00:57.318]                   name <- added[[kk]]
[18:00:57.318]                   NAME <- NAMES[[kk]]
[18:00:57.318]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.318]                     next
[18:00:57.318]                   args[[name]] <- ""
[18:00:57.318]                 }
[18:00:57.318]                 NAMES <- toupper(removed)
[18:00:57.318]                 for (kk in seq_along(NAMES)) {
[18:00:57.318]                   name <- removed[[kk]]
[18:00:57.318]                   NAME <- NAMES[[kk]]
[18:00:57.318]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.318]                     next
[18:00:57.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.318]                 }
[18:00:57.318]                 if (length(args) > 0) 
[18:00:57.318]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.318]             }
[18:00:57.318]             else {
[18:00:57.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.318]             }
[18:00:57.318]             {
[18:00:57.318]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.318]                   0L) {
[18:00:57.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.318]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.318]                   base::options(opts)
[18:00:57.318]                 }
[18:00:57.318]                 {
[18:00:57.318]                   {
[18:00:57.318]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.318]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.318]                     1423455687L), envir = base::globalenv(), 
[18:00:57.318]                       inherits = FALSE)
[18:00:57.318]                     NULL
[18:00:57.318]                   }
[18:00:57.318]                   options(future.plan = NULL)
[18:00:57.318]                   if (is.na(NA_character_)) 
[18:00:57.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.318]                     .init = FALSE)
[18:00:57.318]                 }
[18:00:57.318]             }
[18:00:57.318]         }
[18:00:57.318]     })
[18:00:57.318]     if (TRUE) {
[18:00:57.318]         base::sink(type = "output", split = FALSE)
[18:00:57.318]         if (TRUE) {
[18:00:57.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.318]         }
[18:00:57.318]         else {
[18:00:57.318]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.318]         }
[18:00:57.318]         base::close(...future.stdout)
[18:00:57.318]         ...future.stdout <- NULL
[18:00:57.318]     }
[18:00:57.318]     ...future.result$conditions <- ...future.conditions
[18:00:57.318]     ...future.result$finished <- base::Sys.time()
[18:00:57.318]     ...future.result
[18:00:57.318] }
[18:00:57.321] assign_globals() ...
[18:00:57.321] List of 5
[18:00:57.321]  $ ...future.FUN            :function (x, ...)  
[18:00:57.321]  $ MoreArgs                 : NULL
[18:00:57.321]  $ ...future.elements_ii    :List of 2
[18:00:57.321]   ..$ :List of 4
[18:00:57.321]   .. ..$ : int 1
[18:00:57.321]   .. ..$ : int 2
[18:00:57.321]   .. ..$ : int 3
[18:00:57.321]   .. ..$ : int 4
[18:00:57.321]   ..$ :List of 4
[18:00:57.321]   .. ..$ : int 4
[18:00:57.321]   .. ..$ : int 3
[18:00:57.321]   .. ..$ : int 2
[18:00:57.321]   .. ..$ : int 1
[18:00:57.321]  $ ...future.seeds_ii       : NULL
[18:00:57.321]  $ ...future.globals.maxSize: NULL
[18:00:57.321]  - attr(*, "where")=List of 5
[18:00:57.321]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.321]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.321]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.321]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.321]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.321]  - attr(*, "resolved")= logi FALSE
[18:00:57.321]  - attr(*, "total_size")= num 504
[18:00:57.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.321]  - attr(*, "already-done")= logi TRUE
[18:00:57.334] - copied ‘...future.FUN’ to environment
[18:00:57.335] - copied ‘MoreArgs’ to environment
[18:00:57.335] - copied ‘...future.elements_ii’ to environment
[18:00:57.335] - copied ‘...future.seeds_ii’ to environment
[18:00:57.335] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.335] assign_globals() ... done
[18:00:57.336] plan(): Setting new future strategy stack:
[18:00:57.336] List of future strategies:
[18:00:57.336] 1. sequential:
[18:00:57.336]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.336]    - tweaked: FALSE
[18:00:57.336]    - call: NULL
[18:00:57.337] plan(): nbrOfWorkers() = 1
[18:00:57.338] plan(): Setting new future strategy stack:
[18:00:57.339] List of future strategies:
[18:00:57.339] 1. sequential:
[18:00:57.339]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.339]    - tweaked: FALSE
[18:00:57.339]    - call: plan(strategy)
[18:00:57.339] plan(): nbrOfWorkers() = 1
[18:00:57.340] SequentialFuture started (and completed)
[18:00:57.340] - Launch lazy future ... done
[18:00:57.341] run() for ‘SequentialFuture’ ... done
[18:00:57.342] Created future:
[18:00:57.342] SequentialFuture:
[18:00:57.342] Label: ‘future_mapply-1’
[18:00:57.342] Expression:
[18:00:57.342] {
[18:00:57.342]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.342]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.342]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.342]         on.exit(options(oopts), add = TRUE)
[18:00:57.342]     }
[18:00:57.342]     {
[18:00:57.342]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.342]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.342]         do.call(mapply, args = args)
[18:00:57.342]     }
[18:00:57.342] }
[18:00:57.342] Lazy evaluation: FALSE
[18:00:57.342] Asynchronous evaluation: FALSE
[18:00:57.342] Local evaluation: TRUE
[18:00:57.342] Environment: R_GlobalEnv
[18:00:57.342] Capture standard output: TRUE
[18:00:57.342] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.342] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.342] Packages: <none>
[18:00:57.342] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.342] Resolved: TRUE
[18:00:57.342] Value: 240 bytes of class ‘list’
[18:00:57.342] Early signaling: FALSE
[18:00:57.342] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.342] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.344] Chunk #1 of 1 ... DONE
[18:00:57.344] Launching 1 futures (chunks) ... DONE
[18:00:57.345] Resolving 1 futures (chunks) ...
[18:00:57.346] resolve() on list ...
[18:00:57.347]  recursive: 0
[18:00:57.347]  length: 1
[18:00:57.347] 
[18:00:57.347] resolved() for ‘SequentialFuture’ ...
[18:00:57.347] - state: ‘finished’
[18:00:57.348] - run: TRUE
[18:00:57.348] - result: ‘FutureResult’
[18:00:57.349] resolved() for ‘SequentialFuture’ ... done
[18:00:57.349] Future #1
[18:00:57.349] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.349] - nx: 1
[18:00:57.350] - relay: TRUE
[18:00:57.350] - stdout: TRUE
[18:00:57.350] - signal: TRUE
[18:00:57.350] - resignal: FALSE
[18:00:57.350] - force: TRUE
[18:00:57.350] - relayed: [n=1] FALSE
[18:00:57.351] - queued futures: [n=1] FALSE
[18:00:57.351]  - until=1
[18:00:57.351]  - relaying element #1
[18:00:57.351] - relayed: [n=1] TRUE
[18:00:57.352] - queued futures: [n=1] TRUE
[18:00:57.352] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.352]  length: 0 (resolved future 1)
[18:00:57.352] Relaying remaining futures
[18:00:57.352] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.353] - nx: 1
[18:00:57.353] - relay: TRUE
[18:00:57.353] - stdout: TRUE
[18:00:57.353] - signal: TRUE
[18:00:57.353] - resignal: FALSE
[18:00:57.353] - force: TRUE
[18:00:57.354] - relayed: [n=1] TRUE
[18:00:57.354] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.354] - relayed: [n=1] TRUE
[18:00:57.354] - queued futures: [n=1] TRUE
[18:00:57.354] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.355] resolve() on list ... DONE
[18:00:57.355]  - Number of value chunks collected: 1
[18:00:57.355] Resolving 1 futures (chunks) ... DONE
[18:00:57.355] Reducing values from 1 chunks ...
[18:00:57.356]  - Number of values collected after concatenation: 4
[18:00:57.356]  - Number of values expected: 4
[18:00:57.356] Reducing values from 1 chunks ... DONE
[18:00:57.356] future_mapply() ... DONE
[18:00:57.356] future_mapply() ...
[18:00:57.357] Number of chunks: 1
[18:00:57.357] getGlobalsAndPackagesXApply() ...
[18:00:57.357]  - future.globals: TRUE
[18:00:57.357] getGlobalsAndPackages() ...
[18:00:57.357] Searching for globals...
[18:00:57.359] - globals found: [1] ‘FUN’
[18:00:57.359] Searching for globals ... DONE
[18:00:57.359] Resolving globals: FALSE
[18:00:57.360] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:57.360] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:57.361] - globals: [1] ‘FUN’
[18:00:57.361] 
[18:00:57.361] getGlobalsAndPackages() ... DONE
[18:00:57.361]  - globals found/used: [n=1] ‘FUN’
[18:00:57.361]  - needed namespaces: [n=0] 
[18:00:57.362] Finding globals ... DONE
[18:00:57.362] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.362] List of 2
[18:00:57.362]  $ ...future.FUN:function (x, ...)  
[18:00:57.362]  $ MoreArgs     : NULL
[18:00:57.362]  - attr(*, "where")=List of 2
[18:00:57.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.362]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.362]  - attr(*, "resolved")= logi FALSE
[18:00:57.362]  - attr(*, "total_size")= num NA
[18:00:57.369] Packages to be attached in all futures: [n=0] 
[18:00:57.370] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.370] Number of futures (= number of chunks): 1
[18:00:57.370] Launching 1 futures (chunks) ...
[18:00:57.370] Chunk #1 of 1 ...
[18:00:57.371]  - Finding globals in '...' for chunk #1 ...
[18:00:57.371] getGlobalsAndPackages() ...
[18:00:57.371] Searching for globals...
[18:00:57.372] 
[18:00:57.372] Searching for globals ... DONE
[18:00:57.372] - globals: [0] <none>
[18:00:57.373] getGlobalsAndPackages() ... DONE
[18:00:57.373]    + additional globals found: [n=0] 
[18:00:57.373]    + additional namespaces needed: [n=0] 
[18:00:57.373]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.374]  - seeds: <none>
[18:00:57.374]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.375] getGlobalsAndPackages() ...
[18:00:57.375] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.375] Resolving globals: FALSE
[18:00:57.376] The total size of the 5 globals is 504 bytes (504 bytes)
[18:00:57.377] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.377] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.378] 
[18:00:57.378] getGlobalsAndPackages() ... DONE
[18:00:57.378] run() for ‘Future’ ...
[18:00:57.379] - state: ‘created’
[18:00:57.379] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.380]   - Field: ‘label’
[18:00:57.380]   - Field: ‘local’
[18:00:57.380]   - Field: ‘owner’
[18:00:57.381]   - Field: ‘envir’
[18:00:57.381]   - Field: ‘packages’
[18:00:57.381]   - Field: ‘gc’
[18:00:57.381]   - Field: ‘conditions’
[18:00:57.381]   - Field: ‘expr’
[18:00:57.382]   - Field: ‘uuid’
[18:00:57.382]   - Field: ‘seed’
[18:00:57.382]   - Field: ‘version’
[18:00:57.382]   - Field: ‘result’
[18:00:57.382]   - Field: ‘asynchronous’
[18:00:57.383]   - Field: ‘calls’
[18:00:57.383]   - Field: ‘globals’
[18:00:57.383]   - Field: ‘stdout’
[18:00:57.383]   - Field: ‘earlySignal’
[18:00:57.383]   - Field: ‘lazy’
[18:00:57.383]   - Field: ‘state’
[18:00:57.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.384] - Launch lazy future ...
[18:00:57.384] Packages needed by the future expression (n = 0): <none>
[18:00:57.384] Packages needed by future strategies (n = 0): <none>
[18:00:57.385] {
[18:00:57.385]     {
[18:00:57.385]         {
[18:00:57.385]             ...future.startTime <- base::Sys.time()
[18:00:57.385]             {
[18:00:57.385]                 {
[18:00:57.385]                   {
[18:00:57.385]                     base::local({
[18:00:57.385]                       has_future <- base::requireNamespace("future", 
[18:00:57.385]                         quietly = TRUE)
[18:00:57.385]                       if (has_future) {
[18:00:57.385]                         ns <- base::getNamespace("future")
[18:00:57.385]                         version <- ns[[".package"]][["version"]]
[18:00:57.385]                         if (is.null(version)) 
[18:00:57.385]                           version <- utils::packageVersion("future")
[18:00:57.385]                       }
[18:00:57.385]                       else {
[18:00:57.385]                         version <- NULL
[18:00:57.385]                       }
[18:00:57.385]                       if (!has_future || version < "1.8.0") {
[18:00:57.385]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.385]                           "", base::R.version$version.string), 
[18:00:57.385]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.385]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.385]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.385]                             "release", "version")], collapse = " "), 
[18:00:57.385]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.385]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.385]                           info)
[18:00:57.385]                         info <- base::paste(info, collapse = "; ")
[18:00:57.385]                         if (!has_future) {
[18:00:57.385]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.385]                             info)
[18:00:57.385]                         }
[18:00:57.385]                         else {
[18:00:57.385]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.385]                             info, version)
[18:00:57.385]                         }
[18:00:57.385]                         base::stop(msg)
[18:00:57.385]                       }
[18:00:57.385]                     })
[18:00:57.385]                   }
[18:00:57.385]                   ...future.strategy.old <- future::plan("list")
[18:00:57.385]                   options(future.plan = NULL)
[18:00:57.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.385]                 }
[18:00:57.385]                 ...future.workdir <- getwd()
[18:00:57.385]             }
[18:00:57.385]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.385]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.385]         }
[18:00:57.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.385]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.385]             base::names(...future.oldOptions))
[18:00:57.385]     }
[18:00:57.385]     if (FALSE) {
[18:00:57.385]     }
[18:00:57.385]     else {
[18:00:57.385]         if (TRUE) {
[18:00:57.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.385]                 open = "w")
[18:00:57.385]         }
[18:00:57.385]         else {
[18:00:57.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.385]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.385]         }
[18:00:57.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.385]             base::sink(type = "output", split = FALSE)
[18:00:57.385]             base::close(...future.stdout)
[18:00:57.385]         }, add = TRUE)
[18:00:57.385]     }
[18:00:57.385]     ...future.frame <- base::sys.nframe()
[18:00:57.385]     ...future.conditions <- base::list()
[18:00:57.385]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.385]     if (FALSE) {
[18:00:57.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.385]     }
[18:00:57.385]     ...future.result <- base::tryCatch({
[18:00:57.385]         base::withCallingHandlers({
[18:00:57.385]             ...future.value <- base::withVisible(base::local({
[18:00:57.385]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.385]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.385]                   ...future.globals.maxSize)) {
[18:00:57.385]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.385]                   on.exit(options(oopts), add = TRUE)
[18:00:57.385]                 }
[18:00:57.385]                 {
[18:00:57.385]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.385]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.385]                     USE.NAMES = FALSE)
[18:00:57.385]                   do.call(mapply, args = args)
[18:00:57.385]                 }
[18:00:57.385]             }))
[18:00:57.385]             future::FutureResult(value = ...future.value$value, 
[18:00:57.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.385]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.385]                     ...future.globalenv.names))
[18:00:57.385]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.385]         }, condition = base::local({
[18:00:57.385]             c <- base::c
[18:00:57.385]             inherits <- base::inherits
[18:00:57.385]             invokeRestart <- base::invokeRestart
[18:00:57.385]             length <- base::length
[18:00:57.385]             list <- base::list
[18:00:57.385]             seq.int <- base::seq.int
[18:00:57.385]             signalCondition <- base::signalCondition
[18:00:57.385]             sys.calls <- base::sys.calls
[18:00:57.385]             `[[` <- base::`[[`
[18:00:57.385]             `+` <- base::`+`
[18:00:57.385]             `<<-` <- base::`<<-`
[18:00:57.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.385]                   3L)]
[18:00:57.385]             }
[18:00:57.385]             function(cond) {
[18:00:57.385]                 is_error <- inherits(cond, "error")
[18:00:57.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.385]                   NULL)
[18:00:57.385]                 if (is_error) {
[18:00:57.385]                   sessionInformation <- function() {
[18:00:57.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.385]                       search = base::search(), system = base::Sys.info())
[18:00:57.385]                   }
[18:00:57.385]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.385]                     cond$call), session = sessionInformation(), 
[18:00:57.385]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.385]                   signalCondition(cond)
[18:00:57.385]                 }
[18:00:57.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.385]                 "immediateCondition"))) {
[18:00:57.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.385]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.385]                   if (TRUE && !signal) {
[18:00:57.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.385]                     {
[18:00:57.385]                       inherits <- base::inherits
[18:00:57.385]                       invokeRestart <- base::invokeRestart
[18:00:57.385]                       is.null <- base::is.null
[18:00:57.385]                       muffled <- FALSE
[18:00:57.385]                       if (inherits(cond, "message")) {
[18:00:57.385]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.385]                         if (muffled) 
[18:00:57.385]                           invokeRestart("muffleMessage")
[18:00:57.385]                       }
[18:00:57.385]                       else if (inherits(cond, "warning")) {
[18:00:57.385]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.385]                         if (muffled) 
[18:00:57.385]                           invokeRestart("muffleWarning")
[18:00:57.385]                       }
[18:00:57.385]                       else if (inherits(cond, "condition")) {
[18:00:57.385]                         if (!is.null(pattern)) {
[18:00:57.385]                           computeRestarts <- base::computeRestarts
[18:00:57.385]                           grepl <- base::grepl
[18:00:57.385]                           restarts <- computeRestarts(cond)
[18:00:57.385]                           for (restart in restarts) {
[18:00:57.385]                             name <- restart$name
[18:00:57.385]                             if (is.null(name)) 
[18:00:57.385]                               next
[18:00:57.385]                             if (!grepl(pattern, name)) 
[18:00:57.385]                               next
[18:00:57.385]                             invokeRestart(restart)
[18:00:57.385]                             muffled <- TRUE
[18:00:57.385]                             break
[18:00:57.385]                           }
[18:00:57.385]                         }
[18:00:57.385]                       }
[18:00:57.385]                       invisible(muffled)
[18:00:57.385]                     }
[18:00:57.385]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.385]                   }
[18:00:57.385]                 }
[18:00:57.385]                 else {
[18:00:57.385]                   if (TRUE) {
[18:00:57.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.385]                     {
[18:00:57.385]                       inherits <- base::inherits
[18:00:57.385]                       invokeRestart <- base::invokeRestart
[18:00:57.385]                       is.null <- base::is.null
[18:00:57.385]                       muffled <- FALSE
[18:00:57.385]                       if (inherits(cond, "message")) {
[18:00:57.385]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.385]                         if (muffled) 
[18:00:57.385]                           invokeRestart("muffleMessage")
[18:00:57.385]                       }
[18:00:57.385]                       else if (inherits(cond, "warning")) {
[18:00:57.385]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.385]                         if (muffled) 
[18:00:57.385]                           invokeRestart("muffleWarning")
[18:00:57.385]                       }
[18:00:57.385]                       else if (inherits(cond, "condition")) {
[18:00:57.385]                         if (!is.null(pattern)) {
[18:00:57.385]                           computeRestarts <- base::computeRestarts
[18:00:57.385]                           grepl <- base::grepl
[18:00:57.385]                           restarts <- computeRestarts(cond)
[18:00:57.385]                           for (restart in restarts) {
[18:00:57.385]                             name <- restart$name
[18:00:57.385]                             if (is.null(name)) 
[18:00:57.385]                               next
[18:00:57.385]                             if (!grepl(pattern, name)) 
[18:00:57.385]                               next
[18:00:57.385]                             invokeRestart(restart)
[18:00:57.385]                             muffled <- TRUE
[18:00:57.385]                             break
[18:00:57.385]                           }
[18:00:57.385]                         }
[18:00:57.385]                       }
[18:00:57.385]                       invisible(muffled)
[18:00:57.385]                     }
[18:00:57.385]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.385]                   }
[18:00:57.385]                 }
[18:00:57.385]             }
[18:00:57.385]         }))
[18:00:57.385]     }, error = function(ex) {
[18:00:57.385]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.385]                 ...future.rng), started = ...future.startTime, 
[18:00:57.385]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.385]             version = "1.8"), class = "FutureResult")
[18:00:57.385]     }, finally = {
[18:00:57.385]         if (!identical(...future.workdir, getwd())) 
[18:00:57.385]             setwd(...future.workdir)
[18:00:57.385]         {
[18:00:57.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.385]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.385]             }
[18:00:57.385]             base::options(...future.oldOptions)
[18:00:57.385]             if (.Platform$OS.type == "windows") {
[18:00:57.385]                 old_names <- names(...future.oldEnvVars)
[18:00:57.385]                 envs <- base::Sys.getenv()
[18:00:57.385]                 names <- names(envs)
[18:00:57.385]                 common <- intersect(names, old_names)
[18:00:57.385]                 added <- setdiff(names, old_names)
[18:00:57.385]                 removed <- setdiff(old_names, names)
[18:00:57.385]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.385]                   envs[common]]
[18:00:57.385]                 NAMES <- toupper(changed)
[18:00:57.385]                 args <- list()
[18:00:57.385]                 for (kk in seq_along(NAMES)) {
[18:00:57.385]                   name <- changed[[kk]]
[18:00:57.385]                   NAME <- NAMES[[kk]]
[18:00:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.385]                     next
[18:00:57.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.385]                 }
[18:00:57.385]                 NAMES <- toupper(added)
[18:00:57.385]                 for (kk in seq_along(NAMES)) {
[18:00:57.385]                   name <- added[[kk]]
[18:00:57.385]                   NAME <- NAMES[[kk]]
[18:00:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.385]                     next
[18:00:57.385]                   args[[name]] <- ""
[18:00:57.385]                 }
[18:00:57.385]                 NAMES <- toupper(removed)
[18:00:57.385]                 for (kk in seq_along(NAMES)) {
[18:00:57.385]                   name <- removed[[kk]]
[18:00:57.385]                   NAME <- NAMES[[kk]]
[18:00:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.385]                     next
[18:00:57.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.385]                 }
[18:00:57.385]                 if (length(args) > 0) 
[18:00:57.385]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.385]             }
[18:00:57.385]             else {
[18:00:57.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.385]             }
[18:00:57.385]             {
[18:00:57.385]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.385]                   0L) {
[18:00:57.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.385]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.385]                   base::options(opts)
[18:00:57.385]                 }
[18:00:57.385]                 {
[18:00:57.385]                   {
[18:00:57.385]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.385]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.385]                     1423455687L), envir = base::globalenv(), 
[18:00:57.385]                       inherits = FALSE)
[18:00:57.385]                     NULL
[18:00:57.385]                   }
[18:00:57.385]                   options(future.plan = NULL)
[18:00:57.385]                   if (is.na(NA_character_)) 
[18:00:57.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.385]                     .init = FALSE)
[18:00:57.385]                 }
[18:00:57.385]             }
[18:00:57.385]         }
[18:00:57.385]     })
[18:00:57.385]     if (TRUE) {
[18:00:57.385]         base::sink(type = "output", split = FALSE)
[18:00:57.385]         if (TRUE) {
[18:00:57.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.385]         }
[18:00:57.385]         else {
[18:00:57.385]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.385]         }
[18:00:57.385]         base::close(...future.stdout)
[18:00:57.385]         ...future.stdout <- NULL
[18:00:57.385]     }
[18:00:57.385]     ...future.result$conditions <- ...future.conditions
[18:00:57.385]     ...future.result$finished <- base::Sys.time()
[18:00:57.385]     ...future.result
[18:00:57.385] }
[18:00:57.389] assign_globals() ...
[18:00:57.389] List of 5
[18:00:57.389]  $ ...future.FUN            :function (x, ...)  
[18:00:57.389]  $ MoreArgs                 : NULL
[18:00:57.389]  $ ...future.elements_ii    :List of 2
[18:00:57.389]   ..$ times:List of 4
[18:00:57.389]   .. ..$ : int 1
[18:00:57.389]   .. ..$ : int 2
[18:00:57.389]   .. ..$ : int 3
[18:00:57.389]   .. ..$ : int 4
[18:00:57.389]   ..$ x    :List of 4
[18:00:57.389]   .. ..$ : int 4
[18:00:57.389]   .. ..$ : int 3
[18:00:57.389]   .. ..$ : int 2
[18:00:57.389]   .. ..$ : int 1
[18:00:57.389]  $ ...future.seeds_ii       : NULL
[18:00:57.389]  $ ...future.globals.maxSize: NULL
[18:00:57.389]  - attr(*, "where")=List of 5
[18:00:57.389]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.389]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.389]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.389]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.389]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.389]  - attr(*, "resolved")= logi FALSE
[18:00:57.389]  - attr(*, "total_size")= num 504
[18:00:57.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.389]  - attr(*, "already-done")= logi TRUE
[18:00:57.402] - copied ‘...future.FUN’ to environment
[18:00:57.402] - copied ‘MoreArgs’ to environment
[18:00:57.403] - copied ‘...future.elements_ii’ to environment
[18:00:57.403] - copied ‘...future.seeds_ii’ to environment
[18:00:57.403] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.403] assign_globals() ... done
[18:00:57.404] plan(): Setting new future strategy stack:
[18:00:57.404] List of future strategies:
[18:00:57.404] 1. sequential:
[18:00:57.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.404]    - tweaked: FALSE
[18:00:57.404]    - call: NULL
[18:00:57.405] plan(): nbrOfWorkers() = 1
[18:00:57.406] plan(): Setting new future strategy stack:
[18:00:57.407] List of future strategies:
[18:00:57.407] 1. sequential:
[18:00:57.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.407]    - tweaked: FALSE
[18:00:57.407]    - call: plan(strategy)
[18:00:57.408] plan(): nbrOfWorkers() = 1
[18:00:57.408] SequentialFuture started (and completed)
[18:00:57.408] - Launch lazy future ... done
[18:00:57.409] run() for ‘SequentialFuture’ ... done
[18:00:57.409] Created future:
[18:00:57.409] SequentialFuture:
[18:00:57.409] Label: ‘future_mapply-1’
[18:00:57.409] Expression:
[18:00:57.409] {
[18:00:57.409]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.409]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.409]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.409]         on.exit(options(oopts), add = TRUE)
[18:00:57.409]     }
[18:00:57.409]     {
[18:00:57.409]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.409]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.409]         do.call(mapply, args = args)
[18:00:57.409]     }
[18:00:57.409] }
[18:00:57.409] Lazy evaluation: FALSE
[18:00:57.409] Asynchronous evaluation: FALSE
[18:00:57.409] Local evaluation: TRUE
[18:00:57.409] Environment: R_GlobalEnv
[18:00:57.409] Capture standard output: TRUE
[18:00:57.409] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.409] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.409] Packages: <none>
[18:00:57.409] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.409] Resolved: TRUE
[18:00:57.409] Value: 240 bytes of class ‘list’
[18:00:57.409] Early signaling: FALSE
[18:00:57.409] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.409] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.411] Chunk #1 of 1 ... DONE
[18:00:57.411] Launching 1 futures (chunks) ... DONE
[18:00:57.411] Resolving 1 futures (chunks) ...
[18:00:57.411] resolve() on list ...
[18:00:57.412]  recursive: 0
[18:00:57.412]  length: 1
[18:00:57.412] 
[18:00:57.412] resolved() for ‘SequentialFuture’ ...
[18:00:57.412] - state: ‘finished’
[18:00:57.413] - run: TRUE
[18:00:57.413] - result: ‘FutureResult’
[18:00:57.413] resolved() for ‘SequentialFuture’ ... done
[18:00:57.413] Future #1
[18:00:57.413] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.414] - nx: 1
[18:00:57.414] - relay: TRUE
[18:00:57.414] - stdout: TRUE
[18:00:57.414] - signal: TRUE
[18:00:57.414] - resignal: FALSE
[18:00:57.415] - force: TRUE
[18:00:57.415] - relayed: [n=1] FALSE
[18:00:57.415] - queued futures: [n=1] FALSE
[18:00:57.415]  - until=1
[18:00:57.415]  - relaying element #1
[18:00:57.416] - relayed: [n=1] TRUE
[18:00:57.416] - queued futures: [n=1] TRUE
[18:00:57.416] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.416]  length: 0 (resolved future 1)
[18:00:57.416] Relaying remaining futures
[18:00:57.417] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.417] - nx: 1
[18:00:57.417] - relay: TRUE
[18:00:57.417] - stdout: TRUE
[18:00:57.417] - signal: TRUE
[18:00:57.417] - resignal: FALSE
[18:00:57.418] - force: TRUE
[18:00:57.418] - relayed: [n=1] TRUE
[18:00:57.418] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.418] - relayed: [n=1] TRUE
[18:00:57.418] - queued futures: [n=1] TRUE
[18:00:57.419] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.421] resolve() on list ... DONE
[18:00:57.422]  - Number of value chunks collected: 1
[18:00:57.422] Resolving 1 futures (chunks) ... DONE
[18:00:57.422] Reducing values from 1 chunks ...
[18:00:57.422]  - Number of values collected after concatenation: 4
[18:00:57.422]  - Number of values expected: 4
[18:00:57.422] Reducing values from 1 chunks ... DONE
[18:00:57.423] future_mapply() ... DONE
[18:00:57.423] future_mapply() ...
[18:00:57.423] Number of chunks: 1
[18:00:57.423] getGlobalsAndPackagesXApply() ...
[18:00:57.424]  - future.globals: TRUE
[18:00:57.424] getGlobalsAndPackages() ...
[18:00:57.424] Searching for globals...
[18:00:57.425] - globals found: [1] ‘FUN’
[18:00:57.425] Searching for globals ... DONE
[18:00:57.426] Resolving globals: FALSE
[18:00:57.426] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:57.427] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:57.427] - globals: [1] ‘FUN’
[18:00:57.427] 
[18:00:57.427] getGlobalsAndPackages() ... DONE
[18:00:57.428]  - globals found/used: [n=1] ‘FUN’
[18:00:57.428]  - needed namespaces: [n=0] 
[18:00:57.428] Finding globals ... DONE
[18:00:57.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.429] List of 2
[18:00:57.429]  $ ...future.FUN:function (x, ...)  
[18:00:57.429]  $ MoreArgs     :List of 1
[18:00:57.429]   ..$ x: num 42
[18:00:57.429]  - attr(*, "where")=List of 2
[18:00:57.429]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.429]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.429]  - attr(*, "resolved")= logi FALSE
[18:00:57.429]  - attr(*, "total_size")= num NA
[18:00:57.435] Packages to be attached in all futures: [n=0] 
[18:00:57.435] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.435] Number of futures (= number of chunks): 1
[18:00:57.435] Launching 1 futures (chunks) ...
[18:00:57.436] Chunk #1 of 1 ...
[18:00:57.436]  - Finding globals in '...' for chunk #1 ...
[18:00:57.436] getGlobalsAndPackages() ...
[18:00:57.436] Searching for globals...
[18:00:57.437] 
[18:00:57.437] Searching for globals ... DONE
[18:00:57.437] - globals: [0] <none>
[18:00:57.437] getGlobalsAndPackages() ... DONE
[18:00:57.438]    + additional globals found: [n=0] 
[18:00:57.438]    + additional namespaces needed: [n=0] 
[18:00:57.438]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.438]  - seeds: <none>
[18:00:57.438]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.439] getGlobalsAndPackages() ...
[18:00:57.439] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.439] Resolving globals: FALSE
[18:00:57.440] The total size of the 5 globals is 336 bytes (336 bytes)
[18:00:57.441] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:00:57.441] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.441] 
[18:00:57.442] getGlobalsAndPackages() ... DONE
[18:00:57.442] run() for ‘Future’ ...
[18:00:57.442] - state: ‘created’
[18:00:57.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.443] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.443]   - Field: ‘label’
[18:00:57.444]   - Field: ‘local’
[18:00:57.444]   - Field: ‘owner’
[18:00:57.444]   - Field: ‘envir’
[18:00:57.444]   - Field: ‘packages’
[18:00:57.444]   - Field: ‘gc’
[18:00:57.445]   - Field: ‘conditions’
[18:00:57.445]   - Field: ‘expr’
[18:00:57.445]   - Field: ‘uuid’
[18:00:57.445]   - Field: ‘seed’
[18:00:57.445]   - Field: ‘version’
[18:00:57.446]   - Field: ‘result’
[18:00:57.446]   - Field: ‘asynchronous’
[18:00:57.446]   - Field: ‘calls’
[18:00:57.446]   - Field: ‘globals’
[18:00:57.446]   - Field: ‘stdout’
[18:00:57.447]   - Field: ‘earlySignal’
[18:00:57.447]   - Field: ‘lazy’
[18:00:57.447]   - Field: ‘state’
[18:00:57.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.447] - Launch lazy future ...
[18:00:57.448] Packages needed by the future expression (n = 0): <none>
[18:00:57.448] Packages needed by future strategies (n = 0): <none>
[18:00:57.449] {
[18:00:57.449]     {
[18:00:57.449]         {
[18:00:57.449]             ...future.startTime <- base::Sys.time()
[18:00:57.449]             {
[18:00:57.449]                 {
[18:00:57.449]                   {
[18:00:57.449]                     base::local({
[18:00:57.449]                       has_future <- base::requireNamespace("future", 
[18:00:57.449]                         quietly = TRUE)
[18:00:57.449]                       if (has_future) {
[18:00:57.449]                         ns <- base::getNamespace("future")
[18:00:57.449]                         version <- ns[[".package"]][["version"]]
[18:00:57.449]                         if (is.null(version)) 
[18:00:57.449]                           version <- utils::packageVersion("future")
[18:00:57.449]                       }
[18:00:57.449]                       else {
[18:00:57.449]                         version <- NULL
[18:00:57.449]                       }
[18:00:57.449]                       if (!has_future || version < "1.8.0") {
[18:00:57.449]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.449]                           "", base::R.version$version.string), 
[18:00:57.449]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.449]                             "release", "version")], collapse = " "), 
[18:00:57.449]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.449]                           info)
[18:00:57.449]                         info <- base::paste(info, collapse = "; ")
[18:00:57.449]                         if (!has_future) {
[18:00:57.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.449]                             info)
[18:00:57.449]                         }
[18:00:57.449]                         else {
[18:00:57.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.449]                             info, version)
[18:00:57.449]                         }
[18:00:57.449]                         base::stop(msg)
[18:00:57.449]                       }
[18:00:57.449]                     })
[18:00:57.449]                   }
[18:00:57.449]                   ...future.strategy.old <- future::plan("list")
[18:00:57.449]                   options(future.plan = NULL)
[18:00:57.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.449]                 }
[18:00:57.449]                 ...future.workdir <- getwd()
[18:00:57.449]             }
[18:00:57.449]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.449]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.449]         }
[18:00:57.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.449]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.449]             base::names(...future.oldOptions))
[18:00:57.449]     }
[18:00:57.449]     if (FALSE) {
[18:00:57.449]     }
[18:00:57.449]     else {
[18:00:57.449]         if (TRUE) {
[18:00:57.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.449]                 open = "w")
[18:00:57.449]         }
[18:00:57.449]         else {
[18:00:57.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.449]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.449]         }
[18:00:57.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.449]             base::sink(type = "output", split = FALSE)
[18:00:57.449]             base::close(...future.stdout)
[18:00:57.449]         }, add = TRUE)
[18:00:57.449]     }
[18:00:57.449]     ...future.frame <- base::sys.nframe()
[18:00:57.449]     ...future.conditions <- base::list()
[18:00:57.449]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.449]     if (FALSE) {
[18:00:57.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.449]     }
[18:00:57.449]     ...future.result <- base::tryCatch({
[18:00:57.449]         base::withCallingHandlers({
[18:00:57.449]             ...future.value <- base::withVisible(base::local({
[18:00:57.449]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.449]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.449]                   ...future.globals.maxSize)) {
[18:00:57.449]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.449]                   on.exit(options(oopts), add = TRUE)
[18:00:57.449]                 }
[18:00:57.449]                 {
[18:00:57.449]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.449]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.449]                     USE.NAMES = FALSE)
[18:00:57.449]                   do.call(mapply, args = args)
[18:00:57.449]                 }
[18:00:57.449]             }))
[18:00:57.449]             future::FutureResult(value = ...future.value$value, 
[18:00:57.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.449]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.449]                     ...future.globalenv.names))
[18:00:57.449]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.449]         }, condition = base::local({
[18:00:57.449]             c <- base::c
[18:00:57.449]             inherits <- base::inherits
[18:00:57.449]             invokeRestart <- base::invokeRestart
[18:00:57.449]             length <- base::length
[18:00:57.449]             list <- base::list
[18:00:57.449]             seq.int <- base::seq.int
[18:00:57.449]             signalCondition <- base::signalCondition
[18:00:57.449]             sys.calls <- base::sys.calls
[18:00:57.449]             `[[` <- base::`[[`
[18:00:57.449]             `+` <- base::`+`
[18:00:57.449]             `<<-` <- base::`<<-`
[18:00:57.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.449]                   3L)]
[18:00:57.449]             }
[18:00:57.449]             function(cond) {
[18:00:57.449]                 is_error <- inherits(cond, "error")
[18:00:57.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.449]                   NULL)
[18:00:57.449]                 if (is_error) {
[18:00:57.449]                   sessionInformation <- function() {
[18:00:57.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.449]                       search = base::search(), system = base::Sys.info())
[18:00:57.449]                   }
[18:00:57.449]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.449]                     cond$call), session = sessionInformation(), 
[18:00:57.449]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.449]                   signalCondition(cond)
[18:00:57.449]                 }
[18:00:57.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.449]                 "immediateCondition"))) {
[18:00:57.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.449]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.449]                   if (TRUE && !signal) {
[18:00:57.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.449]                     {
[18:00:57.449]                       inherits <- base::inherits
[18:00:57.449]                       invokeRestart <- base::invokeRestart
[18:00:57.449]                       is.null <- base::is.null
[18:00:57.449]                       muffled <- FALSE
[18:00:57.449]                       if (inherits(cond, "message")) {
[18:00:57.449]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.449]                         if (muffled) 
[18:00:57.449]                           invokeRestart("muffleMessage")
[18:00:57.449]                       }
[18:00:57.449]                       else if (inherits(cond, "warning")) {
[18:00:57.449]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.449]                         if (muffled) 
[18:00:57.449]                           invokeRestart("muffleWarning")
[18:00:57.449]                       }
[18:00:57.449]                       else if (inherits(cond, "condition")) {
[18:00:57.449]                         if (!is.null(pattern)) {
[18:00:57.449]                           computeRestarts <- base::computeRestarts
[18:00:57.449]                           grepl <- base::grepl
[18:00:57.449]                           restarts <- computeRestarts(cond)
[18:00:57.449]                           for (restart in restarts) {
[18:00:57.449]                             name <- restart$name
[18:00:57.449]                             if (is.null(name)) 
[18:00:57.449]                               next
[18:00:57.449]                             if (!grepl(pattern, name)) 
[18:00:57.449]                               next
[18:00:57.449]                             invokeRestart(restart)
[18:00:57.449]                             muffled <- TRUE
[18:00:57.449]                             break
[18:00:57.449]                           }
[18:00:57.449]                         }
[18:00:57.449]                       }
[18:00:57.449]                       invisible(muffled)
[18:00:57.449]                     }
[18:00:57.449]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.449]                   }
[18:00:57.449]                 }
[18:00:57.449]                 else {
[18:00:57.449]                   if (TRUE) {
[18:00:57.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.449]                     {
[18:00:57.449]                       inherits <- base::inherits
[18:00:57.449]                       invokeRestart <- base::invokeRestart
[18:00:57.449]                       is.null <- base::is.null
[18:00:57.449]                       muffled <- FALSE
[18:00:57.449]                       if (inherits(cond, "message")) {
[18:00:57.449]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.449]                         if (muffled) 
[18:00:57.449]                           invokeRestart("muffleMessage")
[18:00:57.449]                       }
[18:00:57.449]                       else if (inherits(cond, "warning")) {
[18:00:57.449]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.449]                         if (muffled) 
[18:00:57.449]                           invokeRestart("muffleWarning")
[18:00:57.449]                       }
[18:00:57.449]                       else if (inherits(cond, "condition")) {
[18:00:57.449]                         if (!is.null(pattern)) {
[18:00:57.449]                           computeRestarts <- base::computeRestarts
[18:00:57.449]                           grepl <- base::grepl
[18:00:57.449]                           restarts <- computeRestarts(cond)
[18:00:57.449]                           for (restart in restarts) {
[18:00:57.449]                             name <- restart$name
[18:00:57.449]                             if (is.null(name)) 
[18:00:57.449]                               next
[18:00:57.449]                             if (!grepl(pattern, name)) 
[18:00:57.449]                               next
[18:00:57.449]                             invokeRestart(restart)
[18:00:57.449]                             muffled <- TRUE
[18:00:57.449]                             break
[18:00:57.449]                           }
[18:00:57.449]                         }
[18:00:57.449]                       }
[18:00:57.449]                       invisible(muffled)
[18:00:57.449]                     }
[18:00:57.449]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.449]                   }
[18:00:57.449]                 }
[18:00:57.449]             }
[18:00:57.449]         }))
[18:00:57.449]     }, error = function(ex) {
[18:00:57.449]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.449]                 ...future.rng), started = ...future.startTime, 
[18:00:57.449]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.449]             version = "1.8"), class = "FutureResult")
[18:00:57.449]     }, finally = {
[18:00:57.449]         if (!identical(...future.workdir, getwd())) 
[18:00:57.449]             setwd(...future.workdir)
[18:00:57.449]         {
[18:00:57.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.449]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.449]             }
[18:00:57.449]             base::options(...future.oldOptions)
[18:00:57.449]             if (.Platform$OS.type == "windows") {
[18:00:57.449]                 old_names <- names(...future.oldEnvVars)
[18:00:57.449]                 envs <- base::Sys.getenv()
[18:00:57.449]                 names <- names(envs)
[18:00:57.449]                 common <- intersect(names, old_names)
[18:00:57.449]                 added <- setdiff(names, old_names)
[18:00:57.449]                 removed <- setdiff(old_names, names)
[18:00:57.449]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.449]                   envs[common]]
[18:00:57.449]                 NAMES <- toupper(changed)
[18:00:57.449]                 args <- list()
[18:00:57.449]                 for (kk in seq_along(NAMES)) {
[18:00:57.449]                   name <- changed[[kk]]
[18:00:57.449]                   NAME <- NAMES[[kk]]
[18:00:57.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.449]                     next
[18:00:57.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.449]                 }
[18:00:57.449]                 NAMES <- toupper(added)
[18:00:57.449]                 for (kk in seq_along(NAMES)) {
[18:00:57.449]                   name <- added[[kk]]
[18:00:57.449]                   NAME <- NAMES[[kk]]
[18:00:57.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.449]                     next
[18:00:57.449]                   args[[name]] <- ""
[18:00:57.449]                 }
[18:00:57.449]                 NAMES <- toupper(removed)
[18:00:57.449]                 for (kk in seq_along(NAMES)) {
[18:00:57.449]                   name <- removed[[kk]]
[18:00:57.449]                   NAME <- NAMES[[kk]]
[18:00:57.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.449]                     next
[18:00:57.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.449]                 }
[18:00:57.449]                 if (length(args) > 0) 
[18:00:57.449]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.449]             }
[18:00:57.449]             else {
[18:00:57.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.449]             }
[18:00:57.449]             {
[18:00:57.449]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.449]                   0L) {
[18:00:57.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.449]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.449]                   base::options(opts)
[18:00:57.449]                 }
[18:00:57.449]                 {
[18:00:57.449]                   {
[18:00:57.449]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.449]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.449]                     1423455687L), envir = base::globalenv(), 
[18:00:57.449]                       inherits = FALSE)
[18:00:57.449]                     NULL
[18:00:57.449]                   }
[18:00:57.449]                   options(future.plan = NULL)
[18:00:57.449]                   if (is.na(NA_character_)) 
[18:00:57.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.449]                     .init = FALSE)
[18:00:57.449]                 }
[18:00:57.449]             }
[18:00:57.449]         }
[18:00:57.449]     })
[18:00:57.449]     if (TRUE) {
[18:00:57.449]         base::sink(type = "output", split = FALSE)
[18:00:57.449]         if (TRUE) {
[18:00:57.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.449]         }
[18:00:57.449]         else {
[18:00:57.449]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.449]         }
[18:00:57.449]         base::close(...future.stdout)
[18:00:57.449]         ...future.stdout <- NULL
[18:00:57.449]     }
[18:00:57.449]     ...future.result$conditions <- ...future.conditions
[18:00:57.449]     ...future.result$finished <- base::Sys.time()
[18:00:57.449]     ...future.result
[18:00:57.449] }
[18:00:57.452] assign_globals() ...
[18:00:57.452] List of 5
[18:00:57.452]  $ ...future.FUN            :function (x, ...)  
[18:00:57.452]  $ MoreArgs                 :List of 1
[18:00:57.452]   ..$ x: num 42
[18:00:57.452]  $ ...future.elements_ii    :List of 1
[18:00:57.452]   ..$ times:List of 4
[18:00:57.452]   .. ..$ : int 1
[18:00:57.452]   .. ..$ : int 2
[18:00:57.452]   .. ..$ : int 3
[18:00:57.452]   .. ..$ : int 4
[18:00:57.452]  $ ...future.seeds_ii       : NULL
[18:00:57.452]  $ ...future.globals.maxSize: NULL
[18:00:57.452]  - attr(*, "where")=List of 5
[18:00:57.452]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.452]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.452]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.452]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.452]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.452]  - attr(*, "resolved")= logi FALSE
[18:00:57.452]  - attr(*, "total_size")= num 336
[18:00:57.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.452]  - attr(*, "already-done")= logi TRUE
[18:00:57.464] - copied ‘...future.FUN’ to environment
[18:00:57.464] - copied ‘MoreArgs’ to environment
[18:00:57.464] - copied ‘...future.elements_ii’ to environment
[18:00:57.464] - copied ‘...future.seeds_ii’ to environment
[18:00:57.465] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.465] assign_globals() ... done
[18:00:57.465] plan(): Setting new future strategy stack:
[18:00:57.466] List of future strategies:
[18:00:57.466] 1. sequential:
[18:00:57.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.466]    - tweaked: FALSE
[18:00:57.466]    - call: NULL
[18:00:57.466] plan(): nbrOfWorkers() = 1
[18:00:57.468] plan(): Setting new future strategy stack:
[18:00:57.468] List of future strategies:
[18:00:57.468] 1. sequential:
[18:00:57.468]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.468]    - tweaked: FALSE
[18:00:57.468]    - call: plan(strategy)
[18:00:57.469] plan(): nbrOfWorkers() = 1
[18:00:57.469] SequentialFuture started (and completed)
[18:00:57.469] - Launch lazy future ... done
[18:00:57.470] run() for ‘SequentialFuture’ ... done
[18:00:57.470] Created future:
[18:00:57.470] SequentialFuture:
[18:00:57.470] Label: ‘future_mapply-1’
[18:00:57.470] Expression:
[18:00:57.470] {
[18:00:57.470]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.470]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.470]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.470]         on.exit(options(oopts), add = TRUE)
[18:00:57.470]     }
[18:00:57.470]     {
[18:00:57.470]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.470]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.470]         do.call(mapply, args = args)
[18:00:57.470]     }
[18:00:57.470] }
[18:00:57.470] Lazy evaluation: FALSE
[18:00:57.470] Asynchronous evaluation: FALSE
[18:00:57.470] Local evaluation: TRUE
[18:00:57.470] Environment: R_GlobalEnv
[18:00:57.470] Capture standard output: TRUE
[18:00:57.470] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.470] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.470] Packages: <none>
[18:00:57.470] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.470] Resolved: TRUE
[18:00:57.470] Value: 280 bytes of class ‘list’
[18:00:57.470] Early signaling: FALSE
[18:00:57.470] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.470] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.472] Chunk #1 of 1 ... DONE
[18:00:57.472] Launching 1 futures (chunks) ... DONE
[18:00:57.472] Resolving 1 futures (chunks) ...
[18:00:57.473] resolve() on list ...
[18:00:57.473]  recursive: 0
[18:00:57.475]  length: 1
[18:00:57.475] 
[18:00:57.476] resolved() for ‘SequentialFuture’ ...
[18:00:57.476] - state: ‘finished’
[18:00:57.476] - run: TRUE
[18:00:57.476] - result: ‘FutureResult’
[18:00:57.476] resolved() for ‘SequentialFuture’ ... done
[18:00:57.477] Future #1
[18:00:57.477] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.477] - nx: 1
[18:00:57.477] - relay: TRUE
[18:00:57.477] - stdout: TRUE
[18:00:57.478] - signal: TRUE
[18:00:57.478] - resignal: FALSE
[18:00:57.478] - force: TRUE
[18:00:57.478] - relayed: [n=1] FALSE
[18:00:57.478] - queued futures: [n=1] FALSE
[18:00:57.479]  - until=1
[18:00:57.479]  - relaying element #1
[18:00:57.479] - relayed: [n=1] TRUE
[18:00:57.479] - queued futures: [n=1] TRUE
[18:00:57.480] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.480]  length: 0 (resolved future 1)
[18:00:57.480] Relaying remaining futures
[18:00:57.480] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.480] - nx: 1
[18:00:57.480] - relay: TRUE
[18:00:57.481] - stdout: TRUE
[18:00:57.481] - signal: TRUE
[18:00:57.481] - resignal: FALSE
[18:00:57.481] - force: TRUE
[18:00:57.481] - relayed: [n=1] TRUE
[18:00:57.482] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.482] - relayed: [n=1] TRUE
[18:00:57.482] - queued futures: [n=1] TRUE
[18:00:57.482] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.482] resolve() on list ... DONE
[18:00:57.483]  - Number of value chunks collected: 1
[18:00:57.483] Resolving 1 futures (chunks) ... DONE
[18:00:57.483] Reducing values from 1 chunks ...
[18:00:57.483]  - Number of values collected after concatenation: 4
[18:00:57.483]  - Number of values expected: 4
[18:00:57.484] Reducing values from 1 chunks ... DONE
[18:00:57.484] future_mapply() ... DONE
[18:00:57.484] future_mapply() ...
[18:00:57.484] Number of chunks: 1
[18:00:57.485] getGlobalsAndPackagesXApply() ...
[18:00:57.485]  - future.globals: TRUE
[18:00:57.485] getGlobalsAndPackages() ...
[18:00:57.485] Searching for globals...
[18:00:57.488] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[18:00:57.488] Searching for globals ... DONE
[18:00:57.488] Resolving globals: FALSE
[18:00:57.489] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[18:00:57.489] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[18:00:57.490] - globals: [1] ‘FUN’
[18:00:57.490] 
[18:00:57.490] getGlobalsAndPackages() ... DONE
[18:00:57.490]  - globals found/used: [n=1] ‘FUN’
[18:00:57.490]  - needed namespaces: [n=0] 
[18:00:57.491] Finding globals ... DONE
[18:00:57.491] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.491] List of 2
[18:00:57.491]  $ ...future.FUN:function (x, y)  
[18:00:57.491]  $ MoreArgs     : NULL
[18:00:57.491]  - attr(*, "where")=List of 2
[18:00:57.491]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.491]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.491]  - attr(*, "resolved")= logi FALSE
[18:00:57.491]  - attr(*, "total_size")= num NA
[18:00:57.496] Packages to be attached in all futures: [n=0] 
[18:00:57.496] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.497] Number of futures (= number of chunks): 1
[18:00:57.497] Launching 1 futures (chunks) ...
[18:00:57.497] Chunk #1 of 1 ...
[18:00:57.497]  - Finding globals in '...' for chunk #1 ...
[18:00:57.498] getGlobalsAndPackages() ...
[18:00:57.498] Searching for globals...
[18:00:57.498] 
[18:00:57.499] Searching for globals ... DONE
[18:00:57.499] - globals: [0] <none>
[18:00:57.499] getGlobalsAndPackages() ... DONE
[18:00:57.499]    + additional globals found: [n=0] 
[18:00:57.499]    + additional namespaces needed: [n=0] 
[18:00:57.500]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.500]  - seeds: <none>
[18:00:57.500]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.500] getGlobalsAndPackages() ...
[18:00:57.500] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.501] Resolving globals: FALSE
[18:00:57.502] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[18:00:57.502] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.503] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.503] 
[18:00:57.503] getGlobalsAndPackages() ... DONE
[18:00:57.504] run() for ‘Future’ ...
[18:00:57.504] - state: ‘created’
[18:00:57.504] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.505] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.505]   - Field: ‘label’
[18:00:57.505]   - Field: ‘local’
[18:00:57.506]   - Field: ‘owner’
[18:00:57.506]   - Field: ‘envir’
[18:00:57.506]   - Field: ‘packages’
[18:00:57.506]   - Field: ‘gc’
[18:00:57.506]   - Field: ‘conditions’
[18:00:57.507]   - Field: ‘expr’
[18:00:57.507]   - Field: ‘uuid’
[18:00:57.507]   - Field: ‘seed’
[18:00:57.507]   - Field: ‘version’
[18:00:57.507]   - Field: ‘result’
[18:00:57.507]   - Field: ‘asynchronous’
[18:00:57.508]   - Field: ‘calls’
[18:00:57.508]   - Field: ‘globals’
[18:00:57.508]   - Field: ‘stdout’
[18:00:57.508]   - Field: ‘earlySignal’
[18:00:57.508]   - Field: ‘lazy’
[18:00:57.509]   - Field: ‘state’
[18:00:57.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.509] - Launch lazy future ...
[18:00:57.509] Packages needed by the future expression (n = 0): <none>
[18:00:57.510] Packages needed by future strategies (n = 0): <none>
[18:00:57.510] {
[18:00:57.510]     {
[18:00:57.510]         {
[18:00:57.510]             ...future.startTime <- base::Sys.time()
[18:00:57.510]             {
[18:00:57.510]                 {
[18:00:57.510]                   {
[18:00:57.510]                     base::local({
[18:00:57.510]                       has_future <- base::requireNamespace("future", 
[18:00:57.510]                         quietly = TRUE)
[18:00:57.510]                       if (has_future) {
[18:00:57.510]                         ns <- base::getNamespace("future")
[18:00:57.510]                         version <- ns[[".package"]][["version"]]
[18:00:57.510]                         if (is.null(version)) 
[18:00:57.510]                           version <- utils::packageVersion("future")
[18:00:57.510]                       }
[18:00:57.510]                       else {
[18:00:57.510]                         version <- NULL
[18:00:57.510]                       }
[18:00:57.510]                       if (!has_future || version < "1.8.0") {
[18:00:57.510]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.510]                           "", base::R.version$version.string), 
[18:00:57.510]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.510]                             "release", "version")], collapse = " "), 
[18:00:57.510]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.510]                           info)
[18:00:57.510]                         info <- base::paste(info, collapse = "; ")
[18:00:57.510]                         if (!has_future) {
[18:00:57.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.510]                             info)
[18:00:57.510]                         }
[18:00:57.510]                         else {
[18:00:57.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.510]                             info, version)
[18:00:57.510]                         }
[18:00:57.510]                         base::stop(msg)
[18:00:57.510]                       }
[18:00:57.510]                     })
[18:00:57.510]                   }
[18:00:57.510]                   ...future.strategy.old <- future::plan("list")
[18:00:57.510]                   options(future.plan = NULL)
[18:00:57.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.510]                 }
[18:00:57.510]                 ...future.workdir <- getwd()
[18:00:57.510]             }
[18:00:57.510]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.510]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.510]         }
[18:00:57.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.510]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.510]             base::names(...future.oldOptions))
[18:00:57.510]     }
[18:00:57.510]     if (FALSE) {
[18:00:57.510]     }
[18:00:57.510]     else {
[18:00:57.510]         if (TRUE) {
[18:00:57.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.510]                 open = "w")
[18:00:57.510]         }
[18:00:57.510]         else {
[18:00:57.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.510]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.510]         }
[18:00:57.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.510]             base::sink(type = "output", split = FALSE)
[18:00:57.510]             base::close(...future.stdout)
[18:00:57.510]         }, add = TRUE)
[18:00:57.510]     }
[18:00:57.510]     ...future.frame <- base::sys.nframe()
[18:00:57.510]     ...future.conditions <- base::list()
[18:00:57.510]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.510]     if (FALSE) {
[18:00:57.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.510]     }
[18:00:57.510]     ...future.result <- base::tryCatch({
[18:00:57.510]         base::withCallingHandlers({
[18:00:57.510]             ...future.value <- base::withVisible(base::local({
[18:00:57.510]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.510]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.510]                   ...future.globals.maxSize)) {
[18:00:57.510]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.510]                   on.exit(options(oopts), add = TRUE)
[18:00:57.510]                 }
[18:00:57.510]                 {
[18:00:57.510]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.510]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.510]                     USE.NAMES = FALSE)
[18:00:57.510]                   do.call(mapply, args = args)
[18:00:57.510]                 }
[18:00:57.510]             }))
[18:00:57.510]             future::FutureResult(value = ...future.value$value, 
[18:00:57.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.510]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.510]                     ...future.globalenv.names))
[18:00:57.510]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.510]         }, condition = base::local({
[18:00:57.510]             c <- base::c
[18:00:57.510]             inherits <- base::inherits
[18:00:57.510]             invokeRestart <- base::invokeRestart
[18:00:57.510]             length <- base::length
[18:00:57.510]             list <- base::list
[18:00:57.510]             seq.int <- base::seq.int
[18:00:57.510]             signalCondition <- base::signalCondition
[18:00:57.510]             sys.calls <- base::sys.calls
[18:00:57.510]             `[[` <- base::`[[`
[18:00:57.510]             `+` <- base::`+`
[18:00:57.510]             `<<-` <- base::`<<-`
[18:00:57.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.510]                   3L)]
[18:00:57.510]             }
[18:00:57.510]             function(cond) {
[18:00:57.510]                 is_error <- inherits(cond, "error")
[18:00:57.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.510]                   NULL)
[18:00:57.510]                 if (is_error) {
[18:00:57.510]                   sessionInformation <- function() {
[18:00:57.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.510]                       search = base::search(), system = base::Sys.info())
[18:00:57.510]                   }
[18:00:57.510]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.510]                     cond$call), session = sessionInformation(), 
[18:00:57.510]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.510]                   signalCondition(cond)
[18:00:57.510]                 }
[18:00:57.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.510]                 "immediateCondition"))) {
[18:00:57.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.510]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.510]                   if (TRUE && !signal) {
[18:00:57.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.510]                     {
[18:00:57.510]                       inherits <- base::inherits
[18:00:57.510]                       invokeRestart <- base::invokeRestart
[18:00:57.510]                       is.null <- base::is.null
[18:00:57.510]                       muffled <- FALSE
[18:00:57.510]                       if (inherits(cond, "message")) {
[18:00:57.510]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.510]                         if (muffled) 
[18:00:57.510]                           invokeRestart("muffleMessage")
[18:00:57.510]                       }
[18:00:57.510]                       else if (inherits(cond, "warning")) {
[18:00:57.510]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.510]                         if (muffled) 
[18:00:57.510]                           invokeRestart("muffleWarning")
[18:00:57.510]                       }
[18:00:57.510]                       else if (inherits(cond, "condition")) {
[18:00:57.510]                         if (!is.null(pattern)) {
[18:00:57.510]                           computeRestarts <- base::computeRestarts
[18:00:57.510]                           grepl <- base::grepl
[18:00:57.510]                           restarts <- computeRestarts(cond)
[18:00:57.510]                           for (restart in restarts) {
[18:00:57.510]                             name <- restart$name
[18:00:57.510]                             if (is.null(name)) 
[18:00:57.510]                               next
[18:00:57.510]                             if (!grepl(pattern, name)) 
[18:00:57.510]                               next
[18:00:57.510]                             invokeRestart(restart)
[18:00:57.510]                             muffled <- TRUE
[18:00:57.510]                             break
[18:00:57.510]                           }
[18:00:57.510]                         }
[18:00:57.510]                       }
[18:00:57.510]                       invisible(muffled)
[18:00:57.510]                     }
[18:00:57.510]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.510]                   }
[18:00:57.510]                 }
[18:00:57.510]                 else {
[18:00:57.510]                   if (TRUE) {
[18:00:57.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.510]                     {
[18:00:57.510]                       inherits <- base::inherits
[18:00:57.510]                       invokeRestart <- base::invokeRestart
[18:00:57.510]                       is.null <- base::is.null
[18:00:57.510]                       muffled <- FALSE
[18:00:57.510]                       if (inherits(cond, "message")) {
[18:00:57.510]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.510]                         if (muffled) 
[18:00:57.510]                           invokeRestart("muffleMessage")
[18:00:57.510]                       }
[18:00:57.510]                       else if (inherits(cond, "warning")) {
[18:00:57.510]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.510]                         if (muffled) 
[18:00:57.510]                           invokeRestart("muffleWarning")
[18:00:57.510]                       }
[18:00:57.510]                       else if (inherits(cond, "condition")) {
[18:00:57.510]                         if (!is.null(pattern)) {
[18:00:57.510]                           computeRestarts <- base::computeRestarts
[18:00:57.510]                           grepl <- base::grepl
[18:00:57.510]                           restarts <- computeRestarts(cond)
[18:00:57.510]                           for (restart in restarts) {
[18:00:57.510]                             name <- restart$name
[18:00:57.510]                             if (is.null(name)) 
[18:00:57.510]                               next
[18:00:57.510]                             if (!grepl(pattern, name)) 
[18:00:57.510]                               next
[18:00:57.510]                             invokeRestart(restart)
[18:00:57.510]                             muffled <- TRUE
[18:00:57.510]                             break
[18:00:57.510]                           }
[18:00:57.510]                         }
[18:00:57.510]                       }
[18:00:57.510]                       invisible(muffled)
[18:00:57.510]                     }
[18:00:57.510]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.510]                   }
[18:00:57.510]                 }
[18:00:57.510]             }
[18:00:57.510]         }))
[18:00:57.510]     }, error = function(ex) {
[18:00:57.510]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.510]                 ...future.rng), started = ...future.startTime, 
[18:00:57.510]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.510]             version = "1.8"), class = "FutureResult")
[18:00:57.510]     }, finally = {
[18:00:57.510]         if (!identical(...future.workdir, getwd())) 
[18:00:57.510]             setwd(...future.workdir)
[18:00:57.510]         {
[18:00:57.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.510]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.510]             }
[18:00:57.510]             base::options(...future.oldOptions)
[18:00:57.510]             if (.Platform$OS.type == "windows") {
[18:00:57.510]                 old_names <- names(...future.oldEnvVars)
[18:00:57.510]                 envs <- base::Sys.getenv()
[18:00:57.510]                 names <- names(envs)
[18:00:57.510]                 common <- intersect(names, old_names)
[18:00:57.510]                 added <- setdiff(names, old_names)
[18:00:57.510]                 removed <- setdiff(old_names, names)
[18:00:57.510]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.510]                   envs[common]]
[18:00:57.510]                 NAMES <- toupper(changed)
[18:00:57.510]                 args <- list()
[18:00:57.510]                 for (kk in seq_along(NAMES)) {
[18:00:57.510]                   name <- changed[[kk]]
[18:00:57.510]                   NAME <- NAMES[[kk]]
[18:00:57.510]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.510]                     next
[18:00:57.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.510]                 }
[18:00:57.510]                 NAMES <- toupper(added)
[18:00:57.510]                 for (kk in seq_along(NAMES)) {
[18:00:57.510]                   name <- added[[kk]]
[18:00:57.510]                   NAME <- NAMES[[kk]]
[18:00:57.510]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.510]                     next
[18:00:57.510]                   args[[name]] <- ""
[18:00:57.510]                 }
[18:00:57.510]                 NAMES <- toupper(removed)
[18:00:57.510]                 for (kk in seq_along(NAMES)) {
[18:00:57.510]                   name <- removed[[kk]]
[18:00:57.510]                   NAME <- NAMES[[kk]]
[18:00:57.510]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.510]                     next
[18:00:57.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.510]                 }
[18:00:57.510]                 if (length(args) > 0) 
[18:00:57.510]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.510]             }
[18:00:57.510]             else {
[18:00:57.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.510]             }
[18:00:57.510]             {
[18:00:57.510]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.510]                   0L) {
[18:00:57.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.510]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.510]                   base::options(opts)
[18:00:57.510]                 }
[18:00:57.510]                 {
[18:00:57.510]                   {
[18:00:57.510]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.510]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.510]                     1423455687L), envir = base::globalenv(), 
[18:00:57.510]                       inherits = FALSE)
[18:00:57.510]                     NULL
[18:00:57.510]                   }
[18:00:57.510]                   options(future.plan = NULL)
[18:00:57.510]                   if (is.na(NA_character_)) 
[18:00:57.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.510]                     .init = FALSE)
[18:00:57.510]                 }
[18:00:57.510]             }
[18:00:57.510]         }
[18:00:57.510]     })
[18:00:57.510]     if (TRUE) {
[18:00:57.510]         base::sink(type = "output", split = FALSE)
[18:00:57.510]         if (TRUE) {
[18:00:57.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.510]         }
[18:00:57.510]         else {
[18:00:57.510]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.510]         }
[18:00:57.510]         base::close(...future.stdout)
[18:00:57.510]         ...future.stdout <- NULL
[18:00:57.510]     }
[18:00:57.510]     ...future.result$conditions <- ...future.conditions
[18:00:57.510]     ...future.result$finished <- base::Sys.time()
[18:00:57.510]     ...future.result
[18:00:57.510] }
[18:00:57.514] assign_globals() ...
[18:00:57.514] List of 5
[18:00:57.514]  $ ...future.FUN            :function (x, y)  
[18:00:57.514]  $ MoreArgs                 : NULL
[18:00:57.514]  $ ...future.elements_ii    :List of 2
[18:00:57.514]   ..$ :List of 3
[18:00:57.514]   .. ..$ a: num 1
[18:00:57.514]   .. ..$ b: num 2
[18:00:57.514]   .. ..$ c: num 3
[18:00:57.514]   ..$ :List of 3
[18:00:57.514]   .. ..$ A: num 10
[18:00:57.514]   .. ..$ B: num 0
[18:00:57.514]   .. ..$ C: num -10
[18:00:57.514]  $ ...future.seeds_ii       : NULL
[18:00:57.514]  $ ...future.globals.maxSize: NULL
[18:00:57.514]  - attr(*, "where")=List of 5
[18:00:57.514]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.514]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.514]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.514]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.514]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.514]  - attr(*, "resolved")= logi FALSE
[18:00:57.514]  - attr(*, "total_size")= num 2312
[18:00:57.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.514]  - attr(*, "already-done")= logi TRUE
[18:00:57.530] - reassign environment for ‘...future.FUN’
[18:00:57.530] - copied ‘...future.FUN’ to environment
[18:00:57.530] - copied ‘MoreArgs’ to environment
[18:00:57.531] - copied ‘...future.elements_ii’ to environment
[18:00:57.531] - copied ‘...future.seeds_ii’ to environment
[18:00:57.531] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.531] assign_globals() ... done
[18:00:57.532] plan(): Setting new future strategy stack:
[18:00:57.532] List of future strategies:
[18:00:57.532] 1. sequential:
[18:00:57.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.532]    - tweaked: FALSE
[18:00:57.532]    - call: NULL
[18:00:57.533] plan(): nbrOfWorkers() = 1
[18:00:57.534] plan(): Setting new future strategy stack:
[18:00:57.534] List of future strategies:
[18:00:57.534] 1. sequential:
[18:00:57.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.534]    - tweaked: FALSE
[18:00:57.534]    - call: plan(strategy)
[18:00:57.535] plan(): nbrOfWorkers() = 1
[18:00:57.536] SequentialFuture started (and completed)
[18:00:57.536] - Launch lazy future ... done
[18:00:57.536] run() for ‘SequentialFuture’ ... done
[18:00:57.536] Created future:
[18:00:57.536] SequentialFuture:
[18:00:57.536] Label: ‘future_mapply-1’
[18:00:57.536] Expression:
[18:00:57.536] {
[18:00:57.536]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.536]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.536]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.536]         on.exit(options(oopts), add = TRUE)
[18:00:57.536]     }
[18:00:57.536]     {
[18:00:57.536]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.536]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.536]         do.call(mapply, args = args)
[18:00:57.536]     }
[18:00:57.536] }
[18:00:57.536] Lazy evaluation: FALSE
[18:00:57.536] Asynchronous evaluation: FALSE
[18:00:57.536] Local evaluation: TRUE
[18:00:57.536] Environment: R_GlobalEnv
[18:00:57.536] Capture standard output: TRUE
[18:00:57.536] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.536] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.536] Packages: <none>
[18:00:57.536] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.536] Resolved: TRUE
[18:00:57.536] Value: 200 bytes of class ‘list’
[18:00:57.536] Early signaling: FALSE
[18:00:57.536] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.536] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.538] Chunk #1 of 1 ... DONE
[18:00:57.538] Launching 1 futures (chunks) ... DONE
[18:00:57.539] Resolving 1 futures (chunks) ...
[18:00:57.539] resolve() on list ...
[18:00:57.539]  recursive: 0
[18:00:57.539]  length: 1
[18:00:57.539] 
[18:00:57.540] resolved() for ‘SequentialFuture’ ...
[18:00:57.540] - state: ‘finished’
[18:00:57.540] - run: TRUE
[18:00:57.540] - result: ‘FutureResult’
[18:00:57.540] resolved() for ‘SequentialFuture’ ... done
[18:00:57.541] Future #1
[18:00:57.541] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.541] - nx: 1
[18:00:57.541] - relay: TRUE
[18:00:57.541] - stdout: TRUE
[18:00:57.542] - signal: TRUE
[18:00:57.542] - resignal: FALSE
[18:00:57.542] - force: TRUE
[18:00:57.542] - relayed: [n=1] FALSE
[18:00:57.542] - queued futures: [n=1] FALSE
[18:00:57.543]  - until=1
[18:00:57.543]  - relaying element #1
[18:00:57.543] - relayed: [n=1] TRUE
[18:00:57.543] - queued futures: [n=1] TRUE
[18:00:57.543] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.544]  length: 0 (resolved future 1)
[18:00:57.544] Relaying remaining futures
[18:00:57.544] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.544] - nx: 1
[18:00:57.544] - relay: TRUE
[18:00:57.545] - stdout: TRUE
[18:00:57.545] - signal: TRUE
[18:00:57.545] - resignal: FALSE
[18:00:57.545] - force: TRUE
[18:00:57.545] - relayed: [n=1] TRUE
[18:00:57.545] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.546] - relayed: [n=1] TRUE
[18:00:57.546] - queued futures: [n=1] TRUE
[18:00:57.546] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.546] resolve() on list ... DONE
[18:00:57.547]  - Number of value chunks collected: 1
[18:00:57.547] Resolving 1 futures (chunks) ... DONE
[18:00:57.547] Reducing values from 1 chunks ...
[18:00:57.547]  - Number of values collected after concatenation: 3
[18:00:57.547]  - Number of values expected: 3
[18:00:57.547] Reducing values from 1 chunks ... DONE
[18:00:57.548] future_mapply() ... DONE
- future_.mapply()
[18:00:57.549] future_mapply() ...
[18:00:57.549] Number of chunks: 1
[18:00:57.550] getGlobalsAndPackagesXApply() ...
[18:00:57.550]  - future.globals: TRUE
[18:00:57.550] getGlobalsAndPackages() ...
[18:00:57.550] Searching for globals...
[18:00:57.553] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[18:00:57.553] Searching for globals ... DONE
[18:00:57.553] Resolving globals: FALSE
[18:00:57.554] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[18:00:57.554] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[18:00:57.555] - globals: [1] ‘FUN’
[18:00:57.555] 
[18:00:57.555] getGlobalsAndPackages() ... DONE
[18:00:57.555]  - globals found/used: [n=1] ‘FUN’
[18:00:57.555]  - needed namespaces: [n=0] 
[18:00:57.556] Finding globals ... DONE
[18:00:57.556] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.556] List of 2
[18:00:57.556]  $ ...future.FUN:function (x, y)  
[18:00:57.556]  $ MoreArgs     : list()
[18:00:57.556]  - attr(*, "where")=List of 2
[18:00:57.556]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.556]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.556]  - attr(*, "resolved")= logi FALSE
[18:00:57.556]  - attr(*, "total_size")= num NA
[18:00:57.561] Packages to be attached in all futures: [n=0] 
[18:00:57.561] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.562] Number of futures (= number of chunks): 1
[18:00:57.562] Launching 1 futures (chunks) ...
[18:00:57.562] Chunk #1 of 1 ...
[18:00:57.563]  - Finding globals in '...' for chunk #1 ...
[18:00:57.563] getGlobalsAndPackages() ...
[18:00:57.563] Searching for globals...
[18:00:57.564] 
[18:00:57.564] Searching for globals ... DONE
[18:00:57.564] - globals: [0] <none>
[18:00:57.564] getGlobalsAndPackages() ... DONE
[18:00:57.564]    + additional globals found: [n=0] 
[18:00:57.565]    + additional namespaces needed: [n=0] 
[18:00:57.565]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.565]  - seeds: <none>
[18:00:57.565]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.565] getGlobalsAndPackages() ...
[18:00:57.566] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.566] Resolving globals: FALSE
[18:00:57.567] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[18:00:57.568] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:00:57.568] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.568] 
[18:00:57.569] getGlobalsAndPackages() ... DONE
[18:00:57.569] run() for ‘Future’ ...
[18:00:57.569] - state: ‘created’
[18:00:57.570] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.570] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.571]   - Field: ‘label’
[18:00:57.571]   - Field: ‘local’
[18:00:57.571]   - Field: ‘owner’
[18:00:57.571]   - Field: ‘envir’
[18:00:57.572]   - Field: ‘packages’
[18:00:57.572]   - Field: ‘gc’
[18:00:57.572]   - Field: ‘conditions’
[18:00:57.572]   - Field: ‘expr’
[18:00:57.572]   - Field: ‘uuid’
[18:00:57.573]   - Field: ‘seed’
[18:00:57.573]   - Field: ‘version’
[18:00:57.573]   - Field: ‘result’
[18:00:57.573]   - Field: ‘asynchronous’
[18:00:57.573]   - Field: ‘calls’
[18:00:57.574]   - Field: ‘globals’
[18:00:57.574]   - Field: ‘stdout’
[18:00:57.574]   - Field: ‘earlySignal’
[18:00:57.574]   - Field: ‘lazy’
[18:00:57.574]   - Field: ‘state’
[18:00:57.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.575] - Launch lazy future ...
[18:00:57.575] Packages needed by the future expression (n = 0): <none>
[18:00:57.575] Packages needed by future strategies (n = 0): <none>
[18:00:57.576] {
[18:00:57.576]     {
[18:00:57.576]         {
[18:00:57.576]             ...future.startTime <- base::Sys.time()
[18:00:57.576]             {
[18:00:57.576]                 {
[18:00:57.576]                   {
[18:00:57.576]                     base::local({
[18:00:57.576]                       has_future <- base::requireNamespace("future", 
[18:00:57.576]                         quietly = TRUE)
[18:00:57.576]                       if (has_future) {
[18:00:57.576]                         ns <- base::getNamespace("future")
[18:00:57.576]                         version <- ns[[".package"]][["version"]]
[18:00:57.576]                         if (is.null(version)) 
[18:00:57.576]                           version <- utils::packageVersion("future")
[18:00:57.576]                       }
[18:00:57.576]                       else {
[18:00:57.576]                         version <- NULL
[18:00:57.576]                       }
[18:00:57.576]                       if (!has_future || version < "1.8.0") {
[18:00:57.576]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.576]                           "", base::R.version$version.string), 
[18:00:57.576]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.576]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.576]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.576]                             "release", "version")], collapse = " "), 
[18:00:57.576]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.576]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.576]                           info)
[18:00:57.576]                         info <- base::paste(info, collapse = "; ")
[18:00:57.576]                         if (!has_future) {
[18:00:57.576]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.576]                             info)
[18:00:57.576]                         }
[18:00:57.576]                         else {
[18:00:57.576]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.576]                             info, version)
[18:00:57.576]                         }
[18:00:57.576]                         base::stop(msg)
[18:00:57.576]                       }
[18:00:57.576]                     })
[18:00:57.576]                   }
[18:00:57.576]                   ...future.strategy.old <- future::plan("list")
[18:00:57.576]                   options(future.plan = NULL)
[18:00:57.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.576]                 }
[18:00:57.576]                 ...future.workdir <- getwd()
[18:00:57.576]             }
[18:00:57.576]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.576]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.576]         }
[18:00:57.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.576]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.576]             base::names(...future.oldOptions))
[18:00:57.576]     }
[18:00:57.576]     if (FALSE) {
[18:00:57.576]     }
[18:00:57.576]     else {
[18:00:57.576]         if (TRUE) {
[18:00:57.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.576]                 open = "w")
[18:00:57.576]         }
[18:00:57.576]         else {
[18:00:57.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.576]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.576]         }
[18:00:57.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.576]             base::sink(type = "output", split = FALSE)
[18:00:57.576]             base::close(...future.stdout)
[18:00:57.576]         }, add = TRUE)
[18:00:57.576]     }
[18:00:57.576]     ...future.frame <- base::sys.nframe()
[18:00:57.576]     ...future.conditions <- base::list()
[18:00:57.576]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.576]     if (FALSE) {
[18:00:57.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.576]     }
[18:00:57.576]     ...future.result <- base::tryCatch({
[18:00:57.576]         base::withCallingHandlers({
[18:00:57.576]             ...future.value <- base::withVisible(base::local({
[18:00:57.576]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.576]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.576]                   ...future.globals.maxSize)) {
[18:00:57.576]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.576]                   on.exit(options(oopts), add = TRUE)
[18:00:57.576]                 }
[18:00:57.576]                 {
[18:00:57.576]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.576]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.576]                     USE.NAMES = FALSE)
[18:00:57.576]                   do.call(mapply, args = args)
[18:00:57.576]                 }
[18:00:57.576]             }))
[18:00:57.576]             future::FutureResult(value = ...future.value$value, 
[18:00:57.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.576]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.576]                     ...future.globalenv.names))
[18:00:57.576]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.576]         }, condition = base::local({
[18:00:57.576]             c <- base::c
[18:00:57.576]             inherits <- base::inherits
[18:00:57.576]             invokeRestart <- base::invokeRestart
[18:00:57.576]             length <- base::length
[18:00:57.576]             list <- base::list
[18:00:57.576]             seq.int <- base::seq.int
[18:00:57.576]             signalCondition <- base::signalCondition
[18:00:57.576]             sys.calls <- base::sys.calls
[18:00:57.576]             `[[` <- base::`[[`
[18:00:57.576]             `+` <- base::`+`
[18:00:57.576]             `<<-` <- base::`<<-`
[18:00:57.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.576]                   3L)]
[18:00:57.576]             }
[18:00:57.576]             function(cond) {
[18:00:57.576]                 is_error <- inherits(cond, "error")
[18:00:57.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.576]                   NULL)
[18:00:57.576]                 if (is_error) {
[18:00:57.576]                   sessionInformation <- function() {
[18:00:57.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.576]                       search = base::search(), system = base::Sys.info())
[18:00:57.576]                   }
[18:00:57.576]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.576]                     cond$call), session = sessionInformation(), 
[18:00:57.576]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.576]                   signalCondition(cond)
[18:00:57.576]                 }
[18:00:57.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.576]                 "immediateCondition"))) {
[18:00:57.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.576]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.576]                   if (TRUE && !signal) {
[18:00:57.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.576]                     {
[18:00:57.576]                       inherits <- base::inherits
[18:00:57.576]                       invokeRestart <- base::invokeRestart
[18:00:57.576]                       is.null <- base::is.null
[18:00:57.576]                       muffled <- FALSE
[18:00:57.576]                       if (inherits(cond, "message")) {
[18:00:57.576]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.576]                         if (muffled) 
[18:00:57.576]                           invokeRestart("muffleMessage")
[18:00:57.576]                       }
[18:00:57.576]                       else if (inherits(cond, "warning")) {
[18:00:57.576]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.576]                         if (muffled) 
[18:00:57.576]                           invokeRestart("muffleWarning")
[18:00:57.576]                       }
[18:00:57.576]                       else if (inherits(cond, "condition")) {
[18:00:57.576]                         if (!is.null(pattern)) {
[18:00:57.576]                           computeRestarts <- base::computeRestarts
[18:00:57.576]                           grepl <- base::grepl
[18:00:57.576]                           restarts <- computeRestarts(cond)
[18:00:57.576]                           for (restart in restarts) {
[18:00:57.576]                             name <- restart$name
[18:00:57.576]                             if (is.null(name)) 
[18:00:57.576]                               next
[18:00:57.576]                             if (!grepl(pattern, name)) 
[18:00:57.576]                               next
[18:00:57.576]                             invokeRestart(restart)
[18:00:57.576]                             muffled <- TRUE
[18:00:57.576]                             break
[18:00:57.576]                           }
[18:00:57.576]                         }
[18:00:57.576]                       }
[18:00:57.576]                       invisible(muffled)
[18:00:57.576]                     }
[18:00:57.576]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.576]                   }
[18:00:57.576]                 }
[18:00:57.576]                 else {
[18:00:57.576]                   if (TRUE) {
[18:00:57.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.576]                     {
[18:00:57.576]                       inherits <- base::inherits
[18:00:57.576]                       invokeRestart <- base::invokeRestart
[18:00:57.576]                       is.null <- base::is.null
[18:00:57.576]                       muffled <- FALSE
[18:00:57.576]                       if (inherits(cond, "message")) {
[18:00:57.576]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.576]                         if (muffled) 
[18:00:57.576]                           invokeRestart("muffleMessage")
[18:00:57.576]                       }
[18:00:57.576]                       else if (inherits(cond, "warning")) {
[18:00:57.576]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.576]                         if (muffled) 
[18:00:57.576]                           invokeRestart("muffleWarning")
[18:00:57.576]                       }
[18:00:57.576]                       else if (inherits(cond, "condition")) {
[18:00:57.576]                         if (!is.null(pattern)) {
[18:00:57.576]                           computeRestarts <- base::computeRestarts
[18:00:57.576]                           grepl <- base::grepl
[18:00:57.576]                           restarts <- computeRestarts(cond)
[18:00:57.576]                           for (restart in restarts) {
[18:00:57.576]                             name <- restart$name
[18:00:57.576]                             if (is.null(name)) 
[18:00:57.576]                               next
[18:00:57.576]                             if (!grepl(pattern, name)) 
[18:00:57.576]                               next
[18:00:57.576]                             invokeRestart(restart)
[18:00:57.576]                             muffled <- TRUE
[18:00:57.576]                             break
[18:00:57.576]                           }
[18:00:57.576]                         }
[18:00:57.576]                       }
[18:00:57.576]                       invisible(muffled)
[18:00:57.576]                     }
[18:00:57.576]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.576]                   }
[18:00:57.576]                 }
[18:00:57.576]             }
[18:00:57.576]         }))
[18:00:57.576]     }, error = function(ex) {
[18:00:57.576]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.576]                 ...future.rng), started = ...future.startTime, 
[18:00:57.576]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.576]             version = "1.8"), class = "FutureResult")
[18:00:57.576]     }, finally = {
[18:00:57.576]         if (!identical(...future.workdir, getwd())) 
[18:00:57.576]             setwd(...future.workdir)
[18:00:57.576]         {
[18:00:57.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.576]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.576]             }
[18:00:57.576]             base::options(...future.oldOptions)
[18:00:57.576]             if (.Platform$OS.type == "windows") {
[18:00:57.576]                 old_names <- names(...future.oldEnvVars)
[18:00:57.576]                 envs <- base::Sys.getenv()
[18:00:57.576]                 names <- names(envs)
[18:00:57.576]                 common <- intersect(names, old_names)
[18:00:57.576]                 added <- setdiff(names, old_names)
[18:00:57.576]                 removed <- setdiff(old_names, names)
[18:00:57.576]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.576]                   envs[common]]
[18:00:57.576]                 NAMES <- toupper(changed)
[18:00:57.576]                 args <- list()
[18:00:57.576]                 for (kk in seq_along(NAMES)) {
[18:00:57.576]                   name <- changed[[kk]]
[18:00:57.576]                   NAME <- NAMES[[kk]]
[18:00:57.576]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.576]                     next
[18:00:57.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.576]                 }
[18:00:57.576]                 NAMES <- toupper(added)
[18:00:57.576]                 for (kk in seq_along(NAMES)) {
[18:00:57.576]                   name <- added[[kk]]
[18:00:57.576]                   NAME <- NAMES[[kk]]
[18:00:57.576]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.576]                     next
[18:00:57.576]                   args[[name]] <- ""
[18:00:57.576]                 }
[18:00:57.576]                 NAMES <- toupper(removed)
[18:00:57.576]                 for (kk in seq_along(NAMES)) {
[18:00:57.576]                   name <- removed[[kk]]
[18:00:57.576]                   NAME <- NAMES[[kk]]
[18:00:57.576]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.576]                     next
[18:00:57.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.576]                 }
[18:00:57.576]                 if (length(args) > 0) 
[18:00:57.576]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.576]             }
[18:00:57.576]             else {
[18:00:57.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.576]             }
[18:00:57.576]             {
[18:00:57.576]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.576]                   0L) {
[18:00:57.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.576]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.576]                   base::options(opts)
[18:00:57.576]                 }
[18:00:57.576]                 {
[18:00:57.576]                   {
[18:00:57.576]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.576]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.576]                     1423455687L), envir = base::globalenv(), 
[18:00:57.576]                       inherits = FALSE)
[18:00:57.576]                     NULL
[18:00:57.576]                   }
[18:00:57.576]                   options(future.plan = NULL)
[18:00:57.576]                   if (is.na(NA_character_)) 
[18:00:57.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.576]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.576]                     .init = FALSE)
[18:00:57.576]                 }
[18:00:57.576]             }
[18:00:57.576]         }
[18:00:57.576]     })
[18:00:57.576]     if (TRUE) {
[18:00:57.576]         base::sink(type = "output", split = FALSE)
[18:00:57.576]         if (TRUE) {
[18:00:57.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.576]         }
[18:00:57.576]         else {
[18:00:57.576]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.576]         }
[18:00:57.576]         base::close(...future.stdout)
[18:00:57.576]         ...future.stdout <- NULL
[18:00:57.576]     }
[18:00:57.576]     ...future.result$conditions <- ...future.conditions
[18:00:57.576]     ...future.result$finished <- base::Sys.time()
[18:00:57.576]     ...future.result
[18:00:57.576] }
[18:00:57.581] assign_globals() ...
[18:00:57.581] List of 5
[18:00:57.581]  $ ...future.FUN            :function (x, y)  
[18:00:57.581]  $ MoreArgs                 : list()
[18:00:57.581]  $ ...future.elements_ii    :List of 2
[18:00:57.581]   ..$ :List of 3
[18:00:57.581]   .. ..$ a: num 1
[18:00:57.581]   .. ..$ b: num 2
[18:00:57.581]   .. ..$ c: num 3
[18:00:57.581]   ..$ :List of 3
[18:00:57.581]   .. ..$ A: num 10
[18:00:57.581]   .. ..$ B: num 0
[18:00:57.581]   .. ..$ C: num -10
[18:00:57.581]  $ ...future.seeds_ii       : NULL
[18:00:57.581]  $ ...future.globals.maxSize: NULL
[18:00:57.581]  - attr(*, "where")=List of 5
[18:00:57.581]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.581]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.581]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.581]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.581]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.581]  - attr(*, "resolved")= logi FALSE
[18:00:57.581]  - attr(*, "total_size")= num 2312
[18:00:57.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.581]  - attr(*, "already-done")= logi TRUE
[18:00:57.598] - reassign environment for ‘...future.FUN’
[18:00:57.598] - copied ‘...future.FUN’ to environment
[18:00:57.598] - copied ‘MoreArgs’ to environment
[18:00:57.598] - copied ‘...future.elements_ii’ to environment
[18:00:57.598] - copied ‘...future.seeds_ii’ to environment
[18:00:57.599] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.599] assign_globals() ... done
[18:00:57.599] plan(): Setting new future strategy stack:
[18:00:57.600] List of future strategies:
[18:00:57.600] 1. sequential:
[18:00:57.600]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.600]    - tweaked: FALSE
[18:00:57.600]    - call: NULL
[18:00:57.600] plan(): nbrOfWorkers() = 1
[18:00:57.602] plan(): Setting new future strategy stack:
[18:00:57.602] List of future strategies:
[18:00:57.602] 1. sequential:
[18:00:57.602]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.602]    - tweaked: FALSE
[18:00:57.602]    - call: plan(strategy)
[18:00:57.603] plan(): nbrOfWorkers() = 1
[18:00:57.603] SequentialFuture started (and completed)
[18:00:57.604] - Launch lazy future ... done
[18:00:57.604] run() for ‘SequentialFuture’ ... done
[18:00:57.604] Created future:
[18:00:57.604] SequentialFuture:
[18:00:57.604] Label: ‘future_.mapply-1’
[18:00:57.604] Expression:
[18:00:57.604] {
[18:00:57.604]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.604]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.604]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.604]         on.exit(options(oopts), add = TRUE)
[18:00:57.604]     }
[18:00:57.604]     {
[18:00:57.604]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.604]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.604]         do.call(mapply, args = args)
[18:00:57.604]     }
[18:00:57.604] }
[18:00:57.604] Lazy evaluation: FALSE
[18:00:57.604] Asynchronous evaluation: FALSE
[18:00:57.604] Local evaluation: TRUE
[18:00:57.604] Environment: R_GlobalEnv
[18:00:57.604] Capture standard output: TRUE
[18:00:57.604] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.604] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.604] Packages: <none>
[18:00:57.604] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.604] Resolved: TRUE
[18:00:57.604] Value: 200 bytes of class ‘list’
[18:00:57.604] Early signaling: FALSE
[18:00:57.604] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.604] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.606] Chunk #1 of 1 ... DONE
[18:00:57.606] Launching 1 futures (chunks) ... DONE
[18:00:57.606] Resolving 1 futures (chunks) ...
[18:00:57.607] resolve() on list ...
[18:00:57.607]  recursive: 0
[18:00:57.607]  length: 1
[18:00:57.607] 
[18:00:57.607] resolved() for ‘SequentialFuture’ ...
[18:00:57.608] - state: ‘finished’
[18:00:57.608] - run: TRUE
[18:00:57.608] - result: ‘FutureResult’
[18:00:57.608] resolved() for ‘SequentialFuture’ ... done
[18:00:57.608] Future #1
[18:00:57.609] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.609] - nx: 1
[18:00:57.609] - relay: TRUE
[18:00:57.609] - stdout: TRUE
[18:00:57.609] - signal: TRUE
[18:00:57.610] - resignal: FALSE
[18:00:57.610] - force: TRUE
[18:00:57.610] - relayed: [n=1] FALSE
[18:00:57.610] - queued futures: [n=1] FALSE
[18:00:57.610]  - until=1
[18:00:57.611]  - relaying element #1
[18:00:57.611] - relayed: [n=1] TRUE
[18:00:57.611] - queued futures: [n=1] TRUE
[18:00:57.611] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.612]  length: 0 (resolved future 1)
[18:00:57.612] Relaying remaining futures
[18:00:57.612] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.612] - nx: 1
[18:00:57.612] - relay: TRUE
[18:00:57.612] - stdout: TRUE
[18:00:57.613] - signal: TRUE
[18:00:57.613] - resignal: FALSE
[18:00:57.613] - force: TRUE
[18:00:57.613] - relayed: [n=1] TRUE
[18:00:57.613] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.614] - relayed: [n=1] TRUE
[18:00:57.614] - queued futures: [n=1] TRUE
[18:00:57.614] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.614] resolve() on list ... DONE
[18:00:57.615]  - Number of value chunks collected: 1
[18:00:57.615] Resolving 1 futures (chunks) ... DONE
[18:00:57.615] Reducing values from 1 chunks ...
[18:00:57.615]  - Number of values collected after concatenation: 3
[18:00:57.616]  - Number of values expected: 3
[18:00:57.616] Reducing values from 1 chunks ... DONE
[18:00:57.616] future_mapply() ... DONE
[18:00:57.616] future_mapply() ...
[18:00:57.619] Number of chunks: 5
[18:00:57.620] getGlobalsAndPackagesXApply() ...
[18:00:57.620]  - future.globals: TRUE
[18:00:57.620] getGlobalsAndPackages() ...
[18:00:57.620] Searching for globals...
[18:00:57.623] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:00:57.623] Searching for globals ... DONE
[18:00:57.623] Resolving globals: FALSE
[18:00:57.624] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:00:57.625] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:00:57.625] - globals: [1] ‘FUN’
[18:00:57.625] 
[18:00:57.625] getGlobalsAndPackages() ... DONE
[18:00:57.625]  - globals found/used: [n=1] ‘FUN’
[18:00:57.626]  - needed namespaces: [n=0] 
[18:00:57.626] Finding globals ... DONE
[18:00:57.626] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.626] List of 2
[18:00:57.626]  $ ...future.FUN:function (C, k)  
[18:00:57.626]  $ MoreArgs     : NULL
[18:00:57.626]  - attr(*, "where")=List of 2
[18:00:57.626]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.626]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.626]  - attr(*, "resolved")= logi FALSE
[18:00:57.626]  - attr(*, "total_size")= num NA
[18:00:57.631] Packages to be attached in all futures: [n=0] 
[18:00:57.631] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.632] Number of futures (= number of chunks): 5
[18:00:57.632] Launching 5 futures (chunks) ...
[18:00:57.632] Chunk #1 of 5 ...
[18:00:57.632]  - Finding globals in '...' for chunk #1 ...
[18:00:57.633] getGlobalsAndPackages() ...
[18:00:57.633] Searching for globals...
[18:00:57.636] 
[18:00:57.636] Searching for globals ... DONE
[18:00:57.637] - globals: [0] <none>
[18:00:57.637] getGlobalsAndPackages() ... DONE
[18:00:57.637]    + additional globals found: [n=0] 
[18:00:57.637]    + additional namespaces needed: [n=0] 
[18:00:57.637]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.637]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:00:57.638]  - seeds: <none>
[18:00:57.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.638] getGlobalsAndPackages() ...
[18:00:57.638] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.639] Resolving globals: FALSE
[18:00:57.639] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:00:57.640] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.641] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.641] 
[18:00:57.641] getGlobalsAndPackages() ... DONE
[18:00:57.642] run() for ‘Future’ ...
[18:00:57.642] - state: ‘created’
[18:00:57.642] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.643] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.643]   - Field: ‘label’
[18:00:57.643]   - Field: ‘local’
[18:00:57.643]   - Field: ‘owner’
[18:00:57.644]   - Field: ‘envir’
[18:00:57.644]   - Field: ‘packages’
[18:00:57.644]   - Field: ‘gc’
[18:00:57.644]   - Field: ‘conditions’
[18:00:57.644]   - Field: ‘expr’
[18:00:57.645]   - Field: ‘uuid’
[18:00:57.645]   - Field: ‘seed’
[18:00:57.645]   - Field: ‘version’
[18:00:57.645]   - Field: ‘result’
[18:00:57.645]   - Field: ‘asynchronous’
[18:00:57.646]   - Field: ‘calls’
[18:00:57.646]   - Field: ‘globals’
[18:00:57.646]   - Field: ‘stdout’
[18:00:57.646]   - Field: ‘earlySignal’
[18:00:57.646]   - Field: ‘lazy’
[18:00:57.646]   - Field: ‘state’
[18:00:57.647] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.647] - Launch lazy future ...
[18:00:57.647] Packages needed by the future expression (n = 0): <none>
[18:00:57.647] Packages needed by future strategies (n = 0): <none>
[18:00:57.648] {
[18:00:57.648]     {
[18:00:57.648]         {
[18:00:57.648]             ...future.startTime <- base::Sys.time()
[18:00:57.648]             {
[18:00:57.648]                 {
[18:00:57.648]                   {
[18:00:57.648]                     base::local({
[18:00:57.648]                       has_future <- base::requireNamespace("future", 
[18:00:57.648]                         quietly = TRUE)
[18:00:57.648]                       if (has_future) {
[18:00:57.648]                         ns <- base::getNamespace("future")
[18:00:57.648]                         version <- ns[[".package"]][["version"]]
[18:00:57.648]                         if (is.null(version)) 
[18:00:57.648]                           version <- utils::packageVersion("future")
[18:00:57.648]                       }
[18:00:57.648]                       else {
[18:00:57.648]                         version <- NULL
[18:00:57.648]                       }
[18:00:57.648]                       if (!has_future || version < "1.8.0") {
[18:00:57.648]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.648]                           "", base::R.version$version.string), 
[18:00:57.648]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.648]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.648]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.648]                             "release", "version")], collapse = " "), 
[18:00:57.648]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.648]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.648]                           info)
[18:00:57.648]                         info <- base::paste(info, collapse = "; ")
[18:00:57.648]                         if (!has_future) {
[18:00:57.648]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.648]                             info)
[18:00:57.648]                         }
[18:00:57.648]                         else {
[18:00:57.648]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.648]                             info, version)
[18:00:57.648]                         }
[18:00:57.648]                         base::stop(msg)
[18:00:57.648]                       }
[18:00:57.648]                     })
[18:00:57.648]                   }
[18:00:57.648]                   ...future.strategy.old <- future::plan("list")
[18:00:57.648]                   options(future.plan = NULL)
[18:00:57.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.648]                 }
[18:00:57.648]                 ...future.workdir <- getwd()
[18:00:57.648]             }
[18:00:57.648]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.648]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.648]         }
[18:00:57.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.648]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:00:57.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.648]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.648]             base::names(...future.oldOptions))
[18:00:57.648]     }
[18:00:57.648]     if (FALSE) {
[18:00:57.648]     }
[18:00:57.648]     else {
[18:00:57.648]         if (TRUE) {
[18:00:57.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.648]                 open = "w")
[18:00:57.648]         }
[18:00:57.648]         else {
[18:00:57.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.648]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.648]         }
[18:00:57.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.648]             base::sink(type = "output", split = FALSE)
[18:00:57.648]             base::close(...future.stdout)
[18:00:57.648]         }, add = TRUE)
[18:00:57.648]     }
[18:00:57.648]     ...future.frame <- base::sys.nframe()
[18:00:57.648]     ...future.conditions <- base::list()
[18:00:57.648]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.648]     if (FALSE) {
[18:00:57.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.648]     }
[18:00:57.648]     ...future.result <- base::tryCatch({
[18:00:57.648]         base::withCallingHandlers({
[18:00:57.648]             ...future.value <- base::withVisible(base::local({
[18:00:57.648]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.648]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.648]                   ...future.globals.maxSize)) {
[18:00:57.648]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.648]                   on.exit(options(oopts), add = TRUE)
[18:00:57.648]                 }
[18:00:57.648]                 {
[18:00:57.648]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.648]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.648]                     USE.NAMES = FALSE)
[18:00:57.648]                   do.call(mapply, args = args)
[18:00:57.648]                 }
[18:00:57.648]             }))
[18:00:57.648]             future::FutureResult(value = ...future.value$value, 
[18:00:57.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.648]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.648]                     ...future.globalenv.names))
[18:00:57.648]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.648]         }, condition = base::local({
[18:00:57.648]             c <- base::c
[18:00:57.648]             inherits <- base::inherits
[18:00:57.648]             invokeRestart <- base::invokeRestart
[18:00:57.648]             length <- base::length
[18:00:57.648]             list <- base::list
[18:00:57.648]             seq.int <- base::seq.int
[18:00:57.648]             signalCondition <- base::signalCondition
[18:00:57.648]             sys.calls <- base::sys.calls
[18:00:57.648]             `[[` <- base::`[[`
[18:00:57.648]             `+` <- base::`+`
[18:00:57.648]             `<<-` <- base::`<<-`
[18:00:57.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.648]                   3L)]
[18:00:57.648]             }
[18:00:57.648]             function(cond) {
[18:00:57.648]                 is_error <- inherits(cond, "error")
[18:00:57.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.648]                   NULL)
[18:00:57.648]                 if (is_error) {
[18:00:57.648]                   sessionInformation <- function() {
[18:00:57.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.648]                       search = base::search(), system = base::Sys.info())
[18:00:57.648]                   }
[18:00:57.648]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.648]                     cond$call), session = sessionInformation(), 
[18:00:57.648]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.648]                   signalCondition(cond)
[18:00:57.648]                 }
[18:00:57.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.648]                 "immediateCondition"))) {
[18:00:57.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.648]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.648]                   if (TRUE && !signal) {
[18:00:57.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.648]                     {
[18:00:57.648]                       inherits <- base::inherits
[18:00:57.648]                       invokeRestart <- base::invokeRestart
[18:00:57.648]                       is.null <- base::is.null
[18:00:57.648]                       muffled <- FALSE
[18:00:57.648]                       if (inherits(cond, "message")) {
[18:00:57.648]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.648]                         if (muffled) 
[18:00:57.648]                           invokeRestart("muffleMessage")
[18:00:57.648]                       }
[18:00:57.648]                       else if (inherits(cond, "warning")) {
[18:00:57.648]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.648]                         if (muffled) 
[18:00:57.648]                           invokeRestart("muffleWarning")
[18:00:57.648]                       }
[18:00:57.648]                       else if (inherits(cond, "condition")) {
[18:00:57.648]                         if (!is.null(pattern)) {
[18:00:57.648]                           computeRestarts <- base::computeRestarts
[18:00:57.648]                           grepl <- base::grepl
[18:00:57.648]                           restarts <- computeRestarts(cond)
[18:00:57.648]                           for (restart in restarts) {
[18:00:57.648]                             name <- restart$name
[18:00:57.648]                             if (is.null(name)) 
[18:00:57.648]                               next
[18:00:57.648]                             if (!grepl(pattern, name)) 
[18:00:57.648]                               next
[18:00:57.648]                             invokeRestart(restart)
[18:00:57.648]                             muffled <- TRUE
[18:00:57.648]                             break
[18:00:57.648]                           }
[18:00:57.648]                         }
[18:00:57.648]                       }
[18:00:57.648]                       invisible(muffled)
[18:00:57.648]                     }
[18:00:57.648]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.648]                   }
[18:00:57.648]                 }
[18:00:57.648]                 else {
[18:00:57.648]                   if (TRUE) {
[18:00:57.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.648]                     {
[18:00:57.648]                       inherits <- base::inherits
[18:00:57.648]                       invokeRestart <- base::invokeRestart
[18:00:57.648]                       is.null <- base::is.null
[18:00:57.648]                       muffled <- FALSE
[18:00:57.648]                       if (inherits(cond, "message")) {
[18:00:57.648]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.648]                         if (muffled) 
[18:00:57.648]                           invokeRestart("muffleMessage")
[18:00:57.648]                       }
[18:00:57.648]                       else if (inherits(cond, "warning")) {
[18:00:57.648]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.648]                         if (muffled) 
[18:00:57.648]                           invokeRestart("muffleWarning")
[18:00:57.648]                       }
[18:00:57.648]                       else if (inherits(cond, "condition")) {
[18:00:57.648]                         if (!is.null(pattern)) {
[18:00:57.648]                           computeRestarts <- base::computeRestarts
[18:00:57.648]                           grepl <- base::grepl
[18:00:57.648]                           restarts <- computeRestarts(cond)
[18:00:57.648]                           for (restart in restarts) {
[18:00:57.648]                             name <- restart$name
[18:00:57.648]                             if (is.null(name)) 
[18:00:57.648]                               next
[18:00:57.648]                             if (!grepl(pattern, name)) 
[18:00:57.648]                               next
[18:00:57.648]                             invokeRestart(restart)
[18:00:57.648]                             muffled <- TRUE
[18:00:57.648]                             break
[18:00:57.648]                           }
[18:00:57.648]                         }
[18:00:57.648]                       }
[18:00:57.648]                       invisible(muffled)
[18:00:57.648]                     }
[18:00:57.648]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.648]                   }
[18:00:57.648]                 }
[18:00:57.648]             }
[18:00:57.648]         }))
[18:00:57.648]     }, error = function(ex) {
[18:00:57.648]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.648]                 ...future.rng), started = ...future.startTime, 
[18:00:57.648]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.648]             version = "1.8"), class = "FutureResult")
[18:00:57.648]     }, finally = {
[18:00:57.648]         if (!identical(...future.workdir, getwd())) 
[18:00:57.648]             setwd(...future.workdir)
[18:00:57.648]         {
[18:00:57.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.648]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.648]             }
[18:00:57.648]             base::options(...future.oldOptions)
[18:00:57.648]             if (.Platform$OS.type == "windows") {
[18:00:57.648]                 old_names <- names(...future.oldEnvVars)
[18:00:57.648]                 envs <- base::Sys.getenv()
[18:00:57.648]                 names <- names(envs)
[18:00:57.648]                 common <- intersect(names, old_names)
[18:00:57.648]                 added <- setdiff(names, old_names)
[18:00:57.648]                 removed <- setdiff(old_names, names)
[18:00:57.648]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.648]                   envs[common]]
[18:00:57.648]                 NAMES <- toupper(changed)
[18:00:57.648]                 args <- list()
[18:00:57.648]                 for (kk in seq_along(NAMES)) {
[18:00:57.648]                   name <- changed[[kk]]
[18:00:57.648]                   NAME <- NAMES[[kk]]
[18:00:57.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.648]                     next
[18:00:57.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.648]                 }
[18:00:57.648]                 NAMES <- toupper(added)
[18:00:57.648]                 for (kk in seq_along(NAMES)) {
[18:00:57.648]                   name <- added[[kk]]
[18:00:57.648]                   NAME <- NAMES[[kk]]
[18:00:57.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.648]                     next
[18:00:57.648]                   args[[name]] <- ""
[18:00:57.648]                 }
[18:00:57.648]                 NAMES <- toupper(removed)
[18:00:57.648]                 for (kk in seq_along(NAMES)) {
[18:00:57.648]                   name <- removed[[kk]]
[18:00:57.648]                   NAME <- NAMES[[kk]]
[18:00:57.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.648]                     next
[18:00:57.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.648]                 }
[18:00:57.648]                 if (length(args) > 0) 
[18:00:57.648]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.648]             }
[18:00:57.648]             else {
[18:00:57.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.648]             }
[18:00:57.648]             {
[18:00:57.648]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.648]                   0L) {
[18:00:57.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.648]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.648]                   base::options(opts)
[18:00:57.648]                 }
[18:00:57.648]                 {
[18:00:57.648]                   {
[18:00:57.648]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.648]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.648]                     1423455687L), envir = base::globalenv(), 
[18:00:57.648]                       inherits = FALSE)
[18:00:57.648]                     NULL
[18:00:57.648]                   }
[18:00:57.648]                   options(future.plan = NULL)
[18:00:57.648]                   if (is.na(NA_character_)) 
[18:00:57.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.648]                     .init = FALSE)
[18:00:57.648]                 }
[18:00:57.648]             }
[18:00:57.648]         }
[18:00:57.648]     })
[18:00:57.648]     if (TRUE) {
[18:00:57.648]         base::sink(type = "output", split = FALSE)
[18:00:57.648]         if (TRUE) {
[18:00:57.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.648]         }
[18:00:57.648]         else {
[18:00:57.648]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.648]         }
[18:00:57.648]         base::close(...future.stdout)
[18:00:57.648]         ...future.stdout <- NULL
[18:00:57.648]     }
[18:00:57.648]     ...future.result$conditions <- ...future.conditions
[18:00:57.648]     ...future.result$finished <- base::Sys.time()
[18:00:57.648]     ...future.result
[18:00:57.648] }
[18:00:57.652] assign_globals() ...
[18:00:57.652] List of 5
[18:00:57.652]  $ ...future.FUN            :function (C, k)  
[18:00:57.652]  $ MoreArgs                 : NULL
[18:00:57.652]  $ ...future.elements_ii    :List of 2
[18:00:57.652]   ..$ :List of 1
[18:00:57.652]   .. ..$ : chr "A"
[18:00:57.652]   ..$ :List of 1
[18:00:57.652]   .. ..$ : int 5
[18:00:57.652]  $ ...future.seeds_ii       : NULL
[18:00:57.652]  $ ...future.globals.maxSize: NULL
[18:00:57.652]  - attr(*, "where")=List of 5
[18:00:57.652]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.652]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.652]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.652]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.652]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.652]  - attr(*, "resolved")= logi FALSE
[18:00:57.652]  - attr(*, "total_size")= num 3488
[18:00:57.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.652]  - attr(*, "already-done")= logi TRUE
[18:00:57.662] - reassign environment for ‘...future.FUN’
[18:00:57.662] - copied ‘...future.FUN’ to environment
[18:00:57.662] - copied ‘MoreArgs’ to environment
[18:00:57.662] - copied ‘...future.elements_ii’ to environment
[18:00:57.662] - copied ‘...future.seeds_ii’ to environment
[18:00:57.663] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.663] assign_globals() ... done
[18:00:57.663] plan(): Setting new future strategy stack:
[18:00:57.664] List of future strategies:
[18:00:57.664] 1. sequential:
[18:00:57.664]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.664]    - tweaked: FALSE
[18:00:57.664]    - call: NULL
[18:00:57.664] plan(): nbrOfWorkers() = 1
[18:00:57.666] plan(): Setting new future strategy stack:
[18:00:57.666] List of future strategies:
[18:00:57.666] 1. sequential:
[18:00:57.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.666]    - tweaked: FALSE
[18:00:57.666]    - call: plan(strategy)
[18:00:57.667] plan(): nbrOfWorkers() = 1
[18:00:57.667] SequentialFuture started (and completed)
[18:00:57.668] - Launch lazy future ... done
[18:00:57.668] run() for ‘SequentialFuture’ ... done
[18:00:57.668] Created future:
[18:00:57.668] SequentialFuture:
[18:00:57.668] Label: ‘future_mapply-1’
[18:00:57.668] Expression:
[18:00:57.668] {
[18:00:57.668]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.668]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.668]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.668]         on.exit(options(oopts), add = TRUE)
[18:00:57.668]     }
[18:00:57.668]     {
[18:00:57.668]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.668]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.668]         do.call(mapply, args = args)
[18:00:57.668]     }
[18:00:57.668] }
[18:00:57.668] Lazy evaluation: FALSE
[18:00:57.668] Asynchronous evaluation: FALSE
[18:00:57.668] Local evaluation: TRUE
[18:00:57.668] Environment: R_GlobalEnv
[18:00:57.668] Capture standard output: TRUE
[18:00:57.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.668] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.668] Packages: <none>
[18:00:57.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.668] Resolved: TRUE
[18:00:57.668] Value: 112 bytes of class ‘list’
[18:00:57.668] Early signaling: FALSE
[18:00:57.668] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.668] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.670] Chunk #1 of 5 ... DONE
[18:00:57.670] Chunk #2 of 5 ...
[18:00:57.670]  - Finding globals in '...' for chunk #2 ...
[18:00:57.671] getGlobalsAndPackages() ...
[18:00:57.671] Searching for globals...
[18:00:57.671] 
[18:00:57.672] Searching for globals ... DONE
[18:00:57.672] - globals: [0] <none>
[18:00:57.672] getGlobalsAndPackages() ... DONE
[18:00:57.672]    + additional globals found: [n=0] 
[18:00:57.672]    + additional namespaces needed: [n=0] 
[18:00:57.673]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:57.673]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:00:57.673]  - seeds: <none>
[18:00:57.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.673] getGlobalsAndPackages() ...
[18:00:57.674] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.674] Resolving globals: FALSE
[18:00:57.675] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:00:57.676] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.676] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.676] 
[18:00:57.676] getGlobalsAndPackages() ... DONE
[18:00:57.677] run() for ‘Future’ ...
[18:00:57.677] - state: ‘created’
[18:00:57.677] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.678] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.678]   - Field: ‘label’
[18:00:57.678]   - Field: ‘local’
[18:00:57.679]   - Field: ‘owner’
[18:00:57.679]   - Field: ‘envir’
[18:00:57.679]   - Field: ‘packages’
[18:00:57.679]   - Field: ‘gc’
[18:00:57.679]   - Field: ‘conditions’
[18:00:57.680]   - Field: ‘expr’
[18:00:57.680]   - Field: ‘uuid’
[18:00:57.680]   - Field: ‘seed’
[18:00:57.680]   - Field: ‘version’
[18:00:57.680]   - Field: ‘result’
[18:00:57.681]   - Field: ‘asynchronous’
[18:00:57.681]   - Field: ‘calls’
[18:00:57.681]   - Field: ‘globals’
[18:00:57.681]   - Field: ‘stdout’
[18:00:57.681]   - Field: ‘earlySignal’
[18:00:57.682]   - Field: ‘lazy’
[18:00:57.682]   - Field: ‘state’
[18:00:57.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.682] - Launch lazy future ...
[18:00:57.683] Packages needed by the future expression (n = 0): <none>
[18:00:57.683] Packages needed by future strategies (n = 0): <none>
[18:00:57.684] {
[18:00:57.684]     {
[18:00:57.684]         {
[18:00:57.684]             ...future.startTime <- base::Sys.time()
[18:00:57.684]             {
[18:00:57.684]                 {
[18:00:57.684]                   {
[18:00:57.684]                     base::local({
[18:00:57.684]                       has_future <- base::requireNamespace("future", 
[18:00:57.684]                         quietly = TRUE)
[18:00:57.684]                       if (has_future) {
[18:00:57.684]                         ns <- base::getNamespace("future")
[18:00:57.684]                         version <- ns[[".package"]][["version"]]
[18:00:57.684]                         if (is.null(version)) 
[18:00:57.684]                           version <- utils::packageVersion("future")
[18:00:57.684]                       }
[18:00:57.684]                       else {
[18:00:57.684]                         version <- NULL
[18:00:57.684]                       }
[18:00:57.684]                       if (!has_future || version < "1.8.0") {
[18:00:57.684]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.684]                           "", base::R.version$version.string), 
[18:00:57.684]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.684]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.684]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.684]                             "release", "version")], collapse = " "), 
[18:00:57.684]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.684]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.684]                           info)
[18:00:57.684]                         info <- base::paste(info, collapse = "; ")
[18:00:57.684]                         if (!has_future) {
[18:00:57.684]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.684]                             info)
[18:00:57.684]                         }
[18:00:57.684]                         else {
[18:00:57.684]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.684]                             info, version)
[18:00:57.684]                         }
[18:00:57.684]                         base::stop(msg)
[18:00:57.684]                       }
[18:00:57.684]                     })
[18:00:57.684]                   }
[18:00:57.684]                   ...future.strategy.old <- future::plan("list")
[18:00:57.684]                   options(future.plan = NULL)
[18:00:57.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.684]                 }
[18:00:57.684]                 ...future.workdir <- getwd()
[18:00:57.684]             }
[18:00:57.684]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.684]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.684]         }
[18:00:57.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.684]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:00:57.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.684]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.684]             base::names(...future.oldOptions))
[18:00:57.684]     }
[18:00:57.684]     if (FALSE) {
[18:00:57.684]     }
[18:00:57.684]     else {
[18:00:57.684]         if (TRUE) {
[18:00:57.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.684]                 open = "w")
[18:00:57.684]         }
[18:00:57.684]         else {
[18:00:57.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.684]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.684]         }
[18:00:57.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.684]             base::sink(type = "output", split = FALSE)
[18:00:57.684]             base::close(...future.stdout)
[18:00:57.684]         }, add = TRUE)
[18:00:57.684]     }
[18:00:57.684]     ...future.frame <- base::sys.nframe()
[18:00:57.684]     ...future.conditions <- base::list()
[18:00:57.684]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.684]     if (FALSE) {
[18:00:57.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.684]     }
[18:00:57.684]     ...future.result <- base::tryCatch({
[18:00:57.684]         base::withCallingHandlers({
[18:00:57.684]             ...future.value <- base::withVisible(base::local({
[18:00:57.684]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.684]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.684]                   ...future.globals.maxSize)) {
[18:00:57.684]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.684]                   on.exit(options(oopts), add = TRUE)
[18:00:57.684]                 }
[18:00:57.684]                 {
[18:00:57.684]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.684]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.684]                     USE.NAMES = FALSE)
[18:00:57.684]                   do.call(mapply, args = args)
[18:00:57.684]                 }
[18:00:57.684]             }))
[18:00:57.684]             future::FutureResult(value = ...future.value$value, 
[18:00:57.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.684]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.684]                     ...future.globalenv.names))
[18:00:57.684]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.684]         }, condition = base::local({
[18:00:57.684]             c <- base::c
[18:00:57.684]             inherits <- base::inherits
[18:00:57.684]             invokeRestart <- base::invokeRestart
[18:00:57.684]             length <- base::length
[18:00:57.684]             list <- base::list
[18:00:57.684]             seq.int <- base::seq.int
[18:00:57.684]             signalCondition <- base::signalCondition
[18:00:57.684]             sys.calls <- base::sys.calls
[18:00:57.684]             `[[` <- base::`[[`
[18:00:57.684]             `+` <- base::`+`
[18:00:57.684]             `<<-` <- base::`<<-`
[18:00:57.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.684]                   3L)]
[18:00:57.684]             }
[18:00:57.684]             function(cond) {
[18:00:57.684]                 is_error <- inherits(cond, "error")
[18:00:57.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.684]                   NULL)
[18:00:57.684]                 if (is_error) {
[18:00:57.684]                   sessionInformation <- function() {
[18:00:57.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.684]                       search = base::search(), system = base::Sys.info())
[18:00:57.684]                   }
[18:00:57.684]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.684]                     cond$call), session = sessionInformation(), 
[18:00:57.684]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.684]                   signalCondition(cond)
[18:00:57.684]                 }
[18:00:57.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.684]                 "immediateCondition"))) {
[18:00:57.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.684]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.684]                   if (TRUE && !signal) {
[18:00:57.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.684]                     {
[18:00:57.684]                       inherits <- base::inherits
[18:00:57.684]                       invokeRestart <- base::invokeRestart
[18:00:57.684]                       is.null <- base::is.null
[18:00:57.684]                       muffled <- FALSE
[18:00:57.684]                       if (inherits(cond, "message")) {
[18:00:57.684]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.684]                         if (muffled) 
[18:00:57.684]                           invokeRestart("muffleMessage")
[18:00:57.684]                       }
[18:00:57.684]                       else if (inherits(cond, "warning")) {
[18:00:57.684]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.684]                         if (muffled) 
[18:00:57.684]                           invokeRestart("muffleWarning")
[18:00:57.684]                       }
[18:00:57.684]                       else if (inherits(cond, "condition")) {
[18:00:57.684]                         if (!is.null(pattern)) {
[18:00:57.684]                           computeRestarts <- base::computeRestarts
[18:00:57.684]                           grepl <- base::grepl
[18:00:57.684]                           restarts <- computeRestarts(cond)
[18:00:57.684]                           for (restart in restarts) {
[18:00:57.684]                             name <- restart$name
[18:00:57.684]                             if (is.null(name)) 
[18:00:57.684]                               next
[18:00:57.684]                             if (!grepl(pattern, name)) 
[18:00:57.684]                               next
[18:00:57.684]                             invokeRestart(restart)
[18:00:57.684]                             muffled <- TRUE
[18:00:57.684]                             break
[18:00:57.684]                           }
[18:00:57.684]                         }
[18:00:57.684]                       }
[18:00:57.684]                       invisible(muffled)
[18:00:57.684]                     }
[18:00:57.684]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.684]                   }
[18:00:57.684]                 }
[18:00:57.684]                 else {
[18:00:57.684]                   if (TRUE) {
[18:00:57.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.684]                     {
[18:00:57.684]                       inherits <- base::inherits
[18:00:57.684]                       invokeRestart <- base::invokeRestart
[18:00:57.684]                       is.null <- base::is.null
[18:00:57.684]                       muffled <- FALSE
[18:00:57.684]                       if (inherits(cond, "message")) {
[18:00:57.684]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.684]                         if (muffled) 
[18:00:57.684]                           invokeRestart("muffleMessage")
[18:00:57.684]                       }
[18:00:57.684]                       else if (inherits(cond, "warning")) {
[18:00:57.684]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.684]                         if (muffled) 
[18:00:57.684]                           invokeRestart("muffleWarning")
[18:00:57.684]                       }
[18:00:57.684]                       else if (inherits(cond, "condition")) {
[18:00:57.684]                         if (!is.null(pattern)) {
[18:00:57.684]                           computeRestarts <- base::computeRestarts
[18:00:57.684]                           grepl <- base::grepl
[18:00:57.684]                           restarts <- computeRestarts(cond)
[18:00:57.684]                           for (restart in restarts) {
[18:00:57.684]                             name <- restart$name
[18:00:57.684]                             if (is.null(name)) 
[18:00:57.684]                               next
[18:00:57.684]                             if (!grepl(pattern, name)) 
[18:00:57.684]                               next
[18:00:57.684]                             invokeRestart(restart)
[18:00:57.684]                             muffled <- TRUE
[18:00:57.684]                             break
[18:00:57.684]                           }
[18:00:57.684]                         }
[18:00:57.684]                       }
[18:00:57.684]                       invisible(muffled)
[18:00:57.684]                     }
[18:00:57.684]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.684]                   }
[18:00:57.684]                 }
[18:00:57.684]             }
[18:00:57.684]         }))
[18:00:57.684]     }, error = function(ex) {
[18:00:57.684]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.684]                 ...future.rng), started = ...future.startTime, 
[18:00:57.684]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.684]             version = "1.8"), class = "FutureResult")
[18:00:57.684]     }, finally = {
[18:00:57.684]         if (!identical(...future.workdir, getwd())) 
[18:00:57.684]             setwd(...future.workdir)
[18:00:57.684]         {
[18:00:57.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.684]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.684]             }
[18:00:57.684]             base::options(...future.oldOptions)
[18:00:57.684]             if (.Platform$OS.type == "windows") {
[18:00:57.684]                 old_names <- names(...future.oldEnvVars)
[18:00:57.684]                 envs <- base::Sys.getenv()
[18:00:57.684]                 names <- names(envs)
[18:00:57.684]                 common <- intersect(names, old_names)
[18:00:57.684]                 added <- setdiff(names, old_names)
[18:00:57.684]                 removed <- setdiff(old_names, names)
[18:00:57.684]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.684]                   envs[common]]
[18:00:57.684]                 NAMES <- toupper(changed)
[18:00:57.684]                 args <- list()
[18:00:57.684]                 for (kk in seq_along(NAMES)) {
[18:00:57.684]                   name <- changed[[kk]]
[18:00:57.684]                   NAME <- NAMES[[kk]]
[18:00:57.684]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.684]                     next
[18:00:57.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.684]                 }
[18:00:57.684]                 NAMES <- toupper(added)
[18:00:57.684]                 for (kk in seq_along(NAMES)) {
[18:00:57.684]                   name <- added[[kk]]
[18:00:57.684]                   NAME <- NAMES[[kk]]
[18:00:57.684]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.684]                     next
[18:00:57.684]                   args[[name]] <- ""
[18:00:57.684]                 }
[18:00:57.684]                 NAMES <- toupper(removed)
[18:00:57.684]                 for (kk in seq_along(NAMES)) {
[18:00:57.684]                   name <- removed[[kk]]
[18:00:57.684]                   NAME <- NAMES[[kk]]
[18:00:57.684]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.684]                     next
[18:00:57.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.684]                 }
[18:00:57.684]                 if (length(args) > 0) 
[18:00:57.684]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.684]             }
[18:00:57.684]             else {
[18:00:57.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.684]             }
[18:00:57.684]             {
[18:00:57.684]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.684]                   0L) {
[18:00:57.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.684]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.684]                   base::options(opts)
[18:00:57.684]                 }
[18:00:57.684]                 {
[18:00:57.684]                   {
[18:00:57.684]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.684]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.684]                     1423455687L), envir = base::globalenv(), 
[18:00:57.684]                       inherits = FALSE)
[18:00:57.684]                     NULL
[18:00:57.684]                   }
[18:00:57.684]                   options(future.plan = NULL)
[18:00:57.684]                   if (is.na(NA_character_)) 
[18:00:57.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.684]                     .init = FALSE)
[18:00:57.684]                 }
[18:00:57.684]             }
[18:00:57.684]         }
[18:00:57.684]     })
[18:00:57.684]     if (TRUE) {
[18:00:57.684]         base::sink(type = "output", split = FALSE)
[18:00:57.684]         if (TRUE) {
[18:00:57.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.684]         }
[18:00:57.684]         else {
[18:00:57.684]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.684]         }
[18:00:57.684]         base::close(...future.stdout)
[18:00:57.684]         ...future.stdout <- NULL
[18:00:57.684]     }
[18:00:57.684]     ...future.result$conditions <- ...future.conditions
[18:00:57.684]     ...future.result$finished <- base::Sys.time()
[18:00:57.684]     ...future.result
[18:00:57.684] }
[18:00:57.689] assign_globals() ...
[18:00:57.690] List of 5
[18:00:57.690]  $ ...future.FUN            :function (C, k)  
[18:00:57.690]  $ MoreArgs                 : NULL
[18:00:57.690]  $ ...future.elements_ii    :List of 2
[18:00:57.690]   ..$ :List of 1
[18:00:57.690]   .. ..$ : chr "B"
[18:00:57.690]   ..$ :List of 1
[18:00:57.690]   .. ..$ : int 4
[18:00:57.690]  $ ...future.seeds_ii       : NULL
[18:00:57.690]  $ ...future.globals.maxSize: NULL
[18:00:57.690]  - attr(*, "where")=List of 5
[18:00:57.690]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.690]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.690]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.690]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.690]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.690]  - attr(*, "resolved")= logi FALSE
[18:00:57.690]  - attr(*, "total_size")= num 3488
[18:00:57.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.690]  - attr(*, "already-done")= logi TRUE
[18:00:57.699] - reassign environment for ‘...future.FUN’
[18:00:57.700] - copied ‘...future.FUN’ to environment
[18:00:57.700] - copied ‘MoreArgs’ to environment
[18:00:57.700] - copied ‘...future.elements_ii’ to environment
[18:00:57.700] - copied ‘...future.seeds_ii’ to environment
[18:00:57.700] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.701] assign_globals() ... done
[18:00:57.701] plan(): Setting new future strategy stack:
[18:00:57.701] List of future strategies:
[18:00:57.701] 1. sequential:
[18:00:57.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.701]    - tweaked: FALSE
[18:00:57.701]    - call: NULL
[18:00:57.702] plan(): nbrOfWorkers() = 1
[18:00:57.704] plan(): Setting new future strategy stack:
[18:00:57.704] List of future strategies:
[18:00:57.704] 1. sequential:
[18:00:57.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.704]    - tweaked: FALSE
[18:00:57.704]    - call: plan(strategy)
[18:00:57.705] plan(): nbrOfWorkers() = 1
[18:00:57.706] SequentialFuture started (and completed)
[18:00:57.706] - Launch lazy future ... done
[18:00:57.706] run() for ‘SequentialFuture’ ... done
[18:00:57.706] Created future:
[18:00:57.706] SequentialFuture:
[18:00:57.706] Label: ‘future_mapply-2’
[18:00:57.706] Expression:
[18:00:57.706] {
[18:00:57.706]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.706]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.706]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.706]         on.exit(options(oopts), add = TRUE)
[18:00:57.706]     }
[18:00:57.706]     {
[18:00:57.706]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.706]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.706]         do.call(mapply, args = args)
[18:00:57.706]     }
[18:00:57.706] }
[18:00:57.706] Lazy evaluation: FALSE
[18:00:57.706] Asynchronous evaluation: FALSE
[18:00:57.706] Local evaluation: TRUE
[18:00:57.706] Environment: R_GlobalEnv
[18:00:57.706] Capture standard output: TRUE
[18:00:57.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.706] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.706] Packages: <none>
[18:00:57.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.706] Resolved: TRUE
[18:00:57.706] Value: 112 bytes of class ‘list’
[18:00:57.706] Early signaling: FALSE
[18:00:57.706] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.706] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.708] Chunk #2 of 5 ... DONE
[18:00:57.708] Chunk #3 of 5 ...
[18:00:57.709]  - Finding globals in '...' for chunk #3 ...
[18:00:57.709] getGlobalsAndPackages() ...
[18:00:57.709] Searching for globals...
[18:00:57.710] 
[18:00:57.710] Searching for globals ... DONE
[18:00:57.710] - globals: [0] <none>
[18:00:57.710] getGlobalsAndPackages() ... DONE
[18:00:57.710]    + additional globals found: [n=0] 
[18:00:57.711]    + additional namespaces needed: [n=0] 
[18:00:57.711]  - Finding globals in '...' for chunk #3 ... DONE
[18:00:57.711]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:00:57.711]  - seeds: <none>
[18:00:57.711]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.712] getGlobalsAndPackages() ...
[18:00:57.712] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.712] Resolving globals: FALSE
[18:00:57.713] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:00:57.714] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.714] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.714] 
[18:00:57.715] getGlobalsAndPackages() ... DONE
[18:00:57.715] run() for ‘Future’ ...
[18:00:57.715] - state: ‘created’
[18:00:57.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.717]   - Field: ‘label’
[18:00:57.717]   - Field: ‘local’
[18:00:57.717]   - Field: ‘owner’
[18:00:57.717]   - Field: ‘envir’
[18:00:57.717]   - Field: ‘packages’
[18:00:57.718]   - Field: ‘gc’
[18:00:57.718]   - Field: ‘conditions’
[18:00:57.718]   - Field: ‘expr’
[18:00:57.718]   - Field: ‘uuid’
[18:00:57.718]   - Field: ‘seed’
[18:00:57.719]   - Field: ‘version’
[18:00:57.719]   - Field: ‘result’
[18:00:57.719]   - Field: ‘asynchronous’
[18:00:57.719]   - Field: ‘calls’
[18:00:57.719]   - Field: ‘globals’
[18:00:57.719]   - Field: ‘stdout’
[18:00:57.720]   - Field: ‘earlySignal’
[18:00:57.720]   - Field: ‘lazy’
[18:00:57.720]   - Field: ‘state’
[18:00:57.720] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.720] - Launch lazy future ...
[18:00:57.721] Packages needed by the future expression (n = 0): <none>
[18:00:57.721] Packages needed by future strategies (n = 0): <none>
[18:00:57.722] {
[18:00:57.722]     {
[18:00:57.722]         {
[18:00:57.722]             ...future.startTime <- base::Sys.time()
[18:00:57.722]             {
[18:00:57.722]                 {
[18:00:57.722]                   {
[18:00:57.722]                     base::local({
[18:00:57.722]                       has_future <- base::requireNamespace("future", 
[18:00:57.722]                         quietly = TRUE)
[18:00:57.722]                       if (has_future) {
[18:00:57.722]                         ns <- base::getNamespace("future")
[18:00:57.722]                         version <- ns[[".package"]][["version"]]
[18:00:57.722]                         if (is.null(version)) 
[18:00:57.722]                           version <- utils::packageVersion("future")
[18:00:57.722]                       }
[18:00:57.722]                       else {
[18:00:57.722]                         version <- NULL
[18:00:57.722]                       }
[18:00:57.722]                       if (!has_future || version < "1.8.0") {
[18:00:57.722]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.722]                           "", base::R.version$version.string), 
[18:00:57.722]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.722]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.722]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.722]                             "release", "version")], collapse = " "), 
[18:00:57.722]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.722]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.722]                           info)
[18:00:57.722]                         info <- base::paste(info, collapse = "; ")
[18:00:57.722]                         if (!has_future) {
[18:00:57.722]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.722]                             info)
[18:00:57.722]                         }
[18:00:57.722]                         else {
[18:00:57.722]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.722]                             info, version)
[18:00:57.722]                         }
[18:00:57.722]                         base::stop(msg)
[18:00:57.722]                       }
[18:00:57.722]                     })
[18:00:57.722]                   }
[18:00:57.722]                   ...future.strategy.old <- future::plan("list")
[18:00:57.722]                   options(future.plan = NULL)
[18:00:57.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.722]                 }
[18:00:57.722]                 ...future.workdir <- getwd()
[18:00:57.722]             }
[18:00:57.722]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.722]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.722]         }
[18:00:57.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.722]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:00:57.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.722]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.722]             base::names(...future.oldOptions))
[18:00:57.722]     }
[18:00:57.722]     if (FALSE) {
[18:00:57.722]     }
[18:00:57.722]     else {
[18:00:57.722]         if (TRUE) {
[18:00:57.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.722]                 open = "w")
[18:00:57.722]         }
[18:00:57.722]         else {
[18:00:57.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.722]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.722]         }
[18:00:57.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.722]             base::sink(type = "output", split = FALSE)
[18:00:57.722]             base::close(...future.stdout)
[18:00:57.722]         }, add = TRUE)
[18:00:57.722]     }
[18:00:57.722]     ...future.frame <- base::sys.nframe()
[18:00:57.722]     ...future.conditions <- base::list()
[18:00:57.722]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.722]     if (FALSE) {
[18:00:57.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.722]     }
[18:00:57.722]     ...future.result <- base::tryCatch({
[18:00:57.722]         base::withCallingHandlers({
[18:00:57.722]             ...future.value <- base::withVisible(base::local({
[18:00:57.722]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.722]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.722]                   ...future.globals.maxSize)) {
[18:00:57.722]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.722]                   on.exit(options(oopts), add = TRUE)
[18:00:57.722]                 }
[18:00:57.722]                 {
[18:00:57.722]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.722]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.722]                     USE.NAMES = FALSE)
[18:00:57.722]                   do.call(mapply, args = args)
[18:00:57.722]                 }
[18:00:57.722]             }))
[18:00:57.722]             future::FutureResult(value = ...future.value$value, 
[18:00:57.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.722]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.722]                     ...future.globalenv.names))
[18:00:57.722]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.722]         }, condition = base::local({
[18:00:57.722]             c <- base::c
[18:00:57.722]             inherits <- base::inherits
[18:00:57.722]             invokeRestart <- base::invokeRestart
[18:00:57.722]             length <- base::length
[18:00:57.722]             list <- base::list
[18:00:57.722]             seq.int <- base::seq.int
[18:00:57.722]             signalCondition <- base::signalCondition
[18:00:57.722]             sys.calls <- base::sys.calls
[18:00:57.722]             `[[` <- base::`[[`
[18:00:57.722]             `+` <- base::`+`
[18:00:57.722]             `<<-` <- base::`<<-`
[18:00:57.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.722]                   3L)]
[18:00:57.722]             }
[18:00:57.722]             function(cond) {
[18:00:57.722]                 is_error <- inherits(cond, "error")
[18:00:57.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.722]                   NULL)
[18:00:57.722]                 if (is_error) {
[18:00:57.722]                   sessionInformation <- function() {
[18:00:57.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.722]                       search = base::search(), system = base::Sys.info())
[18:00:57.722]                   }
[18:00:57.722]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.722]                     cond$call), session = sessionInformation(), 
[18:00:57.722]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.722]                   signalCondition(cond)
[18:00:57.722]                 }
[18:00:57.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.722]                 "immediateCondition"))) {
[18:00:57.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.722]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.722]                   if (TRUE && !signal) {
[18:00:57.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.722]                     {
[18:00:57.722]                       inherits <- base::inherits
[18:00:57.722]                       invokeRestart <- base::invokeRestart
[18:00:57.722]                       is.null <- base::is.null
[18:00:57.722]                       muffled <- FALSE
[18:00:57.722]                       if (inherits(cond, "message")) {
[18:00:57.722]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.722]                         if (muffled) 
[18:00:57.722]                           invokeRestart("muffleMessage")
[18:00:57.722]                       }
[18:00:57.722]                       else if (inherits(cond, "warning")) {
[18:00:57.722]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.722]                         if (muffled) 
[18:00:57.722]                           invokeRestart("muffleWarning")
[18:00:57.722]                       }
[18:00:57.722]                       else if (inherits(cond, "condition")) {
[18:00:57.722]                         if (!is.null(pattern)) {
[18:00:57.722]                           computeRestarts <- base::computeRestarts
[18:00:57.722]                           grepl <- base::grepl
[18:00:57.722]                           restarts <- computeRestarts(cond)
[18:00:57.722]                           for (restart in restarts) {
[18:00:57.722]                             name <- restart$name
[18:00:57.722]                             if (is.null(name)) 
[18:00:57.722]                               next
[18:00:57.722]                             if (!grepl(pattern, name)) 
[18:00:57.722]                               next
[18:00:57.722]                             invokeRestart(restart)
[18:00:57.722]                             muffled <- TRUE
[18:00:57.722]                             break
[18:00:57.722]                           }
[18:00:57.722]                         }
[18:00:57.722]                       }
[18:00:57.722]                       invisible(muffled)
[18:00:57.722]                     }
[18:00:57.722]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.722]                   }
[18:00:57.722]                 }
[18:00:57.722]                 else {
[18:00:57.722]                   if (TRUE) {
[18:00:57.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.722]                     {
[18:00:57.722]                       inherits <- base::inherits
[18:00:57.722]                       invokeRestart <- base::invokeRestart
[18:00:57.722]                       is.null <- base::is.null
[18:00:57.722]                       muffled <- FALSE
[18:00:57.722]                       if (inherits(cond, "message")) {
[18:00:57.722]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.722]                         if (muffled) 
[18:00:57.722]                           invokeRestart("muffleMessage")
[18:00:57.722]                       }
[18:00:57.722]                       else if (inherits(cond, "warning")) {
[18:00:57.722]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.722]                         if (muffled) 
[18:00:57.722]                           invokeRestart("muffleWarning")
[18:00:57.722]                       }
[18:00:57.722]                       else if (inherits(cond, "condition")) {
[18:00:57.722]                         if (!is.null(pattern)) {
[18:00:57.722]                           computeRestarts <- base::computeRestarts
[18:00:57.722]                           grepl <- base::grepl
[18:00:57.722]                           restarts <- computeRestarts(cond)
[18:00:57.722]                           for (restart in restarts) {
[18:00:57.722]                             name <- restart$name
[18:00:57.722]                             if (is.null(name)) 
[18:00:57.722]                               next
[18:00:57.722]                             if (!grepl(pattern, name)) 
[18:00:57.722]                               next
[18:00:57.722]                             invokeRestart(restart)
[18:00:57.722]                             muffled <- TRUE
[18:00:57.722]                             break
[18:00:57.722]                           }
[18:00:57.722]                         }
[18:00:57.722]                       }
[18:00:57.722]                       invisible(muffled)
[18:00:57.722]                     }
[18:00:57.722]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.722]                   }
[18:00:57.722]                 }
[18:00:57.722]             }
[18:00:57.722]         }))
[18:00:57.722]     }, error = function(ex) {
[18:00:57.722]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.722]                 ...future.rng), started = ...future.startTime, 
[18:00:57.722]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.722]             version = "1.8"), class = "FutureResult")
[18:00:57.722]     }, finally = {
[18:00:57.722]         if (!identical(...future.workdir, getwd())) 
[18:00:57.722]             setwd(...future.workdir)
[18:00:57.722]         {
[18:00:57.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.722]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.722]             }
[18:00:57.722]             base::options(...future.oldOptions)
[18:00:57.722]             if (.Platform$OS.type == "windows") {
[18:00:57.722]                 old_names <- names(...future.oldEnvVars)
[18:00:57.722]                 envs <- base::Sys.getenv()
[18:00:57.722]                 names <- names(envs)
[18:00:57.722]                 common <- intersect(names, old_names)
[18:00:57.722]                 added <- setdiff(names, old_names)
[18:00:57.722]                 removed <- setdiff(old_names, names)
[18:00:57.722]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.722]                   envs[common]]
[18:00:57.722]                 NAMES <- toupper(changed)
[18:00:57.722]                 args <- list()
[18:00:57.722]                 for (kk in seq_along(NAMES)) {
[18:00:57.722]                   name <- changed[[kk]]
[18:00:57.722]                   NAME <- NAMES[[kk]]
[18:00:57.722]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.722]                     next
[18:00:57.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.722]                 }
[18:00:57.722]                 NAMES <- toupper(added)
[18:00:57.722]                 for (kk in seq_along(NAMES)) {
[18:00:57.722]                   name <- added[[kk]]
[18:00:57.722]                   NAME <- NAMES[[kk]]
[18:00:57.722]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.722]                     next
[18:00:57.722]                   args[[name]] <- ""
[18:00:57.722]                 }
[18:00:57.722]                 NAMES <- toupper(removed)
[18:00:57.722]                 for (kk in seq_along(NAMES)) {
[18:00:57.722]                   name <- removed[[kk]]
[18:00:57.722]                   NAME <- NAMES[[kk]]
[18:00:57.722]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.722]                     next
[18:00:57.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.722]                 }
[18:00:57.722]                 if (length(args) > 0) 
[18:00:57.722]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.722]             }
[18:00:57.722]             else {
[18:00:57.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.722]             }
[18:00:57.722]             {
[18:00:57.722]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.722]                   0L) {
[18:00:57.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.722]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.722]                   base::options(opts)
[18:00:57.722]                 }
[18:00:57.722]                 {
[18:00:57.722]                   {
[18:00:57.722]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.722]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.722]                     1423455687L), envir = base::globalenv(), 
[18:00:57.722]                       inherits = FALSE)
[18:00:57.722]                     NULL
[18:00:57.722]                   }
[18:00:57.722]                   options(future.plan = NULL)
[18:00:57.722]                   if (is.na(NA_character_)) 
[18:00:57.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.722]                     .init = FALSE)
[18:00:57.722]                 }
[18:00:57.722]             }
[18:00:57.722]         }
[18:00:57.722]     })
[18:00:57.722]     if (TRUE) {
[18:00:57.722]         base::sink(type = "output", split = FALSE)
[18:00:57.722]         if (TRUE) {
[18:00:57.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.722]         }
[18:00:57.722]         else {
[18:00:57.722]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.722]         }
[18:00:57.722]         base::close(...future.stdout)
[18:00:57.722]         ...future.stdout <- NULL
[18:00:57.722]     }
[18:00:57.722]     ...future.result$conditions <- ...future.conditions
[18:00:57.722]     ...future.result$finished <- base::Sys.time()
[18:00:57.722]     ...future.result
[18:00:57.722] }
[18:00:57.726] assign_globals() ...
[18:00:57.726] List of 5
[18:00:57.726]  $ ...future.FUN            :function (C, k)  
[18:00:57.726]  $ MoreArgs                 : NULL
[18:00:57.726]  $ ...future.elements_ii    :List of 2
[18:00:57.726]   ..$ :List of 1
[18:00:57.726]   .. ..$ : chr "C"
[18:00:57.726]   ..$ :List of 1
[18:00:57.726]   .. ..$ : int 3
[18:00:57.726]  $ ...future.seeds_ii       : NULL
[18:00:57.726]  $ ...future.globals.maxSize: NULL
[18:00:57.726]  - attr(*, "where")=List of 5
[18:00:57.726]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.726]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.726]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.726]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.726]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.726]  - attr(*, "resolved")= logi FALSE
[18:00:57.726]  - attr(*, "total_size")= num 3488
[18:00:57.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.726]  - attr(*, "already-done")= logi TRUE
[18:00:57.736] - reassign environment for ‘...future.FUN’
[18:00:57.736] - copied ‘...future.FUN’ to environment
[18:00:57.736] - copied ‘MoreArgs’ to environment
[18:00:57.736] - copied ‘...future.elements_ii’ to environment
[18:00:57.739] - copied ‘...future.seeds_ii’ to environment
[18:00:57.739] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.739] assign_globals() ... done
[18:00:57.740] plan(): Setting new future strategy stack:
[18:00:57.740] List of future strategies:
[18:00:57.740] 1. sequential:
[18:00:57.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.740]    - tweaked: FALSE
[18:00:57.740]    - call: NULL
[18:00:57.741] plan(): nbrOfWorkers() = 1
[18:00:57.742] plan(): Setting new future strategy stack:
[18:00:57.743] List of future strategies:
[18:00:57.743] 1. sequential:
[18:00:57.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.743]    - tweaked: FALSE
[18:00:57.743]    - call: plan(strategy)
[18:00:57.744] plan(): nbrOfWorkers() = 1
[18:00:57.744] SequentialFuture started (and completed)
[18:00:57.744] - Launch lazy future ... done
[18:00:57.744] run() for ‘SequentialFuture’ ... done
[18:00:57.745] Created future:
[18:00:57.745] SequentialFuture:
[18:00:57.745] Label: ‘future_mapply-3’
[18:00:57.745] Expression:
[18:00:57.745] {
[18:00:57.745]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.745]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.745]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.745]         on.exit(options(oopts), add = TRUE)
[18:00:57.745]     }
[18:00:57.745]     {
[18:00:57.745]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.745]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.745]         do.call(mapply, args = args)
[18:00:57.745]     }
[18:00:57.745] }
[18:00:57.745] Lazy evaluation: FALSE
[18:00:57.745] Asynchronous evaluation: FALSE
[18:00:57.745] Local evaluation: TRUE
[18:00:57.745] Environment: R_GlobalEnv
[18:00:57.745] Capture standard output: TRUE
[18:00:57.745] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.745] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.745] Packages: <none>
[18:00:57.745] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.745] Resolved: TRUE
[18:00:57.745] Value: 112 bytes of class ‘list’
[18:00:57.745] Early signaling: FALSE
[18:00:57.745] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.745] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.747] Chunk #3 of 5 ... DONE
[18:00:57.747] Chunk #4 of 5 ...
[18:00:57.747]  - Finding globals in '...' for chunk #4 ...
[18:00:57.747] getGlobalsAndPackages() ...
[18:00:57.747] Searching for globals...
[18:00:57.748] 
[18:00:57.748] Searching for globals ... DONE
[18:00:57.748] - globals: [0] <none>
[18:00:57.749] getGlobalsAndPackages() ... DONE
[18:00:57.749]    + additional globals found: [n=0] 
[18:00:57.749]    + additional namespaces needed: [n=0] 
[18:00:57.750]  - Finding globals in '...' for chunk #4 ... DONE
[18:00:57.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:00:57.750]  - seeds: <none>
[18:00:57.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.750] getGlobalsAndPackages() ...
[18:00:57.751] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.751] Resolving globals: FALSE
[18:00:57.752] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:00:57.753] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.753] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.753] 
[18:00:57.753] getGlobalsAndPackages() ... DONE
[18:00:57.754] run() for ‘Future’ ...
[18:00:57.754] - state: ‘created’
[18:00:57.754] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.755] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.755]   - Field: ‘label’
[18:00:57.755]   - Field: ‘local’
[18:00:57.756]   - Field: ‘owner’
[18:00:57.756]   - Field: ‘envir’
[18:00:57.756]   - Field: ‘packages’
[18:00:57.756]   - Field: ‘gc’
[18:00:57.756]   - Field: ‘conditions’
[18:00:57.757]   - Field: ‘expr’
[18:00:57.757]   - Field: ‘uuid’
[18:00:57.757]   - Field: ‘seed’
[18:00:57.757]   - Field: ‘version’
[18:00:57.757]   - Field: ‘result’
[18:00:57.758]   - Field: ‘asynchronous’
[18:00:57.758]   - Field: ‘calls’
[18:00:57.758]   - Field: ‘globals’
[18:00:57.758]   - Field: ‘stdout’
[18:00:57.758]   - Field: ‘earlySignal’
[18:00:57.759]   - Field: ‘lazy’
[18:00:57.759]   - Field: ‘state’
[18:00:57.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.759] - Launch lazy future ...
[18:00:57.760] Packages needed by the future expression (n = 0): <none>
[18:00:57.760] Packages needed by future strategies (n = 0): <none>
[18:00:57.761] {
[18:00:57.761]     {
[18:00:57.761]         {
[18:00:57.761]             ...future.startTime <- base::Sys.time()
[18:00:57.761]             {
[18:00:57.761]                 {
[18:00:57.761]                   {
[18:00:57.761]                     base::local({
[18:00:57.761]                       has_future <- base::requireNamespace("future", 
[18:00:57.761]                         quietly = TRUE)
[18:00:57.761]                       if (has_future) {
[18:00:57.761]                         ns <- base::getNamespace("future")
[18:00:57.761]                         version <- ns[[".package"]][["version"]]
[18:00:57.761]                         if (is.null(version)) 
[18:00:57.761]                           version <- utils::packageVersion("future")
[18:00:57.761]                       }
[18:00:57.761]                       else {
[18:00:57.761]                         version <- NULL
[18:00:57.761]                       }
[18:00:57.761]                       if (!has_future || version < "1.8.0") {
[18:00:57.761]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.761]                           "", base::R.version$version.string), 
[18:00:57.761]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.761]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.761]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.761]                             "release", "version")], collapse = " "), 
[18:00:57.761]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.761]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.761]                           info)
[18:00:57.761]                         info <- base::paste(info, collapse = "; ")
[18:00:57.761]                         if (!has_future) {
[18:00:57.761]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.761]                             info)
[18:00:57.761]                         }
[18:00:57.761]                         else {
[18:00:57.761]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.761]                             info, version)
[18:00:57.761]                         }
[18:00:57.761]                         base::stop(msg)
[18:00:57.761]                       }
[18:00:57.761]                     })
[18:00:57.761]                   }
[18:00:57.761]                   ...future.strategy.old <- future::plan("list")
[18:00:57.761]                   options(future.plan = NULL)
[18:00:57.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.761]                 }
[18:00:57.761]                 ...future.workdir <- getwd()
[18:00:57.761]             }
[18:00:57.761]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.761]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.761]         }
[18:00:57.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.761]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:00:57.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.761]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.761]             base::names(...future.oldOptions))
[18:00:57.761]     }
[18:00:57.761]     if (FALSE) {
[18:00:57.761]     }
[18:00:57.761]     else {
[18:00:57.761]         if (TRUE) {
[18:00:57.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.761]                 open = "w")
[18:00:57.761]         }
[18:00:57.761]         else {
[18:00:57.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.761]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.761]         }
[18:00:57.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.761]             base::sink(type = "output", split = FALSE)
[18:00:57.761]             base::close(...future.stdout)
[18:00:57.761]         }, add = TRUE)
[18:00:57.761]     }
[18:00:57.761]     ...future.frame <- base::sys.nframe()
[18:00:57.761]     ...future.conditions <- base::list()
[18:00:57.761]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.761]     if (FALSE) {
[18:00:57.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.761]     }
[18:00:57.761]     ...future.result <- base::tryCatch({
[18:00:57.761]         base::withCallingHandlers({
[18:00:57.761]             ...future.value <- base::withVisible(base::local({
[18:00:57.761]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.761]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.761]                   ...future.globals.maxSize)) {
[18:00:57.761]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.761]                   on.exit(options(oopts), add = TRUE)
[18:00:57.761]                 }
[18:00:57.761]                 {
[18:00:57.761]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.761]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.761]                     USE.NAMES = FALSE)
[18:00:57.761]                   do.call(mapply, args = args)
[18:00:57.761]                 }
[18:00:57.761]             }))
[18:00:57.761]             future::FutureResult(value = ...future.value$value, 
[18:00:57.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.761]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.761]                     ...future.globalenv.names))
[18:00:57.761]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.761]         }, condition = base::local({
[18:00:57.761]             c <- base::c
[18:00:57.761]             inherits <- base::inherits
[18:00:57.761]             invokeRestart <- base::invokeRestart
[18:00:57.761]             length <- base::length
[18:00:57.761]             list <- base::list
[18:00:57.761]             seq.int <- base::seq.int
[18:00:57.761]             signalCondition <- base::signalCondition
[18:00:57.761]             sys.calls <- base::sys.calls
[18:00:57.761]             `[[` <- base::`[[`
[18:00:57.761]             `+` <- base::`+`
[18:00:57.761]             `<<-` <- base::`<<-`
[18:00:57.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.761]                   3L)]
[18:00:57.761]             }
[18:00:57.761]             function(cond) {
[18:00:57.761]                 is_error <- inherits(cond, "error")
[18:00:57.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.761]                   NULL)
[18:00:57.761]                 if (is_error) {
[18:00:57.761]                   sessionInformation <- function() {
[18:00:57.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.761]                       search = base::search(), system = base::Sys.info())
[18:00:57.761]                   }
[18:00:57.761]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.761]                     cond$call), session = sessionInformation(), 
[18:00:57.761]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.761]                   signalCondition(cond)
[18:00:57.761]                 }
[18:00:57.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.761]                 "immediateCondition"))) {
[18:00:57.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.761]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.761]                   if (TRUE && !signal) {
[18:00:57.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.761]                     {
[18:00:57.761]                       inherits <- base::inherits
[18:00:57.761]                       invokeRestart <- base::invokeRestart
[18:00:57.761]                       is.null <- base::is.null
[18:00:57.761]                       muffled <- FALSE
[18:00:57.761]                       if (inherits(cond, "message")) {
[18:00:57.761]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.761]                         if (muffled) 
[18:00:57.761]                           invokeRestart("muffleMessage")
[18:00:57.761]                       }
[18:00:57.761]                       else if (inherits(cond, "warning")) {
[18:00:57.761]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.761]                         if (muffled) 
[18:00:57.761]                           invokeRestart("muffleWarning")
[18:00:57.761]                       }
[18:00:57.761]                       else if (inherits(cond, "condition")) {
[18:00:57.761]                         if (!is.null(pattern)) {
[18:00:57.761]                           computeRestarts <- base::computeRestarts
[18:00:57.761]                           grepl <- base::grepl
[18:00:57.761]                           restarts <- computeRestarts(cond)
[18:00:57.761]                           for (restart in restarts) {
[18:00:57.761]                             name <- restart$name
[18:00:57.761]                             if (is.null(name)) 
[18:00:57.761]                               next
[18:00:57.761]                             if (!grepl(pattern, name)) 
[18:00:57.761]                               next
[18:00:57.761]                             invokeRestart(restart)
[18:00:57.761]                             muffled <- TRUE
[18:00:57.761]                             break
[18:00:57.761]                           }
[18:00:57.761]                         }
[18:00:57.761]                       }
[18:00:57.761]                       invisible(muffled)
[18:00:57.761]                     }
[18:00:57.761]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.761]                   }
[18:00:57.761]                 }
[18:00:57.761]                 else {
[18:00:57.761]                   if (TRUE) {
[18:00:57.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.761]                     {
[18:00:57.761]                       inherits <- base::inherits
[18:00:57.761]                       invokeRestart <- base::invokeRestart
[18:00:57.761]                       is.null <- base::is.null
[18:00:57.761]                       muffled <- FALSE
[18:00:57.761]                       if (inherits(cond, "message")) {
[18:00:57.761]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.761]                         if (muffled) 
[18:00:57.761]                           invokeRestart("muffleMessage")
[18:00:57.761]                       }
[18:00:57.761]                       else if (inherits(cond, "warning")) {
[18:00:57.761]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.761]                         if (muffled) 
[18:00:57.761]                           invokeRestart("muffleWarning")
[18:00:57.761]                       }
[18:00:57.761]                       else if (inherits(cond, "condition")) {
[18:00:57.761]                         if (!is.null(pattern)) {
[18:00:57.761]                           computeRestarts <- base::computeRestarts
[18:00:57.761]                           grepl <- base::grepl
[18:00:57.761]                           restarts <- computeRestarts(cond)
[18:00:57.761]                           for (restart in restarts) {
[18:00:57.761]                             name <- restart$name
[18:00:57.761]                             if (is.null(name)) 
[18:00:57.761]                               next
[18:00:57.761]                             if (!grepl(pattern, name)) 
[18:00:57.761]                               next
[18:00:57.761]                             invokeRestart(restart)
[18:00:57.761]                             muffled <- TRUE
[18:00:57.761]                             break
[18:00:57.761]                           }
[18:00:57.761]                         }
[18:00:57.761]                       }
[18:00:57.761]                       invisible(muffled)
[18:00:57.761]                     }
[18:00:57.761]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.761]                   }
[18:00:57.761]                 }
[18:00:57.761]             }
[18:00:57.761]         }))
[18:00:57.761]     }, error = function(ex) {
[18:00:57.761]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.761]                 ...future.rng), started = ...future.startTime, 
[18:00:57.761]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.761]             version = "1.8"), class = "FutureResult")
[18:00:57.761]     }, finally = {
[18:00:57.761]         if (!identical(...future.workdir, getwd())) 
[18:00:57.761]             setwd(...future.workdir)
[18:00:57.761]         {
[18:00:57.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.761]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.761]             }
[18:00:57.761]             base::options(...future.oldOptions)
[18:00:57.761]             if (.Platform$OS.type == "windows") {
[18:00:57.761]                 old_names <- names(...future.oldEnvVars)
[18:00:57.761]                 envs <- base::Sys.getenv()
[18:00:57.761]                 names <- names(envs)
[18:00:57.761]                 common <- intersect(names, old_names)
[18:00:57.761]                 added <- setdiff(names, old_names)
[18:00:57.761]                 removed <- setdiff(old_names, names)
[18:00:57.761]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.761]                   envs[common]]
[18:00:57.761]                 NAMES <- toupper(changed)
[18:00:57.761]                 args <- list()
[18:00:57.761]                 for (kk in seq_along(NAMES)) {
[18:00:57.761]                   name <- changed[[kk]]
[18:00:57.761]                   NAME <- NAMES[[kk]]
[18:00:57.761]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.761]                     next
[18:00:57.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.761]                 }
[18:00:57.761]                 NAMES <- toupper(added)
[18:00:57.761]                 for (kk in seq_along(NAMES)) {
[18:00:57.761]                   name <- added[[kk]]
[18:00:57.761]                   NAME <- NAMES[[kk]]
[18:00:57.761]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.761]                     next
[18:00:57.761]                   args[[name]] <- ""
[18:00:57.761]                 }
[18:00:57.761]                 NAMES <- toupper(removed)
[18:00:57.761]                 for (kk in seq_along(NAMES)) {
[18:00:57.761]                   name <- removed[[kk]]
[18:00:57.761]                   NAME <- NAMES[[kk]]
[18:00:57.761]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.761]                     next
[18:00:57.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.761]                 }
[18:00:57.761]                 if (length(args) > 0) 
[18:00:57.761]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.761]             }
[18:00:57.761]             else {
[18:00:57.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.761]             }
[18:00:57.761]             {
[18:00:57.761]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.761]                   0L) {
[18:00:57.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.761]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.761]                   base::options(opts)
[18:00:57.761]                 }
[18:00:57.761]                 {
[18:00:57.761]                   {
[18:00:57.761]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.761]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.761]                     1423455687L), envir = base::globalenv(), 
[18:00:57.761]                       inherits = FALSE)
[18:00:57.761]                     NULL
[18:00:57.761]                   }
[18:00:57.761]                   options(future.plan = NULL)
[18:00:57.761]                   if (is.na(NA_character_)) 
[18:00:57.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.761]                     .init = FALSE)
[18:00:57.761]                 }
[18:00:57.761]             }
[18:00:57.761]         }
[18:00:57.761]     })
[18:00:57.761]     if (TRUE) {
[18:00:57.761]         base::sink(type = "output", split = FALSE)
[18:00:57.761]         if (TRUE) {
[18:00:57.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.761]         }
[18:00:57.761]         else {
[18:00:57.761]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.761]         }
[18:00:57.761]         base::close(...future.stdout)
[18:00:57.761]         ...future.stdout <- NULL
[18:00:57.761]     }
[18:00:57.761]     ...future.result$conditions <- ...future.conditions
[18:00:57.761]     ...future.result$finished <- base::Sys.time()
[18:00:57.761]     ...future.result
[18:00:57.761] }
[18:00:57.764] assign_globals() ...
[18:00:57.764] List of 5
[18:00:57.764]  $ ...future.FUN            :function (C, k)  
[18:00:57.764]  $ MoreArgs                 : NULL
[18:00:57.764]  $ ...future.elements_ii    :List of 2
[18:00:57.764]   ..$ :List of 1
[18:00:57.764]   .. ..$ : chr "D"
[18:00:57.764]   ..$ :List of 1
[18:00:57.764]   .. ..$ : int 2
[18:00:57.764]  $ ...future.seeds_ii       : NULL
[18:00:57.764]  $ ...future.globals.maxSize: NULL
[18:00:57.764]  - attr(*, "where")=List of 5
[18:00:57.764]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.764]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.764]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.764]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.764]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.764]  - attr(*, "resolved")= logi FALSE
[18:00:57.764]  - attr(*, "total_size")= num 3488
[18:00:57.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.764]  - attr(*, "already-done")= logi TRUE
[18:00:57.774] - reassign environment for ‘...future.FUN’
[18:00:57.775] - copied ‘...future.FUN’ to environment
[18:00:57.775] - copied ‘MoreArgs’ to environment
[18:00:57.775] - copied ‘...future.elements_ii’ to environment
[18:00:57.775] - copied ‘...future.seeds_ii’ to environment
[18:00:57.776] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.776] assign_globals() ... done
[18:00:57.776] plan(): Setting new future strategy stack:
[18:00:57.777] List of future strategies:
[18:00:57.777] 1. sequential:
[18:00:57.777]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.777]    - tweaked: FALSE
[18:00:57.777]    - call: NULL
[18:00:57.778] plan(): nbrOfWorkers() = 1
[18:00:57.779] plan(): Setting new future strategy stack:
[18:00:57.780] List of future strategies:
[18:00:57.780] 1. sequential:
[18:00:57.780]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.780]    - tweaked: FALSE
[18:00:57.780]    - call: plan(strategy)
[18:00:57.781] plan(): nbrOfWorkers() = 1
[18:00:57.781] SequentialFuture started (and completed)
[18:00:57.781] - Launch lazy future ... done
[18:00:57.781] run() for ‘SequentialFuture’ ... done
[18:00:57.782] Created future:
[18:00:57.782] SequentialFuture:
[18:00:57.782] Label: ‘future_mapply-4’
[18:00:57.782] Expression:
[18:00:57.782] {
[18:00:57.782]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.782]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.782]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.782]         on.exit(options(oopts), add = TRUE)
[18:00:57.782]     }
[18:00:57.782]     {
[18:00:57.782]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.782]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.782]         do.call(mapply, args = args)
[18:00:57.782]     }
[18:00:57.782] }
[18:00:57.782] Lazy evaluation: FALSE
[18:00:57.782] Asynchronous evaluation: FALSE
[18:00:57.782] Local evaluation: TRUE
[18:00:57.782] Environment: R_GlobalEnv
[18:00:57.782] Capture standard output: TRUE
[18:00:57.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.782] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.782] Packages: <none>
[18:00:57.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.782] Resolved: TRUE
[18:00:57.782] Value: 112 bytes of class ‘list’
[18:00:57.782] Early signaling: FALSE
[18:00:57.782] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.782] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.784] Chunk #4 of 5 ... DONE
[18:00:57.784] Chunk #5 of 5 ...
[18:00:57.785]  - Finding globals in '...' for chunk #5 ...
[18:00:57.785] getGlobalsAndPackages() ...
[18:00:57.785] Searching for globals...
[18:00:57.786] 
[18:00:57.786] Searching for globals ... DONE
[18:00:57.786] - globals: [0] <none>
[18:00:57.786] getGlobalsAndPackages() ... DONE
[18:00:57.786]    + additional globals found: [n=0] 
[18:00:57.787]    + additional namespaces needed: [n=0] 
[18:00:57.787]  - Finding globals in '...' for chunk #5 ... DONE
[18:00:57.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:00:57.787]  - seeds: <none>
[18:00:57.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.788] getGlobalsAndPackages() ...
[18:00:57.788] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.788] Resolving globals: FALSE
[18:00:57.789] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:00:57.823] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.823] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.824] 
[18:00:57.824] getGlobalsAndPackages() ... DONE
[18:00:57.824] run() for ‘Future’ ...
[18:00:57.825] - state: ‘created’
[18:00:57.825] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.825] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.826]   - Field: ‘label’
[18:00:57.826]   - Field: ‘local’
[18:00:57.826]   - Field: ‘owner’
[18:00:57.827]   - Field: ‘envir’
[18:00:57.827]   - Field: ‘packages’
[18:00:57.827]   - Field: ‘gc’
[18:00:57.827]   - Field: ‘conditions’
[18:00:57.827]   - Field: ‘expr’
[18:00:57.828]   - Field: ‘uuid’
[18:00:57.828]   - Field: ‘seed’
[18:00:57.828]   - Field: ‘version’
[18:00:57.828]   - Field: ‘result’
[18:00:57.828]   - Field: ‘asynchronous’
[18:00:57.829]   - Field: ‘calls’
[18:00:57.829]   - Field: ‘globals’
[18:00:57.829]   - Field: ‘stdout’
[18:00:57.829]   - Field: ‘earlySignal’
[18:00:57.829]   - Field: ‘lazy’
[18:00:57.829]   - Field: ‘state’
[18:00:57.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.830] - Launch lazy future ...
[18:00:57.830] Packages needed by the future expression (n = 0): <none>
[18:00:57.830] Packages needed by future strategies (n = 0): <none>
[18:00:57.831] {
[18:00:57.831]     {
[18:00:57.831]         {
[18:00:57.831]             ...future.startTime <- base::Sys.time()
[18:00:57.831]             {
[18:00:57.831]                 {
[18:00:57.831]                   {
[18:00:57.831]                     base::local({
[18:00:57.831]                       has_future <- base::requireNamespace("future", 
[18:00:57.831]                         quietly = TRUE)
[18:00:57.831]                       if (has_future) {
[18:00:57.831]                         ns <- base::getNamespace("future")
[18:00:57.831]                         version <- ns[[".package"]][["version"]]
[18:00:57.831]                         if (is.null(version)) 
[18:00:57.831]                           version <- utils::packageVersion("future")
[18:00:57.831]                       }
[18:00:57.831]                       else {
[18:00:57.831]                         version <- NULL
[18:00:57.831]                       }
[18:00:57.831]                       if (!has_future || version < "1.8.0") {
[18:00:57.831]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.831]                           "", base::R.version$version.string), 
[18:00:57.831]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.831]                             "release", "version")], collapse = " "), 
[18:00:57.831]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.831]                           info)
[18:00:57.831]                         info <- base::paste(info, collapse = "; ")
[18:00:57.831]                         if (!has_future) {
[18:00:57.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.831]                             info)
[18:00:57.831]                         }
[18:00:57.831]                         else {
[18:00:57.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.831]                             info, version)
[18:00:57.831]                         }
[18:00:57.831]                         base::stop(msg)
[18:00:57.831]                       }
[18:00:57.831]                     })
[18:00:57.831]                   }
[18:00:57.831]                   ...future.strategy.old <- future::plan("list")
[18:00:57.831]                   options(future.plan = NULL)
[18:00:57.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.831]                 }
[18:00:57.831]                 ...future.workdir <- getwd()
[18:00:57.831]             }
[18:00:57.831]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.831]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.831]         }
[18:00:57.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.831]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:00:57.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.831]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.831]             base::names(...future.oldOptions))
[18:00:57.831]     }
[18:00:57.831]     if (FALSE) {
[18:00:57.831]     }
[18:00:57.831]     else {
[18:00:57.831]         if (TRUE) {
[18:00:57.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.831]                 open = "w")
[18:00:57.831]         }
[18:00:57.831]         else {
[18:00:57.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.831]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.831]         }
[18:00:57.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.831]             base::sink(type = "output", split = FALSE)
[18:00:57.831]             base::close(...future.stdout)
[18:00:57.831]         }, add = TRUE)
[18:00:57.831]     }
[18:00:57.831]     ...future.frame <- base::sys.nframe()
[18:00:57.831]     ...future.conditions <- base::list()
[18:00:57.831]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.831]     if (FALSE) {
[18:00:57.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.831]     }
[18:00:57.831]     ...future.result <- base::tryCatch({
[18:00:57.831]         base::withCallingHandlers({
[18:00:57.831]             ...future.value <- base::withVisible(base::local({
[18:00:57.831]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.831]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.831]                   ...future.globals.maxSize)) {
[18:00:57.831]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.831]                   on.exit(options(oopts), add = TRUE)
[18:00:57.831]                 }
[18:00:57.831]                 {
[18:00:57.831]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.831]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.831]                     USE.NAMES = FALSE)
[18:00:57.831]                   do.call(mapply, args = args)
[18:00:57.831]                 }
[18:00:57.831]             }))
[18:00:57.831]             future::FutureResult(value = ...future.value$value, 
[18:00:57.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.831]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.831]                     ...future.globalenv.names))
[18:00:57.831]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.831]         }, condition = base::local({
[18:00:57.831]             c <- base::c
[18:00:57.831]             inherits <- base::inherits
[18:00:57.831]             invokeRestart <- base::invokeRestart
[18:00:57.831]             length <- base::length
[18:00:57.831]             list <- base::list
[18:00:57.831]             seq.int <- base::seq.int
[18:00:57.831]             signalCondition <- base::signalCondition
[18:00:57.831]             sys.calls <- base::sys.calls
[18:00:57.831]             `[[` <- base::`[[`
[18:00:57.831]             `+` <- base::`+`
[18:00:57.831]             `<<-` <- base::`<<-`
[18:00:57.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.831]                   3L)]
[18:00:57.831]             }
[18:00:57.831]             function(cond) {
[18:00:57.831]                 is_error <- inherits(cond, "error")
[18:00:57.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.831]                   NULL)
[18:00:57.831]                 if (is_error) {
[18:00:57.831]                   sessionInformation <- function() {
[18:00:57.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.831]                       search = base::search(), system = base::Sys.info())
[18:00:57.831]                   }
[18:00:57.831]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.831]                     cond$call), session = sessionInformation(), 
[18:00:57.831]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.831]                   signalCondition(cond)
[18:00:57.831]                 }
[18:00:57.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.831]                 "immediateCondition"))) {
[18:00:57.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.831]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.831]                   if (TRUE && !signal) {
[18:00:57.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.831]                     {
[18:00:57.831]                       inherits <- base::inherits
[18:00:57.831]                       invokeRestart <- base::invokeRestart
[18:00:57.831]                       is.null <- base::is.null
[18:00:57.831]                       muffled <- FALSE
[18:00:57.831]                       if (inherits(cond, "message")) {
[18:00:57.831]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.831]                         if (muffled) 
[18:00:57.831]                           invokeRestart("muffleMessage")
[18:00:57.831]                       }
[18:00:57.831]                       else if (inherits(cond, "warning")) {
[18:00:57.831]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.831]                         if (muffled) 
[18:00:57.831]                           invokeRestart("muffleWarning")
[18:00:57.831]                       }
[18:00:57.831]                       else if (inherits(cond, "condition")) {
[18:00:57.831]                         if (!is.null(pattern)) {
[18:00:57.831]                           computeRestarts <- base::computeRestarts
[18:00:57.831]                           grepl <- base::grepl
[18:00:57.831]                           restarts <- computeRestarts(cond)
[18:00:57.831]                           for (restart in restarts) {
[18:00:57.831]                             name <- restart$name
[18:00:57.831]                             if (is.null(name)) 
[18:00:57.831]                               next
[18:00:57.831]                             if (!grepl(pattern, name)) 
[18:00:57.831]                               next
[18:00:57.831]                             invokeRestart(restart)
[18:00:57.831]                             muffled <- TRUE
[18:00:57.831]                             break
[18:00:57.831]                           }
[18:00:57.831]                         }
[18:00:57.831]                       }
[18:00:57.831]                       invisible(muffled)
[18:00:57.831]                     }
[18:00:57.831]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.831]                   }
[18:00:57.831]                 }
[18:00:57.831]                 else {
[18:00:57.831]                   if (TRUE) {
[18:00:57.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.831]                     {
[18:00:57.831]                       inherits <- base::inherits
[18:00:57.831]                       invokeRestart <- base::invokeRestart
[18:00:57.831]                       is.null <- base::is.null
[18:00:57.831]                       muffled <- FALSE
[18:00:57.831]                       if (inherits(cond, "message")) {
[18:00:57.831]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.831]                         if (muffled) 
[18:00:57.831]                           invokeRestart("muffleMessage")
[18:00:57.831]                       }
[18:00:57.831]                       else if (inherits(cond, "warning")) {
[18:00:57.831]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.831]                         if (muffled) 
[18:00:57.831]                           invokeRestart("muffleWarning")
[18:00:57.831]                       }
[18:00:57.831]                       else if (inherits(cond, "condition")) {
[18:00:57.831]                         if (!is.null(pattern)) {
[18:00:57.831]                           computeRestarts <- base::computeRestarts
[18:00:57.831]                           grepl <- base::grepl
[18:00:57.831]                           restarts <- computeRestarts(cond)
[18:00:57.831]                           for (restart in restarts) {
[18:00:57.831]                             name <- restart$name
[18:00:57.831]                             if (is.null(name)) 
[18:00:57.831]                               next
[18:00:57.831]                             if (!grepl(pattern, name)) 
[18:00:57.831]                               next
[18:00:57.831]                             invokeRestart(restart)
[18:00:57.831]                             muffled <- TRUE
[18:00:57.831]                             break
[18:00:57.831]                           }
[18:00:57.831]                         }
[18:00:57.831]                       }
[18:00:57.831]                       invisible(muffled)
[18:00:57.831]                     }
[18:00:57.831]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.831]                   }
[18:00:57.831]                 }
[18:00:57.831]             }
[18:00:57.831]         }))
[18:00:57.831]     }, error = function(ex) {
[18:00:57.831]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.831]                 ...future.rng), started = ...future.startTime, 
[18:00:57.831]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.831]             version = "1.8"), class = "FutureResult")
[18:00:57.831]     }, finally = {
[18:00:57.831]         if (!identical(...future.workdir, getwd())) 
[18:00:57.831]             setwd(...future.workdir)
[18:00:57.831]         {
[18:00:57.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.831]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.831]             }
[18:00:57.831]             base::options(...future.oldOptions)
[18:00:57.831]             if (.Platform$OS.type == "windows") {
[18:00:57.831]                 old_names <- names(...future.oldEnvVars)
[18:00:57.831]                 envs <- base::Sys.getenv()
[18:00:57.831]                 names <- names(envs)
[18:00:57.831]                 common <- intersect(names, old_names)
[18:00:57.831]                 added <- setdiff(names, old_names)
[18:00:57.831]                 removed <- setdiff(old_names, names)
[18:00:57.831]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.831]                   envs[common]]
[18:00:57.831]                 NAMES <- toupper(changed)
[18:00:57.831]                 args <- list()
[18:00:57.831]                 for (kk in seq_along(NAMES)) {
[18:00:57.831]                   name <- changed[[kk]]
[18:00:57.831]                   NAME <- NAMES[[kk]]
[18:00:57.831]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.831]                     next
[18:00:57.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.831]                 }
[18:00:57.831]                 NAMES <- toupper(added)
[18:00:57.831]                 for (kk in seq_along(NAMES)) {
[18:00:57.831]                   name <- added[[kk]]
[18:00:57.831]                   NAME <- NAMES[[kk]]
[18:00:57.831]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.831]                     next
[18:00:57.831]                   args[[name]] <- ""
[18:00:57.831]                 }
[18:00:57.831]                 NAMES <- toupper(removed)
[18:00:57.831]                 for (kk in seq_along(NAMES)) {
[18:00:57.831]                   name <- removed[[kk]]
[18:00:57.831]                   NAME <- NAMES[[kk]]
[18:00:57.831]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.831]                     next
[18:00:57.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.831]                 }
[18:00:57.831]                 if (length(args) > 0) 
[18:00:57.831]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.831]             }
[18:00:57.831]             else {
[18:00:57.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.831]             }
[18:00:57.831]             {
[18:00:57.831]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.831]                   0L) {
[18:00:57.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.831]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.831]                   base::options(opts)
[18:00:57.831]                 }
[18:00:57.831]                 {
[18:00:57.831]                   {
[18:00:57.831]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.831]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.831]                     1423455687L), envir = base::globalenv(), 
[18:00:57.831]                       inherits = FALSE)
[18:00:57.831]                     NULL
[18:00:57.831]                   }
[18:00:57.831]                   options(future.plan = NULL)
[18:00:57.831]                   if (is.na(NA_character_)) 
[18:00:57.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.831]                     .init = FALSE)
[18:00:57.831]                 }
[18:00:57.831]             }
[18:00:57.831]         }
[18:00:57.831]     })
[18:00:57.831]     if (TRUE) {
[18:00:57.831]         base::sink(type = "output", split = FALSE)
[18:00:57.831]         if (TRUE) {
[18:00:57.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.831]         }
[18:00:57.831]         else {
[18:00:57.831]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.831]         }
[18:00:57.831]         base::close(...future.stdout)
[18:00:57.831]         ...future.stdout <- NULL
[18:00:57.831]     }
[18:00:57.831]     ...future.result$conditions <- ...future.conditions
[18:00:57.831]     ...future.result$finished <- base::Sys.time()
[18:00:57.831]     ...future.result
[18:00:57.831] }
[18:00:57.835] assign_globals() ...
[18:00:57.835] List of 5
[18:00:57.835]  $ ...future.FUN            :function (C, k)  
[18:00:57.835]  $ MoreArgs                 : NULL
[18:00:57.835]  $ ...future.elements_ii    :List of 2
[18:00:57.835]   ..$ :List of 1
[18:00:57.835]   .. ..$ : chr "E"
[18:00:57.835]   ..$ :List of 1
[18:00:57.835]   .. ..$ : int 1
[18:00:57.835]  $ ...future.seeds_ii       : NULL
[18:00:57.835]  $ ...future.globals.maxSize: NULL
[18:00:57.835]  - attr(*, "where")=List of 5
[18:00:57.835]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.835]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.835]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.835]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.835]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.835]  - attr(*, "resolved")= logi FALSE
[18:00:57.835]  - attr(*, "total_size")= num 3488
[18:00:57.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.835]  - attr(*, "already-done")= logi TRUE
[18:00:57.845] - reassign environment for ‘...future.FUN’
[18:00:57.845] - copied ‘...future.FUN’ to environment
[18:00:57.845] - copied ‘MoreArgs’ to environment
[18:00:57.845] - copied ‘...future.elements_ii’ to environment
[18:00:57.846] - copied ‘...future.seeds_ii’ to environment
[18:00:57.846] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.846] assign_globals() ... done
[18:00:57.847] plan(): Setting new future strategy stack:
[18:00:57.847] List of future strategies:
[18:00:57.847] 1. sequential:
[18:00:57.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.847]    - tweaked: FALSE
[18:00:57.847]    - call: NULL
[18:00:57.848] plan(): nbrOfWorkers() = 1
[18:00:57.849] plan(): Setting new future strategy stack:
[18:00:57.850] List of future strategies:
[18:00:57.850] 1. sequential:
[18:00:57.850]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.850]    - tweaked: FALSE
[18:00:57.850]    - call: plan(strategy)
[18:00:57.851] plan(): nbrOfWorkers() = 1
[18:00:57.851] SequentialFuture started (and completed)
[18:00:57.851] - Launch lazy future ... done
[18:00:57.851] run() for ‘SequentialFuture’ ... done
[18:00:57.852] Created future:
[18:00:57.852] SequentialFuture:
[18:00:57.852] Label: ‘future_mapply-5’
[18:00:57.852] Expression:
[18:00:57.852] {
[18:00:57.852]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.852]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.852]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.852]         on.exit(options(oopts), add = TRUE)
[18:00:57.852]     }
[18:00:57.852]     {
[18:00:57.852]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.852]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.852]         do.call(mapply, args = args)
[18:00:57.852]     }
[18:00:57.852] }
[18:00:57.852] Lazy evaluation: FALSE
[18:00:57.852] Asynchronous evaluation: FALSE
[18:00:57.852] Local evaluation: TRUE
[18:00:57.852] Environment: R_GlobalEnv
[18:00:57.852] Capture standard output: TRUE
[18:00:57.852] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.852] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.852] Packages: <none>
[18:00:57.852] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.852] Resolved: TRUE
[18:00:57.852] Value: 112 bytes of class ‘list’
[18:00:57.852] Early signaling: FALSE
[18:00:57.852] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.852] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.854] Chunk #5 of 5 ... DONE
[18:00:57.854] Launching 5 futures (chunks) ... DONE
[18:00:57.854] Resolving 5 futures (chunks) ...
[18:00:57.855] resolve() on list ...
[18:00:57.855]  recursive: 0
[18:00:57.855]  length: 5
[18:00:57.855] 
[18:00:57.855] resolved() for ‘SequentialFuture’ ...
[18:00:57.856] - state: ‘finished’
[18:00:57.856] - run: TRUE
[18:00:57.856] - result: ‘FutureResult’
[18:00:57.856] resolved() for ‘SequentialFuture’ ... done
[18:00:57.856] Future #1
[18:00:57.857] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.857] - nx: 5
[18:00:57.857] - relay: TRUE
[18:00:57.857] - stdout: TRUE
[18:00:57.857] - signal: TRUE
[18:00:57.858] - resignal: FALSE
[18:00:57.858] - force: TRUE
[18:00:57.858] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[18:00:57.858] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[18:00:57.858]  - until=1
[18:00:57.859]  - relaying element #1
[18:00:57.859] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:00:57.859] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:00:57.859] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.860]  length: 4 (resolved future 1)
[18:00:57.860] resolved() for ‘SequentialFuture’ ...
[18:00:57.860] - state: ‘finished’
[18:00:57.860] - run: TRUE
[18:00:57.860] - result: ‘FutureResult’
[18:00:57.861] resolved() for ‘SequentialFuture’ ... done
[18:00:57.861] Future #2
[18:00:57.861] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:00:57.861] - nx: 5
[18:00:57.862] - relay: TRUE
[18:00:57.862] - stdout: TRUE
[18:00:57.862] - signal: TRUE
[18:00:57.862] - resignal: FALSE
[18:00:57.862] - force: TRUE
[18:00:57.862] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:00:57.863] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:00:57.863]  - until=2
[18:00:57.863]  - relaying element #2
[18:00:57.864] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:00:57.864] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:00:57.864] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:00:57.864]  length: 3 (resolved future 2)
[18:00:57.864] resolved() for ‘SequentialFuture’ ...
[18:00:57.865] - state: ‘finished’
[18:00:57.865] - run: TRUE
[18:00:57.865] - result: ‘FutureResult’
[18:00:57.865] resolved() for ‘SequentialFuture’ ... done
[18:00:57.865] Future #3
[18:00:57.866] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:00:57.866] - nx: 5
[18:00:57.866] - relay: TRUE
[18:00:57.866] - stdout: TRUE
[18:00:57.867] - signal: TRUE
[18:00:57.867] - resignal: FALSE
[18:00:57.867] - force: TRUE
[18:00:57.867] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:00:57.867] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:00:57.867]  - until=3
[18:00:57.868]  - relaying element #3
[18:00:57.868] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:00:57.868] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:00:57.869] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:00:57.869]  length: 2 (resolved future 3)
[18:00:57.869] resolved() for ‘SequentialFuture’ ...
[18:00:57.870] - state: ‘finished’
[18:00:57.870] - run: TRUE
[18:00:57.870] - result: ‘FutureResult’
[18:00:57.870] resolved() for ‘SequentialFuture’ ... done
[18:00:57.870] Future #4
[18:00:57.871] signalConditionsASAP(SequentialFuture, pos=4) ...
[18:00:57.871] - nx: 5
[18:00:57.871] - relay: TRUE
[18:00:57.871] - stdout: TRUE
[18:00:57.871] - signal: TRUE
[18:00:57.872] - resignal: FALSE
[18:00:57.872] - force: TRUE
[18:00:57.872] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:00:57.872] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:00:57.872]  - until=4
[18:00:57.872]  - relaying element #4
[18:00:57.873] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:00:57.873] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:00:57.873] signalConditionsASAP(SequentialFuture, pos=4) ... done
[18:00:57.874]  length: 1 (resolved future 4)
[18:00:57.874] resolved() for ‘SequentialFuture’ ...
[18:00:57.874] - state: ‘finished’
[18:00:57.874] - run: TRUE
[18:00:57.874] - result: ‘FutureResult’
[18:00:57.875] resolved() for ‘SequentialFuture’ ... done
[18:00:57.875] Future #5
[18:00:57.875] signalConditionsASAP(SequentialFuture, pos=5) ...
[18:00:57.875] - nx: 5
[18:00:57.875] - relay: TRUE
[18:00:57.876] - stdout: TRUE
[18:00:57.876] - signal: TRUE
[18:00:57.876] - resignal: FALSE
[18:00:57.876] - force: TRUE
[18:00:57.876] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:00:57.877] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:00:57.877]  - until=5
[18:00:57.877]  - relaying element #5
[18:00:57.877] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:00:57.880] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:00:57.880] signalConditionsASAP(SequentialFuture, pos=5) ... done
[18:00:57.880]  length: 0 (resolved future 5)
[18:00:57.880] Relaying remaining futures
[18:00:57.881] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.881] - nx: 5
[18:00:57.881] - relay: TRUE
[18:00:57.881] - stdout: TRUE
[18:00:57.881] - signal: TRUE
[18:00:57.882] - resignal: FALSE
[18:00:57.882] - force: TRUE
[18:00:57.882] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:00:57.882] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[18:00:57.882] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:00:57.883] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:00:57.883] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.883] resolve() on list ... DONE
[18:00:57.884]  - Number of value chunks collected: 5
[18:00:57.884] Resolving 5 futures (chunks) ... DONE
[18:00:57.884] Reducing values from 5 chunks ...
[18:00:57.884]  - Number of values collected after concatenation: 5
[18:00:57.885]  - Number of values expected: 5
[18:00:57.885] Reducing values from 5 chunks ... DONE
[18:00:57.885] future_mapply() ... DONE
[18:00:57.886] future_mapply() ...
[18:00:57.886] Number of chunks: 1
[18:00:57.886] getGlobalsAndPackagesXApply() ...
[18:00:57.886]  - future.globals: TRUE
[18:00:57.887] getGlobalsAndPackages() ...
[18:00:57.887] Searching for globals...
[18:00:57.889] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:00:57.890] Searching for globals ... DONE
[18:00:57.890] Resolving globals: FALSE
[18:00:57.890] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:00:57.891] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:00:57.891] - globals: [1] ‘FUN’
[18:00:57.891] 
[18:00:57.892] getGlobalsAndPackages() ... DONE
[18:00:57.892]  - globals found/used: [n=1] ‘FUN’
[18:00:57.892]  - needed namespaces: [n=0] 
[18:00:57.892] Finding globals ... DONE
[18:00:57.893] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.893] List of 2
[18:00:57.893]  $ ...future.FUN:function (C, k)  
[18:00:57.893]  $ MoreArgs     : list()
[18:00:57.893]  - attr(*, "where")=List of 2
[18:00:57.893]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.893]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.893]  - attr(*, "resolved")= logi FALSE
[18:00:57.893]  - attr(*, "total_size")= num NA
[18:00:57.898] Packages to be attached in all futures: [n=0] 
[18:00:57.898] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.898] Number of futures (= number of chunks): 1
[18:00:57.898] Launching 1 futures (chunks) ...
[18:00:57.899] Chunk #1 of 1 ...
[18:00:57.899]  - Finding globals in '...' for chunk #1 ...
[18:00:57.899] getGlobalsAndPackages() ...
[18:00:57.899] Searching for globals...
[18:00:57.900] 
[18:00:57.900] Searching for globals ... DONE
[18:00:57.900] - globals: [0] <none>
[18:00:57.901] getGlobalsAndPackages() ... DONE
[18:00:57.901]    + additional globals found: [n=0] 
[18:00:57.901]    + additional namespaces needed: [n=0] 
[18:00:57.901]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.901]  - seeds: <none>
[18:00:57.901]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.902] getGlobalsAndPackages() ...
[18:00:57.902] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.902] Resolving globals: FALSE
[18:00:57.903] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[18:00:57.904] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:00:57.904] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.905] 
[18:00:57.905] getGlobalsAndPackages() ... DONE
[18:00:57.905] run() for ‘Future’ ...
[18:00:57.905] - state: ‘created’
[18:00:57.906] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.906] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.907]   - Field: ‘label’
[18:00:57.907]   - Field: ‘local’
[18:00:57.907]   - Field: ‘owner’
[18:00:57.907]   - Field: ‘envir’
[18:00:57.907]   - Field: ‘packages’
[18:00:57.908]   - Field: ‘gc’
[18:00:57.908]   - Field: ‘conditions’
[18:00:57.908]   - Field: ‘expr’
[18:00:57.908]   - Field: ‘uuid’
[18:00:57.908]   - Field: ‘seed’
[18:00:57.909]   - Field: ‘version’
[18:00:57.909]   - Field: ‘result’
[18:00:57.909]   - Field: ‘asynchronous’
[18:00:57.909]   - Field: ‘calls’
[18:00:57.909]   - Field: ‘globals’
[18:00:57.910]   - Field: ‘stdout’
[18:00:57.910]   - Field: ‘earlySignal’
[18:00:57.910]   - Field: ‘lazy’
[18:00:57.910]   - Field: ‘state’
[18:00:57.910] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.911] - Launch lazy future ...
[18:00:57.911] Packages needed by the future expression (n = 0): <none>
[18:00:57.911] Packages needed by future strategies (n = 0): <none>
[18:00:57.912] {
[18:00:57.912]     {
[18:00:57.912]         {
[18:00:57.912]             ...future.startTime <- base::Sys.time()
[18:00:57.912]             {
[18:00:57.912]                 {
[18:00:57.912]                   {
[18:00:57.912]                     base::local({
[18:00:57.912]                       has_future <- base::requireNamespace("future", 
[18:00:57.912]                         quietly = TRUE)
[18:00:57.912]                       if (has_future) {
[18:00:57.912]                         ns <- base::getNamespace("future")
[18:00:57.912]                         version <- ns[[".package"]][["version"]]
[18:00:57.912]                         if (is.null(version)) 
[18:00:57.912]                           version <- utils::packageVersion("future")
[18:00:57.912]                       }
[18:00:57.912]                       else {
[18:00:57.912]                         version <- NULL
[18:00:57.912]                       }
[18:00:57.912]                       if (!has_future || version < "1.8.0") {
[18:00:57.912]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.912]                           "", base::R.version$version.string), 
[18:00:57.912]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.912]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.912]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.912]                             "release", "version")], collapse = " "), 
[18:00:57.912]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.912]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.912]                           info)
[18:00:57.912]                         info <- base::paste(info, collapse = "; ")
[18:00:57.912]                         if (!has_future) {
[18:00:57.912]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.912]                             info)
[18:00:57.912]                         }
[18:00:57.912]                         else {
[18:00:57.912]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.912]                             info, version)
[18:00:57.912]                         }
[18:00:57.912]                         base::stop(msg)
[18:00:57.912]                       }
[18:00:57.912]                     })
[18:00:57.912]                   }
[18:00:57.912]                   ...future.strategy.old <- future::plan("list")
[18:00:57.912]                   options(future.plan = NULL)
[18:00:57.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.912]                 }
[18:00:57.912]                 ...future.workdir <- getwd()
[18:00:57.912]             }
[18:00:57.912]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.912]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.912]         }
[18:00:57.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:57.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.912]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.912]             base::names(...future.oldOptions))
[18:00:57.912]     }
[18:00:57.912]     if (FALSE) {
[18:00:57.912]     }
[18:00:57.912]     else {
[18:00:57.912]         if (TRUE) {
[18:00:57.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.912]                 open = "w")
[18:00:57.912]         }
[18:00:57.912]         else {
[18:00:57.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.912]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.912]         }
[18:00:57.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.912]             base::sink(type = "output", split = FALSE)
[18:00:57.912]             base::close(...future.stdout)
[18:00:57.912]         }, add = TRUE)
[18:00:57.912]     }
[18:00:57.912]     ...future.frame <- base::sys.nframe()
[18:00:57.912]     ...future.conditions <- base::list()
[18:00:57.912]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.912]     if (FALSE) {
[18:00:57.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.912]     }
[18:00:57.912]     ...future.result <- base::tryCatch({
[18:00:57.912]         base::withCallingHandlers({
[18:00:57.912]             ...future.value <- base::withVisible(base::local({
[18:00:57.912]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.912]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.912]                   ...future.globals.maxSize)) {
[18:00:57.912]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.912]                   on.exit(options(oopts), add = TRUE)
[18:00:57.912]                 }
[18:00:57.912]                 {
[18:00:57.912]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.912]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.912]                     USE.NAMES = FALSE)
[18:00:57.912]                   do.call(mapply, args = args)
[18:00:57.912]                 }
[18:00:57.912]             }))
[18:00:57.912]             future::FutureResult(value = ...future.value$value, 
[18:00:57.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.912]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.912]                     ...future.globalenv.names))
[18:00:57.912]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.912]         }, condition = base::local({
[18:00:57.912]             c <- base::c
[18:00:57.912]             inherits <- base::inherits
[18:00:57.912]             invokeRestart <- base::invokeRestart
[18:00:57.912]             length <- base::length
[18:00:57.912]             list <- base::list
[18:00:57.912]             seq.int <- base::seq.int
[18:00:57.912]             signalCondition <- base::signalCondition
[18:00:57.912]             sys.calls <- base::sys.calls
[18:00:57.912]             `[[` <- base::`[[`
[18:00:57.912]             `+` <- base::`+`
[18:00:57.912]             `<<-` <- base::`<<-`
[18:00:57.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.912]                   3L)]
[18:00:57.912]             }
[18:00:57.912]             function(cond) {
[18:00:57.912]                 is_error <- inherits(cond, "error")
[18:00:57.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.912]                   NULL)
[18:00:57.912]                 if (is_error) {
[18:00:57.912]                   sessionInformation <- function() {
[18:00:57.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.912]                       search = base::search(), system = base::Sys.info())
[18:00:57.912]                   }
[18:00:57.912]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.912]                     cond$call), session = sessionInformation(), 
[18:00:57.912]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.912]                   signalCondition(cond)
[18:00:57.912]                 }
[18:00:57.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.912]                 "immediateCondition"))) {
[18:00:57.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.912]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.912]                   if (TRUE && !signal) {
[18:00:57.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.912]                     {
[18:00:57.912]                       inherits <- base::inherits
[18:00:57.912]                       invokeRestart <- base::invokeRestart
[18:00:57.912]                       is.null <- base::is.null
[18:00:57.912]                       muffled <- FALSE
[18:00:57.912]                       if (inherits(cond, "message")) {
[18:00:57.912]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.912]                         if (muffled) 
[18:00:57.912]                           invokeRestart("muffleMessage")
[18:00:57.912]                       }
[18:00:57.912]                       else if (inherits(cond, "warning")) {
[18:00:57.912]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.912]                         if (muffled) 
[18:00:57.912]                           invokeRestart("muffleWarning")
[18:00:57.912]                       }
[18:00:57.912]                       else if (inherits(cond, "condition")) {
[18:00:57.912]                         if (!is.null(pattern)) {
[18:00:57.912]                           computeRestarts <- base::computeRestarts
[18:00:57.912]                           grepl <- base::grepl
[18:00:57.912]                           restarts <- computeRestarts(cond)
[18:00:57.912]                           for (restart in restarts) {
[18:00:57.912]                             name <- restart$name
[18:00:57.912]                             if (is.null(name)) 
[18:00:57.912]                               next
[18:00:57.912]                             if (!grepl(pattern, name)) 
[18:00:57.912]                               next
[18:00:57.912]                             invokeRestart(restart)
[18:00:57.912]                             muffled <- TRUE
[18:00:57.912]                             break
[18:00:57.912]                           }
[18:00:57.912]                         }
[18:00:57.912]                       }
[18:00:57.912]                       invisible(muffled)
[18:00:57.912]                     }
[18:00:57.912]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.912]                   }
[18:00:57.912]                 }
[18:00:57.912]                 else {
[18:00:57.912]                   if (TRUE) {
[18:00:57.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.912]                     {
[18:00:57.912]                       inherits <- base::inherits
[18:00:57.912]                       invokeRestart <- base::invokeRestart
[18:00:57.912]                       is.null <- base::is.null
[18:00:57.912]                       muffled <- FALSE
[18:00:57.912]                       if (inherits(cond, "message")) {
[18:00:57.912]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.912]                         if (muffled) 
[18:00:57.912]                           invokeRestart("muffleMessage")
[18:00:57.912]                       }
[18:00:57.912]                       else if (inherits(cond, "warning")) {
[18:00:57.912]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.912]                         if (muffled) 
[18:00:57.912]                           invokeRestart("muffleWarning")
[18:00:57.912]                       }
[18:00:57.912]                       else if (inherits(cond, "condition")) {
[18:00:57.912]                         if (!is.null(pattern)) {
[18:00:57.912]                           computeRestarts <- base::computeRestarts
[18:00:57.912]                           grepl <- base::grepl
[18:00:57.912]                           restarts <- computeRestarts(cond)
[18:00:57.912]                           for (restart in restarts) {
[18:00:57.912]                             name <- restart$name
[18:00:57.912]                             if (is.null(name)) 
[18:00:57.912]                               next
[18:00:57.912]                             if (!grepl(pattern, name)) 
[18:00:57.912]                               next
[18:00:57.912]                             invokeRestart(restart)
[18:00:57.912]                             muffled <- TRUE
[18:00:57.912]                             break
[18:00:57.912]                           }
[18:00:57.912]                         }
[18:00:57.912]                       }
[18:00:57.912]                       invisible(muffled)
[18:00:57.912]                     }
[18:00:57.912]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.912]                   }
[18:00:57.912]                 }
[18:00:57.912]             }
[18:00:57.912]         }))
[18:00:57.912]     }, error = function(ex) {
[18:00:57.912]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.912]                 ...future.rng), started = ...future.startTime, 
[18:00:57.912]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.912]             version = "1.8"), class = "FutureResult")
[18:00:57.912]     }, finally = {
[18:00:57.912]         if (!identical(...future.workdir, getwd())) 
[18:00:57.912]             setwd(...future.workdir)
[18:00:57.912]         {
[18:00:57.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.912]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.912]             }
[18:00:57.912]             base::options(...future.oldOptions)
[18:00:57.912]             if (.Platform$OS.type == "windows") {
[18:00:57.912]                 old_names <- names(...future.oldEnvVars)
[18:00:57.912]                 envs <- base::Sys.getenv()
[18:00:57.912]                 names <- names(envs)
[18:00:57.912]                 common <- intersect(names, old_names)
[18:00:57.912]                 added <- setdiff(names, old_names)
[18:00:57.912]                 removed <- setdiff(old_names, names)
[18:00:57.912]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.912]                   envs[common]]
[18:00:57.912]                 NAMES <- toupper(changed)
[18:00:57.912]                 args <- list()
[18:00:57.912]                 for (kk in seq_along(NAMES)) {
[18:00:57.912]                   name <- changed[[kk]]
[18:00:57.912]                   NAME <- NAMES[[kk]]
[18:00:57.912]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.912]                     next
[18:00:57.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.912]                 }
[18:00:57.912]                 NAMES <- toupper(added)
[18:00:57.912]                 for (kk in seq_along(NAMES)) {
[18:00:57.912]                   name <- added[[kk]]
[18:00:57.912]                   NAME <- NAMES[[kk]]
[18:00:57.912]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.912]                     next
[18:00:57.912]                   args[[name]] <- ""
[18:00:57.912]                 }
[18:00:57.912]                 NAMES <- toupper(removed)
[18:00:57.912]                 for (kk in seq_along(NAMES)) {
[18:00:57.912]                   name <- removed[[kk]]
[18:00:57.912]                   NAME <- NAMES[[kk]]
[18:00:57.912]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.912]                     next
[18:00:57.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.912]                 }
[18:00:57.912]                 if (length(args) > 0) 
[18:00:57.912]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.912]             }
[18:00:57.912]             else {
[18:00:57.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.912]             }
[18:00:57.912]             {
[18:00:57.912]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.912]                   0L) {
[18:00:57.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.912]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.912]                   base::options(opts)
[18:00:57.912]                 }
[18:00:57.912]                 {
[18:00:57.912]                   {
[18:00:57.912]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.912]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.912]                     1423455687L), envir = base::globalenv(), 
[18:00:57.912]                       inherits = FALSE)
[18:00:57.912]                     NULL
[18:00:57.912]                   }
[18:00:57.912]                   options(future.plan = NULL)
[18:00:57.912]                   if (is.na(NA_character_)) 
[18:00:57.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.912]                     .init = FALSE)
[18:00:57.912]                 }
[18:00:57.912]             }
[18:00:57.912]         }
[18:00:57.912]     })
[18:00:57.912]     if (TRUE) {
[18:00:57.912]         base::sink(type = "output", split = FALSE)
[18:00:57.912]         if (TRUE) {
[18:00:57.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.912]         }
[18:00:57.912]         else {
[18:00:57.912]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.912]         }
[18:00:57.912]         base::close(...future.stdout)
[18:00:57.912]         ...future.stdout <- NULL
[18:00:57.912]     }
[18:00:57.912]     ...future.result$conditions <- ...future.conditions
[18:00:57.912]     ...future.result$finished <- base::Sys.time()
[18:00:57.912]     ...future.result
[18:00:57.912] }
[18:00:57.915] assign_globals() ...
[18:00:57.915] List of 5
[18:00:57.915]  $ ...future.FUN            :function (C, k)  
[18:00:57.915]  $ MoreArgs                 : list()
[18:00:57.915]  $ ...future.elements_ii    :List of 2
[18:00:57.915]   ..$ :List of 5
[18:00:57.915]   .. ..$ : chr "A"
[18:00:57.915]   .. ..$ : chr "B"
[18:00:57.915]   .. ..$ : chr "C"
[18:00:57.915]   .. ..$ : chr "D"
[18:00:57.915]   .. ..$ : chr "E"
[18:00:57.915]   ..$ :List of 5
[18:00:57.915]   .. ..$ : int 5
[18:00:57.915]   .. ..$ : int 4
[18:00:57.915]   .. ..$ : int 3
[18:00:57.915]   .. ..$ : int 2
[18:00:57.915]   .. ..$ : int 1
[18:00:57.915]  $ ...future.seeds_ii       : NULL
[18:00:57.915]  $ ...future.globals.maxSize: NULL
[18:00:57.915]  - attr(*, "where")=List of 5
[18:00:57.915]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.915]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.915]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.915]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.915]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.915]  - attr(*, "resolved")= logi FALSE
[18:00:57.915]  - attr(*, "total_size")= num 4160
[18:00:57.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.915]  - attr(*, "already-done")= logi TRUE
[18:00:57.930] - reassign environment for ‘...future.FUN’
[18:00:57.930] - copied ‘...future.FUN’ to environment
[18:00:57.932] - copied ‘MoreArgs’ to environment
[18:00:57.932] - copied ‘...future.elements_ii’ to environment
[18:00:57.933] - copied ‘...future.seeds_ii’ to environment
[18:00:57.933] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.933] assign_globals() ... done
[18:00:57.934] plan(): Setting new future strategy stack:
[18:00:57.934] List of future strategies:
[18:00:57.934] 1. sequential:
[18:00:57.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.934]    - tweaked: FALSE
[18:00:57.934]    - call: NULL
[18:00:57.935] plan(): nbrOfWorkers() = 1
[18:00:57.936] plan(): Setting new future strategy stack:
[18:00:57.937] List of future strategies:
[18:00:57.937] 1. sequential:
[18:00:57.937]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.937]    - tweaked: FALSE
[18:00:57.937]    - call: plan(strategy)
[18:00:57.937] plan(): nbrOfWorkers() = 1
[18:00:57.938] SequentialFuture started (and completed)
[18:00:57.938] - Launch lazy future ... done
[18:00:57.938] run() for ‘SequentialFuture’ ... done
[18:00:57.939] Created future:
[18:00:57.939] SequentialFuture:
[18:00:57.939] Label: ‘future_.mapply-1’
[18:00:57.939] Expression:
[18:00:57.939] {
[18:00:57.939]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.939]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:57.939]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.939]         on.exit(options(oopts), add = TRUE)
[18:00:57.939]     }
[18:00:57.939]     {
[18:00:57.939]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.939]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:57.939]         do.call(mapply, args = args)
[18:00:57.939]     }
[18:00:57.939] }
[18:00:57.939] Lazy evaluation: FALSE
[18:00:57.939] Asynchronous evaluation: FALSE
[18:00:57.939] Local evaluation: TRUE
[18:00:57.939] Environment: R_GlobalEnv
[18:00:57.939] Capture standard output: TRUE
[18:00:57.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:57.939] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:57.939] Packages: <none>
[18:00:57.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:57.939] Resolved: TRUE
[18:00:57.939] Value: 560 bytes of class ‘list’
[18:00:57.939] Early signaling: FALSE
[18:00:57.939] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:57.939] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.941] Chunk #1 of 1 ... DONE
[18:00:57.941] Launching 1 futures (chunks) ... DONE
[18:00:57.941] Resolving 1 futures (chunks) ...
[18:00:57.942] resolve() on list ...
[18:00:57.942]  recursive: 0
[18:00:57.942]  length: 1
[18:00:57.942] 
[18:00:57.942] resolved() for ‘SequentialFuture’ ...
[18:00:57.943] - state: ‘finished’
[18:00:57.943] - run: TRUE
[18:00:57.943] - result: ‘FutureResult’
[18:00:57.943] resolved() for ‘SequentialFuture’ ... done
[18:00:57.943] Future #1
[18:00:57.944] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:57.944] - nx: 1
[18:00:57.944] - relay: TRUE
[18:00:57.944] - stdout: TRUE
[18:00:57.944] - signal: TRUE
[18:00:57.944] - resignal: FALSE
[18:00:57.945] - force: TRUE
[18:00:57.945] - relayed: [n=1] FALSE
[18:00:57.945] - queued futures: [n=1] FALSE
[18:00:57.945]  - until=1
[18:00:57.945]  - relaying element #1
[18:00:57.946] - relayed: [n=1] TRUE
[18:00:57.946] - queued futures: [n=1] TRUE
[18:00:57.946] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:57.946]  length: 0 (resolved future 1)
[18:00:57.947] Relaying remaining futures
[18:00:57.947] signalConditionsASAP(NULL, pos=0) ...
[18:00:57.947] - nx: 1
[18:00:57.947] - relay: TRUE
[18:00:57.947] - stdout: TRUE
[18:00:57.947] - signal: TRUE
[18:00:57.948] - resignal: FALSE
[18:00:57.948] - force: TRUE
[18:00:57.948] - relayed: [n=1] TRUE
[18:00:57.948] - queued futures: [n=1] TRUE
 - flush all
[18:00:57.948] - relayed: [n=1] TRUE
[18:00:57.949] - queued futures: [n=1] TRUE
[18:00:57.949] signalConditionsASAP(NULL, pos=0) ... done
[18:00:57.949] resolve() on list ... DONE
[18:00:57.949]  - Number of value chunks collected: 1
[18:00:57.949] Resolving 1 futures (chunks) ... DONE
[18:00:57.950] Reducing values from 1 chunks ...
[18:00:57.950]  - Number of values collected after concatenation: 5
[18:00:57.950]  - Number of values expected: 5
[18:00:57.950] Reducing values from 1 chunks ... DONE
[18:00:57.950] future_mapply() ... DONE
[18:00:57.951] future_mapply() ...
[18:00:57.952] Number of chunks: 3
[18:00:57.952] Index remapping (attribute 'ordering'): [n = 5] 3, 1, 5, 4, 2
[18:00:57.952] getGlobalsAndPackagesXApply() ...
[18:00:57.952]  - future.globals: TRUE
[18:00:57.952] getGlobalsAndPackages() ...
[18:00:57.953] Searching for globals...
[18:00:57.955] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:00:57.955] Searching for globals ... DONE
[18:00:57.955] Resolving globals: FALSE
[18:00:57.956] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:00:57.957] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:00:57.957] - globals: [1] ‘FUN’
[18:00:57.957] 
[18:00:57.957] getGlobalsAndPackages() ... DONE
[18:00:57.958]  - globals found/used: [n=1] ‘FUN’
[18:00:57.958]  - needed namespaces: [n=0] 
[18:00:57.958] Finding globals ... DONE
[18:00:57.958] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:57.959] List of 2
[18:00:57.959]  $ ...future.FUN:function (C, k)  
[18:00:57.959]  $ MoreArgs     : NULL
[18:00:57.959]  - attr(*, "where")=List of 2
[18:00:57.959]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:57.959]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:57.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.959]  - attr(*, "resolved")= logi FALSE
[18:00:57.959]  - attr(*, "total_size")= num NA
[18:00:57.963] Packages to be attached in all futures: [n=0] 
[18:00:57.964] getGlobalsAndPackagesXApply() ... DONE
[18:00:57.964] Number of futures (= number of chunks): 3
[18:00:57.964] Launching 3 futures (chunks) ...
[18:00:57.964] Chunk #1 of 3 ...
[18:00:57.965]  - Finding globals in '...' for chunk #1 ...
[18:00:57.965] getGlobalsAndPackages() ...
[18:00:57.965] Searching for globals...
[18:00:57.966] 
[18:00:57.966] Searching for globals ... DONE
[18:00:57.966] - globals: [0] <none>
[18:00:57.966] getGlobalsAndPackages() ... DONE
[18:00:57.966]    + additional globals found: [n=0] 
[18:00:57.967]    + additional namespaces needed: [n=0] 
[18:00:57.967]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:57.967]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:00:57.967]  - seeds: <none>
[18:00:57.967]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.968] getGlobalsAndPackages() ...
[18:00:57.968] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.968] Resolving globals: FALSE
[18:00:57.969] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:00:57.970] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:57.970] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:57.971] 
[18:00:57.971] getGlobalsAndPackages() ... DONE
[18:00:57.971] run() for ‘Future’ ...
[18:00:57.971] - state: ‘created’
[18:00:57.972] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:57.972] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:57.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:57.973]   - Field: ‘label’
[18:00:57.973]   - Field: ‘local’
[18:00:57.973]   - Field: ‘owner’
[18:00:57.973]   - Field: ‘envir’
[18:00:57.973]   - Field: ‘packages’
[18:00:57.974]   - Field: ‘gc’
[18:00:57.974]   - Field: ‘conditions’
[18:00:57.974]   - Field: ‘expr’
[18:00:57.974]   - Field: ‘uuid’
[18:00:57.974]   - Field: ‘seed’
[18:00:57.975]   - Field: ‘version’
[18:00:57.975]   - Field: ‘result’
[18:00:57.975]   - Field: ‘asynchronous’
[18:00:57.975]   - Field: ‘calls’
[18:00:57.975]   - Field: ‘globals’
[18:00:57.976]   - Field: ‘stdout’
[18:00:57.976]   - Field: ‘earlySignal’
[18:00:57.976]   - Field: ‘lazy’
[18:00:57.976]   - Field: ‘state’
[18:00:57.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:57.977] - Launch lazy future ...
[18:00:57.977] Packages needed by the future expression (n = 0): <none>
[18:00:57.977] Packages needed by future strategies (n = 0): <none>
[18:00:57.978] {
[18:00:57.978]     {
[18:00:57.978]         {
[18:00:57.978]             ...future.startTime <- base::Sys.time()
[18:00:57.978]             {
[18:00:57.978]                 {
[18:00:57.978]                   {
[18:00:57.978]                     base::local({
[18:00:57.978]                       has_future <- base::requireNamespace("future", 
[18:00:57.978]                         quietly = TRUE)
[18:00:57.978]                       if (has_future) {
[18:00:57.978]                         ns <- base::getNamespace("future")
[18:00:57.978]                         version <- ns[[".package"]][["version"]]
[18:00:57.978]                         if (is.null(version)) 
[18:00:57.978]                           version <- utils::packageVersion("future")
[18:00:57.978]                       }
[18:00:57.978]                       else {
[18:00:57.978]                         version <- NULL
[18:00:57.978]                       }
[18:00:57.978]                       if (!has_future || version < "1.8.0") {
[18:00:57.978]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:57.978]                           "", base::R.version$version.string), 
[18:00:57.978]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:57.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:57.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:57.978]                             "release", "version")], collapse = " "), 
[18:00:57.978]                           hostname = base::Sys.info()[["nodename"]])
[18:00:57.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:57.978]                           info)
[18:00:57.978]                         info <- base::paste(info, collapse = "; ")
[18:00:57.978]                         if (!has_future) {
[18:00:57.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:57.978]                             info)
[18:00:57.978]                         }
[18:00:57.978]                         else {
[18:00:57.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:57.978]                             info, version)
[18:00:57.978]                         }
[18:00:57.978]                         base::stop(msg)
[18:00:57.978]                       }
[18:00:57.978]                     })
[18:00:57.978]                   }
[18:00:57.978]                   ...future.strategy.old <- future::plan("list")
[18:00:57.978]                   options(future.plan = NULL)
[18:00:57.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:57.978]                 }
[18:00:57.978]                 ...future.workdir <- getwd()
[18:00:57.978]             }
[18:00:57.978]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:57.978]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:57.978]         }
[18:00:57.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:57.978]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:00:57.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:57.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:57.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:57.978]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:57.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:57.978]             base::names(...future.oldOptions))
[18:00:57.978]     }
[18:00:57.978]     if (FALSE) {
[18:00:57.978]     }
[18:00:57.978]     else {
[18:00:57.978]         if (TRUE) {
[18:00:57.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:57.978]                 open = "w")
[18:00:57.978]         }
[18:00:57.978]         else {
[18:00:57.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:57.978]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:57.978]         }
[18:00:57.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:57.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:57.978]             base::sink(type = "output", split = FALSE)
[18:00:57.978]             base::close(...future.stdout)
[18:00:57.978]         }, add = TRUE)
[18:00:57.978]     }
[18:00:57.978]     ...future.frame <- base::sys.nframe()
[18:00:57.978]     ...future.conditions <- base::list()
[18:00:57.978]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:57.978]     if (FALSE) {
[18:00:57.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:57.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:57.978]     }
[18:00:57.978]     ...future.result <- base::tryCatch({
[18:00:57.978]         base::withCallingHandlers({
[18:00:57.978]             ...future.value <- base::withVisible(base::local({
[18:00:57.978]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:57.978]                 if (!identical(...future.globals.maxSize.org, 
[18:00:57.978]                   ...future.globals.maxSize)) {
[18:00:57.978]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:57.978]                   on.exit(options(oopts), add = TRUE)
[18:00:57.978]                 }
[18:00:57.978]                 {
[18:00:57.978]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:57.978]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:57.978]                     USE.NAMES = FALSE)
[18:00:57.978]                   do.call(mapply, args = args)
[18:00:57.978]                 }
[18:00:57.978]             }))
[18:00:57.978]             future::FutureResult(value = ...future.value$value, 
[18:00:57.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.978]                   ...future.rng), globalenv = if (FALSE) 
[18:00:57.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:57.978]                     ...future.globalenv.names))
[18:00:57.978]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:57.978]         }, condition = base::local({
[18:00:57.978]             c <- base::c
[18:00:57.978]             inherits <- base::inherits
[18:00:57.978]             invokeRestart <- base::invokeRestart
[18:00:57.978]             length <- base::length
[18:00:57.978]             list <- base::list
[18:00:57.978]             seq.int <- base::seq.int
[18:00:57.978]             signalCondition <- base::signalCondition
[18:00:57.978]             sys.calls <- base::sys.calls
[18:00:57.978]             `[[` <- base::`[[`
[18:00:57.978]             `+` <- base::`+`
[18:00:57.978]             `<<-` <- base::`<<-`
[18:00:57.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:57.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:57.978]                   3L)]
[18:00:57.978]             }
[18:00:57.978]             function(cond) {
[18:00:57.978]                 is_error <- inherits(cond, "error")
[18:00:57.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:57.978]                   NULL)
[18:00:57.978]                 if (is_error) {
[18:00:57.978]                   sessionInformation <- function() {
[18:00:57.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:57.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:57.978]                       search = base::search(), system = base::Sys.info())
[18:00:57.978]                   }
[18:00:57.978]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:57.978]                     cond$call), session = sessionInformation(), 
[18:00:57.978]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:57.978]                   signalCondition(cond)
[18:00:57.978]                 }
[18:00:57.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:57.978]                 "immediateCondition"))) {
[18:00:57.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:57.978]                   ...future.conditions[[length(...future.conditions) + 
[18:00:57.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:57.978]                   if (TRUE && !signal) {
[18:00:57.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.978]                     {
[18:00:57.978]                       inherits <- base::inherits
[18:00:57.978]                       invokeRestart <- base::invokeRestart
[18:00:57.978]                       is.null <- base::is.null
[18:00:57.978]                       muffled <- FALSE
[18:00:57.978]                       if (inherits(cond, "message")) {
[18:00:57.978]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.978]                         if (muffled) 
[18:00:57.978]                           invokeRestart("muffleMessage")
[18:00:57.978]                       }
[18:00:57.978]                       else if (inherits(cond, "warning")) {
[18:00:57.978]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.978]                         if (muffled) 
[18:00:57.978]                           invokeRestart("muffleWarning")
[18:00:57.978]                       }
[18:00:57.978]                       else if (inherits(cond, "condition")) {
[18:00:57.978]                         if (!is.null(pattern)) {
[18:00:57.978]                           computeRestarts <- base::computeRestarts
[18:00:57.978]                           grepl <- base::grepl
[18:00:57.978]                           restarts <- computeRestarts(cond)
[18:00:57.978]                           for (restart in restarts) {
[18:00:57.978]                             name <- restart$name
[18:00:57.978]                             if (is.null(name)) 
[18:00:57.978]                               next
[18:00:57.978]                             if (!grepl(pattern, name)) 
[18:00:57.978]                               next
[18:00:57.978]                             invokeRestart(restart)
[18:00:57.978]                             muffled <- TRUE
[18:00:57.978]                             break
[18:00:57.978]                           }
[18:00:57.978]                         }
[18:00:57.978]                       }
[18:00:57.978]                       invisible(muffled)
[18:00:57.978]                     }
[18:00:57.978]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.978]                   }
[18:00:57.978]                 }
[18:00:57.978]                 else {
[18:00:57.978]                   if (TRUE) {
[18:00:57.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:57.978]                     {
[18:00:57.978]                       inherits <- base::inherits
[18:00:57.978]                       invokeRestart <- base::invokeRestart
[18:00:57.978]                       is.null <- base::is.null
[18:00:57.978]                       muffled <- FALSE
[18:00:57.978]                       if (inherits(cond, "message")) {
[18:00:57.978]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:57.978]                         if (muffled) 
[18:00:57.978]                           invokeRestart("muffleMessage")
[18:00:57.978]                       }
[18:00:57.978]                       else if (inherits(cond, "warning")) {
[18:00:57.978]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:57.978]                         if (muffled) 
[18:00:57.978]                           invokeRestart("muffleWarning")
[18:00:57.978]                       }
[18:00:57.978]                       else if (inherits(cond, "condition")) {
[18:00:57.978]                         if (!is.null(pattern)) {
[18:00:57.978]                           computeRestarts <- base::computeRestarts
[18:00:57.978]                           grepl <- base::grepl
[18:00:57.978]                           restarts <- computeRestarts(cond)
[18:00:57.978]                           for (restart in restarts) {
[18:00:57.978]                             name <- restart$name
[18:00:57.978]                             if (is.null(name)) 
[18:00:57.978]                               next
[18:00:57.978]                             if (!grepl(pattern, name)) 
[18:00:57.978]                               next
[18:00:57.978]                             invokeRestart(restart)
[18:00:57.978]                             muffled <- TRUE
[18:00:57.978]                             break
[18:00:57.978]                           }
[18:00:57.978]                         }
[18:00:57.978]                       }
[18:00:57.978]                       invisible(muffled)
[18:00:57.978]                     }
[18:00:57.978]                     muffleCondition(cond, pattern = "^muffle")
[18:00:57.978]                   }
[18:00:57.978]                 }
[18:00:57.978]             }
[18:00:57.978]         }))
[18:00:57.978]     }, error = function(ex) {
[18:00:57.978]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:57.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:57.978]                 ...future.rng), started = ...future.startTime, 
[18:00:57.978]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:57.978]             version = "1.8"), class = "FutureResult")
[18:00:57.978]     }, finally = {
[18:00:57.978]         if (!identical(...future.workdir, getwd())) 
[18:00:57.978]             setwd(...future.workdir)
[18:00:57.978]         {
[18:00:57.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:57.978]                 ...future.oldOptions$nwarnings <- NULL
[18:00:57.978]             }
[18:00:57.978]             base::options(...future.oldOptions)
[18:00:57.978]             if (.Platform$OS.type == "windows") {
[18:00:57.978]                 old_names <- names(...future.oldEnvVars)
[18:00:57.978]                 envs <- base::Sys.getenv()
[18:00:57.978]                 names <- names(envs)
[18:00:57.978]                 common <- intersect(names, old_names)
[18:00:57.978]                 added <- setdiff(names, old_names)
[18:00:57.978]                 removed <- setdiff(old_names, names)
[18:00:57.978]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:57.978]                   envs[common]]
[18:00:57.978]                 NAMES <- toupper(changed)
[18:00:57.978]                 args <- list()
[18:00:57.978]                 for (kk in seq_along(NAMES)) {
[18:00:57.978]                   name <- changed[[kk]]
[18:00:57.978]                   NAME <- NAMES[[kk]]
[18:00:57.978]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.978]                     next
[18:00:57.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.978]                 }
[18:00:57.978]                 NAMES <- toupper(added)
[18:00:57.978]                 for (kk in seq_along(NAMES)) {
[18:00:57.978]                   name <- added[[kk]]
[18:00:57.978]                   NAME <- NAMES[[kk]]
[18:00:57.978]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.978]                     next
[18:00:57.978]                   args[[name]] <- ""
[18:00:57.978]                 }
[18:00:57.978]                 NAMES <- toupper(removed)
[18:00:57.978]                 for (kk in seq_along(NAMES)) {
[18:00:57.978]                   name <- removed[[kk]]
[18:00:57.978]                   NAME <- NAMES[[kk]]
[18:00:57.978]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:57.978]                     next
[18:00:57.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:57.978]                 }
[18:00:57.978]                 if (length(args) > 0) 
[18:00:57.978]                   base::do.call(base::Sys.setenv, args = args)
[18:00:57.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:57.978]             }
[18:00:57.978]             else {
[18:00:57.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:57.978]             }
[18:00:57.978]             {
[18:00:57.978]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:57.978]                   0L) {
[18:00:57.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:57.978]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:57.978]                   base::options(opts)
[18:00:57.978]                 }
[18:00:57.978]                 {
[18:00:57.978]                   {
[18:00:57.978]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:57.978]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:57.978]                     1423455687L), envir = base::globalenv(), 
[18:00:57.978]                       inherits = FALSE)
[18:00:57.978]                     NULL
[18:00:57.978]                   }
[18:00:57.978]                   options(future.plan = NULL)
[18:00:57.978]                   if (is.na(NA_character_)) 
[18:00:57.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:57.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:57.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:57.978]                     .init = FALSE)
[18:00:57.978]                 }
[18:00:57.978]             }
[18:00:57.978]         }
[18:00:57.978]     })
[18:00:57.978]     if (TRUE) {
[18:00:57.978]         base::sink(type = "output", split = FALSE)
[18:00:57.978]         if (TRUE) {
[18:00:57.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:57.978]         }
[18:00:57.978]         else {
[18:00:57.978]             ...future.result["stdout"] <- base::list(NULL)
[18:00:57.978]         }
[18:00:57.978]         base::close(...future.stdout)
[18:00:57.978]         ...future.stdout <- NULL
[18:00:57.978]     }
[18:00:57.978]     ...future.result$conditions <- ...future.conditions
[18:00:57.978]     ...future.result$finished <- base::Sys.time()
[18:00:57.978]     ...future.result
[18:00:57.978] }
[18:00:57.981] assign_globals() ...
[18:00:57.981] List of 5
[18:00:57.981]  $ ...future.FUN            :function (C, k)  
[18:00:57.981]  $ MoreArgs                 : NULL
[18:00:57.981]  $ ...future.elements_ii    :List of 2
[18:00:57.981]   ..$ :List of 2
[18:00:57.981]   .. ..$ : chr "C"
[18:00:57.981]   .. ..$ : chr "A"
[18:00:57.981]   ..$ :List of 2
[18:00:57.981]   .. ..$ : int 3
[18:00:57.981]   .. ..$ : int 5
[18:00:57.981]  $ ...future.seeds_ii       : NULL
[18:00:57.981]  $ ...future.globals.maxSize: NULL
[18:00:57.981]  - attr(*, "where")=List of 5
[18:00:57.981]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:57.981]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:57.981]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:57.981]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:57.981]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:57.981]  - attr(*, "resolved")= logi FALSE
[18:00:57.981]  - attr(*, "total_size")= num 3656
[18:00:57.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:57.981]  - attr(*, "already-done")= logi TRUE
[18:00:57.995] - reassign environment for ‘...future.FUN’
[18:00:57.995] - copied ‘...future.FUN’ to environment
[18:00:57.995] - copied ‘MoreArgs’ to environment
[18:00:57.996] - copied ‘...future.elements_ii’ to environment
[18:00:57.996] - copied ‘...future.seeds_ii’ to environment
[18:00:57.996] - copied ‘...future.globals.maxSize’ to environment
[18:00:57.996] assign_globals() ... done
[18:00:57.997] plan(): Setting new future strategy stack:
[18:00:57.997] List of future strategies:
[18:00:57.997] 1. sequential:
[18:00:57.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:57.997]    - tweaked: FALSE
[18:00:57.997]    - call: NULL
[18:00:57.998] plan(): nbrOfWorkers() = 1
[18:00:57.999] plan(): Setting new future strategy stack:
[18:00:58.000] List of future strategies:
[18:00:58.000] 1. sequential:
[18:00:58.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.000]    - tweaked: FALSE
[18:00:58.000]    - call: plan(strategy)
[18:00:58.000] plan(): nbrOfWorkers() = 1
[18:00:58.001] SequentialFuture started (and completed)
[18:00:58.001] - Launch lazy future ... done
[18:00:58.001] run() for ‘SequentialFuture’ ... done
[18:00:58.001] Created future:
[18:00:58.002] SequentialFuture:
[18:00:58.002] Label: ‘future_mapply-1’
[18:00:58.002] Expression:
[18:00:58.002] {
[18:00:58.002]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.002]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.002]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.002]         on.exit(options(oopts), add = TRUE)
[18:00:58.002]     }
[18:00:58.002]     {
[18:00:58.002]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.002]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.002]         do.call(mapply, args = args)
[18:00:58.002]     }
[18:00:58.002] }
[18:00:58.002] Lazy evaluation: FALSE
[18:00:58.002] Asynchronous evaluation: FALSE
[18:00:58.002] Local evaluation: TRUE
[18:00:58.002] Environment: R_GlobalEnv
[18:00:58.002] Capture standard output: TRUE
[18:00:58.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.002] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.002] Packages: <none>
[18:00:58.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.002] Resolved: TRUE
[18:00:58.002] Value: 224 bytes of class ‘list’
[18:00:58.002] Early signaling: FALSE
[18:00:58.002] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.002] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.003] Chunk #1 of 3 ... DONE
[18:00:58.004] Chunk #2 of 3 ...
[18:00:58.004]  - Finding globals in '...' for chunk #2 ...
[18:00:58.004] getGlobalsAndPackages() ...
[18:00:58.004] Searching for globals...
[18:00:58.005] 
[18:00:58.005] Searching for globals ... DONE
[18:00:58.005] - globals: [0] <none>
[18:00:58.005] getGlobalsAndPackages() ... DONE
[18:00:58.006]    + additional globals found: [n=0] 
[18:00:58.006]    + additional namespaces needed: [n=0] 
[18:00:58.006]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:58.006]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:00:58.006]  - seeds: <none>
[18:00:58.007]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.007] getGlobalsAndPackages() ...
[18:00:58.007] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.007] Resolving globals: FALSE
[18:00:58.008] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:00:58.009] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.009] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.010] 
[18:00:58.010] getGlobalsAndPackages() ... DONE
[18:00:58.010] run() for ‘Future’ ...
[18:00:58.011] - state: ‘created’
[18:00:58.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.011] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.012]   - Field: ‘label’
[18:00:58.012]   - Field: ‘local’
[18:00:58.012]   - Field: ‘owner’
[18:00:58.012]   - Field: ‘envir’
[18:00:58.013]   - Field: ‘packages’
[18:00:58.013]   - Field: ‘gc’
[18:00:58.013]   - Field: ‘conditions’
[18:00:58.013]   - Field: ‘expr’
[18:00:58.013]   - Field: ‘uuid’
[18:00:58.014]   - Field: ‘seed’
[18:00:58.014]   - Field: ‘version’
[18:00:58.014]   - Field: ‘result’
[18:00:58.014]   - Field: ‘asynchronous’
[18:00:58.014]   - Field: ‘calls’
[18:00:58.014]   - Field: ‘globals’
[18:00:58.015]   - Field: ‘stdout’
[18:00:58.015]   - Field: ‘earlySignal’
[18:00:58.015]   - Field: ‘lazy’
[18:00:58.015]   - Field: ‘state’
[18:00:58.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.016] - Launch lazy future ...
[18:00:58.016] Packages needed by the future expression (n = 0): <none>
[18:00:58.016] Packages needed by future strategies (n = 0): <none>
[18:00:58.017] {
[18:00:58.017]     {
[18:00:58.017]         {
[18:00:58.017]             ...future.startTime <- base::Sys.time()
[18:00:58.017]             {
[18:00:58.017]                 {
[18:00:58.017]                   {
[18:00:58.017]                     base::local({
[18:00:58.017]                       has_future <- base::requireNamespace("future", 
[18:00:58.017]                         quietly = TRUE)
[18:00:58.017]                       if (has_future) {
[18:00:58.017]                         ns <- base::getNamespace("future")
[18:00:58.017]                         version <- ns[[".package"]][["version"]]
[18:00:58.017]                         if (is.null(version)) 
[18:00:58.017]                           version <- utils::packageVersion("future")
[18:00:58.017]                       }
[18:00:58.017]                       else {
[18:00:58.017]                         version <- NULL
[18:00:58.017]                       }
[18:00:58.017]                       if (!has_future || version < "1.8.0") {
[18:00:58.017]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.017]                           "", base::R.version$version.string), 
[18:00:58.017]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.017]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.017]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.017]                             "release", "version")], collapse = " "), 
[18:00:58.017]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.017]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.017]                           info)
[18:00:58.017]                         info <- base::paste(info, collapse = "; ")
[18:00:58.017]                         if (!has_future) {
[18:00:58.017]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.017]                             info)
[18:00:58.017]                         }
[18:00:58.017]                         else {
[18:00:58.017]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.017]                             info, version)
[18:00:58.017]                         }
[18:00:58.017]                         base::stop(msg)
[18:00:58.017]                       }
[18:00:58.017]                     })
[18:00:58.017]                   }
[18:00:58.017]                   ...future.strategy.old <- future::plan("list")
[18:00:58.017]                   options(future.plan = NULL)
[18:00:58.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.017]                 }
[18:00:58.017]                 ...future.workdir <- getwd()
[18:00:58.017]             }
[18:00:58.017]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.017]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.017]         }
[18:00:58.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.017]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:00:58.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.017]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.017]             base::names(...future.oldOptions))
[18:00:58.017]     }
[18:00:58.017]     if (FALSE) {
[18:00:58.017]     }
[18:00:58.017]     else {
[18:00:58.017]         if (TRUE) {
[18:00:58.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.017]                 open = "w")
[18:00:58.017]         }
[18:00:58.017]         else {
[18:00:58.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.017]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.017]         }
[18:00:58.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.017]             base::sink(type = "output", split = FALSE)
[18:00:58.017]             base::close(...future.stdout)
[18:00:58.017]         }, add = TRUE)
[18:00:58.017]     }
[18:00:58.017]     ...future.frame <- base::sys.nframe()
[18:00:58.017]     ...future.conditions <- base::list()
[18:00:58.017]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.017]     if (FALSE) {
[18:00:58.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.017]     }
[18:00:58.017]     ...future.result <- base::tryCatch({
[18:00:58.017]         base::withCallingHandlers({
[18:00:58.017]             ...future.value <- base::withVisible(base::local({
[18:00:58.017]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.017]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.017]                   ...future.globals.maxSize)) {
[18:00:58.017]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.017]                   on.exit(options(oopts), add = TRUE)
[18:00:58.017]                 }
[18:00:58.017]                 {
[18:00:58.017]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.017]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.017]                     USE.NAMES = FALSE)
[18:00:58.017]                   do.call(mapply, args = args)
[18:00:58.017]                 }
[18:00:58.017]             }))
[18:00:58.017]             future::FutureResult(value = ...future.value$value, 
[18:00:58.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.017]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.017]                     ...future.globalenv.names))
[18:00:58.017]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.017]         }, condition = base::local({
[18:00:58.017]             c <- base::c
[18:00:58.017]             inherits <- base::inherits
[18:00:58.017]             invokeRestart <- base::invokeRestart
[18:00:58.017]             length <- base::length
[18:00:58.017]             list <- base::list
[18:00:58.017]             seq.int <- base::seq.int
[18:00:58.017]             signalCondition <- base::signalCondition
[18:00:58.017]             sys.calls <- base::sys.calls
[18:00:58.017]             `[[` <- base::`[[`
[18:00:58.017]             `+` <- base::`+`
[18:00:58.017]             `<<-` <- base::`<<-`
[18:00:58.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.017]                   3L)]
[18:00:58.017]             }
[18:00:58.017]             function(cond) {
[18:00:58.017]                 is_error <- inherits(cond, "error")
[18:00:58.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.017]                   NULL)
[18:00:58.017]                 if (is_error) {
[18:00:58.017]                   sessionInformation <- function() {
[18:00:58.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.017]                       search = base::search(), system = base::Sys.info())
[18:00:58.017]                   }
[18:00:58.017]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.017]                     cond$call), session = sessionInformation(), 
[18:00:58.017]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.017]                   signalCondition(cond)
[18:00:58.017]                 }
[18:00:58.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.017]                 "immediateCondition"))) {
[18:00:58.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.017]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.017]                   if (TRUE && !signal) {
[18:00:58.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.017]                     {
[18:00:58.017]                       inherits <- base::inherits
[18:00:58.017]                       invokeRestart <- base::invokeRestart
[18:00:58.017]                       is.null <- base::is.null
[18:00:58.017]                       muffled <- FALSE
[18:00:58.017]                       if (inherits(cond, "message")) {
[18:00:58.017]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.017]                         if (muffled) 
[18:00:58.017]                           invokeRestart("muffleMessage")
[18:00:58.017]                       }
[18:00:58.017]                       else if (inherits(cond, "warning")) {
[18:00:58.017]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.017]                         if (muffled) 
[18:00:58.017]                           invokeRestart("muffleWarning")
[18:00:58.017]                       }
[18:00:58.017]                       else if (inherits(cond, "condition")) {
[18:00:58.017]                         if (!is.null(pattern)) {
[18:00:58.017]                           computeRestarts <- base::computeRestarts
[18:00:58.017]                           grepl <- base::grepl
[18:00:58.017]                           restarts <- computeRestarts(cond)
[18:00:58.017]                           for (restart in restarts) {
[18:00:58.017]                             name <- restart$name
[18:00:58.017]                             if (is.null(name)) 
[18:00:58.017]                               next
[18:00:58.017]                             if (!grepl(pattern, name)) 
[18:00:58.017]                               next
[18:00:58.017]                             invokeRestart(restart)
[18:00:58.017]                             muffled <- TRUE
[18:00:58.017]                             break
[18:00:58.017]                           }
[18:00:58.017]                         }
[18:00:58.017]                       }
[18:00:58.017]                       invisible(muffled)
[18:00:58.017]                     }
[18:00:58.017]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.017]                   }
[18:00:58.017]                 }
[18:00:58.017]                 else {
[18:00:58.017]                   if (TRUE) {
[18:00:58.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.017]                     {
[18:00:58.017]                       inherits <- base::inherits
[18:00:58.017]                       invokeRestart <- base::invokeRestart
[18:00:58.017]                       is.null <- base::is.null
[18:00:58.017]                       muffled <- FALSE
[18:00:58.017]                       if (inherits(cond, "message")) {
[18:00:58.017]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.017]                         if (muffled) 
[18:00:58.017]                           invokeRestart("muffleMessage")
[18:00:58.017]                       }
[18:00:58.017]                       else if (inherits(cond, "warning")) {
[18:00:58.017]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.017]                         if (muffled) 
[18:00:58.017]                           invokeRestart("muffleWarning")
[18:00:58.017]                       }
[18:00:58.017]                       else if (inherits(cond, "condition")) {
[18:00:58.017]                         if (!is.null(pattern)) {
[18:00:58.017]                           computeRestarts <- base::computeRestarts
[18:00:58.017]                           grepl <- base::grepl
[18:00:58.017]                           restarts <- computeRestarts(cond)
[18:00:58.017]                           for (restart in restarts) {
[18:00:58.017]                             name <- restart$name
[18:00:58.017]                             if (is.null(name)) 
[18:00:58.017]                               next
[18:00:58.017]                             if (!grepl(pattern, name)) 
[18:00:58.017]                               next
[18:00:58.017]                             invokeRestart(restart)
[18:00:58.017]                             muffled <- TRUE
[18:00:58.017]                             break
[18:00:58.017]                           }
[18:00:58.017]                         }
[18:00:58.017]                       }
[18:00:58.017]                       invisible(muffled)
[18:00:58.017]                     }
[18:00:58.017]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.017]                   }
[18:00:58.017]                 }
[18:00:58.017]             }
[18:00:58.017]         }))
[18:00:58.017]     }, error = function(ex) {
[18:00:58.017]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.017]                 ...future.rng), started = ...future.startTime, 
[18:00:58.017]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.017]             version = "1.8"), class = "FutureResult")
[18:00:58.017]     }, finally = {
[18:00:58.017]         if (!identical(...future.workdir, getwd())) 
[18:00:58.017]             setwd(...future.workdir)
[18:00:58.017]         {
[18:00:58.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.017]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.017]             }
[18:00:58.017]             base::options(...future.oldOptions)
[18:00:58.017]             if (.Platform$OS.type == "windows") {
[18:00:58.017]                 old_names <- names(...future.oldEnvVars)
[18:00:58.017]                 envs <- base::Sys.getenv()
[18:00:58.017]                 names <- names(envs)
[18:00:58.017]                 common <- intersect(names, old_names)
[18:00:58.017]                 added <- setdiff(names, old_names)
[18:00:58.017]                 removed <- setdiff(old_names, names)
[18:00:58.017]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.017]                   envs[common]]
[18:00:58.017]                 NAMES <- toupper(changed)
[18:00:58.017]                 args <- list()
[18:00:58.017]                 for (kk in seq_along(NAMES)) {
[18:00:58.017]                   name <- changed[[kk]]
[18:00:58.017]                   NAME <- NAMES[[kk]]
[18:00:58.017]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.017]                     next
[18:00:58.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.017]                 }
[18:00:58.017]                 NAMES <- toupper(added)
[18:00:58.017]                 for (kk in seq_along(NAMES)) {
[18:00:58.017]                   name <- added[[kk]]
[18:00:58.017]                   NAME <- NAMES[[kk]]
[18:00:58.017]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.017]                     next
[18:00:58.017]                   args[[name]] <- ""
[18:00:58.017]                 }
[18:00:58.017]                 NAMES <- toupper(removed)
[18:00:58.017]                 for (kk in seq_along(NAMES)) {
[18:00:58.017]                   name <- removed[[kk]]
[18:00:58.017]                   NAME <- NAMES[[kk]]
[18:00:58.017]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.017]                     next
[18:00:58.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.017]                 }
[18:00:58.017]                 if (length(args) > 0) 
[18:00:58.017]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.017]             }
[18:00:58.017]             else {
[18:00:58.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.017]             }
[18:00:58.017]             {
[18:00:58.017]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.017]                   0L) {
[18:00:58.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.017]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.017]                   base::options(opts)
[18:00:58.017]                 }
[18:00:58.017]                 {
[18:00:58.017]                   {
[18:00:58.017]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.017]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.017]                     1423455687L), envir = base::globalenv(), 
[18:00:58.017]                       inherits = FALSE)
[18:00:58.017]                     NULL
[18:00:58.017]                   }
[18:00:58.017]                   options(future.plan = NULL)
[18:00:58.017]                   if (is.na(NA_character_)) 
[18:00:58.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.017]                     .init = FALSE)
[18:00:58.017]                 }
[18:00:58.017]             }
[18:00:58.017]         }
[18:00:58.017]     })
[18:00:58.017]     if (TRUE) {
[18:00:58.017]         base::sink(type = "output", split = FALSE)
[18:00:58.017]         if (TRUE) {
[18:00:58.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.017]         }
[18:00:58.017]         else {
[18:00:58.017]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.017]         }
[18:00:58.017]         base::close(...future.stdout)
[18:00:58.017]         ...future.stdout <- NULL
[18:00:58.017]     }
[18:00:58.017]     ...future.result$conditions <- ...future.conditions
[18:00:58.017]     ...future.result$finished <- base::Sys.time()
[18:00:58.017]     ...future.result
[18:00:58.017] }
[18:00:58.020] assign_globals() ...
[18:00:58.021] List of 5
[18:00:58.021]  $ ...future.FUN            :function (C, k)  
[18:00:58.021]  $ MoreArgs                 : NULL
[18:00:58.021]  $ ...future.elements_ii    :List of 2
[18:00:58.021]   ..$ :List of 1
[18:00:58.021]   .. ..$ : chr "E"
[18:00:58.021]   ..$ :List of 1
[18:00:58.021]   .. ..$ : int 1
[18:00:58.021]  $ ...future.seeds_ii       : NULL
[18:00:58.021]  $ ...future.globals.maxSize: NULL
[18:00:58.021]  - attr(*, "where")=List of 5
[18:00:58.021]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.021]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.021]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.021]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.021]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.021]  - attr(*, "resolved")= logi FALSE
[18:00:58.021]  - attr(*, "total_size")= num 3488
[18:00:58.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.021]  - attr(*, "already-done")= logi TRUE
[18:00:58.031] - reassign environment for ‘...future.FUN’
[18:00:58.031] - copied ‘...future.FUN’ to environment
[18:00:58.031] - copied ‘MoreArgs’ to environment
[18:00:58.032] - copied ‘...future.elements_ii’ to environment
[18:00:58.032] - copied ‘...future.seeds_ii’ to environment
[18:00:58.032] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.032] assign_globals() ... done
[18:00:58.033] plan(): Setting new future strategy stack:
[18:00:58.033] List of future strategies:
[18:00:58.033] 1. sequential:
[18:00:58.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.033]    - tweaked: FALSE
[18:00:58.033]    - call: NULL
[18:00:58.034] plan(): nbrOfWorkers() = 1
[18:00:58.035] plan(): Setting new future strategy stack:
[18:00:58.035] List of future strategies:
[18:00:58.035] 1. sequential:
[18:00:58.035]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.035]    - tweaked: FALSE
[18:00:58.035]    - call: plan(strategy)
[18:00:58.036] plan(): nbrOfWorkers() = 1
[18:00:58.037] SequentialFuture started (and completed)
[18:00:58.037] - Launch lazy future ... done
[18:00:58.037] run() for ‘SequentialFuture’ ... done
[18:00:58.037] Created future:
[18:00:58.037] SequentialFuture:
[18:00:58.037] Label: ‘future_mapply-2’
[18:00:58.037] Expression:
[18:00:58.037] {
[18:00:58.037]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.037]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.037]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.037]         on.exit(options(oopts), add = TRUE)
[18:00:58.037]     }
[18:00:58.037]     {
[18:00:58.037]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.037]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.037]         do.call(mapply, args = args)
[18:00:58.037]     }
[18:00:58.037] }
[18:00:58.037] Lazy evaluation: FALSE
[18:00:58.037] Asynchronous evaluation: FALSE
[18:00:58.037] Local evaluation: TRUE
[18:00:58.037] Environment: R_GlobalEnv
[18:00:58.037] Capture standard output: TRUE
[18:00:58.037] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.037] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.037] Packages: <none>
[18:00:58.037] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.037] Resolved: TRUE
[18:00:58.037] Value: 112 bytes of class ‘list’
[18:00:58.037] Early signaling: FALSE
[18:00:58.037] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.037] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.041] Chunk #2 of 3 ... DONE
[18:00:58.042] Chunk #3 of 3 ...
[18:00:58.042]  - Finding globals in '...' for chunk #3 ...
[18:00:58.042] getGlobalsAndPackages() ...
[18:00:58.042] Searching for globals...
[18:00:58.043] 
[18:00:58.043] Searching for globals ... DONE
[18:00:58.044] - globals: [0] <none>
[18:00:58.044] getGlobalsAndPackages() ... DONE
[18:00:58.044]    + additional globals found: [n=0] 
[18:00:58.044]    + additional namespaces needed: [n=0] 
[18:00:58.044]  - Finding globals in '...' for chunk #3 ... DONE
[18:00:58.045]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:00:58.045]  - seeds: <none>
[18:00:58.045]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.045] getGlobalsAndPackages() ...
[18:00:58.045] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.046] Resolving globals: FALSE
[18:00:58.047] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:00:58.047] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.048] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.048] 
[18:00:58.048] getGlobalsAndPackages() ... DONE
[18:00:58.049] run() for ‘Future’ ...
[18:00:58.049] - state: ‘created’
[18:00:58.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.050] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.050]   - Field: ‘label’
[18:00:58.050]   - Field: ‘local’
[18:00:58.050]   - Field: ‘owner’
[18:00:58.051]   - Field: ‘envir’
[18:00:58.051]   - Field: ‘packages’
[18:00:58.051]   - Field: ‘gc’
[18:00:58.051]   - Field: ‘conditions’
[18:00:58.051]   - Field: ‘expr’
[18:00:58.052]   - Field: ‘uuid’
[18:00:58.052]   - Field: ‘seed’
[18:00:58.052]   - Field: ‘version’
[18:00:58.052]   - Field: ‘result’
[18:00:58.052]   - Field: ‘asynchronous’
[18:00:58.053]   - Field: ‘calls’
[18:00:58.053]   - Field: ‘globals’
[18:00:58.053]   - Field: ‘stdout’
[18:00:58.053]   - Field: ‘earlySignal’
[18:00:58.053]   - Field: ‘lazy’
[18:00:58.054]   - Field: ‘state’
[18:00:58.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.054] - Launch lazy future ...
[18:00:58.054] Packages needed by the future expression (n = 0): <none>
[18:00:58.054] Packages needed by future strategies (n = 0): <none>
[18:00:58.055] {
[18:00:58.055]     {
[18:00:58.055]         {
[18:00:58.055]             ...future.startTime <- base::Sys.time()
[18:00:58.055]             {
[18:00:58.055]                 {
[18:00:58.055]                   {
[18:00:58.055]                     base::local({
[18:00:58.055]                       has_future <- base::requireNamespace("future", 
[18:00:58.055]                         quietly = TRUE)
[18:00:58.055]                       if (has_future) {
[18:00:58.055]                         ns <- base::getNamespace("future")
[18:00:58.055]                         version <- ns[[".package"]][["version"]]
[18:00:58.055]                         if (is.null(version)) 
[18:00:58.055]                           version <- utils::packageVersion("future")
[18:00:58.055]                       }
[18:00:58.055]                       else {
[18:00:58.055]                         version <- NULL
[18:00:58.055]                       }
[18:00:58.055]                       if (!has_future || version < "1.8.0") {
[18:00:58.055]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.055]                           "", base::R.version$version.string), 
[18:00:58.055]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.055]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.055]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.055]                             "release", "version")], collapse = " "), 
[18:00:58.055]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.055]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.055]                           info)
[18:00:58.055]                         info <- base::paste(info, collapse = "; ")
[18:00:58.055]                         if (!has_future) {
[18:00:58.055]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.055]                             info)
[18:00:58.055]                         }
[18:00:58.055]                         else {
[18:00:58.055]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.055]                             info, version)
[18:00:58.055]                         }
[18:00:58.055]                         base::stop(msg)
[18:00:58.055]                       }
[18:00:58.055]                     })
[18:00:58.055]                   }
[18:00:58.055]                   ...future.strategy.old <- future::plan("list")
[18:00:58.055]                   options(future.plan = NULL)
[18:00:58.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.055]                 }
[18:00:58.055]                 ...future.workdir <- getwd()
[18:00:58.055]             }
[18:00:58.055]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.055]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.055]         }
[18:00:58.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.055]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:00:58.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.055]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.055]             base::names(...future.oldOptions))
[18:00:58.055]     }
[18:00:58.055]     if (FALSE) {
[18:00:58.055]     }
[18:00:58.055]     else {
[18:00:58.055]         if (TRUE) {
[18:00:58.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.055]                 open = "w")
[18:00:58.055]         }
[18:00:58.055]         else {
[18:00:58.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.055]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.055]         }
[18:00:58.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.055]             base::sink(type = "output", split = FALSE)
[18:00:58.055]             base::close(...future.stdout)
[18:00:58.055]         }, add = TRUE)
[18:00:58.055]     }
[18:00:58.055]     ...future.frame <- base::sys.nframe()
[18:00:58.055]     ...future.conditions <- base::list()
[18:00:58.055]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.055]     if (FALSE) {
[18:00:58.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.055]     }
[18:00:58.055]     ...future.result <- base::tryCatch({
[18:00:58.055]         base::withCallingHandlers({
[18:00:58.055]             ...future.value <- base::withVisible(base::local({
[18:00:58.055]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.055]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.055]                   ...future.globals.maxSize)) {
[18:00:58.055]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.055]                   on.exit(options(oopts), add = TRUE)
[18:00:58.055]                 }
[18:00:58.055]                 {
[18:00:58.055]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.055]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.055]                     USE.NAMES = FALSE)
[18:00:58.055]                   do.call(mapply, args = args)
[18:00:58.055]                 }
[18:00:58.055]             }))
[18:00:58.055]             future::FutureResult(value = ...future.value$value, 
[18:00:58.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.055]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.055]                     ...future.globalenv.names))
[18:00:58.055]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.055]         }, condition = base::local({
[18:00:58.055]             c <- base::c
[18:00:58.055]             inherits <- base::inherits
[18:00:58.055]             invokeRestart <- base::invokeRestart
[18:00:58.055]             length <- base::length
[18:00:58.055]             list <- base::list
[18:00:58.055]             seq.int <- base::seq.int
[18:00:58.055]             signalCondition <- base::signalCondition
[18:00:58.055]             sys.calls <- base::sys.calls
[18:00:58.055]             `[[` <- base::`[[`
[18:00:58.055]             `+` <- base::`+`
[18:00:58.055]             `<<-` <- base::`<<-`
[18:00:58.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.055]                   3L)]
[18:00:58.055]             }
[18:00:58.055]             function(cond) {
[18:00:58.055]                 is_error <- inherits(cond, "error")
[18:00:58.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.055]                   NULL)
[18:00:58.055]                 if (is_error) {
[18:00:58.055]                   sessionInformation <- function() {
[18:00:58.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.055]                       search = base::search(), system = base::Sys.info())
[18:00:58.055]                   }
[18:00:58.055]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.055]                     cond$call), session = sessionInformation(), 
[18:00:58.055]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.055]                   signalCondition(cond)
[18:00:58.055]                 }
[18:00:58.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.055]                 "immediateCondition"))) {
[18:00:58.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.055]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.055]                   if (TRUE && !signal) {
[18:00:58.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.055]                     {
[18:00:58.055]                       inherits <- base::inherits
[18:00:58.055]                       invokeRestart <- base::invokeRestart
[18:00:58.055]                       is.null <- base::is.null
[18:00:58.055]                       muffled <- FALSE
[18:00:58.055]                       if (inherits(cond, "message")) {
[18:00:58.055]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.055]                         if (muffled) 
[18:00:58.055]                           invokeRestart("muffleMessage")
[18:00:58.055]                       }
[18:00:58.055]                       else if (inherits(cond, "warning")) {
[18:00:58.055]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.055]                         if (muffled) 
[18:00:58.055]                           invokeRestart("muffleWarning")
[18:00:58.055]                       }
[18:00:58.055]                       else if (inherits(cond, "condition")) {
[18:00:58.055]                         if (!is.null(pattern)) {
[18:00:58.055]                           computeRestarts <- base::computeRestarts
[18:00:58.055]                           grepl <- base::grepl
[18:00:58.055]                           restarts <- computeRestarts(cond)
[18:00:58.055]                           for (restart in restarts) {
[18:00:58.055]                             name <- restart$name
[18:00:58.055]                             if (is.null(name)) 
[18:00:58.055]                               next
[18:00:58.055]                             if (!grepl(pattern, name)) 
[18:00:58.055]                               next
[18:00:58.055]                             invokeRestart(restart)
[18:00:58.055]                             muffled <- TRUE
[18:00:58.055]                             break
[18:00:58.055]                           }
[18:00:58.055]                         }
[18:00:58.055]                       }
[18:00:58.055]                       invisible(muffled)
[18:00:58.055]                     }
[18:00:58.055]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.055]                   }
[18:00:58.055]                 }
[18:00:58.055]                 else {
[18:00:58.055]                   if (TRUE) {
[18:00:58.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.055]                     {
[18:00:58.055]                       inherits <- base::inherits
[18:00:58.055]                       invokeRestart <- base::invokeRestart
[18:00:58.055]                       is.null <- base::is.null
[18:00:58.055]                       muffled <- FALSE
[18:00:58.055]                       if (inherits(cond, "message")) {
[18:00:58.055]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.055]                         if (muffled) 
[18:00:58.055]                           invokeRestart("muffleMessage")
[18:00:58.055]                       }
[18:00:58.055]                       else if (inherits(cond, "warning")) {
[18:00:58.055]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.055]                         if (muffled) 
[18:00:58.055]                           invokeRestart("muffleWarning")
[18:00:58.055]                       }
[18:00:58.055]                       else if (inherits(cond, "condition")) {
[18:00:58.055]                         if (!is.null(pattern)) {
[18:00:58.055]                           computeRestarts <- base::computeRestarts
[18:00:58.055]                           grepl <- base::grepl
[18:00:58.055]                           restarts <- computeRestarts(cond)
[18:00:58.055]                           for (restart in restarts) {
[18:00:58.055]                             name <- restart$name
[18:00:58.055]                             if (is.null(name)) 
[18:00:58.055]                               next
[18:00:58.055]                             if (!grepl(pattern, name)) 
[18:00:58.055]                               next
[18:00:58.055]                             invokeRestart(restart)
[18:00:58.055]                             muffled <- TRUE
[18:00:58.055]                             break
[18:00:58.055]                           }
[18:00:58.055]                         }
[18:00:58.055]                       }
[18:00:58.055]                       invisible(muffled)
[18:00:58.055]                     }
[18:00:58.055]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.055]                   }
[18:00:58.055]                 }
[18:00:58.055]             }
[18:00:58.055]         }))
[18:00:58.055]     }, error = function(ex) {
[18:00:58.055]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.055]                 ...future.rng), started = ...future.startTime, 
[18:00:58.055]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.055]             version = "1.8"), class = "FutureResult")
[18:00:58.055]     }, finally = {
[18:00:58.055]         if (!identical(...future.workdir, getwd())) 
[18:00:58.055]             setwd(...future.workdir)
[18:00:58.055]         {
[18:00:58.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.055]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.055]             }
[18:00:58.055]             base::options(...future.oldOptions)
[18:00:58.055]             if (.Platform$OS.type == "windows") {
[18:00:58.055]                 old_names <- names(...future.oldEnvVars)
[18:00:58.055]                 envs <- base::Sys.getenv()
[18:00:58.055]                 names <- names(envs)
[18:00:58.055]                 common <- intersect(names, old_names)
[18:00:58.055]                 added <- setdiff(names, old_names)
[18:00:58.055]                 removed <- setdiff(old_names, names)
[18:00:58.055]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.055]                   envs[common]]
[18:00:58.055]                 NAMES <- toupper(changed)
[18:00:58.055]                 args <- list()
[18:00:58.055]                 for (kk in seq_along(NAMES)) {
[18:00:58.055]                   name <- changed[[kk]]
[18:00:58.055]                   NAME <- NAMES[[kk]]
[18:00:58.055]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.055]                     next
[18:00:58.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.055]                 }
[18:00:58.055]                 NAMES <- toupper(added)
[18:00:58.055]                 for (kk in seq_along(NAMES)) {
[18:00:58.055]                   name <- added[[kk]]
[18:00:58.055]                   NAME <- NAMES[[kk]]
[18:00:58.055]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.055]                     next
[18:00:58.055]                   args[[name]] <- ""
[18:00:58.055]                 }
[18:00:58.055]                 NAMES <- toupper(removed)
[18:00:58.055]                 for (kk in seq_along(NAMES)) {
[18:00:58.055]                   name <- removed[[kk]]
[18:00:58.055]                   NAME <- NAMES[[kk]]
[18:00:58.055]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.055]                     next
[18:00:58.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.055]                 }
[18:00:58.055]                 if (length(args) > 0) 
[18:00:58.055]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.055]             }
[18:00:58.055]             else {
[18:00:58.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.055]             }
[18:00:58.055]             {
[18:00:58.055]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.055]                   0L) {
[18:00:58.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.055]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.055]                   base::options(opts)
[18:00:58.055]                 }
[18:00:58.055]                 {
[18:00:58.055]                   {
[18:00:58.055]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.055]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.055]                     1423455687L), envir = base::globalenv(), 
[18:00:58.055]                       inherits = FALSE)
[18:00:58.055]                     NULL
[18:00:58.055]                   }
[18:00:58.055]                   options(future.plan = NULL)
[18:00:58.055]                   if (is.na(NA_character_)) 
[18:00:58.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.055]                     .init = FALSE)
[18:00:58.055]                 }
[18:00:58.055]             }
[18:00:58.055]         }
[18:00:58.055]     })
[18:00:58.055]     if (TRUE) {
[18:00:58.055]         base::sink(type = "output", split = FALSE)
[18:00:58.055]         if (TRUE) {
[18:00:58.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.055]         }
[18:00:58.055]         else {
[18:00:58.055]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.055]         }
[18:00:58.055]         base::close(...future.stdout)
[18:00:58.055]         ...future.stdout <- NULL
[18:00:58.055]     }
[18:00:58.055]     ...future.result$conditions <- ...future.conditions
[18:00:58.055]     ...future.result$finished <- base::Sys.time()
[18:00:58.055]     ...future.result
[18:00:58.055] }
[18:00:58.059] assign_globals() ...
[18:00:58.059] List of 5
[18:00:58.059]  $ ...future.FUN            :function (C, k)  
[18:00:58.059]  $ MoreArgs                 : NULL
[18:00:58.059]  $ ...future.elements_ii    :List of 2
[18:00:58.059]   ..$ :List of 2
[18:00:58.059]   .. ..$ : chr "D"
[18:00:58.059]   .. ..$ : chr "B"
[18:00:58.059]   ..$ :List of 2
[18:00:58.059]   .. ..$ : int 2
[18:00:58.059]   .. ..$ : int 4
[18:00:58.059]  $ ...future.seeds_ii       : NULL
[18:00:58.059]  $ ...future.globals.maxSize: NULL
[18:00:58.059]  - attr(*, "where")=List of 5
[18:00:58.059]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.059]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.059]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.059]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.059]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.059]  - attr(*, "resolved")= logi FALSE
[18:00:58.059]  - attr(*, "total_size")= num 3656
[18:00:58.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.059]  - attr(*, "already-done")= logi TRUE
[18:00:58.074] - reassign environment for ‘...future.FUN’
[18:00:58.074] - copied ‘...future.FUN’ to environment
[18:00:58.075] - copied ‘MoreArgs’ to environment
[18:00:58.075] - copied ‘...future.elements_ii’ to environment
[18:00:58.076] - copied ‘...future.seeds_ii’ to environment
[18:00:58.076] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.076] assign_globals() ... done
[18:00:58.077] plan(): Setting new future strategy stack:
[18:00:58.077] List of future strategies:
[18:00:58.077] 1. sequential:
[18:00:58.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.077]    - tweaked: FALSE
[18:00:58.077]    - call: NULL
[18:00:58.078] plan(): nbrOfWorkers() = 1
[18:00:58.080] plan(): Setting new future strategy stack:
[18:00:58.080] List of future strategies:
[18:00:58.080] 1. sequential:
[18:00:58.080]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.080]    - tweaked: FALSE
[18:00:58.080]    - call: plan(strategy)
[18:00:58.082] plan(): nbrOfWorkers() = 1
[18:00:58.082] SequentialFuture started (and completed)
[18:00:58.082] - Launch lazy future ... done
[18:00:58.082] run() for ‘SequentialFuture’ ... done
[18:00:58.083] Created future:
[18:00:58.083] SequentialFuture:
[18:00:58.083] Label: ‘future_mapply-3’
[18:00:58.083] Expression:
[18:00:58.083] {
[18:00:58.083]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.083]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.083]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.083]         on.exit(options(oopts), add = TRUE)
[18:00:58.083]     }
[18:00:58.083]     {
[18:00:58.083]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.083]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.083]         do.call(mapply, args = args)
[18:00:58.083]     }
[18:00:58.083] }
[18:00:58.083] Lazy evaluation: FALSE
[18:00:58.083] Asynchronous evaluation: FALSE
[18:00:58.083] Local evaluation: TRUE
[18:00:58.083] Environment: R_GlobalEnv
[18:00:58.083] Capture standard output: TRUE
[18:00:58.083] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.083] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.083] Packages: <none>
[18:00:58.083] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.083] Resolved: TRUE
[18:00:58.083] Value: 224 bytes of class ‘list’
[18:00:58.083] Early signaling: FALSE
[18:00:58.083] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.083] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.085] Chunk #3 of 3 ... DONE
[18:00:58.085] Launching 3 futures (chunks) ... DONE
[18:00:58.085] Resolving 3 futures (chunks) ...
[18:00:58.086] resolve() on list ...
[18:00:58.086]  recursive: 0
[18:00:58.086]  length: 3
[18:00:58.086] 
[18:00:58.087] resolved() for ‘SequentialFuture’ ...
[18:00:58.087] - state: ‘finished’
[18:00:58.087] - run: TRUE
[18:00:58.087] - result: ‘FutureResult’
[18:00:58.087] resolved() for ‘SequentialFuture’ ... done
[18:00:58.088] Future #1
[18:00:58.088] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.088] - nx: 3
[18:00:58.088] - relay: TRUE
[18:00:58.089] - stdout: TRUE
[18:00:58.089] - signal: TRUE
[18:00:58.089] - resignal: FALSE
[18:00:58.089] - force: TRUE
[18:00:58.089] - relayed: [n=3] FALSE, FALSE, FALSE
[18:00:58.089] - queued futures: [n=3] FALSE, FALSE, FALSE
[18:00:58.090]  - until=1
[18:00:58.090]  - relaying element #1
[18:00:58.090] - relayed: [n=3] TRUE, FALSE, FALSE
[18:00:58.091] - queued futures: [n=3] TRUE, FALSE, FALSE
[18:00:58.091] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.091]  length: 2 (resolved future 1)
[18:00:58.091] resolved() for ‘SequentialFuture’ ...
[18:00:58.092] - state: ‘finished’
[18:00:58.092] - run: TRUE
[18:00:58.092] - result: ‘FutureResult’
[18:00:58.092] resolved() for ‘SequentialFuture’ ... done
[18:00:58.092] Future #2
[18:00:58.093] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:00:58.093] - nx: 3
[18:00:58.093] - relay: TRUE
[18:00:58.093] - stdout: TRUE
[18:00:58.093] - signal: TRUE
[18:00:58.094] - resignal: FALSE
[18:00:58.094] - force: TRUE
[18:00:58.094] - relayed: [n=3] TRUE, FALSE, FALSE
[18:00:58.094] - queued futures: [n=3] TRUE, FALSE, FALSE
[18:00:58.094]  - until=2
[18:00:58.095]  - relaying element #2
[18:00:58.095] - relayed: [n=3] TRUE, TRUE, FALSE
[18:00:58.095] - queued futures: [n=3] TRUE, TRUE, FALSE
[18:00:58.095] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:00:58.096]  length: 1 (resolved future 2)
[18:00:58.096] resolved() for ‘SequentialFuture’ ...
[18:00:58.096] - state: ‘finished’
[18:00:58.096] - run: TRUE
[18:00:58.097] - result: ‘FutureResult’
[18:00:58.097] resolved() for ‘SequentialFuture’ ... done
[18:00:58.097] Future #3
[18:00:58.097] signalConditionsASAP(SequentialFuture, pos=3) ...
[18:00:58.097] - nx: 3
[18:00:58.098] - relay: TRUE
[18:00:58.098] - stdout: TRUE
[18:00:58.098] - signal: TRUE
[18:00:58.098] - resignal: FALSE
[18:00:58.098] - force: TRUE
[18:00:58.099] - relayed: [n=3] TRUE, TRUE, FALSE
[18:00:58.099] - queued futures: [n=3] TRUE, TRUE, FALSE
[18:00:58.099]  - until=3
[18:00:58.099]  - relaying element #3
[18:00:58.100] - relayed: [n=3] TRUE, TRUE, TRUE
[18:00:58.100] - queued futures: [n=3] TRUE, TRUE, TRUE
[18:00:58.100] signalConditionsASAP(SequentialFuture, pos=3) ... done
[18:00:58.102]  length: 0 (resolved future 3)
[18:00:58.103] Relaying remaining futures
[18:00:58.103] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.103] - nx: 3
[18:00:58.103] - relay: TRUE
[18:00:58.104] - stdout: TRUE
[18:00:58.104] - signal: TRUE
[18:00:58.104] - resignal: FALSE
[18:00:58.104] - force: TRUE
[18:00:58.104] - relayed: [n=3] TRUE, TRUE, TRUE
[18:00:58.105] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[18:00:58.105] - relayed: [n=3] TRUE, TRUE, TRUE
[18:00:58.105] - queued futures: [n=3] TRUE, TRUE, TRUE
[18:00:58.105] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.106] resolve() on list ... DONE
[18:00:58.106]  - Number of value chunks collected: 3
[18:00:58.107] Resolving 3 futures (chunks) ... DONE
[18:00:58.107] Reducing values from 3 chunks ...
[18:00:58.107]  - Number of values collected after concatenation: 5
[18:00:58.107]  - Number of values expected: 5
[18:00:58.107] Reverse index remapping (attribute 'ordering'): [n = 5] 2, 5, 1, 4, 3
[18:00:58.108] Reducing values from 3 chunks ... DONE
[18:00:58.108] future_mapply() ... DONE
[18:00:58.108] future_mapply() ...
[18:00:58.109] Number of chunks: 1
[18:00:58.109] getGlobalsAndPackagesXApply() ...
[18:00:58.109]  - future.globals: TRUE
[18:00:58.109] getGlobalsAndPackages() ...
[18:00:58.110] Searching for globals...
[18:00:58.112] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:00:58.113] Searching for globals ... DONE
[18:00:58.113] Resolving globals: FALSE
[18:00:58.114] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:00:58.114] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:00:58.115] - globals: [1] ‘FUN’
[18:00:58.115] 
[18:00:58.115] getGlobalsAndPackages() ... DONE
[18:00:58.115]  - globals found/used: [n=1] ‘FUN’
[18:00:58.116]  - needed namespaces: [n=0] 
[18:00:58.116] Finding globals ... DONE
[18:00:58.116] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.116] List of 2
[18:00:58.116]  $ ...future.FUN:function (C, k)  
[18:00:58.116]  $ MoreArgs     : list()
[18:00:58.116]  - attr(*, "where")=List of 2
[18:00:58.116]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.116]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.116]  - attr(*, "resolved")= logi FALSE
[18:00:58.116]  - attr(*, "total_size")= num NA
[18:00:58.122] Packages to be attached in all futures: [n=0] 
[18:00:58.122] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.122] Number of futures (= number of chunks): 1
[18:00:58.123] Launching 1 futures (chunks) ...
[18:00:58.123] Chunk #1 of 1 ...
[18:00:58.123]  - Finding globals in '...' for chunk #1 ...
[18:00:58.123] getGlobalsAndPackages() ...
[18:00:58.124] Searching for globals...
[18:00:58.124] 
[18:00:58.125] Searching for globals ... DONE
[18:00:58.125] - globals: [0] <none>
[18:00:58.125] getGlobalsAndPackages() ... DONE
[18:00:58.125]    + additional globals found: [n=0] 
[18:00:58.125]    + additional namespaces needed: [n=0] 
[18:00:58.126]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.126]  - seeds: <none>
[18:00:58.126]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.126] getGlobalsAndPackages() ...
[18:00:58.126] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.127] Resolving globals: FALSE
[18:00:58.128] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[18:00:58.129] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:00:58.129] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.130] 
[18:00:58.130] getGlobalsAndPackages() ... DONE
[18:00:58.130] run() for ‘Future’ ...
[18:00:58.131] - state: ‘created’
[18:00:58.131] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.132] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.132]   - Field: ‘label’
[18:00:58.132]   - Field: ‘local’
[18:00:58.132]   - Field: ‘owner’
[18:00:58.133]   - Field: ‘envir’
[18:00:58.133]   - Field: ‘packages’
[18:00:58.133]   - Field: ‘gc’
[18:00:58.133]   - Field: ‘conditions’
[18:00:58.133]   - Field: ‘expr’
[18:00:58.134]   - Field: ‘uuid’
[18:00:58.134]   - Field: ‘seed’
[18:00:58.134]   - Field: ‘version’
[18:00:58.134]   - Field: ‘result’
[18:00:58.134]   - Field: ‘asynchronous’
[18:00:58.135]   - Field: ‘calls’
[18:00:58.135]   - Field: ‘globals’
[18:00:58.135]   - Field: ‘stdout’
[18:00:58.135]   - Field: ‘earlySignal’
[18:00:58.136]   - Field: ‘lazy’
[18:00:58.136]   - Field: ‘state’
[18:00:58.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.136] - Launch lazy future ...
[18:00:58.137] Packages needed by the future expression (n = 0): <none>
[18:00:58.137] Packages needed by future strategies (n = 0): <none>
[18:00:58.138] {
[18:00:58.138]     {
[18:00:58.138]         {
[18:00:58.138]             ...future.startTime <- base::Sys.time()
[18:00:58.138]             {
[18:00:58.138]                 {
[18:00:58.138]                   {
[18:00:58.138]                     base::local({
[18:00:58.138]                       has_future <- base::requireNamespace("future", 
[18:00:58.138]                         quietly = TRUE)
[18:00:58.138]                       if (has_future) {
[18:00:58.138]                         ns <- base::getNamespace("future")
[18:00:58.138]                         version <- ns[[".package"]][["version"]]
[18:00:58.138]                         if (is.null(version)) 
[18:00:58.138]                           version <- utils::packageVersion("future")
[18:00:58.138]                       }
[18:00:58.138]                       else {
[18:00:58.138]                         version <- NULL
[18:00:58.138]                       }
[18:00:58.138]                       if (!has_future || version < "1.8.0") {
[18:00:58.138]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.138]                           "", base::R.version$version.string), 
[18:00:58.138]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.138]                             "release", "version")], collapse = " "), 
[18:00:58.138]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.138]                           info)
[18:00:58.138]                         info <- base::paste(info, collapse = "; ")
[18:00:58.138]                         if (!has_future) {
[18:00:58.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.138]                             info)
[18:00:58.138]                         }
[18:00:58.138]                         else {
[18:00:58.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.138]                             info, version)
[18:00:58.138]                         }
[18:00:58.138]                         base::stop(msg)
[18:00:58.138]                       }
[18:00:58.138]                     })
[18:00:58.138]                   }
[18:00:58.138]                   ...future.strategy.old <- future::plan("list")
[18:00:58.138]                   options(future.plan = NULL)
[18:00:58.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.138]                 }
[18:00:58.138]                 ...future.workdir <- getwd()
[18:00:58.138]             }
[18:00:58.138]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.138]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.138]         }
[18:00:58.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.138]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.138]             base::names(...future.oldOptions))
[18:00:58.138]     }
[18:00:58.138]     if (FALSE) {
[18:00:58.138]     }
[18:00:58.138]     else {
[18:00:58.138]         if (TRUE) {
[18:00:58.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.138]                 open = "w")
[18:00:58.138]         }
[18:00:58.138]         else {
[18:00:58.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.138]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.138]         }
[18:00:58.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.138]             base::sink(type = "output", split = FALSE)
[18:00:58.138]             base::close(...future.stdout)
[18:00:58.138]         }, add = TRUE)
[18:00:58.138]     }
[18:00:58.138]     ...future.frame <- base::sys.nframe()
[18:00:58.138]     ...future.conditions <- base::list()
[18:00:58.138]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.138]     if (FALSE) {
[18:00:58.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.138]     }
[18:00:58.138]     ...future.result <- base::tryCatch({
[18:00:58.138]         base::withCallingHandlers({
[18:00:58.138]             ...future.value <- base::withVisible(base::local({
[18:00:58.138]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.138]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.138]                   ...future.globals.maxSize)) {
[18:00:58.138]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.138]                   on.exit(options(oopts), add = TRUE)
[18:00:58.138]                 }
[18:00:58.138]                 {
[18:00:58.138]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.138]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.138]                     USE.NAMES = FALSE)
[18:00:58.138]                   do.call(mapply, args = args)
[18:00:58.138]                 }
[18:00:58.138]             }))
[18:00:58.138]             future::FutureResult(value = ...future.value$value, 
[18:00:58.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.138]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.138]                     ...future.globalenv.names))
[18:00:58.138]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.138]         }, condition = base::local({
[18:00:58.138]             c <- base::c
[18:00:58.138]             inherits <- base::inherits
[18:00:58.138]             invokeRestart <- base::invokeRestart
[18:00:58.138]             length <- base::length
[18:00:58.138]             list <- base::list
[18:00:58.138]             seq.int <- base::seq.int
[18:00:58.138]             signalCondition <- base::signalCondition
[18:00:58.138]             sys.calls <- base::sys.calls
[18:00:58.138]             `[[` <- base::`[[`
[18:00:58.138]             `+` <- base::`+`
[18:00:58.138]             `<<-` <- base::`<<-`
[18:00:58.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.138]                   3L)]
[18:00:58.138]             }
[18:00:58.138]             function(cond) {
[18:00:58.138]                 is_error <- inherits(cond, "error")
[18:00:58.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.138]                   NULL)
[18:00:58.138]                 if (is_error) {
[18:00:58.138]                   sessionInformation <- function() {
[18:00:58.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.138]                       search = base::search(), system = base::Sys.info())
[18:00:58.138]                   }
[18:00:58.138]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.138]                     cond$call), session = sessionInformation(), 
[18:00:58.138]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.138]                   signalCondition(cond)
[18:00:58.138]                 }
[18:00:58.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.138]                 "immediateCondition"))) {
[18:00:58.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.138]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.138]                   if (TRUE && !signal) {
[18:00:58.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.138]                     {
[18:00:58.138]                       inherits <- base::inherits
[18:00:58.138]                       invokeRestart <- base::invokeRestart
[18:00:58.138]                       is.null <- base::is.null
[18:00:58.138]                       muffled <- FALSE
[18:00:58.138]                       if (inherits(cond, "message")) {
[18:00:58.138]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.138]                         if (muffled) 
[18:00:58.138]                           invokeRestart("muffleMessage")
[18:00:58.138]                       }
[18:00:58.138]                       else if (inherits(cond, "warning")) {
[18:00:58.138]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.138]                         if (muffled) 
[18:00:58.138]                           invokeRestart("muffleWarning")
[18:00:58.138]                       }
[18:00:58.138]                       else if (inherits(cond, "condition")) {
[18:00:58.138]                         if (!is.null(pattern)) {
[18:00:58.138]                           computeRestarts <- base::computeRestarts
[18:00:58.138]                           grepl <- base::grepl
[18:00:58.138]                           restarts <- computeRestarts(cond)
[18:00:58.138]                           for (restart in restarts) {
[18:00:58.138]                             name <- restart$name
[18:00:58.138]                             if (is.null(name)) 
[18:00:58.138]                               next
[18:00:58.138]                             if (!grepl(pattern, name)) 
[18:00:58.138]                               next
[18:00:58.138]                             invokeRestart(restart)
[18:00:58.138]                             muffled <- TRUE
[18:00:58.138]                             break
[18:00:58.138]                           }
[18:00:58.138]                         }
[18:00:58.138]                       }
[18:00:58.138]                       invisible(muffled)
[18:00:58.138]                     }
[18:00:58.138]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.138]                   }
[18:00:58.138]                 }
[18:00:58.138]                 else {
[18:00:58.138]                   if (TRUE) {
[18:00:58.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.138]                     {
[18:00:58.138]                       inherits <- base::inherits
[18:00:58.138]                       invokeRestart <- base::invokeRestart
[18:00:58.138]                       is.null <- base::is.null
[18:00:58.138]                       muffled <- FALSE
[18:00:58.138]                       if (inherits(cond, "message")) {
[18:00:58.138]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.138]                         if (muffled) 
[18:00:58.138]                           invokeRestart("muffleMessage")
[18:00:58.138]                       }
[18:00:58.138]                       else if (inherits(cond, "warning")) {
[18:00:58.138]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.138]                         if (muffled) 
[18:00:58.138]                           invokeRestart("muffleWarning")
[18:00:58.138]                       }
[18:00:58.138]                       else if (inherits(cond, "condition")) {
[18:00:58.138]                         if (!is.null(pattern)) {
[18:00:58.138]                           computeRestarts <- base::computeRestarts
[18:00:58.138]                           grepl <- base::grepl
[18:00:58.138]                           restarts <- computeRestarts(cond)
[18:00:58.138]                           for (restart in restarts) {
[18:00:58.138]                             name <- restart$name
[18:00:58.138]                             if (is.null(name)) 
[18:00:58.138]                               next
[18:00:58.138]                             if (!grepl(pattern, name)) 
[18:00:58.138]                               next
[18:00:58.138]                             invokeRestart(restart)
[18:00:58.138]                             muffled <- TRUE
[18:00:58.138]                             break
[18:00:58.138]                           }
[18:00:58.138]                         }
[18:00:58.138]                       }
[18:00:58.138]                       invisible(muffled)
[18:00:58.138]                     }
[18:00:58.138]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.138]                   }
[18:00:58.138]                 }
[18:00:58.138]             }
[18:00:58.138]         }))
[18:00:58.138]     }, error = function(ex) {
[18:00:58.138]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.138]                 ...future.rng), started = ...future.startTime, 
[18:00:58.138]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.138]             version = "1.8"), class = "FutureResult")
[18:00:58.138]     }, finally = {
[18:00:58.138]         if (!identical(...future.workdir, getwd())) 
[18:00:58.138]             setwd(...future.workdir)
[18:00:58.138]         {
[18:00:58.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.138]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.138]             }
[18:00:58.138]             base::options(...future.oldOptions)
[18:00:58.138]             if (.Platform$OS.type == "windows") {
[18:00:58.138]                 old_names <- names(...future.oldEnvVars)
[18:00:58.138]                 envs <- base::Sys.getenv()
[18:00:58.138]                 names <- names(envs)
[18:00:58.138]                 common <- intersect(names, old_names)
[18:00:58.138]                 added <- setdiff(names, old_names)
[18:00:58.138]                 removed <- setdiff(old_names, names)
[18:00:58.138]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.138]                   envs[common]]
[18:00:58.138]                 NAMES <- toupper(changed)
[18:00:58.138]                 args <- list()
[18:00:58.138]                 for (kk in seq_along(NAMES)) {
[18:00:58.138]                   name <- changed[[kk]]
[18:00:58.138]                   NAME <- NAMES[[kk]]
[18:00:58.138]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.138]                     next
[18:00:58.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.138]                 }
[18:00:58.138]                 NAMES <- toupper(added)
[18:00:58.138]                 for (kk in seq_along(NAMES)) {
[18:00:58.138]                   name <- added[[kk]]
[18:00:58.138]                   NAME <- NAMES[[kk]]
[18:00:58.138]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.138]                     next
[18:00:58.138]                   args[[name]] <- ""
[18:00:58.138]                 }
[18:00:58.138]                 NAMES <- toupper(removed)
[18:00:58.138]                 for (kk in seq_along(NAMES)) {
[18:00:58.138]                   name <- removed[[kk]]
[18:00:58.138]                   NAME <- NAMES[[kk]]
[18:00:58.138]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.138]                     next
[18:00:58.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.138]                 }
[18:00:58.138]                 if (length(args) > 0) 
[18:00:58.138]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.138]             }
[18:00:58.138]             else {
[18:00:58.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.138]             }
[18:00:58.138]             {
[18:00:58.138]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.138]                   0L) {
[18:00:58.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.138]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.138]                   base::options(opts)
[18:00:58.138]                 }
[18:00:58.138]                 {
[18:00:58.138]                   {
[18:00:58.138]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.138]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.138]                     1423455687L), envir = base::globalenv(), 
[18:00:58.138]                       inherits = FALSE)
[18:00:58.138]                     NULL
[18:00:58.138]                   }
[18:00:58.138]                   options(future.plan = NULL)
[18:00:58.138]                   if (is.na(NA_character_)) 
[18:00:58.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.138]                     .init = FALSE)
[18:00:58.138]                 }
[18:00:58.138]             }
[18:00:58.138]         }
[18:00:58.138]     })
[18:00:58.138]     if (TRUE) {
[18:00:58.138]         base::sink(type = "output", split = FALSE)
[18:00:58.138]         if (TRUE) {
[18:00:58.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.138]         }
[18:00:58.138]         else {
[18:00:58.138]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.138]         }
[18:00:58.138]         base::close(...future.stdout)
[18:00:58.138]         ...future.stdout <- NULL
[18:00:58.138]     }
[18:00:58.138]     ...future.result$conditions <- ...future.conditions
[18:00:58.138]     ...future.result$finished <- base::Sys.time()
[18:00:58.138]     ...future.result
[18:00:58.138] }
[18:00:58.141] assign_globals() ...
[18:00:58.141] List of 5
[18:00:58.141]  $ ...future.FUN            :function (C, k)  
[18:00:58.141]  $ MoreArgs                 : list()
[18:00:58.141]  $ ...future.elements_ii    :List of 2
[18:00:58.141]   ..$ :List of 5
[18:00:58.141]   .. ..$ : chr "A"
[18:00:58.141]   .. ..$ : chr "B"
[18:00:58.141]   .. ..$ : chr "C"
[18:00:58.141]   .. ..$ : chr "D"
[18:00:58.141]   .. ..$ : chr "E"
[18:00:58.141]   ..$ :List of 5
[18:00:58.141]   .. ..$ : int 5
[18:00:58.141]   .. ..$ : int 4
[18:00:58.141]   .. ..$ : int 3
[18:00:58.141]   .. ..$ : int 2
[18:00:58.141]   .. ..$ : int 1
[18:00:58.141]  $ ...future.seeds_ii       : NULL
[18:00:58.141]  $ ...future.globals.maxSize: NULL
[18:00:58.141]  - attr(*, "where")=List of 5
[18:00:58.141]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.141]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.141]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.141]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.141]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.141]  - attr(*, "resolved")= logi FALSE
[18:00:58.141]  - attr(*, "total_size")= num 4160
[18:00:58.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.141]  - attr(*, "already-done")= logi TRUE
[18:00:58.161] - reassign environment for ‘...future.FUN’
[18:00:58.161] - copied ‘...future.FUN’ to environment
[18:00:58.162] - copied ‘MoreArgs’ to environment
[18:00:58.162] - copied ‘...future.elements_ii’ to environment
[18:00:58.162] - copied ‘...future.seeds_ii’ to environment
[18:00:58.162] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.162] assign_globals() ... done
[18:00:58.163] plan(): Setting new future strategy stack:
[18:00:58.163] List of future strategies:
[18:00:58.163] 1. sequential:
[18:00:58.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.163]    - tweaked: FALSE
[18:00:58.163]    - call: NULL
[18:00:58.164] plan(): nbrOfWorkers() = 1
[18:00:58.166] plan(): Setting new future strategy stack:
[18:00:58.166] List of future strategies:
[18:00:58.166] 1. sequential:
[18:00:58.166]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.166]    - tweaked: FALSE
[18:00:58.166]    - call: plan(strategy)
[18:00:58.167] plan(): nbrOfWorkers() = 1
[18:00:58.167] SequentialFuture started (and completed)
[18:00:58.167] - Launch lazy future ... done
[18:00:58.168] run() for ‘SequentialFuture’ ... done
[18:00:58.168] Created future:
[18:00:58.168] SequentialFuture:
[18:00:58.168] Label: ‘future_.mapply-1’
[18:00:58.168] Expression:
[18:00:58.168] {
[18:00:58.168]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.168]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.168]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.168]         on.exit(options(oopts), add = TRUE)
[18:00:58.168]     }
[18:00:58.168]     {
[18:00:58.168]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.168]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.168]         do.call(mapply, args = args)
[18:00:58.168]     }
[18:00:58.168] }
[18:00:58.168] Lazy evaluation: FALSE
[18:00:58.168] Asynchronous evaluation: FALSE
[18:00:58.168] Local evaluation: TRUE
[18:00:58.168] Environment: R_GlobalEnv
[18:00:58.168] Capture standard output: TRUE
[18:00:58.168] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.168] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.168] Packages: <none>
[18:00:58.168] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.168] Resolved: TRUE
[18:00:58.168] Value: 560 bytes of class ‘list’
[18:00:58.168] Early signaling: FALSE
[18:00:58.168] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.168] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.170] Chunk #1 of 1 ... DONE
[18:00:58.170] Launching 1 futures (chunks) ... DONE
[18:00:58.170] Resolving 1 futures (chunks) ...
[18:00:58.171] resolve() on list ...
[18:00:58.171]  recursive: 0
[18:00:58.171]  length: 1
[18:00:58.171] 
[18:00:58.171] resolved() for ‘SequentialFuture’ ...
[18:00:58.171] - state: ‘finished’
[18:00:58.172] - run: TRUE
[18:00:58.172] - result: ‘FutureResult’
[18:00:58.172] resolved() for ‘SequentialFuture’ ... done
[18:00:58.172] Future #1
[18:00:58.173] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.173] - nx: 1
[18:00:58.173] - relay: TRUE
[18:00:58.173] - stdout: TRUE
[18:00:58.173] - signal: TRUE
[18:00:58.173] - resignal: FALSE
[18:00:58.174] - force: TRUE
[18:00:58.174] - relayed: [n=1] FALSE
[18:00:58.174] - queued futures: [n=1] FALSE
[18:00:58.174]  - until=1
[18:00:58.174]  - relaying element #1
[18:00:58.175] - relayed: [n=1] TRUE
[18:00:58.175] - queued futures: [n=1] TRUE
[18:00:58.175] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.175]  length: 0 (resolved future 1)
[18:00:58.176] Relaying remaining futures
[18:00:58.176] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.176] - nx: 1
[18:00:58.176] - relay: TRUE
[18:00:58.176] - stdout: TRUE
[18:00:58.176] - signal: TRUE
[18:00:58.177] - resignal: FALSE
[18:00:58.177] - force: TRUE
[18:00:58.177] - relayed: [n=1] TRUE
[18:00:58.177] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.177] - relayed: [n=1] TRUE
[18:00:58.178] - queued futures: [n=1] TRUE
[18:00:58.178] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.178] resolve() on list ... DONE
[18:00:58.178]  - Number of value chunks collected: 1
[18:00:58.178] Resolving 1 futures (chunks) ... DONE
[18:00:58.179] Reducing values from 1 chunks ...
[18:00:58.179]  - Number of values collected after concatenation: 5
[18:00:58.179]  - Number of values expected: 5
[18:00:58.179] Reducing values from 1 chunks ... DONE
[18:00:58.179] future_mapply() ... DONE
[18:00:58.180] future_mapply() ...
[18:00:58.181] Number of chunks: 2
[18:00:58.181] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[18:00:58.181] getGlobalsAndPackagesXApply() ...
[18:00:58.181]  - future.globals: TRUE
[18:00:58.181] getGlobalsAndPackages() ...
[18:00:58.182] Searching for globals...
[18:00:58.184] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:00:58.185] Searching for globals ... DONE
[18:00:58.185] Resolving globals: FALSE
[18:00:58.186] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:00:58.186] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:00:58.187] - globals: [1] ‘FUN’
[18:00:58.187] 
[18:00:58.187] getGlobalsAndPackages() ... DONE
[18:00:58.187]  - globals found/used: [n=1] ‘FUN’
[18:00:58.187]  - needed namespaces: [n=0] 
[18:00:58.188] Finding globals ... DONE
[18:00:58.188] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.188] List of 2
[18:00:58.188]  $ ...future.FUN:function (C, k)  
[18:00:58.188]  $ MoreArgs     : NULL
[18:00:58.188]  - attr(*, "where")=List of 2
[18:00:58.188]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.188]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.188]  - attr(*, "resolved")= logi FALSE
[18:00:58.188]  - attr(*, "total_size")= num NA
[18:00:58.193] Packages to be attached in all futures: [n=0] 
[18:00:58.194] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.194] Number of futures (= number of chunks): 2
[18:00:58.194] Launching 2 futures (chunks) ...
[18:00:58.195] Chunk #1 of 2 ...
[18:00:58.195]  - Finding globals in '...' for chunk #1 ...
[18:00:58.195] getGlobalsAndPackages() ...
[18:00:58.195] Searching for globals...
[18:00:58.196] 
[18:00:58.196] Searching for globals ... DONE
[18:00:58.196] - globals: [0] <none>
[18:00:58.197] getGlobalsAndPackages() ... DONE
[18:00:58.197]    + additional globals found: [n=0] 
[18:00:58.197]    + additional namespaces needed: [n=0] 
[18:00:58.197]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.197]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:58.198]  - seeds: <none>
[18:00:58.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.198] getGlobalsAndPackages() ...
[18:00:58.198] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.198] Resolving globals: FALSE
[18:00:58.200] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:00:58.201] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.201] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.201] 
[18:00:58.201] getGlobalsAndPackages() ... DONE
[18:00:58.202] run() for ‘Future’ ...
[18:00:58.202] - state: ‘created’
[18:00:58.203] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.204]   - Field: ‘label’
[18:00:58.204]   - Field: ‘local’
[18:00:58.204]   - Field: ‘owner’
[18:00:58.204]   - Field: ‘envir’
[18:00:58.205]   - Field: ‘packages’
[18:00:58.205]   - Field: ‘gc’
[18:00:58.205]   - Field: ‘conditions’
[18:00:58.205]   - Field: ‘expr’
[18:00:58.205]   - Field: ‘uuid’
[18:00:58.206]   - Field: ‘seed’
[18:00:58.206]   - Field: ‘version’
[18:00:58.206]   - Field: ‘result’
[18:00:58.206]   - Field: ‘asynchronous’
[18:00:58.206]   - Field: ‘calls’
[18:00:58.207]   - Field: ‘globals’
[18:00:58.207]   - Field: ‘stdout’
[18:00:58.207]   - Field: ‘earlySignal’
[18:00:58.207]   - Field: ‘lazy’
[18:00:58.207]   - Field: ‘state’
[18:00:58.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.208] - Launch lazy future ...
[18:00:58.208] Packages needed by the future expression (n = 0): <none>
[18:00:58.208] Packages needed by future strategies (n = 0): <none>
[18:00:58.209] {
[18:00:58.209]     {
[18:00:58.209]         {
[18:00:58.209]             ...future.startTime <- base::Sys.time()
[18:00:58.209]             {
[18:00:58.209]                 {
[18:00:58.209]                   {
[18:00:58.209]                     base::local({
[18:00:58.209]                       has_future <- base::requireNamespace("future", 
[18:00:58.209]                         quietly = TRUE)
[18:00:58.209]                       if (has_future) {
[18:00:58.209]                         ns <- base::getNamespace("future")
[18:00:58.209]                         version <- ns[[".package"]][["version"]]
[18:00:58.209]                         if (is.null(version)) 
[18:00:58.209]                           version <- utils::packageVersion("future")
[18:00:58.209]                       }
[18:00:58.209]                       else {
[18:00:58.209]                         version <- NULL
[18:00:58.209]                       }
[18:00:58.209]                       if (!has_future || version < "1.8.0") {
[18:00:58.209]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.209]                           "", base::R.version$version.string), 
[18:00:58.209]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.209]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.209]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.209]                             "release", "version")], collapse = " "), 
[18:00:58.209]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.209]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.209]                           info)
[18:00:58.209]                         info <- base::paste(info, collapse = "; ")
[18:00:58.209]                         if (!has_future) {
[18:00:58.209]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.209]                             info)
[18:00:58.209]                         }
[18:00:58.209]                         else {
[18:00:58.209]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.209]                             info, version)
[18:00:58.209]                         }
[18:00:58.209]                         base::stop(msg)
[18:00:58.209]                       }
[18:00:58.209]                     })
[18:00:58.209]                   }
[18:00:58.209]                   ...future.strategy.old <- future::plan("list")
[18:00:58.209]                   options(future.plan = NULL)
[18:00:58.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.209]                 }
[18:00:58.209]                 ...future.workdir <- getwd()
[18:00:58.209]             }
[18:00:58.209]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.209]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.209]         }
[18:00:58.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.209]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:58.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.209]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.209]             base::names(...future.oldOptions))
[18:00:58.209]     }
[18:00:58.209]     if (FALSE) {
[18:00:58.209]     }
[18:00:58.209]     else {
[18:00:58.209]         if (TRUE) {
[18:00:58.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.209]                 open = "w")
[18:00:58.209]         }
[18:00:58.209]         else {
[18:00:58.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.209]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.209]         }
[18:00:58.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.209]             base::sink(type = "output", split = FALSE)
[18:00:58.209]             base::close(...future.stdout)
[18:00:58.209]         }, add = TRUE)
[18:00:58.209]     }
[18:00:58.209]     ...future.frame <- base::sys.nframe()
[18:00:58.209]     ...future.conditions <- base::list()
[18:00:58.209]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.209]     if (FALSE) {
[18:00:58.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.209]     }
[18:00:58.209]     ...future.result <- base::tryCatch({
[18:00:58.209]         base::withCallingHandlers({
[18:00:58.209]             ...future.value <- base::withVisible(base::local({
[18:00:58.209]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.209]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.209]                   ...future.globals.maxSize)) {
[18:00:58.209]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.209]                   on.exit(options(oopts), add = TRUE)
[18:00:58.209]                 }
[18:00:58.209]                 {
[18:00:58.209]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.209]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.209]                     USE.NAMES = FALSE)
[18:00:58.209]                   do.call(mapply, args = args)
[18:00:58.209]                 }
[18:00:58.209]             }))
[18:00:58.209]             future::FutureResult(value = ...future.value$value, 
[18:00:58.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.209]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.209]                     ...future.globalenv.names))
[18:00:58.209]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.209]         }, condition = base::local({
[18:00:58.209]             c <- base::c
[18:00:58.209]             inherits <- base::inherits
[18:00:58.209]             invokeRestart <- base::invokeRestart
[18:00:58.209]             length <- base::length
[18:00:58.209]             list <- base::list
[18:00:58.209]             seq.int <- base::seq.int
[18:00:58.209]             signalCondition <- base::signalCondition
[18:00:58.209]             sys.calls <- base::sys.calls
[18:00:58.209]             `[[` <- base::`[[`
[18:00:58.209]             `+` <- base::`+`
[18:00:58.209]             `<<-` <- base::`<<-`
[18:00:58.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.209]                   3L)]
[18:00:58.209]             }
[18:00:58.209]             function(cond) {
[18:00:58.209]                 is_error <- inherits(cond, "error")
[18:00:58.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.209]                   NULL)
[18:00:58.209]                 if (is_error) {
[18:00:58.209]                   sessionInformation <- function() {
[18:00:58.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.209]                       search = base::search(), system = base::Sys.info())
[18:00:58.209]                   }
[18:00:58.209]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.209]                     cond$call), session = sessionInformation(), 
[18:00:58.209]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.209]                   signalCondition(cond)
[18:00:58.209]                 }
[18:00:58.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.209]                 "immediateCondition"))) {
[18:00:58.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.209]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.209]                   if (TRUE && !signal) {
[18:00:58.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.209]                     {
[18:00:58.209]                       inherits <- base::inherits
[18:00:58.209]                       invokeRestart <- base::invokeRestart
[18:00:58.209]                       is.null <- base::is.null
[18:00:58.209]                       muffled <- FALSE
[18:00:58.209]                       if (inherits(cond, "message")) {
[18:00:58.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.209]                         if (muffled) 
[18:00:58.209]                           invokeRestart("muffleMessage")
[18:00:58.209]                       }
[18:00:58.209]                       else if (inherits(cond, "warning")) {
[18:00:58.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.209]                         if (muffled) 
[18:00:58.209]                           invokeRestart("muffleWarning")
[18:00:58.209]                       }
[18:00:58.209]                       else if (inherits(cond, "condition")) {
[18:00:58.209]                         if (!is.null(pattern)) {
[18:00:58.209]                           computeRestarts <- base::computeRestarts
[18:00:58.209]                           grepl <- base::grepl
[18:00:58.209]                           restarts <- computeRestarts(cond)
[18:00:58.209]                           for (restart in restarts) {
[18:00:58.209]                             name <- restart$name
[18:00:58.209]                             if (is.null(name)) 
[18:00:58.209]                               next
[18:00:58.209]                             if (!grepl(pattern, name)) 
[18:00:58.209]                               next
[18:00:58.209]                             invokeRestart(restart)
[18:00:58.209]                             muffled <- TRUE
[18:00:58.209]                             break
[18:00:58.209]                           }
[18:00:58.209]                         }
[18:00:58.209]                       }
[18:00:58.209]                       invisible(muffled)
[18:00:58.209]                     }
[18:00:58.209]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.209]                   }
[18:00:58.209]                 }
[18:00:58.209]                 else {
[18:00:58.209]                   if (TRUE) {
[18:00:58.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.209]                     {
[18:00:58.209]                       inherits <- base::inherits
[18:00:58.209]                       invokeRestart <- base::invokeRestart
[18:00:58.209]                       is.null <- base::is.null
[18:00:58.209]                       muffled <- FALSE
[18:00:58.209]                       if (inherits(cond, "message")) {
[18:00:58.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.209]                         if (muffled) 
[18:00:58.209]                           invokeRestart("muffleMessage")
[18:00:58.209]                       }
[18:00:58.209]                       else if (inherits(cond, "warning")) {
[18:00:58.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.209]                         if (muffled) 
[18:00:58.209]                           invokeRestart("muffleWarning")
[18:00:58.209]                       }
[18:00:58.209]                       else if (inherits(cond, "condition")) {
[18:00:58.209]                         if (!is.null(pattern)) {
[18:00:58.209]                           computeRestarts <- base::computeRestarts
[18:00:58.209]                           grepl <- base::grepl
[18:00:58.209]                           restarts <- computeRestarts(cond)
[18:00:58.209]                           for (restart in restarts) {
[18:00:58.209]                             name <- restart$name
[18:00:58.209]                             if (is.null(name)) 
[18:00:58.209]                               next
[18:00:58.209]                             if (!grepl(pattern, name)) 
[18:00:58.209]                               next
[18:00:58.209]                             invokeRestart(restart)
[18:00:58.209]                             muffled <- TRUE
[18:00:58.209]                             break
[18:00:58.209]                           }
[18:00:58.209]                         }
[18:00:58.209]                       }
[18:00:58.209]                       invisible(muffled)
[18:00:58.209]                     }
[18:00:58.209]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.209]                   }
[18:00:58.209]                 }
[18:00:58.209]             }
[18:00:58.209]         }))
[18:00:58.209]     }, error = function(ex) {
[18:00:58.209]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.209]                 ...future.rng), started = ...future.startTime, 
[18:00:58.209]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.209]             version = "1.8"), class = "FutureResult")
[18:00:58.209]     }, finally = {
[18:00:58.209]         if (!identical(...future.workdir, getwd())) 
[18:00:58.209]             setwd(...future.workdir)
[18:00:58.209]         {
[18:00:58.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.209]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.209]             }
[18:00:58.209]             base::options(...future.oldOptions)
[18:00:58.209]             if (.Platform$OS.type == "windows") {
[18:00:58.209]                 old_names <- names(...future.oldEnvVars)
[18:00:58.209]                 envs <- base::Sys.getenv()
[18:00:58.209]                 names <- names(envs)
[18:00:58.209]                 common <- intersect(names, old_names)
[18:00:58.209]                 added <- setdiff(names, old_names)
[18:00:58.209]                 removed <- setdiff(old_names, names)
[18:00:58.209]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.209]                   envs[common]]
[18:00:58.209]                 NAMES <- toupper(changed)
[18:00:58.209]                 args <- list()
[18:00:58.209]                 for (kk in seq_along(NAMES)) {
[18:00:58.209]                   name <- changed[[kk]]
[18:00:58.209]                   NAME <- NAMES[[kk]]
[18:00:58.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.209]                     next
[18:00:58.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.209]                 }
[18:00:58.209]                 NAMES <- toupper(added)
[18:00:58.209]                 for (kk in seq_along(NAMES)) {
[18:00:58.209]                   name <- added[[kk]]
[18:00:58.209]                   NAME <- NAMES[[kk]]
[18:00:58.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.209]                     next
[18:00:58.209]                   args[[name]] <- ""
[18:00:58.209]                 }
[18:00:58.209]                 NAMES <- toupper(removed)
[18:00:58.209]                 for (kk in seq_along(NAMES)) {
[18:00:58.209]                   name <- removed[[kk]]
[18:00:58.209]                   NAME <- NAMES[[kk]]
[18:00:58.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.209]                     next
[18:00:58.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.209]                 }
[18:00:58.209]                 if (length(args) > 0) 
[18:00:58.209]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.209]             }
[18:00:58.209]             else {
[18:00:58.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.209]             }
[18:00:58.209]             {
[18:00:58.209]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.209]                   0L) {
[18:00:58.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.209]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.209]                   base::options(opts)
[18:00:58.209]                 }
[18:00:58.209]                 {
[18:00:58.209]                   {
[18:00:58.209]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.209]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.209]                     1423455687L), envir = base::globalenv(), 
[18:00:58.209]                       inherits = FALSE)
[18:00:58.209]                     NULL
[18:00:58.209]                   }
[18:00:58.209]                   options(future.plan = NULL)
[18:00:58.209]                   if (is.na(NA_character_)) 
[18:00:58.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.209]                     .init = FALSE)
[18:00:58.209]                 }
[18:00:58.209]             }
[18:00:58.209]         }
[18:00:58.209]     })
[18:00:58.209]     if (TRUE) {
[18:00:58.209]         base::sink(type = "output", split = FALSE)
[18:00:58.209]         if (TRUE) {
[18:00:58.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.209]         }
[18:00:58.209]         else {
[18:00:58.209]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.209]         }
[18:00:58.209]         base::close(...future.stdout)
[18:00:58.209]         ...future.stdout <- NULL
[18:00:58.209]     }
[18:00:58.209]     ...future.result$conditions <- ...future.conditions
[18:00:58.209]     ...future.result$finished <- base::Sys.time()
[18:00:58.209]     ...future.result
[18:00:58.209] }
[18:00:58.213] assign_globals() ...
[18:00:58.213] List of 5
[18:00:58.213]  $ ...future.FUN            :function (C, k)  
[18:00:58.213]  $ MoreArgs                 : NULL
[18:00:58.213]  $ ...future.elements_ii    :List of 2
[18:00:58.213]   ..$ :List of 2
[18:00:58.213]   .. ..$ : chr "E"
[18:00:58.213]   .. ..$ : chr "D"
[18:00:58.213]   ..$ :List of 2
[18:00:58.213]   .. ..$ : int 1
[18:00:58.213]   .. ..$ : int 2
[18:00:58.213]  $ ...future.seeds_ii       : NULL
[18:00:58.213]  $ ...future.globals.maxSize: NULL
[18:00:58.213]  - attr(*, "where")=List of 5
[18:00:58.213]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.213]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.213]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.213]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.213]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.213]  - attr(*, "resolved")= logi FALSE
[18:00:58.213]  - attr(*, "total_size")= num 3656
[18:00:58.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.213]  - attr(*, "already-done")= logi TRUE
[18:00:58.227] - reassign environment for ‘...future.FUN’
[18:00:58.227] - copied ‘...future.FUN’ to environment
[18:00:58.227] - copied ‘MoreArgs’ to environment
[18:00:58.228] - copied ‘...future.elements_ii’ to environment
[18:00:58.228] - copied ‘...future.seeds_ii’ to environment
[18:00:58.228] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.228] assign_globals() ... done
[18:00:58.229] plan(): Setting new future strategy stack:
[18:00:58.229] List of future strategies:
[18:00:58.229] 1. sequential:
[18:00:58.229]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.229]    - tweaked: FALSE
[18:00:58.229]    - call: NULL
[18:00:58.230] plan(): nbrOfWorkers() = 1
[18:00:58.231] plan(): Setting new future strategy stack:
[18:00:58.231] List of future strategies:
[18:00:58.231] 1. sequential:
[18:00:58.231]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.231]    - tweaked: FALSE
[18:00:58.231]    - call: plan(strategy)
[18:00:58.232] plan(): nbrOfWorkers() = 1
[18:00:58.233] SequentialFuture started (and completed)
[18:00:58.233] - Launch lazy future ... done
[18:00:58.233] run() for ‘SequentialFuture’ ... done
[18:00:58.233] Created future:
[18:00:58.233] SequentialFuture:
[18:00:58.233] Label: ‘future_mapply-1’
[18:00:58.233] Expression:
[18:00:58.233] {
[18:00:58.233]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.233]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.233]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.233]         on.exit(options(oopts), add = TRUE)
[18:00:58.233]     }
[18:00:58.233]     {
[18:00:58.233]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.233]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.233]         do.call(mapply, args = args)
[18:00:58.233]     }
[18:00:58.233] }
[18:00:58.233] Lazy evaluation: FALSE
[18:00:58.233] Asynchronous evaluation: FALSE
[18:00:58.233] Local evaluation: TRUE
[18:00:58.233] Environment: R_GlobalEnv
[18:00:58.233] Capture standard output: TRUE
[18:00:58.233] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.233] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.233] Packages: <none>
[18:00:58.233] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.233] Resolved: TRUE
[18:00:58.233] Value: 224 bytes of class ‘list’
[18:00:58.233] Early signaling: FALSE
[18:00:58.233] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.233] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.235] Chunk #1 of 2 ... DONE
[18:00:58.235] Chunk #2 of 2 ...
[18:00:58.236]  - Finding globals in '...' for chunk #2 ...
[18:00:58.236] getGlobalsAndPackages() ...
[18:00:58.236] Searching for globals...
[18:00:58.237] 
[18:00:58.237] Searching for globals ... DONE
[18:00:58.237] - globals: [0] <none>
[18:00:58.237] getGlobalsAndPackages() ... DONE
[18:00:58.238]    + additional globals found: [n=0] 
[18:00:58.238]    + additional namespaces needed: [n=0] 
[18:00:58.238]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:58.238]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:58.238]  - seeds: <none>
[18:00:58.239]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.239] getGlobalsAndPackages() ...
[18:00:58.239] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.239] Resolving globals: FALSE
[18:00:58.240] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:00:58.241] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.241] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.242] 
[18:00:58.242] getGlobalsAndPackages() ... DONE
[18:00:58.242] run() for ‘Future’ ...
[18:00:58.243] - state: ‘created’
[18:00:58.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.244]   - Field: ‘label’
[18:00:58.244]   - Field: ‘local’
[18:00:58.244]   - Field: ‘owner’
[18:00:58.244]   - Field: ‘envir’
[18:00:58.245]   - Field: ‘packages’
[18:00:58.245]   - Field: ‘gc’
[18:00:58.245]   - Field: ‘conditions’
[18:00:58.245]   - Field: ‘expr’
[18:00:58.245]   - Field: ‘uuid’
[18:00:58.246]   - Field: ‘seed’
[18:00:58.246]   - Field: ‘version’
[18:00:58.246]   - Field: ‘result’
[18:00:58.246]   - Field: ‘asynchronous’
[18:00:58.246]   - Field: ‘calls’
[18:00:58.247]   - Field: ‘globals’
[18:00:58.247]   - Field: ‘stdout’
[18:00:58.247]   - Field: ‘earlySignal’
[18:00:58.247]   - Field: ‘lazy’
[18:00:58.247]   - Field: ‘state’
[18:00:58.247] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.248] - Launch lazy future ...
[18:00:58.248] Packages needed by the future expression (n = 0): <none>
[18:00:58.248] Packages needed by future strategies (n = 0): <none>
[18:00:58.249] {
[18:00:58.249]     {
[18:00:58.249]         {
[18:00:58.249]             ...future.startTime <- base::Sys.time()
[18:00:58.249]             {
[18:00:58.249]                 {
[18:00:58.249]                   {
[18:00:58.249]                     base::local({
[18:00:58.249]                       has_future <- base::requireNamespace("future", 
[18:00:58.249]                         quietly = TRUE)
[18:00:58.249]                       if (has_future) {
[18:00:58.249]                         ns <- base::getNamespace("future")
[18:00:58.249]                         version <- ns[[".package"]][["version"]]
[18:00:58.249]                         if (is.null(version)) 
[18:00:58.249]                           version <- utils::packageVersion("future")
[18:00:58.249]                       }
[18:00:58.249]                       else {
[18:00:58.249]                         version <- NULL
[18:00:58.249]                       }
[18:00:58.249]                       if (!has_future || version < "1.8.0") {
[18:00:58.249]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.249]                           "", base::R.version$version.string), 
[18:00:58.249]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.249]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.249]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.249]                             "release", "version")], collapse = " "), 
[18:00:58.249]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.249]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.249]                           info)
[18:00:58.249]                         info <- base::paste(info, collapse = "; ")
[18:00:58.249]                         if (!has_future) {
[18:00:58.249]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.249]                             info)
[18:00:58.249]                         }
[18:00:58.249]                         else {
[18:00:58.249]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.249]                             info, version)
[18:00:58.249]                         }
[18:00:58.249]                         base::stop(msg)
[18:00:58.249]                       }
[18:00:58.249]                     })
[18:00:58.249]                   }
[18:00:58.249]                   ...future.strategy.old <- future::plan("list")
[18:00:58.249]                   options(future.plan = NULL)
[18:00:58.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.249]                 }
[18:00:58.249]                 ...future.workdir <- getwd()
[18:00:58.249]             }
[18:00:58.249]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.249]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.249]         }
[18:00:58.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.249]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:58.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.249]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.249]             base::names(...future.oldOptions))
[18:00:58.249]     }
[18:00:58.249]     if (FALSE) {
[18:00:58.249]     }
[18:00:58.249]     else {
[18:00:58.249]         if (TRUE) {
[18:00:58.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.249]                 open = "w")
[18:00:58.249]         }
[18:00:58.249]         else {
[18:00:58.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.249]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.249]         }
[18:00:58.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.249]             base::sink(type = "output", split = FALSE)
[18:00:58.249]             base::close(...future.stdout)
[18:00:58.249]         }, add = TRUE)
[18:00:58.249]     }
[18:00:58.249]     ...future.frame <- base::sys.nframe()
[18:00:58.249]     ...future.conditions <- base::list()
[18:00:58.249]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.249]     if (FALSE) {
[18:00:58.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.249]     }
[18:00:58.249]     ...future.result <- base::tryCatch({
[18:00:58.249]         base::withCallingHandlers({
[18:00:58.249]             ...future.value <- base::withVisible(base::local({
[18:00:58.249]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.249]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.249]                   ...future.globals.maxSize)) {
[18:00:58.249]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.249]                   on.exit(options(oopts), add = TRUE)
[18:00:58.249]                 }
[18:00:58.249]                 {
[18:00:58.249]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.249]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.249]                     USE.NAMES = FALSE)
[18:00:58.249]                   do.call(mapply, args = args)
[18:00:58.249]                 }
[18:00:58.249]             }))
[18:00:58.249]             future::FutureResult(value = ...future.value$value, 
[18:00:58.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.249]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.249]                     ...future.globalenv.names))
[18:00:58.249]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.249]         }, condition = base::local({
[18:00:58.249]             c <- base::c
[18:00:58.249]             inherits <- base::inherits
[18:00:58.249]             invokeRestart <- base::invokeRestart
[18:00:58.249]             length <- base::length
[18:00:58.249]             list <- base::list
[18:00:58.249]             seq.int <- base::seq.int
[18:00:58.249]             signalCondition <- base::signalCondition
[18:00:58.249]             sys.calls <- base::sys.calls
[18:00:58.249]             `[[` <- base::`[[`
[18:00:58.249]             `+` <- base::`+`
[18:00:58.249]             `<<-` <- base::`<<-`
[18:00:58.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.249]                   3L)]
[18:00:58.249]             }
[18:00:58.249]             function(cond) {
[18:00:58.249]                 is_error <- inherits(cond, "error")
[18:00:58.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.249]                   NULL)
[18:00:58.249]                 if (is_error) {
[18:00:58.249]                   sessionInformation <- function() {
[18:00:58.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.249]                       search = base::search(), system = base::Sys.info())
[18:00:58.249]                   }
[18:00:58.249]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.249]                     cond$call), session = sessionInformation(), 
[18:00:58.249]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.249]                   signalCondition(cond)
[18:00:58.249]                 }
[18:00:58.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.249]                 "immediateCondition"))) {
[18:00:58.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.249]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.249]                   if (TRUE && !signal) {
[18:00:58.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.249]                     {
[18:00:58.249]                       inherits <- base::inherits
[18:00:58.249]                       invokeRestart <- base::invokeRestart
[18:00:58.249]                       is.null <- base::is.null
[18:00:58.249]                       muffled <- FALSE
[18:00:58.249]                       if (inherits(cond, "message")) {
[18:00:58.249]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.249]                         if (muffled) 
[18:00:58.249]                           invokeRestart("muffleMessage")
[18:00:58.249]                       }
[18:00:58.249]                       else if (inherits(cond, "warning")) {
[18:00:58.249]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.249]                         if (muffled) 
[18:00:58.249]                           invokeRestart("muffleWarning")
[18:00:58.249]                       }
[18:00:58.249]                       else if (inherits(cond, "condition")) {
[18:00:58.249]                         if (!is.null(pattern)) {
[18:00:58.249]                           computeRestarts <- base::computeRestarts
[18:00:58.249]                           grepl <- base::grepl
[18:00:58.249]                           restarts <- computeRestarts(cond)
[18:00:58.249]                           for (restart in restarts) {
[18:00:58.249]                             name <- restart$name
[18:00:58.249]                             if (is.null(name)) 
[18:00:58.249]                               next
[18:00:58.249]                             if (!grepl(pattern, name)) 
[18:00:58.249]                               next
[18:00:58.249]                             invokeRestart(restart)
[18:00:58.249]                             muffled <- TRUE
[18:00:58.249]                             break
[18:00:58.249]                           }
[18:00:58.249]                         }
[18:00:58.249]                       }
[18:00:58.249]                       invisible(muffled)
[18:00:58.249]                     }
[18:00:58.249]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.249]                   }
[18:00:58.249]                 }
[18:00:58.249]                 else {
[18:00:58.249]                   if (TRUE) {
[18:00:58.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.249]                     {
[18:00:58.249]                       inherits <- base::inherits
[18:00:58.249]                       invokeRestart <- base::invokeRestart
[18:00:58.249]                       is.null <- base::is.null
[18:00:58.249]                       muffled <- FALSE
[18:00:58.249]                       if (inherits(cond, "message")) {
[18:00:58.249]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.249]                         if (muffled) 
[18:00:58.249]                           invokeRestart("muffleMessage")
[18:00:58.249]                       }
[18:00:58.249]                       else if (inherits(cond, "warning")) {
[18:00:58.249]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.249]                         if (muffled) 
[18:00:58.249]                           invokeRestart("muffleWarning")
[18:00:58.249]                       }
[18:00:58.249]                       else if (inherits(cond, "condition")) {
[18:00:58.249]                         if (!is.null(pattern)) {
[18:00:58.249]                           computeRestarts <- base::computeRestarts
[18:00:58.249]                           grepl <- base::grepl
[18:00:58.249]                           restarts <- computeRestarts(cond)
[18:00:58.249]                           for (restart in restarts) {
[18:00:58.249]                             name <- restart$name
[18:00:58.249]                             if (is.null(name)) 
[18:00:58.249]                               next
[18:00:58.249]                             if (!grepl(pattern, name)) 
[18:00:58.249]                               next
[18:00:58.249]                             invokeRestart(restart)
[18:00:58.249]                             muffled <- TRUE
[18:00:58.249]                             break
[18:00:58.249]                           }
[18:00:58.249]                         }
[18:00:58.249]                       }
[18:00:58.249]                       invisible(muffled)
[18:00:58.249]                     }
[18:00:58.249]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.249]                   }
[18:00:58.249]                 }
[18:00:58.249]             }
[18:00:58.249]         }))
[18:00:58.249]     }, error = function(ex) {
[18:00:58.249]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.249]                 ...future.rng), started = ...future.startTime, 
[18:00:58.249]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.249]             version = "1.8"), class = "FutureResult")
[18:00:58.249]     }, finally = {
[18:00:58.249]         if (!identical(...future.workdir, getwd())) 
[18:00:58.249]             setwd(...future.workdir)
[18:00:58.249]         {
[18:00:58.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.249]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.249]             }
[18:00:58.249]             base::options(...future.oldOptions)
[18:00:58.249]             if (.Platform$OS.type == "windows") {
[18:00:58.249]                 old_names <- names(...future.oldEnvVars)
[18:00:58.249]                 envs <- base::Sys.getenv()
[18:00:58.249]                 names <- names(envs)
[18:00:58.249]                 common <- intersect(names, old_names)
[18:00:58.249]                 added <- setdiff(names, old_names)
[18:00:58.249]                 removed <- setdiff(old_names, names)
[18:00:58.249]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.249]                   envs[common]]
[18:00:58.249]                 NAMES <- toupper(changed)
[18:00:58.249]                 args <- list()
[18:00:58.249]                 for (kk in seq_along(NAMES)) {
[18:00:58.249]                   name <- changed[[kk]]
[18:00:58.249]                   NAME <- NAMES[[kk]]
[18:00:58.249]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.249]                     next
[18:00:58.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.249]                 }
[18:00:58.249]                 NAMES <- toupper(added)
[18:00:58.249]                 for (kk in seq_along(NAMES)) {
[18:00:58.249]                   name <- added[[kk]]
[18:00:58.249]                   NAME <- NAMES[[kk]]
[18:00:58.249]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.249]                     next
[18:00:58.249]                   args[[name]] <- ""
[18:00:58.249]                 }
[18:00:58.249]                 NAMES <- toupper(removed)
[18:00:58.249]                 for (kk in seq_along(NAMES)) {
[18:00:58.249]                   name <- removed[[kk]]
[18:00:58.249]                   NAME <- NAMES[[kk]]
[18:00:58.249]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.249]                     next
[18:00:58.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.249]                 }
[18:00:58.249]                 if (length(args) > 0) 
[18:00:58.249]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.249]             }
[18:00:58.249]             else {
[18:00:58.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.249]             }
[18:00:58.249]             {
[18:00:58.249]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.249]                   0L) {
[18:00:58.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.249]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.249]                   base::options(opts)
[18:00:58.249]                 }
[18:00:58.249]                 {
[18:00:58.249]                   {
[18:00:58.249]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.249]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.249]                     1423455687L), envir = base::globalenv(), 
[18:00:58.249]                       inherits = FALSE)
[18:00:58.249]                     NULL
[18:00:58.249]                   }
[18:00:58.249]                   options(future.plan = NULL)
[18:00:58.249]                   if (is.na(NA_character_)) 
[18:00:58.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.249]                     .init = FALSE)
[18:00:58.249]                 }
[18:00:58.249]             }
[18:00:58.249]         }
[18:00:58.249]     })
[18:00:58.249]     if (TRUE) {
[18:00:58.249]         base::sink(type = "output", split = FALSE)
[18:00:58.249]         if (TRUE) {
[18:00:58.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.249]         }
[18:00:58.249]         else {
[18:00:58.249]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.249]         }
[18:00:58.249]         base::close(...future.stdout)
[18:00:58.249]         ...future.stdout <- NULL
[18:00:58.249]     }
[18:00:58.249]     ...future.result$conditions <- ...future.conditions
[18:00:58.249]     ...future.result$finished <- base::Sys.time()
[18:00:58.249]     ...future.result
[18:00:58.249] }
[18:00:58.252] assign_globals() ...
[18:00:58.253] List of 5
[18:00:58.253]  $ ...future.FUN            :function (C, k)  
[18:00:58.253]  $ MoreArgs                 : NULL
[18:00:58.253]  $ ...future.elements_ii    :List of 2
[18:00:58.253]   ..$ :List of 3
[18:00:58.253]   .. ..$ : chr "C"
[18:00:58.253]   .. ..$ : chr "B"
[18:00:58.253]   .. ..$ : chr "A"
[18:00:58.253]   ..$ :List of 3
[18:00:58.253]   .. ..$ : int 3
[18:00:58.253]   .. ..$ : int 4
[18:00:58.253]   .. ..$ : int 5
[18:00:58.253]  $ ...future.seeds_ii       : NULL
[18:00:58.253]  $ ...future.globals.maxSize: NULL
[18:00:58.253]  - attr(*, "where")=List of 5
[18:00:58.253]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.253]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.253]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.253]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.253]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.253]  - attr(*, "resolved")= logi FALSE
[18:00:58.253]  - attr(*, "total_size")= num 3824
[18:00:58.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.253]  - attr(*, "already-done")= logi TRUE
[18:00:58.265] - reassign environment for ‘...future.FUN’
[18:00:58.265] - copied ‘...future.FUN’ to environment
[18:00:58.265] - copied ‘MoreArgs’ to environment
[18:00:58.265] - copied ‘...future.elements_ii’ to environment
[18:00:58.265] - copied ‘...future.seeds_ii’ to environment
[18:00:58.268] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.268] assign_globals() ... done
[18:00:58.269] plan(): Setting new future strategy stack:
[18:00:58.269] List of future strategies:
[18:00:58.269] 1. sequential:
[18:00:58.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.269]    - tweaked: FALSE
[18:00:58.269]    - call: NULL
[18:00:58.270] plan(): nbrOfWorkers() = 1
[18:00:58.272] plan(): Setting new future strategy stack:
[18:00:58.272] List of future strategies:
[18:00:58.272] 1. sequential:
[18:00:58.272]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.272]    - tweaked: FALSE
[18:00:58.272]    - call: plan(strategy)
[18:00:58.273] plan(): nbrOfWorkers() = 1
[18:00:58.273] SequentialFuture started (and completed)
[18:00:58.273] - Launch lazy future ... done
[18:00:58.273] run() for ‘SequentialFuture’ ... done
[18:00:58.274] Created future:
[18:00:58.274] SequentialFuture:
[18:00:58.274] Label: ‘future_mapply-2’
[18:00:58.274] Expression:
[18:00:58.274] {
[18:00:58.274]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.274]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.274]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.274]         on.exit(options(oopts), add = TRUE)
[18:00:58.274]     }
[18:00:58.274]     {
[18:00:58.274]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.274]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.274]         do.call(mapply, args = args)
[18:00:58.274]     }
[18:00:58.274] }
[18:00:58.274] Lazy evaluation: FALSE
[18:00:58.274] Asynchronous evaluation: FALSE
[18:00:58.274] Local evaluation: TRUE
[18:00:58.274] Environment: R_GlobalEnv
[18:00:58.274] Capture standard output: TRUE
[18:00:58.274] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.274] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.274] Packages: <none>
[18:00:58.274] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.274] Resolved: TRUE
[18:00:58.274] Value: 336 bytes of class ‘list’
[18:00:58.274] Early signaling: FALSE
[18:00:58.274] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.274] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.276] Chunk #2 of 2 ... DONE
[18:00:58.276] Launching 2 futures (chunks) ... DONE
[18:00:58.276] Resolving 2 futures (chunks) ...
[18:00:58.276] resolve() on list ...
[18:00:58.277]  recursive: 0
[18:00:58.277]  length: 2
[18:00:58.277] 
[18:00:58.277] resolved() for ‘SequentialFuture’ ...
[18:00:58.277] - state: ‘finished’
[18:00:58.278] - run: TRUE
[18:00:58.278] - result: ‘FutureResult’
[18:00:58.278] resolved() for ‘SequentialFuture’ ... done
[18:00:58.278] Future #1
[18:00:58.278] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.279] - nx: 2
[18:00:58.279] - relay: TRUE
[18:00:58.279] - stdout: TRUE
[18:00:58.279] - signal: TRUE
[18:00:58.279] - resignal: FALSE
[18:00:58.279] - force: TRUE
[18:00:58.280] - relayed: [n=2] FALSE, FALSE
[18:00:58.280] - queued futures: [n=2] FALSE, FALSE
[18:00:58.280]  - until=1
[18:00:58.280]  - relaying element #1
[18:00:58.281] - relayed: [n=2] TRUE, FALSE
[18:00:58.281] - queued futures: [n=2] TRUE, FALSE
[18:00:58.281] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.281]  length: 1 (resolved future 1)
[18:00:58.281] resolved() for ‘SequentialFuture’ ...
[18:00:58.282] - state: ‘finished’
[18:00:58.282] - run: TRUE
[18:00:58.282] - result: ‘FutureResult’
[18:00:58.282] resolved() for ‘SequentialFuture’ ... done
[18:00:58.282] Future #2
[18:00:58.283] signalConditionsASAP(SequentialFuture, pos=2) ...
[18:00:58.283] - nx: 2
[18:00:58.283] - relay: TRUE
[18:00:58.283] - stdout: TRUE
[18:00:58.283] - signal: TRUE
[18:00:58.284] - resignal: FALSE
[18:00:58.284] - force: TRUE
[18:00:58.284] - relayed: [n=2] TRUE, FALSE
[18:00:58.284] - queued futures: [n=2] TRUE, FALSE
[18:00:58.284]  - until=2
[18:00:58.284]  - relaying element #2
[18:00:58.285] - relayed: [n=2] TRUE, TRUE
[18:00:58.285] - queued futures: [n=2] TRUE, TRUE
[18:00:58.285] signalConditionsASAP(SequentialFuture, pos=2) ... done
[18:00:58.285]  length: 0 (resolved future 2)
[18:00:58.286] Relaying remaining futures
[18:00:58.286] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.286] - nx: 2
[18:00:58.286] - relay: TRUE
[18:00:58.286] - stdout: TRUE
[18:00:58.286] - signal: TRUE
[18:00:58.287] - resignal: FALSE
[18:00:58.287] - force: TRUE
[18:00:58.287] - relayed: [n=2] TRUE, TRUE
[18:00:58.287] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:00:58.287] - relayed: [n=2] TRUE, TRUE
[18:00:58.288] - queued futures: [n=2] TRUE, TRUE
[18:00:58.288] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.288] resolve() on list ... DONE
[18:00:58.288]  - Number of value chunks collected: 2
[18:00:58.289] Resolving 2 futures (chunks) ... DONE
[18:00:58.289] Reducing values from 2 chunks ...
[18:00:58.289]  - Number of values collected after concatenation: 5
[18:00:58.289]  - Number of values expected: 5
[18:00:58.289] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[18:00:58.290] Reducing values from 2 chunks ... DONE
[18:00:58.290] future_mapply() ... DONE
[18:00:58.290] future_mapply() ...
[18:00:58.291] Number of chunks: 1
[18:00:58.291] getGlobalsAndPackagesXApply() ...
[18:00:58.291]  - future.globals: TRUE
[18:00:58.291] getGlobalsAndPackages() ...
[18:00:58.291] Searching for globals...
[18:00:58.294] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:00:58.294] Searching for globals ... DONE
[18:00:58.294] Resolving globals: FALSE
[18:00:58.295] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:00:58.296] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:00:58.296] - globals: [1] ‘FUN’
[18:00:58.296] 
[18:00:58.296] getGlobalsAndPackages() ... DONE
[18:00:58.296]  - globals found/used: [n=1] ‘FUN’
[18:00:58.297]  - needed namespaces: [n=0] 
[18:00:58.297] Finding globals ... DONE
[18:00:58.297] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.297] List of 2
[18:00:58.297]  $ ...future.FUN:function (C, k)  
[18:00:58.297]  $ MoreArgs     : list()
[18:00:58.297]  - attr(*, "where")=List of 2
[18:00:58.297]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.297]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.297]  - attr(*, "resolved")= logi FALSE
[18:00:58.297]  - attr(*, "total_size")= num NA
[18:00:58.302] Packages to be attached in all futures: [n=0] 
[18:00:58.302] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.303] Number of futures (= number of chunks): 1
[18:00:58.303] Launching 1 futures (chunks) ...
[18:00:58.303] Chunk #1 of 1 ...
[18:00:58.304]  - Finding globals in '...' for chunk #1 ...
[18:00:58.304] getGlobalsAndPackages() ...
[18:00:58.304] Searching for globals...
[18:00:58.305] 
[18:00:58.305] Searching for globals ... DONE
[18:00:58.305] - globals: [0] <none>
[18:00:58.305] getGlobalsAndPackages() ... DONE
[18:00:58.305]    + additional globals found: [n=0] 
[18:00:58.306]    + additional namespaces needed: [n=0] 
[18:00:58.306]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.306]  - seeds: <none>
[18:00:58.306]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.306] getGlobalsAndPackages() ...
[18:00:58.307] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.307] Resolving globals: FALSE
[18:00:58.308] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[18:00:58.309] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:00:58.309] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.310] 
[18:00:58.310] getGlobalsAndPackages() ... DONE
[18:00:58.310] run() for ‘Future’ ...
[18:00:58.311] - state: ‘created’
[18:00:58.311] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.311] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.312]   - Field: ‘label’
[18:00:58.312]   - Field: ‘local’
[18:00:58.312]   - Field: ‘owner’
[18:00:58.312]   - Field: ‘envir’
[18:00:58.313]   - Field: ‘packages’
[18:00:58.313]   - Field: ‘gc’
[18:00:58.313]   - Field: ‘conditions’
[18:00:58.313]   - Field: ‘expr’
[18:00:58.313]   - Field: ‘uuid’
[18:00:58.314]   - Field: ‘seed’
[18:00:58.314]   - Field: ‘version’
[18:00:58.314]   - Field: ‘result’
[18:00:58.314]   - Field: ‘asynchronous’
[18:00:58.314]   - Field: ‘calls’
[18:00:58.315]   - Field: ‘globals’
[18:00:58.315]   - Field: ‘stdout’
[18:00:58.315]   - Field: ‘earlySignal’
[18:00:58.315]   - Field: ‘lazy’
[18:00:58.315]   - Field: ‘state’
[18:00:58.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.316] - Launch lazy future ...
[18:00:58.316] Packages needed by the future expression (n = 0): <none>
[18:00:58.319] Packages needed by future strategies (n = 0): <none>
[18:00:58.320] {
[18:00:58.320]     {
[18:00:58.320]         {
[18:00:58.320]             ...future.startTime <- base::Sys.time()
[18:00:58.320]             {
[18:00:58.320]                 {
[18:00:58.320]                   {
[18:00:58.320]                     base::local({
[18:00:58.320]                       has_future <- base::requireNamespace("future", 
[18:00:58.320]                         quietly = TRUE)
[18:00:58.320]                       if (has_future) {
[18:00:58.320]                         ns <- base::getNamespace("future")
[18:00:58.320]                         version <- ns[[".package"]][["version"]]
[18:00:58.320]                         if (is.null(version)) 
[18:00:58.320]                           version <- utils::packageVersion("future")
[18:00:58.320]                       }
[18:00:58.320]                       else {
[18:00:58.320]                         version <- NULL
[18:00:58.320]                       }
[18:00:58.320]                       if (!has_future || version < "1.8.0") {
[18:00:58.320]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.320]                           "", base::R.version$version.string), 
[18:00:58.320]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.320]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.320]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.320]                             "release", "version")], collapse = " "), 
[18:00:58.320]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.320]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.320]                           info)
[18:00:58.320]                         info <- base::paste(info, collapse = "; ")
[18:00:58.320]                         if (!has_future) {
[18:00:58.320]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.320]                             info)
[18:00:58.320]                         }
[18:00:58.320]                         else {
[18:00:58.320]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.320]                             info, version)
[18:00:58.320]                         }
[18:00:58.320]                         base::stop(msg)
[18:00:58.320]                       }
[18:00:58.320]                     })
[18:00:58.320]                   }
[18:00:58.320]                   ...future.strategy.old <- future::plan("list")
[18:00:58.320]                   options(future.plan = NULL)
[18:00:58.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.320]                 }
[18:00:58.320]                 ...future.workdir <- getwd()
[18:00:58.320]             }
[18:00:58.320]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.320]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.320]         }
[18:00:58.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.320]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.320]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.320]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.320]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.320]             base::names(...future.oldOptions))
[18:00:58.320]     }
[18:00:58.320]     if (FALSE) {
[18:00:58.320]     }
[18:00:58.320]     else {
[18:00:58.320]         if (TRUE) {
[18:00:58.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.320]                 open = "w")
[18:00:58.320]         }
[18:00:58.320]         else {
[18:00:58.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.320]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.320]         }
[18:00:58.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.320]             base::sink(type = "output", split = FALSE)
[18:00:58.320]             base::close(...future.stdout)
[18:00:58.320]         }, add = TRUE)
[18:00:58.320]     }
[18:00:58.320]     ...future.frame <- base::sys.nframe()
[18:00:58.320]     ...future.conditions <- base::list()
[18:00:58.320]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.320]     if (FALSE) {
[18:00:58.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.320]     }
[18:00:58.320]     ...future.result <- base::tryCatch({
[18:00:58.320]         base::withCallingHandlers({
[18:00:58.320]             ...future.value <- base::withVisible(base::local({
[18:00:58.320]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.320]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.320]                   ...future.globals.maxSize)) {
[18:00:58.320]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.320]                   on.exit(options(oopts), add = TRUE)
[18:00:58.320]                 }
[18:00:58.320]                 {
[18:00:58.320]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.320]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.320]                     USE.NAMES = FALSE)
[18:00:58.320]                   do.call(mapply, args = args)
[18:00:58.320]                 }
[18:00:58.320]             }))
[18:00:58.320]             future::FutureResult(value = ...future.value$value, 
[18:00:58.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.320]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.320]                     ...future.globalenv.names))
[18:00:58.320]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.320]         }, condition = base::local({
[18:00:58.320]             c <- base::c
[18:00:58.320]             inherits <- base::inherits
[18:00:58.320]             invokeRestart <- base::invokeRestart
[18:00:58.320]             length <- base::length
[18:00:58.320]             list <- base::list
[18:00:58.320]             seq.int <- base::seq.int
[18:00:58.320]             signalCondition <- base::signalCondition
[18:00:58.320]             sys.calls <- base::sys.calls
[18:00:58.320]             `[[` <- base::`[[`
[18:00:58.320]             `+` <- base::`+`
[18:00:58.320]             `<<-` <- base::`<<-`
[18:00:58.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.320]                   3L)]
[18:00:58.320]             }
[18:00:58.320]             function(cond) {
[18:00:58.320]                 is_error <- inherits(cond, "error")
[18:00:58.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.320]                   NULL)
[18:00:58.320]                 if (is_error) {
[18:00:58.320]                   sessionInformation <- function() {
[18:00:58.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.320]                       search = base::search(), system = base::Sys.info())
[18:00:58.320]                   }
[18:00:58.320]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.320]                     cond$call), session = sessionInformation(), 
[18:00:58.320]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.320]                   signalCondition(cond)
[18:00:58.320]                 }
[18:00:58.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.320]                 "immediateCondition"))) {
[18:00:58.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.320]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.320]                   if (TRUE && !signal) {
[18:00:58.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.320]                     {
[18:00:58.320]                       inherits <- base::inherits
[18:00:58.320]                       invokeRestart <- base::invokeRestart
[18:00:58.320]                       is.null <- base::is.null
[18:00:58.320]                       muffled <- FALSE
[18:00:58.320]                       if (inherits(cond, "message")) {
[18:00:58.320]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.320]                         if (muffled) 
[18:00:58.320]                           invokeRestart("muffleMessage")
[18:00:58.320]                       }
[18:00:58.320]                       else if (inherits(cond, "warning")) {
[18:00:58.320]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.320]                         if (muffled) 
[18:00:58.320]                           invokeRestart("muffleWarning")
[18:00:58.320]                       }
[18:00:58.320]                       else if (inherits(cond, "condition")) {
[18:00:58.320]                         if (!is.null(pattern)) {
[18:00:58.320]                           computeRestarts <- base::computeRestarts
[18:00:58.320]                           grepl <- base::grepl
[18:00:58.320]                           restarts <- computeRestarts(cond)
[18:00:58.320]                           for (restart in restarts) {
[18:00:58.320]                             name <- restart$name
[18:00:58.320]                             if (is.null(name)) 
[18:00:58.320]                               next
[18:00:58.320]                             if (!grepl(pattern, name)) 
[18:00:58.320]                               next
[18:00:58.320]                             invokeRestart(restart)
[18:00:58.320]                             muffled <- TRUE
[18:00:58.320]                             break
[18:00:58.320]                           }
[18:00:58.320]                         }
[18:00:58.320]                       }
[18:00:58.320]                       invisible(muffled)
[18:00:58.320]                     }
[18:00:58.320]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.320]                   }
[18:00:58.320]                 }
[18:00:58.320]                 else {
[18:00:58.320]                   if (TRUE) {
[18:00:58.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.320]                     {
[18:00:58.320]                       inherits <- base::inherits
[18:00:58.320]                       invokeRestart <- base::invokeRestart
[18:00:58.320]                       is.null <- base::is.null
[18:00:58.320]                       muffled <- FALSE
[18:00:58.320]                       if (inherits(cond, "message")) {
[18:00:58.320]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.320]                         if (muffled) 
[18:00:58.320]                           invokeRestart("muffleMessage")
[18:00:58.320]                       }
[18:00:58.320]                       else if (inherits(cond, "warning")) {
[18:00:58.320]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.320]                         if (muffled) 
[18:00:58.320]                           invokeRestart("muffleWarning")
[18:00:58.320]                       }
[18:00:58.320]                       else if (inherits(cond, "condition")) {
[18:00:58.320]                         if (!is.null(pattern)) {
[18:00:58.320]                           computeRestarts <- base::computeRestarts
[18:00:58.320]                           grepl <- base::grepl
[18:00:58.320]                           restarts <- computeRestarts(cond)
[18:00:58.320]                           for (restart in restarts) {
[18:00:58.320]                             name <- restart$name
[18:00:58.320]                             if (is.null(name)) 
[18:00:58.320]                               next
[18:00:58.320]                             if (!grepl(pattern, name)) 
[18:00:58.320]                               next
[18:00:58.320]                             invokeRestart(restart)
[18:00:58.320]                             muffled <- TRUE
[18:00:58.320]                             break
[18:00:58.320]                           }
[18:00:58.320]                         }
[18:00:58.320]                       }
[18:00:58.320]                       invisible(muffled)
[18:00:58.320]                     }
[18:00:58.320]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.320]                   }
[18:00:58.320]                 }
[18:00:58.320]             }
[18:00:58.320]         }))
[18:00:58.320]     }, error = function(ex) {
[18:00:58.320]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.320]                 ...future.rng), started = ...future.startTime, 
[18:00:58.320]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.320]             version = "1.8"), class = "FutureResult")
[18:00:58.320]     }, finally = {
[18:00:58.320]         if (!identical(...future.workdir, getwd())) 
[18:00:58.320]             setwd(...future.workdir)
[18:00:58.320]         {
[18:00:58.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.320]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.320]             }
[18:00:58.320]             base::options(...future.oldOptions)
[18:00:58.320]             if (.Platform$OS.type == "windows") {
[18:00:58.320]                 old_names <- names(...future.oldEnvVars)
[18:00:58.320]                 envs <- base::Sys.getenv()
[18:00:58.320]                 names <- names(envs)
[18:00:58.320]                 common <- intersect(names, old_names)
[18:00:58.320]                 added <- setdiff(names, old_names)
[18:00:58.320]                 removed <- setdiff(old_names, names)
[18:00:58.320]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.320]                   envs[common]]
[18:00:58.320]                 NAMES <- toupper(changed)
[18:00:58.320]                 args <- list()
[18:00:58.320]                 for (kk in seq_along(NAMES)) {
[18:00:58.320]                   name <- changed[[kk]]
[18:00:58.320]                   NAME <- NAMES[[kk]]
[18:00:58.320]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.320]                     next
[18:00:58.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.320]                 }
[18:00:58.320]                 NAMES <- toupper(added)
[18:00:58.320]                 for (kk in seq_along(NAMES)) {
[18:00:58.320]                   name <- added[[kk]]
[18:00:58.320]                   NAME <- NAMES[[kk]]
[18:00:58.320]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.320]                     next
[18:00:58.320]                   args[[name]] <- ""
[18:00:58.320]                 }
[18:00:58.320]                 NAMES <- toupper(removed)
[18:00:58.320]                 for (kk in seq_along(NAMES)) {
[18:00:58.320]                   name <- removed[[kk]]
[18:00:58.320]                   NAME <- NAMES[[kk]]
[18:00:58.320]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.320]                     next
[18:00:58.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.320]                 }
[18:00:58.320]                 if (length(args) > 0) 
[18:00:58.320]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.320]             }
[18:00:58.320]             else {
[18:00:58.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.320]             }
[18:00:58.320]             {
[18:00:58.320]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.320]                   0L) {
[18:00:58.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.320]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.320]                   base::options(opts)
[18:00:58.320]                 }
[18:00:58.320]                 {
[18:00:58.320]                   {
[18:00:58.320]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.320]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.320]                     1423455687L), envir = base::globalenv(), 
[18:00:58.320]                       inherits = FALSE)
[18:00:58.320]                     NULL
[18:00:58.320]                   }
[18:00:58.320]                   options(future.plan = NULL)
[18:00:58.320]                   if (is.na(NA_character_)) 
[18:00:58.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.320]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.320]                     .init = FALSE)
[18:00:58.320]                 }
[18:00:58.320]             }
[18:00:58.320]         }
[18:00:58.320]     })
[18:00:58.320]     if (TRUE) {
[18:00:58.320]         base::sink(type = "output", split = FALSE)
[18:00:58.320]         if (TRUE) {
[18:00:58.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.320]         }
[18:00:58.320]         else {
[18:00:58.320]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.320]         }
[18:00:58.320]         base::close(...future.stdout)
[18:00:58.320]         ...future.stdout <- NULL
[18:00:58.320]     }
[18:00:58.320]     ...future.result$conditions <- ...future.conditions
[18:00:58.320]     ...future.result$finished <- base::Sys.time()
[18:00:58.320]     ...future.result
[18:00:58.320] }
[18:00:58.323] assign_globals() ...
[18:00:58.323] List of 5
[18:00:58.323]  $ ...future.FUN            :function (C, k)  
[18:00:58.323]  $ MoreArgs                 : list()
[18:00:58.323]  $ ...future.elements_ii    :List of 2
[18:00:58.323]   ..$ :List of 5
[18:00:58.323]   .. ..$ : chr "A"
[18:00:58.323]   .. ..$ : chr "B"
[18:00:58.323]   .. ..$ : chr "C"
[18:00:58.323]   .. ..$ : chr "D"
[18:00:58.323]   .. ..$ : chr "E"
[18:00:58.323]   ..$ :List of 5
[18:00:58.323]   .. ..$ : int 5
[18:00:58.323]   .. ..$ : int 4
[18:00:58.323]   .. ..$ : int 3
[18:00:58.323]   .. ..$ : int 2
[18:00:58.323]   .. ..$ : int 1
[18:00:58.323]  $ ...future.seeds_ii       : NULL
[18:00:58.323]  $ ...future.globals.maxSize: NULL
[18:00:58.323]  - attr(*, "where")=List of 5
[18:00:58.323]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.323]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.323]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.323]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.323]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.323]  - attr(*, "resolved")= logi FALSE
[18:00:58.323]  - attr(*, "total_size")= num 4160
[18:00:58.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.323]  - attr(*, "already-done")= logi TRUE
[18:00:58.337] - reassign environment for ‘...future.FUN’
[18:00:58.338] - copied ‘...future.FUN’ to environment
[18:00:58.338] - copied ‘MoreArgs’ to environment
[18:00:58.338] - copied ‘...future.elements_ii’ to environment
[18:00:58.338] - copied ‘...future.seeds_ii’ to environment
[18:00:58.338] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.339] assign_globals() ... done
[18:00:58.339] plan(): Setting new future strategy stack:
[18:00:58.339] List of future strategies:
[18:00:58.339] 1. sequential:
[18:00:58.339]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.339]    - tweaked: FALSE
[18:00:58.339]    - call: NULL
[18:00:58.340] plan(): nbrOfWorkers() = 1
[18:00:58.342] plan(): Setting new future strategy stack:
[18:00:58.342] List of future strategies:
[18:00:58.342] 1. sequential:
[18:00:58.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.342]    - tweaked: FALSE
[18:00:58.342]    - call: plan(strategy)
[18:00:58.343] plan(): nbrOfWorkers() = 1
[18:00:58.344] SequentialFuture started (and completed)
[18:00:58.344] - Launch lazy future ... done
[18:00:58.344] run() for ‘SequentialFuture’ ... done
[18:00:58.344] Created future:
[18:00:58.345] SequentialFuture:
[18:00:58.345] Label: ‘future_.mapply-1’
[18:00:58.345] Expression:
[18:00:58.345] {
[18:00:58.345]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.345]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.345]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.345]         on.exit(options(oopts), add = TRUE)
[18:00:58.345]     }
[18:00:58.345]     {
[18:00:58.345]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.345]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.345]         do.call(mapply, args = args)
[18:00:58.345]     }
[18:00:58.345] }
[18:00:58.345] Lazy evaluation: FALSE
[18:00:58.345] Asynchronous evaluation: FALSE
[18:00:58.345] Local evaluation: TRUE
[18:00:58.345] Environment: R_GlobalEnv
[18:00:58.345] Capture standard output: TRUE
[18:00:58.345] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.345] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.345] Packages: <none>
[18:00:58.345] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.345] Resolved: TRUE
[18:00:58.345] Value: 560 bytes of class ‘list’
[18:00:58.345] Early signaling: FALSE
[18:00:58.345] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.345] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.347] Chunk #1 of 1 ... DONE
[18:00:58.347] Launching 1 futures (chunks) ... DONE
[18:00:58.347] Resolving 1 futures (chunks) ...
[18:00:58.347] resolve() on list ...
[18:00:58.347]  recursive: 0
[18:00:58.348]  length: 1
[18:00:58.348] 
[18:00:58.348] resolved() for ‘SequentialFuture’ ...
[18:00:58.348] - state: ‘finished’
[18:00:58.348] - run: TRUE
[18:00:58.349] - result: ‘FutureResult’
[18:00:58.349] resolved() for ‘SequentialFuture’ ... done
[18:00:58.349] Future #1
[18:00:58.349] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.349] - nx: 1
[18:00:58.350] - relay: TRUE
[18:00:58.350] - stdout: TRUE
[18:00:58.350] - signal: TRUE
[18:00:58.350] - resignal: FALSE
[18:00:58.350] - force: TRUE
[18:00:58.351] - relayed: [n=1] FALSE
[18:00:58.351] - queued futures: [n=1] FALSE
[18:00:58.351]  - until=1
[18:00:58.351]  - relaying element #1
[18:00:58.351] - relayed: [n=1] TRUE
[18:00:58.352] - queued futures: [n=1] TRUE
[18:00:58.352] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.352]  length: 0 (resolved future 1)
[18:00:58.352] Relaying remaining futures
[18:00:58.352] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.353] - nx: 1
[18:00:58.353] - relay: TRUE
[18:00:58.353] - stdout: TRUE
[18:00:58.353] - signal: TRUE
[18:00:58.353] - resignal: FALSE
[18:00:58.353] - force: TRUE
[18:00:58.354] - relayed: [n=1] TRUE
[18:00:58.354] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.354] - relayed: [n=1] TRUE
[18:00:58.354] - queued futures: [n=1] TRUE
[18:00:58.355] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.355] resolve() on list ... DONE
[18:00:58.355]  - Number of value chunks collected: 1
[18:00:58.355] Resolving 1 futures (chunks) ... DONE
[18:00:58.355] Reducing values from 1 chunks ...
[18:00:58.356]  - Number of values collected after concatenation: 5
[18:00:58.356]  - Number of values expected: 5
[18:00:58.356] Reducing values from 1 chunks ... DONE
[18:00:58.356] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[18:00:58.357] future_mapply() ...
[18:00:58.358] Number of chunks: 1
[18:00:58.358] getGlobalsAndPackagesXApply() ...
[18:00:58.358]  - future.globals: TRUE
[18:00:58.358] getGlobalsAndPackages() ...
[18:00:58.358] Searching for globals...
[18:00:58.360] - globals found: [1] ‘FUN’
[18:00:58.360] Searching for globals ... DONE
[18:00:58.361] Resolving globals: FALSE
[18:00:58.361] The total size of the 1 globals is 848 bytes (848 bytes)
[18:00:58.362] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:00:58.362] - globals: [1] ‘FUN’
[18:00:58.362] 
[18:00:58.362] getGlobalsAndPackages() ... DONE
[18:00:58.363]  - globals found/used: [n=1] ‘FUN’
[18:00:58.363]  - needed namespaces: [n=0] 
[18:00:58.363] Finding globals ... DONE
[18:00:58.363] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.364] List of 2
[18:00:58.364]  $ ...future.FUN:function (x)  
[18:00:58.364]  $ MoreArgs     : NULL
[18:00:58.364]  - attr(*, "where")=List of 2
[18:00:58.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.364]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.364]  - attr(*, "resolved")= logi FALSE
[18:00:58.364]  - attr(*, "total_size")= num NA
[18:00:58.372] Packages to be attached in all futures: [n=0] 
[18:00:58.372] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.372] Number of futures (= number of chunks): 1
[18:00:58.373] Launching 1 futures (chunks) ...
[18:00:58.373] Chunk #1 of 1 ...
[18:00:58.373]  - Finding globals in '...' for chunk #1 ...
[18:00:58.373] getGlobalsAndPackages() ...
[18:00:58.374] Searching for globals...
[18:00:58.374] 
[18:00:58.374] Searching for globals ... DONE
[18:00:58.375] - globals: [0] <none>
[18:00:58.375] getGlobalsAndPackages() ... DONE
[18:00:58.375]    + additional globals found: [n=0] 
[18:00:58.375]    + additional namespaces needed: [n=0] 
[18:00:58.375]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.376]  - seeds: <none>
[18:00:58.376]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.376] getGlobalsAndPackages() ...
[18:00:58.376] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.376] Resolving globals: FALSE
[18:00:58.377] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[18:00:58.378] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.378] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.379] 
[18:00:58.379] getGlobalsAndPackages() ... DONE
[18:00:58.379] run() for ‘Future’ ...
[18:00:58.380] - state: ‘created’
[18:00:58.380] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.381]   - Field: ‘label’
[18:00:58.381]   - Field: ‘local’
[18:00:58.381]   - Field: ‘owner’
[18:00:58.381]   - Field: ‘envir’
[18:00:58.382]   - Field: ‘packages’
[18:00:58.382]   - Field: ‘gc’
[18:00:58.382]   - Field: ‘conditions’
[18:00:58.382]   - Field: ‘expr’
[18:00:58.382]   - Field: ‘uuid’
[18:00:58.383]   - Field: ‘seed’
[18:00:58.383]   - Field: ‘version’
[18:00:58.383]   - Field: ‘result’
[18:00:58.383]   - Field: ‘asynchronous’
[18:00:58.383]   - Field: ‘calls’
[18:00:58.384]   - Field: ‘globals’
[18:00:58.384]   - Field: ‘stdout’
[18:00:58.384]   - Field: ‘earlySignal’
[18:00:58.384]   - Field: ‘lazy’
[18:00:58.384]   - Field: ‘state’
[18:00:58.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.385] - Launch lazy future ...
[18:00:58.385] Packages needed by the future expression (n = 0): <none>
[18:00:58.385] Packages needed by future strategies (n = 0): <none>
[18:00:58.386] {
[18:00:58.386]     {
[18:00:58.386]         {
[18:00:58.386]             ...future.startTime <- base::Sys.time()
[18:00:58.386]             {
[18:00:58.386]                 {
[18:00:58.386]                   {
[18:00:58.386]                     base::local({
[18:00:58.386]                       has_future <- base::requireNamespace("future", 
[18:00:58.386]                         quietly = TRUE)
[18:00:58.386]                       if (has_future) {
[18:00:58.386]                         ns <- base::getNamespace("future")
[18:00:58.386]                         version <- ns[[".package"]][["version"]]
[18:00:58.386]                         if (is.null(version)) 
[18:00:58.386]                           version <- utils::packageVersion("future")
[18:00:58.386]                       }
[18:00:58.386]                       else {
[18:00:58.386]                         version <- NULL
[18:00:58.386]                       }
[18:00:58.386]                       if (!has_future || version < "1.8.0") {
[18:00:58.386]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.386]                           "", base::R.version$version.string), 
[18:00:58.386]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.386]                             "release", "version")], collapse = " "), 
[18:00:58.386]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.386]                           info)
[18:00:58.386]                         info <- base::paste(info, collapse = "; ")
[18:00:58.386]                         if (!has_future) {
[18:00:58.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.386]                             info)
[18:00:58.386]                         }
[18:00:58.386]                         else {
[18:00:58.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.386]                             info, version)
[18:00:58.386]                         }
[18:00:58.386]                         base::stop(msg)
[18:00:58.386]                       }
[18:00:58.386]                     })
[18:00:58.386]                   }
[18:00:58.386]                   ...future.strategy.old <- future::plan("list")
[18:00:58.386]                   options(future.plan = NULL)
[18:00:58.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.386]                 }
[18:00:58.386]                 ...future.workdir <- getwd()
[18:00:58.386]             }
[18:00:58.386]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.386]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.386]         }
[18:00:58.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.386]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.386]             base::names(...future.oldOptions))
[18:00:58.386]     }
[18:00:58.386]     if (FALSE) {
[18:00:58.386]     }
[18:00:58.386]     else {
[18:00:58.386]         if (TRUE) {
[18:00:58.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.386]                 open = "w")
[18:00:58.386]         }
[18:00:58.386]         else {
[18:00:58.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.386]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.386]         }
[18:00:58.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.386]             base::sink(type = "output", split = FALSE)
[18:00:58.386]             base::close(...future.stdout)
[18:00:58.386]         }, add = TRUE)
[18:00:58.386]     }
[18:00:58.386]     ...future.frame <- base::sys.nframe()
[18:00:58.386]     ...future.conditions <- base::list()
[18:00:58.386]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.386]     if (FALSE) {
[18:00:58.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.386]     }
[18:00:58.386]     ...future.result <- base::tryCatch({
[18:00:58.386]         base::withCallingHandlers({
[18:00:58.386]             ...future.value <- base::withVisible(base::local({
[18:00:58.386]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.386]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.386]                   ...future.globals.maxSize)) {
[18:00:58.386]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.386]                   on.exit(options(oopts), add = TRUE)
[18:00:58.386]                 }
[18:00:58.386]                 {
[18:00:58.386]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.386]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.386]                     USE.NAMES = FALSE)
[18:00:58.386]                   do.call(mapply, args = args)
[18:00:58.386]                 }
[18:00:58.386]             }))
[18:00:58.386]             future::FutureResult(value = ...future.value$value, 
[18:00:58.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.386]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.386]                     ...future.globalenv.names))
[18:00:58.386]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.386]         }, condition = base::local({
[18:00:58.386]             c <- base::c
[18:00:58.386]             inherits <- base::inherits
[18:00:58.386]             invokeRestart <- base::invokeRestart
[18:00:58.386]             length <- base::length
[18:00:58.386]             list <- base::list
[18:00:58.386]             seq.int <- base::seq.int
[18:00:58.386]             signalCondition <- base::signalCondition
[18:00:58.386]             sys.calls <- base::sys.calls
[18:00:58.386]             `[[` <- base::`[[`
[18:00:58.386]             `+` <- base::`+`
[18:00:58.386]             `<<-` <- base::`<<-`
[18:00:58.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.386]                   3L)]
[18:00:58.386]             }
[18:00:58.386]             function(cond) {
[18:00:58.386]                 is_error <- inherits(cond, "error")
[18:00:58.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.386]                   NULL)
[18:00:58.386]                 if (is_error) {
[18:00:58.386]                   sessionInformation <- function() {
[18:00:58.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.386]                       search = base::search(), system = base::Sys.info())
[18:00:58.386]                   }
[18:00:58.386]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.386]                     cond$call), session = sessionInformation(), 
[18:00:58.386]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.386]                   signalCondition(cond)
[18:00:58.386]                 }
[18:00:58.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.386]                 "immediateCondition"))) {
[18:00:58.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.386]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.386]                   if (TRUE && !signal) {
[18:00:58.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.386]                     {
[18:00:58.386]                       inherits <- base::inherits
[18:00:58.386]                       invokeRestart <- base::invokeRestart
[18:00:58.386]                       is.null <- base::is.null
[18:00:58.386]                       muffled <- FALSE
[18:00:58.386]                       if (inherits(cond, "message")) {
[18:00:58.386]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.386]                         if (muffled) 
[18:00:58.386]                           invokeRestart("muffleMessage")
[18:00:58.386]                       }
[18:00:58.386]                       else if (inherits(cond, "warning")) {
[18:00:58.386]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.386]                         if (muffled) 
[18:00:58.386]                           invokeRestart("muffleWarning")
[18:00:58.386]                       }
[18:00:58.386]                       else if (inherits(cond, "condition")) {
[18:00:58.386]                         if (!is.null(pattern)) {
[18:00:58.386]                           computeRestarts <- base::computeRestarts
[18:00:58.386]                           grepl <- base::grepl
[18:00:58.386]                           restarts <- computeRestarts(cond)
[18:00:58.386]                           for (restart in restarts) {
[18:00:58.386]                             name <- restart$name
[18:00:58.386]                             if (is.null(name)) 
[18:00:58.386]                               next
[18:00:58.386]                             if (!grepl(pattern, name)) 
[18:00:58.386]                               next
[18:00:58.386]                             invokeRestart(restart)
[18:00:58.386]                             muffled <- TRUE
[18:00:58.386]                             break
[18:00:58.386]                           }
[18:00:58.386]                         }
[18:00:58.386]                       }
[18:00:58.386]                       invisible(muffled)
[18:00:58.386]                     }
[18:00:58.386]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.386]                   }
[18:00:58.386]                 }
[18:00:58.386]                 else {
[18:00:58.386]                   if (TRUE) {
[18:00:58.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.386]                     {
[18:00:58.386]                       inherits <- base::inherits
[18:00:58.386]                       invokeRestart <- base::invokeRestart
[18:00:58.386]                       is.null <- base::is.null
[18:00:58.386]                       muffled <- FALSE
[18:00:58.386]                       if (inherits(cond, "message")) {
[18:00:58.386]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.386]                         if (muffled) 
[18:00:58.386]                           invokeRestart("muffleMessage")
[18:00:58.386]                       }
[18:00:58.386]                       else if (inherits(cond, "warning")) {
[18:00:58.386]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.386]                         if (muffled) 
[18:00:58.386]                           invokeRestart("muffleWarning")
[18:00:58.386]                       }
[18:00:58.386]                       else if (inherits(cond, "condition")) {
[18:00:58.386]                         if (!is.null(pattern)) {
[18:00:58.386]                           computeRestarts <- base::computeRestarts
[18:00:58.386]                           grepl <- base::grepl
[18:00:58.386]                           restarts <- computeRestarts(cond)
[18:00:58.386]                           for (restart in restarts) {
[18:00:58.386]                             name <- restart$name
[18:00:58.386]                             if (is.null(name)) 
[18:00:58.386]                               next
[18:00:58.386]                             if (!grepl(pattern, name)) 
[18:00:58.386]                               next
[18:00:58.386]                             invokeRestart(restart)
[18:00:58.386]                             muffled <- TRUE
[18:00:58.386]                             break
[18:00:58.386]                           }
[18:00:58.386]                         }
[18:00:58.386]                       }
[18:00:58.386]                       invisible(muffled)
[18:00:58.386]                     }
[18:00:58.386]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.386]                   }
[18:00:58.386]                 }
[18:00:58.386]             }
[18:00:58.386]         }))
[18:00:58.386]     }, error = function(ex) {
[18:00:58.386]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.386]                 ...future.rng), started = ...future.startTime, 
[18:00:58.386]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.386]             version = "1.8"), class = "FutureResult")
[18:00:58.386]     }, finally = {
[18:00:58.386]         if (!identical(...future.workdir, getwd())) 
[18:00:58.386]             setwd(...future.workdir)
[18:00:58.386]         {
[18:00:58.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.386]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.386]             }
[18:00:58.386]             base::options(...future.oldOptions)
[18:00:58.386]             if (.Platform$OS.type == "windows") {
[18:00:58.386]                 old_names <- names(...future.oldEnvVars)
[18:00:58.386]                 envs <- base::Sys.getenv()
[18:00:58.386]                 names <- names(envs)
[18:00:58.386]                 common <- intersect(names, old_names)
[18:00:58.386]                 added <- setdiff(names, old_names)
[18:00:58.386]                 removed <- setdiff(old_names, names)
[18:00:58.386]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.386]                   envs[common]]
[18:00:58.386]                 NAMES <- toupper(changed)
[18:00:58.386]                 args <- list()
[18:00:58.386]                 for (kk in seq_along(NAMES)) {
[18:00:58.386]                   name <- changed[[kk]]
[18:00:58.386]                   NAME <- NAMES[[kk]]
[18:00:58.386]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.386]                     next
[18:00:58.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.386]                 }
[18:00:58.386]                 NAMES <- toupper(added)
[18:00:58.386]                 for (kk in seq_along(NAMES)) {
[18:00:58.386]                   name <- added[[kk]]
[18:00:58.386]                   NAME <- NAMES[[kk]]
[18:00:58.386]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.386]                     next
[18:00:58.386]                   args[[name]] <- ""
[18:00:58.386]                 }
[18:00:58.386]                 NAMES <- toupper(removed)
[18:00:58.386]                 for (kk in seq_along(NAMES)) {
[18:00:58.386]                   name <- removed[[kk]]
[18:00:58.386]                   NAME <- NAMES[[kk]]
[18:00:58.386]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.386]                     next
[18:00:58.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.386]                 }
[18:00:58.386]                 if (length(args) > 0) 
[18:00:58.386]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.386]             }
[18:00:58.386]             else {
[18:00:58.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.386]             }
[18:00:58.386]             {
[18:00:58.386]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.386]                   0L) {
[18:00:58.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.386]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.386]                   base::options(opts)
[18:00:58.386]                 }
[18:00:58.386]                 {
[18:00:58.386]                   {
[18:00:58.386]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.386]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.386]                     1423455687L), envir = base::globalenv(), 
[18:00:58.386]                       inherits = FALSE)
[18:00:58.386]                     NULL
[18:00:58.386]                   }
[18:00:58.386]                   options(future.plan = NULL)
[18:00:58.386]                   if (is.na(NA_character_)) 
[18:00:58.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.386]                     .init = FALSE)
[18:00:58.386]                 }
[18:00:58.386]             }
[18:00:58.386]         }
[18:00:58.386]     })
[18:00:58.386]     if (TRUE) {
[18:00:58.386]         base::sink(type = "output", split = FALSE)
[18:00:58.386]         if (TRUE) {
[18:00:58.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.386]         }
[18:00:58.386]         else {
[18:00:58.386]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.386]         }
[18:00:58.386]         base::close(...future.stdout)
[18:00:58.386]         ...future.stdout <- NULL
[18:00:58.386]     }
[18:00:58.386]     ...future.result$conditions <- ...future.conditions
[18:00:58.386]     ...future.result$finished <- base::Sys.time()
[18:00:58.386]     ...future.result
[18:00:58.386] }
[18:00:58.389] assign_globals() ...
[18:00:58.390] List of 5
[18:00:58.390]  $ ...future.FUN            :function (x)  
[18:00:58.390]  $ MoreArgs                 : NULL
[18:00:58.390]  $ ...future.elements_ii    :List of 1
[18:00:58.390]   ..$ :List of 1
[18:00:58.390]   .. ..$ : Date[1:1], format: "2018-06-01"
[18:00:58.390]  $ ...future.seeds_ii       : NULL
[18:00:58.390]  $ ...future.globals.maxSize: NULL
[18:00:58.390]  - attr(*, "where")=List of 5
[18:00:58.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.390]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.390]  - attr(*, "resolved")= logi FALSE
[18:00:58.390]  - attr(*, "total_size")= num 1128
[18:00:58.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.390]  - attr(*, "already-done")= logi TRUE
[18:00:58.399] - copied ‘...future.FUN’ to environment
[18:00:58.399] - copied ‘MoreArgs’ to environment
[18:00:58.399] - copied ‘...future.elements_ii’ to environment
[18:00:58.400] - copied ‘...future.seeds_ii’ to environment
[18:00:58.400] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.400] assign_globals() ... done
[18:00:58.401] plan(): Setting new future strategy stack:
[18:00:58.401] List of future strategies:
[18:00:58.401] 1. sequential:
[18:00:58.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.401]    - tweaked: FALSE
[18:00:58.401]    - call: NULL
[18:00:58.402] plan(): nbrOfWorkers() = 1
[18:00:58.403] plan(): Setting new future strategy stack:
[18:00:58.403] List of future strategies:
[18:00:58.403] 1. sequential:
[18:00:58.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.403]    - tweaked: FALSE
[18:00:58.403]    - call: plan(strategy)
[18:00:58.404] plan(): nbrOfWorkers() = 1
[18:00:58.404] SequentialFuture started (and completed)
[18:00:58.405] - Launch lazy future ... done
[18:00:58.405] run() for ‘SequentialFuture’ ... done
[18:00:58.405] Created future:
[18:00:58.405] SequentialFuture:
[18:00:58.405] Label: ‘future_mapply-1’
[18:00:58.405] Expression:
[18:00:58.405] {
[18:00:58.405]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.405]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.405]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.405]         on.exit(options(oopts), add = TRUE)
[18:00:58.405]     }
[18:00:58.405]     {
[18:00:58.405]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.405]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.405]         do.call(mapply, args = args)
[18:00:58.405]     }
[18:00:58.405] }
[18:00:58.405] Lazy evaluation: FALSE
[18:00:58.405] Asynchronous evaluation: FALSE
[18:00:58.405] Local evaluation: TRUE
[18:00:58.405] Environment: R_GlobalEnv
[18:00:58.405] Capture standard output: TRUE
[18:00:58.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.405] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.405] Packages: <none>
[18:00:58.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.405] Resolved: TRUE
[18:00:58.405] Value: 280 bytes of class ‘list’
[18:00:58.405] Early signaling: FALSE
[18:00:58.405] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.405] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.407] Chunk #1 of 1 ... DONE
[18:00:58.407] Launching 1 futures (chunks) ... DONE
[18:00:58.407] Resolving 1 futures (chunks) ...
[18:00:58.408] resolve() on list ...
[18:00:58.408]  recursive: 0
[18:00:58.408]  length: 1
[18:00:58.408] 
[18:00:58.409] resolved() for ‘SequentialFuture’ ...
[18:00:58.409] - state: ‘finished’
[18:00:58.409] - run: TRUE
[18:00:58.409] - result: ‘FutureResult’
[18:00:58.410] resolved() for ‘SequentialFuture’ ... done
[18:00:58.410] Future #1
[18:00:58.410] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.410] - nx: 1
[18:00:58.411] - relay: TRUE
[18:00:58.411] - stdout: TRUE
[18:00:58.411] - signal: TRUE
[18:00:58.411] - resignal: FALSE
[18:00:58.411] - force: TRUE
[18:00:58.412] - relayed: [n=1] FALSE
[18:00:58.412] - queued futures: [n=1] FALSE
[18:00:58.412]  - until=1
[18:00:58.412]  - relaying element #1
[18:00:58.413] - relayed: [n=1] TRUE
[18:00:58.413] - queued futures: [n=1] TRUE
[18:00:58.413] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.413]  length: 0 (resolved future 1)
[18:00:58.413] Relaying remaining futures
[18:00:58.414] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.414] - nx: 1
[18:00:58.414] - relay: TRUE
[18:00:58.414] - stdout: TRUE
[18:00:58.414] - signal: TRUE
[18:00:58.414] - resignal: FALSE
[18:00:58.415] - force: TRUE
[18:00:58.415] - relayed: [n=1] TRUE
[18:00:58.415] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.415] - relayed: [n=1] TRUE
[18:00:58.416] - queued futures: [n=1] TRUE
[18:00:58.416] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.416] resolve() on list ... DONE
[18:00:58.416]  - Number of value chunks collected: 1
[18:00:58.416] Resolving 1 futures (chunks) ... DONE
[18:00:58.417] Reducing values from 1 chunks ...
[18:00:58.417]  - Number of values collected after concatenation: 1
[18:00:58.417]  - Number of values expected: 1
[18:00:58.417] Reducing values from 1 chunks ... DONE
[18:00:58.417] future_mapply() ... DONE
[18:00:58.418] future_mapply() ...
[18:00:58.418] Number of chunks: 1
[18:00:58.418] getGlobalsAndPackagesXApply() ...
[18:00:58.419]  - future.globals: TRUE
[18:00:58.419] getGlobalsAndPackages() ...
[18:00:58.419] Searching for globals...
[18:00:58.423] - globals found: [1] ‘FUN’
[18:00:58.424] Searching for globals ... DONE
[18:00:58.424] Resolving globals: FALSE
[18:00:58.425] The total size of the 1 globals is 848 bytes (848 bytes)
[18:00:58.426] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:00:58.426] - globals: [1] ‘FUN’
[18:00:58.426] 
[18:00:58.426] getGlobalsAndPackages() ... DONE
[18:00:58.427]  - globals found/used: [n=1] ‘FUN’
[18:00:58.427]  - needed namespaces: [n=0] 
[18:00:58.427] Finding globals ... DONE
[18:00:58.428] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.428] List of 2
[18:00:58.428]  $ ...future.FUN:function (x)  
[18:00:58.428]  $ MoreArgs     : list()
[18:00:58.428]  - attr(*, "where")=List of 2
[18:00:58.428]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.428]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.428]  - attr(*, "resolved")= logi FALSE
[18:00:58.428]  - attr(*, "total_size")= num NA
[18:00:58.433] Packages to be attached in all futures: [n=0] 
[18:00:58.433] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.434] Number of futures (= number of chunks): 1
[18:00:58.434] Launching 1 futures (chunks) ...
[18:00:58.434] Chunk #1 of 1 ...
[18:00:58.435]  - Finding globals in '...' for chunk #1 ...
[18:00:58.435] getGlobalsAndPackages() ...
[18:00:58.435] Searching for globals...
[18:00:58.436] 
[18:00:58.436] Searching for globals ... DONE
[18:00:58.436] - globals: [0] <none>
[18:00:58.436] getGlobalsAndPackages() ... DONE
[18:00:58.437]    + additional globals found: [n=0] 
[18:00:58.437]    + additional namespaces needed: [n=0] 
[18:00:58.437]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.437]  - seeds: <none>
[18:00:58.437]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.438] getGlobalsAndPackages() ...
[18:00:58.438] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.438] Resolving globals: FALSE
[18:00:58.439] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[18:00:58.440] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:00:58.440] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.441] 
[18:00:58.441] getGlobalsAndPackages() ... DONE
[18:00:58.441] run() for ‘Future’ ...
[18:00:58.442] - state: ‘created’
[18:00:58.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.443] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.443]   - Field: ‘label’
[18:00:58.443]   - Field: ‘local’
[18:00:58.444]   - Field: ‘owner’
[18:00:58.444]   - Field: ‘envir’
[18:00:58.444]   - Field: ‘packages’
[18:00:58.444]   - Field: ‘gc’
[18:00:58.444]   - Field: ‘conditions’
[18:00:58.445]   - Field: ‘expr’
[18:00:58.445]   - Field: ‘uuid’
[18:00:58.445]   - Field: ‘seed’
[18:00:58.445]   - Field: ‘version’
[18:00:58.445]   - Field: ‘result’
[18:00:58.446]   - Field: ‘asynchronous’
[18:00:58.446]   - Field: ‘calls’
[18:00:58.446]   - Field: ‘globals’
[18:00:58.446]   - Field: ‘stdout’
[18:00:58.446]   - Field: ‘earlySignal’
[18:00:58.447]   - Field: ‘lazy’
[18:00:58.447]   - Field: ‘state’
[18:00:58.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.447] - Launch lazy future ...
[18:00:58.448] Packages needed by the future expression (n = 0): <none>
[18:00:58.448] Packages needed by future strategies (n = 0): <none>
[18:00:58.449] {
[18:00:58.449]     {
[18:00:58.449]         {
[18:00:58.449]             ...future.startTime <- base::Sys.time()
[18:00:58.449]             {
[18:00:58.449]                 {
[18:00:58.449]                   {
[18:00:58.449]                     base::local({
[18:00:58.449]                       has_future <- base::requireNamespace("future", 
[18:00:58.449]                         quietly = TRUE)
[18:00:58.449]                       if (has_future) {
[18:00:58.449]                         ns <- base::getNamespace("future")
[18:00:58.449]                         version <- ns[[".package"]][["version"]]
[18:00:58.449]                         if (is.null(version)) 
[18:00:58.449]                           version <- utils::packageVersion("future")
[18:00:58.449]                       }
[18:00:58.449]                       else {
[18:00:58.449]                         version <- NULL
[18:00:58.449]                       }
[18:00:58.449]                       if (!has_future || version < "1.8.0") {
[18:00:58.449]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.449]                           "", base::R.version$version.string), 
[18:00:58.449]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.449]                             "release", "version")], collapse = " "), 
[18:00:58.449]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.449]                           info)
[18:00:58.449]                         info <- base::paste(info, collapse = "; ")
[18:00:58.449]                         if (!has_future) {
[18:00:58.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.449]                             info)
[18:00:58.449]                         }
[18:00:58.449]                         else {
[18:00:58.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.449]                             info, version)
[18:00:58.449]                         }
[18:00:58.449]                         base::stop(msg)
[18:00:58.449]                       }
[18:00:58.449]                     })
[18:00:58.449]                   }
[18:00:58.449]                   ...future.strategy.old <- future::plan("list")
[18:00:58.449]                   options(future.plan = NULL)
[18:00:58.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.449]                 }
[18:00:58.449]                 ...future.workdir <- getwd()
[18:00:58.449]             }
[18:00:58.449]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.449]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.449]         }
[18:00:58.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.449]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.449]             base::names(...future.oldOptions))
[18:00:58.449]     }
[18:00:58.449]     if (FALSE) {
[18:00:58.449]     }
[18:00:58.449]     else {
[18:00:58.449]         if (TRUE) {
[18:00:58.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.449]                 open = "w")
[18:00:58.449]         }
[18:00:58.449]         else {
[18:00:58.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.449]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.449]         }
[18:00:58.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.449]             base::sink(type = "output", split = FALSE)
[18:00:58.449]             base::close(...future.stdout)
[18:00:58.449]         }, add = TRUE)
[18:00:58.449]     }
[18:00:58.449]     ...future.frame <- base::sys.nframe()
[18:00:58.449]     ...future.conditions <- base::list()
[18:00:58.449]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.449]     if (FALSE) {
[18:00:58.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.449]     }
[18:00:58.449]     ...future.result <- base::tryCatch({
[18:00:58.449]         base::withCallingHandlers({
[18:00:58.449]             ...future.value <- base::withVisible(base::local({
[18:00:58.449]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.449]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.449]                   ...future.globals.maxSize)) {
[18:00:58.449]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.449]                   on.exit(options(oopts), add = TRUE)
[18:00:58.449]                 }
[18:00:58.449]                 {
[18:00:58.449]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.449]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.449]                     USE.NAMES = FALSE)
[18:00:58.449]                   do.call(mapply, args = args)
[18:00:58.449]                 }
[18:00:58.449]             }))
[18:00:58.449]             future::FutureResult(value = ...future.value$value, 
[18:00:58.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.449]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.449]                     ...future.globalenv.names))
[18:00:58.449]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.449]         }, condition = base::local({
[18:00:58.449]             c <- base::c
[18:00:58.449]             inherits <- base::inherits
[18:00:58.449]             invokeRestart <- base::invokeRestart
[18:00:58.449]             length <- base::length
[18:00:58.449]             list <- base::list
[18:00:58.449]             seq.int <- base::seq.int
[18:00:58.449]             signalCondition <- base::signalCondition
[18:00:58.449]             sys.calls <- base::sys.calls
[18:00:58.449]             `[[` <- base::`[[`
[18:00:58.449]             `+` <- base::`+`
[18:00:58.449]             `<<-` <- base::`<<-`
[18:00:58.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.449]                   3L)]
[18:00:58.449]             }
[18:00:58.449]             function(cond) {
[18:00:58.449]                 is_error <- inherits(cond, "error")
[18:00:58.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.449]                   NULL)
[18:00:58.449]                 if (is_error) {
[18:00:58.449]                   sessionInformation <- function() {
[18:00:58.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.449]                       search = base::search(), system = base::Sys.info())
[18:00:58.449]                   }
[18:00:58.449]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.449]                     cond$call), session = sessionInformation(), 
[18:00:58.449]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.449]                   signalCondition(cond)
[18:00:58.449]                 }
[18:00:58.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.449]                 "immediateCondition"))) {
[18:00:58.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.449]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.449]                   if (TRUE && !signal) {
[18:00:58.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.449]                     {
[18:00:58.449]                       inherits <- base::inherits
[18:00:58.449]                       invokeRestart <- base::invokeRestart
[18:00:58.449]                       is.null <- base::is.null
[18:00:58.449]                       muffled <- FALSE
[18:00:58.449]                       if (inherits(cond, "message")) {
[18:00:58.449]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.449]                         if (muffled) 
[18:00:58.449]                           invokeRestart("muffleMessage")
[18:00:58.449]                       }
[18:00:58.449]                       else if (inherits(cond, "warning")) {
[18:00:58.449]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.449]                         if (muffled) 
[18:00:58.449]                           invokeRestart("muffleWarning")
[18:00:58.449]                       }
[18:00:58.449]                       else if (inherits(cond, "condition")) {
[18:00:58.449]                         if (!is.null(pattern)) {
[18:00:58.449]                           computeRestarts <- base::computeRestarts
[18:00:58.449]                           grepl <- base::grepl
[18:00:58.449]                           restarts <- computeRestarts(cond)
[18:00:58.449]                           for (restart in restarts) {
[18:00:58.449]                             name <- restart$name
[18:00:58.449]                             if (is.null(name)) 
[18:00:58.449]                               next
[18:00:58.449]                             if (!grepl(pattern, name)) 
[18:00:58.449]                               next
[18:00:58.449]                             invokeRestart(restart)
[18:00:58.449]                             muffled <- TRUE
[18:00:58.449]                             break
[18:00:58.449]                           }
[18:00:58.449]                         }
[18:00:58.449]                       }
[18:00:58.449]                       invisible(muffled)
[18:00:58.449]                     }
[18:00:58.449]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.449]                   }
[18:00:58.449]                 }
[18:00:58.449]                 else {
[18:00:58.449]                   if (TRUE) {
[18:00:58.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.449]                     {
[18:00:58.449]                       inherits <- base::inherits
[18:00:58.449]                       invokeRestart <- base::invokeRestart
[18:00:58.449]                       is.null <- base::is.null
[18:00:58.449]                       muffled <- FALSE
[18:00:58.449]                       if (inherits(cond, "message")) {
[18:00:58.449]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.449]                         if (muffled) 
[18:00:58.449]                           invokeRestart("muffleMessage")
[18:00:58.449]                       }
[18:00:58.449]                       else if (inherits(cond, "warning")) {
[18:00:58.449]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.449]                         if (muffled) 
[18:00:58.449]                           invokeRestart("muffleWarning")
[18:00:58.449]                       }
[18:00:58.449]                       else if (inherits(cond, "condition")) {
[18:00:58.449]                         if (!is.null(pattern)) {
[18:00:58.449]                           computeRestarts <- base::computeRestarts
[18:00:58.449]                           grepl <- base::grepl
[18:00:58.449]                           restarts <- computeRestarts(cond)
[18:00:58.449]                           for (restart in restarts) {
[18:00:58.449]                             name <- restart$name
[18:00:58.449]                             if (is.null(name)) 
[18:00:58.449]                               next
[18:00:58.449]                             if (!grepl(pattern, name)) 
[18:00:58.449]                               next
[18:00:58.449]                             invokeRestart(restart)
[18:00:58.449]                             muffled <- TRUE
[18:00:58.449]                             break
[18:00:58.449]                           }
[18:00:58.449]                         }
[18:00:58.449]                       }
[18:00:58.449]                       invisible(muffled)
[18:00:58.449]                     }
[18:00:58.449]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.449]                   }
[18:00:58.449]                 }
[18:00:58.449]             }
[18:00:58.449]         }))
[18:00:58.449]     }, error = function(ex) {
[18:00:58.449]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.449]                 ...future.rng), started = ...future.startTime, 
[18:00:58.449]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.449]             version = "1.8"), class = "FutureResult")
[18:00:58.449]     }, finally = {
[18:00:58.449]         if (!identical(...future.workdir, getwd())) 
[18:00:58.449]             setwd(...future.workdir)
[18:00:58.449]         {
[18:00:58.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.449]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.449]             }
[18:00:58.449]             base::options(...future.oldOptions)
[18:00:58.449]             if (.Platform$OS.type == "windows") {
[18:00:58.449]                 old_names <- names(...future.oldEnvVars)
[18:00:58.449]                 envs <- base::Sys.getenv()
[18:00:58.449]                 names <- names(envs)
[18:00:58.449]                 common <- intersect(names, old_names)
[18:00:58.449]                 added <- setdiff(names, old_names)
[18:00:58.449]                 removed <- setdiff(old_names, names)
[18:00:58.449]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.449]                   envs[common]]
[18:00:58.449]                 NAMES <- toupper(changed)
[18:00:58.449]                 args <- list()
[18:00:58.449]                 for (kk in seq_along(NAMES)) {
[18:00:58.449]                   name <- changed[[kk]]
[18:00:58.449]                   NAME <- NAMES[[kk]]
[18:00:58.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.449]                     next
[18:00:58.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.449]                 }
[18:00:58.449]                 NAMES <- toupper(added)
[18:00:58.449]                 for (kk in seq_along(NAMES)) {
[18:00:58.449]                   name <- added[[kk]]
[18:00:58.449]                   NAME <- NAMES[[kk]]
[18:00:58.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.449]                     next
[18:00:58.449]                   args[[name]] <- ""
[18:00:58.449]                 }
[18:00:58.449]                 NAMES <- toupper(removed)
[18:00:58.449]                 for (kk in seq_along(NAMES)) {
[18:00:58.449]                   name <- removed[[kk]]
[18:00:58.449]                   NAME <- NAMES[[kk]]
[18:00:58.449]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.449]                     next
[18:00:58.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.449]                 }
[18:00:58.449]                 if (length(args) > 0) 
[18:00:58.449]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.449]             }
[18:00:58.449]             else {
[18:00:58.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.449]             }
[18:00:58.449]             {
[18:00:58.449]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.449]                   0L) {
[18:00:58.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.449]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.449]                   base::options(opts)
[18:00:58.449]                 }
[18:00:58.449]                 {
[18:00:58.449]                   {
[18:00:58.449]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.449]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.449]                     1423455687L), envir = base::globalenv(), 
[18:00:58.449]                       inherits = FALSE)
[18:00:58.449]                     NULL
[18:00:58.449]                   }
[18:00:58.449]                   options(future.plan = NULL)
[18:00:58.449]                   if (is.na(NA_character_)) 
[18:00:58.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.449]                     .init = FALSE)
[18:00:58.449]                 }
[18:00:58.449]             }
[18:00:58.449]         }
[18:00:58.449]     })
[18:00:58.449]     if (TRUE) {
[18:00:58.449]         base::sink(type = "output", split = FALSE)
[18:00:58.449]         if (TRUE) {
[18:00:58.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.449]         }
[18:00:58.449]         else {
[18:00:58.449]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.449]         }
[18:00:58.449]         base::close(...future.stdout)
[18:00:58.449]         ...future.stdout <- NULL
[18:00:58.449]     }
[18:00:58.449]     ...future.result$conditions <- ...future.conditions
[18:00:58.449]     ...future.result$finished <- base::Sys.time()
[18:00:58.449]     ...future.result
[18:00:58.449] }
[18:00:58.452] assign_globals() ...
[18:00:58.453] List of 5
[18:00:58.453]  $ ...future.FUN            :function (x)  
[18:00:58.453]  $ MoreArgs                 : list()
[18:00:58.453]  $ ...future.elements_ii    :List of 1
[18:00:58.453]   ..$ :List of 1
[18:00:58.453]   .. ..$ : Date[1:1], format: "2018-06-01"
[18:00:58.453]  $ ...future.seeds_ii       : NULL
[18:00:58.453]  $ ...future.globals.maxSize: NULL
[18:00:58.453]  - attr(*, "where")=List of 5
[18:00:58.453]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.453]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.453]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.453]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.453]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.453]  - attr(*, "resolved")= logi FALSE
[18:00:58.453]  - attr(*, "total_size")= num 1128
[18:00:58.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.453]  - attr(*, "already-done")= logi TRUE
[18:00:58.463] - copied ‘...future.FUN’ to environment
[18:00:58.463] - copied ‘MoreArgs’ to environment
[18:00:58.463] - copied ‘...future.elements_ii’ to environment
[18:00:58.463] - copied ‘...future.seeds_ii’ to environment
[18:00:58.464] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.464] assign_globals() ... done
[18:00:58.464] plan(): Setting new future strategy stack:
[18:00:58.465] List of future strategies:
[18:00:58.465] 1. sequential:
[18:00:58.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.465]    - tweaked: FALSE
[18:00:58.465]    - call: NULL
[18:00:58.466] plan(): nbrOfWorkers() = 1
[18:00:58.468] plan(): Setting new future strategy stack:
[18:00:58.468] List of future strategies:
[18:00:58.468] 1. sequential:
[18:00:58.468]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.468]    - tweaked: FALSE
[18:00:58.468]    - call: plan(strategy)
[18:00:58.469] plan(): nbrOfWorkers() = 1
[18:00:58.469] SequentialFuture started (and completed)
[18:00:58.470] - Launch lazy future ... done
[18:00:58.470] run() for ‘SequentialFuture’ ... done
[18:00:58.470] Created future:
[18:00:58.470] SequentialFuture:
[18:00:58.470] Label: ‘future_.mapply-1’
[18:00:58.470] Expression:
[18:00:58.470] {
[18:00:58.470]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.470]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.470]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.470]         on.exit(options(oopts), add = TRUE)
[18:00:58.470]     }
[18:00:58.470]     {
[18:00:58.470]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.470]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.470]         do.call(mapply, args = args)
[18:00:58.470]     }
[18:00:58.470] }
[18:00:58.470] Lazy evaluation: FALSE
[18:00:58.470] Asynchronous evaluation: FALSE
[18:00:58.470] Local evaluation: TRUE
[18:00:58.470] Environment: R_GlobalEnv
[18:00:58.470] Capture standard output: TRUE
[18:00:58.470] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.470] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.470] Packages: <none>
[18:00:58.470] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.470] Resolved: TRUE
[18:00:58.470] Value: 280 bytes of class ‘list’
[18:00:58.470] Early signaling: FALSE
[18:00:58.470] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.470] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.472] Chunk #1 of 1 ... DONE
[18:00:58.473] Launching 1 futures (chunks) ... DONE
[18:00:58.473] Resolving 1 futures (chunks) ...
[18:00:58.473] resolve() on list ...
[18:00:58.473]  recursive: 0
[18:00:58.474]  length: 1
[18:00:58.474] 
[18:00:58.474] resolved() for ‘SequentialFuture’ ...
[18:00:58.474] - state: ‘finished’
[18:00:58.474] - run: TRUE
[18:00:58.475] - result: ‘FutureResult’
[18:00:58.475] resolved() for ‘SequentialFuture’ ... done
[18:00:58.475] Future #1
[18:00:58.475] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.475] - nx: 1
[18:00:58.476] - relay: TRUE
[18:00:58.476] - stdout: TRUE
[18:00:58.476] - signal: TRUE
[18:00:58.476] - resignal: FALSE
[18:00:58.476] - force: TRUE
[18:00:58.477] - relayed: [n=1] FALSE
[18:00:58.477] - queued futures: [n=1] FALSE
[18:00:58.477]  - until=1
[18:00:58.477]  - relaying element #1
[18:00:58.478] - relayed: [n=1] TRUE
[18:00:58.480] - queued futures: [n=1] TRUE
[18:00:58.481] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.481]  length: 0 (resolved future 1)
[18:00:58.481] Relaying remaining futures
[18:00:58.481] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.482] - nx: 1
[18:00:58.482] - relay: TRUE
[18:00:58.482] - stdout: TRUE
[18:00:58.483] - signal: TRUE
[18:00:58.483] - resignal: FALSE
[18:00:58.483] - force: TRUE
[18:00:58.483] - relayed: [n=1] TRUE
[18:00:58.484] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.484] - relayed: [n=1] TRUE
[18:00:58.484] - queued futures: [n=1] TRUE
[18:00:58.484] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.485] resolve() on list ... DONE
[18:00:58.485]  - Number of value chunks collected: 1
[18:00:58.485] Resolving 1 futures (chunks) ... DONE
[18:00:58.485] Reducing values from 1 chunks ...
[18:00:58.485]  - Number of values collected after concatenation: 1
[18:00:58.486]  - Number of values expected: 1
[18:00:58.486] Reducing values from 1 chunks ... DONE
[18:00:58.486] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[18:00:58.487] future_mapply() ...
[18:00:58.487] Number of chunks: 1
[18:00:58.487] getGlobalsAndPackagesXApply() ...
[18:00:58.488]  - future.globals: TRUE
[18:00:58.488] getGlobalsAndPackages() ...
[18:00:58.488] Searching for globals...
[18:00:58.490] - globals found: [1] ‘FUN’
[18:00:58.490] Searching for globals ... DONE
[18:00:58.491] Resolving globals: FALSE
[18:00:58.491] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:00:58.492] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:00:58.492] - globals: [1] ‘FUN’
[18:00:58.492] 
[18:00:58.493] getGlobalsAndPackages() ... DONE
[18:00:58.493]  - globals found/used: [n=1] ‘FUN’
[18:00:58.493]  - needed namespaces: [n=0] 
[18:00:58.493] Finding globals ... DONE
[18:00:58.494] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.494] List of 2
[18:00:58.494]  $ ...future.FUN:function (x, y)  
[18:00:58.494]  $ MoreArgs     :List of 1
[18:00:58.494]   ..$ y: int [1:2] 3 4
[18:00:58.494]  - attr(*, "where")=List of 2
[18:00:58.494]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.494]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.494]  - attr(*, "resolved")= logi FALSE
[18:00:58.494]  - attr(*, "total_size")= num NA
[18:00:58.500] Packages to be attached in all futures: [n=0] 
[18:00:58.500] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.501] Number of futures (= number of chunks): 1
[18:00:58.501] Launching 1 futures (chunks) ...
[18:00:58.501] Chunk #1 of 1 ...
[18:00:58.502]  - Finding globals in '...' for chunk #1 ...
[18:00:58.502] getGlobalsAndPackages() ...
[18:00:58.502] Searching for globals...
[18:00:58.503] 
[18:00:58.503] Searching for globals ... DONE
[18:00:58.503] - globals: [0] <none>
[18:00:58.503] getGlobalsAndPackages() ... DONE
[18:00:58.503]    + additional globals found: [n=0] 
[18:00:58.504]    + additional namespaces needed: [n=0] 
[18:00:58.504]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.504]  - seeds: <none>
[18:00:58.504]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.504] getGlobalsAndPackages() ...
[18:00:58.505] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.505] Resolving globals: FALSE
[18:00:58.506] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[18:00:58.507] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:00:58.507] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.508] 
[18:00:58.508] getGlobalsAndPackages() ... DONE
[18:00:58.508] run() for ‘Future’ ...
[18:00:58.509] - state: ‘created’
[18:00:58.509] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.510] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.510]   - Field: ‘label’
[18:00:58.510]   - Field: ‘local’
[18:00:58.511]   - Field: ‘owner’
[18:00:58.511]   - Field: ‘envir’
[18:00:58.511]   - Field: ‘packages’
[18:00:58.511]   - Field: ‘gc’
[18:00:58.511]   - Field: ‘conditions’
[18:00:58.512]   - Field: ‘expr’
[18:00:58.512]   - Field: ‘uuid’
[18:00:58.512]   - Field: ‘seed’
[18:00:58.512]   - Field: ‘version’
[18:00:58.512]   - Field: ‘result’
[18:00:58.513]   - Field: ‘asynchronous’
[18:00:58.513]   - Field: ‘calls’
[18:00:58.513]   - Field: ‘globals’
[18:00:58.513]   - Field: ‘stdout’
[18:00:58.513]   - Field: ‘earlySignal’
[18:00:58.514]   - Field: ‘lazy’
[18:00:58.514]   - Field: ‘state’
[18:00:58.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.514] - Launch lazy future ...
[18:00:58.515] Packages needed by the future expression (n = 0): <none>
[18:00:58.515] Packages needed by future strategies (n = 0): <none>
[18:00:58.516] {
[18:00:58.516]     {
[18:00:58.516]         {
[18:00:58.516]             ...future.startTime <- base::Sys.time()
[18:00:58.516]             {
[18:00:58.516]                 {
[18:00:58.516]                   {
[18:00:58.516]                     base::local({
[18:00:58.516]                       has_future <- base::requireNamespace("future", 
[18:00:58.516]                         quietly = TRUE)
[18:00:58.516]                       if (has_future) {
[18:00:58.516]                         ns <- base::getNamespace("future")
[18:00:58.516]                         version <- ns[[".package"]][["version"]]
[18:00:58.516]                         if (is.null(version)) 
[18:00:58.516]                           version <- utils::packageVersion("future")
[18:00:58.516]                       }
[18:00:58.516]                       else {
[18:00:58.516]                         version <- NULL
[18:00:58.516]                       }
[18:00:58.516]                       if (!has_future || version < "1.8.0") {
[18:00:58.516]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.516]                           "", base::R.version$version.string), 
[18:00:58.516]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.516]                             "release", "version")], collapse = " "), 
[18:00:58.516]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.516]                           info)
[18:00:58.516]                         info <- base::paste(info, collapse = "; ")
[18:00:58.516]                         if (!has_future) {
[18:00:58.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.516]                             info)
[18:00:58.516]                         }
[18:00:58.516]                         else {
[18:00:58.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.516]                             info, version)
[18:00:58.516]                         }
[18:00:58.516]                         base::stop(msg)
[18:00:58.516]                       }
[18:00:58.516]                     })
[18:00:58.516]                   }
[18:00:58.516]                   ...future.strategy.old <- future::plan("list")
[18:00:58.516]                   options(future.plan = NULL)
[18:00:58.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.516]                 }
[18:00:58.516]                 ...future.workdir <- getwd()
[18:00:58.516]             }
[18:00:58.516]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.516]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.516]         }
[18:00:58.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.516]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.516]             base::names(...future.oldOptions))
[18:00:58.516]     }
[18:00:58.516]     if (FALSE) {
[18:00:58.516]     }
[18:00:58.516]     else {
[18:00:58.516]         if (TRUE) {
[18:00:58.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.516]                 open = "w")
[18:00:58.516]         }
[18:00:58.516]         else {
[18:00:58.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.516]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.516]         }
[18:00:58.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.516]             base::sink(type = "output", split = FALSE)
[18:00:58.516]             base::close(...future.stdout)
[18:00:58.516]         }, add = TRUE)
[18:00:58.516]     }
[18:00:58.516]     ...future.frame <- base::sys.nframe()
[18:00:58.516]     ...future.conditions <- base::list()
[18:00:58.516]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.516]     if (FALSE) {
[18:00:58.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.516]     }
[18:00:58.516]     ...future.result <- base::tryCatch({
[18:00:58.516]         base::withCallingHandlers({
[18:00:58.516]             ...future.value <- base::withVisible(base::local({
[18:00:58.516]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.516]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.516]                   ...future.globals.maxSize)) {
[18:00:58.516]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.516]                   on.exit(options(oopts), add = TRUE)
[18:00:58.516]                 }
[18:00:58.516]                 {
[18:00:58.516]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.516]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.516]                     USE.NAMES = FALSE)
[18:00:58.516]                   do.call(mapply, args = args)
[18:00:58.516]                 }
[18:00:58.516]             }))
[18:00:58.516]             future::FutureResult(value = ...future.value$value, 
[18:00:58.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.516]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.516]                     ...future.globalenv.names))
[18:00:58.516]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.516]         }, condition = base::local({
[18:00:58.516]             c <- base::c
[18:00:58.516]             inherits <- base::inherits
[18:00:58.516]             invokeRestart <- base::invokeRestart
[18:00:58.516]             length <- base::length
[18:00:58.516]             list <- base::list
[18:00:58.516]             seq.int <- base::seq.int
[18:00:58.516]             signalCondition <- base::signalCondition
[18:00:58.516]             sys.calls <- base::sys.calls
[18:00:58.516]             `[[` <- base::`[[`
[18:00:58.516]             `+` <- base::`+`
[18:00:58.516]             `<<-` <- base::`<<-`
[18:00:58.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.516]                   3L)]
[18:00:58.516]             }
[18:00:58.516]             function(cond) {
[18:00:58.516]                 is_error <- inherits(cond, "error")
[18:00:58.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.516]                   NULL)
[18:00:58.516]                 if (is_error) {
[18:00:58.516]                   sessionInformation <- function() {
[18:00:58.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.516]                       search = base::search(), system = base::Sys.info())
[18:00:58.516]                   }
[18:00:58.516]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.516]                     cond$call), session = sessionInformation(), 
[18:00:58.516]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.516]                   signalCondition(cond)
[18:00:58.516]                 }
[18:00:58.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.516]                 "immediateCondition"))) {
[18:00:58.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.516]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.516]                   if (TRUE && !signal) {
[18:00:58.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.516]                     {
[18:00:58.516]                       inherits <- base::inherits
[18:00:58.516]                       invokeRestart <- base::invokeRestart
[18:00:58.516]                       is.null <- base::is.null
[18:00:58.516]                       muffled <- FALSE
[18:00:58.516]                       if (inherits(cond, "message")) {
[18:00:58.516]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.516]                         if (muffled) 
[18:00:58.516]                           invokeRestart("muffleMessage")
[18:00:58.516]                       }
[18:00:58.516]                       else if (inherits(cond, "warning")) {
[18:00:58.516]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.516]                         if (muffled) 
[18:00:58.516]                           invokeRestart("muffleWarning")
[18:00:58.516]                       }
[18:00:58.516]                       else if (inherits(cond, "condition")) {
[18:00:58.516]                         if (!is.null(pattern)) {
[18:00:58.516]                           computeRestarts <- base::computeRestarts
[18:00:58.516]                           grepl <- base::grepl
[18:00:58.516]                           restarts <- computeRestarts(cond)
[18:00:58.516]                           for (restart in restarts) {
[18:00:58.516]                             name <- restart$name
[18:00:58.516]                             if (is.null(name)) 
[18:00:58.516]                               next
[18:00:58.516]                             if (!grepl(pattern, name)) 
[18:00:58.516]                               next
[18:00:58.516]                             invokeRestart(restart)
[18:00:58.516]                             muffled <- TRUE
[18:00:58.516]                             break
[18:00:58.516]                           }
[18:00:58.516]                         }
[18:00:58.516]                       }
[18:00:58.516]                       invisible(muffled)
[18:00:58.516]                     }
[18:00:58.516]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.516]                   }
[18:00:58.516]                 }
[18:00:58.516]                 else {
[18:00:58.516]                   if (TRUE) {
[18:00:58.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.516]                     {
[18:00:58.516]                       inherits <- base::inherits
[18:00:58.516]                       invokeRestart <- base::invokeRestart
[18:00:58.516]                       is.null <- base::is.null
[18:00:58.516]                       muffled <- FALSE
[18:00:58.516]                       if (inherits(cond, "message")) {
[18:00:58.516]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.516]                         if (muffled) 
[18:00:58.516]                           invokeRestart("muffleMessage")
[18:00:58.516]                       }
[18:00:58.516]                       else if (inherits(cond, "warning")) {
[18:00:58.516]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.516]                         if (muffled) 
[18:00:58.516]                           invokeRestart("muffleWarning")
[18:00:58.516]                       }
[18:00:58.516]                       else if (inherits(cond, "condition")) {
[18:00:58.516]                         if (!is.null(pattern)) {
[18:00:58.516]                           computeRestarts <- base::computeRestarts
[18:00:58.516]                           grepl <- base::grepl
[18:00:58.516]                           restarts <- computeRestarts(cond)
[18:00:58.516]                           for (restart in restarts) {
[18:00:58.516]                             name <- restart$name
[18:00:58.516]                             if (is.null(name)) 
[18:00:58.516]                               next
[18:00:58.516]                             if (!grepl(pattern, name)) 
[18:00:58.516]                               next
[18:00:58.516]                             invokeRestart(restart)
[18:00:58.516]                             muffled <- TRUE
[18:00:58.516]                             break
[18:00:58.516]                           }
[18:00:58.516]                         }
[18:00:58.516]                       }
[18:00:58.516]                       invisible(muffled)
[18:00:58.516]                     }
[18:00:58.516]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.516]                   }
[18:00:58.516]                 }
[18:00:58.516]             }
[18:00:58.516]         }))
[18:00:58.516]     }, error = function(ex) {
[18:00:58.516]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.516]                 ...future.rng), started = ...future.startTime, 
[18:00:58.516]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.516]             version = "1.8"), class = "FutureResult")
[18:00:58.516]     }, finally = {
[18:00:58.516]         if (!identical(...future.workdir, getwd())) 
[18:00:58.516]             setwd(...future.workdir)
[18:00:58.516]         {
[18:00:58.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.516]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.516]             }
[18:00:58.516]             base::options(...future.oldOptions)
[18:00:58.516]             if (.Platform$OS.type == "windows") {
[18:00:58.516]                 old_names <- names(...future.oldEnvVars)
[18:00:58.516]                 envs <- base::Sys.getenv()
[18:00:58.516]                 names <- names(envs)
[18:00:58.516]                 common <- intersect(names, old_names)
[18:00:58.516]                 added <- setdiff(names, old_names)
[18:00:58.516]                 removed <- setdiff(old_names, names)
[18:00:58.516]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.516]                   envs[common]]
[18:00:58.516]                 NAMES <- toupper(changed)
[18:00:58.516]                 args <- list()
[18:00:58.516]                 for (kk in seq_along(NAMES)) {
[18:00:58.516]                   name <- changed[[kk]]
[18:00:58.516]                   NAME <- NAMES[[kk]]
[18:00:58.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.516]                     next
[18:00:58.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.516]                 }
[18:00:58.516]                 NAMES <- toupper(added)
[18:00:58.516]                 for (kk in seq_along(NAMES)) {
[18:00:58.516]                   name <- added[[kk]]
[18:00:58.516]                   NAME <- NAMES[[kk]]
[18:00:58.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.516]                     next
[18:00:58.516]                   args[[name]] <- ""
[18:00:58.516]                 }
[18:00:58.516]                 NAMES <- toupper(removed)
[18:00:58.516]                 for (kk in seq_along(NAMES)) {
[18:00:58.516]                   name <- removed[[kk]]
[18:00:58.516]                   NAME <- NAMES[[kk]]
[18:00:58.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.516]                     next
[18:00:58.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.516]                 }
[18:00:58.516]                 if (length(args) > 0) 
[18:00:58.516]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.516]             }
[18:00:58.516]             else {
[18:00:58.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.516]             }
[18:00:58.516]             {
[18:00:58.516]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.516]                   0L) {
[18:00:58.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.516]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.516]                   base::options(opts)
[18:00:58.516]                 }
[18:00:58.516]                 {
[18:00:58.516]                   {
[18:00:58.516]                     base::assign(".Random.seed", c(10407L, 636678181L, 
[18:00:58.516]                     502178195L, 276891767L, -1069534784L, -723886220L, 
[18:00:58.516]                     1423455687L), envir = base::globalenv(), 
[18:00:58.516]                       inherits = FALSE)
[18:00:58.516]                     NULL
[18:00:58.516]                   }
[18:00:58.516]                   options(future.plan = NULL)
[18:00:58.516]                   if (is.na(NA_character_)) 
[18:00:58.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.516]                     .init = FALSE)
[18:00:58.516]                 }
[18:00:58.516]             }
[18:00:58.516]         }
[18:00:58.516]     })
[18:00:58.516]     if (TRUE) {
[18:00:58.516]         base::sink(type = "output", split = FALSE)
[18:00:58.516]         if (TRUE) {
[18:00:58.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.516]         }
[18:00:58.516]         else {
[18:00:58.516]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.516]         }
[18:00:58.516]         base::close(...future.stdout)
[18:00:58.516]         ...future.stdout <- NULL
[18:00:58.516]     }
[18:00:58.516]     ...future.result$conditions <- ...future.conditions
[18:00:58.516]     ...future.result$finished <- base::Sys.time()
[18:00:58.516]     ...future.result
[18:00:58.516] }
[18:00:58.519] assign_globals() ...
[18:00:58.520] List of 5
[18:00:58.520]  $ ...future.FUN            :function (x, y)  
[18:00:58.520]  $ MoreArgs                 :List of 1
[18:00:58.520]   ..$ y: int [1:2] 3 4
[18:00:58.520]  $ ...future.elements_ii    :List of 1
[18:00:58.520]   ..$ x:List of 2
[18:00:58.520]   .. ..$ : int 1
[18:00:58.520]   .. ..$ : int 2
[18:00:58.520]  $ ...future.seeds_ii       : NULL
[18:00:58.520]  $ ...future.globals.maxSize: NULL
[18:00:58.520]  - attr(*, "where")=List of 5
[18:00:58.520]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.520]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.520]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.520]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.520]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.520]  - attr(*, "resolved")= logi FALSE
[18:00:58.520]  - attr(*, "total_size")= num 1872
[18:00:58.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.520]  - attr(*, "already-done")= logi TRUE
[18:00:58.531] - reassign environment for ‘...future.FUN’
[18:00:58.531] - copied ‘...future.FUN’ to environment
[18:00:58.531] - copied ‘MoreArgs’ to environment
[18:00:58.532] - copied ‘...future.elements_ii’ to environment
[18:00:58.532] - copied ‘...future.seeds_ii’ to environment
[18:00:58.532] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.532] assign_globals() ... done
[18:00:58.535] plan(): Setting new future strategy stack:
[18:00:58.535] List of future strategies:
[18:00:58.535] 1. sequential:
[18:00:58.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.535]    - tweaked: FALSE
[18:00:58.535]    - call: NULL
[18:00:58.536] plan(): nbrOfWorkers() = 1
[18:00:58.538] plan(): Setting new future strategy stack:
[18:00:58.538] List of future strategies:
[18:00:58.538] 1. sequential:
[18:00:58.538]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.538]    - tweaked: FALSE
[18:00:58.538]    - call: plan(strategy)
[18:00:58.539] plan(): nbrOfWorkers() = 1
[18:00:58.539] SequentialFuture started (and completed)
[18:00:58.540] - Launch lazy future ... done
[18:00:58.540] run() for ‘SequentialFuture’ ... done
[18:00:58.540] Created future:
[18:00:58.540] SequentialFuture:
[18:00:58.540] Label: ‘future_mapply-1’
[18:00:58.540] Expression:
[18:00:58.540] {
[18:00:58.540]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.540]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.540]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.540]         on.exit(options(oopts), add = TRUE)
[18:00:58.540]     }
[18:00:58.540]     {
[18:00:58.540]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.540]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.540]         do.call(mapply, args = args)
[18:00:58.540]     }
[18:00:58.540] }
[18:00:58.540] Lazy evaluation: FALSE
[18:00:58.540] Asynchronous evaluation: FALSE
[18:00:58.540] Local evaluation: TRUE
[18:00:58.540] Environment: R_GlobalEnv
[18:00:58.540] Capture standard output: TRUE
[18:00:58.540] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.540] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.540] Packages: <none>
[18:00:58.540] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.540] Resolved: TRUE
[18:00:58.540] Value: 112 bytes of class ‘list’
[18:00:58.540] Early signaling: FALSE
[18:00:58.540] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.540] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.542] Chunk #1 of 1 ... DONE
[18:00:58.542] Launching 1 futures (chunks) ... DONE
[18:00:58.542] Resolving 1 futures (chunks) ...
[18:00:58.543] resolve() on list ...
[18:00:58.543]  recursive: 0
[18:00:58.543]  length: 1
[18:00:58.543] 
[18:00:58.543] resolved() for ‘SequentialFuture’ ...
[18:00:58.544] - state: ‘finished’
[18:00:58.544] - run: TRUE
[18:00:58.544] - result: ‘FutureResult’
[18:00:58.544] resolved() for ‘SequentialFuture’ ... done
[18:00:58.544] Future #1
[18:00:58.545] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.545] - nx: 1
[18:00:58.545] - relay: TRUE
[18:00:58.545] - stdout: TRUE
[18:00:58.545] - signal: TRUE
[18:00:58.546] - resignal: FALSE
[18:00:58.546] - force: TRUE
[18:00:58.546] - relayed: [n=1] FALSE
[18:00:58.546] - queued futures: [n=1] FALSE
[18:00:58.546]  - until=1
[18:00:58.546]  - relaying element #1
[18:00:58.547] - relayed: [n=1] TRUE
[18:00:58.547] - queued futures: [n=1] TRUE
[18:00:58.547] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.547]  length: 0 (resolved future 1)
[18:00:58.548] Relaying remaining futures
[18:00:58.548] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.548] - nx: 1
[18:00:58.548] - relay: TRUE
[18:00:58.548] - stdout: TRUE
[18:00:58.548] - signal: TRUE
[18:00:58.549] - resignal: FALSE
[18:00:58.549] - force: TRUE
[18:00:58.549] - relayed: [n=1] TRUE
[18:00:58.549] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.549] - relayed: [n=1] TRUE
[18:00:58.550] - queued futures: [n=1] TRUE
[18:00:58.550] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.550] resolve() on list ... DONE
[18:00:58.550]  - Number of value chunks collected: 1
[18:00:58.550] Resolving 1 futures (chunks) ... DONE
[18:00:58.551] Reducing values from 1 chunks ...
[18:00:58.551]  - Number of values collected after concatenation: 2
[18:00:58.551]  - Number of values expected: 2
[18:00:58.551] Reducing values from 1 chunks ... DONE
[18:00:58.551] future_mapply() ... DONE
[18:00:58.552] future_mapply() ...
[18:00:58.552] Generating random seeds ...
[18:00:58.552] Generating random seed streams for 2 elements ...
[18:00:58.552] Generating random seed streams for 2 elements ... DONE
[18:00:58.553] Generating random seeds ... DONE
[18:00:58.553] Will set RNG state on exit: 10407, 276891767, 833447509, -344040774, 1423455687, -2113572702, 704118981
[18:00:58.553] Number of chunks: 1
[18:00:58.553] getGlobalsAndPackagesXApply() ...
[18:00:58.553]  - future.globals: TRUE
[18:00:58.554] getGlobalsAndPackages() ...
[18:00:58.554] Searching for globals...
[18:00:58.556] - globals found: [1] ‘FUN’
[18:00:58.556] Searching for globals ... DONE
[18:00:58.556] Resolving globals: FALSE
[18:00:58.557] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:00:58.557] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:00:58.558] - globals: [1] ‘FUN’
[18:00:58.558] 
[18:00:58.558] getGlobalsAndPackages() ... DONE
[18:00:58.558]  - globals found/used: [n=1] ‘FUN’
[18:00:58.558]  - needed namespaces: [n=0] 
[18:00:58.559] Finding globals ... DONE
[18:00:58.559] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.559] List of 2
[18:00:58.559]  $ ...future.FUN:function (x, y)  
[18:00:58.559]  $ MoreArgs     :List of 1
[18:00:58.559]   ..$ y: int [1:2] 3 4
[18:00:58.559]  - attr(*, "where")=List of 2
[18:00:58.559]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.559]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.559]  - attr(*, "resolved")= logi FALSE
[18:00:58.559]  - attr(*, "total_size")= num NA
[18:00:58.565] Packages to be attached in all futures: [n=0] 
[18:00:58.565] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.565] Number of futures (= number of chunks): 1
[18:00:58.566] Launching 1 futures (chunks) ...
[18:00:58.566] Chunk #1 of 1 ...
[18:00:58.566]  - Finding globals in '...' for chunk #1 ...
[18:00:58.566] getGlobalsAndPackages() ...
[18:00:58.566] Searching for globals...
[18:00:58.567] 
[18:00:58.567] Searching for globals ... DONE
[18:00:58.567] - globals: [0] <none>
[18:00:58.568] getGlobalsAndPackages() ... DONE
[18:00:58.568]    + additional globals found: [n=0] 
[18:00:58.568]    + additional namespaces needed: [n=0] 
[18:00:58.568]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.568]  - seeds: [2] <seeds>
[18:00:58.569]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.569] getGlobalsAndPackages() ...
[18:00:58.569] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.569] Resolving globals: FALSE
[18:00:58.570] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[18:00:58.571] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[18:00:58.572] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.572] 
[18:00:58.572] getGlobalsAndPackages() ... DONE
[18:00:58.573] run() for ‘Future’ ...
[18:00:58.573] - state: ‘created’
[18:00:58.573] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.574] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.574] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.574]   - Field: ‘label’
[18:00:58.574]   - Field: ‘local’
[18:00:58.575]   - Field: ‘owner’
[18:00:58.575]   - Field: ‘envir’
[18:00:58.575]   - Field: ‘packages’
[18:00:58.575]   - Field: ‘gc’
[18:00:58.575]   - Field: ‘conditions’
[18:00:58.576]   - Field: ‘expr’
[18:00:58.576]   - Field: ‘uuid’
[18:00:58.576]   - Field: ‘seed’
[18:00:58.576]   - Field: ‘version’
[18:00:58.576]   - Field: ‘result’
[18:00:58.577]   - Field: ‘asynchronous’
[18:00:58.577]   - Field: ‘calls’
[18:00:58.577]   - Field: ‘globals’
[18:00:58.577]   - Field: ‘stdout’
[18:00:58.577]   - Field: ‘earlySignal’
[18:00:58.578]   - Field: ‘lazy’
[18:00:58.578]   - Field: ‘state’
[18:00:58.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.578] - Launch lazy future ...
[18:00:58.579] Packages needed by the future expression (n = 0): <none>
[18:00:58.579] Packages needed by future strategies (n = 0): <none>
[18:00:58.580] {
[18:00:58.580]     {
[18:00:58.580]         {
[18:00:58.580]             ...future.startTime <- base::Sys.time()
[18:00:58.580]             {
[18:00:58.580]                 {
[18:00:58.580]                   {
[18:00:58.580]                     base::local({
[18:00:58.580]                       has_future <- base::requireNamespace("future", 
[18:00:58.580]                         quietly = TRUE)
[18:00:58.580]                       if (has_future) {
[18:00:58.580]                         ns <- base::getNamespace("future")
[18:00:58.580]                         version <- ns[[".package"]][["version"]]
[18:00:58.580]                         if (is.null(version)) 
[18:00:58.580]                           version <- utils::packageVersion("future")
[18:00:58.580]                       }
[18:00:58.580]                       else {
[18:00:58.580]                         version <- NULL
[18:00:58.580]                       }
[18:00:58.580]                       if (!has_future || version < "1.8.0") {
[18:00:58.580]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.580]                           "", base::R.version$version.string), 
[18:00:58.580]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.580]                             "release", "version")], collapse = " "), 
[18:00:58.580]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.580]                           info)
[18:00:58.580]                         info <- base::paste(info, collapse = "; ")
[18:00:58.580]                         if (!has_future) {
[18:00:58.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.580]                             info)
[18:00:58.580]                         }
[18:00:58.580]                         else {
[18:00:58.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.580]                             info, version)
[18:00:58.580]                         }
[18:00:58.580]                         base::stop(msg)
[18:00:58.580]                       }
[18:00:58.580]                     })
[18:00:58.580]                   }
[18:00:58.580]                   ...future.strategy.old <- future::plan("list")
[18:00:58.580]                   options(future.plan = NULL)
[18:00:58.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.580]                 }
[18:00:58.580]                 ...future.workdir <- getwd()
[18:00:58.580]             }
[18:00:58.580]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.580]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.580]         }
[18:00:58.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.580]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.580]             base::names(...future.oldOptions))
[18:00:58.580]     }
[18:00:58.580]     if (FALSE) {
[18:00:58.580]     }
[18:00:58.580]     else {
[18:00:58.580]         if (TRUE) {
[18:00:58.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.580]                 open = "w")
[18:00:58.580]         }
[18:00:58.580]         else {
[18:00:58.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.580]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.580]         }
[18:00:58.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.580]             base::sink(type = "output", split = FALSE)
[18:00:58.580]             base::close(...future.stdout)
[18:00:58.580]         }, add = TRUE)
[18:00:58.580]     }
[18:00:58.580]     ...future.frame <- base::sys.nframe()
[18:00:58.580]     ...future.conditions <- base::list()
[18:00:58.580]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.580]     if (FALSE) {
[18:00:58.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.580]     }
[18:00:58.580]     ...future.result <- base::tryCatch({
[18:00:58.580]         base::withCallingHandlers({
[18:00:58.580]             ...future.value <- base::withVisible(base::local({
[18:00:58.580]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.580]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.580]                   ...future.globals.maxSize)) {
[18:00:58.580]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.580]                   on.exit(options(oopts), add = TRUE)
[18:00:58.580]                 }
[18:00:58.580]                 {
[18:00:58.580]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:00:58.580]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[18:00:58.580]                       envir = globalenv(), inherits = FALSE)
[18:00:58.580]                     ...future.FUN(...)
[18:00:58.580]                   }
[18:00:58.580]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:00:58.580]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:00:58.580]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.580]                     USE.NAMES = FALSE)
[18:00:58.580]                   do.call(mapply, args = args)
[18:00:58.580]                 }
[18:00:58.580]             }))
[18:00:58.580]             future::FutureResult(value = ...future.value$value, 
[18:00:58.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.580]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.580]                     ...future.globalenv.names))
[18:00:58.580]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.580]         }, condition = base::local({
[18:00:58.580]             c <- base::c
[18:00:58.580]             inherits <- base::inherits
[18:00:58.580]             invokeRestart <- base::invokeRestart
[18:00:58.580]             length <- base::length
[18:00:58.580]             list <- base::list
[18:00:58.580]             seq.int <- base::seq.int
[18:00:58.580]             signalCondition <- base::signalCondition
[18:00:58.580]             sys.calls <- base::sys.calls
[18:00:58.580]             `[[` <- base::`[[`
[18:00:58.580]             `+` <- base::`+`
[18:00:58.580]             `<<-` <- base::`<<-`
[18:00:58.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.580]                   3L)]
[18:00:58.580]             }
[18:00:58.580]             function(cond) {
[18:00:58.580]                 is_error <- inherits(cond, "error")
[18:00:58.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.580]                   NULL)
[18:00:58.580]                 if (is_error) {
[18:00:58.580]                   sessionInformation <- function() {
[18:00:58.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.580]                       search = base::search(), system = base::Sys.info())
[18:00:58.580]                   }
[18:00:58.580]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.580]                     cond$call), session = sessionInformation(), 
[18:00:58.580]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.580]                   signalCondition(cond)
[18:00:58.580]                 }
[18:00:58.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.580]                 "immediateCondition"))) {
[18:00:58.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.580]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.580]                   if (TRUE && !signal) {
[18:00:58.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.580]                     {
[18:00:58.580]                       inherits <- base::inherits
[18:00:58.580]                       invokeRestart <- base::invokeRestart
[18:00:58.580]                       is.null <- base::is.null
[18:00:58.580]                       muffled <- FALSE
[18:00:58.580]                       if (inherits(cond, "message")) {
[18:00:58.580]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.580]                         if (muffled) 
[18:00:58.580]                           invokeRestart("muffleMessage")
[18:00:58.580]                       }
[18:00:58.580]                       else if (inherits(cond, "warning")) {
[18:00:58.580]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.580]                         if (muffled) 
[18:00:58.580]                           invokeRestart("muffleWarning")
[18:00:58.580]                       }
[18:00:58.580]                       else if (inherits(cond, "condition")) {
[18:00:58.580]                         if (!is.null(pattern)) {
[18:00:58.580]                           computeRestarts <- base::computeRestarts
[18:00:58.580]                           grepl <- base::grepl
[18:00:58.580]                           restarts <- computeRestarts(cond)
[18:00:58.580]                           for (restart in restarts) {
[18:00:58.580]                             name <- restart$name
[18:00:58.580]                             if (is.null(name)) 
[18:00:58.580]                               next
[18:00:58.580]                             if (!grepl(pattern, name)) 
[18:00:58.580]                               next
[18:00:58.580]                             invokeRestart(restart)
[18:00:58.580]                             muffled <- TRUE
[18:00:58.580]                             break
[18:00:58.580]                           }
[18:00:58.580]                         }
[18:00:58.580]                       }
[18:00:58.580]                       invisible(muffled)
[18:00:58.580]                     }
[18:00:58.580]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.580]                   }
[18:00:58.580]                 }
[18:00:58.580]                 else {
[18:00:58.580]                   if (TRUE) {
[18:00:58.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.580]                     {
[18:00:58.580]                       inherits <- base::inherits
[18:00:58.580]                       invokeRestart <- base::invokeRestart
[18:00:58.580]                       is.null <- base::is.null
[18:00:58.580]                       muffled <- FALSE
[18:00:58.580]                       if (inherits(cond, "message")) {
[18:00:58.580]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.580]                         if (muffled) 
[18:00:58.580]                           invokeRestart("muffleMessage")
[18:00:58.580]                       }
[18:00:58.580]                       else if (inherits(cond, "warning")) {
[18:00:58.580]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.580]                         if (muffled) 
[18:00:58.580]                           invokeRestart("muffleWarning")
[18:00:58.580]                       }
[18:00:58.580]                       else if (inherits(cond, "condition")) {
[18:00:58.580]                         if (!is.null(pattern)) {
[18:00:58.580]                           computeRestarts <- base::computeRestarts
[18:00:58.580]                           grepl <- base::grepl
[18:00:58.580]                           restarts <- computeRestarts(cond)
[18:00:58.580]                           for (restart in restarts) {
[18:00:58.580]                             name <- restart$name
[18:00:58.580]                             if (is.null(name)) 
[18:00:58.580]                               next
[18:00:58.580]                             if (!grepl(pattern, name)) 
[18:00:58.580]                               next
[18:00:58.580]                             invokeRestart(restart)
[18:00:58.580]                             muffled <- TRUE
[18:00:58.580]                             break
[18:00:58.580]                           }
[18:00:58.580]                         }
[18:00:58.580]                       }
[18:00:58.580]                       invisible(muffled)
[18:00:58.580]                     }
[18:00:58.580]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.580]                   }
[18:00:58.580]                 }
[18:00:58.580]             }
[18:00:58.580]         }))
[18:00:58.580]     }, error = function(ex) {
[18:00:58.580]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.580]                 ...future.rng), started = ...future.startTime, 
[18:00:58.580]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.580]             version = "1.8"), class = "FutureResult")
[18:00:58.580]     }, finally = {
[18:00:58.580]         if (!identical(...future.workdir, getwd())) 
[18:00:58.580]             setwd(...future.workdir)
[18:00:58.580]         {
[18:00:58.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.580]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.580]             }
[18:00:58.580]             base::options(...future.oldOptions)
[18:00:58.580]             if (.Platform$OS.type == "windows") {
[18:00:58.580]                 old_names <- names(...future.oldEnvVars)
[18:00:58.580]                 envs <- base::Sys.getenv()
[18:00:58.580]                 names <- names(envs)
[18:00:58.580]                 common <- intersect(names, old_names)
[18:00:58.580]                 added <- setdiff(names, old_names)
[18:00:58.580]                 removed <- setdiff(old_names, names)
[18:00:58.580]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.580]                   envs[common]]
[18:00:58.580]                 NAMES <- toupper(changed)
[18:00:58.580]                 args <- list()
[18:00:58.580]                 for (kk in seq_along(NAMES)) {
[18:00:58.580]                   name <- changed[[kk]]
[18:00:58.580]                   NAME <- NAMES[[kk]]
[18:00:58.580]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.580]                     next
[18:00:58.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.580]                 }
[18:00:58.580]                 NAMES <- toupper(added)
[18:00:58.580]                 for (kk in seq_along(NAMES)) {
[18:00:58.580]                   name <- added[[kk]]
[18:00:58.580]                   NAME <- NAMES[[kk]]
[18:00:58.580]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.580]                     next
[18:00:58.580]                   args[[name]] <- ""
[18:00:58.580]                 }
[18:00:58.580]                 NAMES <- toupper(removed)
[18:00:58.580]                 for (kk in seq_along(NAMES)) {
[18:00:58.580]                   name <- removed[[kk]]
[18:00:58.580]                   NAME <- NAMES[[kk]]
[18:00:58.580]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.580]                     next
[18:00:58.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.580]                 }
[18:00:58.580]                 if (length(args) > 0) 
[18:00:58.580]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.580]             }
[18:00:58.580]             else {
[18:00:58.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.580]             }
[18:00:58.580]             {
[18:00:58.580]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.580]                   0L) {
[18:00:58.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.580]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.580]                   base::options(opts)
[18:00:58.580]                 }
[18:00:58.580]                 {
[18:00:58.580]                   {
[18:00:58.580]                     base::assign(".Random.seed", c(10407L, 276891767L, 
[18:00:58.580]                     833447509L, -344040774L, 1423455687L, -2113572702L, 
[18:00:58.580]                     704118981L), envir = base::globalenv(), inherits = FALSE)
[18:00:58.580]                     NULL
[18:00:58.580]                   }
[18:00:58.580]                   options(future.plan = NULL)
[18:00:58.580]                   if (is.na(NA_character_)) 
[18:00:58.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.580]                     .init = FALSE)
[18:00:58.580]                 }
[18:00:58.580]             }
[18:00:58.580]         }
[18:00:58.580]     })
[18:00:58.580]     if (TRUE) {
[18:00:58.580]         base::sink(type = "output", split = FALSE)
[18:00:58.580]         if (TRUE) {
[18:00:58.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.580]         }
[18:00:58.580]         else {
[18:00:58.580]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.580]         }
[18:00:58.580]         base::close(...future.stdout)
[18:00:58.580]         ...future.stdout <- NULL
[18:00:58.580]     }
[18:00:58.580]     ...future.result$conditions <- ...future.conditions
[18:00:58.580]     ...future.result$finished <- base::Sys.time()
[18:00:58.580]     ...future.result
[18:00:58.580] }
[18:00:58.583] assign_globals() ...
[18:00:58.583] List of 5
[18:00:58.583]  $ ...future.FUN            :function (x, y)  
[18:00:58.583]  $ MoreArgs                 :List of 1
[18:00:58.583]   ..$ y: int [1:2] 3 4
[18:00:58.583]  $ ...future.elements_ii    :List of 1
[18:00:58.583]   ..$ x:List of 2
[18:00:58.583]   .. ..$ : int 1
[18:00:58.583]   .. ..$ : int 2
[18:00:58.583]  $ ...future.seeds_ii       :List of 2
[18:00:58.583]   ..$ : int [1:7] 10407 -2019988123 1634254909 -2084188024 -1666496055 -1596431770 900247742
[18:00:58.583]   ..$ : int [1:7] 10407 501543438 1438324543 -693058638 280880231 1250459915 1840888332
[18:00:58.583]  $ ...future.globals.maxSize: NULL
[18:00:58.583]  - attr(*, "where")=List of 5
[18:00:58.583]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.583]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.583]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.583]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.583]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.583]  - attr(*, "resolved")= logi FALSE
[18:00:58.583]  - attr(*, "total_size")= num 2032
[18:00:58.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.583]  - attr(*, "already-done")= logi TRUE
[18:00:58.599] - reassign environment for ‘...future.FUN’
[18:00:58.600] - copied ‘...future.FUN’ to environment
[18:00:58.600] - copied ‘MoreArgs’ to environment
[18:00:58.600] - copied ‘...future.elements_ii’ to environment
[18:00:58.600] - copied ‘...future.seeds_ii’ to environment
[18:00:58.601] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.601] assign_globals() ... done
[18:00:58.601] plan(): Setting new future strategy stack:
[18:00:58.601] List of future strategies:
[18:00:58.601] 1. sequential:
[18:00:58.601]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.601]    - tweaked: FALSE
[18:00:58.601]    - call: NULL
[18:00:58.602] plan(): nbrOfWorkers() = 1
[18:00:58.604] plan(): Setting new future strategy stack:
[18:00:58.604] List of future strategies:
[18:00:58.604] 1. sequential:
[18:00:58.604]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.604]    - tweaked: FALSE
[18:00:58.604]    - call: plan(strategy)
[18:00:58.605] plan(): nbrOfWorkers() = 1
[18:00:58.605] SequentialFuture started (and completed)
[18:00:58.606] - Launch lazy future ... done
[18:00:58.606] run() for ‘SequentialFuture’ ... done
[18:00:58.606] Created future:
[18:00:58.606] SequentialFuture:
[18:00:58.606] Label: ‘future_mapply-1’
[18:00:58.606] Expression:
[18:00:58.606] {
[18:00:58.606]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.606]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.606]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.606]         on.exit(options(oopts), add = TRUE)
[18:00:58.606]     }
[18:00:58.606]     {
[18:00:58.606]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:00:58.606]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:00:58.606]                 inherits = FALSE)
[18:00:58.606]             ...future.FUN(...)
[18:00:58.606]         }
[18:00:58.606]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:00:58.606]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:00:58.606]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.606]         do.call(mapply, args = args)
[18:00:58.606]     }
[18:00:58.606] }
[18:00:58.606] Lazy evaluation: FALSE
[18:00:58.606] Asynchronous evaluation: FALSE
[18:00:58.606] Local evaluation: TRUE
[18:00:58.606] Environment: R_GlobalEnv
[18:00:58.606] Capture standard output: TRUE
[18:00:58.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.606] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.606] Packages: <none>
[18:00:58.606] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:00:58.606] Resolved: TRUE
[18:00:58.606] Value: 112 bytes of class ‘list’
[18:00:58.606] Early signaling: FALSE
[18:00:58.606] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.606] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.608] Chunk #1 of 1 ... DONE
[18:00:58.608] Launching 1 futures (chunks) ... DONE
[18:00:58.609] Resolving 1 futures (chunks) ...
[18:00:58.609] resolve() on list ...
[18:00:58.609]  recursive: 0
[18:00:58.609]  length: 1
[18:00:58.609] 
[18:00:58.610] resolved() for ‘SequentialFuture’ ...
[18:00:58.610] - state: ‘finished’
[18:00:58.610] - run: TRUE
[18:00:58.610] - result: ‘FutureResult’
[18:00:58.610] resolved() for ‘SequentialFuture’ ... done
[18:00:58.611] Future #1
[18:00:58.611] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.611] - nx: 1
[18:00:58.611] - relay: TRUE
[18:00:58.611] - stdout: TRUE
[18:00:58.612] - signal: TRUE
[18:00:58.612] - resignal: FALSE
[18:00:58.612] - force: TRUE
[18:00:58.612] - relayed: [n=1] FALSE
[18:00:58.612] - queued futures: [n=1] FALSE
[18:00:58.613]  - until=1
[18:00:58.613]  - relaying element #1
[18:00:58.613] - relayed: [n=1] TRUE
[18:00:58.613] - queued futures: [n=1] TRUE
[18:00:58.613] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.614]  length: 0 (resolved future 1)
[18:00:58.614] Relaying remaining futures
[18:00:58.614] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.614] - nx: 1
[18:00:58.614] - relay: TRUE
[18:00:58.615] - stdout: TRUE
[18:00:58.615] - signal: TRUE
[18:00:58.615] - resignal: FALSE
[18:00:58.615] - force: TRUE
[18:00:58.615] - relayed: [n=1] TRUE
[18:00:58.615] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.616] - relayed: [n=1] TRUE
[18:00:58.616] - queued futures: [n=1] TRUE
[18:00:58.616] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.616] resolve() on list ... DONE
[18:00:58.617]  - Number of value chunks collected: 1
[18:00:58.617] Resolving 1 futures (chunks) ... DONE
[18:00:58.617] Reducing values from 1 chunks ...
[18:00:58.617]  - Number of values collected after concatenation: 2
[18:00:58.617]  - Number of values expected: 2
[18:00:58.617] Reducing values from 1 chunks ... DONE
[18:00:58.618] future_mapply() ... DONE
[18:00:58.618] future_mapply() ...
[18:00:58.618] Number of chunks: 1
[18:00:58.619] getGlobalsAndPackagesXApply() ...
[18:00:58.619]  - future.globals: TRUE
[18:00:58.619] getGlobalsAndPackages() ...
[18:00:58.619] Searching for globals...
[18:00:58.621] - globals found: [1] ‘FUN’
[18:00:58.621] Searching for globals ... DONE
[18:00:58.622] Resolving globals: FALSE
[18:00:58.622] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:00:58.623] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:00:58.623] - globals: [1] ‘FUN’
[18:00:58.623] 
[18:00:58.623] getGlobalsAndPackages() ... DONE
[18:00:58.624]  - globals found/used: [n=1] ‘FUN’
[18:00:58.624]  - needed namespaces: [n=0] 
[18:00:58.624] Finding globals ... DONE
[18:00:58.624] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.625] List of 2
[18:00:58.625]  $ ...future.FUN:function (x, y)  
[18:00:58.625]  $ MoreArgs     :List of 1
[18:00:58.625]   ..$ y: int [1:2] 3 4
[18:00:58.625]  - attr(*, "where")=List of 2
[18:00:58.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.625]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.625]  - attr(*, "resolved")= logi FALSE
[18:00:58.625]  - attr(*, "total_size")= num NA
[18:00:58.630] Packages to be attached in all futures: [n=0] 
[18:00:58.630] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.631] Number of futures (= number of chunks): 1
[18:00:58.631] Launching 1 futures (chunks) ...
[18:00:58.631] Chunk #1 of 1 ...
[18:00:58.631]  - Finding globals in '...' for chunk #1 ...
[18:00:58.632] getGlobalsAndPackages() ...
[18:00:58.632] Searching for globals...
[18:00:58.632] 
[18:00:58.633] Searching for globals ... DONE
[18:00:58.635] - globals: [0] <none>
[18:00:58.635] getGlobalsAndPackages() ... DONE
[18:00:58.636]    + additional globals found: [n=0] 
[18:00:58.636]    + additional namespaces needed: [n=0] 
[18:00:58.636]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.636]  - seeds: <none>
[18:00:58.636]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.637] getGlobalsAndPackages() ...
[18:00:58.637] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.637] Resolving globals: FALSE
[18:00:58.638] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[18:00:58.639] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:00:58.639] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.639] 
[18:00:58.640] getGlobalsAndPackages() ... DONE
[18:00:58.640] run() for ‘Future’ ...
[18:00:58.640] - state: ‘created’
[18:00:58.641] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.642]   - Field: ‘label’
[18:00:58.642]   - Field: ‘local’
[18:00:58.642]   - Field: ‘owner’
[18:00:58.642]   - Field: ‘envir’
[18:00:58.642]   - Field: ‘packages’
[18:00:58.643]   - Field: ‘gc’
[18:00:58.643]   - Field: ‘conditions’
[18:00:58.643]   - Field: ‘expr’
[18:00:58.643]   - Field: ‘uuid’
[18:00:58.643]   - Field: ‘seed’
[18:00:58.644]   - Field: ‘version’
[18:00:58.644]   - Field: ‘result’
[18:00:58.644]   - Field: ‘asynchronous’
[18:00:58.644]   - Field: ‘calls’
[18:00:58.644]   - Field: ‘globals’
[18:00:58.645]   - Field: ‘stdout’
[18:00:58.645]   - Field: ‘earlySignal’
[18:00:58.645]   - Field: ‘lazy’
[18:00:58.645]   - Field: ‘state’
[18:00:58.645] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.646] - Launch lazy future ...
[18:00:58.646] Packages needed by the future expression (n = 0): <none>
[18:00:58.646] Packages needed by future strategies (n = 0): <none>
[18:00:58.647] {
[18:00:58.647]     {
[18:00:58.647]         {
[18:00:58.647]             ...future.startTime <- base::Sys.time()
[18:00:58.647]             {
[18:00:58.647]                 {
[18:00:58.647]                   {
[18:00:58.647]                     base::local({
[18:00:58.647]                       has_future <- base::requireNamespace("future", 
[18:00:58.647]                         quietly = TRUE)
[18:00:58.647]                       if (has_future) {
[18:00:58.647]                         ns <- base::getNamespace("future")
[18:00:58.647]                         version <- ns[[".package"]][["version"]]
[18:00:58.647]                         if (is.null(version)) 
[18:00:58.647]                           version <- utils::packageVersion("future")
[18:00:58.647]                       }
[18:00:58.647]                       else {
[18:00:58.647]                         version <- NULL
[18:00:58.647]                       }
[18:00:58.647]                       if (!has_future || version < "1.8.0") {
[18:00:58.647]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.647]                           "", base::R.version$version.string), 
[18:00:58.647]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.647]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.647]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.647]                             "release", "version")], collapse = " "), 
[18:00:58.647]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.647]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.647]                           info)
[18:00:58.647]                         info <- base::paste(info, collapse = "; ")
[18:00:58.647]                         if (!has_future) {
[18:00:58.647]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.647]                             info)
[18:00:58.647]                         }
[18:00:58.647]                         else {
[18:00:58.647]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.647]                             info, version)
[18:00:58.647]                         }
[18:00:58.647]                         base::stop(msg)
[18:00:58.647]                       }
[18:00:58.647]                     })
[18:00:58.647]                   }
[18:00:58.647]                   ...future.strategy.old <- future::plan("list")
[18:00:58.647]                   options(future.plan = NULL)
[18:00:58.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.647]                 }
[18:00:58.647]                 ...future.workdir <- getwd()
[18:00:58.647]             }
[18:00:58.647]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.647]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.647]         }
[18:00:58.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.647]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.647]             base::names(...future.oldOptions))
[18:00:58.647]     }
[18:00:58.647]     if (FALSE) {
[18:00:58.647]     }
[18:00:58.647]     else {
[18:00:58.647]         if (TRUE) {
[18:00:58.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.647]                 open = "w")
[18:00:58.647]         }
[18:00:58.647]         else {
[18:00:58.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.647]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.647]         }
[18:00:58.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.647]             base::sink(type = "output", split = FALSE)
[18:00:58.647]             base::close(...future.stdout)
[18:00:58.647]         }, add = TRUE)
[18:00:58.647]     }
[18:00:58.647]     ...future.frame <- base::sys.nframe()
[18:00:58.647]     ...future.conditions <- base::list()
[18:00:58.647]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.647]     if (FALSE) {
[18:00:58.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.647]     }
[18:00:58.647]     ...future.result <- base::tryCatch({
[18:00:58.647]         base::withCallingHandlers({
[18:00:58.647]             ...future.value <- base::withVisible(base::local({
[18:00:58.647]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.647]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.647]                   ...future.globals.maxSize)) {
[18:00:58.647]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.647]                   on.exit(options(oopts), add = TRUE)
[18:00:58.647]                 }
[18:00:58.647]                 {
[18:00:58.647]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.647]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.647]                     USE.NAMES = FALSE)
[18:00:58.647]                   do.call(mapply, args = args)
[18:00:58.647]                 }
[18:00:58.647]             }))
[18:00:58.647]             future::FutureResult(value = ...future.value$value, 
[18:00:58.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.647]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.647]                     ...future.globalenv.names))
[18:00:58.647]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.647]         }, condition = base::local({
[18:00:58.647]             c <- base::c
[18:00:58.647]             inherits <- base::inherits
[18:00:58.647]             invokeRestart <- base::invokeRestart
[18:00:58.647]             length <- base::length
[18:00:58.647]             list <- base::list
[18:00:58.647]             seq.int <- base::seq.int
[18:00:58.647]             signalCondition <- base::signalCondition
[18:00:58.647]             sys.calls <- base::sys.calls
[18:00:58.647]             `[[` <- base::`[[`
[18:00:58.647]             `+` <- base::`+`
[18:00:58.647]             `<<-` <- base::`<<-`
[18:00:58.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.647]                   3L)]
[18:00:58.647]             }
[18:00:58.647]             function(cond) {
[18:00:58.647]                 is_error <- inherits(cond, "error")
[18:00:58.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.647]                   NULL)
[18:00:58.647]                 if (is_error) {
[18:00:58.647]                   sessionInformation <- function() {
[18:00:58.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.647]                       search = base::search(), system = base::Sys.info())
[18:00:58.647]                   }
[18:00:58.647]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.647]                     cond$call), session = sessionInformation(), 
[18:00:58.647]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.647]                   signalCondition(cond)
[18:00:58.647]                 }
[18:00:58.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.647]                 "immediateCondition"))) {
[18:00:58.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.647]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.647]                   if (TRUE && !signal) {
[18:00:58.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.647]                     {
[18:00:58.647]                       inherits <- base::inherits
[18:00:58.647]                       invokeRestart <- base::invokeRestart
[18:00:58.647]                       is.null <- base::is.null
[18:00:58.647]                       muffled <- FALSE
[18:00:58.647]                       if (inherits(cond, "message")) {
[18:00:58.647]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.647]                         if (muffled) 
[18:00:58.647]                           invokeRestart("muffleMessage")
[18:00:58.647]                       }
[18:00:58.647]                       else if (inherits(cond, "warning")) {
[18:00:58.647]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.647]                         if (muffled) 
[18:00:58.647]                           invokeRestart("muffleWarning")
[18:00:58.647]                       }
[18:00:58.647]                       else if (inherits(cond, "condition")) {
[18:00:58.647]                         if (!is.null(pattern)) {
[18:00:58.647]                           computeRestarts <- base::computeRestarts
[18:00:58.647]                           grepl <- base::grepl
[18:00:58.647]                           restarts <- computeRestarts(cond)
[18:00:58.647]                           for (restart in restarts) {
[18:00:58.647]                             name <- restart$name
[18:00:58.647]                             if (is.null(name)) 
[18:00:58.647]                               next
[18:00:58.647]                             if (!grepl(pattern, name)) 
[18:00:58.647]                               next
[18:00:58.647]                             invokeRestart(restart)
[18:00:58.647]                             muffled <- TRUE
[18:00:58.647]                             break
[18:00:58.647]                           }
[18:00:58.647]                         }
[18:00:58.647]                       }
[18:00:58.647]                       invisible(muffled)
[18:00:58.647]                     }
[18:00:58.647]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.647]                   }
[18:00:58.647]                 }
[18:00:58.647]                 else {
[18:00:58.647]                   if (TRUE) {
[18:00:58.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.647]                     {
[18:00:58.647]                       inherits <- base::inherits
[18:00:58.647]                       invokeRestart <- base::invokeRestart
[18:00:58.647]                       is.null <- base::is.null
[18:00:58.647]                       muffled <- FALSE
[18:00:58.647]                       if (inherits(cond, "message")) {
[18:00:58.647]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.647]                         if (muffled) 
[18:00:58.647]                           invokeRestart("muffleMessage")
[18:00:58.647]                       }
[18:00:58.647]                       else if (inherits(cond, "warning")) {
[18:00:58.647]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.647]                         if (muffled) 
[18:00:58.647]                           invokeRestart("muffleWarning")
[18:00:58.647]                       }
[18:00:58.647]                       else if (inherits(cond, "condition")) {
[18:00:58.647]                         if (!is.null(pattern)) {
[18:00:58.647]                           computeRestarts <- base::computeRestarts
[18:00:58.647]                           grepl <- base::grepl
[18:00:58.647]                           restarts <- computeRestarts(cond)
[18:00:58.647]                           for (restart in restarts) {
[18:00:58.647]                             name <- restart$name
[18:00:58.647]                             if (is.null(name)) 
[18:00:58.647]                               next
[18:00:58.647]                             if (!grepl(pattern, name)) 
[18:00:58.647]                               next
[18:00:58.647]                             invokeRestart(restart)
[18:00:58.647]                             muffled <- TRUE
[18:00:58.647]                             break
[18:00:58.647]                           }
[18:00:58.647]                         }
[18:00:58.647]                       }
[18:00:58.647]                       invisible(muffled)
[18:00:58.647]                     }
[18:00:58.647]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.647]                   }
[18:00:58.647]                 }
[18:00:58.647]             }
[18:00:58.647]         }))
[18:00:58.647]     }, error = function(ex) {
[18:00:58.647]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.647]                 ...future.rng), started = ...future.startTime, 
[18:00:58.647]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.647]             version = "1.8"), class = "FutureResult")
[18:00:58.647]     }, finally = {
[18:00:58.647]         if (!identical(...future.workdir, getwd())) 
[18:00:58.647]             setwd(...future.workdir)
[18:00:58.647]         {
[18:00:58.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.647]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.647]             }
[18:00:58.647]             base::options(...future.oldOptions)
[18:00:58.647]             if (.Platform$OS.type == "windows") {
[18:00:58.647]                 old_names <- names(...future.oldEnvVars)
[18:00:58.647]                 envs <- base::Sys.getenv()
[18:00:58.647]                 names <- names(envs)
[18:00:58.647]                 common <- intersect(names, old_names)
[18:00:58.647]                 added <- setdiff(names, old_names)
[18:00:58.647]                 removed <- setdiff(old_names, names)
[18:00:58.647]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.647]                   envs[common]]
[18:00:58.647]                 NAMES <- toupper(changed)
[18:00:58.647]                 args <- list()
[18:00:58.647]                 for (kk in seq_along(NAMES)) {
[18:00:58.647]                   name <- changed[[kk]]
[18:00:58.647]                   NAME <- NAMES[[kk]]
[18:00:58.647]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.647]                     next
[18:00:58.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.647]                 }
[18:00:58.647]                 NAMES <- toupper(added)
[18:00:58.647]                 for (kk in seq_along(NAMES)) {
[18:00:58.647]                   name <- added[[kk]]
[18:00:58.647]                   NAME <- NAMES[[kk]]
[18:00:58.647]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.647]                     next
[18:00:58.647]                   args[[name]] <- ""
[18:00:58.647]                 }
[18:00:58.647]                 NAMES <- toupper(removed)
[18:00:58.647]                 for (kk in seq_along(NAMES)) {
[18:00:58.647]                   name <- removed[[kk]]
[18:00:58.647]                   NAME <- NAMES[[kk]]
[18:00:58.647]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.647]                     next
[18:00:58.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.647]                 }
[18:00:58.647]                 if (length(args) > 0) 
[18:00:58.647]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.647]             }
[18:00:58.647]             else {
[18:00:58.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.647]             }
[18:00:58.647]             {
[18:00:58.647]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.647]                   0L) {
[18:00:58.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.647]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.647]                   base::options(opts)
[18:00:58.647]                 }
[18:00:58.647]                 {
[18:00:58.647]                   {
[18:00:58.647]                     base::assign(".Random.seed", c(10407L, 276891767L, 
[18:00:58.647]                     833447509L, -344040774L, 1423455687L, -2113572702L, 
[18:00:58.647]                     704118981L), envir = base::globalenv(), inherits = FALSE)
[18:00:58.647]                     NULL
[18:00:58.647]                   }
[18:00:58.647]                   options(future.plan = NULL)
[18:00:58.647]                   if (is.na(NA_character_)) 
[18:00:58.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.647]                     .init = FALSE)
[18:00:58.647]                 }
[18:00:58.647]             }
[18:00:58.647]         }
[18:00:58.647]     })
[18:00:58.647]     if (TRUE) {
[18:00:58.647]         base::sink(type = "output", split = FALSE)
[18:00:58.647]         if (TRUE) {
[18:00:58.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.647]         }
[18:00:58.647]         else {
[18:00:58.647]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.647]         }
[18:00:58.647]         base::close(...future.stdout)
[18:00:58.647]         ...future.stdout <- NULL
[18:00:58.647]     }
[18:00:58.647]     ...future.result$conditions <- ...future.conditions
[18:00:58.647]     ...future.result$finished <- base::Sys.time()
[18:00:58.647]     ...future.result
[18:00:58.647] }
[18:00:58.650] assign_globals() ...
[18:00:58.650] List of 5
[18:00:58.650]  $ ...future.FUN            :function (x, y)  
[18:00:58.650]  $ MoreArgs                 :List of 1
[18:00:58.650]   ..$ y: int [1:2] 3 4
[18:00:58.650]  $ ...future.elements_ii    :List of 1
[18:00:58.650]   ..$ x:List of 2
[18:00:58.650]   .. ..$ : int 1
[18:00:58.650]   .. ..$ : int 2
[18:00:58.650]  $ ...future.seeds_ii       : NULL
[18:00:58.650]  $ ...future.globals.maxSize: NULL
[18:00:58.650]  - attr(*, "where")=List of 5
[18:00:58.650]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.650]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.650]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.650]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.650]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.650]  - attr(*, "resolved")= logi FALSE
[18:00:58.650]  - attr(*, "total_size")= num 1872
[18:00:58.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.650]  - attr(*, "already-done")= logi TRUE
[18:00:58.661] - reassign environment for ‘...future.FUN’
[18:00:58.661] - copied ‘...future.FUN’ to environment
[18:00:58.661] - copied ‘MoreArgs’ to environment
[18:00:58.661] - copied ‘...future.elements_ii’ to environment
[18:00:58.662] - copied ‘...future.seeds_ii’ to environment
[18:00:58.662] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.662] assign_globals() ... done
[18:00:58.662] plan(): Setting new future strategy stack:
[18:00:58.663] List of future strategies:
[18:00:58.663] 1. sequential:
[18:00:58.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.663]    - tweaked: FALSE
[18:00:58.663]    - call: NULL
[18:00:58.664] plan(): nbrOfWorkers() = 1
[18:00:58.665] plan(): Setting new future strategy stack:
[18:00:58.665] List of future strategies:
[18:00:58.665] 1. sequential:
[18:00:58.665]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.665]    - tweaked: FALSE
[18:00:58.665]    - call: plan(strategy)
[18:00:58.666] plan(): nbrOfWorkers() = 1
[18:00:58.666] SequentialFuture started (and completed)
[18:00:58.667] - Launch lazy future ... done
[18:00:58.667] run() for ‘SequentialFuture’ ... done
[18:00:58.667] Created future:
[18:00:58.667] SequentialFuture:
[18:00:58.667] Label: ‘future_.mapply-1’
[18:00:58.667] Expression:
[18:00:58.667] {
[18:00:58.667]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.667]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.667]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.667]         on.exit(options(oopts), add = TRUE)
[18:00:58.667]     }
[18:00:58.667]     {
[18:00:58.667]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.667]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.667]         do.call(mapply, args = args)
[18:00:58.667]     }
[18:00:58.667] }
[18:00:58.667] Lazy evaluation: FALSE
[18:00:58.667] Asynchronous evaluation: FALSE
[18:00:58.667] Local evaluation: TRUE
[18:00:58.667] Environment: R_GlobalEnv
[18:00:58.667] Capture standard output: TRUE
[18:00:58.667] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.667] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.667] Packages: <none>
[18:00:58.667] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.667] Resolved: TRUE
[18:00:58.667] Value: 112 bytes of class ‘list’
[18:00:58.667] Early signaling: FALSE
[18:00:58.667] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.667] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.669] Chunk #1 of 1 ... DONE
[18:00:58.669] Launching 1 futures (chunks) ... DONE
[18:00:58.669] Resolving 1 futures (chunks) ...
[18:00:58.670] resolve() on list ...
[18:00:58.670]  recursive: 0
[18:00:58.670]  length: 1
[18:00:58.670] 
[18:00:58.670] resolved() for ‘SequentialFuture’ ...
[18:00:58.671] - state: ‘finished’
[18:00:58.671] - run: TRUE
[18:00:58.671] - result: ‘FutureResult’
[18:00:58.671] resolved() for ‘SequentialFuture’ ... done
[18:00:58.671] Future #1
[18:00:58.672] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.672] - nx: 1
[18:00:58.672] - relay: TRUE
[18:00:58.672] - stdout: TRUE
[18:00:58.672] - signal: TRUE
[18:00:58.673] - resignal: FALSE
[18:00:58.673] - force: TRUE
[18:00:58.673] - relayed: [n=1] FALSE
[18:00:58.673] - queued futures: [n=1] FALSE
[18:00:58.673]  - until=1
[18:00:58.674]  - relaying element #1
[18:00:58.674] - relayed: [n=1] TRUE
[18:00:58.674] - queued futures: [n=1] TRUE
[18:00:58.674] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.675]  length: 0 (resolved future 1)
[18:00:58.675] Relaying remaining futures
[18:00:58.675] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.675] - nx: 1
[18:00:58.675] - relay: TRUE
[18:00:58.675] - stdout: TRUE
[18:00:58.676] - signal: TRUE
[18:00:58.676] - resignal: FALSE
[18:00:58.676] - force: TRUE
[18:00:58.676] - relayed: [n=1] TRUE
[18:00:58.676] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.677] - relayed: [n=1] TRUE
[18:00:58.677] - queued futures: [n=1] TRUE
[18:00:58.677] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.677] resolve() on list ... DONE
[18:00:58.677]  - Number of value chunks collected: 1
[18:00:58.678] Resolving 1 futures (chunks) ... DONE
[18:00:58.678] Reducing values from 1 chunks ...
[18:00:58.678]  - Number of values collected after concatenation: 2
[18:00:58.678]  - Number of values expected: 2
[18:00:58.678] Reducing values from 1 chunks ... DONE
[18:00:58.679] future_mapply() ... DONE
- Recycle arguments to same length ...
[18:00:58.679] future_mapply() ...
[18:00:58.679] Number of chunks: 1
[18:00:58.680] getGlobalsAndPackagesXApply() ...
[18:00:58.680]  - future.globals: TRUE
[18:00:58.680] getGlobalsAndPackages() ...
[18:00:58.680] Searching for globals...
[18:00:58.681] - globals found: [1] ‘FUN’
[18:00:58.681] Searching for globals ... DONE
[18:00:58.682] Resolving globals: FALSE
[18:00:58.685] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:58.685] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:58.686] - globals: [1] ‘FUN’
[18:00:58.686] 
[18:00:58.686] getGlobalsAndPackages() ... DONE
[18:00:58.686]  - globals found/used: [n=1] ‘FUN’
[18:00:58.686]  - needed namespaces: [n=0] 
[18:00:58.687] Finding globals ... DONE
[18:00:58.687] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.687] List of 2
[18:00:58.687]  $ ...future.FUN:function (x, ...)  
[18:00:58.687]  $ MoreArgs     : NULL
[18:00:58.687]  - attr(*, "where")=List of 2
[18:00:58.687]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.687]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.687]  - attr(*, "resolved")= logi FALSE
[18:00:58.687]  - attr(*, "total_size")= num NA
[18:00:58.692] Packages to be attached in all futures: [n=0] 
[18:00:58.692] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.693] Number of futures (= number of chunks): 1
[18:00:58.693] Launching 1 futures (chunks) ...
[18:00:58.693] Chunk #1 of 1 ...
[18:00:58.693]  - Finding globals in '...' for chunk #1 ...
[18:00:58.694] getGlobalsAndPackages() ...
[18:00:58.694] Searching for globals...
[18:00:58.695] 
[18:00:58.695] Searching for globals ... DONE
[18:00:58.695] - globals: [0] <none>
[18:00:58.695] getGlobalsAndPackages() ... DONE
[18:00:58.695]    + additional globals found: [n=0] 
[18:00:58.695]    + additional namespaces needed: [n=0] 
[18:00:58.696]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.696]  - seeds: <none>
[18:00:58.696]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.696] getGlobalsAndPackages() ...
[18:00:58.696] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.697] Resolving globals: FALSE
[18:00:58.698] The total size of the 5 globals is 504 bytes (504 bytes)
[18:00:58.699] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.699] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.699] 
[18:00:58.699] getGlobalsAndPackages() ... DONE
[18:00:58.700] run() for ‘Future’ ...
[18:00:58.700] - state: ‘created’
[18:00:58.700] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.701] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.701]   - Field: ‘label’
[18:00:58.701]   - Field: ‘local’
[18:00:58.702]   - Field: ‘owner’
[18:00:58.702]   - Field: ‘envir’
[18:00:58.702]   - Field: ‘packages’
[18:00:58.702]   - Field: ‘gc’
[18:00:58.702]   - Field: ‘conditions’
[18:00:58.703]   - Field: ‘expr’
[18:00:58.703]   - Field: ‘uuid’
[18:00:58.703]   - Field: ‘seed’
[18:00:58.703]   - Field: ‘version’
[18:00:58.703]   - Field: ‘result’
[18:00:58.704]   - Field: ‘asynchronous’
[18:00:58.704]   - Field: ‘calls’
[18:00:58.704]   - Field: ‘globals’
[18:00:58.704]   - Field: ‘stdout’
[18:00:58.704]   - Field: ‘earlySignal’
[18:00:58.705]   - Field: ‘lazy’
[18:00:58.705]   - Field: ‘state’
[18:00:58.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.705] - Launch lazy future ...
[18:00:58.705] Packages needed by the future expression (n = 0): <none>
[18:00:58.706] Packages needed by future strategies (n = 0): <none>
[18:00:58.707] {
[18:00:58.707]     {
[18:00:58.707]         {
[18:00:58.707]             ...future.startTime <- base::Sys.time()
[18:00:58.707]             {
[18:00:58.707]                 {
[18:00:58.707]                   {
[18:00:58.707]                     base::local({
[18:00:58.707]                       has_future <- base::requireNamespace("future", 
[18:00:58.707]                         quietly = TRUE)
[18:00:58.707]                       if (has_future) {
[18:00:58.707]                         ns <- base::getNamespace("future")
[18:00:58.707]                         version <- ns[[".package"]][["version"]]
[18:00:58.707]                         if (is.null(version)) 
[18:00:58.707]                           version <- utils::packageVersion("future")
[18:00:58.707]                       }
[18:00:58.707]                       else {
[18:00:58.707]                         version <- NULL
[18:00:58.707]                       }
[18:00:58.707]                       if (!has_future || version < "1.8.0") {
[18:00:58.707]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.707]                           "", base::R.version$version.string), 
[18:00:58.707]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.707]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.707]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.707]                             "release", "version")], collapse = " "), 
[18:00:58.707]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.707]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.707]                           info)
[18:00:58.707]                         info <- base::paste(info, collapse = "; ")
[18:00:58.707]                         if (!has_future) {
[18:00:58.707]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.707]                             info)
[18:00:58.707]                         }
[18:00:58.707]                         else {
[18:00:58.707]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.707]                             info, version)
[18:00:58.707]                         }
[18:00:58.707]                         base::stop(msg)
[18:00:58.707]                       }
[18:00:58.707]                     })
[18:00:58.707]                   }
[18:00:58.707]                   ...future.strategy.old <- future::plan("list")
[18:00:58.707]                   options(future.plan = NULL)
[18:00:58.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.707]                 }
[18:00:58.707]                 ...future.workdir <- getwd()
[18:00:58.707]             }
[18:00:58.707]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.707]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.707]         }
[18:00:58.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.707]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.707]             base::names(...future.oldOptions))
[18:00:58.707]     }
[18:00:58.707]     if (FALSE) {
[18:00:58.707]     }
[18:00:58.707]     else {
[18:00:58.707]         if (TRUE) {
[18:00:58.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.707]                 open = "w")
[18:00:58.707]         }
[18:00:58.707]         else {
[18:00:58.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.707]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.707]         }
[18:00:58.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.707]             base::sink(type = "output", split = FALSE)
[18:00:58.707]             base::close(...future.stdout)
[18:00:58.707]         }, add = TRUE)
[18:00:58.707]     }
[18:00:58.707]     ...future.frame <- base::sys.nframe()
[18:00:58.707]     ...future.conditions <- base::list()
[18:00:58.707]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.707]     if (FALSE) {
[18:00:58.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.707]     }
[18:00:58.707]     ...future.result <- base::tryCatch({
[18:00:58.707]         base::withCallingHandlers({
[18:00:58.707]             ...future.value <- base::withVisible(base::local({
[18:00:58.707]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.707]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.707]                   ...future.globals.maxSize)) {
[18:00:58.707]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.707]                   on.exit(options(oopts), add = TRUE)
[18:00:58.707]                 }
[18:00:58.707]                 {
[18:00:58.707]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.707]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.707]                     USE.NAMES = FALSE)
[18:00:58.707]                   do.call(mapply, args = args)
[18:00:58.707]                 }
[18:00:58.707]             }))
[18:00:58.707]             future::FutureResult(value = ...future.value$value, 
[18:00:58.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.707]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.707]                     ...future.globalenv.names))
[18:00:58.707]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.707]         }, condition = base::local({
[18:00:58.707]             c <- base::c
[18:00:58.707]             inherits <- base::inherits
[18:00:58.707]             invokeRestart <- base::invokeRestart
[18:00:58.707]             length <- base::length
[18:00:58.707]             list <- base::list
[18:00:58.707]             seq.int <- base::seq.int
[18:00:58.707]             signalCondition <- base::signalCondition
[18:00:58.707]             sys.calls <- base::sys.calls
[18:00:58.707]             `[[` <- base::`[[`
[18:00:58.707]             `+` <- base::`+`
[18:00:58.707]             `<<-` <- base::`<<-`
[18:00:58.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.707]                   3L)]
[18:00:58.707]             }
[18:00:58.707]             function(cond) {
[18:00:58.707]                 is_error <- inherits(cond, "error")
[18:00:58.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.707]                   NULL)
[18:00:58.707]                 if (is_error) {
[18:00:58.707]                   sessionInformation <- function() {
[18:00:58.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.707]                       search = base::search(), system = base::Sys.info())
[18:00:58.707]                   }
[18:00:58.707]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.707]                     cond$call), session = sessionInformation(), 
[18:00:58.707]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.707]                   signalCondition(cond)
[18:00:58.707]                 }
[18:00:58.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.707]                 "immediateCondition"))) {
[18:00:58.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.707]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.707]                   if (TRUE && !signal) {
[18:00:58.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.707]                     {
[18:00:58.707]                       inherits <- base::inherits
[18:00:58.707]                       invokeRestart <- base::invokeRestart
[18:00:58.707]                       is.null <- base::is.null
[18:00:58.707]                       muffled <- FALSE
[18:00:58.707]                       if (inherits(cond, "message")) {
[18:00:58.707]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.707]                         if (muffled) 
[18:00:58.707]                           invokeRestart("muffleMessage")
[18:00:58.707]                       }
[18:00:58.707]                       else if (inherits(cond, "warning")) {
[18:00:58.707]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.707]                         if (muffled) 
[18:00:58.707]                           invokeRestart("muffleWarning")
[18:00:58.707]                       }
[18:00:58.707]                       else if (inherits(cond, "condition")) {
[18:00:58.707]                         if (!is.null(pattern)) {
[18:00:58.707]                           computeRestarts <- base::computeRestarts
[18:00:58.707]                           grepl <- base::grepl
[18:00:58.707]                           restarts <- computeRestarts(cond)
[18:00:58.707]                           for (restart in restarts) {
[18:00:58.707]                             name <- restart$name
[18:00:58.707]                             if (is.null(name)) 
[18:00:58.707]                               next
[18:00:58.707]                             if (!grepl(pattern, name)) 
[18:00:58.707]                               next
[18:00:58.707]                             invokeRestart(restart)
[18:00:58.707]                             muffled <- TRUE
[18:00:58.707]                             break
[18:00:58.707]                           }
[18:00:58.707]                         }
[18:00:58.707]                       }
[18:00:58.707]                       invisible(muffled)
[18:00:58.707]                     }
[18:00:58.707]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.707]                   }
[18:00:58.707]                 }
[18:00:58.707]                 else {
[18:00:58.707]                   if (TRUE) {
[18:00:58.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.707]                     {
[18:00:58.707]                       inherits <- base::inherits
[18:00:58.707]                       invokeRestart <- base::invokeRestart
[18:00:58.707]                       is.null <- base::is.null
[18:00:58.707]                       muffled <- FALSE
[18:00:58.707]                       if (inherits(cond, "message")) {
[18:00:58.707]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.707]                         if (muffled) 
[18:00:58.707]                           invokeRestart("muffleMessage")
[18:00:58.707]                       }
[18:00:58.707]                       else if (inherits(cond, "warning")) {
[18:00:58.707]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.707]                         if (muffled) 
[18:00:58.707]                           invokeRestart("muffleWarning")
[18:00:58.707]                       }
[18:00:58.707]                       else if (inherits(cond, "condition")) {
[18:00:58.707]                         if (!is.null(pattern)) {
[18:00:58.707]                           computeRestarts <- base::computeRestarts
[18:00:58.707]                           grepl <- base::grepl
[18:00:58.707]                           restarts <- computeRestarts(cond)
[18:00:58.707]                           for (restart in restarts) {
[18:00:58.707]                             name <- restart$name
[18:00:58.707]                             if (is.null(name)) 
[18:00:58.707]                               next
[18:00:58.707]                             if (!grepl(pattern, name)) 
[18:00:58.707]                               next
[18:00:58.707]                             invokeRestart(restart)
[18:00:58.707]                             muffled <- TRUE
[18:00:58.707]                             break
[18:00:58.707]                           }
[18:00:58.707]                         }
[18:00:58.707]                       }
[18:00:58.707]                       invisible(muffled)
[18:00:58.707]                     }
[18:00:58.707]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.707]                   }
[18:00:58.707]                 }
[18:00:58.707]             }
[18:00:58.707]         }))
[18:00:58.707]     }, error = function(ex) {
[18:00:58.707]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.707]                 ...future.rng), started = ...future.startTime, 
[18:00:58.707]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.707]             version = "1.8"), class = "FutureResult")
[18:00:58.707]     }, finally = {
[18:00:58.707]         if (!identical(...future.workdir, getwd())) 
[18:00:58.707]             setwd(...future.workdir)
[18:00:58.707]         {
[18:00:58.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.707]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.707]             }
[18:00:58.707]             base::options(...future.oldOptions)
[18:00:58.707]             if (.Platform$OS.type == "windows") {
[18:00:58.707]                 old_names <- names(...future.oldEnvVars)
[18:00:58.707]                 envs <- base::Sys.getenv()
[18:00:58.707]                 names <- names(envs)
[18:00:58.707]                 common <- intersect(names, old_names)
[18:00:58.707]                 added <- setdiff(names, old_names)
[18:00:58.707]                 removed <- setdiff(old_names, names)
[18:00:58.707]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.707]                   envs[common]]
[18:00:58.707]                 NAMES <- toupper(changed)
[18:00:58.707]                 args <- list()
[18:00:58.707]                 for (kk in seq_along(NAMES)) {
[18:00:58.707]                   name <- changed[[kk]]
[18:00:58.707]                   NAME <- NAMES[[kk]]
[18:00:58.707]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.707]                     next
[18:00:58.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.707]                 }
[18:00:58.707]                 NAMES <- toupper(added)
[18:00:58.707]                 for (kk in seq_along(NAMES)) {
[18:00:58.707]                   name <- added[[kk]]
[18:00:58.707]                   NAME <- NAMES[[kk]]
[18:00:58.707]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.707]                     next
[18:00:58.707]                   args[[name]] <- ""
[18:00:58.707]                 }
[18:00:58.707]                 NAMES <- toupper(removed)
[18:00:58.707]                 for (kk in seq_along(NAMES)) {
[18:00:58.707]                   name <- removed[[kk]]
[18:00:58.707]                   NAME <- NAMES[[kk]]
[18:00:58.707]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.707]                     next
[18:00:58.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.707]                 }
[18:00:58.707]                 if (length(args) > 0) 
[18:00:58.707]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.707]             }
[18:00:58.707]             else {
[18:00:58.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.707]             }
[18:00:58.707]             {
[18:00:58.707]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.707]                   0L) {
[18:00:58.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.707]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.707]                   base::options(opts)
[18:00:58.707]                 }
[18:00:58.707]                 {
[18:00:58.707]                   {
[18:00:58.707]                     base::assign(".Random.seed", c(10407L, 276891767L, 
[18:00:58.707]                     833447509L, -344040774L, 1423455687L, -2113572702L, 
[18:00:58.707]                     704118981L), envir = base::globalenv(), inherits = FALSE)
[18:00:58.707]                     NULL
[18:00:58.707]                   }
[18:00:58.707]                   options(future.plan = NULL)
[18:00:58.707]                   if (is.na(NA_character_)) 
[18:00:58.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.707]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.707]                     .init = FALSE)
[18:00:58.707]                 }
[18:00:58.707]             }
[18:00:58.707]         }
[18:00:58.707]     })
[18:00:58.707]     if (TRUE) {
[18:00:58.707]         base::sink(type = "output", split = FALSE)
[18:00:58.707]         if (TRUE) {
[18:00:58.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.707]         }
[18:00:58.707]         else {
[18:00:58.707]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.707]         }
[18:00:58.707]         base::close(...future.stdout)
[18:00:58.707]         ...future.stdout <- NULL
[18:00:58.707]     }
[18:00:58.707]     ...future.result$conditions <- ...future.conditions
[18:00:58.707]     ...future.result$finished <- base::Sys.time()
[18:00:58.707]     ...future.result
[18:00:58.707] }
[18:00:58.710] assign_globals() ...
[18:00:58.710] List of 5
[18:00:58.710]  $ ...future.FUN            :function (x, ...)  
[18:00:58.710]  $ MoreArgs                 : NULL
[18:00:58.710]  $ ...future.elements_ii    :List of 2
[18:00:58.710]   ..$ :List of 4
[18:00:58.710]   .. ..$ : int 1
[18:00:58.710]   .. ..$ : int 2
[18:00:58.710]   .. ..$ : int 3
[18:00:58.710]   .. ..$ : int 4
[18:00:58.710]   ..$ :List of 4
[18:00:58.710]   .. ..$ : int 2
[18:00:58.710]   .. ..$ : int 1
[18:00:58.710]   .. ..$ : int 2
[18:00:58.710]   .. ..$ : int 1
[18:00:58.710]  $ ...future.seeds_ii       : NULL
[18:00:58.710]  $ ...future.globals.maxSize: NULL
[18:00:58.710]  - attr(*, "where")=List of 5
[18:00:58.710]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.710]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.710]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.710]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.710]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.710]  - attr(*, "resolved")= logi FALSE
[18:00:58.710]  - attr(*, "total_size")= num 504
[18:00:58.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.710]  - attr(*, "already-done")= logi TRUE
[18:00:58.724] - copied ‘...future.FUN’ to environment
[18:00:58.724] - copied ‘MoreArgs’ to environment
[18:00:58.724] - copied ‘...future.elements_ii’ to environment
[18:00:58.725] - copied ‘...future.seeds_ii’ to environment
[18:00:58.725] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.725] assign_globals() ... done
[18:00:58.726] plan(): Setting new future strategy stack:
[18:00:58.726] List of future strategies:
[18:00:58.726] 1. sequential:
[18:00:58.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.726]    - tweaked: FALSE
[18:00:58.726]    - call: NULL
[18:00:58.727] plan(): nbrOfWorkers() = 1
[18:00:58.728] plan(): Setting new future strategy stack:
[18:00:58.728] List of future strategies:
[18:00:58.728] 1. sequential:
[18:00:58.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.728]    - tweaked: FALSE
[18:00:58.728]    - call: plan(strategy)
[18:00:58.729] plan(): nbrOfWorkers() = 1
[18:00:58.729] SequentialFuture started (and completed)
[18:00:58.730] - Launch lazy future ... done
[18:00:58.730] run() for ‘SequentialFuture’ ... done
[18:00:58.730] Created future:
[18:00:58.730] SequentialFuture:
[18:00:58.730] Label: ‘future_mapply-1’
[18:00:58.730] Expression:
[18:00:58.730] {
[18:00:58.730]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.730]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.730]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.730]         on.exit(options(oopts), add = TRUE)
[18:00:58.730]     }
[18:00:58.730]     {
[18:00:58.730]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.730]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.730]         do.call(mapply, args = args)
[18:00:58.730]     }
[18:00:58.730] }
[18:00:58.730] Lazy evaluation: FALSE
[18:00:58.730] Asynchronous evaluation: FALSE
[18:00:58.730] Local evaluation: TRUE
[18:00:58.730] Environment: R_GlobalEnv
[18:00:58.730] Capture standard output: TRUE
[18:00:58.730] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.730] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.730] Packages: <none>
[18:00:58.730] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.730] Resolved: TRUE
[18:00:58.730] Value: 224 bytes of class ‘list’
[18:00:58.730] Early signaling: FALSE
[18:00:58.730] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.730] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.735] Chunk #1 of 1 ... DONE
[18:00:58.735] Launching 1 futures (chunks) ... DONE
[18:00:58.735] Resolving 1 futures (chunks) ...
[18:00:58.735] resolve() on list ...
[18:00:58.736]  recursive: 0
[18:00:58.736]  length: 1
[18:00:58.736] 
[18:00:58.736] resolved() for ‘SequentialFuture’ ...
[18:00:58.736] - state: ‘finished’
[18:00:58.737] - run: TRUE
[18:00:58.737] - result: ‘FutureResult’
[18:00:58.737] resolved() for ‘SequentialFuture’ ... done
[18:00:58.737] Future #1
[18:00:58.738] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.738] - nx: 1
[18:00:58.738] - relay: TRUE
[18:00:58.738] - stdout: TRUE
[18:00:58.738] - signal: TRUE
[18:00:58.738] - resignal: FALSE
[18:00:58.739] - force: TRUE
[18:00:58.739] - relayed: [n=1] FALSE
[18:00:58.739] - queued futures: [n=1] FALSE
[18:00:58.739]  - until=1
[18:00:58.739]  - relaying element #1
[18:00:58.740] - relayed: [n=1] TRUE
[18:00:58.740] - queued futures: [n=1] TRUE
[18:00:58.740] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.740]  length: 0 (resolved future 1)
[18:00:58.741] Relaying remaining futures
[18:00:58.741] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.741] - nx: 1
[18:00:58.741] - relay: TRUE
[18:00:58.741] - stdout: TRUE
[18:00:58.741] - signal: TRUE
[18:00:58.742] - resignal: FALSE
[18:00:58.742] - force: TRUE
[18:00:58.742] - relayed: [n=1] TRUE
[18:00:58.742] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.742] - relayed: [n=1] TRUE
[18:00:58.743] - queued futures: [n=1] TRUE
[18:00:58.743] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.743] resolve() on list ... DONE
[18:00:58.743]  - Number of value chunks collected: 1
[18:00:58.743] Resolving 1 futures (chunks) ... DONE
[18:00:58.744] Reducing values from 1 chunks ...
[18:00:58.744]  - Number of values collected after concatenation: 4
[18:00:58.744]  - Number of values expected: 4
[18:00:58.744] Reducing values from 1 chunks ... DONE
[18:00:58.744] future_mapply() ... DONE
- Parallel RNG ...
[18:00:58.745] future_mapply() ...
[18:00:58.745] Generating random seeds ...
[18:00:58.745] Generating random seed streams for 4 elements ...
[18:00:58.745] Generating random seed streams for 4 elements ... DONE
[18:00:58.746] Generating random seeds ... DONE
[18:00:58.746] Will set RNG state on exit: 10407, -344040774, -204610152, 1158254433, 704118981, -968951431, 1592730962
[18:00:58.746] Number of chunks: 1
[18:00:58.746] getGlobalsAndPackagesXApply() ...
[18:00:58.746]  - future.globals: TRUE
[18:00:58.747] getGlobalsAndPackages() ...
[18:00:58.747] Searching for globals...
[18:00:58.749] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[18:00:58.750] Searching for globals ... DONE
[18:00:58.750] Resolving globals: FALSE
[18:00:58.751] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[18:00:58.751] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[18:00:58.752] - globals: [1] ‘FUN’
[18:00:58.752] - packages: [1] ‘stats’
[18:00:58.752] getGlobalsAndPackages() ... DONE
[18:00:58.752]  - globals found/used: [n=1] ‘FUN’
[18:00:58.752]  - needed namespaces: [n=1] ‘stats’
[18:00:58.753] Finding globals ... DONE
[18:00:58.753] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.753] List of 2
[18:00:58.753]  $ ...future.FUN:function (n, min = 0, max = 1)  
[18:00:58.753]  $ MoreArgs     :List of 1
[18:00:58.753]   ..$ min: num 1
[18:00:58.753]  - attr(*, "where")=List of 2
[18:00:58.753]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.753]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.753]  - attr(*, "resolved")= logi FALSE
[18:00:58.753]  - attr(*, "total_size")= num NA
[18:00:58.759] Packages to be attached in all futures: [n=1] ‘stats’
[18:00:58.759] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.759] Number of futures (= number of chunks): 1
[18:00:58.760] Launching 1 futures (chunks) ...
[18:00:58.760] Chunk #1 of 1 ...
[18:00:58.760]  - Finding globals in '...' for chunk #1 ...
[18:00:58.760] getGlobalsAndPackages() ...
[18:00:58.760] Searching for globals...
[18:00:58.761] 
[18:00:58.761] Searching for globals ... DONE
[18:00:58.762] - globals: [0] <none>
[18:00:58.762] getGlobalsAndPackages() ... DONE
[18:00:58.762]    + additional globals found: [n=0] 
[18:00:58.762]    + additional namespaces needed: [n=0] 
[18:00:58.762]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.762]  - seeds: [4] <seeds>
[18:00:58.763]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.763] getGlobalsAndPackages() ...
[18:00:58.763] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.763] Resolving globals: FALSE
[18:00:58.764] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[18:00:58.765] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[18:00:58.766] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.766] - packages: [1] ‘stats’
[18:00:58.766] getGlobalsAndPackages() ... DONE
[18:00:58.767] run() for ‘Future’ ...
[18:00:58.767] - state: ‘created’
[18:00:58.767] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.768]   - Field: ‘label’
[18:00:58.768]   - Field: ‘local’
[18:00:58.769]   - Field: ‘owner’
[18:00:58.769]   - Field: ‘envir’
[18:00:58.769]   - Field: ‘packages’
[18:00:58.769]   - Field: ‘gc’
[18:00:58.769]   - Field: ‘conditions’
[18:00:58.770]   - Field: ‘expr’
[18:00:58.770]   - Field: ‘uuid’
[18:00:58.770]   - Field: ‘seed’
[18:00:58.770]   - Field: ‘version’
[18:00:58.770]   - Field: ‘result’
[18:00:58.771]   - Field: ‘asynchronous’
[18:00:58.771]   - Field: ‘calls’
[18:00:58.771]   - Field: ‘globals’
[18:00:58.771]   - Field: ‘stdout’
[18:00:58.771]   - Field: ‘earlySignal’
[18:00:58.772]   - Field: ‘lazy’
[18:00:58.772]   - Field: ‘state’
[18:00:58.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.772] - Launch lazy future ...
[18:00:58.772] Packages needed by the future expression (n = 1): ‘stats’
[18:00:58.773] Packages needed by future strategies (n = 0): <none>
[18:00:58.774] {
[18:00:58.774]     {
[18:00:58.774]         {
[18:00:58.774]             ...future.startTime <- base::Sys.time()
[18:00:58.774]             {
[18:00:58.774]                 {
[18:00:58.774]                   {
[18:00:58.774]                     {
[18:00:58.774]                       base::local({
[18:00:58.774]                         has_future <- base::requireNamespace("future", 
[18:00:58.774]                           quietly = TRUE)
[18:00:58.774]                         if (has_future) {
[18:00:58.774]                           ns <- base::getNamespace("future")
[18:00:58.774]                           version <- ns[[".package"]][["version"]]
[18:00:58.774]                           if (is.null(version)) 
[18:00:58.774]                             version <- utils::packageVersion("future")
[18:00:58.774]                         }
[18:00:58.774]                         else {
[18:00:58.774]                           version <- NULL
[18:00:58.774]                         }
[18:00:58.774]                         if (!has_future || version < "1.8.0") {
[18:00:58.774]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.774]                             "", base::R.version$version.string), 
[18:00:58.774]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:58.774]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.774]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.774]                               "release", "version")], collapse = " "), 
[18:00:58.774]                             hostname = base::Sys.info()[["nodename"]])
[18:00:58.774]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.774]                             info)
[18:00:58.774]                           info <- base::paste(info, collapse = "; ")
[18:00:58.774]                           if (!has_future) {
[18:00:58.774]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.774]                               info)
[18:00:58.774]                           }
[18:00:58.774]                           else {
[18:00:58.774]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.774]                               info, version)
[18:00:58.774]                           }
[18:00:58.774]                           base::stop(msg)
[18:00:58.774]                         }
[18:00:58.774]                       })
[18:00:58.774]                     }
[18:00:58.774]                     base::local({
[18:00:58.774]                       for (pkg in "stats") {
[18:00:58.774]                         base::loadNamespace(pkg)
[18:00:58.774]                         base::library(pkg, character.only = TRUE)
[18:00:58.774]                       }
[18:00:58.774]                     })
[18:00:58.774]                   }
[18:00:58.774]                   ...future.strategy.old <- future::plan("list")
[18:00:58.774]                   options(future.plan = NULL)
[18:00:58.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.774]                 }
[18:00:58.774]                 ...future.workdir <- getwd()
[18:00:58.774]             }
[18:00:58.774]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.774]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.774]         }
[18:00:58.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.774]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.774]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.774]             base::names(...future.oldOptions))
[18:00:58.774]     }
[18:00:58.774]     if (FALSE) {
[18:00:58.774]     }
[18:00:58.774]     else {
[18:00:58.774]         if (TRUE) {
[18:00:58.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.774]                 open = "w")
[18:00:58.774]         }
[18:00:58.774]         else {
[18:00:58.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.774]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.774]         }
[18:00:58.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.774]             base::sink(type = "output", split = FALSE)
[18:00:58.774]             base::close(...future.stdout)
[18:00:58.774]         }, add = TRUE)
[18:00:58.774]     }
[18:00:58.774]     ...future.frame <- base::sys.nframe()
[18:00:58.774]     ...future.conditions <- base::list()
[18:00:58.774]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.774]     if (FALSE) {
[18:00:58.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.774]     }
[18:00:58.774]     ...future.result <- base::tryCatch({
[18:00:58.774]         base::withCallingHandlers({
[18:00:58.774]             ...future.value <- base::withVisible(base::local({
[18:00:58.774]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.774]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.774]                   ...future.globals.maxSize)) {
[18:00:58.774]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.774]                   on.exit(options(oopts), add = TRUE)
[18:00:58.774]                 }
[18:00:58.774]                 {
[18:00:58.774]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:00:58.774]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[18:00:58.774]                       envir = globalenv(), inherits = FALSE)
[18:00:58.774]                     ...future.FUN(...)
[18:00:58.774]                   }
[18:00:58.774]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:00:58.774]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:00:58.774]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.774]                     USE.NAMES = FALSE)
[18:00:58.774]                   do.call(mapply, args = args)
[18:00:58.774]                 }
[18:00:58.774]             }))
[18:00:58.774]             future::FutureResult(value = ...future.value$value, 
[18:00:58.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.774]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.774]                     ...future.globalenv.names))
[18:00:58.774]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.774]         }, condition = base::local({
[18:00:58.774]             c <- base::c
[18:00:58.774]             inherits <- base::inherits
[18:00:58.774]             invokeRestart <- base::invokeRestart
[18:00:58.774]             length <- base::length
[18:00:58.774]             list <- base::list
[18:00:58.774]             seq.int <- base::seq.int
[18:00:58.774]             signalCondition <- base::signalCondition
[18:00:58.774]             sys.calls <- base::sys.calls
[18:00:58.774]             `[[` <- base::`[[`
[18:00:58.774]             `+` <- base::`+`
[18:00:58.774]             `<<-` <- base::`<<-`
[18:00:58.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.774]                   3L)]
[18:00:58.774]             }
[18:00:58.774]             function(cond) {
[18:00:58.774]                 is_error <- inherits(cond, "error")
[18:00:58.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.774]                   NULL)
[18:00:58.774]                 if (is_error) {
[18:00:58.774]                   sessionInformation <- function() {
[18:00:58.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.774]                       search = base::search(), system = base::Sys.info())
[18:00:58.774]                   }
[18:00:58.774]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.774]                     cond$call), session = sessionInformation(), 
[18:00:58.774]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.774]                   signalCondition(cond)
[18:00:58.774]                 }
[18:00:58.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.774]                 "immediateCondition"))) {
[18:00:58.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.774]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.774]                   if (TRUE && !signal) {
[18:00:58.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.774]                     {
[18:00:58.774]                       inherits <- base::inherits
[18:00:58.774]                       invokeRestart <- base::invokeRestart
[18:00:58.774]                       is.null <- base::is.null
[18:00:58.774]                       muffled <- FALSE
[18:00:58.774]                       if (inherits(cond, "message")) {
[18:00:58.774]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.774]                         if (muffled) 
[18:00:58.774]                           invokeRestart("muffleMessage")
[18:00:58.774]                       }
[18:00:58.774]                       else if (inherits(cond, "warning")) {
[18:00:58.774]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.774]                         if (muffled) 
[18:00:58.774]                           invokeRestart("muffleWarning")
[18:00:58.774]                       }
[18:00:58.774]                       else if (inherits(cond, "condition")) {
[18:00:58.774]                         if (!is.null(pattern)) {
[18:00:58.774]                           computeRestarts <- base::computeRestarts
[18:00:58.774]                           grepl <- base::grepl
[18:00:58.774]                           restarts <- computeRestarts(cond)
[18:00:58.774]                           for (restart in restarts) {
[18:00:58.774]                             name <- restart$name
[18:00:58.774]                             if (is.null(name)) 
[18:00:58.774]                               next
[18:00:58.774]                             if (!grepl(pattern, name)) 
[18:00:58.774]                               next
[18:00:58.774]                             invokeRestart(restart)
[18:00:58.774]                             muffled <- TRUE
[18:00:58.774]                             break
[18:00:58.774]                           }
[18:00:58.774]                         }
[18:00:58.774]                       }
[18:00:58.774]                       invisible(muffled)
[18:00:58.774]                     }
[18:00:58.774]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.774]                   }
[18:00:58.774]                 }
[18:00:58.774]                 else {
[18:00:58.774]                   if (TRUE) {
[18:00:58.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.774]                     {
[18:00:58.774]                       inherits <- base::inherits
[18:00:58.774]                       invokeRestart <- base::invokeRestart
[18:00:58.774]                       is.null <- base::is.null
[18:00:58.774]                       muffled <- FALSE
[18:00:58.774]                       if (inherits(cond, "message")) {
[18:00:58.774]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.774]                         if (muffled) 
[18:00:58.774]                           invokeRestart("muffleMessage")
[18:00:58.774]                       }
[18:00:58.774]                       else if (inherits(cond, "warning")) {
[18:00:58.774]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.774]                         if (muffled) 
[18:00:58.774]                           invokeRestart("muffleWarning")
[18:00:58.774]                       }
[18:00:58.774]                       else if (inherits(cond, "condition")) {
[18:00:58.774]                         if (!is.null(pattern)) {
[18:00:58.774]                           computeRestarts <- base::computeRestarts
[18:00:58.774]                           grepl <- base::grepl
[18:00:58.774]                           restarts <- computeRestarts(cond)
[18:00:58.774]                           for (restart in restarts) {
[18:00:58.774]                             name <- restart$name
[18:00:58.774]                             if (is.null(name)) 
[18:00:58.774]                               next
[18:00:58.774]                             if (!grepl(pattern, name)) 
[18:00:58.774]                               next
[18:00:58.774]                             invokeRestart(restart)
[18:00:58.774]                             muffled <- TRUE
[18:00:58.774]                             break
[18:00:58.774]                           }
[18:00:58.774]                         }
[18:00:58.774]                       }
[18:00:58.774]                       invisible(muffled)
[18:00:58.774]                     }
[18:00:58.774]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.774]                   }
[18:00:58.774]                 }
[18:00:58.774]             }
[18:00:58.774]         }))
[18:00:58.774]     }, error = function(ex) {
[18:00:58.774]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.774]                 ...future.rng), started = ...future.startTime, 
[18:00:58.774]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.774]             version = "1.8"), class = "FutureResult")
[18:00:58.774]     }, finally = {
[18:00:58.774]         if (!identical(...future.workdir, getwd())) 
[18:00:58.774]             setwd(...future.workdir)
[18:00:58.774]         {
[18:00:58.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.774]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.774]             }
[18:00:58.774]             base::options(...future.oldOptions)
[18:00:58.774]             if (.Platform$OS.type == "windows") {
[18:00:58.774]                 old_names <- names(...future.oldEnvVars)
[18:00:58.774]                 envs <- base::Sys.getenv()
[18:00:58.774]                 names <- names(envs)
[18:00:58.774]                 common <- intersect(names, old_names)
[18:00:58.774]                 added <- setdiff(names, old_names)
[18:00:58.774]                 removed <- setdiff(old_names, names)
[18:00:58.774]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.774]                   envs[common]]
[18:00:58.774]                 NAMES <- toupper(changed)
[18:00:58.774]                 args <- list()
[18:00:58.774]                 for (kk in seq_along(NAMES)) {
[18:00:58.774]                   name <- changed[[kk]]
[18:00:58.774]                   NAME <- NAMES[[kk]]
[18:00:58.774]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.774]                     next
[18:00:58.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.774]                 }
[18:00:58.774]                 NAMES <- toupper(added)
[18:00:58.774]                 for (kk in seq_along(NAMES)) {
[18:00:58.774]                   name <- added[[kk]]
[18:00:58.774]                   NAME <- NAMES[[kk]]
[18:00:58.774]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.774]                     next
[18:00:58.774]                   args[[name]] <- ""
[18:00:58.774]                 }
[18:00:58.774]                 NAMES <- toupper(removed)
[18:00:58.774]                 for (kk in seq_along(NAMES)) {
[18:00:58.774]                   name <- removed[[kk]]
[18:00:58.774]                   NAME <- NAMES[[kk]]
[18:00:58.774]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.774]                     next
[18:00:58.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.774]                 }
[18:00:58.774]                 if (length(args) > 0) 
[18:00:58.774]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.774]             }
[18:00:58.774]             else {
[18:00:58.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.774]             }
[18:00:58.774]             {
[18:00:58.774]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.774]                   0L) {
[18:00:58.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.774]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.774]                   base::options(opts)
[18:00:58.774]                 }
[18:00:58.774]                 {
[18:00:58.774]                   {
[18:00:58.774]                     base::assign(".Random.seed", c(10407L, -344040774L, 
[18:00:58.774]                     -204610152L, 1158254433L, 704118981L, -968951431L, 
[18:00:58.774]                     1592730962L), envir = base::globalenv(), 
[18:00:58.774]                       inherits = FALSE)
[18:00:58.774]                     NULL
[18:00:58.774]                   }
[18:00:58.774]                   options(future.plan = NULL)
[18:00:58.774]                   if (is.na(NA_character_)) 
[18:00:58.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.774]                     .init = FALSE)
[18:00:58.774]                 }
[18:00:58.774]             }
[18:00:58.774]         }
[18:00:58.774]     })
[18:00:58.774]     if (TRUE) {
[18:00:58.774]         base::sink(type = "output", split = FALSE)
[18:00:58.774]         if (TRUE) {
[18:00:58.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.774]         }
[18:00:58.774]         else {
[18:00:58.774]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.774]         }
[18:00:58.774]         base::close(...future.stdout)
[18:00:58.774]         ...future.stdout <- NULL
[18:00:58.774]     }
[18:00:58.774]     ...future.result$conditions <- ...future.conditions
[18:00:58.774]     ...future.result$finished <- base::Sys.time()
[18:00:58.774]     ...future.result
[18:00:58.774] }
[18:00:58.777] assign_globals() ...
[18:00:58.777] List of 5
[18:00:58.777]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[18:00:58.777]  $ MoreArgs                 :List of 1
[18:00:58.777]   ..$ min: num 1
[18:00:58.777]  $ ...future.elements_ii    :List of 2
[18:00:58.777]   ..$ n  :List of 4
[18:00:58.777]   .. ..$ : int 1
[18:00:58.777]   .. ..$ : int 2
[18:00:58.777]   .. ..$ : int 3
[18:00:58.777]   .. ..$ : int 4
[18:00:58.777]   ..$ max:List of 4
[18:00:58.777]   .. ..$ : int 2
[18:00:58.777]   .. ..$ : int 3
[18:00:58.777]   .. ..$ : int 4
[18:00:58.777]   .. ..$ : int 5
[18:00:58.777]  $ ...future.seeds_ii       :List of 4
[18:00:58.777]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[18:00:58.777]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[18:00:58.777]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[18:00:58.777]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[18:00:58.777]  $ ...future.globals.maxSize: NULL
[18:00:58.777]  - attr(*, "where")=List of 5
[18:00:58.777]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.777]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.777]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.777]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.777]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.777]  - attr(*, "resolved")= logi FALSE
[18:00:58.777]  - attr(*, "total_size")= num 2912
[18:00:58.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.777]  - attr(*, "already-done")= logi TRUE
[18:00:58.798] - copied ‘...future.FUN’ to environment
[18:00:58.798] - copied ‘MoreArgs’ to environment
[18:00:58.798] - copied ‘...future.elements_ii’ to environment
[18:00:58.798] - copied ‘...future.seeds_ii’ to environment
[18:00:58.799] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.799] assign_globals() ... done
[18:00:58.800] plan(): Setting new future strategy stack:
[18:00:58.800] List of future strategies:
[18:00:58.800] 1. sequential:
[18:00:58.800]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.800]    - tweaked: FALSE
[18:00:58.800]    - call: NULL
[18:00:58.801] plan(): nbrOfWorkers() = 1
[18:00:58.803] plan(): Setting new future strategy stack:
[18:00:58.803] List of future strategies:
[18:00:58.803] 1. sequential:
[18:00:58.803]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.803]    - tweaked: FALSE
[18:00:58.803]    - call: plan(strategy)
[18:00:58.804] plan(): nbrOfWorkers() = 1
[18:00:58.804] SequentialFuture started (and completed)
[18:00:58.804] - Launch lazy future ... done
[18:00:58.804] run() for ‘SequentialFuture’ ... done
[18:00:58.805] Created future:
[18:00:58.805] SequentialFuture:
[18:00:58.805] Label: ‘future_mapply-1’
[18:00:58.805] Expression:
[18:00:58.805] {
[18:00:58.805]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.805]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.805]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.805]         on.exit(options(oopts), add = TRUE)
[18:00:58.805]     }
[18:00:58.805]     {
[18:00:58.805]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:00:58.805]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:00:58.805]                 inherits = FALSE)
[18:00:58.805]             ...future.FUN(...)
[18:00:58.805]         }
[18:00:58.805]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:00:58.805]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:00:58.805]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.805]         do.call(mapply, args = args)
[18:00:58.805]     }
[18:00:58.805] }
[18:00:58.805] Lazy evaluation: FALSE
[18:00:58.805] Asynchronous evaluation: FALSE
[18:00:58.805] Local evaluation: TRUE
[18:00:58.805] Environment: R_GlobalEnv
[18:00:58.805] Capture standard output: TRUE
[18:00:58.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.805] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.805] Packages: 1 packages (‘stats’)
[18:00:58.805] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:00:58.805] Resolved: TRUE
[18:00:58.805] Value: 280 bytes of class ‘list’
[18:00:58.805] Early signaling: FALSE
[18:00:58.805] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.805] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.807] Chunk #1 of 1 ... DONE
[18:00:58.807] Launching 1 futures (chunks) ... DONE
[18:00:58.807] Resolving 1 futures (chunks) ...
[18:00:58.807] resolve() on list ...
[18:00:58.808]  recursive: 0
[18:00:58.808]  length: 1
[18:00:58.808] 
[18:00:58.808] resolved() for ‘SequentialFuture’ ...
[18:00:58.808] - state: ‘finished’
[18:00:58.809] - run: TRUE
[18:00:58.809] - result: ‘FutureResult’
[18:00:58.809] resolved() for ‘SequentialFuture’ ... done
[18:00:58.809] Future #1
[18:00:58.810] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.810] - nx: 1
[18:00:58.810] - relay: TRUE
[18:00:58.810] - stdout: TRUE
[18:00:58.810] - signal: TRUE
[18:00:58.810] - resignal: FALSE
[18:00:58.811] - force: TRUE
[18:00:58.811] - relayed: [n=1] FALSE
[18:00:58.811] - queued futures: [n=1] FALSE
[18:00:58.811]  - until=1
[18:00:58.811]  - relaying element #1
[18:00:58.812] - relayed: [n=1] TRUE
[18:00:58.812] - queued futures: [n=1] TRUE
[18:00:58.812] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.812]  length: 0 (resolved future 1)
[18:00:58.813] Relaying remaining futures
[18:00:58.813] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.813] - nx: 1
[18:00:58.813] - relay: TRUE
[18:00:58.813] - stdout: TRUE
[18:00:58.814] - signal: TRUE
[18:00:58.814] - resignal: FALSE
[18:00:58.814] - force: TRUE
[18:00:58.814] - relayed: [n=1] TRUE
[18:00:58.814] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.815] - relayed: [n=1] TRUE
[18:00:58.815] - queued futures: [n=1] TRUE
[18:00:58.815] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.815] resolve() on list ... DONE
[18:00:58.815]  - Number of value chunks collected: 1
[18:00:58.816] Resolving 1 futures (chunks) ... DONE
[18:00:58.816] Reducing values from 1 chunks ...
[18:00:58.816]  - Number of values collected after concatenation: 4
[18:00:58.816]  - Number of values expected: 4
[18:00:58.816] Reducing values from 1 chunks ... DONE
[18:00:58.817] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[18:00:58.821] future_mapply() ...
[18:00:58.822] Number of chunks: 1
[18:00:58.822] getGlobalsAndPackagesXApply() ...
[18:00:58.822]  - future.globals: TRUE
[18:00:58.822] getGlobalsAndPackages() ...
[18:00:58.823] Searching for globals...
[18:00:58.825] - globals found: [2] ‘FUN’, ‘UseMethod’
[18:00:58.825] Searching for globals ... DONE
[18:00:58.825] Resolving globals: FALSE
[18:00:58.826] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[18:00:58.830] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[18:00:58.830] - globals: [1] ‘FUN’
[18:00:58.830] - packages: [1] ‘stats’
[18:00:58.831] getGlobalsAndPackages() ... DONE
[18:00:58.831]  - globals found/used: [n=1] ‘FUN’
[18:00:58.831]  - needed namespaces: [n=1] ‘stats’
[18:00:58.831] Finding globals ... DONE
[18:00:58.832] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.832] List of 2
[18:00:58.832]  $ ...future.FUN:function (x, w, ...)  
[18:00:58.832]  $ MoreArgs     : NULL
[18:00:58.832]  - attr(*, "where")=List of 2
[18:00:58.832]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.832]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.832]  - attr(*, "resolved")= logi FALSE
[18:00:58.832]  - attr(*, "total_size")= num NA
[18:00:58.838] Packages to be attached in all futures: [n=1] ‘stats’
[18:00:58.838] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.838] Number of futures (= number of chunks): 1
[18:00:58.839] Launching 1 futures (chunks) ...
[18:00:58.839] Chunk #1 of 1 ...
[18:00:58.839]  - Finding globals in '...' for chunk #1 ...
[18:00:58.839] getGlobalsAndPackages() ...
[18:00:58.839] Searching for globals...
[18:00:58.840] 
[18:00:58.840] Searching for globals ... DONE
[18:00:58.841] - globals: [0] <none>
[18:00:58.841] getGlobalsAndPackages() ... DONE
[18:00:58.841]    + additional globals found: [n=0] 
[18:00:58.841]    + additional namespaces needed: [n=0] 
[18:00:58.841]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.842]  - seeds: <none>
[18:00:58.842]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.842] getGlobalsAndPackages() ...
[18:00:58.842] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.842] Resolving globals: FALSE
[18:00:58.843] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[18:00:58.844] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.845] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.845] - packages: [1] ‘stats’
[18:00:58.845] getGlobalsAndPackages() ... DONE
[18:00:58.846] run() for ‘Future’ ...
[18:00:58.846] - state: ‘created’
[18:00:58.846] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.847] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.847]   - Field: ‘label’
[18:00:58.847]   - Field: ‘local’
[18:00:58.848]   - Field: ‘owner’
[18:00:58.848]   - Field: ‘envir’
[18:00:58.848]   - Field: ‘packages’
[18:00:58.848]   - Field: ‘gc’
[18:00:58.848]   - Field: ‘conditions’
[18:00:58.849]   - Field: ‘expr’
[18:00:58.849]   - Field: ‘uuid’
[18:00:58.849]   - Field: ‘seed’
[18:00:58.849]   - Field: ‘version’
[18:00:58.849]   - Field: ‘result’
[18:00:58.849]   - Field: ‘asynchronous’
[18:00:58.850]   - Field: ‘calls’
[18:00:58.850]   - Field: ‘globals’
[18:00:58.850]   - Field: ‘stdout’
[18:00:58.850]   - Field: ‘earlySignal’
[18:00:58.850]   - Field: ‘lazy’
[18:00:58.851]   - Field: ‘state’
[18:00:58.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.851] - Launch lazy future ...
[18:00:58.851] Packages needed by the future expression (n = 1): ‘stats’
[18:00:58.852] Packages needed by future strategies (n = 0): <none>
[18:00:58.853] {
[18:00:58.853]     {
[18:00:58.853]         {
[18:00:58.853]             ...future.startTime <- base::Sys.time()
[18:00:58.853]             {
[18:00:58.853]                 {
[18:00:58.853]                   {
[18:00:58.853]                     {
[18:00:58.853]                       base::local({
[18:00:58.853]                         has_future <- base::requireNamespace("future", 
[18:00:58.853]                           quietly = TRUE)
[18:00:58.853]                         if (has_future) {
[18:00:58.853]                           ns <- base::getNamespace("future")
[18:00:58.853]                           version <- ns[[".package"]][["version"]]
[18:00:58.853]                           if (is.null(version)) 
[18:00:58.853]                             version <- utils::packageVersion("future")
[18:00:58.853]                         }
[18:00:58.853]                         else {
[18:00:58.853]                           version <- NULL
[18:00:58.853]                         }
[18:00:58.853]                         if (!has_future || version < "1.8.0") {
[18:00:58.853]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.853]                             "", base::R.version$version.string), 
[18:00:58.853]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:58.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.853]                               "release", "version")], collapse = " "), 
[18:00:58.853]                             hostname = base::Sys.info()[["nodename"]])
[18:00:58.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.853]                             info)
[18:00:58.853]                           info <- base::paste(info, collapse = "; ")
[18:00:58.853]                           if (!has_future) {
[18:00:58.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.853]                               info)
[18:00:58.853]                           }
[18:00:58.853]                           else {
[18:00:58.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.853]                               info, version)
[18:00:58.853]                           }
[18:00:58.853]                           base::stop(msg)
[18:00:58.853]                         }
[18:00:58.853]                       })
[18:00:58.853]                     }
[18:00:58.853]                     base::local({
[18:00:58.853]                       for (pkg in "stats") {
[18:00:58.853]                         base::loadNamespace(pkg)
[18:00:58.853]                         base::library(pkg, character.only = TRUE)
[18:00:58.853]                       }
[18:00:58.853]                     })
[18:00:58.853]                   }
[18:00:58.853]                   ...future.strategy.old <- future::plan("list")
[18:00:58.853]                   options(future.plan = NULL)
[18:00:58.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.853]                 }
[18:00:58.853]                 ...future.workdir <- getwd()
[18:00:58.853]             }
[18:00:58.853]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.853]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.853]         }
[18:00:58.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.853]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.853]             base::names(...future.oldOptions))
[18:00:58.853]     }
[18:00:58.853]     if (FALSE) {
[18:00:58.853]     }
[18:00:58.853]     else {
[18:00:58.853]         if (TRUE) {
[18:00:58.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.853]                 open = "w")
[18:00:58.853]         }
[18:00:58.853]         else {
[18:00:58.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.853]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.853]         }
[18:00:58.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.853]             base::sink(type = "output", split = FALSE)
[18:00:58.853]             base::close(...future.stdout)
[18:00:58.853]         }, add = TRUE)
[18:00:58.853]     }
[18:00:58.853]     ...future.frame <- base::sys.nframe()
[18:00:58.853]     ...future.conditions <- base::list()
[18:00:58.853]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.853]     if (FALSE) {
[18:00:58.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.853]     }
[18:00:58.853]     ...future.result <- base::tryCatch({
[18:00:58.853]         base::withCallingHandlers({
[18:00:58.853]             ...future.value <- base::withVisible(base::local({
[18:00:58.853]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.853]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.853]                   ...future.globals.maxSize)) {
[18:00:58.853]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.853]                   on.exit(options(oopts), add = TRUE)
[18:00:58.853]                 }
[18:00:58.853]                 {
[18:00:58.853]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.853]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.853]                     USE.NAMES = FALSE)
[18:00:58.853]                   do.call(mapply, args = args)
[18:00:58.853]                 }
[18:00:58.853]             }))
[18:00:58.853]             future::FutureResult(value = ...future.value$value, 
[18:00:58.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.853]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.853]                     ...future.globalenv.names))
[18:00:58.853]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.853]         }, condition = base::local({
[18:00:58.853]             c <- base::c
[18:00:58.853]             inherits <- base::inherits
[18:00:58.853]             invokeRestart <- base::invokeRestart
[18:00:58.853]             length <- base::length
[18:00:58.853]             list <- base::list
[18:00:58.853]             seq.int <- base::seq.int
[18:00:58.853]             signalCondition <- base::signalCondition
[18:00:58.853]             sys.calls <- base::sys.calls
[18:00:58.853]             `[[` <- base::`[[`
[18:00:58.853]             `+` <- base::`+`
[18:00:58.853]             `<<-` <- base::`<<-`
[18:00:58.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.853]                   3L)]
[18:00:58.853]             }
[18:00:58.853]             function(cond) {
[18:00:58.853]                 is_error <- inherits(cond, "error")
[18:00:58.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.853]                   NULL)
[18:00:58.853]                 if (is_error) {
[18:00:58.853]                   sessionInformation <- function() {
[18:00:58.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.853]                       search = base::search(), system = base::Sys.info())
[18:00:58.853]                   }
[18:00:58.853]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.853]                     cond$call), session = sessionInformation(), 
[18:00:58.853]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.853]                   signalCondition(cond)
[18:00:58.853]                 }
[18:00:58.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.853]                 "immediateCondition"))) {
[18:00:58.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.853]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.853]                   if (TRUE && !signal) {
[18:00:58.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.853]                     {
[18:00:58.853]                       inherits <- base::inherits
[18:00:58.853]                       invokeRestart <- base::invokeRestart
[18:00:58.853]                       is.null <- base::is.null
[18:00:58.853]                       muffled <- FALSE
[18:00:58.853]                       if (inherits(cond, "message")) {
[18:00:58.853]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.853]                         if (muffled) 
[18:00:58.853]                           invokeRestart("muffleMessage")
[18:00:58.853]                       }
[18:00:58.853]                       else if (inherits(cond, "warning")) {
[18:00:58.853]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.853]                         if (muffled) 
[18:00:58.853]                           invokeRestart("muffleWarning")
[18:00:58.853]                       }
[18:00:58.853]                       else if (inherits(cond, "condition")) {
[18:00:58.853]                         if (!is.null(pattern)) {
[18:00:58.853]                           computeRestarts <- base::computeRestarts
[18:00:58.853]                           grepl <- base::grepl
[18:00:58.853]                           restarts <- computeRestarts(cond)
[18:00:58.853]                           for (restart in restarts) {
[18:00:58.853]                             name <- restart$name
[18:00:58.853]                             if (is.null(name)) 
[18:00:58.853]                               next
[18:00:58.853]                             if (!grepl(pattern, name)) 
[18:00:58.853]                               next
[18:00:58.853]                             invokeRestart(restart)
[18:00:58.853]                             muffled <- TRUE
[18:00:58.853]                             break
[18:00:58.853]                           }
[18:00:58.853]                         }
[18:00:58.853]                       }
[18:00:58.853]                       invisible(muffled)
[18:00:58.853]                     }
[18:00:58.853]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.853]                   }
[18:00:58.853]                 }
[18:00:58.853]                 else {
[18:00:58.853]                   if (TRUE) {
[18:00:58.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.853]                     {
[18:00:58.853]                       inherits <- base::inherits
[18:00:58.853]                       invokeRestart <- base::invokeRestart
[18:00:58.853]                       is.null <- base::is.null
[18:00:58.853]                       muffled <- FALSE
[18:00:58.853]                       if (inherits(cond, "message")) {
[18:00:58.853]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.853]                         if (muffled) 
[18:00:58.853]                           invokeRestart("muffleMessage")
[18:00:58.853]                       }
[18:00:58.853]                       else if (inherits(cond, "warning")) {
[18:00:58.853]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.853]                         if (muffled) 
[18:00:58.853]                           invokeRestart("muffleWarning")
[18:00:58.853]                       }
[18:00:58.853]                       else if (inherits(cond, "condition")) {
[18:00:58.853]                         if (!is.null(pattern)) {
[18:00:58.853]                           computeRestarts <- base::computeRestarts
[18:00:58.853]                           grepl <- base::grepl
[18:00:58.853]                           restarts <- computeRestarts(cond)
[18:00:58.853]                           for (restart in restarts) {
[18:00:58.853]                             name <- restart$name
[18:00:58.853]                             if (is.null(name)) 
[18:00:58.853]                               next
[18:00:58.853]                             if (!grepl(pattern, name)) 
[18:00:58.853]                               next
[18:00:58.853]                             invokeRestart(restart)
[18:00:58.853]                             muffled <- TRUE
[18:00:58.853]                             break
[18:00:58.853]                           }
[18:00:58.853]                         }
[18:00:58.853]                       }
[18:00:58.853]                       invisible(muffled)
[18:00:58.853]                     }
[18:00:58.853]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.853]                   }
[18:00:58.853]                 }
[18:00:58.853]             }
[18:00:58.853]         }))
[18:00:58.853]     }, error = function(ex) {
[18:00:58.853]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.853]                 ...future.rng), started = ...future.startTime, 
[18:00:58.853]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.853]             version = "1.8"), class = "FutureResult")
[18:00:58.853]     }, finally = {
[18:00:58.853]         if (!identical(...future.workdir, getwd())) 
[18:00:58.853]             setwd(...future.workdir)
[18:00:58.853]         {
[18:00:58.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.853]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.853]             }
[18:00:58.853]             base::options(...future.oldOptions)
[18:00:58.853]             if (.Platform$OS.type == "windows") {
[18:00:58.853]                 old_names <- names(...future.oldEnvVars)
[18:00:58.853]                 envs <- base::Sys.getenv()
[18:00:58.853]                 names <- names(envs)
[18:00:58.853]                 common <- intersect(names, old_names)
[18:00:58.853]                 added <- setdiff(names, old_names)
[18:00:58.853]                 removed <- setdiff(old_names, names)
[18:00:58.853]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.853]                   envs[common]]
[18:00:58.853]                 NAMES <- toupper(changed)
[18:00:58.853]                 args <- list()
[18:00:58.853]                 for (kk in seq_along(NAMES)) {
[18:00:58.853]                   name <- changed[[kk]]
[18:00:58.853]                   NAME <- NAMES[[kk]]
[18:00:58.853]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.853]                     next
[18:00:58.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.853]                 }
[18:00:58.853]                 NAMES <- toupper(added)
[18:00:58.853]                 for (kk in seq_along(NAMES)) {
[18:00:58.853]                   name <- added[[kk]]
[18:00:58.853]                   NAME <- NAMES[[kk]]
[18:00:58.853]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.853]                     next
[18:00:58.853]                   args[[name]] <- ""
[18:00:58.853]                 }
[18:00:58.853]                 NAMES <- toupper(removed)
[18:00:58.853]                 for (kk in seq_along(NAMES)) {
[18:00:58.853]                   name <- removed[[kk]]
[18:00:58.853]                   NAME <- NAMES[[kk]]
[18:00:58.853]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.853]                     next
[18:00:58.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.853]                 }
[18:00:58.853]                 if (length(args) > 0) 
[18:00:58.853]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.853]             }
[18:00:58.853]             else {
[18:00:58.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.853]             }
[18:00:58.853]             {
[18:00:58.853]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.853]                   0L) {
[18:00:58.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.853]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.853]                   base::options(opts)
[18:00:58.853]                 }
[18:00:58.853]                 {
[18:00:58.853]                   {
[18:00:58.853]                     base::assign(".Random.seed", c(10407L, 567452142L, 
[18:00:58.853]                     1421140261L, 1045937781L, 1233976574L, -322649955L, 
[18:00:58.853]                     -65150472L), envir = base::globalenv(), inherits = FALSE)
[18:00:58.853]                     NULL
[18:00:58.853]                   }
[18:00:58.853]                   options(future.plan = NULL)
[18:00:58.853]                   if (is.na(NA_character_)) 
[18:00:58.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.853]                     .init = FALSE)
[18:00:58.853]                 }
[18:00:58.853]             }
[18:00:58.853]         }
[18:00:58.853]     })
[18:00:58.853]     if (TRUE) {
[18:00:58.853]         base::sink(type = "output", split = FALSE)
[18:00:58.853]         if (TRUE) {
[18:00:58.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.853]         }
[18:00:58.853]         else {
[18:00:58.853]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.853]         }
[18:00:58.853]         base::close(...future.stdout)
[18:00:58.853]         ...future.stdout <- NULL
[18:00:58.853]     }
[18:00:58.853]     ...future.result$conditions <- ...future.conditions
[18:00:58.853]     ...future.result$finished <- base::Sys.time()
[18:00:58.853]     ...future.result
[18:00:58.853] }
[18:00:58.856] assign_globals() ...
[18:00:58.856] List of 5
[18:00:58.856]  $ ...future.FUN            :function (x, w, ...)  
[18:00:58.856]  $ MoreArgs                 : NULL
[18:00:58.856]  $ ...future.elements_ii    :List of 2
[18:00:58.856]   ..$ :List of 5
[18:00:58.856]   .. ..$ : num [1:10] 0.4359 0.3287 0.0688 0.3424 0.4445 ...
[18:00:58.856]   .. ..$ : num [1:10] 0.253 0.537 0.164 0.236 0.952 ...
[18:00:58.856]   .. ..$ : num [1:10] 0.4984 0.0416 0.3266 0.918 0.0263 ...
[18:00:58.856]   .. ..$ : num [1:10] 0.1102 0.8672 0.6969 0.0932 0.91 ...
[18:00:58.856]   .. ..$ : num [1:10] 0.851 0.219 0.625 0.937 0.304 ...
[18:00:58.856]   ..$ :List of 5
[18:00:58.856]   .. ..$ : num [1:10] 8 9 5 2 3 6 5 4 5 8
[18:00:58.856]   .. ..$ : num [1:10] 7 9 7 6 8 10 8 8 2 5
[18:00:58.856]   .. ..$ : num [1:10] 12 4 7 4 6 8 10 4 5 9
[18:00:58.856]   .. ..$ : num [1:10] 4 3 3 4 5 9 8 5 6 7
[18:00:58.856]   .. ..$ : num [1:10] 5 4 4 6 6 10 10 8 5 4
[18:00:58.856]  $ ...future.seeds_ii       : NULL
[18:00:58.856]  $ ...future.globals.maxSize: NULL
[18:00:58.856]  - attr(*, "where")=List of 5
[18:00:58.856]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.856]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.856]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.856]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.856]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.856]  - attr(*, "resolved")= logi FALSE
[18:00:58.856]  - attr(*, "total_size")= num 3176
[18:00:58.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.856]  - attr(*, "already-done")= logi TRUE
[18:00:58.872] - copied ‘...future.FUN’ to environment
[18:00:58.872] - copied ‘MoreArgs’ to environment
[18:00:58.873] - copied ‘...future.elements_ii’ to environment
[18:00:58.873] - copied ‘...future.seeds_ii’ to environment
[18:00:58.873] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.873] assign_globals() ... done
[18:00:58.874] plan(): Setting new future strategy stack:
[18:00:58.874] List of future strategies:
[18:00:58.874] 1. sequential:
[18:00:58.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.874]    - tweaked: FALSE
[18:00:58.874]    - call: NULL
[18:00:58.875] plan(): nbrOfWorkers() = 1
[18:00:58.879] plan(): Setting new future strategy stack:
[18:00:58.879] List of future strategies:
[18:00:58.879] 1. sequential:
[18:00:58.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.879]    - tweaked: FALSE
[18:00:58.879]    - call: plan(strategy)
[18:00:58.880] plan(): nbrOfWorkers() = 1
[18:00:58.881] SequentialFuture started (and completed)
[18:00:58.881] - Launch lazy future ... done
[18:00:58.881] run() for ‘SequentialFuture’ ... done
[18:00:58.882] Created future:
[18:00:58.882] SequentialFuture:
[18:00:58.882] Label: ‘future_Map-1’
[18:00:58.882] Expression:
[18:00:58.882] {
[18:00:58.882]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.882]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.882]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.882]         on.exit(options(oopts), add = TRUE)
[18:00:58.882]     }
[18:00:58.882]     {
[18:00:58.882]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.882]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.882]         do.call(mapply, args = args)
[18:00:58.882]     }
[18:00:58.882] }
[18:00:58.882] Lazy evaluation: FALSE
[18:00:58.882] Asynchronous evaluation: FALSE
[18:00:58.882] Local evaluation: TRUE
[18:00:58.882] Environment: R_GlobalEnv
[18:00:58.882] Capture standard output: TRUE
[18:00:58.882] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.882] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.882] Packages: 1 packages (‘stats’)
[18:00:58.882] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.882] Resolved: TRUE
[18:00:58.882] Value: 280 bytes of class ‘list’
[18:00:58.882] Early signaling: FALSE
[18:00:58.882] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.882] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.884] Chunk #1 of 1 ... DONE
[18:00:58.884] Launching 1 futures (chunks) ... DONE
[18:00:58.884] Resolving 1 futures (chunks) ...
[18:00:58.884] resolve() on list ...
[18:00:58.884]  recursive: 0
[18:00:58.885]  length: 1
[18:00:58.885] 
[18:00:58.885] resolved() for ‘SequentialFuture’ ...
[18:00:58.885] - state: ‘finished’
[18:00:58.885] - run: TRUE
[18:00:58.886] - result: ‘FutureResult’
[18:00:58.886] resolved() for ‘SequentialFuture’ ... done
[18:00:58.886] Future #1
[18:00:58.886] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.887] - nx: 1
[18:00:58.887] - relay: TRUE
[18:00:58.887] - stdout: TRUE
[18:00:58.887] - signal: TRUE
[18:00:58.887] - resignal: FALSE
[18:00:58.887] - force: TRUE
[18:00:58.888] - relayed: [n=1] FALSE
[18:00:58.888] - queued futures: [n=1] FALSE
[18:00:58.888]  - until=1
[18:00:58.888]  - relaying element #1
[18:00:58.889] - relayed: [n=1] TRUE
[18:00:58.889] - queued futures: [n=1] TRUE
[18:00:58.889] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.889]  length: 0 (resolved future 1)
[18:00:58.889] Relaying remaining futures
[18:00:58.889] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.890] - nx: 1
[18:00:58.890] - relay: TRUE
[18:00:58.890] - stdout: TRUE
[18:00:58.890] - signal: TRUE
[18:00:58.890] - resignal: FALSE
[18:00:58.890] - force: TRUE
[18:00:58.891] - relayed: [n=1] TRUE
[18:00:58.891] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.891] - relayed: [n=1] TRUE
[18:00:58.891] - queued futures: [n=1] TRUE
[18:00:58.891] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.892] resolve() on list ... DONE
[18:00:58.892]  - Number of value chunks collected: 1
[18:00:58.892] Resolving 1 futures (chunks) ... DONE
[18:00:58.892] Reducing values from 1 chunks ...
[18:00:58.893]  - Number of values collected after concatenation: 5
[18:00:58.893]  - Number of values expected: 5
[18:00:58.893] Reducing values from 1 chunks ... DONE
[18:00:58.893] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[18:00:58.897] future_mapply() ...
[18:00:58.897] Number of chunks: 1
[18:00:58.897] getGlobalsAndPackagesXApply() ...
[18:00:58.897]  - future.globals: TRUE
[18:00:58.898] getGlobalsAndPackages() ...
[18:00:58.898] Searching for globals...
[18:00:58.899] - globals found: [1] ‘FUN’
[18:00:58.899] Searching for globals ... DONE
[18:00:58.899] Resolving globals: FALSE
[18:00:58.900] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:58.901] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:58.901] - globals: [1] ‘FUN’
[18:00:58.901] 
[18:00:58.901] getGlobalsAndPackages() ... DONE
[18:00:58.901]  - globals found/used: [n=1] ‘FUN’
[18:00:58.902]  - needed namespaces: [n=0] 
[18:00:58.902] Finding globals ... DONE
[18:00:58.902] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.902] List of 2
[18:00:58.902]  $ ...future.FUN:function (e1, e2)  
[18:00:58.902]  $ MoreArgs     : NULL
[18:00:58.902]  - attr(*, "where")=List of 2
[18:00:58.902]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.902]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.902]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.902]  - attr(*, "resolved")= logi FALSE
[18:00:58.902]  - attr(*, "total_size")= num NA
[18:00:58.907] Packages to be attached in all futures: [n=0] 
[18:00:58.907] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.908] Number of futures (= number of chunks): 1
[18:00:58.908] Launching 1 futures (chunks) ...
[18:00:58.908] Chunk #1 of 1 ...
[18:00:58.908]  - Finding globals in '...' for chunk #1 ...
[18:00:58.909] getGlobalsAndPackages() ...
[18:00:58.909] Searching for globals...
[18:00:58.910] 
[18:00:58.910] Searching for globals ... DONE
[18:00:58.910] - globals: [0] <none>
[18:00:58.910] getGlobalsAndPackages() ... DONE
[18:00:58.910]    + additional globals found: [n=0] 
[18:00:58.911]    + additional namespaces needed: [n=0] 
[18:00:58.911]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.911]  - seeds: <none>
[18:00:58.911]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.911] getGlobalsAndPackages() ...
[18:00:58.911] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.912] Resolving globals: FALSE
[18:00:58.913] The total size of the 5 globals is 392 bytes (392 bytes)
[18:00:58.914] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.914] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.914] 
[18:00:58.914] getGlobalsAndPackages() ... DONE
[18:00:58.915] run() for ‘Future’ ...
[18:00:58.915] - state: ‘created’
[18:00:58.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.916] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.916]   - Field: ‘label’
[18:00:58.917]   - Field: ‘local’
[18:00:58.917]   - Field: ‘owner’
[18:00:58.917]   - Field: ‘envir’
[18:00:58.917]   - Field: ‘packages’
[18:00:58.917]   - Field: ‘gc’
[18:00:58.917]   - Field: ‘conditions’
[18:00:58.918]   - Field: ‘expr’
[18:00:58.918]   - Field: ‘uuid’
[18:00:58.918]   - Field: ‘seed’
[18:00:58.918]   - Field: ‘version’
[18:00:58.918]   - Field: ‘result’
[18:00:58.919]   - Field: ‘asynchronous’
[18:00:58.919]   - Field: ‘calls’
[18:00:58.919]   - Field: ‘globals’
[18:00:58.919]   - Field: ‘stdout’
[18:00:58.919]   - Field: ‘earlySignal’
[18:00:58.920]   - Field: ‘lazy’
[18:00:58.920]   - Field: ‘state’
[18:00:58.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.920] - Launch lazy future ...
[18:00:58.921] Packages needed by the future expression (n = 0): <none>
[18:00:58.921] Packages needed by future strategies (n = 0): <none>
[18:00:58.922] {
[18:00:58.922]     {
[18:00:58.922]         {
[18:00:58.922]             ...future.startTime <- base::Sys.time()
[18:00:58.922]             {
[18:00:58.922]                 {
[18:00:58.922]                   {
[18:00:58.922]                     base::local({
[18:00:58.922]                       has_future <- base::requireNamespace("future", 
[18:00:58.922]                         quietly = TRUE)
[18:00:58.922]                       if (has_future) {
[18:00:58.922]                         ns <- base::getNamespace("future")
[18:00:58.922]                         version <- ns[[".package"]][["version"]]
[18:00:58.922]                         if (is.null(version)) 
[18:00:58.922]                           version <- utils::packageVersion("future")
[18:00:58.922]                       }
[18:00:58.922]                       else {
[18:00:58.922]                         version <- NULL
[18:00:58.922]                       }
[18:00:58.922]                       if (!has_future || version < "1.8.0") {
[18:00:58.922]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.922]                           "", base::R.version$version.string), 
[18:00:58.922]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.922]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.922]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.922]                             "release", "version")], collapse = " "), 
[18:00:58.922]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.922]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.922]                           info)
[18:00:58.922]                         info <- base::paste(info, collapse = "; ")
[18:00:58.922]                         if (!has_future) {
[18:00:58.922]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.922]                             info)
[18:00:58.922]                         }
[18:00:58.922]                         else {
[18:00:58.922]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.922]                             info, version)
[18:00:58.922]                         }
[18:00:58.922]                         base::stop(msg)
[18:00:58.922]                       }
[18:00:58.922]                     })
[18:00:58.922]                   }
[18:00:58.922]                   ...future.strategy.old <- future::plan("list")
[18:00:58.922]                   options(future.plan = NULL)
[18:00:58.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.922]                 }
[18:00:58.922]                 ...future.workdir <- getwd()
[18:00:58.922]             }
[18:00:58.922]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.922]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.922]         }
[18:00:58.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.922]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.922]             base::names(...future.oldOptions))
[18:00:58.922]     }
[18:00:58.922]     if (FALSE) {
[18:00:58.922]     }
[18:00:58.922]     else {
[18:00:58.922]         if (TRUE) {
[18:00:58.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.922]                 open = "w")
[18:00:58.922]         }
[18:00:58.922]         else {
[18:00:58.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.922]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.922]         }
[18:00:58.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.922]             base::sink(type = "output", split = FALSE)
[18:00:58.922]             base::close(...future.stdout)
[18:00:58.922]         }, add = TRUE)
[18:00:58.922]     }
[18:00:58.922]     ...future.frame <- base::sys.nframe()
[18:00:58.922]     ...future.conditions <- base::list()
[18:00:58.922]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.922]     if (FALSE) {
[18:00:58.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.922]     }
[18:00:58.922]     ...future.result <- base::tryCatch({
[18:00:58.922]         base::withCallingHandlers({
[18:00:58.922]             ...future.value <- base::withVisible(base::local({
[18:00:58.922]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.922]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.922]                   ...future.globals.maxSize)) {
[18:00:58.922]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.922]                   on.exit(options(oopts), add = TRUE)
[18:00:58.922]                 }
[18:00:58.922]                 {
[18:00:58.922]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.922]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.922]                     USE.NAMES = FALSE)
[18:00:58.922]                   do.call(mapply, args = args)
[18:00:58.922]                 }
[18:00:58.922]             }))
[18:00:58.922]             future::FutureResult(value = ...future.value$value, 
[18:00:58.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.922]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.922]                     ...future.globalenv.names))
[18:00:58.922]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.922]         }, condition = base::local({
[18:00:58.922]             c <- base::c
[18:00:58.922]             inherits <- base::inherits
[18:00:58.922]             invokeRestart <- base::invokeRestart
[18:00:58.922]             length <- base::length
[18:00:58.922]             list <- base::list
[18:00:58.922]             seq.int <- base::seq.int
[18:00:58.922]             signalCondition <- base::signalCondition
[18:00:58.922]             sys.calls <- base::sys.calls
[18:00:58.922]             `[[` <- base::`[[`
[18:00:58.922]             `+` <- base::`+`
[18:00:58.922]             `<<-` <- base::`<<-`
[18:00:58.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.922]                   3L)]
[18:00:58.922]             }
[18:00:58.922]             function(cond) {
[18:00:58.922]                 is_error <- inherits(cond, "error")
[18:00:58.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.922]                   NULL)
[18:00:58.922]                 if (is_error) {
[18:00:58.922]                   sessionInformation <- function() {
[18:00:58.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.922]                       search = base::search(), system = base::Sys.info())
[18:00:58.922]                   }
[18:00:58.922]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.922]                     cond$call), session = sessionInformation(), 
[18:00:58.922]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.922]                   signalCondition(cond)
[18:00:58.922]                 }
[18:00:58.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.922]                 "immediateCondition"))) {
[18:00:58.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.922]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.922]                   if (TRUE && !signal) {
[18:00:58.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.922]                     {
[18:00:58.922]                       inherits <- base::inherits
[18:00:58.922]                       invokeRestart <- base::invokeRestart
[18:00:58.922]                       is.null <- base::is.null
[18:00:58.922]                       muffled <- FALSE
[18:00:58.922]                       if (inherits(cond, "message")) {
[18:00:58.922]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.922]                         if (muffled) 
[18:00:58.922]                           invokeRestart("muffleMessage")
[18:00:58.922]                       }
[18:00:58.922]                       else if (inherits(cond, "warning")) {
[18:00:58.922]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.922]                         if (muffled) 
[18:00:58.922]                           invokeRestart("muffleWarning")
[18:00:58.922]                       }
[18:00:58.922]                       else if (inherits(cond, "condition")) {
[18:00:58.922]                         if (!is.null(pattern)) {
[18:00:58.922]                           computeRestarts <- base::computeRestarts
[18:00:58.922]                           grepl <- base::grepl
[18:00:58.922]                           restarts <- computeRestarts(cond)
[18:00:58.922]                           for (restart in restarts) {
[18:00:58.922]                             name <- restart$name
[18:00:58.922]                             if (is.null(name)) 
[18:00:58.922]                               next
[18:00:58.922]                             if (!grepl(pattern, name)) 
[18:00:58.922]                               next
[18:00:58.922]                             invokeRestart(restart)
[18:00:58.922]                             muffled <- TRUE
[18:00:58.922]                             break
[18:00:58.922]                           }
[18:00:58.922]                         }
[18:00:58.922]                       }
[18:00:58.922]                       invisible(muffled)
[18:00:58.922]                     }
[18:00:58.922]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.922]                   }
[18:00:58.922]                 }
[18:00:58.922]                 else {
[18:00:58.922]                   if (TRUE) {
[18:00:58.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.922]                     {
[18:00:58.922]                       inherits <- base::inherits
[18:00:58.922]                       invokeRestart <- base::invokeRestart
[18:00:58.922]                       is.null <- base::is.null
[18:00:58.922]                       muffled <- FALSE
[18:00:58.922]                       if (inherits(cond, "message")) {
[18:00:58.922]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.922]                         if (muffled) 
[18:00:58.922]                           invokeRestart("muffleMessage")
[18:00:58.922]                       }
[18:00:58.922]                       else if (inherits(cond, "warning")) {
[18:00:58.922]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.922]                         if (muffled) 
[18:00:58.922]                           invokeRestart("muffleWarning")
[18:00:58.922]                       }
[18:00:58.922]                       else if (inherits(cond, "condition")) {
[18:00:58.922]                         if (!is.null(pattern)) {
[18:00:58.922]                           computeRestarts <- base::computeRestarts
[18:00:58.922]                           grepl <- base::grepl
[18:00:58.922]                           restarts <- computeRestarts(cond)
[18:00:58.922]                           for (restart in restarts) {
[18:00:58.922]                             name <- restart$name
[18:00:58.922]                             if (is.null(name)) 
[18:00:58.922]                               next
[18:00:58.922]                             if (!grepl(pattern, name)) 
[18:00:58.922]                               next
[18:00:58.922]                             invokeRestart(restart)
[18:00:58.922]                             muffled <- TRUE
[18:00:58.922]                             break
[18:00:58.922]                           }
[18:00:58.922]                         }
[18:00:58.922]                       }
[18:00:58.922]                       invisible(muffled)
[18:00:58.922]                     }
[18:00:58.922]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.922]                   }
[18:00:58.922]                 }
[18:00:58.922]             }
[18:00:58.922]         }))
[18:00:58.922]     }, error = function(ex) {
[18:00:58.922]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.922]                 ...future.rng), started = ...future.startTime, 
[18:00:58.922]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.922]             version = "1.8"), class = "FutureResult")
[18:00:58.922]     }, finally = {
[18:00:58.922]         if (!identical(...future.workdir, getwd())) 
[18:00:58.922]             setwd(...future.workdir)
[18:00:58.922]         {
[18:00:58.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.922]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.922]             }
[18:00:58.922]             base::options(...future.oldOptions)
[18:00:58.922]             if (.Platform$OS.type == "windows") {
[18:00:58.922]                 old_names <- names(...future.oldEnvVars)
[18:00:58.922]                 envs <- base::Sys.getenv()
[18:00:58.922]                 names <- names(envs)
[18:00:58.922]                 common <- intersect(names, old_names)
[18:00:58.922]                 added <- setdiff(names, old_names)
[18:00:58.922]                 removed <- setdiff(old_names, names)
[18:00:58.922]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.922]                   envs[common]]
[18:00:58.922]                 NAMES <- toupper(changed)
[18:00:58.922]                 args <- list()
[18:00:58.922]                 for (kk in seq_along(NAMES)) {
[18:00:58.922]                   name <- changed[[kk]]
[18:00:58.922]                   NAME <- NAMES[[kk]]
[18:00:58.922]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.922]                     next
[18:00:58.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.922]                 }
[18:00:58.922]                 NAMES <- toupper(added)
[18:00:58.922]                 for (kk in seq_along(NAMES)) {
[18:00:58.922]                   name <- added[[kk]]
[18:00:58.922]                   NAME <- NAMES[[kk]]
[18:00:58.922]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.922]                     next
[18:00:58.922]                   args[[name]] <- ""
[18:00:58.922]                 }
[18:00:58.922]                 NAMES <- toupper(removed)
[18:00:58.922]                 for (kk in seq_along(NAMES)) {
[18:00:58.922]                   name <- removed[[kk]]
[18:00:58.922]                   NAME <- NAMES[[kk]]
[18:00:58.922]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.922]                     next
[18:00:58.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.922]                 }
[18:00:58.922]                 if (length(args) > 0) 
[18:00:58.922]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.922]             }
[18:00:58.922]             else {
[18:00:58.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.922]             }
[18:00:58.922]             {
[18:00:58.922]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.922]                   0L) {
[18:00:58.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.922]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.922]                   base::options(opts)
[18:00:58.922]                 }
[18:00:58.922]                 {
[18:00:58.922]                   {
[18:00:58.922]                     base::assign(".Random.seed", c(10407L, 567452142L, 
[18:00:58.922]                     1421140261L, 1045937781L, 1233976574L, -322649955L, 
[18:00:58.922]                     -65150472L), envir = base::globalenv(), inherits = FALSE)
[18:00:58.922]                     NULL
[18:00:58.922]                   }
[18:00:58.922]                   options(future.plan = NULL)
[18:00:58.922]                   if (is.na(NA_character_)) 
[18:00:58.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.922]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.922]                     .init = FALSE)
[18:00:58.922]                 }
[18:00:58.922]             }
[18:00:58.922]         }
[18:00:58.922]     })
[18:00:58.922]     if (TRUE) {
[18:00:58.922]         base::sink(type = "output", split = FALSE)
[18:00:58.922]         if (TRUE) {
[18:00:58.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.922]         }
[18:00:58.922]         else {
[18:00:58.922]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.922]         }
[18:00:58.922]         base::close(...future.stdout)
[18:00:58.922]         ...future.stdout <- NULL
[18:00:58.922]     }
[18:00:58.922]     ...future.result$conditions <- ...future.conditions
[18:00:58.922]     ...future.result$finished <- base::Sys.time()
[18:00:58.922]     ...future.result
[18:00:58.922] }
[18:00:58.930] assign_globals() ...
[18:00:58.931] List of 5
[18:00:58.931]  $ ...future.FUN            :function (e1, e2)  
[18:00:58.931]  $ MoreArgs                 : NULL
[18:00:58.931]  $ ...future.elements_ii    :List of 2
[18:00:58.931]   ..$ :List of 3
[18:00:58.931]   .. ..$ : num 1
[18:00:58.931]   .. ..$ : num 1
[18:00:58.931]   .. ..$ : num 1
[18:00:58.931]   ..$ :List of 3
[18:00:58.931]   .. ..$ : int 1
[18:00:58.931]   .. ..$ : int 2
[18:00:58.931]   .. ..$ : int 3
[18:00:58.931]  $ ...future.seeds_ii       : NULL
[18:00:58.931]  $ ...future.globals.maxSize: NULL
[18:00:58.931]  - attr(*, "where")=List of 5
[18:00:58.931]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.931]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.931]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.931]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.931]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.931]  - attr(*, "resolved")= logi FALSE
[18:00:58.931]  - attr(*, "total_size")= num 392
[18:00:58.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.931]  - attr(*, "already-done")= logi TRUE
[18:00:58.944] - copied ‘...future.FUN’ to environment
[18:00:58.944] - copied ‘MoreArgs’ to environment
[18:00:58.944] - copied ‘...future.elements_ii’ to environment
[18:00:58.944] - copied ‘...future.seeds_ii’ to environment
[18:00:58.945] - copied ‘...future.globals.maxSize’ to environment
[18:00:58.945] assign_globals() ... done
[18:00:58.945] plan(): Setting new future strategy stack:
[18:00:58.945] List of future strategies:
[18:00:58.945] 1. sequential:
[18:00:58.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.945]    - tweaked: FALSE
[18:00:58.945]    - call: NULL
[18:00:58.946] plan(): nbrOfWorkers() = 1
[18:00:58.948] plan(): Setting new future strategy stack:
[18:00:58.948] List of future strategies:
[18:00:58.948] 1. sequential:
[18:00:58.948]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:58.948]    - tweaked: FALSE
[18:00:58.948]    - call: plan(strategy)
[18:00:58.949] plan(): nbrOfWorkers() = 1
[18:00:58.949] SequentialFuture started (and completed)
[18:00:58.949] - Launch lazy future ... done
[18:00:58.950] run() for ‘SequentialFuture’ ... done
[18:00:58.950] Created future:
[18:00:58.950] SequentialFuture:
[18:00:58.950] Label: ‘future_Map-1’
[18:00:58.950] Expression:
[18:00:58.950] {
[18:00:58.950]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.950]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:58.950]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.950]         on.exit(options(oopts), add = TRUE)
[18:00:58.950]     }
[18:00:58.950]     {
[18:00:58.950]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.950]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:58.950]         do.call(mapply, args = args)
[18:00:58.950]     }
[18:00:58.950] }
[18:00:58.950] Lazy evaluation: FALSE
[18:00:58.950] Asynchronous evaluation: FALSE
[18:00:58.950] Local evaluation: TRUE
[18:00:58.950] Environment: R_GlobalEnv
[18:00:58.950] Capture standard output: TRUE
[18:00:58.950] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:58.950] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:58.950] Packages: <none>
[18:00:58.950] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:58.950] Resolved: TRUE
[18:00:58.950] Value: 168 bytes of class ‘list’
[18:00:58.950] Early signaling: FALSE
[18:00:58.950] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:58.950] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.952] Chunk #1 of 1 ... DONE
[18:00:58.952] Launching 1 futures (chunks) ... DONE
[18:00:58.952] Resolving 1 futures (chunks) ...
[18:00:58.952] resolve() on list ...
[18:00:58.953]  recursive: 0
[18:00:58.953]  length: 1
[18:00:58.953] 
[18:00:58.953] resolved() for ‘SequentialFuture’ ...
[18:00:58.953] - state: ‘finished’
[18:00:58.954] - run: TRUE
[18:00:58.954] - result: ‘FutureResult’
[18:00:58.954] resolved() for ‘SequentialFuture’ ... done
[18:00:58.954] Future #1
[18:00:58.954] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:58.955] - nx: 1
[18:00:58.955] - relay: TRUE
[18:00:58.955] - stdout: TRUE
[18:00:58.955] - signal: TRUE
[18:00:58.955] - resignal: FALSE
[18:00:58.956] - force: TRUE
[18:00:58.956] - relayed: [n=1] FALSE
[18:00:58.956] - queued futures: [n=1] FALSE
[18:00:58.956]  - until=1
[18:00:58.956]  - relaying element #1
[18:00:58.957] - relayed: [n=1] TRUE
[18:00:58.957] - queued futures: [n=1] TRUE
[18:00:58.957] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:58.957]  length: 0 (resolved future 1)
[18:00:58.957] Relaying remaining futures
[18:00:58.958] signalConditionsASAP(NULL, pos=0) ...
[18:00:58.958] - nx: 1
[18:00:58.958] - relay: TRUE
[18:00:58.958] - stdout: TRUE
[18:00:58.958] - signal: TRUE
[18:00:58.958] - resignal: FALSE
[18:00:58.959] - force: TRUE
[18:00:58.959] - relayed: [n=1] TRUE
[18:00:58.959] - queued futures: [n=1] TRUE
 - flush all
[18:00:58.959] - relayed: [n=1] TRUE
[18:00:58.959] - queued futures: [n=1] TRUE
[18:00:58.960] signalConditionsASAP(NULL, pos=0) ... done
[18:00:58.960] resolve() on list ... DONE
[18:00:58.960]  - Number of value chunks collected: 1
[18:00:58.960] Resolving 1 futures (chunks) ... DONE
[18:00:58.961] Reducing values from 1 chunks ...
[18:00:58.961]  - Number of values collected after concatenation: 3
[18:00:58.961]  - Number of values expected: 3
[18:00:58.961] Reducing values from 1 chunks ... DONE
[18:00:58.961] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[18:00:58.962] future_mapply() ...
[18:00:58.962] Number of chunks: 1
[18:00:58.963] getGlobalsAndPackagesXApply() ...
[18:00:58.963]  - future.globals: TRUE
[18:00:58.963] getGlobalsAndPackages() ...
[18:00:58.963] Searching for globals...
[18:00:58.965] - globals found: [1] ‘FUN’
[18:00:58.965] Searching for globals ... DONE
[18:00:58.966] Resolving globals: FALSE
[18:00:58.966] The total size of the 1 globals is 848 bytes (848 bytes)
[18:00:58.967] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:00:58.967] - globals: [1] ‘FUN’
[18:00:58.967] 
[18:00:58.967] getGlobalsAndPackages() ... DONE
[18:00:58.968]  - globals found/used: [n=1] ‘FUN’
[18:00:58.968]  - needed namespaces: [n=0] 
[18:00:58.968] Finding globals ... DONE
[18:00:58.968] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:58.969] List of 2
[18:00:58.969]  $ ...future.FUN:function (x)  
[18:00:58.969]  $ MoreArgs     : NULL
[18:00:58.969]  - attr(*, "where")=List of 2
[18:00:58.969]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:58.969]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:58.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.969]  - attr(*, "resolved")= logi FALSE
[18:00:58.969]  - attr(*, "total_size")= num NA
[18:00:58.973] Packages to be attached in all futures: [n=0] 
[18:00:58.974] getGlobalsAndPackagesXApply() ... DONE
[18:00:58.974] Number of futures (= number of chunks): 1
[18:00:58.974] Launching 1 futures (chunks) ...
[18:00:58.974] Chunk #1 of 1 ...
[18:00:58.975]  - Finding globals in '...' for chunk #1 ...
[18:00:58.975] getGlobalsAndPackages() ...
[18:00:58.975] Searching for globals...
[18:00:58.976] 
[18:00:58.976] Searching for globals ... DONE
[18:00:58.976] - globals: [0] <none>
[18:00:58.976] getGlobalsAndPackages() ... DONE
[18:00:58.976]    + additional globals found: [n=0] 
[18:00:58.979]    + additional namespaces needed: [n=0] 
[18:00:58.979]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:58.980]  - seeds: <none>
[18:00:58.980]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.980] getGlobalsAndPackages() ...
[18:00:58.980] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.981] Resolving globals: FALSE
[18:00:58.982] The total size of the 5 globals is 960 bytes (960 bytes)
[18:00:58.982] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:58.983] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:58.983] 
[18:00:58.983] getGlobalsAndPackages() ... DONE
[18:00:58.984] run() for ‘Future’ ...
[18:00:58.984] - state: ‘created’
[18:00:58.984] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:00:58.985] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:58.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:00:58.985]   - Field: ‘label’
[18:00:58.985]   - Field: ‘local’
[18:00:58.986]   - Field: ‘owner’
[18:00:58.986]   - Field: ‘envir’
[18:00:58.986]   - Field: ‘packages’
[18:00:58.986]   - Field: ‘gc’
[18:00:58.986]   - Field: ‘conditions’
[18:00:58.987]   - Field: ‘expr’
[18:00:58.987]   - Field: ‘uuid’
[18:00:58.987]   - Field: ‘seed’
[18:00:58.987]   - Field: ‘version’
[18:00:58.987]   - Field: ‘result’
[18:00:58.988]   - Field: ‘asynchronous’
[18:00:58.988]   - Field: ‘calls’
[18:00:58.988]   - Field: ‘globals’
[18:00:58.988]   - Field: ‘stdout’
[18:00:58.988]   - Field: ‘earlySignal’
[18:00:58.989]   - Field: ‘lazy’
[18:00:58.989]   - Field: ‘state’
[18:00:58.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:00:58.989] - Launch lazy future ...
[18:00:58.990] Packages needed by the future expression (n = 0): <none>
[18:00:58.990] Packages needed by future strategies (n = 0): <none>
[18:00:58.991] {
[18:00:58.991]     {
[18:00:58.991]         {
[18:00:58.991]             ...future.startTime <- base::Sys.time()
[18:00:58.991]             {
[18:00:58.991]                 {
[18:00:58.991]                   {
[18:00:58.991]                     base::local({
[18:00:58.991]                       has_future <- base::requireNamespace("future", 
[18:00:58.991]                         quietly = TRUE)
[18:00:58.991]                       if (has_future) {
[18:00:58.991]                         ns <- base::getNamespace("future")
[18:00:58.991]                         version <- ns[[".package"]][["version"]]
[18:00:58.991]                         if (is.null(version)) 
[18:00:58.991]                           version <- utils::packageVersion("future")
[18:00:58.991]                       }
[18:00:58.991]                       else {
[18:00:58.991]                         version <- NULL
[18:00:58.991]                       }
[18:00:58.991]                       if (!has_future || version < "1.8.0") {
[18:00:58.991]                         info <- base::c(r_version = base::gsub("R version ", 
[18:00:58.991]                           "", base::R.version$version.string), 
[18:00:58.991]                           platform = base::sprintf("%s (%s-bit)", 
[18:00:58.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:58.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:58.991]                             "release", "version")], collapse = " "), 
[18:00:58.991]                           hostname = base::Sys.info()[["nodename"]])
[18:00:58.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:00:58.991]                           info)
[18:00:58.991]                         info <- base::paste(info, collapse = "; ")
[18:00:58.991]                         if (!has_future) {
[18:00:58.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:58.991]                             info)
[18:00:58.991]                         }
[18:00:58.991]                         else {
[18:00:58.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:58.991]                             info, version)
[18:00:58.991]                         }
[18:00:58.991]                         base::stop(msg)
[18:00:58.991]                       }
[18:00:58.991]                     })
[18:00:58.991]                   }
[18:00:58.991]                   ...future.strategy.old <- future::plan("list")
[18:00:58.991]                   options(future.plan = NULL)
[18:00:58.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:58.991]                 }
[18:00:58.991]                 ...future.workdir <- getwd()
[18:00:58.991]             }
[18:00:58.991]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:58.991]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:58.991]         }
[18:00:58.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:58.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:00:58.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:58.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:58.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:58.991]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:58.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:58.991]             base::names(...future.oldOptions))
[18:00:58.991]     }
[18:00:58.991]     if (FALSE) {
[18:00:58.991]     }
[18:00:58.991]     else {
[18:00:58.991]         if (TRUE) {
[18:00:58.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:58.991]                 open = "w")
[18:00:58.991]         }
[18:00:58.991]         else {
[18:00:58.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:58.991]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:58.991]         }
[18:00:58.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:58.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:58.991]             base::sink(type = "output", split = FALSE)
[18:00:58.991]             base::close(...future.stdout)
[18:00:58.991]         }, add = TRUE)
[18:00:58.991]     }
[18:00:58.991]     ...future.frame <- base::sys.nframe()
[18:00:58.991]     ...future.conditions <- base::list()
[18:00:58.991]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:58.991]     if (FALSE) {
[18:00:58.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:58.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:58.991]     }
[18:00:58.991]     ...future.result <- base::tryCatch({
[18:00:58.991]         base::withCallingHandlers({
[18:00:58.991]             ...future.value <- base::withVisible(base::local({
[18:00:58.991]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:58.991]                 if (!identical(...future.globals.maxSize.org, 
[18:00:58.991]                   ...future.globals.maxSize)) {
[18:00:58.991]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:58.991]                   on.exit(options(oopts), add = TRUE)
[18:00:58.991]                 }
[18:00:58.991]                 {
[18:00:58.991]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:58.991]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:58.991]                     USE.NAMES = FALSE)
[18:00:58.991]                   do.call(mapply, args = args)
[18:00:58.991]                 }
[18:00:58.991]             }))
[18:00:58.991]             future::FutureResult(value = ...future.value$value, 
[18:00:58.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.991]                   ...future.rng), globalenv = if (FALSE) 
[18:00:58.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:58.991]                     ...future.globalenv.names))
[18:00:58.991]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:58.991]         }, condition = base::local({
[18:00:58.991]             c <- base::c
[18:00:58.991]             inherits <- base::inherits
[18:00:58.991]             invokeRestart <- base::invokeRestart
[18:00:58.991]             length <- base::length
[18:00:58.991]             list <- base::list
[18:00:58.991]             seq.int <- base::seq.int
[18:00:58.991]             signalCondition <- base::signalCondition
[18:00:58.991]             sys.calls <- base::sys.calls
[18:00:58.991]             `[[` <- base::`[[`
[18:00:58.991]             `+` <- base::`+`
[18:00:58.991]             `<<-` <- base::`<<-`
[18:00:58.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:58.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:58.991]                   3L)]
[18:00:58.991]             }
[18:00:58.991]             function(cond) {
[18:00:58.991]                 is_error <- inherits(cond, "error")
[18:00:58.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:58.991]                   NULL)
[18:00:58.991]                 if (is_error) {
[18:00:58.991]                   sessionInformation <- function() {
[18:00:58.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:58.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:58.991]                       search = base::search(), system = base::Sys.info())
[18:00:58.991]                   }
[18:00:58.991]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:58.991]                     cond$call), session = sessionInformation(), 
[18:00:58.991]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:58.991]                   signalCondition(cond)
[18:00:58.991]                 }
[18:00:58.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:58.991]                 "immediateCondition"))) {
[18:00:58.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:58.991]                   ...future.conditions[[length(...future.conditions) + 
[18:00:58.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:58.991]                   if (TRUE && !signal) {
[18:00:58.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.991]                     {
[18:00:58.991]                       inherits <- base::inherits
[18:00:58.991]                       invokeRestart <- base::invokeRestart
[18:00:58.991]                       is.null <- base::is.null
[18:00:58.991]                       muffled <- FALSE
[18:00:58.991]                       if (inherits(cond, "message")) {
[18:00:58.991]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.991]                         if (muffled) 
[18:00:58.991]                           invokeRestart("muffleMessage")
[18:00:58.991]                       }
[18:00:58.991]                       else if (inherits(cond, "warning")) {
[18:00:58.991]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.991]                         if (muffled) 
[18:00:58.991]                           invokeRestart("muffleWarning")
[18:00:58.991]                       }
[18:00:58.991]                       else if (inherits(cond, "condition")) {
[18:00:58.991]                         if (!is.null(pattern)) {
[18:00:58.991]                           computeRestarts <- base::computeRestarts
[18:00:58.991]                           grepl <- base::grepl
[18:00:58.991]                           restarts <- computeRestarts(cond)
[18:00:58.991]                           for (restart in restarts) {
[18:00:58.991]                             name <- restart$name
[18:00:58.991]                             if (is.null(name)) 
[18:00:58.991]                               next
[18:00:58.991]                             if (!grepl(pattern, name)) 
[18:00:58.991]                               next
[18:00:58.991]                             invokeRestart(restart)
[18:00:58.991]                             muffled <- TRUE
[18:00:58.991]                             break
[18:00:58.991]                           }
[18:00:58.991]                         }
[18:00:58.991]                       }
[18:00:58.991]                       invisible(muffled)
[18:00:58.991]                     }
[18:00:58.991]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.991]                   }
[18:00:58.991]                 }
[18:00:58.991]                 else {
[18:00:58.991]                   if (TRUE) {
[18:00:58.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:58.991]                     {
[18:00:58.991]                       inherits <- base::inherits
[18:00:58.991]                       invokeRestart <- base::invokeRestart
[18:00:58.991]                       is.null <- base::is.null
[18:00:58.991]                       muffled <- FALSE
[18:00:58.991]                       if (inherits(cond, "message")) {
[18:00:58.991]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:58.991]                         if (muffled) 
[18:00:58.991]                           invokeRestart("muffleMessage")
[18:00:58.991]                       }
[18:00:58.991]                       else if (inherits(cond, "warning")) {
[18:00:58.991]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:58.991]                         if (muffled) 
[18:00:58.991]                           invokeRestart("muffleWarning")
[18:00:58.991]                       }
[18:00:58.991]                       else if (inherits(cond, "condition")) {
[18:00:58.991]                         if (!is.null(pattern)) {
[18:00:58.991]                           computeRestarts <- base::computeRestarts
[18:00:58.991]                           grepl <- base::grepl
[18:00:58.991]                           restarts <- computeRestarts(cond)
[18:00:58.991]                           for (restart in restarts) {
[18:00:58.991]                             name <- restart$name
[18:00:58.991]                             if (is.null(name)) 
[18:00:58.991]                               next
[18:00:58.991]                             if (!grepl(pattern, name)) 
[18:00:58.991]                               next
[18:00:58.991]                             invokeRestart(restart)
[18:00:58.991]                             muffled <- TRUE
[18:00:58.991]                             break
[18:00:58.991]                           }
[18:00:58.991]                         }
[18:00:58.991]                       }
[18:00:58.991]                       invisible(muffled)
[18:00:58.991]                     }
[18:00:58.991]                     muffleCondition(cond, pattern = "^muffle")
[18:00:58.991]                   }
[18:00:58.991]                 }
[18:00:58.991]             }
[18:00:58.991]         }))
[18:00:58.991]     }, error = function(ex) {
[18:00:58.991]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:58.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:58.991]                 ...future.rng), started = ...future.startTime, 
[18:00:58.991]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:58.991]             version = "1.8"), class = "FutureResult")
[18:00:58.991]     }, finally = {
[18:00:58.991]         if (!identical(...future.workdir, getwd())) 
[18:00:58.991]             setwd(...future.workdir)
[18:00:58.991]         {
[18:00:58.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:58.991]                 ...future.oldOptions$nwarnings <- NULL
[18:00:58.991]             }
[18:00:58.991]             base::options(...future.oldOptions)
[18:00:58.991]             if (.Platform$OS.type == "windows") {
[18:00:58.991]                 old_names <- names(...future.oldEnvVars)
[18:00:58.991]                 envs <- base::Sys.getenv()
[18:00:58.991]                 names <- names(envs)
[18:00:58.991]                 common <- intersect(names, old_names)
[18:00:58.991]                 added <- setdiff(names, old_names)
[18:00:58.991]                 removed <- setdiff(old_names, names)
[18:00:58.991]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:58.991]                   envs[common]]
[18:00:58.991]                 NAMES <- toupper(changed)
[18:00:58.991]                 args <- list()
[18:00:58.991]                 for (kk in seq_along(NAMES)) {
[18:00:58.991]                   name <- changed[[kk]]
[18:00:58.991]                   NAME <- NAMES[[kk]]
[18:00:58.991]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.991]                     next
[18:00:58.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.991]                 }
[18:00:58.991]                 NAMES <- toupper(added)
[18:00:58.991]                 for (kk in seq_along(NAMES)) {
[18:00:58.991]                   name <- added[[kk]]
[18:00:58.991]                   NAME <- NAMES[[kk]]
[18:00:58.991]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.991]                     next
[18:00:58.991]                   args[[name]] <- ""
[18:00:58.991]                 }
[18:00:58.991]                 NAMES <- toupper(removed)
[18:00:58.991]                 for (kk in seq_along(NAMES)) {
[18:00:58.991]                   name <- removed[[kk]]
[18:00:58.991]                   NAME <- NAMES[[kk]]
[18:00:58.991]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:58.991]                     next
[18:00:58.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:58.991]                 }
[18:00:58.991]                 if (length(args) > 0) 
[18:00:58.991]                   base::do.call(base::Sys.setenv, args = args)
[18:00:58.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:58.991]             }
[18:00:58.991]             else {
[18:00:58.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:58.991]             }
[18:00:58.991]             {
[18:00:58.991]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:58.991]                   0L) {
[18:00:58.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:58.991]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:58.991]                   base::options(opts)
[18:00:58.991]                 }
[18:00:58.991]                 {
[18:00:58.991]                   {
[18:00:58.991]                     base::assign(".Random.seed", c(10407L, 567452142L, 
[18:00:58.991]                     1421140261L, 1045937781L, 1233976574L, -322649955L, 
[18:00:58.991]                     -65150472L), envir = base::globalenv(), inherits = FALSE)
[18:00:58.991]                     NULL
[18:00:58.991]                   }
[18:00:58.991]                   options(future.plan = NULL)
[18:00:58.991]                   if (is.na(NA_character_)) 
[18:00:58.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:58.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:58.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:58.991]                     .init = FALSE)
[18:00:58.991]                 }
[18:00:58.991]             }
[18:00:58.991]         }
[18:00:58.991]     })
[18:00:58.991]     if (TRUE) {
[18:00:58.991]         base::sink(type = "output", split = FALSE)
[18:00:58.991]         if (TRUE) {
[18:00:58.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:58.991]         }
[18:00:58.991]         else {
[18:00:58.991]             ...future.result["stdout"] <- base::list(NULL)
[18:00:58.991]         }
[18:00:58.991]         base::close(...future.stdout)
[18:00:58.991]         ...future.stdout <- NULL
[18:00:58.991]     }
[18:00:58.991]     ...future.result$conditions <- ...future.conditions
[18:00:58.991]     ...future.result$finished <- base::Sys.time()
[18:00:58.991]     ...future.result
[18:00:58.991] }
[18:00:58.994] assign_globals() ...
[18:00:58.994] List of 5
[18:00:58.994]  $ ...future.FUN            :function (x)  
[18:00:58.994]  $ MoreArgs                 : NULL
[18:00:58.994]  $ ...future.elements_ii    :List of 1
[18:00:58.994]   ..$ :List of 2
[18:00:58.994]   .. ..$ a: num 0
[18:00:58.994]   .. ..$ b: num 0
[18:00:58.994]  $ ...future.seeds_ii       : NULL
[18:00:58.994]  $ ...future.globals.maxSize: NULL
[18:00:58.994]  - attr(*, "where")=List of 5
[18:00:58.994]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:58.994]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:58.994]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:58.994]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:58.994]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:58.994]  - attr(*, "resolved")= logi FALSE
[18:00:58.994]  - attr(*, "total_size")= num 960
[18:00:58.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:58.994]  - attr(*, "already-done")= logi TRUE
[18:00:59.004] - copied ‘...future.FUN’ to environment
[18:00:59.004] - copied ‘MoreArgs’ to environment
[18:00:59.004] - copied ‘...future.elements_ii’ to environment
[18:00:59.004] - copied ‘...future.seeds_ii’ to environment
[18:00:59.005] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.005] assign_globals() ... done
[18:00:59.005] plan(): Setting new future strategy stack:
[18:00:59.006] List of future strategies:
[18:00:59.006] 1. sequential:
[18:00:59.006]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.006]    - tweaked: FALSE
[18:00:59.006]    - call: NULL
[18:00:59.006] plan(): nbrOfWorkers() = 1
[18:00:59.008] plan(): Setting new future strategy stack:
[18:00:59.008] List of future strategies:
[18:00:59.008] 1. sequential:
[18:00:59.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.008]    - tweaked: FALSE
[18:00:59.008]    - call: plan(strategy)
[18:00:59.009] plan(): nbrOfWorkers() = 1
[18:00:59.009] SequentialFuture started (and completed)
[18:00:59.010] - Launch lazy future ... done
[18:00:59.010] run() for ‘SequentialFuture’ ... done
[18:00:59.010] Created future:
[18:00:59.010] SequentialFuture:
[18:00:59.010] Label: ‘future_mapply-1’
[18:00:59.010] Expression:
[18:00:59.010] {
[18:00:59.010]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.010]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.010]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.010]         on.exit(options(oopts), add = TRUE)
[18:00:59.010]     }
[18:00:59.010]     {
[18:00:59.010]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.010]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.010]         do.call(mapply, args = args)
[18:00:59.010]     }
[18:00:59.010] }
[18:00:59.010] Lazy evaluation: FALSE
[18:00:59.010] Asynchronous evaluation: FALSE
[18:00:59.010] Local evaluation: TRUE
[18:00:59.010] Environment: R_GlobalEnv
[18:00:59.010] Capture standard output: TRUE
[18:00:59.010] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.010] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.010] Packages: <none>
[18:00:59.010] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.010] Resolved: TRUE
[18:00:59.010] Value: 112 bytes of class ‘list’
[18:00:59.010] Early signaling: FALSE
[18:00:59.010] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.010] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:00:59.012] Chunk #1 of 1 ... DONE
[18:00:59.012] Launching 1 futures (chunks) ... DONE
[18:00:59.012] Resolving 1 futures (chunks) ...
[18:00:59.013] resolve() on list ...
[18:00:59.013]  recursive: 0
[18:00:59.013]  length: 1
[18:00:59.013] 
[18:00:59.013] resolved() for ‘SequentialFuture’ ...
[18:00:59.014] - state: ‘finished’
[18:00:59.014] - run: TRUE
[18:00:59.014] - result: ‘FutureResult’
[18:00:59.014] resolved() for ‘SequentialFuture’ ... done
[18:00:59.014] Future #1
[18:00:59.015] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:00:59.015] - nx: 1
[18:00:59.015] - relay: TRUE
[18:00:59.015] - stdout: TRUE
[18:00:59.015] - signal: TRUE
[18:00:59.016] - resignal: FALSE
[18:00:59.016] - force: TRUE
[18:00:59.016] - relayed: [n=1] FALSE
[18:00:59.016] - queued futures: [n=1] FALSE
[18:00:59.016]  - until=1
[18:00:59.016]  - relaying element #1
[18:00:59.017] - relayed: [n=1] TRUE
[18:00:59.017] - queued futures: [n=1] TRUE
[18:00:59.017] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:00:59.017]  length: 0 (resolved future 1)
[18:00:59.018] Relaying remaining futures
[18:00:59.018] signalConditionsASAP(NULL, pos=0) ...
[18:00:59.018] - nx: 1
[18:00:59.018] - relay: TRUE
[18:00:59.019] - stdout: TRUE
[18:00:59.019] - signal: TRUE
[18:00:59.019] - resignal: FALSE
[18:00:59.019] - force: TRUE
[18:00:59.019] - relayed: [n=1] TRUE
[18:00:59.020] - queued futures: [n=1] TRUE
 - flush all
[18:00:59.020] - relayed: [n=1] TRUE
[18:00:59.020] - queued futures: [n=1] TRUE
[18:00:59.020] signalConditionsASAP(NULL, pos=0) ... done
[18:00:59.020] resolve() on list ... DONE
[18:00:59.021]  - Number of value chunks collected: 1
[18:00:59.021] Resolving 1 futures (chunks) ... DONE
[18:00:59.021] Reducing values from 1 chunks ...
[18:00:59.021]  - Number of values collected after concatenation: 2
[18:00:59.022]  - Number of values expected: 2
[18:00:59.022] Reducing values from 1 chunks ... DONE
[18:00:59.022] future_mapply() ... DONE
[18:00:59.022] plan(): Setting new future strategy stack:
[18:00:59.022] List of future strategies:
[18:00:59.022] 1. sequential:
[18:00:59.022]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.022]    - tweaked: FALSE
[18:00:59.022]    - call: plan(sequential)
[18:00:59.023] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[18:00:59.024] plan(): Setting new future strategy stack:
[18:00:59.024] List of future strategies:
[18:00:59.024] 1. multicore:
[18:00:59.024]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.024]    - tweaked: FALSE
[18:00:59.024]    - call: plan(strategy)
[18:00:59.031] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[18:00:59.031] future_mapply() ...
[18:00:59.041] Number of chunks: 2
[18:00:59.042] getGlobalsAndPackagesXApply() ...
[18:00:59.042]  - future.globals: TRUE
[18:00:59.042] getGlobalsAndPackages() ...
[18:00:59.042] Searching for globals...
[18:00:59.044] - globals found: [1] ‘FUN’
[18:00:59.044] Searching for globals ... DONE
[18:00:59.044] Resolving globals: FALSE
[18:00:59.045] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:59.046] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:59.046] - globals: [1] ‘FUN’
[18:00:59.046] 
[18:00:59.047] getGlobalsAndPackages() ... DONE
[18:00:59.047]  - globals found/used: [n=1] ‘FUN’
[18:00:59.047]  - needed namespaces: [n=0] 
[18:00:59.047] Finding globals ... DONE
[18:00:59.048] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:59.048] List of 2
[18:00:59.048]  $ ...future.FUN:function (x, ...)  
[18:00:59.048]  $ MoreArgs     : NULL
[18:00:59.048]  - attr(*, "where")=List of 2
[18:00:59.048]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:59.048]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:59.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.048]  - attr(*, "resolved")= logi FALSE
[18:00:59.048]  - attr(*, "total_size")= num NA
[18:00:59.053] Packages to be attached in all futures: [n=0] 
[18:00:59.054] getGlobalsAndPackagesXApply() ... DONE
[18:00:59.054] Number of futures (= number of chunks): 2
[18:00:59.054] Launching 2 futures (chunks) ...
[18:00:59.055] Chunk #1 of 2 ...
[18:00:59.055]  - Finding globals in '...' for chunk #1 ...
[18:00:59.055] getGlobalsAndPackages() ...
[18:00:59.055] Searching for globals...
[18:00:59.056] 
[18:00:59.056] Searching for globals ... DONE
[18:00:59.057] - globals: [0] <none>
[18:00:59.057] getGlobalsAndPackages() ... DONE
[18:00:59.057]    + additional globals found: [n=0] 
[18:00:59.057]    + additional namespaces needed: [n=0] 
[18:00:59.057]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:59.058]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.058]  - seeds: <none>
[18:00:59.058]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.058] getGlobalsAndPackages() ...
[18:00:59.058] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.059] Resolving globals: FALSE
[18:00:59.060] The total size of the 5 globals is 280 bytes (280 bytes)
[18:00:59.061] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.061] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.061] 
[18:00:59.062] getGlobalsAndPackages() ... DONE
[18:00:59.062] run() for ‘Future’ ...
[18:00:59.063] - state: ‘created’
[18:00:59.063] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.070] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.071]   - Field: ‘label’
[18:00:59.071]   - Field: ‘local’
[18:00:59.071]   - Field: ‘owner’
[18:00:59.071]   - Field: ‘envir’
[18:00:59.071]   - Field: ‘workers’
[18:00:59.072]   - Field: ‘packages’
[18:00:59.072]   - Field: ‘gc’
[18:00:59.072]   - Field: ‘job’
[18:00:59.072]   - Field: ‘conditions’
[18:00:59.072]   - Field: ‘expr’
[18:00:59.073]   - Field: ‘uuid’
[18:00:59.073]   - Field: ‘seed’
[18:00:59.073]   - Field: ‘version’
[18:00:59.073]   - Field: ‘result’
[18:00:59.073]   - Field: ‘asynchronous’
[18:00:59.074]   - Field: ‘calls’
[18:00:59.074]   - Field: ‘globals’
[18:00:59.074]   - Field: ‘stdout’
[18:00:59.075]   - Field: ‘earlySignal’
[18:00:59.075]   - Field: ‘lazy’
[18:00:59.075]   - Field: ‘state’
[18:00:59.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.075] - Launch lazy future ...
[18:00:59.078] Packages needed by the future expression (n = 0): <none>
[18:00:59.078] Packages needed by future strategies (n = 0): <none>
[18:00:59.079] {
[18:00:59.079]     {
[18:00:59.079]         {
[18:00:59.079]             ...future.startTime <- base::Sys.time()
[18:00:59.079]             {
[18:00:59.079]                 {
[18:00:59.079]                   {
[18:00:59.079]                     {
[18:00:59.079]                       base::local({
[18:00:59.079]                         has_future <- base::requireNamespace("future", 
[18:00:59.079]                           quietly = TRUE)
[18:00:59.079]                         if (has_future) {
[18:00:59.079]                           ns <- base::getNamespace("future")
[18:00:59.079]                           version <- ns[[".package"]][["version"]]
[18:00:59.079]                           if (is.null(version)) 
[18:00:59.079]                             version <- utils::packageVersion("future")
[18:00:59.079]                         }
[18:00:59.079]                         else {
[18:00:59.079]                           version <- NULL
[18:00:59.079]                         }
[18:00:59.079]                         if (!has_future || version < "1.8.0") {
[18:00:59.079]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.079]                             "", base::R.version$version.string), 
[18:00:59.079]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.079]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.079]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.079]                               "release", "version")], collapse = " "), 
[18:00:59.079]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.079]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.079]                             info)
[18:00:59.079]                           info <- base::paste(info, collapse = "; ")
[18:00:59.079]                           if (!has_future) {
[18:00:59.079]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.079]                               info)
[18:00:59.079]                           }
[18:00:59.079]                           else {
[18:00:59.079]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.079]                               info, version)
[18:00:59.079]                           }
[18:00:59.079]                           base::stop(msg)
[18:00:59.079]                         }
[18:00:59.079]                       })
[18:00:59.079]                     }
[18:00:59.079]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.079]                     base::options(mc.cores = 1L)
[18:00:59.079]                   }
[18:00:59.079]                   ...future.strategy.old <- future::plan("list")
[18:00:59.079]                   options(future.plan = NULL)
[18:00:59.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.079]                 }
[18:00:59.079]                 ...future.workdir <- getwd()
[18:00:59.079]             }
[18:00:59.079]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.079]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.079]         }
[18:00:59.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.079]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.079]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.079]             base::names(...future.oldOptions))
[18:00:59.079]     }
[18:00:59.079]     if (FALSE) {
[18:00:59.079]     }
[18:00:59.079]     else {
[18:00:59.079]         if (TRUE) {
[18:00:59.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.079]                 open = "w")
[18:00:59.079]         }
[18:00:59.079]         else {
[18:00:59.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.079]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.079]         }
[18:00:59.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.079]             base::sink(type = "output", split = FALSE)
[18:00:59.079]             base::close(...future.stdout)
[18:00:59.079]         }, add = TRUE)
[18:00:59.079]     }
[18:00:59.079]     ...future.frame <- base::sys.nframe()
[18:00:59.079]     ...future.conditions <- base::list()
[18:00:59.079]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.079]     if (FALSE) {
[18:00:59.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.079]     }
[18:00:59.079]     ...future.result <- base::tryCatch({
[18:00:59.079]         base::withCallingHandlers({
[18:00:59.079]             ...future.value <- base::withVisible(base::local({
[18:00:59.079]                 withCallingHandlers({
[18:00:59.079]                   {
[18:00:59.079]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.079]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.079]                       ...future.globals.maxSize)) {
[18:00:59.079]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.079]                       on.exit(options(oopts), add = TRUE)
[18:00:59.079]                     }
[18:00:59.079]                     {
[18:00:59.079]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.079]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.079]                         USE.NAMES = FALSE)
[18:00:59.079]                       do.call(mapply, args = args)
[18:00:59.079]                     }
[18:00:59.079]                   }
[18:00:59.079]                 }, immediateCondition = function(cond) {
[18:00:59.079]                   save_rds <- function (object, pathname, ...) 
[18:00:59.079]                   {
[18:00:59.079]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.079]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.079]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.079]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.079]                         fi_tmp[["mtime"]])
[18:00:59.079]                     }
[18:00:59.079]                     tryCatch({
[18:00:59.079]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.079]                     }, error = function(ex) {
[18:00:59.079]                       msg <- conditionMessage(ex)
[18:00:59.079]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.079]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.079]                         fi_tmp[["mtime"]], msg)
[18:00:59.079]                       ex$message <- msg
[18:00:59.079]                       stop(ex)
[18:00:59.079]                     })
[18:00:59.079]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.079]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.079]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.079]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.079]                       fi <- file.info(pathname)
[18:00:59.079]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.079]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.079]                         fi[["size"]], fi[["mtime"]])
[18:00:59.079]                       stop(msg)
[18:00:59.079]                     }
[18:00:59.079]                     invisible(pathname)
[18:00:59.079]                   }
[18:00:59.079]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.079]                     rootPath = tempdir()) 
[18:00:59.079]                   {
[18:00:59.079]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.079]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.079]                       tmpdir = path, fileext = ".rds")
[18:00:59.079]                     save_rds(obj, file)
[18:00:59.079]                   }
[18:00:59.079]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.079]                   {
[18:00:59.079]                     inherits <- base::inherits
[18:00:59.079]                     invokeRestart <- base::invokeRestart
[18:00:59.079]                     is.null <- base::is.null
[18:00:59.079]                     muffled <- FALSE
[18:00:59.079]                     if (inherits(cond, "message")) {
[18:00:59.079]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.079]                       if (muffled) 
[18:00:59.079]                         invokeRestart("muffleMessage")
[18:00:59.079]                     }
[18:00:59.079]                     else if (inherits(cond, "warning")) {
[18:00:59.079]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.079]                       if (muffled) 
[18:00:59.079]                         invokeRestart("muffleWarning")
[18:00:59.079]                     }
[18:00:59.079]                     else if (inherits(cond, "condition")) {
[18:00:59.079]                       if (!is.null(pattern)) {
[18:00:59.079]                         computeRestarts <- base::computeRestarts
[18:00:59.079]                         grepl <- base::grepl
[18:00:59.079]                         restarts <- computeRestarts(cond)
[18:00:59.079]                         for (restart in restarts) {
[18:00:59.079]                           name <- restart$name
[18:00:59.079]                           if (is.null(name)) 
[18:00:59.079]                             next
[18:00:59.079]                           if (!grepl(pattern, name)) 
[18:00:59.079]                             next
[18:00:59.079]                           invokeRestart(restart)
[18:00:59.079]                           muffled <- TRUE
[18:00:59.079]                           break
[18:00:59.079]                         }
[18:00:59.079]                       }
[18:00:59.079]                     }
[18:00:59.079]                     invisible(muffled)
[18:00:59.079]                   }
[18:00:59.079]                   muffleCondition(cond)
[18:00:59.079]                 })
[18:00:59.079]             }))
[18:00:59.079]             future::FutureResult(value = ...future.value$value, 
[18:00:59.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.079]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.079]                     ...future.globalenv.names))
[18:00:59.079]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.079]         }, condition = base::local({
[18:00:59.079]             c <- base::c
[18:00:59.079]             inherits <- base::inherits
[18:00:59.079]             invokeRestart <- base::invokeRestart
[18:00:59.079]             length <- base::length
[18:00:59.079]             list <- base::list
[18:00:59.079]             seq.int <- base::seq.int
[18:00:59.079]             signalCondition <- base::signalCondition
[18:00:59.079]             sys.calls <- base::sys.calls
[18:00:59.079]             `[[` <- base::`[[`
[18:00:59.079]             `+` <- base::`+`
[18:00:59.079]             `<<-` <- base::`<<-`
[18:00:59.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.079]                   3L)]
[18:00:59.079]             }
[18:00:59.079]             function(cond) {
[18:00:59.079]                 is_error <- inherits(cond, "error")
[18:00:59.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.079]                   NULL)
[18:00:59.079]                 if (is_error) {
[18:00:59.079]                   sessionInformation <- function() {
[18:00:59.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.079]                       search = base::search(), system = base::Sys.info())
[18:00:59.079]                   }
[18:00:59.079]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.079]                     cond$call), session = sessionInformation(), 
[18:00:59.079]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.079]                   signalCondition(cond)
[18:00:59.079]                 }
[18:00:59.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.079]                 "immediateCondition"))) {
[18:00:59.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.079]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.079]                   if (TRUE && !signal) {
[18:00:59.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.079]                     {
[18:00:59.079]                       inherits <- base::inherits
[18:00:59.079]                       invokeRestart <- base::invokeRestart
[18:00:59.079]                       is.null <- base::is.null
[18:00:59.079]                       muffled <- FALSE
[18:00:59.079]                       if (inherits(cond, "message")) {
[18:00:59.079]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.079]                         if (muffled) 
[18:00:59.079]                           invokeRestart("muffleMessage")
[18:00:59.079]                       }
[18:00:59.079]                       else if (inherits(cond, "warning")) {
[18:00:59.079]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.079]                         if (muffled) 
[18:00:59.079]                           invokeRestart("muffleWarning")
[18:00:59.079]                       }
[18:00:59.079]                       else if (inherits(cond, "condition")) {
[18:00:59.079]                         if (!is.null(pattern)) {
[18:00:59.079]                           computeRestarts <- base::computeRestarts
[18:00:59.079]                           grepl <- base::grepl
[18:00:59.079]                           restarts <- computeRestarts(cond)
[18:00:59.079]                           for (restart in restarts) {
[18:00:59.079]                             name <- restart$name
[18:00:59.079]                             if (is.null(name)) 
[18:00:59.079]                               next
[18:00:59.079]                             if (!grepl(pattern, name)) 
[18:00:59.079]                               next
[18:00:59.079]                             invokeRestart(restart)
[18:00:59.079]                             muffled <- TRUE
[18:00:59.079]                             break
[18:00:59.079]                           }
[18:00:59.079]                         }
[18:00:59.079]                       }
[18:00:59.079]                       invisible(muffled)
[18:00:59.079]                     }
[18:00:59.079]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.079]                   }
[18:00:59.079]                 }
[18:00:59.079]                 else {
[18:00:59.079]                   if (TRUE) {
[18:00:59.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.079]                     {
[18:00:59.079]                       inherits <- base::inherits
[18:00:59.079]                       invokeRestart <- base::invokeRestart
[18:00:59.079]                       is.null <- base::is.null
[18:00:59.079]                       muffled <- FALSE
[18:00:59.079]                       if (inherits(cond, "message")) {
[18:00:59.079]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.079]                         if (muffled) 
[18:00:59.079]                           invokeRestart("muffleMessage")
[18:00:59.079]                       }
[18:00:59.079]                       else if (inherits(cond, "warning")) {
[18:00:59.079]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.079]                         if (muffled) 
[18:00:59.079]                           invokeRestart("muffleWarning")
[18:00:59.079]                       }
[18:00:59.079]                       else if (inherits(cond, "condition")) {
[18:00:59.079]                         if (!is.null(pattern)) {
[18:00:59.079]                           computeRestarts <- base::computeRestarts
[18:00:59.079]                           grepl <- base::grepl
[18:00:59.079]                           restarts <- computeRestarts(cond)
[18:00:59.079]                           for (restart in restarts) {
[18:00:59.079]                             name <- restart$name
[18:00:59.079]                             if (is.null(name)) 
[18:00:59.079]                               next
[18:00:59.079]                             if (!grepl(pattern, name)) 
[18:00:59.079]                               next
[18:00:59.079]                             invokeRestart(restart)
[18:00:59.079]                             muffled <- TRUE
[18:00:59.079]                             break
[18:00:59.079]                           }
[18:00:59.079]                         }
[18:00:59.079]                       }
[18:00:59.079]                       invisible(muffled)
[18:00:59.079]                     }
[18:00:59.079]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.079]                   }
[18:00:59.079]                 }
[18:00:59.079]             }
[18:00:59.079]         }))
[18:00:59.079]     }, error = function(ex) {
[18:00:59.079]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.079]                 ...future.rng), started = ...future.startTime, 
[18:00:59.079]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.079]             version = "1.8"), class = "FutureResult")
[18:00:59.079]     }, finally = {
[18:00:59.079]         if (!identical(...future.workdir, getwd())) 
[18:00:59.079]             setwd(...future.workdir)
[18:00:59.079]         {
[18:00:59.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.079]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.079]             }
[18:00:59.079]             base::options(...future.oldOptions)
[18:00:59.079]             if (.Platform$OS.type == "windows") {
[18:00:59.079]                 old_names <- names(...future.oldEnvVars)
[18:00:59.079]                 envs <- base::Sys.getenv()
[18:00:59.079]                 names <- names(envs)
[18:00:59.079]                 common <- intersect(names, old_names)
[18:00:59.079]                 added <- setdiff(names, old_names)
[18:00:59.079]                 removed <- setdiff(old_names, names)
[18:00:59.079]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.079]                   envs[common]]
[18:00:59.079]                 NAMES <- toupper(changed)
[18:00:59.079]                 args <- list()
[18:00:59.079]                 for (kk in seq_along(NAMES)) {
[18:00:59.079]                   name <- changed[[kk]]
[18:00:59.079]                   NAME <- NAMES[[kk]]
[18:00:59.079]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.079]                     next
[18:00:59.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.079]                 }
[18:00:59.079]                 NAMES <- toupper(added)
[18:00:59.079]                 for (kk in seq_along(NAMES)) {
[18:00:59.079]                   name <- added[[kk]]
[18:00:59.079]                   NAME <- NAMES[[kk]]
[18:00:59.079]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.079]                     next
[18:00:59.079]                   args[[name]] <- ""
[18:00:59.079]                 }
[18:00:59.079]                 NAMES <- toupper(removed)
[18:00:59.079]                 for (kk in seq_along(NAMES)) {
[18:00:59.079]                   name <- removed[[kk]]
[18:00:59.079]                   NAME <- NAMES[[kk]]
[18:00:59.079]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.079]                     next
[18:00:59.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.079]                 }
[18:00:59.079]                 if (length(args) > 0) 
[18:00:59.079]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.079]             }
[18:00:59.079]             else {
[18:00:59.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.079]             }
[18:00:59.079]             {
[18:00:59.079]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.079]                   0L) {
[18:00:59.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.079]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.079]                   base::options(opts)
[18:00:59.079]                 }
[18:00:59.079]                 {
[18:00:59.079]                   {
[18:00:59.079]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.079]                     NULL
[18:00:59.079]                   }
[18:00:59.079]                   options(future.plan = NULL)
[18:00:59.079]                   if (is.na(NA_character_)) 
[18:00:59.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.079]                     .init = FALSE)
[18:00:59.079]                 }
[18:00:59.079]             }
[18:00:59.079]         }
[18:00:59.079]     })
[18:00:59.079]     if (TRUE) {
[18:00:59.079]         base::sink(type = "output", split = FALSE)
[18:00:59.079]         if (TRUE) {
[18:00:59.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.079]         }
[18:00:59.079]         else {
[18:00:59.079]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.079]         }
[18:00:59.079]         base::close(...future.stdout)
[18:00:59.079]         ...future.stdout <- NULL
[18:00:59.079]     }
[18:00:59.079]     ...future.result$conditions <- ...future.conditions
[18:00:59.079]     ...future.result$finished <- base::Sys.time()
[18:00:59.079]     ...future.result
[18:00:59.079] }
[18:00:59.084] assign_globals() ...
[18:00:59.084] List of 5
[18:00:59.084]  $ ...future.FUN            :function (x, ...)  
[18:00:59.084]  $ MoreArgs                 : NULL
[18:00:59.084]  $ ...future.elements_ii    :List of 2
[18:00:59.084]   ..$ :List of 2
[18:00:59.084]   .. ..$ : int 1
[18:00:59.084]   .. ..$ : int 2
[18:00:59.084]   ..$ :List of 2
[18:00:59.084]   .. ..$ : int 4
[18:00:59.084]   .. ..$ : int 3
[18:00:59.084]  $ ...future.seeds_ii       : NULL
[18:00:59.084]  $ ...future.globals.maxSize: NULL
[18:00:59.084]  - attr(*, "where")=List of 5
[18:00:59.084]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.084]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.084]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.084]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.084]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.084]  - attr(*, "resolved")= logi FALSE
[18:00:59.084]  - attr(*, "total_size")= num 280
[18:00:59.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.084]  - attr(*, "already-done")= logi TRUE
[18:00:59.098] - copied ‘...future.FUN’ to environment
[18:00:59.099] - copied ‘MoreArgs’ to environment
[18:00:59.099] - copied ‘...future.elements_ii’ to environment
[18:00:59.099] - copied ‘...future.seeds_ii’ to environment
[18:00:59.099] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.099] assign_globals() ... done
[18:00:59.100] requestCore(): workers = 2
[18:00:59.105] MulticoreFuture started
[18:00:59.105] - Launch lazy future ... done
[18:00:59.106] run() for ‘MulticoreFuture’ ... done
[18:00:59.106] plan(): Setting new future strategy stack:
[18:00:59.106] Created future:
[18:00:59.107] List of future strategies:
[18:00:59.107] 1. sequential:
[18:00:59.107]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.107]    - tweaked: FALSE
[18:00:59.107]    - call: NULL
[18:00:59.109] plan(): nbrOfWorkers() = 1
[18:00:59.120] plan(): Setting new future strategy stack:
[18:00:59.121] List of future strategies:
[18:00:59.121] 1. multicore:
[18:00:59.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.121]    - tweaked: FALSE
[18:00:59.121]    - call: plan(strategy)
[18:00:59.107] MulticoreFuture:
[18:00:59.107] Label: ‘future_mapply-1’
[18:00:59.107] Expression:
[18:00:59.107] {
[18:00:59.107]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.107]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.107]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.107]         on.exit(options(oopts), add = TRUE)
[18:00:59.107]     }
[18:00:59.107]     {
[18:00:59.107]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.107]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.107]         do.call(mapply, args = args)
[18:00:59.107]     }
[18:00:59.107] }
[18:00:59.107] Lazy evaluation: FALSE
[18:00:59.107] Asynchronous evaluation: TRUE
[18:00:59.107] Local evaluation: TRUE
[18:00:59.107] Environment: R_GlobalEnv
[18:00:59.107] Capture standard output: TRUE
[18:00:59.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.107] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.107] Packages: <none>
[18:00:59.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.107] Resolved: FALSE
[18:00:59.107] Value: <not collected>
[18:00:59.107] Conditions captured: <none>
[18:00:59.107] Early signaling: FALSE
[18:00:59.107] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.107] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.133] Chunk #1 of 2 ... DONE
[18:00:59.133] plan(): nbrOfWorkers() = 2
[18:00:59.133] Chunk #2 of 2 ...
[18:00:59.134]  - Finding globals in '...' for chunk #2 ...
[18:00:59.134] getGlobalsAndPackages() ...
[18:00:59.135] Searching for globals...
[18:00:59.136] 
[18:00:59.136] Searching for globals ... DONE
[18:00:59.137] - globals: [0] <none>
[18:00:59.137] getGlobalsAndPackages() ... DONE
[18:00:59.137]    + additional globals found: [n=0] 
[18:00:59.138]    + additional namespaces needed: [n=0] 
[18:00:59.138]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:59.138]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.139]  - seeds: <none>
[18:00:59.139]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.140] getGlobalsAndPackages() ...
[18:00:59.140] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.141] Resolving globals: FALSE
[18:00:59.143] The total size of the 5 globals is 280 bytes (280 bytes)
[18:00:59.144] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.145] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.147] 
[18:00:59.147] getGlobalsAndPackages() ... DONE
[18:00:59.148] run() for ‘Future’ ...
[18:00:59.149] - state: ‘created’
[18:00:59.151] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.159] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.160]   - Field: ‘label’
[18:00:59.161]   - Field: ‘local’
[18:00:59.161]   - Field: ‘owner’
[18:00:59.162]   - Field: ‘envir’
[18:00:59.162]   - Field: ‘workers’
[18:00:59.162]   - Field: ‘packages’
[18:00:59.163]   - Field: ‘gc’
[18:00:59.163]   - Field: ‘job’
[18:00:59.163]   - Field: ‘conditions’
[18:00:59.164]   - Field: ‘expr’
[18:00:59.164]   - Field: ‘uuid’
[18:00:59.164]   - Field: ‘seed’
[18:00:59.165]   - Field: ‘version’
[18:00:59.165]   - Field: ‘result’
[18:00:59.165]   - Field: ‘asynchronous’
[18:00:59.165]   - Field: ‘calls’
[18:00:59.166]   - Field: ‘globals’
[18:00:59.166]   - Field: ‘stdout’
[18:00:59.166]   - Field: ‘earlySignal’
[18:00:59.167]   - Field: ‘lazy’
[18:00:59.167]   - Field: ‘state’
[18:00:59.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.167] - Launch lazy future ...
[18:00:59.168] Packages needed by the future expression (n = 0): <none>
[18:00:59.169] Packages needed by future strategies (n = 0): <none>
[18:00:59.170] {
[18:00:59.170]     {
[18:00:59.170]         {
[18:00:59.170]             ...future.startTime <- base::Sys.time()
[18:00:59.170]             {
[18:00:59.170]                 {
[18:00:59.170]                   {
[18:00:59.170]                     {
[18:00:59.170]                       base::local({
[18:00:59.170]                         has_future <- base::requireNamespace("future", 
[18:00:59.170]                           quietly = TRUE)
[18:00:59.170]                         if (has_future) {
[18:00:59.170]                           ns <- base::getNamespace("future")
[18:00:59.170]                           version <- ns[[".package"]][["version"]]
[18:00:59.170]                           if (is.null(version)) 
[18:00:59.170]                             version <- utils::packageVersion("future")
[18:00:59.170]                         }
[18:00:59.170]                         else {
[18:00:59.170]                           version <- NULL
[18:00:59.170]                         }
[18:00:59.170]                         if (!has_future || version < "1.8.0") {
[18:00:59.170]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.170]                             "", base::R.version$version.string), 
[18:00:59.170]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.170]                               "release", "version")], collapse = " "), 
[18:00:59.170]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.170]                             info)
[18:00:59.170]                           info <- base::paste(info, collapse = "; ")
[18:00:59.170]                           if (!has_future) {
[18:00:59.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.170]                               info)
[18:00:59.170]                           }
[18:00:59.170]                           else {
[18:00:59.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.170]                               info, version)
[18:00:59.170]                           }
[18:00:59.170]                           base::stop(msg)
[18:00:59.170]                         }
[18:00:59.170]                       })
[18:00:59.170]                     }
[18:00:59.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.170]                     base::options(mc.cores = 1L)
[18:00:59.170]                   }
[18:00:59.170]                   ...future.strategy.old <- future::plan("list")
[18:00:59.170]                   options(future.plan = NULL)
[18:00:59.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.170]                 }
[18:00:59.170]                 ...future.workdir <- getwd()
[18:00:59.170]             }
[18:00:59.170]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.170]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.170]         }
[18:00:59.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.170]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.170]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.170]             base::names(...future.oldOptions))
[18:00:59.170]     }
[18:00:59.170]     if (FALSE) {
[18:00:59.170]     }
[18:00:59.170]     else {
[18:00:59.170]         if (TRUE) {
[18:00:59.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.170]                 open = "w")
[18:00:59.170]         }
[18:00:59.170]         else {
[18:00:59.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.170]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.170]         }
[18:00:59.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.170]             base::sink(type = "output", split = FALSE)
[18:00:59.170]             base::close(...future.stdout)
[18:00:59.170]         }, add = TRUE)
[18:00:59.170]     }
[18:00:59.170]     ...future.frame <- base::sys.nframe()
[18:00:59.170]     ...future.conditions <- base::list()
[18:00:59.170]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.170]     if (FALSE) {
[18:00:59.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.170]     }
[18:00:59.170]     ...future.result <- base::tryCatch({
[18:00:59.170]         base::withCallingHandlers({
[18:00:59.170]             ...future.value <- base::withVisible(base::local({
[18:00:59.170]                 withCallingHandlers({
[18:00:59.170]                   {
[18:00:59.170]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.170]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.170]                       ...future.globals.maxSize)) {
[18:00:59.170]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.170]                       on.exit(options(oopts), add = TRUE)
[18:00:59.170]                     }
[18:00:59.170]                     {
[18:00:59.170]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.170]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.170]                         USE.NAMES = FALSE)
[18:00:59.170]                       do.call(mapply, args = args)
[18:00:59.170]                     }
[18:00:59.170]                   }
[18:00:59.170]                 }, immediateCondition = function(cond) {
[18:00:59.170]                   save_rds <- function (object, pathname, ...) 
[18:00:59.170]                   {
[18:00:59.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.170]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.170]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.170]                         fi_tmp[["mtime"]])
[18:00:59.170]                     }
[18:00:59.170]                     tryCatch({
[18:00:59.170]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.170]                     }, error = function(ex) {
[18:00:59.170]                       msg <- conditionMessage(ex)
[18:00:59.170]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.170]                         fi_tmp[["mtime"]], msg)
[18:00:59.170]                       ex$message <- msg
[18:00:59.170]                       stop(ex)
[18:00:59.170]                     })
[18:00:59.170]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.170]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.170]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.170]                       fi <- file.info(pathname)
[18:00:59.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.170]                         fi[["size"]], fi[["mtime"]])
[18:00:59.170]                       stop(msg)
[18:00:59.170]                     }
[18:00:59.170]                     invisible(pathname)
[18:00:59.170]                   }
[18:00:59.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.170]                     rootPath = tempdir()) 
[18:00:59.170]                   {
[18:00:59.170]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.170]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.170]                       tmpdir = path, fileext = ".rds")
[18:00:59.170]                     save_rds(obj, file)
[18:00:59.170]                   }
[18:00:59.170]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.170]                   {
[18:00:59.170]                     inherits <- base::inherits
[18:00:59.170]                     invokeRestart <- base::invokeRestart
[18:00:59.170]                     is.null <- base::is.null
[18:00:59.170]                     muffled <- FALSE
[18:00:59.170]                     if (inherits(cond, "message")) {
[18:00:59.170]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.170]                       if (muffled) 
[18:00:59.170]                         invokeRestart("muffleMessage")
[18:00:59.170]                     }
[18:00:59.170]                     else if (inherits(cond, "warning")) {
[18:00:59.170]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.170]                       if (muffled) 
[18:00:59.170]                         invokeRestart("muffleWarning")
[18:00:59.170]                     }
[18:00:59.170]                     else if (inherits(cond, "condition")) {
[18:00:59.170]                       if (!is.null(pattern)) {
[18:00:59.170]                         computeRestarts <- base::computeRestarts
[18:00:59.170]                         grepl <- base::grepl
[18:00:59.170]                         restarts <- computeRestarts(cond)
[18:00:59.170]                         for (restart in restarts) {
[18:00:59.170]                           name <- restart$name
[18:00:59.170]                           if (is.null(name)) 
[18:00:59.170]                             next
[18:00:59.170]                           if (!grepl(pattern, name)) 
[18:00:59.170]                             next
[18:00:59.170]                           invokeRestart(restart)
[18:00:59.170]                           muffled <- TRUE
[18:00:59.170]                           break
[18:00:59.170]                         }
[18:00:59.170]                       }
[18:00:59.170]                     }
[18:00:59.170]                     invisible(muffled)
[18:00:59.170]                   }
[18:00:59.170]                   muffleCondition(cond)
[18:00:59.170]                 })
[18:00:59.170]             }))
[18:00:59.170]             future::FutureResult(value = ...future.value$value, 
[18:00:59.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.170]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.170]                     ...future.globalenv.names))
[18:00:59.170]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.170]         }, condition = base::local({
[18:00:59.170]             c <- base::c
[18:00:59.170]             inherits <- base::inherits
[18:00:59.170]             invokeRestart <- base::invokeRestart
[18:00:59.170]             length <- base::length
[18:00:59.170]             list <- base::list
[18:00:59.170]             seq.int <- base::seq.int
[18:00:59.170]             signalCondition <- base::signalCondition
[18:00:59.170]             sys.calls <- base::sys.calls
[18:00:59.170]             `[[` <- base::`[[`
[18:00:59.170]             `+` <- base::`+`
[18:00:59.170]             `<<-` <- base::`<<-`
[18:00:59.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.170]                   3L)]
[18:00:59.170]             }
[18:00:59.170]             function(cond) {
[18:00:59.170]                 is_error <- inherits(cond, "error")
[18:00:59.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.170]                   NULL)
[18:00:59.170]                 if (is_error) {
[18:00:59.170]                   sessionInformation <- function() {
[18:00:59.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.170]                       search = base::search(), system = base::Sys.info())
[18:00:59.170]                   }
[18:00:59.170]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.170]                     cond$call), session = sessionInformation(), 
[18:00:59.170]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.170]                   signalCondition(cond)
[18:00:59.170]                 }
[18:00:59.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.170]                 "immediateCondition"))) {
[18:00:59.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.170]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.170]                   if (TRUE && !signal) {
[18:00:59.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.170]                     {
[18:00:59.170]                       inherits <- base::inherits
[18:00:59.170]                       invokeRestart <- base::invokeRestart
[18:00:59.170]                       is.null <- base::is.null
[18:00:59.170]                       muffled <- FALSE
[18:00:59.170]                       if (inherits(cond, "message")) {
[18:00:59.170]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.170]                         if (muffled) 
[18:00:59.170]                           invokeRestart("muffleMessage")
[18:00:59.170]                       }
[18:00:59.170]                       else if (inherits(cond, "warning")) {
[18:00:59.170]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.170]                         if (muffled) 
[18:00:59.170]                           invokeRestart("muffleWarning")
[18:00:59.170]                       }
[18:00:59.170]                       else if (inherits(cond, "condition")) {
[18:00:59.170]                         if (!is.null(pattern)) {
[18:00:59.170]                           computeRestarts <- base::computeRestarts
[18:00:59.170]                           grepl <- base::grepl
[18:00:59.170]                           restarts <- computeRestarts(cond)
[18:00:59.170]                           for (restart in restarts) {
[18:00:59.170]                             name <- restart$name
[18:00:59.170]                             if (is.null(name)) 
[18:00:59.170]                               next
[18:00:59.170]                             if (!grepl(pattern, name)) 
[18:00:59.170]                               next
[18:00:59.170]                             invokeRestart(restart)
[18:00:59.170]                             muffled <- TRUE
[18:00:59.170]                             break
[18:00:59.170]                           }
[18:00:59.170]                         }
[18:00:59.170]                       }
[18:00:59.170]                       invisible(muffled)
[18:00:59.170]                     }
[18:00:59.170]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.170]                   }
[18:00:59.170]                 }
[18:00:59.170]                 else {
[18:00:59.170]                   if (TRUE) {
[18:00:59.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.170]                     {
[18:00:59.170]                       inherits <- base::inherits
[18:00:59.170]                       invokeRestart <- base::invokeRestart
[18:00:59.170]                       is.null <- base::is.null
[18:00:59.170]                       muffled <- FALSE
[18:00:59.170]                       if (inherits(cond, "message")) {
[18:00:59.170]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.170]                         if (muffled) 
[18:00:59.170]                           invokeRestart("muffleMessage")
[18:00:59.170]                       }
[18:00:59.170]                       else if (inherits(cond, "warning")) {
[18:00:59.170]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.170]                         if (muffled) 
[18:00:59.170]                           invokeRestart("muffleWarning")
[18:00:59.170]                       }
[18:00:59.170]                       else if (inherits(cond, "condition")) {
[18:00:59.170]                         if (!is.null(pattern)) {
[18:00:59.170]                           computeRestarts <- base::computeRestarts
[18:00:59.170]                           grepl <- base::grepl
[18:00:59.170]                           restarts <- computeRestarts(cond)
[18:00:59.170]                           for (restart in restarts) {
[18:00:59.170]                             name <- restart$name
[18:00:59.170]                             if (is.null(name)) 
[18:00:59.170]                               next
[18:00:59.170]                             if (!grepl(pattern, name)) 
[18:00:59.170]                               next
[18:00:59.170]                             invokeRestart(restart)
[18:00:59.170]                             muffled <- TRUE
[18:00:59.170]                             break
[18:00:59.170]                           }
[18:00:59.170]                         }
[18:00:59.170]                       }
[18:00:59.170]                       invisible(muffled)
[18:00:59.170]                     }
[18:00:59.170]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.170]                   }
[18:00:59.170]                 }
[18:00:59.170]             }
[18:00:59.170]         }))
[18:00:59.170]     }, error = function(ex) {
[18:00:59.170]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.170]                 ...future.rng), started = ...future.startTime, 
[18:00:59.170]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.170]             version = "1.8"), class = "FutureResult")
[18:00:59.170]     }, finally = {
[18:00:59.170]         if (!identical(...future.workdir, getwd())) 
[18:00:59.170]             setwd(...future.workdir)
[18:00:59.170]         {
[18:00:59.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.170]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.170]             }
[18:00:59.170]             base::options(...future.oldOptions)
[18:00:59.170]             if (.Platform$OS.type == "windows") {
[18:00:59.170]                 old_names <- names(...future.oldEnvVars)
[18:00:59.170]                 envs <- base::Sys.getenv()
[18:00:59.170]                 names <- names(envs)
[18:00:59.170]                 common <- intersect(names, old_names)
[18:00:59.170]                 added <- setdiff(names, old_names)
[18:00:59.170]                 removed <- setdiff(old_names, names)
[18:00:59.170]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.170]                   envs[common]]
[18:00:59.170]                 NAMES <- toupper(changed)
[18:00:59.170]                 args <- list()
[18:00:59.170]                 for (kk in seq_along(NAMES)) {
[18:00:59.170]                   name <- changed[[kk]]
[18:00:59.170]                   NAME <- NAMES[[kk]]
[18:00:59.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.170]                     next
[18:00:59.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.170]                 }
[18:00:59.170]                 NAMES <- toupper(added)
[18:00:59.170]                 for (kk in seq_along(NAMES)) {
[18:00:59.170]                   name <- added[[kk]]
[18:00:59.170]                   NAME <- NAMES[[kk]]
[18:00:59.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.170]                     next
[18:00:59.170]                   args[[name]] <- ""
[18:00:59.170]                 }
[18:00:59.170]                 NAMES <- toupper(removed)
[18:00:59.170]                 for (kk in seq_along(NAMES)) {
[18:00:59.170]                   name <- removed[[kk]]
[18:00:59.170]                   NAME <- NAMES[[kk]]
[18:00:59.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.170]                     next
[18:00:59.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.170]                 }
[18:00:59.170]                 if (length(args) > 0) 
[18:00:59.170]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.170]             }
[18:00:59.170]             else {
[18:00:59.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.170]             }
[18:00:59.170]             {
[18:00:59.170]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.170]                   0L) {
[18:00:59.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.170]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.170]                   base::options(opts)
[18:00:59.170]                 }
[18:00:59.170]                 {
[18:00:59.170]                   {
[18:00:59.170]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.170]                     NULL
[18:00:59.170]                   }
[18:00:59.170]                   options(future.plan = NULL)
[18:00:59.170]                   if (is.na(NA_character_)) 
[18:00:59.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.170]                     .init = FALSE)
[18:00:59.170]                 }
[18:00:59.170]             }
[18:00:59.170]         }
[18:00:59.170]     })
[18:00:59.170]     if (TRUE) {
[18:00:59.170]         base::sink(type = "output", split = FALSE)
[18:00:59.170]         if (TRUE) {
[18:00:59.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.170]         }
[18:00:59.170]         else {
[18:00:59.170]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.170]         }
[18:00:59.170]         base::close(...future.stdout)
[18:00:59.170]         ...future.stdout <- NULL
[18:00:59.170]     }
[18:00:59.170]     ...future.result$conditions <- ...future.conditions
[18:00:59.170]     ...future.result$finished <- base::Sys.time()
[18:00:59.170]     ...future.result
[18:00:59.170] }
[18:00:59.175] assign_globals() ...
[18:00:59.176] List of 5
[18:00:59.176]  $ ...future.FUN            :function (x, ...)  
[18:00:59.176]  $ MoreArgs                 : NULL
[18:00:59.176]  $ ...future.elements_ii    :List of 2
[18:00:59.176]   ..$ :List of 2
[18:00:59.176]   .. ..$ : int 3
[18:00:59.176]   .. ..$ : int 4
[18:00:59.176]   ..$ :List of 2
[18:00:59.176]   .. ..$ : int 2
[18:00:59.176]   .. ..$ : int 1
[18:00:59.176]  $ ...future.seeds_ii       : NULL
[18:00:59.176]  $ ...future.globals.maxSize: NULL
[18:00:59.176]  - attr(*, "where")=List of 5
[18:00:59.176]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.176]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.176]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.176]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.176]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.176]  - attr(*, "resolved")= logi FALSE
[18:00:59.176]  - attr(*, "total_size")= num 280
[18:00:59.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.176]  - attr(*, "already-done")= logi TRUE
[18:00:59.191] - copied ‘...future.FUN’ to environment
[18:00:59.191] - copied ‘MoreArgs’ to environment
[18:00:59.191] - copied ‘...future.elements_ii’ to environment
[18:00:59.191] - copied ‘...future.seeds_ii’ to environment
[18:00:59.192] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.192] assign_globals() ... done
[18:00:59.192] requestCore(): workers = 2
[18:00:59.202] MulticoreFuture started
[18:00:59.203] - Launch lazy future ... done
[18:00:59.204] run() for ‘MulticoreFuture’ ... done
[18:00:59.204] Created future:
[18:00:59.204] plan(): Setting new future strategy stack:
[18:00:59.205] List of future strategies:
[18:00:59.205] 1. sequential:
[18:00:59.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.205]    - tweaked: FALSE
[18:00:59.205]    - call: NULL
[18:00:59.207] plan(): nbrOfWorkers() = 1
[18:00:59.211] plan(): Setting new future strategy stack:
[18:00:59.211] List of future strategies:
[18:00:59.211] 1. multicore:
[18:00:59.211]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.211]    - tweaked: FALSE
[18:00:59.211]    - call: plan(strategy)
[18:00:59.205] MulticoreFuture:
[18:00:59.205] Label: ‘future_mapply-2’
[18:00:59.205] Expression:
[18:00:59.205] {
[18:00:59.205]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.205]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.205]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.205]         on.exit(options(oopts), add = TRUE)
[18:00:59.205]     }
[18:00:59.205]     {
[18:00:59.205]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.205]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.205]         do.call(mapply, args = args)
[18:00:59.205]     }
[18:00:59.205] }
[18:00:59.205] Lazy evaluation: FALSE
[18:00:59.205] Asynchronous evaluation: TRUE
[18:00:59.205] Local evaluation: TRUE
[18:00:59.205] Environment: R_GlobalEnv
[18:00:59.205] Capture standard output: TRUE
[18:00:59.205] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.205] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.205] Packages: <none>
[18:00:59.205] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.205] Resolved: FALSE
[18:00:59.205] Value: <not collected>
[18:00:59.205] Conditions captured: <none>
[18:00:59.205] Early signaling: FALSE
[18:00:59.205] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.205] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.220] Chunk #2 of 2 ... DONE
[18:00:59.220] Launching 2 futures (chunks) ... DONE
[18:00:59.220] Resolving 2 futures (chunks) ...
[18:00:59.221] resolve() on list ...
[18:00:59.221] plan(): nbrOfWorkers() = 2
[18:00:59.221]  recursive: 0
[18:00:59.221]  length: 2
[18:00:59.222] 
[18:00:59.222] Future #1
[18:00:59.223] result() for MulticoreFuture ...
[18:00:59.227] result() for MulticoreFuture ...
[18:00:59.227] result() for MulticoreFuture ... done
[18:00:59.227] result() for MulticoreFuture ... done
[18:00:59.228] result() for MulticoreFuture ...
[18:00:59.228] result() for MulticoreFuture ... done
[18:00:59.235] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:00:59.236] - nx: 2
[18:00:59.236] - relay: TRUE
[18:00:59.237] - stdout: TRUE
[18:00:59.237] - signal: TRUE
[18:00:59.238] - resignal: FALSE
[18:00:59.238] - force: TRUE
[18:00:59.239] - relayed: [n=2] FALSE, FALSE
[18:00:59.239] - queued futures: [n=2] FALSE, FALSE
[18:00:59.240]  - until=1
[18:00:59.241]  - relaying element #1
[18:00:59.241] result() for MulticoreFuture ...
[18:00:59.242] result() for MulticoreFuture ... done
[18:00:59.242] result() for MulticoreFuture ...
[18:00:59.243] result() for MulticoreFuture ... done
[18:00:59.244] result() for MulticoreFuture ...
[18:00:59.244] result() for MulticoreFuture ... done
[18:00:59.245] result() for MulticoreFuture ...
[18:00:59.245] result() for MulticoreFuture ... done
[18:00:59.245] - relayed: [n=2] TRUE, FALSE
[18:00:59.246] - queued futures: [n=2] TRUE, FALSE
[18:00:59.246] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:00:59.247]  length: 1 (resolved future 1)
[18:00:59.248] Future #2
[18:00:59.248] result() for MulticoreFuture ...
[18:00:59.250] result() for MulticoreFuture ...
[18:00:59.250] result() for MulticoreFuture ... done
[18:00:59.251] result() for MulticoreFuture ... done
[18:00:59.251] result() for MulticoreFuture ...
[18:00:59.251] result() for MulticoreFuture ... done
[18:00:59.252] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:00:59.252] - nx: 2
[18:00:59.252] - relay: TRUE
[18:00:59.252] - stdout: TRUE
[18:00:59.252] - signal: TRUE
[18:00:59.253] - resignal: FALSE
[18:00:59.253] - force: TRUE
[18:00:59.253] - relayed: [n=2] TRUE, FALSE
[18:00:59.253] - queued futures: [n=2] TRUE, FALSE
[18:00:59.254]  - until=2
[18:00:59.254]  - relaying element #2
[18:00:59.254] result() for MulticoreFuture ...
[18:00:59.254] result() for MulticoreFuture ... done
[18:00:59.255] result() for MulticoreFuture ...
[18:00:59.255] result() for MulticoreFuture ... done
[18:00:59.255] result() for MulticoreFuture ...
[18:00:59.255] result() for MulticoreFuture ... done
[18:00:59.256] result() for MulticoreFuture ...
[18:00:59.256] result() for MulticoreFuture ... done
[18:00:59.256] - relayed: [n=2] TRUE, TRUE
[18:00:59.256] - queued futures: [n=2] TRUE, TRUE
[18:00:59.256] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:00:59.257]  length: 0 (resolved future 2)
[18:00:59.257] Relaying remaining futures
[18:00:59.257] signalConditionsASAP(NULL, pos=0) ...
[18:00:59.257] - nx: 2
[18:00:59.258] - relay: TRUE
[18:00:59.258] - stdout: TRUE
[18:00:59.258] - signal: TRUE
[18:00:59.258] - resignal: FALSE
[18:00:59.258] - force: TRUE
[18:00:59.259] - relayed: [n=2] TRUE, TRUE
[18:00:59.259] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:00:59.259] - relayed: [n=2] TRUE, TRUE
[18:00:59.259] - queued futures: [n=2] TRUE, TRUE
[18:00:59.260] signalConditionsASAP(NULL, pos=0) ... done
[18:00:59.260] resolve() on list ... DONE
[18:00:59.260] result() for MulticoreFuture ...
[18:00:59.260] result() for MulticoreFuture ... done
[18:00:59.260] result() for MulticoreFuture ...
[18:00:59.261] result() for MulticoreFuture ... done
[18:00:59.261] result() for MulticoreFuture ...
[18:00:59.261] result() for MulticoreFuture ... done
[18:00:59.261] result() for MulticoreFuture ...
[18:00:59.262] result() for MulticoreFuture ... done
[18:00:59.262]  - Number of value chunks collected: 2
[18:00:59.262] Resolving 2 futures (chunks) ... DONE
[18:00:59.262] Reducing values from 2 chunks ...
[18:00:59.262]  - Number of values collected after concatenation: 4
[18:00:59.263]  - Number of values expected: 4
[18:00:59.263] Reducing values from 2 chunks ... DONE
[18:00:59.263] future_mapply() ... DONE
[18:00:59.263] future_mapply() ...
[18:00:59.271] Number of chunks: 2
[18:00:59.271] getGlobalsAndPackagesXApply() ...
[18:00:59.271]  - future.globals: TRUE
[18:00:59.271] getGlobalsAndPackages() ...
[18:00:59.271] Searching for globals...
[18:00:59.273] - globals found: [1] ‘FUN’
[18:00:59.273] Searching for globals ... DONE
[18:00:59.273] Resolving globals: FALSE
[18:00:59.274] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:59.275] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:59.275] - globals: [1] ‘FUN’
[18:00:59.275] 
[18:00:59.275] getGlobalsAndPackages() ... DONE
[18:00:59.276]  - globals found/used: [n=1] ‘FUN’
[18:00:59.276]  - needed namespaces: [n=0] 
[18:00:59.276] Finding globals ... DONE
[18:00:59.276] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:59.277] List of 2
[18:00:59.277]  $ ...future.FUN:function (x, ...)  
[18:00:59.277]  $ MoreArgs     : NULL
[18:00:59.277]  - attr(*, "where")=List of 2
[18:00:59.277]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:59.277]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:59.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.277]  - attr(*, "resolved")= logi FALSE
[18:00:59.277]  - attr(*, "total_size")= num NA
[18:00:59.282] Packages to be attached in all futures: [n=0] 
[18:00:59.282] getGlobalsAndPackagesXApply() ... DONE
[18:00:59.283] Number of futures (= number of chunks): 2
[18:00:59.283] Launching 2 futures (chunks) ...
[18:00:59.283] Chunk #1 of 2 ...
[18:00:59.284]  - Finding globals in '...' for chunk #1 ...
[18:00:59.284] getGlobalsAndPackages() ...
[18:00:59.284] Searching for globals...
[18:00:59.285] 
[18:00:59.285] Searching for globals ... DONE
[18:00:59.285] - globals: [0] <none>
[18:00:59.285] getGlobalsAndPackages() ... DONE
[18:00:59.286]    + additional globals found: [n=0] 
[18:00:59.286]    + additional namespaces needed: [n=0] 
[18:00:59.286]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:59.286]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.286]  - seeds: <none>
[18:00:59.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.287] getGlobalsAndPackages() ...
[18:00:59.287] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.287] Resolving globals: FALSE
[18:00:59.288] The total size of the 5 globals is 280 bytes (280 bytes)
[18:00:59.289] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.290] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.290] 
[18:00:59.290] getGlobalsAndPackages() ... DONE
[18:00:59.291] run() for ‘Future’ ...
[18:00:59.291] - state: ‘created’
[18:00:59.291] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.298] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.298]   - Field: ‘label’
[18:00:59.298]   - Field: ‘local’
[18:00:59.299]   - Field: ‘owner’
[18:00:59.299]   - Field: ‘envir’
[18:00:59.299]   - Field: ‘workers’
[18:00:59.299]   - Field: ‘packages’
[18:00:59.299]   - Field: ‘gc’
[18:00:59.300]   - Field: ‘job’
[18:00:59.300]   - Field: ‘conditions’
[18:00:59.300]   - Field: ‘expr’
[18:00:59.300]   - Field: ‘uuid’
[18:00:59.300]   - Field: ‘seed’
[18:00:59.301]   - Field: ‘version’
[18:00:59.301]   - Field: ‘result’
[18:00:59.301]   - Field: ‘asynchronous’
[18:00:59.304]   - Field: ‘calls’
[18:00:59.304]   - Field: ‘globals’
[18:00:59.304]   - Field: ‘stdout’
[18:00:59.305]   - Field: ‘earlySignal’
[18:00:59.305]   - Field: ‘lazy’
[18:00:59.305]   - Field: ‘state’
[18:00:59.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.305] - Launch lazy future ...
[18:00:59.306] Packages needed by the future expression (n = 0): <none>
[18:00:59.306] Packages needed by future strategies (n = 0): <none>
[18:00:59.307] {
[18:00:59.307]     {
[18:00:59.307]         {
[18:00:59.307]             ...future.startTime <- base::Sys.time()
[18:00:59.307]             {
[18:00:59.307]                 {
[18:00:59.307]                   {
[18:00:59.307]                     {
[18:00:59.307]                       base::local({
[18:00:59.307]                         has_future <- base::requireNamespace("future", 
[18:00:59.307]                           quietly = TRUE)
[18:00:59.307]                         if (has_future) {
[18:00:59.307]                           ns <- base::getNamespace("future")
[18:00:59.307]                           version <- ns[[".package"]][["version"]]
[18:00:59.307]                           if (is.null(version)) 
[18:00:59.307]                             version <- utils::packageVersion("future")
[18:00:59.307]                         }
[18:00:59.307]                         else {
[18:00:59.307]                           version <- NULL
[18:00:59.307]                         }
[18:00:59.307]                         if (!has_future || version < "1.8.0") {
[18:00:59.307]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.307]                             "", base::R.version$version.string), 
[18:00:59.307]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.307]                               "release", "version")], collapse = " "), 
[18:00:59.307]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.307]                             info)
[18:00:59.307]                           info <- base::paste(info, collapse = "; ")
[18:00:59.307]                           if (!has_future) {
[18:00:59.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.307]                               info)
[18:00:59.307]                           }
[18:00:59.307]                           else {
[18:00:59.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.307]                               info, version)
[18:00:59.307]                           }
[18:00:59.307]                           base::stop(msg)
[18:00:59.307]                         }
[18:00:59.307]                       })
[18:00:59.307]                     }
[18:00:59.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.307]                     base::options(mc.cores = 1L)
[18:00:59.307]                   }
[18:00:59.307]                   ...future.strategy.old <- future::plan("list")
[18:00:59.307]                   options(future.plan = NULL)
[18:00:59.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.307]                 }
[18:00:59.307]                 ...future.workdir <- getwd()
[18:00:59.307]             }
[18:00:59.307]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.307]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.307]         }
[18:00:59.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.307]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.307]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.307]             base::names(...future.oldOptions))
[18:00:59.307]     }
[18:00:59.307]     if (FALSE) {
[18:00:59.307]     }
[18:00:59.307]     else {
[18:00:59.307]         if (TRUE) {
[18:00:59.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.307]                 open = "w")
[18:00:59.307]         }
[18:00:59.307]         else {
[18:00:59.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.307]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.307]         }
[18:00:59.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.307]             base::sink(type = "output", split = FALSE)
[18:00:59.307]             base::close(...future.stdout)
[18:00:59.307]         }, add = TRUE)
[18:00:59.307]     }
[18:00:59.307]     ...future.frame <- base::sys.nframe()
[18:00:59.307]     ...future.conditions <- base::list()
[18:00:59.307]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.307]     if (FALSE) {
[18:00:59.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.307]     }
[18:00:59.307]     ...future.result <- base::tryCatch({
[18:00:59.307]         base::withCallingHandlers({
[18:00:59.307]             ...future.value <- base::withVisible(base::local({
[18:00:59.307]                 withCallingHandlers({
[18:00:59.307]                   {
[18:00:59.307]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.307]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.307]                       ...future.globals.maxSize)) {
[18:00:59.307]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.307]                       on.exit(options(oopts), add = TRUE)
[18:00:59.307]                     }
[18:00:59.307]                     {
[18:00:59.307]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.307]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.307]                         USE.NAMES = FALSE)
[18:00:59.307]                       do.call(mapply, args = args)
[18:00:59.307]                     }
[18:00:59.307]                   }
[18:00:59.307]                 }, immediateCondition = function(cond) {
[18:00:59.307]                   save_rds <- function (object, pathname, ...) 
[18:00:59.307]                   {
[18:00:59.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.307]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.307]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.307]                         fi_tmp[["mtime"]])
[18:00:59.307]                     }
[18:00:59.307]                     tryCatch({
[18:00:59.307]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.307]                     }, error = function(ex) {
[18:00:59.307]                       msg <- conditionMessage(ex)
[18:00:59.307]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.307]                         fi_tmp[["mtime"]], msg)
[18:00:59.307]                       ex$message <- msg
[18:00:59.307]                       stop(ex)
[18:00:59.307]                     })
[18:00:59.307]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.307]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.307]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.307]                       fi <- file.info(pathname)
[18:00:59.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.307]                         fi[["size"]], fi[["mtime"]])
[18:00:59.307]                       stop(msg)
[18:00:59.307]                     }
[18:00:59.307]                     invisible(pathname)
[18:00:59.307]                   }
[18:00:59.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.307]                     rootPath = tempdir()) 
[18:00:59.307]                   {
[18:00:59.307]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.307]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.307]                       tmpdir = path, fileext = ".rds")
[18:00:59.307]                     save_rds(obj, file)
[18:00:59.307]                   }
[18:00:59.307]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.307]                   {
[18:00:59.307]                     inherits <- base::inherits
[18:00:59.307]                     invokeRestart <- base::invokeRestart
[18:00:59.307]                     is.null <- base::is.null
[18:00:59.307]                     muffled <- FALSE
[18:00:59.307]                     if (inherits(cond, "message")) {
[18:00:59.307]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.307]                       if (muffled) 
[18:00:59.307]                         invokeRestart("muffleMessage")
[18:00:59.307]                     }
[18:00:59.307]                     else if (inherits(cond, "warning")) {
[18:00:59.307]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.307]                       if (muffled) 
[18:00:59.307]                         invokeRestart("muffleWarning")
[18:00:59.307]                     }
[18:00:59.307]                     else if (inherits(cond, "condition")) {
[18:00:59.307]                       if (!is.null(pattern)) {
[18:00:59.307]                         computeRestarts <- base::computeRestarts
[18:00:59.307]                         grepl <- base::grepl
[18:00:59.307]                         restarts <- computeRestarts(cond)
[18:00:59.307]                         for (restart in restarts) {
[18:00:59.307]                           name <- restart$name
[18:00:59.307]                           if (is.null(name)) 
[18:00:59.307]                             next
[18:00:59.307]                           if (!grepl(pattern, name)) 
[18:00:59.307]                             next
[18:00:59.307]                           invokeRestart(restart)
[18:00:59.307]                           muffled <- TRUE
[18:00:59.307]                           break
[18:00:59.307]                         }
[18:00:59.307]                       }
[18:00:59.307]                     }
[18:00:59.307]                     invisible(muffled)
[18:00:59.307]                   }
[18:00:59.307]                   muffleCondition(cond)
[18:00:59.307]                 })
[18:00:59.307]             }))
[18:00:59.307]             future::FutureResult(value = ...future.value$value, 
[18:00:59.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.307]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.307]                     ...future.globalenv.names))
[18:00:59.307]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.307]         }, condition = base::local({
[18:00:59.307]             c <- base::c
[18:00:59.307]             inherits <- base::inherits
[18:00:59.307]             invokeRestart <- base::invokeRestart
[18:00:59.307]             length <- base::length
[18:00:59.307]             list <- base::list
[18:00:59.307]             seq.int <- base::seq.int
[18:00:59.307]             signalCondition <- base::signalCondition
[18:00:59.307]             sys.calls <- base::sys.calls
[18:00:59.307]             `[[` <- base::`[[`
[18:00:59.307]             `+` <- base::`+`
[18:00:59.307]             `<<-` <- base::`<<-`
[18:00:59.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.307]                   3L)]
[18:00:59.307]             }
[18:00:59.307]             function(cond) {
[18:00:59.307]                 is_error <- inherits(cond, "error")
[18:00:59.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.307]                   NULL)
[18:00:59.307]                 if (is_error) {
[18:00:59.307]                   sessionInformation <- function() {
[18:00:59.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.307]                       search = base::search(), system = base::Sys.info())
[18:00:59.307]                   }
[18:00:59.307]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.307]                     cond$call), session = sessionInformation(), 
[18:00:59.307]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.307]                   signalCondition(cond)
[18:00:59.307]                 }
[18:00:59.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.307]                 "immediateCondition"))) {
[18:00:59.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.307]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.307]                   if (TRUE && !signal) {
[18:00:59.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.307]                     {
[18:00:59.307]                       inherits <- base::inherits
[18:00:59.307]                       invokeRestart <- base::invokeRestart
[18:00:59.307]                       is.null <- base::is.null
[18:00:59.307]                       muffled <- FALSE
[18:00:59.307]                       if (inherits(cond, "message")) {
[18:00:59.307]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.307]                         if (muffled) 
[18:00:59.307]                           invokeRestart("muffleMessage")
[18:00:59.307]                       }
[18:00:59.307]                       else if (inherits(cond, "warning")) {
[18:00:59.307]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.307]                         if (muffled) 
[18:00:59.307]                           invokeRestart("muffleWarning")
[18:00:59.307]                       }
[18:00:59.307]                       else if (inherits(cond, "condition")) {
[18:00:59.307]                         if (!is.null(pattern)) {
[18:00:59.307]                           computeRestarts <- base::computeRestarts
[18:00:59.307]                           grepl <- base::grepl
[18:00:59.307]                           restarts <- computeRestarts(cond)
[18:00:59.307]                           for (restart in restarts) {
[18:00:59.307]                             name <- restart$name
[18:00:59.307]                             if (is.null(name)) 
[18:00:59.307]                               next
[18:00:59.307]                             if (!grepl(pattern, name)) 
[18:00:59.307]                               next
[18:00:59.307]                             invokeRestart(restart)
[18:00:59.307]                             muffled <- TRUE
[18:00:59.307]                             break
[18:00:59.307]                           }
[18:00:59.307]                         }
[18:00:59.307]                       }
[18:00:59.307]                       invisible(muffled)
[18:00:59.307]                     }
[18:00:59.307]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.307]                   }
[18:00:59.307]                 }
[18:00:59.307]                 else {
[18:00:59.307]                   if (TRUE) {
[18:00:59.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.307]                     {
[18:00:59.307]                       inherits <- base::inherits
[18:00:59.307]                       invokeRestart <- base::invokeRestart
[18:00:59.307]                       is.null <- base::is.null
[18:00:59.307]                       muffled <- FALSE
[18:00:59.307]                       if (inherits(cond, "message")) {
[18:00:59.307]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.307]                         if (muffled) 
[18:00:59.307]                           invokeRestart("muffleMessage")
[18:00:59.307]                       }
[18:00:59.307]                       else if (inherits(cond, "warning")) {
[18:00:59.307]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.307]                         if (muffled) 
[18:00:59.307]                           invokeRestart("muffleWarning")
[18:00:59.307]                       }
[18:00:59.307]                       else if (inherits(cond, "condition")) {
[18:00:59.307]                         if (!is.null(pattern)) {
[18:00:59.307]                           computeRestarts <- base::computeRestarts
[18:00:59.307]                           grepl <- base::grepl
[18:00:59.307]                           restarts <- computeRestarts(cond)
[18:00:59.307]                           for (restart in restarts) {
[18:00:59.307]                             name <- restart$name
[18:00:59.307]                             if (is.null(name)) 
[18:00:59.307]                               next
[18:00:59.307]                             if (!grepl(pattern, name)) 
[18:00:59.307]                               next
[18:00:59.307]                             invokeRestart(restart)
[18:00:59.307]                             muffled <- TRUE
[18:00:59.307]                             break
[18:00:59.307]                           }
[18:00:59.307]                         }
[18:00:59.307]                       }
[18:00:59.307]                       invisible(muffled)
[18:00:59.307]                     }
[18:00:59.307]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.307]                   }
[18:00:59.307]                 }
[18:00:59.307]             }
[18:00:59.307]         }))
[18:00:59.307]     }, error = function(ex) {
[18:00:59.307]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.307]                 ...future.rng), started = ...future.startTime, 
[18:00:59.307]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.307]             version = "1.8"), class = "FutureResult")
[18:00:59.307]     }, finally = {
[18:00:59.307]         if (!identical(...future.workdir, getwd())) 
[18:00:59.307]             setwd(...future.workdir)
[18:00:59.307]         {
[18:00:59.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.307]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.307]             }
[18:00:59.307]             base::options(...future.oldOptions)
[18:00:59.307]             if (.Platform$OS.type == "windows") {
[18:00:59.307]                 old_names <- names(...future.oldEnvVars)
[18:00:59.307]                 envs <- base::Sys.getenv()
[18:00:59.307]                 names <- names(envs)
[18:00:59.307]                 common <- intersect(names, old_names)
[18:00:59.307]                 added <- setdiff(names, old_names)
[18:00:59.307]                 removed <- setdiff(old_names, names)
[18:00:59.307]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.307]                   envs[common]]
[18:00:59.307]                 NAMES <- toupper(changed)
[18:00:59.307]                 args <- list()
[18:00:59.307]                 for (kk in seq_along(NAMES)) {
[18:00:59.307]                   name <- changed[[kk]]
[18:00:59.307]                   NAME <- NAMES[[kk]]
[18:00:59.307]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.307]                     next
[18:00:59.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.307]                 }
[18:00:59.307]                 NAMES <- toupper(added)
[18:00:59.307]                 for (kk in seq_along(NAMES)) {
[18:00:59.307]                   name <- added[[kk]]
[18:00:59.307]                   NAME <- NAMES[[kk]]
[18:00:59.307]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.307]                     next
[18:00:59.307]                   args[[name]] <- ""
[18:00:59.307]                 }
[18:00:59.307]                 NAMES <- toupper(removed)
[18:00:59.307]                 for (kk in seq_along(NAMES)) {
[18:00:59.307]                   name <- removed[[kk]]
[18:00:59.307]                   NAME <- NAMES[[kk]]
[18:00:59.307]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.307]                     next
[18:00:59.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.307]                 }
[18:00:59.307]                 if (length(args) > 0) 
[18:00:59.307]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.307]             }
[18:00:59.307]             else {
[18:00:59.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.307]             }
[18:00:59.307]             {
[18:00:59.307]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.307]                   0L) {
[18:00:59.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.307]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.307]                   base::options(opts)
[18:00:59.307]                 }
[18:00:59.307]                 {
[18:00:59.307]                   {
[18:00:59.307]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.307]                     NULL
[18:00:59.307]                   }
[18:00:59.307]                   options(future.plan = NULL)
[18:00:59.307]                   if (is.na(NA_character_)) 
[18:00:59.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.307]                     .init = FALSE)
[18:00:59.307]                 }
[18:00:59.307]             }
[18:00:59.307]         }
[18:00:59.307]     })
[18:00:59.307]     if (TRUE) {
[18:00:59.307]         base::sink(type = "output", split = FALSE)
[18:00:59.307]         if (TRUE) {
[18:00:59.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.307]         }
[18:00:59.307]         else {
[18:00:59.307]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.307]         }
[18:00:59.307]         base::close(...future.stdout)
[18:00:59.307]         ...future.stdout <- NULL
[18:00:59.307]     }
[18:00:59.307]     ...future.result$conditions <- ...future.conditions
[18:00:59.307]     ...future.result$finished <- base::Sys.time()
[18:00:59.307]     ...future.result
[18:00:59.307] }
[18:00:59.312] assign_globals() ...
[18:00:59.312] List of 5
[18:00:59.312]  $ ...future.FUN            :function (x, ...)  
[18:00:59.312]  $ MoreArgs                 : NULL
[18:00:59.312]  $ ...future.elements_ii    :List of 2
[18:00:59.312]   ..$ :List of 2
[18:00:59.312]   .. ..$ : int 1
[18:00:59.312]   .. ..$ : int 2
[18:00:59.312]   ..$ :List of 2
[18:00:59.312]   .. ..$ : int 4
[18:00:59.312]   .. ..$ : int 3
[18:00:59.312]  $ ...future.seeds_ii       : NULL
[18:00:59.312]  $ ...future.globals.maxSize: NULL
[18:00:59.312]  - attr(*, "where")=List of 5
[18:00:59.312]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.312]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.312]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.312]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.312]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.312]  - attr(*, "resolved")= logi FALSE
[18:00:59.312]  - attr(*, "total_size")= num 280
[18:00:59.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.312]  - attr(*, "already-done")= logi TRUE
[18:00:59.323] - copied ‘...future.FUN’ to environment
[18:00:59.324] - copied ‘MoreArgs’ to environment
[18:00:59.324] - copied ‘...future.elements_ii’ to environment
[18:00:59.324] - copied ‘...future.seeds_ii’ to environment
[18:00:59.324] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.324] assign_globals() ... done
[18:00:59.325] requestCore(): workers = 2
[18:00:59.328] MulticoreFuture started
[18:00:59.329] - Launch lazy future ... done
[18:00:59.329] run() for ‘MulticoreFuture’ ... done
[18:00:59.330] Created future:
[18:00:59.330] plan(): Setting new future strategy stack:
[18:00:59.331] List of future strategies:
[18:00:59.331] 1. sequential:
[18:00:59.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.331]    - tweaked: FALSE
[18:00:59.331]    - call: NULL
[18:00:59.333] plan(): nbrOfWorkers() = 1
[18:00:59.337] plan(): Setting new future strategy stack:
[18:00:59.338] List of future strategies:
[18:00:59.338] 1. multicore:
[18:00:59.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.338]    - tweaked: FALSE
[18:00:59.338]    - call: plan(strategy)
[18:00:59.330] MulticoreFuture:
[18:00:59.330] Label: ‘future_mapply-1’
[18:00:59.330] Expression:
[18:00:59.330] {
[18:00:59.330]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.330]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.330]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.330]         on.exit(options(oopts), add = TRUE)
[18:00:59.330]     }
[18:00:59.330]     {
[18:00:59.330]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.330]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.330]         do.call(mapply, args = args)
[18:00:59.330]     }
[18:00:59.330] }
[18:00:59.330] Lazy evaluation: FALSE
[18:00:59.330] Asynchronous evaluation: TRUE
[18:00:59.330] Local evaluation: TRUE
[18:00:59.330] Environment: R_GlobalEnv
[18:00:59.330] Capture standard output: TRUE
[18:00:59.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.330] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.330] Packages: <none>
[18:00:59.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.330] Resolved: FALSE
[18:00:59.330] Value: <not collected>
[18:00:59.330] Conditions captured: <none>
[18:00:59.330] Early signaling: FALSE
[18:00:59.330] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.330] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.346] Chunk #1 of 2 ... DONE
[18:00:59.346] Chunk #2 of 2 ...
[18:00:59.347]  - Finding globals in '...' for chunk #2 ...
[18:00:59.347] plan(): nbrOfWorkers() = 2
[18:00:59.347] getGlobalsAndPackages() ...
[18:00:59.348] Searching for globals...
[18:00:59.349] 
[18:00:59.349] Searching for globals ... DONE
[18:00:59.350] - globals: [0] <none>
[18:00:59.350] getGlobalsAndPackages() ... DONE
[18:00:59.350]    + additional globals found: [n=0] 
[18:00:59.350]    + additional namespaces needed: [n=0] 
[18:00:59.351]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:59.351]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.351]  - seeds: <none>
[18:00:59.352]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.352] getGlobalsAndPackages() ...
[18:00:59.352] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.353] Resolving globals: FALSE
[18:00:59.355] The total size of the 5 globals is 280 bytes (280 bytes)
[18:00:59.356] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.357] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.357] 
[18:00:59.358] getGlobalsAndPackages() ... DONE
[18:00:59.359] run() for ‘Future’ ...
[18:00:59.359] - state: ‘created’
[18:00:59.360] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.372]   - Field: ‘label’
[18:00:59.373]   - Field: ‘local’
[18:00:59.373]   - Field: ‘owner’
[18:00:59.374]   - Field: ‘envir’
[18:00:59.374]   - Field: ‘workers’
[18:00:59.374]   - Field: ‘packages’
[18:00:59.375]   - Field: ‘gc’
[18:00:59.375]   - Field: ‘job’
[18:00:59.375]   - Field: ‘conditions’
[18:00:59.376]   - Field: ‘expr’
[18:00:59.376]   - Field: ‘uuid’
[18:00:59.376]   - Field: ‘seed’
[18:00:59.377]   - Field: ‘version’
[18:00:59.377]   - Field: ‘result’
[18:00:59.377]   - Field: ‘asynchronous’
[18:00:59.378]   - Field: ‘calls’
[18:00:59.378]   - Field: ‘globals’
[18:00:59.378]   - Field: ‘stdout’
[18:00:59.378]   - Field: ‘earlySignal’
[18:00:59.379]   - Field: ‘lazy’
[18:00:59.379]   - Field: ‘state’
[18:00:59.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.380] - Launch lazy future ...
[18:00:59.381] Packages needed by the future expression (n = 0): <none>
[18:00:59.381] Packages needed by future strategies (n = 0): <none>
[18:00:59.382] {
[18:00:59.382]     {
[18:00:59.382]         {
[18:00:59.382]             ...future.startTime <- base::Sys.time()
[18:00:59.382]             {
[18:00:59.382]                 {
[18:00:59.382]                   {
[18:00:59.382]                     {
[18:00:59.382]                       base::local({
[18:00:59.382]                         has_future <- base::requireNamespace("future", 
[18:00:59.382]                           quietly = TRUE)
[18:00:59.382]                         if (has_future) {
[18:00:59.382]                           ns <- base::getNamespace("future")
[18:00:59.382]                           version <- ns[[".package"]][["version"]]
[18:00:59.382]                           if (is.null(version)) 
[18:00:59.382]                             version <- utils::packageVersion("future")
[18:00:59.382]                         }
[18:00:59.382]                         else {
[18:00:59.382]                           version <- NULL
[18:00:59.382]                         }
[18:00:59.382]                         if (!has_future || version < "1.8.0") {
[18:00:59.382]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.382]                             "", base::R.version$version.string), 
[18:00:59.382]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.382]                               "release", "version")], collapse = " "), 
[18:00:59.382]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.382]                             info)
[18:00:59.382]                           info <- base::paste(info, collapse = "; ")
[18:00:59.382]                           if (!has_future) {
[18:00:59.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.382]                               info)
[18:00:59.382]                           }
[18:00:59.382]                           else {
[18:00:59.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.382]                               info, version)
[18:00:59.382]                           }
[18:00:59.382]                           base::stop(msg)
[18:00:59.382]                         }
[18:00:59.382]                       })
[18:00:59.382]                     }
[18:00:59.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.382]                     base::options(mc.cores = 1L)
[18:00:59.382]                   }
[18:00:59.382]                   ...future.strategy.old <- future::plan("list")
[18:00:59.382]                   options(future.plan = NULL)
[18:00:59.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.382]                 }
[18:00:59.382]                 ...future.workdir <- getwd()
[18:00:59.382]             }
[18:00:59.382]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.382]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.382]         }
[18:00:59.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.382]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.382]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.382]             base::names(...future.oldOptions))
[18:00:59.382]     }
[18:00:59.382]     if (FALSE) {
[18:00:59.382]     }
[18:00:59.382]     else {
[18:00:59.382]         if (TRUE) {
[18:00:59.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.382]                 open = "w")
[18:00:59.382]         }
[18:00:59.382]         else {
[18:00:59.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.382]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.382]         }
[18:00:59.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.382]             base::sink(type = "output", split = FALSE)
[18:00:59.382]             base::close(...future.stdout)
[18:00:59.382]         }, add = TRUE)
[18:00:59.382]     }
[18:00:59.382]     ...future.frame <- base::sys.nframe()
[18:00:59.382]     ...future.conditions <- base::list()
[18:00:59.382]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.382]     if (FALSE) {
[18:00:59.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.382]     }
[18:00:59.382]     ...future.result <- base::tryCatch({
[18:00:59.382]         base::withCallingHandlers({
[18:00:59.382]             ...future.value <- base::withVisible(base::local({
[18:00:59.382]                 withCallingHandlers({
[18:00:59.382]                   {
[18:00:59.382]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.382]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.382]                       ...future.globals.maxSize)) {
[18:00:59.382]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.382]                       on.exit(options(oopts), add = TRUE)
[18:00:59.382]                     }
[18:00:59.382]                     {
[18:00:59.382]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.382]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.382]                         USE.NAMES = FALSE)
[18:00:59.382]                       do.call(mapply, args = args)
[18:00:59.382]                     }
[18:00:59.382]                   }
[18:00:59.382]                 }, immediateCondition = function(cond) {
[18:00:59.382]                   save_rds <- function (object, pathname, ...) 
[18:00:59.382]                   {
[18:00:59.382]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.382]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.382]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.382]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.382]                         fi_tmp[["mtime"]])
[18:00:59.382]                     }
[18:00:59.382]                     tryCatch({
[18:00:59.382]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.382]                     }, error = function(ex) {
[18:00:59.382]                       msg <- conditionMessage(ex)
[18:00:59.382]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.382]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.382]                         fi_tmp[["mtime"]], msg)
[18:00:59.382]                       ex$message <- msg
[18:00:59.382]                       stop(ex)
[18:00:59.382]                     })
[18:00:59.382]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.382]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.382]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.382]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.382]                       fi <- file.info(pathname)
[18:00:59.382]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.382]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.382]                         fi[["size"]], fi[["mtime"]])
[18:00:59.382]                       stop(msg)
[18:00:59.382]                     }
[18:00:59.382]                     invisible(pathname)
[18:00:59.382]                   }
[18:00:59.382]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.382]                     rootPath = tempdir()) 
[18:00:59.382]                   {
[18:00:59.382]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.382]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.382]                       tmpdir = path, fileext = ".rds")
[18:00:59.382]                     save_rds(obj, file)
[18:00:59.382]                   }
[18:00:59.382]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.382]                   {
[18:00:59.382]                     inherits <- base::inherits
[18:00:59.382]                     invokeRestart <- base::invokeRestart
[18:00:59.382]                     is.null <- base::is.null
[18:00:59.382]                     muffled <- FALSE
[18:00:59.382]                     if (inherits(cond, "message")) {
[18:00:59.382]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.382]                       if (muffled) 
[18:00:59.382]                         invokeRestart("muffleMessage")
[18:00:59.382]                     }
[18:00:59.382]                     else if (inherits(cond, "warning")) {
[18:00:59.382]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.382]                       if (muffled) 
[18:00:59.382]                         invokeRestart("muffleWarning")
[18:00:59.382]                     }
[18:00:59.382]                     else if (inherits(cond, "condition")) {
[18:00:59.382]                       if (!is.null(pattern)) {
[18:00:59.382]                         computeRestarts <- base::computeRestarts
[18:00:59.382]                         grepl <- base::grepl
[18:00:59.382]                         restarts <- computeRestarts(cond)
[18:00:59.382]                         for (restart in restarts) {
[18:00:59.382]                           name <- restart$name
[18:00:59.382]                           if (is.null(name)) 
[18:00:59.382]                             next
[18:00:59.382]                           if (!grepl(pattern, name)) 
[18:00:59.382]                             next
[18:00:59.382]                           invokeRestart(restart)
[18:00:59.382]                           muffled <- TRUE
[18:00:59.382]                           break
[18:00:59.382]                         }
[18:00:59.382]                       }
[18:00:59.382]                     }
[18:00:59.382]                     invisible(muffled)
[18:00:59.382]                   }
[18:00:59.382]                   muffleCondition(cond)
[18:00:59.382]                 })
[18:00:59.382]             }))
[18:00:59.382]             future::FutureResult(value = ...future.value$value, 
[18:00:59.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.382]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.382]                     ...future.globalenv.names))
[18:00:59.382]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.382]         }, condition = base::local({
[18:00:59.382]             c <- base::c
[18:00:59.382]             inherits <- base::inherits
[18:00:59.382]             invokeRestart <- base::invokeRestart
[18:00:59.382]             length <- base::length
[18:00:59.382]             list <- base::list
[18:00:59.382]             seq.int <- base::seq.int
[18:00:59.382]             signalCondition <- base::signalCondition
[18:00:59.382]             sys.calls <- base::sys.calls
[18:00:59.382]             `[[` <- base::`[[`
[18:00:59.382]             `+` <- base::`+`
[18:00:59.382]             `<<-` <- base::`<<-`
[18:00:59.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.382]                   3L)]
[18:00:59.382]             }
[18:00:59.382]             function(cond) {
[18:00:59.382]                 is_error <- inherits(cond, "error")
[18:00:59.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.382]                   NULL)
[18:00:59.382]                 if (is_error) {
[18:00:59.382]                   sessionInformation <- function() {
[18:00:59.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.382]                       search = base::search(), system = base::Sys.info())
[18:00:59.382]                   }
[18:00:59.382]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.382]                     cond$call), session = sessionInformation(), 
[18:00:59.382]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.382]                   signalCondition(cond)
[18:00:59.382]                 }
[18:00:59.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.382]                 "immediateCondition"))) {
[18:00:59.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.382]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.382]                   if (TRUE && !signal) {
[18:00:59.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.382]                     {
[18:00:59.382]                       inherits <- base::inherits
[18:00:59.382]                       invokeRestart <- base::invokeRestart
[18:00:59.382]                       is.null <- base::is.null
[18:00:59.382]                       muffled <- FALSE
[18:00:59.382]                       if (inherits(cond, "message")) {
[18:00:59.382]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.382]                         if (muffled) 
[18:00:59.382]                           invokeRestart("muffleMessage")
[18:00:59.382]                       }
[18:00:59.382]                       else if (inherits(cond, "warning")) {
[18:00:59.382]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.382]                         if (muffled) 
[18:00:59.382]                           invokeRestart("muffleWarning")
[18:00:59.382]                       }
[18:00:59.382]                       else if (inherits(cond, "condition")) {
[18:00:59.382]                         if (!is.null(pattern)) {
[18:00:59.382]                           computeRestarts <- base::computeRestarts
[18:00:59.382]                           grepl <- base::grepl
[18:00:59.382]                           restarts <- computeRestarts(cond)
[18:00:59.382]                           for (restart in restarts) {
[18:00:59.382]                             name <- restart$name
[18:00:59.382]                             if (is.null(name)) 
[18:00:59.382]                               next
[18:00:59.382]                             if (!grepl(pattern, name)) 
[18:00:59.382]                               next
[18:00:59.382]                             invokeRestart(restart)
[18:00:59.382]                             muffled <- TRUE
[18:00:59.382]                             break
[18:00:59.382]                           }
[18:00:59.382]                         }
[18:00:59.382]                       }
[18:00:59.382]                       invisible(muffled)
[18:00:59.382]                     }
[18:00:59.382]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.382]                   }
[18:00:59.382]                 }
[18:00:59.382]                 else {
[18:00:59.382]                   if (TRUE) {
[18:00:59.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.382]                     {
[18:00:59.382]                       inherits <- base::inherits
[18:00:59.382]                       invokeRestart <- base::invokeRestart
[18:00:59.382]                       is.null <- base::is.null
[18:00:59.382]                       muffled <- FALSE
[18:00:59.382]                       if (inherits(cond, "message")) {
[18:00:59.382]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.382]                         if (muffled) 
[18:00:59.382]                           invokeRestart("muffleMessage")
[18:00:59.382]                       }
[18:00:59.382]                       else if (inherits(cond, "warning")) {
[18:00:59.382]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.382]                         if (muffled) 
[18:00:59.382]                           invokeRestart("muffleWarning")
[18:00:59.382]                       }
[18:00:59.382]                       else if (inherits(cond, "condition")) {
[18:00:59.382]                         if (!is.null(pattern)) {
[18:00:59.382]                           computeRestarts <- base::computeRestarts
[18:00:59.382]                           grepl <- base::grepl
[18:00:59.382]                           restarts <- computeRestarts(cond)
[18:00:59.382]                           for (restart in restarts) {
[18:00:59.382]                             name <- restart$name
[18:00:59.382]                             if (is.null(name)) 
[18:00:59.382]                               next
[18:00:59.382]                             if (!grepl(pattern, name)) 
[18:00:59.382]                               next
[18:00:59.382]                             invokeRestart(restart)
[18:00:59.382]                             muffled <- TRUE
[18:00:59.382]                             break
[18:00:59.382]                           }
[18:00:59.382]                         }
[18:00:59.382]                       }
[18:00:59.382]                       invisible(muffled)
[18:00:59.382]                     }
[18:00:59.382]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.382]                   }
[18:00:59.382]                 }
[18:00:59.382]             }
[18:00:59.382]         }))
[18:00:59.382]     }, error = function(ex) {
[18:00:59.382]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.382]                 ...future.rng), started = ...future.startTime, 
[18:00:59.382]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.382]             version = "1.8"), class = "FutureResult")
[18:00:59.382]     }, finally = {
[18:00:59.382]         if (!identical(...future.workdir, getwd())) 
[18:00:59.382]             setwd(...future.workdir)
[18:00:59.382]         {
[18:00:59.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.382]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.382]             }
[18:00:59.382]             base::options(...future.oldOptions)
[18:00:59.382]             if (.Platform$OS.type == "windows") {
[18:00:59.382]                 old_names <- names(...future.oldEnvVars)
[18:00:59.382]                 envs <- base::Sys.getenv()
[18:00:59.382]                 names <- names(envs)
[18:00:59.382]                 common <- intersect(names, old_names)
[18:00:59.382]                 added <- setdiff(names, old_names)
[18:00:59.382]                 removed <- setdiff(old_names, names)
[18:00:59.382]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.382]                   envs[common]]
[18:00:59.382]                 NAMES <- toupper(changed)
[18:00:59.382]                 args <- list()
[18:00:59.382]                 for (kk in seq_along(NAMES)) {
[18:00:59.382]                   name <- changed[[kk]]
[18:00:59.382]                   NAME <- NAMES[[kk]]
[18:00:59.382]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.382]                     next
[18:00:59.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.382]                 }
[18:00:59.382]                 NAMES <- toupper(added)
[18:00:59.382]                 for (kk in seq_along(NAMES)) {
[18:00:59.382]                   name <- added[[kk]]
[18:00:59.382]                   NAME <- NAMES[[kk]]
[18:00:59.382]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.382]                     next
[18:00:59.382]                   args[[name]] <- ""
[18:00:59.382]                 }
[18:00:59.382]                 NAMES <- toupper(removed)
[18:00:59.382]                 for (kk in seq_along(NAMES)) {
[18:00:59.382]                   name <- removed[[kk]]
[18:00:59.382]                   NAME <- NAMES[[kk]]
[18:00:59.382]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.382]                     next
[18:00:59.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.382]                 }
[18:00:59.382]                 if (length(args) > 0) 
[18:00:59.382]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.382]             }
[18:00:59.382]             else {
[18:00:59.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.382]             }
[18:00:59.382]             {
[18:00:59.382]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.382]                   0L) {
[18:00:59.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.382]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.382]                   base::options(opts)
[18:00:59.382]                 }
[18:00:59.382]                 {
[18:00:59.382]                   {
[18:00:59.382]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.382]                     NULL
[18:00:59.382]                   }
[18:00:59.382]                   options(future.plan = NULL)
[18:00:59.382]                   if (is.na(NA_character_)) 
[18:00:59.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.382]                     .init = FALSE)
[18:00:59.382]                 }
[18:00:59.382]             }
[18:00:59.382]         }
[18:00:59.382]     })
[18:00:59.382]     if (TRUE) {
[18:00:59.382]         base::sink(type = "output", split = FALSE)
[18:00:59.382]         if (TRUE) {
[18:00:59.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.382]         }
[18:00:59.382]         else {
[18:00:59.382]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.382]         }
[18:00:59.382]         base::close(...future.stdout)
[18:00:59.382]         ...future.stdout <- NULL
[18:00:59.382]     }
[18:00:59.382]     ...future.result$conditions <- ...future.conditions
[18:00:59.382]     ...future.result$finished <- base::Sys.time()
[18:00:59.382]     ...future.result
[18:00:59.382] }
[18:00:59.389] assign_globals() ...
[18:00:59.390] List of 5
[18:00:59.390]  $ ...future.FUN            :function (x, ...)  
[18:00:59.390]  $ MoreArgs                 : NULL
[18:00:59.390]  $ ...future.elements_ii    :List of 2
[18:00:59.390]   ..$ :List of 2
[18:00:59.390]   .. ..$ : int 3
[18:00:59.390]   .. ..$ : int 4
[18:00:59.390]   ..$ :List of 2
[18:00:59.390]   .. ..$ : int 2
[18:00:59.390]   .. ..$ : int 1
[18:00:59.390]  $ ...future.seeds_ii       : NULL
[18:00:59.390]  $ ...future.globals.maxSize: NULL
[18:00:59.390]  - attr(*, "where")=List of 5
[18:00:59.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.390]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.390]  - attr(*, "resolved")= logi FALSE
[18:00:59.390]  - attr(*, "total_size")= num 280
[18:00:59.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.390]  - attr(*, "already-done")= logi TRUE
[18:00:59.418] - copied ‘...future.FUN’ to environment
[18:00:59.418] - copied ‘MoreArgs’ to environment
[18:00:59.418] - copied ‘...future.elements_ii’ to environment
[18:00:59.419] - copied ‘...future.seeds_ii’ to environment
[18:00:59.419] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.419] assign_globals() ... done
[18:00:59.420] requestCore(): workers = 2
[18:00:59.424] MulticoreFuture started
[18:00:59.425] - Launch lazy future ... done
[18:00:59.426] run() for ‘MulticoreFuture’ ... done
[18:00:59.426] plan(): Setting new future strategy stack:
[18:00:59.426] Created future:
[18:00:59.426] List of future strategies:
[18:00:59.426] 1. sequential:
[18:00:59.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.426]    - tweaked: FALSE
[18:00:59.426]    - call: NULL
[18:00:59.429] plan(): nbrOfWorkers() = 1
[18:00:59.434] plan(): Setting new future strategy stack:
[18:00:59.435] List of future strategies:
[18:00:59.435] 1. multicore:
[18:00:59.435]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.435]    - tweaked: FALSE
[18:00:59.435]    - call: plan(strategy)
[18:00:59.427] MulticoreFuture:
[18:00:59.427] Label: ‘future_mapply-2’
[18:00:59.427] Expression:
[18:00:59.427] {
[18:00:59.427]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.427]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.427]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.427]         on.exit(options(oopts), add = TRUE)
[18:00:59.427]     }
[18:00:59.427]     {
[18:00:59.427]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.427]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.427]         do.call(mapply, args = args)
[18:00:59.427]     }
[18:00:59.427] }
[18:00:59.427] Lazy evaluation: FALSE
[18:00:59.427] Asynchronous evaluation: TRUE
[18:00:59.427] Local evaluation: TRUE
[18:00:59.427] Environment: R_GlobalEnv
[18:00:59.427] Capture standard output: TRUE
[18:00:59.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.427] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.427] Packages: <none>
[18:00:59.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.427] Resolved: FALSE
[18:00:59.427] Value: <not collected>
[18:00:59.427] Conditions captured: <none>
[18:00:59.427] Early signaling: FALSE
[18:00:59.427] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.427] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.443] Chunk #2 of 2 ... DONE
[18:00:59.443] Launching 2 futures (chunks) ... DONE
[18:00:59.443] Resolving 2 futures (chunks) ...
[18:00:59.444] resolve() on list ...
[18:00:59.444]  recursive: 0
[18:00:59.444] plan(): nbrOfWorkers() = 2
[18:00:59.445]  length: 2
[18:00:59.445] 
[18:00:59.446] Future #1
[18:00:59.446] result() for MulticoreFuture ...
[18:00:59.448] result() for MulticoreFuture ...
[18:00:59.448] result() for MulticoreFuture ... done
[18:00:59.449] result() for MulticoreFuture ... done
[18:00:59.450] result() for MulticoreFuture ...
[18:00:59.451] result() for MulticoreFuture ... done
[18:00:59.451] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:00:59.451] - nx: 2
[18:00:59.452] - relay: TRUE
[18:00:59.452] - stdout: TRUE
[18:00:59.452] - signal: TRUE
[18:00:59.453] - resignal: FALSE
[18:00:59.453] - force: TRUE
[18:00:59.453] - relayed: [n=2] FALSE, FALSE
[18:00:59.454] - queued futures: [n=2] FALSE, FALSE
[18:00:59.454]  - until=1
[18:00:59.454]  - relaying element #1
[18:00:59.455] result() for MulticoreFuture ...
[18:00:59.455] result() for MulticoreFuture ... done
[18:00:59.455] result() for MulticoreFuture ...
[18:00:59.456] result() for MulticoreFuture ... done
[18:00:59.456] result() for MulticoreFuture ...
[18:00:59.456] result() for MulticoreFuture ... done
[18:00:59.457] result() for MulticoreFuture ...
[18:00:59.457] result() for MulticoreFuture ... done
[18:00:59.457] - relayed: [n=2] TRUE, FALSE
[18:00:59.458] - queued futures: [n=2] TRUE, FALSE
[18:00:59.458] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:00:59.458]  length: 1 (resolved future 1)
[18:00:59.459] Future #2
[18:00:59.459] result() for MulticoreFuture ...
[18:00:59.460] result() for MulticoreFuture ...
[18:00:59.461] result() for MulticoreFuture ... done
[18:00:59.461] result() for MulticoreFuture ... done
[18:00:59.461] result() for MulticoreFuture ...
[18:00:59.462] result() for MulticoreFuture ... done
[18:00:59.462] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:00:59.462] - nx: 2
[18:00:59.462] - relay: TRUE
[18:00:59.463] - stdout: TRUE
[18:00:59.463] - signal: TRUE
[18:00:59.463] - resignal: FALSE
[18:00:59.463] - force: TRUE
[18:00:59.464] - relayed: [n=2] TRUE, FALSE
[18:00:59.464] - queued futures: [n=2] TRUE, FALSE
[18:00:59.464]  - until=2
[18:00:59.464]  - relaying element #2
[18:00:59.464] result() for MulticoreFuture ...
[18:00:59.465] result() for MulticoreFuture ... done
[18:00:59.465] result() for MulticoreFuture ...
[18:00:59.465] result() for MulticoreFuture ... done
[18:00:59.466] result() for MulticoreFuture ...
[18:00:59.466] result() for MulticoreFuture ... done
[18:00:59.466] result() for MulticoreFuture ...
[18:00:59.466] result() for MulticoreFuture ... done
[18:00:59.466] - relayed: [n=2] TRUE, TRUE
[18:00:59.467] - queued futures: [n=2] TRUE, TRUE
[18:00:59.467] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:00:59.467]  length: 0 (resolved future 2)
[18:00:59.467] Relaying remaining futures
[18:00:59.468] signalConditionsASAP(NULL, pos=0) ...
[18:00:59.468] - nx: 2
[18:00:59.468] - relay: TRUE
[18:00:59.468] - stdout: TRUE
[18:00:59.468] - signal: TRUE
[18:00:59.469] - resignal: FALSE
[18:00:59.469] - force: TRUE
[18:00:59.469] - relayed: [n=2] TRUE, TRUE
[18:00:59.469] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:00:59.470] - relayed: [n=2] TRUE, TRUE
[18:00:59.470] - queued futures: [n=2] TRUE, TRUE
[18:00:59.470] signalConditionsASAP(NULL, pos=0) ... done
[18:00:59.470] resolve() on list ... DONE
[18:00:59.471] result() for MulticoreFuture ...
[18:00:59.471] result() for MulticoreFuture ... done
[18:00:59.471] result() for MulticoreFuture ...
[18:00:59.471] result() for MulticoreFuture ... done
[18:00:59.471] result() for MulticoreFuture ...
[18:00:59.472] result() for MulticoreFuture ... done
[18:00:59.472] result() for MulticoreFuture ...
[18:00:59.472] result() for MulticoreFuture ... done
[18:00:59.472]  - Number of value chunks collected: 2
[18:00:59.473] Resolving 2 futures (chunks) ... DONE
[18:00:59.473] Reducing values from 2 chunks ...
[18:00:59.473]  - Number of values collected after concatenation: 4
[18:00:59.473]  - Number of values expected: 4
[18:00:59.474] Reducing values from 2 chunks ... DONE
[18:00:59.474] future_mapply() ... DONE
[18:00:59.474] future_mapply() ...
[18:00:59.482] Number of chunks: 2
[18:00:59.482] getGlobalsAndPackagesXApply() ...
[18:00:59.482]  - future.globals: TRUE
[18:00:59.482] getGlobalsAndPackages() ...
[18:00:59.483] Searching for globals...
[18:00:59.484] - globals found: [1] ‘FUN’
[18:00:59.484] Searching for globals ... DONE
[18:00:59.485] Resolving globals: FALSE
[18:00:59.485] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:59.486] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:59.486] - globals: [1] ‘FUN’
[18:00:59.486] 
[18:00:59.487] getGlobalsAndPackages() ... DONE
[18:00:59.487]  - globals found/used: [n=1] ‘FUN’
[18:00:59.487]  - needed namespaces: [n=0] 
[18:00:59.487] Finding globals ... DONE
[18:00:59.488] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:59.488] List of 2
[18:00:59.488]  $ ...future.FUN:function (x, ...)  
[18:00:59.488]  $ MoreArgs     : NULL
[18:00:59.488]  - attr(*, "where")=List of 2
[18:00:59.488]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:59.488]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:59.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.488]  - attr(*, "resolved")= logi FALSE
[18:00:59.488]  - attr(*, "total_size")= num NA
[18:00:59.497] Packages to be attached in all futures: [n=0] 
[18:00:59.497] getGlobalsAndPackagesXApply() ... DONE
[18:00:59.498] Number of futures (= number of chunks): 2
[18:00:59.498] Launching 2 futures (chunks) ...
[18:00:59.498] Chunk #1 of 2 ...
[18:00:59.499]  - Finding globals in '...' for chunk #1 ...
[18:00:59.499] getGlobalsAndPackages() ...
[18:00:59.499] Searching for globals...
[18:00:59.500] 
[18:00:59.500] Searching for globals ... DONE
[18:00:59.500] - globals: [0] <none>
[18:00:59.501] getGlobalsAndPackages() ... DONE
[18:00:59.501]    + additional globals found: [n=0] 
[18:00:59.501]    + additional namespaces needed: [n=0] 
[18:00:59.501]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:59.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.502]  - seeds: <none>
[18:00:59.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.502] getGlobalsAndPackages() ...
[18:00:59.502] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.503] Resolving globals: FALSE
[18:00:59.504] The total size of the 5 globals is 280 bytes (280 bytes)
[18:00:59.505] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.505] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.505] 
[18:00:59.506] getGlobalsAndPackages() ... DONE
[18:00:59.506] run() for ‘Future’ ...
[18:00:59.506] - state: ‘created’
[18:00:59.507] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.513] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.514]   - Field: ‘label’
[18:00:59.514]   - Field: ‘local’
[18:00:59.514]   - Field: ‘owner’
[18:00:59.515]   - Field: ‘envir’
[18:00:59.515]   - Field: ‘workers’
[18:00:59.515]   - Field: ‘packages’
[18:00:59.515]   - Field: ‘gc’
[18:00:59.515]   - Field: ‘job’
[18:00:59.516]   - Field: ‘conditions’
[18:00:59.516]   - Field: ‘expr’
[18:00:59.516]   - Field: ‘uuid’
[18:00:59.516]   - Field: ‘seed’
[18:00:59.516]   - Field: ‘version’
[18:00:59.517]   - Field: ‘result’
[18:00:59.517]   - Field: ‘asynchronous’
[18:00:59.517]   - Field: ‘calls’
[18:00:59.517]   - Field: ‘globals’
[18:00:59.517]   - Field: ‘stdout’
[18:00:59.517]   - Field: ‘earlySignal’
[18:00:59.518]   - Field: ‘lazy’
[18:00:59.518]   - Field: ‘state’
[18:00:59.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.518] - Launch lazy future ...
[18:00:59.519] Packages needed by the future expression (n = 0): <none>
[18:00:59.519] Packages needed by future strategies (n = 0): <none>
[18:00:59.520] {
[18:00:59.520]     {
[18:00:59.520]         {
[18:00:59.520]             ...future.startTime <- base::Sys.time()
[18:00:59.520]             {
[18:00:59.520]                 {
[18:00:59.520]                   {
[18:00:59.520]                     {
[18:00:59.520]                       base::local({
[18:00:59.520]                         has_future <- base::requireNamespace("future", 
[18:00:59.520]                           quietly = TRUE)
[18:00:59.520]                         if (has_future) {
[18:00:59.520]                           ns <- base::getNamespace("future")
[18:00:59.520]                           version <- ns[[".package"]][["version"]]
[18:00:59.520]                           if (is.null(version)) 
[18:00:59.520]                             version <- utils::packageVersion("future")
[18:00:59.520]                         }
[18:00:59.520]                         else {
[18:00:59.520]                           version <- NULL
[18:00:59.520]                         }
[18:00:59.520]                         if (!has_future || version < "1.8.0") {
[18:00:59.520]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.520]                             "", base::R.version$version.string), 
[18:00:59.520]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.520]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.520]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.520]                               "release", "version")], collapse = " "), 
[18:00:59.520]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.520]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.520]                             info)
[18:00:59.520]                           info <- base::paste(info, collapse = "; ")
[18:00:59.520]                           if (!has_future) {
[18:00:59.520]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.520]                               info)
[18:00:59.520]                           }
[18:00:59.520]                           else {
[18:00:59.520]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.520]                               info, version)
[18:00:59.520]                           }
[18:00:59.520]                           base::stop(msg)
[18:00:59.520]                         }
[18:00:59.520]                       })
[18:00:59.520]                     }
[18:00:59.520]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.520]                     base::options(mc.cores = 1L)
[18:00:59.520]                   }
[18:00:59.520]                   ...future.strategy.old <- future::plan("list")
[18:00:59.520]                   options(future.plan = NULL)
[18:00:59.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.520]                 }
[18:00:59.520]                 ...future.workdir <- getwd()
[18:00:59.520]             }
[18:00:59.520]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.520]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.520]         }
[18:00:59.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.520]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.520]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.520]             base::names(...future.oldOptions))
[18:00:59.520]     }
[18:00:59.520]     if (FALSE) {
[18:00:59.520]     }
[18:00:59.520]     else {
[18:00:59.520]         if (TRUE) {
[18:00:59.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.520]                 open = "w")
[18:00:59.520]         }
[18:00:59.520]         else {
[18:00:59.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.520]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.520]         }
[18:00:59.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.520]             base::sink(type = "output", split = FALSE)
[18:00:59.520]             base::close(...future.stdout)
[18:00:59.520]         }, add = TRUE)
[18:00:59.520]     }
[18:00:59.520]     ...future.frame <- base::sys.nframe()
[18:00:59.520]     ...future.conditions <- base::list()
[18:00:59.520]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.520]     if (FALSE) {
[18:00:59.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.520]     }
[18:00:59.520]     ...future.result <- base::tryCatch({
[18:00:59.520]         base::withCallingHandlers({
[18:00:59.520]             ...future.value <- base::withVisible(base::local({
[18:00:59.520]                 withCallingHandlers({
[18:00:59.520]                   {
[18:00:59.520]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.520]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.520]                       ...future.globals.maxSize)) {
[18:00:59.520]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.520]                       on.exit(options(oopts), add = TRUE)
[18:00:59.520]                     }
[18:00:59.520]                     {
[18:00:59.520]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.520]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.520]                         USE.NAMES = FALSE)
[18:00:59.520]                       do.call(mapply, args = args)
[18:00:59.520]                     }
[18:00:59.520]                   }
[18:00:59.520]                 }, immediateCondition = function(cond) {
[18:00:59.520]                   save_rds <- function (object, pathname, ...) 
[18:00:59.520]                   {
[18:00:59.520]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.520]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.520]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.520]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.520]                         fi_tmp[["mtime"]])
[18:00:59.520]                     }
[18:00:59.520]                     tryCatch({
[18:00:59.520]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.520]                     }, error = function(ex) {
[18:00:59.520]                       msg <- conditionMessage(ex)
[18:00:59.520]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.520]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.520]                         fi_tmp[["mtime"]], msg)
[18:00:59.520]                       ex$message <- msg
[18:00:59.520]                       stop(ex)
[18:00:59.520]                     })
[18:00:59.520]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.520]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.520]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.520]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.520]                       fi <- file.info(pathname)
[18:00:59.520]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.520]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.520]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.520]                         fi[["size"]], fi[["mtime"]])
[18:00:59.520]                       stop(msg)
[18:00:59.520]                     }
[18:00:59.520]                     invisible(pathname)
[18:00:59.520]                   }
[18:00:59.520]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.520]                     rootPath = tempdir()) 
[18:00:59.520]                   {
[18:00:59.520]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.520]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.520]                       tmpdir = path, fileext = ".rds")
[18:00:59.520]                     save_rds(obj, file)
[18:00:59.520]                   }
[18:00:59.520]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.520]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.520]                   {
[18:00:59.520]                     inherits <- base::inherits
[18:00:59.520]                     invokeRestart <- base::invokeRestart
[18:00:59.520]                     is.null <- base::is.null
[18:00:59.520]                     muffled <- FALSE
[18:00:59.520]                     if (inherits(cond, "message")) {
[18:00:59.520]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.520]                       if (muffled) 
[18:00:59.520]                         invokeRestart("muffleMessage")
[18:00:59.520]                     }
[18:00:59.520]                     else if (inherits(cond, "warning")) {
[18:00:59.520]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.520]                       if (muffled) 
[18:00:59.520]                         invokeRestart("muffleWarning")
[18:00:59.520]                     }
[18:00:59.520]                     else if (inherits(cond, "condition")) {
[18:00:59.520]                       if (!is.null(pattern)) {
[18:00:59.520]                         computeRestarts <- base::computeRestarts
[18:00:59.520]                         grepl <- base::grepl
[18:00:59.520]                         restarts <- computeRestarts(cond)
[18:00:59.520]                         for (restart in restarts) {
[18:00:59.520]                           name <- restart$name
[18:00:59.520]                           if (is.null(name)) 
[18:00:59.520]                             next
[18:00:59.520]                           if (!grepl(pattern, name)) 
[18:00:59.520]                             next
[18:00:59.520]                           invokeRestart(restart)
[18:00:59.520]                           muffled <- TRUE
[18:00:59.520]                           break
[18:00:59.520]                         }
[18:00:59.520]                       }
[18:00:59.520]                     }
[18:00:59.520]                     invisible(muffled)
[18:00:59.520]                   }
[18:00:59.520]                   muffleCondition(cond)
[18:00:59.520]                 })
[18:00:59.520]             }))
[18:00:59.520]             future::FutureResult(value = ...future.value$value, 
[18:00:59.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.520]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.520]                     ...future.globalenv.names))
[18:00:59.520]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.520]         }, condition = base::local({
[18:00:59.520]             c <- base::c
[18:00:59.520]             inherits <- base::inherits
[18:00:59.520]             invokeRestart <- base::invokeRestart
[18:00:59.520]             length <- base::length
[18:00:59.520]             list <- base::list
[18:00:59.520]             seq.int <- base::seq.int
[18:00:59.520]             signalCondition <- base::signalCondition
[18:00:59.520]             sys.calls <- base::sys.calls
[18:00:59.520]             `[[` <- base::`[[`
[18:00:59.520]             `+` <- base::`+`
[18:00:59.520]             `<<-` <- base::`<<-`
[18:00:59.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.520]                   3L)]
[18:00:59.520]             }
[18:00:59.520]             function(cond) {
[18:00:59.520]                 is_error <- inherits(cond, "error")
[18:00:59.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.520]                   NULL)
[18:00:59.520]                 if (is_error) {
[18:00:59.520]                   sessionInformation <- function() {
[18:00:59.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.520]                       search = base::search(), system = base::Sys.info())
[18:00:59.520]                   }
[18:00:59.520]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.520]                     cond$call), session = sessionInformation(), 
[18:00:59.520]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.520]                   signalCondition(cond)
[18:00:59.520]                 }
[18:00:59.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.520]                 "immediateCondition"))) {
[18:00:59.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.520]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.520]                   if (TRUE && !signal) {
[18:00:59.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.520]                     {
[18:00:59.520]                       inherits <- base::inherits
[18:00:59.520]                       invokeRestart <- base::invokeRestart
[18:00:59.520]                       is.null <- base::is.null
[18:00:59.520]                       muffled <- FALSE
[18:00:59.520]                       if (inherits(cond, "message")) {
[18:00:59.520]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.520]                         if (muffled) 
[18:00:59.520]                           invokeRestart("muffleMessage")
[18:00:59.520]                       }
[18:00:59.520]                       else if (inherits(cond, "warning")) {
[18:00:59.520]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.520]                         if (muffled) 
[18:00:59.520]                           invokeRestart("muffleWarning")
[18:00:59.520]                       }
[18:00:59.520]                       else if (inherits(cond, "condition")) {
[18:00:59.520]                         if (!is.null(pattern)) {
[18:00:59.520]                           computeRestarts <- base::computeRestarts
[18:00:59.520]                           grepl <- base::grepl
[18:00:59.520]                           restarts <- computeRestarts(cond)
[18:00:59.520]                           for (restart in restarts) {
[18:00:59.520]                             name <- restart$name
[18:00:59.520]                             if (is.null(name)) 
[18:00:59.520]                               next
[18:00:59.520]                             if (!grepl(pattern, name)) 
[18:00:59.520]                               next
[18:00:59.520]                             invokeRestart(restart)
[18:00:59.520]                             muffled <- TRUE
[18:00:59.520]                             break
[18:00:59.520]                           }
[18:00:59.520]                         }
[18:00:59.520]                       }
[18:00:59.520]                       invisible(muffled)
[18:00:59.520]                     }
[18:00:59.520]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.520]                   }
[18:00:59.520]                 }
[18:00:59.520]                 else {
[18:00:59.520]                   if (TRUE) {
[18:00:59.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.520]                     {
[18:00:59.520]                       inherits <- base::inherits
[18:00:59.520]                       invokeRestart <- base::invokeRestart
[18:00:59.520]                       is.null <- base::is.null
[18:00:59.520]                       muffled <- FALSE
[18:00:59.520]                       if (inherits(cond, "message")) {
[18:00:59.520]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.520]                         if (muffled) 
[18:00:59.520]                           invokeRestart("muffleMessage")
[18:00:59.520]                       }
[18:00:59.520]                       else if (inherits(cond, "warning")) {
[18:00:59.520]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.520]                         if (muffled) 
[18:00:59.520]                           invokeRestart("muffleWarning")
[18:00:59.520]                       }
[18:00:59.520]                       else if (inherits(cond, "condition")) {
[18:00:59.520]                         if (!is.null(pattern)) {
[18:00:59.520]                           computeRestarts <- base::computeRestarts
[18:00:59.520]                           grepl <- base::grepl
[18:00:59.520]                           restarts <- computeRestarts(cond)
[18:00:59.520]                           for (restart in restarts) {
[18:00:59.520]                             name <- restart$name
[18:00:59.520]                             if (is.null(name)) 
[18:00:59.520]                               next
[18:00:59.520]                             if (!grepl(pattern, name)) 
[18:00:59.520]                               next
[18:00:59.520]                             invokeRestart(restart)
[18:00:59.520]                             muffled <- TRUE
[18:00:59.520]                             break
[18:00:59.520]                           }
[18:00:59.520]                         }
[18:00:59.520]                       }
[18:00:59.520]                       invisible(muffled)
[18:00:59.520]                     }
[18:00:59.520]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.520]                   }
[18:00:59.520]                 }
[18:00:59.520]             }
[18:00:59.520]         }))
[18:00:59.520]     }, error = function(ex) {
[18:00:59.520]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.520]                 ...future.rng), started = ...future.startTime, 
[18:00:59.520]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.520]             version = "1.8"), class = "FutureResult")
[18:00:59.520]     }, finally = {
[18:00:59.520]         if (!identical(...future.workdir, getwd())) 
[18:00:59.520]             setwd(...future.workdir)
[18:00:59.520]         {
[18:00:59.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.520]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.520]             }
[18:00:59.520]             base::options(...future.oldOptions)
[18:00:59.520]             if (.Platform$OS.type == "windows") {
[18:00:59.520]                 old_names <- names(...future.oldEnvVars)
[18:00:59.520]                 envs <- base::Sys.getenv()
[18:00:59.520]                 names <- names(envs)
[18:00:59.520]                 common <- intersect(names, old_names)
[18:00:59.520]                 added <- setdiff(names, old_names)
[18:00:59.520]                 removed <- setdiff(old_names, names)
[18:00:59.520]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.520]                   envs[common]]
[18:00:59.520]                 NAMES <- toupper(changed)
[18:00:59.520]                 args <- list()
[18:00:59.520]                 for (kk in seq_along(NAMES)) {
[18:00:59.520]                   name <- changed[[kk]]
[18:00:59.520]                   NAME <- NAMES[[kk]]
[18:00:59.520]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.520]                     next
[18:00:59.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.520]                 }
[18:00:59.520]                 NAMES <- toupper(added)
[18:00:59.520]                 for (kk in seq_along(NAMES)) {
[18:00:59.520]                   name <- added[[kk]]
[18:00:59.520]                   NAME <- NAMES[[kk]]
[18:00:59.520]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.520]                     next
[18:00:59.520]                   args[[name]] <- ""
[18:00:59.520]                 }
[18:00:59.520]                 NAMES <- toupper(removed)
[18:00:59.520]                 for (kk in seq_along(NAMES)) {
[18:00:59.520]                   name <- removed[[kk]]
[18:00:59.520]                   NAME <- NAMES[[kk]]
[18:00:59.520]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.520]                     next
[18:00:59.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.520]                 }
[18:00:59.520]                 if (length(args) > 0) 
[18:00:59.520]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.520]             }
[18:00:59.520]             else {
[18:00:59.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.520]             }
[18:00:59.520]             {
[18:00:59.520]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.520]                   0L) {
[18:00:59.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.520]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.520]                   base::options(opts)
[18:00:59.520]                 }
[18:00:59.520]                 {
[18:00:59.520]                   {
[18:00:59.520]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.520]                     NULL
[18:00:59.520]                   }
[18:00:59.520]                   options(future.plan = NULL)
[18:00:59.520]                   if (is.na(NA_character_)) 
[18:00:59.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.520]                     .init = FALSE)
[18:00:59.520]                 }
[18:00:59.520]             }
[18:00:59.520]         }
[18:00:59.520]     })
[18:00:59.520]     if (TRUE) {
[18:00:59.520]         base::sink(type = "output", split = FALSE)
[18:00:59.520]         if (TRUE) {
[18:00:59.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.520]         }
[18:00:59.520]         else {
[18:00:59.520]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.520]         }
[18:00:59.520]         base::close(...future.stdout)
[18:00:59.520]         ...future.stdout <- NULL
[18:00:59.520]     }
[18:00:59.520]     ...future.result$conditions <- ...future.conditions
[18:00:59.520]     ...future.result$finished <- base::Sys.time()
[18:00:59.520]     ...future.result
[18:00:59.520] }
[18:00:59.525] assign_globals() ...
[18:00:59.525] List of 5
[18:00:59.525]  $ ...future.FUN            :function (x, ...)  
[18:00:59.525]  $ MoreArgs                 : NULL
[18:00:59.525]  $ ...future.elements_ii    :List of 2
[18:00:59.525]   ..$ times:List of 2
[18:00:59.525]   .. ..$ : int 1
[18:00:59.525]   .. ..$ : int 2
[18:00:59.525]   ..$ x    :List of 2
[18:00:59.525]   .. ..$ : int 4
[18:00:59.525]   .. ..$ : int 3
[18:00:59.525]  $ ...future.seeds_ii       : NULL
[18:00:59.525]  $ ...future.globals.maxSize: NULL
[18:00:59.525]  - attr(*, "where")=List of 5
[18:00:59.525]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.525]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.525]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.525]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.525]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.525]  - attr(*, "resolved")= logi FALSE
[18:00:59.525]  - attr(*, "total_size")= num 280
[18:00:59.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.525]  - attr(*, "already-done")= logi TRUE
[18:00:59.536] - copied ‘...future.FUN’ to environment
[18:00:59.537] - copied ‘MoreArgs’ to environment
[18:00:59.537] - copied ‘...future.elements_ii’ to environment
[18:00:59.537] - copied ‘...future.seeds_ii’ to environment
[18:00:59.537] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.537] assign_globals() ... done
[18:00:59.538] requestCore(): workers = 2
[18:00:59.542] MulticoreFuture started
[18:00:59.542] - Launch lazy future ... done
[18:00:59.543] run() for ‘MulticoreFuture’ ... done
[18:00:59.543] Created future:
[18:00:59.543] plan(): Setting new future strategy stack:
[18:00:59.544] List of future strategies:
[18:00:59.544] 1. sequential:
[18:00:59.544]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.544]    - tweaked: FALSE
[18:00:59.544]    - call: NULL
[18:00:59.546] plan(): nbrOfWorkers() = 1
[18:00:59.550] plan(): Setting new future strategy stack:
[18:00:59.551] List of future strategies:
[18:00:59.551] 1. multicore:
[18:00:59.551]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.551]    - tweaked: FALSE
[18:00:59.551]    - call: plan(strategy)
[18:00:59.544] MulticoreFuture:
[18:00:59.544] Label: ‘future_mapply-1’
[18:00:59.544] Expression:
[18:00:59.544] {
[18:00:59.544]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.544]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.544]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.544]         on.exit(options(oopts), add = TRUE)
[18:00:59.544]     }
[18:00:59.544]     {
[18:00:59.544]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.544]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.544]         do.call(mapply, args = args)
[18:00:59.544]     }
[18:00:59.544] }
[18:00:59.544] Lazy evaluation: FALSE
[18:00:59.544] Asynchronous evaluation: TRUE
[18:00:59.544] Local evaluation: TRUE
[18:00:59.544] Environment: R_GlobalEnv
[18:00:59.544] Capture standard output: TRUE
[18:00:59.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.544] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.544] Packages: <none>
[18:00:59.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.544] Resolved: FALSE
[18:00:59.544] Value: <not collected>
[18:00:59.544] Conditions captured: <none>
[18:00:59.544] Early signaling: FALSE
[18:00:59.544] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.544] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.559] Chunk #1 of 2 ... DONE
[18:00:59.560] Chunk #2 of 2 ...
[18:00:59.560]  - Finding globals in '...' for chunk #2 ...
[18:00:59.560] getGlobalsAndPackages() ...
[18:00:59.561] Searching for globals...
[18:00:59.561] plan(): nbrOfWorkers() = 2
[18:00:59.562] 
[18:00:59.562] Searching for globals ... DONE
[18:00:59.562] - globals: [0] <none>
[18:00:59.563] getGlobalsAndPackages() ... DONE
[18:00:59.563]    + additional globals found: [n=0] 
[18:00:59.563]    + additional namespaces needed: [n=0] 
[18:00:59.563]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:59.564]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.564]  - seeds: <none>
[18:00:59.564]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.565] getGlobalsAndPackages() ...
[18:00:59.565] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.566] Resolving globals: FALSE
[18:00:59.567] The total size of the 5 globals is 280 bytes (280 bytes)
[18:00:59.569] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.569] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.570] 
[18:00:59.570] getGlobalsAndPackages() ... DONE
[18:00:59.571] run() for ‘Future’ ...
[18:00:59.571] - state: ‘created’
[18:00:59.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.589]   - Field: ‘label’
[18:00:59.589]   - Field: ‘local’
[18:00:59.590]   - Field: ‘owner’
[18:00:59.590]   - Field: ‘envir’
[18:00:59.591]   - Field: ‘workers’
[18:00:59.591]   - Field: ‘packages’
[18:00:59.592]   - Field: ‘gc’
[18:00:59.592]   - Field: ‘job’
[18:00:59.593]   - Field: ‘conditions’
[18:00:59.593]   - Field: ‘expr’
[18:00:59.594]   - Field: ‘uuid’
[18:00:59.594]   - Field: ‘seed’
[18:00:59.594]   - Field: ‘version’
[18:00:59.595]   - Field: ‘result’
[18:00:59.595]   - Field: ‘asynchronous’
[18:00:59.596]   - Field: ‘calls’
[18:00:59.596]   - Field: ‘globals’
[18:00:59.597]   - Field: ‘stdout’
[18:00:59.597]   - Field: ‘earlySignal’
[18:00:59.597]   - Field: ‘lazy’
[18:00:59.598]   - Field: ‘state’
[18:00:59.598] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.598] - Launch lazy future ...
[18:00:59.599] Packages needed by the future expression (n = 0): <none>
[18:00:59.599] Packages needed by future strategies (n = 0): <none>
[18:00:59.601] {
[18:00:59.601]     {
[18:00:59.601]         {
[18:00:59.601]             ...future.startTime <- base::Sys.time()
[18:00:59.601]             {
[18:00:59.601]                 {
[18:00:59.601]                   {
[18:00:59.601]                     {
[18:00:59.601]                       base::local({
[18:00:59.601]                         has_future <- base::requireNamespace("future", 
[18:00:59.601]                           quietly = TRUE)
[18:00:59.601]                         if (has_future) {
[18:00:59.601]                           ns <- base::getNamespace("future")
[18:00:59.601]                           version <- ns[[".package"]][["version"]]
[18:00:59.601]                           if (is.null(version)) 
[18:00:59.601]                             version <- utils::packageVersion("future")
[18:00:59.601]                         }
[18:00:59.601]                         else {
[18:00:59.601]                           version <- NULL
[18:00:59.601]                         }
[18:00:59.601]                         if (!has_future || version < "1.8.0") {
[18:00:59.601]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.601]                             "", base::R.version$version.string), 
[18:00:59.601]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.601]                               "release", "version")], collapse = " "), 
[18:00:59.601]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.601]                             info)
[18:00:59.601]                           info <- base::paste(info, collapse = "; ")
[18:00:59.601]                           if (!has_future) {
[18:00:59.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.601]                               info)
[18:00:59.601]                           }
[18:00:59.601]                           else {
[18:00:59.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.601]                               info, version)
[18:00:59.601]                           }
[18:00:59.601]                           base::stop(msg)
[18:00:59.601]                         }
[18:00:59.601]                       })
[18:00:59.601]                     }
[18:00:59.601]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.601]                     base::options(mc.cores = 1L)
[18:00:59.601]                   }
[18:00:59.601]                   ...future.strategy.old <- future::plan("list")
[18:00:59.601]                   options(future.plan = NULL)
[18:00:59.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.601]                 }
[18:00:59.601]                 ...future.workdir <- getwd()
[18:00:59.601]             }
[18:00:59.601]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.601]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.601]         }
[18:00:59.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.601]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.601]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.601]             base::names(...future.oldOptions))
[18:00:59.601]     }
[18:00:59.601]     if (FALSE) {
[18:00:59.601]     }
[18:00:59.601]     else {
[18:00:59.601]         if (TRUE) {
[18:00:59.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.601]                 open = "w")
[18:00:59.601]         }
[18:00:59.601]         else {
[18:00:59.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.601]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.601]         }
[18:00:59.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.601]             base::sink(type = "output", split = FALSE)
[18:00:59.601]             base::close(...future.stdout)
[18:00:59.601]         }, add = TRUE)
[18:00:59.601]     }
[18:00:59.601]     ...future.frame <- base::sys.nframe()
[18:00:59.601]     ...future.conditions <- base::list()
[18:00:59.601]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.601]     if (FALSE) {
[18:00:59.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.601]     }
[18:00:59.601]     ...future.result <- base::tryCatch({
[18:00:59.601]         base::withCallingHandlers({
[18:00:59.601]             ...future.value <- base::withVisible(base::local({
[18:00:59.601]                 withCallingHandlers({
[18:00:59.601]                   {
[18:00:59.601]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.601]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.601]                       ...future.globals.maxSize)) {
[18:00:59.601]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.601]                       on.exit(options(oopts), add = TRUE)
[18:00:59.601]                     }
[18:00:59.601]                     {
[18:00:59.601]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.601]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.601]                         USE.NAMES = FALSE)
[18:00:59.601]                       do.call(mapply, args = args)
[18:00:59.601]                     }
[18:00:59.601]                   }
[18:00:59.601]                 }, immediateCondition = function(cond) {
[18:00:59.601]                   save_rds <- function (object, pathname, ...) 
[18:00:59.601]                   {
[18:00:59.601]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.601]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.601]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.601]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.601]                         fi_tmp[["mtime"]])
[18:00:59.601]                     }
[18:00:59.601]                     tryCatch({
[18:00:59.601]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.601]                     }, error = function(ex) {
[18:00:59.601]                       msg <- conditionMessage(ex)
[18:00:59.601]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.601]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.601]                         fi_tmp[["mtime"]], msg)
[18:00:59.601]                       ex$message <- msg
[18:00:59.601]                       stop(ex)
[18:00:59.601]                     })
[18:00:59.601]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.601]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.601]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.601]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.601]                       fi <- file.info(pathname)
[18:00:59.601]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.601]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.601]                         fi[["size"]], fi[["mtime"]])
[18:00:59.601]                       stop(msg)
[18:00:59.601]                     }
[18:00:59.601]                     invisible(pathname)
[18:00:59.601]                   }
[18:00:59.601]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.601]                     rootPath = tempdir()) 
[18:00:59.601]                   {
[18:00:59.601]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.601]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.601]                       tmpdir = path, fileext = ".rds")
[18:00:59.601]                     save_rds(obj, file)
[18:00:59.601]                   }
[18:00:59.601]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.601]                   {
[18:00:59.601]                     inherits <- base::inherits
[18:00:59.601]                     invokeRestart <- base::invokeRestart
[18:00:59.601]                     is.null <- base::is.null
[18:00:59.601]                     muffled <- FALSE
[18:00:59.601]                     if (inherits(cond, "message")) {
[18:00:59.601]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.601]                       if (muffled) 
[18:00:59.601]                         invokeRestart("muffleMessage")
[18:00:59.601]                     }
[18:00:59.601]                     else if (inherits(cond, "warning")) {
[18:00:59.601]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.601]                       if (muffled) 
[18:00:59.601]                         invokeRestart("muffleWarning")
[18:00:59.601]                     }
[18:00:59.601]                     else if (inherits(cond, "condition")) {
[18:00:59.601]                       if (!is.null(pattern)) {
[18:00:59.601]                         computeRestarts <- base::computeRestarts
[18:00:59.601]                         grepl <- base::grepl
[18:00:59.601]                         restarts <- computeRestarts(cond)
[18:00:59.601]                         for (restart in restarts) {
[18:00:59.601]                           name <- restart$name
[18:00:59.601]                           if (is.null(name)) 
[18:00:59.601]                             next
[18:00:59.601]                           if (!grepl(pattern, name)) 
[18:00:59.601]                             next
[18:00:59.601]                           invokeRestart(restart)
[18:00:59.601]                           muffled <- TRUE
[18:00:59.601]                           break
[18:00:59.601]                         }
[18:00:59.601]                       }
[18:00:59.601]                     }
[18:00:59.601]                     invisible(muffled)
[18:00:59.601]                   }
[18:00:59.601]                   muffleCondition(cond)
[18:00:59.601]                 })
[18:00:59.601]             }))
[18:00:59.601]             future::FutureResult(value = ...future.value$value, 
[18:00:59.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.601]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.601]                     ...future.globalenv.names))
[18:00:59.601]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.601]         }, condition = base::local({
[18:00:59.601]             c <- base::c
[18:00:59.601]             inherits <- base::inherits
[18:00:59.601]             invokeRestart <- base::invokeRestart
[18:00:59.601]             length <- base::length
[18:00:59.601]             list <- base::list
[18:00:59.601]             seq.int <- base::seq.int
[18:00:59.601]             signalCondition <- base::signalCondition
[18:00:59.601]             sys.calls <- base::sys.calls
[18:00:59.601]             `[[` <- base::`[[`
[18:00:59.601]             `+` <- base::`+`
[18:00:59.601]             `<<-` <- base::`<<-`
[18:00:59.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.601]                   3L)]
[18:00:59.601]             }
[18:00:59.601]             function(cond) {
[18:00:59.601]                 is_error <- inherits(cond, "error")
[18:00:59.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.601]                   NULL)
[18:00:59.601]                 if (is_error) {
[18:00:59.601]                   sessionInformation <- function() {
[18:00:59.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.601]                       search = base::search(), system = base::Sys.info())
[18:00:59.601]                   }
[18:00:59.601]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.601]                     cond$call), session = sessionInformation(), 
[18:00:59.601]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.601]                   signalCondition(cond)
[18:00:59.601]                 }
[18:00:59.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.601]                 "immediateCondition"))) {
[18:00:59.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.601]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.601]                   if (TRUE && !signal) {
[18:00:59.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.601]                     {
[18:00:59.601]                       inherits <- base::inherits
[18:00:59.601]                       invokeRestart <- base::invokeRestart
[18:00:59.601]                       is.null <- base::is.null
[18:00:59.601]                       muffled <- FALSE
[18:00:59.601]                       if (inherits(cond, "message")) {
[18:00:59.601]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.601]                         if (muffled) 
[18:00:59.601]                           invokeRestart("muffleMessage")
[18:00:59.601]                       }
[18:00:59.601]                       else if (inherits(cond, "warning")) {
[18:00:59.601]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.601]                         if (muffled) 
[18:00:59.601]                           invokeRestart("muffleWarning")
[18:00:59.601]                       }
[18:00:59.601]                       else if (inherits(cond, "condition")) {
[18:00:59.601]                         if (!is.null(pattern)) {
[18:00:59.601]                           computeRestarts <- base::computeRestarts
[18:00:59.601]                           grepl <- base::grepl
[18:00:59.601]                           restarts <- computeRestarts(cond)
[18:00:59.601]                           for (restart in restarts) {
[18:00:59.601]                             name <- restart$name
[18:00:59.601]                             if (is.null(name)) 
[18:00:59.601]                               next
[18:00:59.601]                             if (!grepl(pattern, name)) 
[18:00:59.601]                               next
[18:00:59.601]                             invokeRestart(restart)
[18:00:59.601]                             muffled <- TRUE
[18:00:59.601]                             break
[18:00:59.601]                           }
[18:00:59.601]                         }
[18:00:59.601]                       }
[18:00:59.601]                       invisible(muffled)
[18:00:59.601]                     }
[18:00:59.601]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.601]                   }
[18:00:59.601]                 }
[18:00:59.601]                 else {
[18:00:59.601]                   if (TRUE) {
[18:00:59.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.601]                     {
[18:00:59.601]                       inherits <- base::inherits
[18:00:59.601]                       invokeRestart <- base::invokeRestart
[18:00:59.601]                       is.null <- base::is.null
[18:00:59.601]                       muffled <- FALSE
[18:00:59.601]                       if (inherits(cond, "message")) {
[18:00:59.601]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.601]                         if (muffled) 
[18:00:59.601]                           invokeRestart("muffleMessage")
[18:00:59.601]                       }
[18:00:59.601]                       else if (inherits(cond, "warning")) {
[18:00:59.601]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.601]                         if (muffled) 
[18:00:59.601]                           invokeRestart("muffleWarning")
[18:00:59.601]                       }
[18:00:59.601]                       else if (inherits(cond, "condition")) {
[18:00:59.601]                         if (!is.null(pattern)) {
[18:00:59.601]                           computeRestarts <- base::computeRestarts
[18:00:59.601]                           grepl <- base::grepl
[18:00:59.601]                           restarts <- computeRestarts(cond)
[18:00:59.601]                           for (restart in restarts) {
[18:00:59.601]                             name <- restart$name
[18:00:59.601]                             if (is.null(name)) 
[18:00:59.601]                               next
[18:00:59.601]                             if (!grepl(pattern, name)) 
[18:00:59.601]                               next
[18:00:59.601]                             invokeRestart(restart)
[18:00:59.601]                             muffled <- TRUE
[18:00:59.601]                             break
[18:00:59.601]                           }
[18:00:59.601]                         }
[18:00:59.601]                       }
[18:00:59.601]                       invisible(muffled)
[18:00:59.601]                     }
[18:00:59.601]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.601]                   }
[18:00:59.601]                 }
[18:00:59.601]             }
[18:00:59.601]         }))
[18:00:59.601]     }, error = function(ex) {
[18:00:59.601]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.601]                 ...future.rng), started = ...future.startTime, 
[18:00:59.601]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.601]             version = "1.8"), class = "FutureResult")
[18:00:59.601]     }, finally = {
[18:00:59.601]         if (!identical(...future.workdir, getwd())) 
[18:00:59.601]             setwd(...future.workdir)
[18:00:59.601]         {
[18:00:59.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.601]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.601]             }
[18:00:59.601]             base::options(...future.oldOptions)
[18:00:59.601]             if (.Platform$OS.type == "windows") {
[18:00:59.601]                 old_names <- names(...future.oldEnvVars)
[18:00:59.601]                 envs <- base::Sys.getenv()
[18:00:59.601]                 names <- names(envs)
[18:00:59.601]                 common <- intersect(names, old_names)
[18:00:59.601]                 added <- setdiff(names, old_names)
[18:00:59.601]                 removed <- setdiff(old_names, names)
[18:00:59.601]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.601]                   envs[common]]
[18:00:59.601]                 NAMES <- toupper(changed)
[18:00:59.601]                 args <- list()
[18:00:59.601]                 for (kk in seq_along(NAMES)) {
[18:00:59.601]                   name <- changed[[kk]]
[18:00:59.601]                   NAME <- NAMES[[kk]]
[18:00:59.601]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.601]                     next
[18:00:59.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.601]                 }
[18:00:59.601]                 NAMES <- toupper(added)
[18:00:59.601]                 for (kk in seq_along(NAMES)) {
[18:00:59.601]                   name <- added[[kk]]
[18:00:59.601]                   NAME <- NAMES[[kk]]
[18:00:59.601]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.601]                     next
[18:00:59.601]                   args[[name]] <- ""
[18:00:59.601]                 }
[18:00:59.601]                 NAMES <- toupper(removed)
[18:00:59.601]                 for (kk in seq_along(NAMES)) {
[18:00:59.601]                   name <- removed[[kk]]
[18:00:59.601]                   NAME <- NAMES[[kk]]
[18:00:59.601]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.601]                     next
[18:00:59.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.601]                 }
[18:00:59.601]                 if (length(args) > 0) 
[18:00:59.601]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.601]             }
[18:00:59.601]             else {
[18:00:59.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.601]             }
[18:00:59.601]             {
[18:00:59.601]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.601]                   0L) {
[18:00:59.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.601]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.601]                   base::options(opts)
[18:00:59.601]                 }
[18:00:59.601]                 {
[18:00:59.601]                   {
[18:00:59.601]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.601]                     NULL
[18:00:59.601]                   }
[18:00:59.601]                   options(future.plan = NULL)
[18:00:59.601]                   if (is.na(NA_character_)) 
[18:00:59.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.601]                     .init = FALSE)
[18:00:59.601]                 }
[18:00:59.601]             }
[18:00:59.601]         }
[18:00:59.601]     })
[18:00:59.601]     if (TRUE) {
[18:00:59.601]         base::sink(type = "output", split = FALSE)
[18:00:59.601]         if (TRUE) {
[18:00:59.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.601]         }
[18:00:59.601]         else {
[18:00:59.601]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.601]         }
[18:00:59.601]         base::close(...future.stdout)
[18:00:59.601]         ...future.stdout <- NULL
[18:00:59.601]     }
[18:00:59.601]     ...future.result$conditions <- ...future.conditions
[18:00:59.601]     ...future.result$finished <- base::Sys.time()
[18:00:59.601]     ...future.result
[18:00:59.601] }
[18:00:59.606] assign_globals() ...
[18:00:59.606] List of 5
[18:00:59.606]  $ ...future.FUN            :function (x, ...)  
[18:00:59.606]  $ MoreArgs                 : NULL
[18:00:59.606]  $ ...future.elements_ii    :List of 2
[18:00:59.606]   ..$ times:List of 2
[18:00:59.606]   .. ..$ : int 3
[18:00:59.606]   .. ..$ : int 4
[18:00:59.606]   ..$ x    :List of 2
[18:00:59.606]   .. ..$ : int 2
[18:00:59.606]   .. ..$ : int 1
[18:00:59.606]  $ ...future.seeds_ii       : NULL
[18:00:59.606]  $ ...future.globals.maxSize: NULL
[18:00:59.606]  - attr(*, "where")=List of 5
[18:00:59.606]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.606]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.606]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.606]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.606]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.606]  - attr(*, "resolved")= logi FALSE
[18:00:59.606]  - attr(*, "total_size")= num 280
[18:00:59.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.606]  - attr(*, "already-done")= logi TRUE
[18:00:59.623] - copied ‘...future.FUN’ to environment
[18:00:59.623] - copied ‘MoreArgs’ to environment
[18:00:59.624] - copied ‘...future.elements_ii’ to environment
[18:00:59.624] - copied ‘...future.seeds_ii’ to environment
[18:00:59.624] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.624] assign_globals() ... done
[18:00:59.625] requestCore(): workers = 2
[18:00:59.629] MulticoreFuture started
[18:00:59.629] - Launch lazy future ... done
[18:00:59.630] run() for ‘MulticoreFuture’ ... done
[18:00:59.630] Created future:
[18:00:59.634] plan(): Setting new future strategy stack:
[18:00:59.634] List of future strategies:
[18:00:59.634] 1. sequential:
[18:00:59.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.634]    - tweaked: FALSE
[18:00:59.634]    - call: NULL
[18:00:59.636] plan(): nbrOfWorkers() = 1
[18:00:59.641] plan(): Setting new future strategy stack:
[18:00:59.641] List of future strategies:
[18:00:59.641] 1. multicore:
[18:00:59.641]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.641]    - tweaked: FALSE
[18:00:59.641]    - call: plan(strategy)
[18:00:59.631] MulticoreFuture:
[18:00:59.631] Label: ‘future_mapply-2’
[18:00:59.631] Expression:
[18:00:59.631] {
[18:00:59.631]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.631]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.631]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.631]         on.exit(options(oopts), add = TRUE)
[18:00:59.631]     }
[18:00:59.631]     {
[18:00:59.631]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.631]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.631]         do.call(mapply, args = args)
[18:00:59.631]     }
[18:00:59.631] }
[18:00:59.631] Lazy evaluation: FALSE
[18:00:59.631] Asynchronous evaluation: TRUE
[18:00:59.631] Local evaluation: TRUE
[18:00:59.631] Environment: R_GlobalEnv
[18:00:59.631] Capture standard output: TRUE
[18:00:59.631] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.631] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.631] Packages: <none>
[18:00:59.631] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.631] Resolved: FALSE
[18:00:59.631] Value: <not collected>
[18:00:59.631] Conditions captured: <none>
[18:00:59.631] Early signaling: FALSE
[18:00:59.631] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.631] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.648] Chunk #2 of 2 ... DONE
[18:00:59.648] Launching 2 futures (chunks) ... DONE
[18:00:59.650] plan(): nbrOfWorkers() = 2
[18:00:59.649] Resolving 2 futures (chunks) ...
[18:00:59.651] resolve() on list ...
[18:00:59.651]  recursive: 0
[18:00:59.652]  length: 2
[18:00:59.652] 
[18:00:59.653] Future #1
[18:00:59.653] result() for MulticoreFuture ...
[18:00:59.655] result() for MulticoreFuture ...
[18:00:59.656] result() for MulticoreFuture ... done
[18:00:59.656] result() for MulticoreFuture ... done
[18:00:59.656] result() for MulticoreFuture ...
[18:00:59.657] result() for MulticoreFuture ... done
[18:00:59.657] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:00:59.658] - nx: 2
[18:00:59.658] - relay: TRUE
[18:00:59.659] - stdout: TRUE
[18:00:59.659] - signal: TRUE
[18:00:59.659] - resignal: FALSE
[18:00:59.660] - force: TRUE
[18:00:59.660] - relayed: [n=2] FALSE, FALSE
[18:00:59.660] - queued futures: [n=2] FALSE, FALSE
[18:00:59.661]  - until=1
[18:00:59.661]  - relaying element #1
[18:00:59.661] result() for MulticoreFuture ...
[18:00:59.662] result() for MulticoreFuture ... done
[18:00:59.662] result() for MulticoreFuture ...
[18:00:59.662] result() for MulticoreFuture ... done
[18:00:59.663] result() for MulticoreFuture ...
[18:00:59.663] result() for MulticoreFuture ... done
[18:00:59.664] result() for MulticoreFuture ...
[18:00:59.664] result() for MulticoreFuture ... done
[18:00:59.664] - relayed: [n=2] TRUE, FALSE
[18:00:59.665] - queued futures: [n=2] TRUE, FALSE
[18:00:59.665] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:00:59.666]  length: 1 (resolved future 1)
[18:00:59.666] Future #2
[18:00:59.667] result() for MulticoreFuture ...
[18:00:59.668] result() for MulticoreFuture ...
[18:00:59.668] result() for MulticoreFuture ... done
[18:00:59.669] result() for MulticoreFuture ... done
[18:00:59.669] result() for MulticoreFuture ...
[18:00:59.669] result() for MulticoreFuture ... done
[18:00:59.670] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:00:59.670] - nx: 2
[18:00:59.671] - relay: TRUE
[18:00:59.671] - stdout: TRUE
[18:00:59.671] - signal: TRUE
[18:00:59.671] - resignal: FALSE
[18:00:59.672] - force: TRUE
[18:00:59.672] - relayed: [n=2] TRUE, FALSE
[18:00:59.673] - queued futures: [n=2] TRUE, FALSE
[18:00:59.673]  - until=2
[18:00:59.673]  - relaying element #2
[18:00:59.673] result() for MulticoreFuture ...
[18:00:59.674] result() for MulticoreFuture ... done
[18:00:59.674] result() for MulticoreFuture ...
[18:00:59.674] result() for MulticoreFuture ... done
[18:00:59.675] result() for MulticoreFuture ...
[18:00:59.675] result() for MulticoreFuture ... done
[18:00:59.675] result() for MulticoreFuture ...
[18:00:59.676] result() for MulticoreFuture ... done
[18:00:59.676] - relayed: [n=2] TRUE, TRUE
[18:00:59.676] - queued futures: [n=2] TRUE, TRUE
[18:00:59.676] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:00:59.677]  length: 0 (resolved future 2)
[18:00:59.677] Relaying remaining futures
[18:00:59.677] signalConditionsASAP(NULL, pos=0) ...
[18:00:59.677] - nx: 2
[18:00:59.677] - relay: TRUE
[18:00:59.678] - stdout: TRUE
[18:00:59.678] - signal: TRUE
[18:00:59.678] - resignal: FALSE
[18:00:59.678] - force: TRUE
[18:00:59.679] - relayed: [n=2] TRUE, TRUE
[18:00:59.679] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:00:59.679] - relayed: [n=2] TRUE, TRUE
[18:00:59.683] - queued futures: [n=2] TRUE, TRUE
[18:00:59.684] signalConditionsASAP(NULL, pos=0) ... done
[18:00:59.684] resolve() on list ... DONE
[18:00:59.684] result() for MulticoreFuture ...
[18:00:59.685] result() for MulticoreFuture ... done
[18:00:59.685] result() for MulticoreFuture ...
[18:00:59.685] result() for MulticoreFuture ... done
[18:00:59.686] result() for MulticoreFuture ...
[18:00:59.686] result() for MulticoreFuture ... done
[18:00:59.686] result() for MulticoreFuture ...
[18:00:59.687] result() for MulticoreFuture ... done
[18:00:59.687]  - Number of value chunks collected: 2
[18:00:59.687] Resolving 2 futures (chunks) ... DONE
[18:00:59.688] Reducing values from 2 chunks ...
[18:00:59.688]  - Number of values collected after concatenation: 4
[18:00:59.688]  - Number of values expected: 4
[18:00:59.688] Reducing values from 2 chunks ... DONE
[18:00:59.689] future_mapply() ... DONE
[18:00:59.689] future_mapply() ...
[18:00:59.697] Number of chunks: 2
[18:00:59.698] getGlobalsAndPackagesXApply() ...
[18:00:59.698]  - future.globals: TRUE
[18:00:59.698] getGlobalsAndPackages() ...
[18:00:59.699] Searching for globals...
[18:00:59.700] - globals found: [1] ‘FUN’
[18:00:59.701] Searching for globals ... DONE
[18:00:59.701] Resolving globals: FALSE
[18:00:59.702] The total size of the 1 globals is 56 bytes (56 bytes)
[18:00:59.702] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:00:59.703] - globals: [1] ‘FUN’
[18:00:59.703] 
[18:00:59.703] getGlobalsAndPackages() ... DONE
[18:00:59.703]  - globals found/used: [n=1] ‘FUN’
[18:00:59.704]  - needed namespaces: [n=0] 
[18:00:59.704] Finding globals ... DONE
[18:00:59.705] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:59.705] List of 2
[18:00:59.705]  $ ...future.FUN:function (x, ...)  
[18:00:59.705]  $ MoreArgs     :List of 1
[18:00:59.705]   ..$ x: num 42
[18:00:59.705]  - attr(*, "where")=List of 2
[18:00:59.705]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:59.705]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:59.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.705]  - attr(*, "resolved")= logi FALSE
[18:00:59.705]  - attr(*, "total_size")= num NA
[18:00:59.712] Packages to be attached in all futures: [n=0] 
[18:00:59.712] getGlobalsAndPackagesXApply() ... DONE
[18:00:59.713] Number of futures (= number of chunks): 2
[18:00:59.713] Launching 2 futures (chunks) ...
[18:00:59.713] Chunk #1 of 2 ...
[18:00:59.714]  - Finding globals in '...' for chunk #1 ...
[18:00:59.714] getGlobalsAndPackages() ...
[18:00:59.714] Searching for globals...
[18:00:59.715] 
[18:00:59.715] Searching for globals ... DONE
[18:00:59.715] - globals: [0] <none>
[18:00:59.715] getGlobalsAndPackages() ... DONE
[18:00:59.716]    + additional globals found: [n=0] 
[18:00:59.716]    + additional namespaces needed: [n=0] 
[18:00:59.716]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:59.716]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.717]  - seeds: <none>
[18:00:59.717]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.717] getGlobalsAndPackages() ...
[18:00:59.717] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.718] Resolving globals: FALSE
[18:00:59.719] The total size of the 5 globals is 224 bytes (224 bytes)
[18:00:59.720] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:00:59.720] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.720] 
[18:00:59.721] getGlobalsAndPackages() ... DONE
[18:00:59.721] run() for ‘Future’ ...
[18:00:59.721] - state: ‘created’
[18:00:59.722] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.728] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.729]   - Field: ‘label’
[18:00:59.729]   - Field: ‘local’
[18:00:59.729]   - Field: ‘owner’
[18:00:59.730]   - Field: ‘envir’
[18:00:59.730]   - Field: ‘workers’
[18:00:59.730]   - Field: ‘packages’
[18:00:59.730]   - Field: ‘gc’
[18:00:59.730]   - Field: ‘job’
[18:00:59.731]   - Field: ‘conditions’
[18:00:59.731]   - Field: ‘expr’
[18:00:59.731]   - Field: ‘uuid’
[18:00:59.731]   - Field: ‘seed’
[18:00:59.731]   - Field: ‘version’
[18:00:59.732]   - Field: ‘result’
[18:00:59.732]   - Field: ‘asynchronous’
[18:00:59.732]   - Field: ‘calls’
[18:00:59.732]   - Field: ‘globals’
[18:00:59.733]   - Field: ‘stdout’
[18:00:59.733]   - Field: ‘earlySignal’
[18:00:59.733]   - Field: ‘lazy’
[18:00:59.733]   - Field: ‘state’
[18:00:59.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.734] - Launch lazy future ...
[18:00:59.734] Packages needed by the future expression (n = 0): <none>
[18:00:59.734] Packages needed by future strategies (n = 0): <none>
[18:00:59.735] {
[18:00:59.735]     {
[18:00:59.735]         {
[18:00:59.735]             ...future.startTime <- base::Sys.time()
[18:00:59.735]             {
[18:00:59.735]                 {
[18:00:59.735]                   {
[18:00:59.735]                     {
[18:00:59.735]                       base::local({
[18:00:59.735]                         has_future <- base::requireNamespace("future", 
[18:00:59.735]                           quietly = TRUE)
[18:00:59.735]                         if (has_future) {
[18:00:59.735]                           ns <- base::getNamespace("future")
[18:00:59.735]                           version <- ns[[".package"]][["version"]]
[18:00:59.735]                           if (is.null(version)) 
[18:00:59.735]                             version <- utils::packageVersion("future")
[18:00:59.735]                         }
[18:00:59.735]                         else {
[18:00:59.735]                           version <- NULL
[18:00:59.735]                         }
[18:00:59.735]                         if (!has_future || version < "1.8.0") {
[18:00:59.735]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.735]                             "", base::R.version$version.string), 
[18:00:59.735]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.735]                               "release", "version")], collapse = " "), 
[18:00:59.735]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.735]                             info)
[18:00:59.735]                           info <- base::paste(info, collapse = "; ")
[18:00:59.735]                           if (!has_future) {
[18:00:59.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.735]                               info)
[18:00:59.735]                           }
[18:00:59.735]                           else {
[18:00:59.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.735]                               info, version)
[18:00:59.735]                           }
[18:00:59.735]                           base::stop(msg)
[18:00:59.735]                         }
[18:00:59.735]                       })
[18:00:59.735]                     }
[18:00:59.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.735]                     base::options(mc.cores = 1L)
[18:00:59.735]                   }
[18:00:59.735]                   ...future.strategy.old <- future::plan("list")
[18:00:59.735]                   options(future.plan = NULL)
[18:00:59.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.735]                 }
[18:00:59.735]                 ...future.workdir <- getwd()
[18:00:59.735]             }
[18:00:59.735]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.735]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.735]         }
[18:00:59.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.735]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.735]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.735]             base::names(...future.oldOptions))
[18:00:59.735]     }
[18:00:59.735]     if (FALSE) {
[18:00:59.735]     }
[18:00:59.735]     else {
[18:00:59.735]         if (TRUE) {
[18:00:59.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.735]                 open = "w")
[18:00:59.735]         }
[18:00:59.735]         else {
[18:00:59.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.735]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.735]         }
[18:00:59.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.735]             base::sink(type = "output", split = FALSE)
[18:00:59.735]             base::close(...future.stdout)
[18:00:59.735]         }, add = TRUE)
[18:00:59.735]     }
[18:00:59.735]     ...future.frame <- base::sys.nframe()
[18:00:59.735]     ...future.conditions <- base::list()
[18:00:59.735]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.735]     if (FALSE) {
[18:00:59.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.735]     }
[18:00:59.735]     ...future.result <- base::tryCatch({
[18:00:59.735]         base::withCallingHandlers({
[18:00:59.735]             ...future.value <- base::withVisible(base::local({
[18:00:59.735]                 withCallingHandlers({
[18:00:59.735]                   {
[18:00:59.735]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.735]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.735]                       ...future.globals.maxSize)) {
[18:00:59.735]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.735]                       on.exit(options(oopts), add = TRUE)
[18:00:59.735]                     }
[18:00:59.735]                     {
[18:00:59.735]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.735]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.735]                         USE.NAMES = FALSE)
[18:00:59.735]                       do.call(mapply, args = args)
[18:00:59.735]                     }
[18:00:59.735]                   }
[18:00:59.735]                 }, immediateCondition = function(cond) {
[18:00:59.735]                   save_rds <- function (object, pathname, ...) 
[18:00:59.735]                   {
[18:00:59.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.735]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.735]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.735]                         fi_tmp[["mtime"]])
[18:00:59.735]                     }
[18:00:59.735]                     tryCatch({
[18:00:59.735]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.735]                     }, error = function(ex) {
[18:00:59.735]                       msg <- conditionMessage(ex)
[18:00:59.735]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.735]                         fi_tmp[["mtime"]], msg)
[18:00:59.735]                       ex$message <- msg
[18:00:59.735]                       stop(ex)
[18:00:59.735]                     })
[18:00:59.735]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.735]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.735]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.735]                       fi <- file.info(pathname)
[18:00:59.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.735]                         fi[["size"]], fi[["mtime"]])
[18:00:59.735]                       stop(msg)
[18:00:59.735]                     }
[18:00:59.735]                     invisible(pathname)
[18:00:59.735]                   }
[18:00:59.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.735]                     rootPath = tempdir()) 
[18:00:59.735]                   {
[18:00:59.735]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.735]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.735]                       tmpdir = path, fileext = ".rds")
[18:00:59.735]                     save_rds(obj, file)
[18:00:59.735]                   }
[18:00:59.735]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.735]                   {
[18:00:59.735]                     inherits <- base::inherits
[18:00:59.735]                     invokeRestart <- base::invokeRestart
[18:00:59.735]                     is.null <- base::is.null
[18:00:59.735]                     muffled <- FALSE
[18:00:59.735]                     if (inherits(cond, "message")) {
[18:00:59.735]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.735]                       if (muffled) 
[18:00:59.735]                         invokeRestart("muffleMessage")
[18:00:59.735]                     }
[18:00:59.735]                     else if (inherits(cond, "warning")) {
[18:00:59.735]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.735]                       if (muffled) 
[18:00:59.735]                         invokeRestart("muffleWarning")
[18:00:59.735]                     }
[18:00:59.735]                     else if (inherits(cond, "condition")) {
[18:00:59.735]                       if (!is.null(pattern)) {
[18:00:59.735]                         computeRestarts <- base::computeRestarts
[18:00:59.735]                         grepl <- base::grepl
[18:00:59.735]                         restarts <- computeRestarts(cond)
[18:00:59.735]                         for (restart in restarts) {
[18:00:59.735]                           name <- restart$name
[18:00:59.735]                           if (is.null(name)) 
[18:00:59.735]                             next
[18:00:59.735]                           if (!grepl(pattern, name)) 
[18:00:59.735]                             next
[18:00:59.735]                           invokeRestart(restart)
[18:00:59.735]                           muffled <- TRUE
[18:00:59.735]                           break
[18:00:59.735]                         }
[18:00:59.735]                       }
[18:00:59.735]                     }
[18:00:59.735]                     invisible(muffled)
[18:00:59.735]                   }
[18:00:59.735]                   muffleCondition(cond)
[18:00:59.735]                 })
[18:00:59.735]             }))
[18:00:59.735]             future::FutureResult(value = ...future.value$value, 
[18:00:59.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.735]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.735]                     ...future.globalenv.names))
[18:00:59.735]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.735]         }, condition = base::local({
[18:00:59.735]             c <- base::c
[18:00:59.735]             inherits <- base::inherits
[18:00:59.735]             invokeRestart <- base::invokeRestart
[18:00:59.735]             length <- base::length
[18:00:59.735]             list <- base::list
[18:00:59.735]             seq.int <- base::seq.int
[18:00:59.735]             signalCondition <- base::signalCondition
[18:00:59.735]             sys.calls <- base::sys.calls
[18:00:59.735]             `[[` <- base::`[[`
[18:00:59.735]             `+` <- base::`+`
[18:00:59.735]             `<<-` <- base::`<<-`
[18:00:59.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.735]                   3L)]
[18:00:59.735]             }
[18:00:59.735]             function(cond) {
[18:00:59.735]                 is_error <- inherits(cond, "error")
[18:00:59.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.735]                   NULL)
[18:00:59.735]                 if (is_error) {
[18:00:59.735]                   sessionInformation <- function() {
[18:00:59.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.735]                       search = base::search(), system = base::Sys.info())
[18:00:59.735]                   }
[18:00:59.735]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.735]                     cond$call), session = sessionInformation(), 
[18:00:59.735]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.735]                   signalCondition(cond)
[18:00:59.735]                 }
[18:00:59.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.735]                 "immediateCondition"))) {
[18:00:59.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.735]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.735]                   if (TRUE && !signal) {
[18:00:59.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.735]                     {
[18:00:59.735]                       inherits <- base::inherits
[18:00:59.735]                       invokeRestart <- base::invokeRestart
[18:00:59.735]                       is.null <- base::is.null
[18:00:59.735]                       muffled <- FALSE
[18:00:59.735]                       if (inherits(cond, "message")) {
[18:00:59.735]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.735]                         if (muffled) 
[18:00:59.735]                           invokeRestart("muffleMessage")
[18:00:59.735]                       }
[18:00:59.735]                       else if (inherits(cond, "warning")) {
[18:00:59.735]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.735]                         if (muffled) 
[18:00:59.735]                           invokeRestart("muffleWarning")
[18:00:59.735]                       }
[18:00:59.735]                       else if (inherits(cond, "condition")) {
[18:00:59.735]                         if (!is.null(pattern)) {
[18:00:59.735]                           computeRestarts <- base::computeRestarts
[18:00:59.735]                           grepl <- base::grepl
[18:00:59.735]                           restarts <- computeRestarts(cond)
[18:00:59.735]                           for (restart in restarts) {
[18:00:59.735]                             name <- restart$name
[18:00:59.735]                             if (is.null(name)) 
[18:00:59.735]                               next
[18:00:59.735]                             if (!grepl(pattern, name)) 
[18:00:59.735]                               next
[18:00:59.735]                             invokeRestart(restart)
[18:00:59.735]                             muffled <- TRUE
[18:00:59.735]                             break
[18:00:59.735]                           }
[18:00:59.735]                         }
[18:00:59.735]                       }
[18:00:59.735]                       invisible(muffled)
[18:00:59.735]                     }
[18:00:59.735]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.735]                   }
[18:00:59.735]                 }
[18:00:59.735]                 else {
[18:00:59.735]                   if (TRUE) {
[18:00:59.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.735]                     {
[18:00:59.735]                       inherits <- base::inherits
[18:00:59.735]                       invokeRestart <- base::invokeRestart
[18:00:59.735]                       is.null <- base::is.null
[18:00:59.735]                       muffled <- FALSE
[18:00:59.735]                       if (inherits(cond, "message")) {
[18:00:59.735]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.735]                         if (muffled) 
[18:00:59.735]                           invokeRestart("muffleMessage")
[18:00:59.735]                       }
[18:00:59.735]                       else if (inherits(cond, "warning")) {
[18:00:59.735]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.735]                         if (muffled) 
[18:00:59.735]                           invokeRestart("muffleWarning")
[18:00:59.735]                       }
[18:00:59.735]                       else if (inherits(cond, "condition")) {
[18:00:59.735]                         if (!is.null(pattern)) {
[18:00:59.735]                           computeRestarts <- base::computeRestarts
[18:00:59.735]                           grepl <- base::grepl
[18:00:59.735]                           restarts <- computeRestarts(cond)
[18:00:59.735]                           for (restart in restarts) {
[18:00:59.735]                             name <- restart$name
[18:00:59.735]                             if (is.null(name)) 
[18:00:59.735]                               next
[18:00:59.735]                             if (!grepl(pattern, name)) 
[18:00:59.735]                               next
[18:00:59.735]                             invokeRestart(restart)
[18:00:59.735]                             muffled <- TRUE
[18:00:59.735]                             break
[18:00:59.735]                           }
[18:00:59.735]                         }
[18:00:59.735]                       }
[18:00:59.735]                       invisible(muffled)
[18:00:59.735]                     }
[18:00:59.735]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.735]                   }
[18:00:59.735]                 }
[18:00:59.735]             }
[18:00:59.735]         }))
[18:00:59.735]     }, error = function(ex) {
[18:00:59.735]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.735]                 ...future.rng), started = ...future.startTime, 
[18:00:59.735]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.735]             version = "1.8"), class = "FutureResult")
[18:00:59.735]     }, finally = {
[18:00:59.735]         if (!identical(...future.workdir, getwd())) 
[18:00:59.735]             setwd(...future.workdir)
[18:00:59.735]         {
[18:00:59.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.735]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.735]             }
[18:00:59.735]             base::options(...future.oldOptions)
[18:00:59.735]             if (.Platform$OS.type == "windows") {
[18:00:59.735]                 old_names <- names(...future.oldEnvVars)
[18:00:59.735]                 envs <- base::Sys.getenv()
[18:00:59.735]                 names <- names(envs)
[18:00:59.735]                 common <- intersect(names, old_names)
[18:00:59.735]                 added <- setdiff(names, old_names)
[18:00:59.735]                 removed <- setdiff(old_names, names)
[18:00:59.735]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.735]                   envs[common]]
[18:00:59.735]                 NAMES <- toupper(changed)
[18:00:59.735]                 args <- list()
[18:00:59.735]                 for (kk in seq_along(NAMES)) {
[18:00:59.735]                   name <- changed[[kk]]
[18:00:59.735]                   NAME <- NAMES[[kk]]
[18:00:59.735]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.735]                     next
[18:00:59.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.735]                 }
[18:00:59.735]                 NAMES <- toupper(added)
[18:00:59.735]                 for (kk in seq_along(NAMES)) {
[18:00:59.735]                   name <- added[[kk]]
[18:00:59.735]                   NAME <- NAMES[[kk]]
[18:00:59.735]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.735]                     next
[18:00:59.735]                   args[[name]] <- ""
[18:00:59.735]                 }
[18:00:59.735]                 NAMES <- toupper(removed)
[18:00:59.735]                 for (kk in seq_along(NAMES)) {
[18:00:59.735]                   name <- removed[[kk]]
[18:00:59.735]                   NAME <- NAMES[[kk]]
[18:00:59.735]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.735]                     next
[18:00:59.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.735]                 }
[18:00:59.735]                 if (length(args) > 0) 
[18:00:59.735]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.735]             }
[18:00:59.735]             else {
[18:00:59.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.735]             }
[18:00:59.735]             {
[18:00:59.735]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.735]                   0L) {
[18:00:59.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.735]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.735]                   base::options(opts)
[18:00:59.735]                 }
[18:00:59.735]                 {
[18:00:59.735]                   {
[18:00:59.735]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.735]                     NULL
[18:00:59.735]                   }
[18:00:59.735]                   options(future.plan = NULL)
[18:00:59.735]                   if (is.na(NA_character_)) 
[18:00:59.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.735]                     .init = FALSE)
[18:00:59.735]                 }
[18:00:59.735]             }
[18:00:59.735]         }
[18:00:59.735]     })
[18:00:59.735]     if (TRUE) {
[18:00:59.735]         base::sink(type = "output", split = FALSE)
[18:00:59.735]         if (TRUE) {
[18:00:59.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.735]         }
[18:00:59.735]         else {
[18:00:59.735]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.735]         }
[18:00:59.735]         base::close(...future.stdout)
[18:00:59.735]         ...future.stdout <- NULL
[18:00:59.735]     }
[18:00:59.735]     ...future.result$conditions <- ...future.conditions
[18:00:59.735]     ...future.result$finished <- base::Sys.time()
[18:00:59.735]     ...future.result
[18:00:59.735] }
[18:00:59.740] assign_globals() ...
[18:00:59.740] List of 5
[18:00:59.740]  $ ...future.FUN            :function (x, ...)  
[18:00:59.740]  $ MoreArgs                 :List of 1
[18:00:59.740]   ..$ x: num 42
[18:00:59.740]  $ ...future.elements_ii    :List of 1
[18:00:59.740]   ..$ times:List of 2
[18:00:59.740]   .. ..$ : int 1
[18:00:59.740]   .. ..$ : int 2
[18:00:59.740]  $ ...future.seeds_ii       : NULL
[18:00:59.740]  $ ...future.globals.maxSize: NULL
[18:00:59.740]  - attr(*, "where")=List of 5
[18:00:59.740]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.740]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.740]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.740]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.740]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.740]  - attr(*, "resolved")= logi FALSE
[18:00:59.740]  - attr(*, "total_size")= num 224
[18:00:59.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.740]  - attr(*, "already-done")= logi TRUE
[18:00:59.755] - copied ‘...future.FUN’ to environment
[18:00:59.755] - copied ‘MoreArgs’ to environment
[18:00:59.756] - copied ‘...future.elements_ii’ to environment
[18:00:59.756] - copied ‘...future.seeds_ii’ to environment
[18:00:59.756] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.756] assign_globals() ... done
[18:00:59.757] requestCore(): workers = 2
[18:00:59.760] MulticoreFuture started
[18:00:59.761] - Launch lazy future ... done
[18:00:59.762] run() for ‘MulticoreFuture’ ... done
[18:00:59.762] plan(): Setting new future strategy stack:
[18:00:59.763] Created future:
[18:00:59.763] List of future strategies:
[18:00:59.763] 1. sequential:
[18:00:59.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.763]    - tweaked: FALSE
[18:00:59.763]    - call: NULL
[18:00:59.765] plan(): nbrOfWorkers() = 1
[18:00:59.770] plan(): Setting new future strategy stack:
[18:00:59.771] List of future strategies:
[18:00:59.771] 1. multicore:
[18:00:59.771]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.771]    - tweaked: FALSE
[18:00:59.771]    - call: plan(strategy)
[18:00:59.763] MulticoreFuture:
[18:00:59.763] Label: ‘future_mapply-1’
[18:00:59.763] Expression:
[18:00:59.763] {
[18:00:59.763]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.763]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.763]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.763]         on.exit(options(oopts), add = TRUE)
[18:00:59.763]     }
[18:00:59.763]     {
[18:00:59.763]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.763]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.763]         do.call(mapply, args = args)
[18:00:59.763]     }
[18:00:59.763] }
[18:00:59.763] Lazy evaluation: FALSE
[18:00:59.763] Asynchronous evaluation: TRUE
[18:00:59.763] Local evaluation: TRUE
[18:00:59.763] Environment: R_GlobalEnv
[18:00:59.763] Capture standard output: TRUE
[18:00:59.763] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.763] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.763] Packages: <none>
[18:00:59.763] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.763] Resolved: FALSE
[18:00:59.763] Value: <not collected>
[18:00:59.763] Conditions captured: <none>
[18:00:59.763] Early signaling: FALSE
[18:00:59.763] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.763] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.779] Chunk #1 of 2 ... DONE
[18:00:59.779] Chunk #2 of 2 ...
[18:00:59.784]  - Finding globals in '...' for chunk #2 ...
[18:00:59.784] getGlobalsAndPackages() ...
[18:00:59.785] Searching for globals...
[18:00:59.784] plan(): nbrOfWorkers() = 2
[18:00:59.787] 
[18:00:59.787] Searching for globals ... DONE
[18:00:59.788] - globals: [0] <none>
[18:00:59.788] getGlobalsAndPackages() ... DONE
[18:00:59.788]    + additional globals found: [n=0] 
[18:00:59.788]    + additional namespaces needed: [n=0] 
[18:00:59.789]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:59.789]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.789]  - seeds: <none>
[18:00:59.790]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.790] getGlobalsAndPackages() ...
[18:00:59.790] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.791] Resolving globals: FALSE
[18:00:59.793] The total size of the 5 globals is 224 bytes (224 bytes)
[18:00:59.795] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:00:59.796] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.796] 
[18:00:59.796] getGlobalsAndPackages() ... DONE
[18:00:59.797] run() for ‘Future’ ...
[18:00:59.798] - state: ‘created’
[18:00:59.798] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.807]   - Field: ‘label’
[18:00:59.807]   - Field: ‘local’
[18:00:59.808]   - Field: ‘owner’
[18:00:59.808]   - Field: ‘envir’
[18:00:59.808]   - Field: ‘workers’
[18:00:59.809]   - Field: ‘packages’
[18:00:59.809]   - Field: ‘gc’
[18:00:59.809]   - Field: ‘job’
[18:00:59.810]   - Field: ‘conditions’
[18:00:59.810]   - Field: ‘expr’
[18:00:59.810]   - Field: ‘uuid’
[18:00:59.810]   - Field: ‘seed’
[18:00:59.811]   - Field: ‘version’
[18:00:59.811]   - Field: ‘result’
[18:00:59.811]   - Field: ‘asynchronous’
[18:00:59.812]   - Field: ‘calls’
[18:00:59.812]   - Field: ‘globals’
[18:00:59.812]   - Field: ‘stdout’
[18:00:59.812]   - Field: ‘earlySignal’
[18:00:59.813]   - Field: ‘lazy’
[18:00:59.813]   - Field: ‘state’
[18:00:59.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.814] - Launch lazy future ...
[18:00:59.814] Packages needed by the future expression (n = 0): <none>
[18:00:59.815] Packages needed by future strategies (n = 0): <none>
[18:00:59.816] {
[18:00:59.816]     {
[18:00:59.816]         {
[18:00:59.816]             ...future.startTime <- base::Sys.time()
[18:00:59.816]             {
[18:00:59.816]                 {
[18:00:59.816]                   {
[18:00:59.816]                     {
[18:00:59.816]                       base::local({
[18:00:59.816]                         has_future <- base::requireNamespace("future", 
[18:00:59.816]                           quietly = TRUE)
[18:00:59.816]                         if (has_future) {
[18:00:59.816]                           ns <- base::getNamespace("future")
[18:00:59.816]                           version <- ns[[".package"]][["version"]]
[18:00:59.816]                           if (is.null(version)) 
[18:00:59.816]                             version <- utils::packageVersion("future")
[18:00:59.816]                         }
[18:00:59.816]                         else {
[18:00:59.816]                           version <- NULL
[18:00:59.816]                         }
[18:00:59.816]                         if (!has_future || version < "1.8.0") {
[18:00:59.816]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.816]                             "", base::R.version$version.string), 
[18:00:59.816]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.816]                               "release", "version")], collapse = " "), 
[18:00:59.816]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.816]                             info)
[18:00:59.816]                           info <- base::paste(info, collapse = "; ")
[18:00:59.816]                           if (!has_future) {
[18:00:59.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.816]                               info)
[18:00:59.816]                           }
[18:00:59.816]                           else {
[18:00:59.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.816]                               info, version)
[18:00:59.816]                           }
[18:00:59.816]                           base::stop(msg)
[18:00:59.816]                         }
[18:00:59.816]                       })
[18:00:59.816]                     }
[18:00:59.816]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.816]                     base::options(mc.cores = 1L)
[18:00:59.816]                   }
[18:00:59.816]                   ...future.strategy.old <- future::plan("list")
[18:00:59.816]                   options(future.plan = NULL)
[18:00:59.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.816]                 }
[18:00:59.816]                 ...future.workdir <- getwd()
[18:00:59.816]             }
[18:00:59.816]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.816]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.816]         }
[18:00:59.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.816]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.816]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.816]             base::names(...future.oldOptions))
[18:00:59.816]     }
[18:00:59.816]     if (FALSE) {
[18:00:59.816]     }
[18:00:59.816]     else {
[18:00:59.816]         if (TRUE) {
[18:00:59.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.816]                 open = "w")
[18:00:59.816]         }
[18:00:59.816]         else {
[18:00:59.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.816]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.816]         }
[18:00:59.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.816]             base::sink(type = "output", split = FALSE)
[18:00:59.816]             base::close(...future.stdout)
[18:00:59.816]         }, add = TRUE)
[18:00:59.816]     }
[18:00:59.816]     ...future.frame <- base::sys.nframe()
[18:00:59.816]     ...future.conditions <- base::list()
[18:00:59.816]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.816]     if (FALSE) {
[18:00:59.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.816]     }
[18:00:59.816]     ...future.result <- base::tryCatch({
[18:00:59.816]         base::withCallingHandlers({
[18:00:59.816]             ...future.value <- base::withVisible(base::local({
[18:00:59.816]                 withCallingHandlers({
[18:00:59.816]                   {
[18:00:59.816]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.816]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.816]                       ...future.globals.maxSize)) {
[18:00:59.816]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.816]                       on.exit(options(oopts), add = TRUE)
[18:00:59.816]                     }
[18:00:59.816]                     {
[18:00:59.816]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.816]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.816]                         USE.NAMES = FALSE)
[18:00:59.816]                       do.call(mapply, args = args)
[18:00:59.816]                     }
[18:00:59.816]                   }
[18:00:59.816]                 }, immediateCondition = function(cond) {
[18:00:59.816]                   save_rds <- function (object, pathname, ...) 
[18:00:59.816]                   {
[18:00:59.816]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.816]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.816]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.816]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.816]                         fi_tmp[["mtime"]])
[18:00:59.816]                     }
[18:00:59.816]                     tryCatch({
[18:00:59.816]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.816]                     }, error = function(ex) {
[18:00:59.816]                       msg <- conditionMessage(ex)
[18:00:59.816]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.816]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.816]                         fi_tmp[["mtime"]], msg)
[18:00:59.816]                       ex$message <- msg
[18:00:59.816]                       stop(ex)
[18:00:59.816]                     })
[18:00:59.816]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.816]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.816]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.816]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.816]                       fi <- file.info(pathname)
[18:00:59.816]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.816]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.816]                         fi[["size"]], fi[["mtime"]])
[18:00:59.816]                       stop(msg)
[18:00:59.816]                     }
[18:00:59.816]                     invisible(pathname)
[18:00:59.816]                   }
[18:00:59.816]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.816]                     rootPath = tempdir()) 
[18:00:59.816]                   {
[18:00:59.816]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.816]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.816]                       tmpdir = path, fileext = ".rds")
[18:00:59.816]                     save_rds(obj, file)
[18:00:59.816]                   }
[18:00:59.816]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.816]                   {
[18:00:59.816]                     inherits <- base::inherits
[18:00:59.816]                     invokeRestart <- base::invokeRestart
[18:00:59.816]                     is.null <- base::is.null
[18:00:59.816]                     muffled <- FALSE
[18:00:59.816]                     if (inherits(cond, "message")) {
[18:00:59.816]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.816]                       if (muffled) 
[18:00:59.816]                         invokeRestart("muffleMessage")
[18:00:59.816]                     }
[18:00:59.816]                     else if (inherits(cond, "warning")) {
[18:00:59.816]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.816]                       if (muffled) 
[18:00:59.816]                         invokeRestart("muffleWarning")
[18:00:59.816]                     }
[18:00:59.816]                     else if (inherits(cond, "condition")) {
[18:00:59.816]                       if (!is.null(pattern)) {
[18:00:59.816]                         computeRestarts <- base::computeRestarts
[18:00:59.816]                         grepl <- base::grepl
[18:00:59.816]                         restarts <- computeRestarts(cond)
[18:00:59.816]                         for (restart in restarts) {
[18:00:59.816]                           name <- restart$name
[18:00:59.816]                           if (is.null(name)) 
[18:00:59.816]                             next
[18:00:59.816]                           if (!grepl(pattern, name)) 
[18:00:59.816]                             next
[18:00:59.816]                           invokeRestart(restart)
[18:00:59.816]                           muffled <- TRUE
[18:00:59.816]                           break
[18:00:59.816]                         }
[18:00:59.816]                       }
[18:00:59.816]                     }
[18:00:59.816]                     invisible(muffled)
[18:00:59.816]                   }
[18:00:59.816]                   muffleCondition(cond)
[18:00:59.816]                 })
[18:00:59.816]             }))
[18:00:59.816]             future::FutureResult(value = ...future.value$value, 
[18:00:59.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.816]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.816]                     ...future.globalenv.names))
[18:00:59.816]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.816]         }, condition = base::local({
[18:00:59.816]             c <- base::c
[18:00:59.816]             inherits <- base::inherits
[18:00:59.816]             invokeRestart <- base::invokeRestart
[18:00:59.816]             length <- base::length
[18:00:59.816]             list <- base::list
[18:00:59.816]             seq.int <- base::seq.int
[18:00:59.816]             signalCondition <- base::signalCondition
[18:00:59.816]             sys.calls <- base::sys.calls
[18:00:59.816]             `[[` <- base::`[[`
[18:00:59.816]             `+` <- base::`+`
[18:00:59.816]             `<<-` <- base::`<<-`
[18:00:59.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.816]                   3L)]
[18:00:59.816]             }
[18:00:59.816]             function(cond) {
[18:00:59.816]                 is_error <- inherits(cond, "error")
[18:00:59.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.816]                   NULL)
[18:00:59.816]                 if (is_error) {
[18:00:59.816]                   sessionInformation <- function() {
[18:00:59.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.816]                       search = base::search(), system = base::Sys.info())
[18:00:59.816]                   }
[18:00:59.816]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.816]                     cond$call), session = sessionInformation(), 
[18:00:59.816]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.816]                   signalCondition(cond)
[18:00:59.816]                 }
[18:00:59.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.816]                 "immediateCondition"))) {
[18:00:59.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.816]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.816]                   if (TRUE && !signal) {
[18:00:59.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.816]                     {
[18:00:59.816]                       inherits <- base::inherits
[18:00:59.816]                       invokeRestart <- base::invokeRestart
[18:00:59.816]                       is.null <- base::is.null
[18:00:59.816]                       muffled <- FALSE
[18:00:59.816]                       if (inherits(cond, "message")) {
[18:00:59.816]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.816]                         if (muffled) 
[18:00:59.816]                           invokeRestart("muffleMessage")
[18:00:59.816]                       }
[18:00:59.816]                       else if (inherits(cond, "warning")) {
[18:00:59.816]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.816]                         if (muffled) 
[18:00:59.816]                           invokeRestart("muffleWarning")
[18:00:59.816]                       }
[18:00:59.816]                       else if (inherits(cond, "condition")) {
[18:00:59.816]                         if (!is.null(pattern)) {
[18:00:59.816]                           computeRestarts <- base::computeRestarts
[18:00:59.816]                           grepl <- base::grepl
[18:00:59.816]                           restarts <- computeRestarts(cond)
[18:00:59.816]                           for (restart in restarts) {
[18:00:59.816]                             name <- restart$name
[18:00:59.816]                             if (is.null(name)) 
[18:00:59.816]                               next
[18:00:59.816]                             if (!grepl(pattern, name)) 
[18:00:59.816]                               next
[18:00:59.816]                             invokeRestart(restart)
[18:00:59.816]                             muffled <- TRUE
[18:00:59.816]                             break
[18:00:59.816]                           }
[18:00:59.816]                         }
[18:00:59.816]                       }
[18:00:59.816]                       invisible(muffled)
[18:00:59.816]                     }
[18:00:59.816]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.816]                   }
[18:00:59.816]                 }
[18:00:59.816]                 else {
[18:00:59.816]                   if (TRUE) {
[18:00:59.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.816]                     {
[18:00:59.816]                       inherits <- base::inherits
[18:00:59.816]                       invokeRestart <- base::invokeRestart
[18:00:59.816]                       is.null <- base::is.null
[18:00:59.816]                       muffled <- FALSE
[18:00:59.816]                       if (inherits(cond, "message")) {
[18:00:59.816]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.816]                         if (muffled) 
[18:00:59.816]                           invokeRestart("muffleMessage")
[18:00:59.816]                       }
[18:00:59.816]                       else if (inherits(cond, "warning")) {
[18:00:59.816]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.816]                         if (muffled) 
[18:00:59.816]                           invokeRestart("muffleWarning")
[18:00:59.816]                       }
[18:00:59.816]                       else if (inherits(cond, "condition")) {
[18:00:59.816]                         if (!is.null(pattern)) {
[18:00:59.816]                           computeRestarts <- base::computeRestarts
[18:00:59.816]                           grepl <- base::grepl
[18:00:59.816]                           restarts <- computeRestarts(cond)
[18:00:59.816]                           for (restart in restarts) {
[18:00:59.816]                             name <- restart$name
[18:00:59.816]                             if (is.null(name)) 
[18:00:59.816]                               next
[18:00:59.816]                             if (!grepl(pattern, name)) 
[18:00:59.816]                               next
[18:00:59.816]                             invokeRestart(restart)
[18:00:59.816]                             muffled <- TRUE
[18:00:59.816]                             break
[18:00:59.816]                           }
[18:00:59.816]                         }
[18:00:59.816]                       }
[18:00:59.816]                       invisible(muffled)
[18:00:59.816]                     }
[18:00:59.816]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.816]                   }
[18:00:59.816]                 }
[18:00:59.816]             }
[18:00:59.816]         }))
[18:00:59.816]     }, error = function(ex) {
[18:00:59.816]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.816]                 ...future.rng), started = ...future.startTime, 
[18:00:59.816]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.816]             version = "1.8"), class = "FutureResult")
[18:00:59.816]     }, finally = {
[18:00:59.816]         if (!identical(...future.workdir, getwd())) 
[18:00:59.816]             setwd(...future.workdir)
[18:00:59.816]         {
[18:00:59.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.816]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.816]             }
[18:00:59.816]             base::options(...future.oldOptions)
[18:00:59.816]             if (.Platform$OS.type == "windows") {
[18:00:59.816]                 old_names <- names(...future.oldEnvVars)
[18:00:59.816]                 envs <- base::Sys.getenv()
[18:00:59.816]                 names <- names(envs)
[18:00:59.816]                 common <- intersect(names, old_names)
[18:00:59.816]                 added <- setdiff(names, old_names)
[18:00:59.816]                 removed <- setdiff(old_names, names)
[18:00:59.816]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.816]                   envs[common]]
[18:00:59.816]                 NAMES <- toupper(changed)
[18:00:59.816]                 args <- list()
[18:00:59.816]                 for (kk in seq_along(NAMES)) {
[18:00:59.816]                   name <- changed[[kk]]
[18:00:59.816]                   NAME <- NAMES[[kk]]
[18:00:59.816]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.816]                     next
[18:00:59.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.816]                 }
[18:00:59.816]                 NAMES <- toupper(added)
[18:00:59.816]                 for (kk in seq_along(NAMES)) {
[18:00:59.816]                   name <- added[[kk]]
[18:00:59.816]                   NAME <- NAMES[[kk]]
[18:00:59.816]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.816]                     next
[18:00:59.816]                   args[[name]] <- ""
[18:00:59.816]                 }
[18:00:59.816]                 NAMES <- toupper(removed)
[18:00:59.816]                 for (kk in seq_along(NAMES)) {
[18:00:59.816]                   name <- removed[[kk]]
[18:00:59.816]                   NAME <- NAMES[[kk]]
[18:00:59.816]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.816]                     next
[18:00:59.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.816]                 }
[18:00:59.816]                 if (length(args) > 0) 
[18:00:59.816]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.816]             }
[18:00:59.816]             else {
[18:00:59.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.816]             }
[18:00:59.816]             {
[18:00:59.816]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.816]                   0L) {
[18:00:59.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.816]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.816]                   base::options(opts)
[18:00:59.816]                 }
[18:00:59.816]                 {
[18:00:59.816]                   {
[18:00:59.816]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.816]                     NULL
[18:00:59.816]                   }
[18:00:59.816]                   options(future.plan = NULL)
[18:00:59.816]                   if (is.na(NA_character_)) 
[18:00:59.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.816]                     .init = FALSE)
[18:00:59.816]                 }
[18:00:59.816]             }
[18:00:59.816]         }
[18:00:59.816]     })
[18:00:59.816]     if (TRUE) {
[18:00:59.816]         base::sink(type = "output", split = FALSE)
[18:00:59.816]         if (TRUE) {
[18:00:59.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.816]         }
[18:00:59.816]         else {
[18:00:59.816]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.816]         }
[18:00:59.816]         base::close(...future.stdout)
[18:00:59.816]         ...future.stdout <- NULL
[18:00:59.816]     }
[18:00:59.816]     ...future.result$conditions <- ...future.conditions
[18:00:59.816]     ...future.result$finished <- base::Sys.time()
[18:00:59.816]     ...future.result
[18:00:59.816] }
[18:00:59.823] assign_globals() ...
[18:00:59.823] List of 5
[18:00:59.823]  $ ...future.FUN            :function (x, ...)  
[18:00:59.823]  $ MoreArgs                 :List of 1
[18:00:59.823]   ..$ x: num 42
[18:00:59.823]  $ ...future.elements_ii    :List of 1
[18:00:59.823]   ..$ times:List of 2
[18:00:59.823]   .. ..$ : int 3
[18:00:59.823]   .. ..$ : int 4
[18:00:59.823]  $ ...future.seeds_ii       : NULL
[18:00:59.823]  $ ...future.globals.maxSize: NULL
[18:00:59.823]  - attr(*, "where")=List of 5
[18:00:59.823]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.823]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.823]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.823]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.823]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.823]  - attr(*, "resolved")= logi FALSE
[18:00:59.823]  - attr(*, "total_size")= num 224
[18:00:59.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.823]  - attr(*, "already-done")= logi TRUE
[18:00:59.840] - copied ‘...future.FUN’ to environment
[18:00:59.840] - copied ‘MoreArgs’ to environment
[18:00:59.841] - copied ‘...future.elements_ii’ to environment
[18:00:59.841] - copied ‘...future.seeds_ii’ to environment
[18:00:59.841] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.842] assign_globals() ... done
[18:00:59.842] requestCore(): workers = 2
[18:00:59.846] MulticoreFuture started
[18:00:59.847] - Launch lazy future ... done
[18:00:59.847] run() for ‘MulticoreFuture’ ... done
[18:00:59.848] Created future:
[18:00:59.848] plan(): Setting new future strategy stack:
[18:00:59.848] List of future strategies:
[18:00:59.848] 1. sequential:
[18:00:59.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.848]    - tweaked: FALSE
[18:00:59.848]    - call: NULL
[18:00:59.850] plan(): nbrOfWorkers() = 1
[18:00:59.855] plan(): Setting new future strategy stack:
[18:00:59.855] List of future strategies:
[18:00:59.855] 1. multicore:
[18:00:59.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.855]    - tweaked: FALSE
[18:00:59.855]    - call: plan(strategy)
[18:00:59.848] MulticoreFuture:
[18:00:59.848] Label: ‘future_mapply-2’
[18:00:59.848] Expression:
[18:00:59.848] {
[18:00:59.848]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.848]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.848]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.848]         on.exit(options(oopts), add = TRUE)
[18:00:59.848]     }
[18:00:59.848]     {
[18:00:59.848]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.848]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.848]         do.call(mapply, args = args)
[18:00:59.848]     }
[18:00:59.848] }
[18:00:59.848] Lazy evaluation: FALSE
[18:00:59.848] Asynchronous evaluation: TRUE
[18:00:59.848] Local evaluation: TRUE
[18:00:59.848] Environment: R_GlobalEnv
[18:00:59.848] Capture standard output: TRUE
[18:00:59.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.848] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.848] Packages: <none>
[18:00:59.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.848] Resolved: FALSE
[18:00:59.848] Value: <not collected>
[18:00:59.848] Conditions captured: <none>
[18:00:59.848] Early signaling: FALSE
[18:00:59.848] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.848] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.863] Chunk #2 of 2 ... DONE
[18:00:59.864] Launching 2 futures (chunks) ... DONE
[18:00:59.864] Resolving 2 futures (chunks) ...
[18:00:59.865] resolve() on list ...
[18:00:59.865]  recursive: 0
[18:00:59.865]  length: 2
[18:00:59.870] 
[18:00:59.871] Future #1
[18:00:59.871] result() for MulticoreFuture ...
[18:00:59.875] plan(): nbrOfWorkers() = 2
[18:00:59.876] result() for MulticoreFuture ...
[18:00:59.877] result() for MulticoreFuture ... done
[18:00:59.877] result() for MulticoreFuture ... done
[18:00:59.877] result() for MulticoreFuture ...
[18:00:59.878] result() for MulticoreFuture ... done
[18:00:59.879] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:00:59.879] - nx: 2
[18:00:59.880] - relay: TRUE
[18:00:59.880] - stdout: TRUE
[18:00:59.881] - signal: TRUE
[18:00:59.881] - resignal: FALSE
[18:00:59.882] - force: TRUE
[18:00:59.882] - relayed: [n=2] FALSE, FALSE
[18:00:59.883] - queued futures: [n=2] FALSE, FALSE
[18:00:59.883]  - until=1
[18:00:59.884]  - relaying element #1
[18:00:59.884] result() for MulticoreFuture ...
[18:00:59.884] result() for MulticoreFuture ... done
[18:00:59.885] result() for MulticoreFuture ...
[18:00:59.886] result() for MulticoreFuture ... done
[18:00:59.886] result() for MulticoreFuture ...
[18:00:59.887] result() for MulticoreFuture ... done
[18:00:59.887] result() for MulticoreFuture ...
[18:00:59.887] result() for MulticoreFuture ... done
[18:00:59.888] - relayed: [n=2] TRUE, FALSE
[18:00:59.888] - queued futures: [n=2] TRUE, FALSE
[18:00:59.888] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:00:59.889]  length: 1 (resolved future 1)
[18:00:59.889] Future #2
[18:00:59.890] result() for MulticoreFuture ...
[18:00:59.891] result() for MulticoreFuture ...
[18:00:59.891] result() for MulticoreFuture ... done
[18:00:59.892] result() for MulticoreFuture ... done
[18:00:59.892] result() for MulticoreFuture ...
[18:00:59.892] result() for MulticoreFuture ... done
[18:00:59.892] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:00:59.893] - nx: 2
[18:00:59.893] - relay: TRUE
[18:00:59.893] - stdout: TRUE
[18:00:59.893] - signal: TRUE
[18:00:59.894] - resignal: FALSE
[18:00:59.894] - force: TRUE
[18:00:59.894] - relayed: [n=2] TRUE, FALSE
[18:00:59.894] - queued futures: [n=2] TRUE, FALSE
[18:00:59.894]  - until=2
[18:00:59.895]  - relaying element #2
[18:00:59.895] result() for MulticoreFuture ...
[18:00:59.895] result() for MulticoreFuture ... done
[18:00:59.896] result() for MulticoreFuture ...
[18:00:59.896] result() for MulticoreFuture ... done
[18:00:59.896] result() for MulticoreFuture ...
[18:00:59.896] result() for MulticoreFuture ... done
[18:00:59.897] result() for MulticoreFuture ...
[18:00:59.897] result() for MulticoreFuture ... done
[18:00:59.897] - relayed: [n=2] TRUE, TRUE
[18:00:59.897] - queued futures: [n=2] TRUE, TRUE
[18:00:59.897] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:00:59.898]  length: 0 (resolved future 2)
[18:00:59.898] Relaying remaining futures
[18:00:59.898] signalConditionsASAP(NULL, pos=0) ...
[18:00:59.898] - nx: 2
[18:00:59.898] - relay: TRUE
[18:00:59.899] - stdout: TRUE
[18:00:59.899] - signal: TRUE
[18:00:59.899] - resignal: FALSE
[18:00:59.899] - force: TRUE
[18:00:59.899] - relayed: [n=2] TRUE, TRUE
[18:00:59.900] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:00:59.900] - relayed: [n=2] TRUE, TRUE
[18:00:59.900] - queued futures: [n=2] TRUE, TRUE
[18:00:59.900] signalConditionsASAP(NULL, pos=0) ... done
[18:00:59.901] resolve() on list ... DONE
[18:00:59.901] result() for MulticoreFuture ...
[18:00:59.901] result() for MulticoreFuture ... done
[18:00:59.901] result() for MulticoreFuture ...
[18:00:59.901] result() for MulticoreFuture ... done
[18:00:59.902] result() for MulticoreFuture ...
[18:00:59.902] result() for MulticoreFuture ... done
[18:00:59.902] result() for MulticoreFuture ...
[18:00:59.902] result() for MulticoreFuture ... done
[18:00:59.903]  - Number of value chunks collected: 2
[18:00:59.903] Resolving 2 futures (chunks) ... DONE
[18:00:59.903] Reducing values from 2 chunks ...
[18:00:59.903]  - Number of values collected after concatenation: 4
[18:00:59.903]  - Number of values expected: 4
[18:00:59.904] Reducing values from 2 chunks ... DONE
[18:00:59.904] future_mapply() ... DONE
[18:00:59.904] future_mapply() ...
[18:00:59.911] Number of chunks: 2
[18:00:59.911] getGlobalsAndPackagesXApply() ...
[18:00:59.912]  - future.globals: TRUE
[18:00:59.912] getGlobalsAndPackages() ...
[18:00:59.912] Searching for globals...
[18:00:59.915] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[18:00:59.915] Searching for globals ... DONE
[18:00:59.915] Resolving globals: FALSE
[18:00:59.916] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[18:00:59.917] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[18:00:59.917] - globals: [1] ‘FUN’
[18:00:59.917] 
[18:00:59.918] getGlobalsAndPackages() ... DONE
[18:00:59.918]  - globals found/used: [n=1] ‘FUN’
[18:00:59.918]  - needed namespaces: [n=0] 
[18:00:59.918] Finding globals ... DONE
[18:00:59.919] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:00:59.919] List of 2
[18:00:59.919]  $ ...future.FUN:function (x, y)  
[18:00:59.919]  $ MoreArgs     : NULL
[18:00:59.919]  - attr(*, "where")=List of 2
[18:00:59.919]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:00:59.919]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:00:59.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.919]  - attr(*, "resolved")= logi FALSE
[18:00:59.919]  - attr(*, "total_size")= num NA
[18:00:59.924] Packages to be attached in all futures: [n=0] 
[18:00:59.925] getGlobalsAndPackagesXApply() ... DONE
[18:00:59.925] Number of futures (= number of chunks): 2
[18:00:59.925] Launching 2 futures (chunks) ...
[18:00:59.925] Chunk #1 of 2 ...
[18:00:59.926]  - Finding globals in '...' for chunk #1 ...
[18:00:59.926] getGlobalsAndPackages() ...
[18:00:59.926] Searching for globals...
[18:00:59.927] 
[18:00:59.927] Searching for globals ... DONE
[18:00:59.927] - globals: [0] <none>
[18:00:59.927] getGlobalsAndPackages() ... DONE
[18:00:59.928]    + additional globals found: [n=0] 
[18:00:59.928]    + additional namespaces needed: [n=0] 
[18:00:59.928]  - Finding globals in '...' for chunk #1 ... DONE
[18:00:59.928]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.929]  - seeds: <none>
[18:00:59.929]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.929] getGlobalsAndPackages() ...
[18:00:59.929] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.929] Resolving globals: FALSE
[18:00:59.930] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[18:00:59.931] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.932] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.932] 
[18:00:59.932] getGlobalsAndPackages() ... DONE
[18:00:59.933] run() for ‘Future’ ...
[18:00:59.933] - state: ‘created’
[18:00:59.936] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:00:59.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:00:59.943]   - Field: ‘label’
[18:00:59.943]   - Field: ‘local’
[18:00:59.944]   - Field: ‘owner’
[18:00:59.944]   - Field: ‘envir’
[18:00:59.944]   - Field: ‘workers’
[18:00:59.944]   - Field: ‘packages’
[18:00:59.944]   - Field: ‘gc’
[18:00:59.945]   - Field: ‘job’
[18:00:59.945]   - Field: ‘conditions’
[18:00:59.945]   - Field: ‘expr’
[18:00:59.945]   - Field: ‘uuid’
[18:00:59.945]   - Field: ‘seed’
[18:00:59.946]   - Field: ‘version’
[18:00:59.946]   - Field: ‘result’
[18:00:59.946]   - Field: ‘asynchronous’
[18:00:59.946]   - Field: ‘calls’
[18:00:59.947]   - Field: ‘globals’
[18:00:59.947]   - Field: ‘stdout’
[18:00:59.947]   - Field: ‘earlySignal’
[18:00:59.947]   - Field: ‘lazy’
[18:00:59.947]   - Field: ‘state’
[18:00:59.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:00:59.948] - Launch lazy future ...
[18:00:59.948] Packages needed by the future expression (n = 0): <none>
[18:00:59.948] Packages needed by future strategies (n = 0): <none>
[18:00:59.949] {
[18:00:59.949]     {
[18:00:59.949]         {
[18:00:59.949]             ...future.startTime <- base::Sys.time()
[18:00:59.949]             {
[18:00:59.949]                 {
[18:00:59.949]                   {
[18:00:59.949]                     {
[18:00:59.949]                       base::local({
[18:00:59.949]                         has_future <- base::requireNamespace("future", 
[18:00:59.949]                           quietly = TRUE)
[18:00:59.949]                         if (has_future) {
[18:00:59.949]                           ns <- base::getNamespace("future")
[18:00:59.949]                           version <- ns[[".package"]][["version"]]
[18:00:59.949]                           if (is.null(version)) 
[18:00:59.949]                             version <- utils::packageVersion("future")
[18:00:59.949]                         }
[18:00:59.949]                         else {
[18:00:59.949]                           version <- NULL
[18:00:59.949]                         }
[18:00:59.949]                         if (!has_future || version < "1.8.0") {
[18:00:59.949]                           info <- base::c(r_version = base::gsub("R version ", 
[18:00:59.949]                             "", base::R.version$version.string), 
[18:00:59.949]                             platform = base::sprintf("%s (%s-bit)", 
[18:00:59.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:00:59.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:00:59.949]                               "release", "version")], collapse = " "), 
[18:00:59.949]                             hostname = base::Sys.info()[["nodename"]])
[18:00:59.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:00:59.949]                             info)
[18:00:59.949]                           info <- base::paste(info, collapse = "; ")
[18:00:59.949]                           if (!has_future) {
[18:00:59.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:00:59.949]                               info)
[18:00:59.949]                           }
[18:00:59.949]                           else {
[18:00:59.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:00:59.949]                               info, version)
[18:00:59.949]                           }
[18:00:59.949]                           base::stop(msg)
[18:00:59.949]                         }
[18:00:59.949]                       })
[18:00:59.949]                     }
[18:00:59.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:00:59.949]                     base::options(mc.cores = 1L)
[18:00:59.949]                   }
[18:00:59.949]                   ...future.strategy.old <- future::plan("list")
[18:00:59.949]                   options(future.plan = NULL)
[18:00:59.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:00:59.949]                 }
[18:00:59.949]                 ...future.workdir <- getwd()
[18:00:59.949]             }
[18:00:59.949]             ...future.oldOptions <- base::as.list(base::.Options)
[18:00:59.949]             ...future.oldEnvVars <- base::Sys.getenv()
[18:00:59.949]         }
[18:00:59.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:00:59.949]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:00:59.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:00:59.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:00:59.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:00:59.949]             future.stdout.windows.reencode = NULL, width = 80L)
[18:00:59.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:00:59.949]             base::names(...future.oldOptions))
[18:00:59.949]     }
[18:00:59.949]     if (FALSE) {
[18:00:59.949]     }
[18:00:59.949]     else {
[18:00:59.949]         if (TRUE) {
[18:00:59.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:00:59.949]                 open = "w")
[18:00:59.949]         }
[18:00:59.949]         else {
[18:00:59.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:00:59.949]                 windows = "NUL", "/dev/null"), open = "w")
[18:00:59.949]         }
[18:00:59.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:00:59.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:00:59.949]             base::sink(type = "output", split = FALSE)
[18:00:59.949]             base::close(...future.stdout)
[18:00:59.949]         }, add = TRUE)
[18:00:59.949]     }
[18:00:59.949]     ...future.frame <- base::sys.nframe()
[18:00:59.949]     ...future.conditions <- base::list()
[18:00:59.949]     ...future.rng <- base::globalenv()$.Random.seed
[18:00:59.949]     if (FALSE) {
[18:00:59.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:00:59.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:00:59.949]     }
[18:00:59.949]     ...future.result <- base::tryCatch({
[18:00:59.949]         base::withCallingHandlers({
[18:00:59.949]             ...future.value <- base::withVisible(base::local({
[18:00:59.949]                 withCallingHandlers({
[18:00:59.949]                   {
[18:00:59.949]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.949]                     if (!identical(...future.globals.maxSize.org, 
[18:00:59.949]                       ...future.globals.maxSize)) {
[18:00:59.949]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.949]                       on.exit(options(oopts), add = TRUE)
[18:00:59.949]                     }
[18:00:59.949]                     {
[18:00:59.949]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.949]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:00:59.949]                         USE.NAMES = FALSE)
[18:00:59.949]                       do.call(mapply, args = args)
[18:00:59.949]                     }
[18:00:59.949]                   }
[18:00:59.949]                 }, immediateCondition = function(cond) {
[18:00:59.949]                   save_rds <- function (object, pathname, ...) 
[18:00:59.949]                   {
[18:00:59.949]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:00:59.949]                     if (file_test("-f", pathname_tmp)) {
[18:00:59.949]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.949]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:00:59.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.949]                         fi_tmp[["mtime"]])
[18:00:59.949]                     }
[18:00:59.949]                     tryCatch({
[18:00:59.949]                       saveRDS(object, file = pathname_tmp, ...)
[18:00:59.949]                     }, error = function(ex) {
[18:00:59.949]                       msg <- conditionMessage(ex)
[18:00:59.949]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.949]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:00:59.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.949]                         fi_tmp[["mtime"]], msg)
[18:00:59.949]                       ex$message <- msg
[18:00:59.949]                       stop(ex)
[18:00:59.949]                     })
[18:00:59.949]                     stopifnot(file_test("-f", pathname_tmp))
[18:00:59.949]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:00:59.949]                     if (!res || file_test("-f", pathname_tmp)) {
[18:00:59.949]                       fi_tmp <- file.info(pathname_tmp)
[18:00:59.949]                       fi <- file.info(pathname)
[18:00:59.949]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:00:59.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:00:59.949]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:00:59.949]                         fi[["size"]], fi[["mtime"]])
[18:00:59.949]                       stop(msg)
[18:00:59.949]                     }
[18:00:59.949]                     invisible(pathname)
[18:00:59.949]                   }
[18:00:59.949]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:00:59.949]                     rootPath = tempdir()) 
[18:00:59.949]                   {
[18:00:59.949]                     obj <- list(time = Sys.time(), condition = cond)
[18:00:59.949]                     file <- tempfile(pattern = class(cond)[1], 
[18:00:59.949]                       tmpdir = path, fileext = ".rds")
[18:00:59.949]                     save_rds(obj, file)
[18:00:59.949]                   }
[18:00:59.949]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:00:59.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.949]                   {
[18:00:59.949]                     inherits <- base::inherits
[18:00:59.949]                     invokeRestart <- base::invokeRestart
[18:00:59.949]                     is.null <- base::is.null
[18:00:59.949]                     muffled <- FALSE
[18:00:59.949]                     if (inherits(cond, "message")) {
[18:00:59.949]                       muffled <- grepl(pattern, "muffleMessage")
[18:00:59.949]                       if (muffled) 
[18:00:59.949]                         invokeRestart("muffleMessage")
[18:00:59.949]                     }
[18:00:59.949]                     else if (inherits(cond, "warning")) {
[18:00:59.949]                       muffled <- grepl(pattern, "muffleWarning")
[18:00:59.949]                       if (muffled) 
[18:00:59.949]                         invokeRestart("muffleWarning")
[18:00:59.949]                     }
[18:00:59.949]                     else if (inherits(cond, "condition")) {
[18:00:59.949]                       if (!is.null(pattern)) {
[18:00:59.949]                         computeRestarts <- base::computeRestarts
[18:00:59.949]                         grepl <- base::grepl
[18:00:59.949]                         restarts <- computeRestarts(cond)
[18:00:59.949]                         for (restart in restarts) {
[18:00:59.949]                           name <- restart$name
[18:00:59.949]                           if (is.null(name)) 
[18:00:59.949]                             next
[18:00:59.949]                           if (!grepl(pattern, name)) 
[18:00:59.949]                             next
[18:00:59.949]                           invokeRestart(restart)
[18:00:59.949]                           muffled <- TRUE
[18:00:59.949]                           break
[18:00:59.949]                         }
[18:00:59.949]                       }
[18:00:59.949]                     }
[18:00:59.949]                     invisible(muffled)
[18:00:59.949]                   }
[18:00:59.949]                   muffleCondition(cond)
[18:00:59.949]                 })
[18:00:59.949]             }))
[18:00:59.949]             future::FutureResult(value = ...future.value$value, 
[18:00:59.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.949]                   ...future.rng), globalenv = if (FALSE) 
[18:00:59.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:00:59.949]                     ...future.globalenv.names))
[18:00:59.949]                 else NULL, started = ...future.startTime, version = "1.8")
[18:00:59.949]         }, condition = base::local({
[18:00:59.949]             c <- base::c
[18:00:59.949]             inherits <- base::inherits
[18:00:59.949]             invokeRestart <- base::invokeRestart
[18:00:59.949]             length <- base::length
[18:00:59.949]             list <- base::list
[18:00:59.949]             seq.int <- base::seq.int
[18:00:59.949]             signalCondition <- base::signalCondition
[18:00:59.949]             sys.calls <- base::sys.calls
[18:00:59.949]             `[[` <- base::`[[`
[18:00:59.949]             `+` <- base::`+`
[18:00:59.949]             `<<-` <- base::`<<-`
[18:00:59.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:00:59.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:00:59.949]                   3L)]
[18:00:59.949]             }
[18:00:59.949]             function(cond) {
[18:00:59.949]                 is_error <- inherits(cond, "error")
[18:00:59.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:00:59.949]                   NULL)
[18:00:59.949]                 if (is_error) {
[18:00:59.949]                   sessionInformation <- function() {
[18:00:59.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:00:59.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:00:59.949]                       search = base::search(), system = base::Sys.info())
[18:00:59.949]                   }
[18:00:59.949]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:00:59.949]                     cond$call), session = sessionInformation(), 
[18:00:59.949]                     timestamp = base::Sys.time(), signaled = 0L)
[18:00:59.949]                   signalCondition(cond)
[18:00:59.949]                 }
[18:00:59.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:00:59.949]                 "immediateCondition"))) {
[18:00:59.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:00:59.949]                   ...future.conditions[[length(...future.conditions) + 
[18:00:59.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:00:59.949]                   if (TRUE && !signal) {
[18:00:59.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.949]                     {
[18:00:59.949]                       inherits <- base::inherits
[18:00:59.949]                       invokeRestart <- base::invokeRestart
[18:00:59.949]                       is.null <- base::is.null
[18:00:59.949]                       muffled <- FALSE
[18:00:59.949]                       if (inherits(cond, "message")) {
[18:00:59.949]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.949]                         if (muffled) 
[18:00:59.949]                           invokeRestart("muffleMessage")
[18:00:59.949]                       }
[18:00:59.949]                       else if (inherits(cond, "warning")) {
[18:00:59.949]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.949]                         if (muffled) 
[18:00:59.949]                           invokeRestart("muffleWarning")
[18:00:59.949]                       }
[18:00:59.949]                       else if (inherits(cond, "condition")) {
[18:00:59.949]                         if (!is.null(pattern)) {
[18:00:59.949]                           computeRestarts <- base::computeRestarts
[18:00:59.949]                           grepl <- base::grepl
[18:00:59.949]                           restarts <- computeRestarts(cond)
[18:00:59.949]                           for (restart in restarts) {
[18:00:59.949]                             name <- restart$name
[18:00:59.949]                             if (is.null(name)) 
[18:00:59.949]                               next
[18:00:59.949]                             if (!grepl(pattern, name)) 
[18:00:59.949]                               next
[18:00:59.949]                             invokeRestart(restart)
[18:00:59.949]                             muffled <- TRUE
[18:00:59.949]                             break
[18:00:59.949]                           }
[18:00:59.949]                         }
[18:00:59.949]                       }
[18:00:59.949]                       invisible(muffled)
[18:00:59.949]                     }
[18:00:59.949]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.949]                   }
[18:00:59.949]                 }
[18:00:59.949]                 else {
[18:00:59.949]                   if (TRUE) {
[18:00:59.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:00:59.949]                     {
[18:00:59.949]                       inherits <- base::inherits
[18:00:59.949]                       invokeRestart <- base::invokeRestart
[18:00:59.949]                       is.null <- base::is.null
[18:00:59.949]                       muffled <- FALSE
[18:00:59.949]                       if (inherits(cond, "message")) {
[18:00:59.949]                         muffled <- grepl(pattern, "muffleMessage")
[18:00:59.949]                         if (muffled) 
[18:00:59.949]                           invokeRestart("muffleMessage")
[18:00:59.949]                       }
[18:00:59.949]                       else if (inherits(cond, "warning")) {
[18:00:59.949]                         muffled <- grepl(pattern, "muffleWarning")
[18:00:59.949]                         if (muffled) 
[18:00:59.949]                           invokeRestart("muffleWarning")
[18:00:59.949]                       }
[18:00:59.949]                       else if (inherits(cond, "condition")) {
[18:00:59.949]                         if (!is.null(pattern)) {
[18:00:59.949]                           computeRestarts <- base::computeRestarts
[18:00:59.949]                           grepl <- base::grepl
[18:00:59.949]                           restarts <- computeRestarts(cond)
[18:00:59.949]                           for (restart in restarts) {
[18:00:59.949]                             name <- restart$name
[18:00:59.949]                             if (is.null(name)) 
[18:00:59.949]                               next
[18:00:59.949]                             if (!grepl(pattern, name)) 
[18:00:59.949]                               next
[18:00:59.949]                             invokeRestart(restart)
[18:00:59.949]                             muffled <- TRUE
[18:00:59.949]                             break
[18:00:59.949]                           }
[18:00:59.949]                         }
[18:00:59.949]                       }
[18:00:59.949]                       invisible(muffled)
[18:00:59.949]                     }
[18:00:59.949]                     muffleCondition(cond, pattern = "^muffle")
[18:00:59.949]                   }
[18:00:59.949]                 }
[18:00:59.949]             }
[18:00:59.949]         }))
[18:00:59.949]     }, error = function(ex) {
[18:00:59.949]         base::structure(base::list(value = NULL, visible = NULL, 
[18:00:59.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:00:59.949]                 ...future.rng), started = ...future.startTime, 
[18:00:59.949]             finished = Sys.time(), session_uuid = NA_character_, 
[18:00:59.949]             version = "1.8"), class = "FutureResult")
[18:00:59.949]     }, finally = {
[18:00:59.949]         if (!identical(...future.workdir, getwd())) 
[18:00:59.949]             setwd(...future.workdir)
[18:00:59.949]         {
[18:00:59.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:00:59.949]                 ...future.oldOptions$nwarnings <- NULL
[18:00:59.949]             }
[18:00:59.949]             base::options(...future.oldOptions)
[18:00:59.949]             if (.Platform$OS.type == "windows") {
[18:00:59.949]                 old_names <- names(...future.oldEnvVars)
[18:00:59.949]                 envs <- base::Sys.getenv()
[18:00:59.949]                 names <- names(envs)
[18:00:59.949]                 common <- intersect(names, old_names)
[18:00:59.949]                 added <- setdiff(names, old_names)
[18:00:59.949]                 removed <- setdiff(old_names, names)
[18:00:59.949]                 changed <- common[...future.oldEnvVars[common] != 
[18:00:59.949]                   envs[common]]
[18:00:59.949]                 NAMES <- toupper(changed)
[18:00:59.949]                 args <- list()
[18:00:59.949]                 for (kk in seq_along(NAMES)) {
[18:00:59.949]                   name <- changed[[kk]]
[18:00:59.949]                   NAME <- NAMES[[kk]]
[18:00:59.949]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.949]                     next
[18:00:59.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.949]                 }
[18:00:59.949]                 NAMES <- toupper(added)
[18:00:59.949]                 for (kk in seq_along(NAMES)) {
[18:00:59.949]                   name <- added[[kk]]
[18:00:59.949]                   NAME <- NAMES[[kk]]
[18:00:59.949]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.949]                     next
[18:00:59.949]                   args[[name]] <- ""
[18:00:59.949]                 }
[18:00:59.949]                 NAMES <- toupper(removed)
[18:00:59.949]                 for (kk in seq_along(NAMES)) {
[18:00:59.949]                   name <- removed[[kk]]
[18:00:59.949]                   NAME <- NAMES[[kk]]
[18:00:59.949]                   if (name != NAME && is.element(NAME, old_names)) 
[18:00:59.949]                     next
[18:00:59.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:00:59.949]                 }
[18:00:59.949]                 if (length(args) > 0) 
[18:00:59.949]                   base::do.call(base::Sys.setenv, args = args)
[18:00:59.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:00:59.949]             }
[18:00:59.949]             else {
[18:00:59.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:00:59.949]             }
[18:00:59.949]             {
[18:00:59.949]                 if (base::length(...future.futureOptionsAdded) > 
[18:00:59.949]                   0L) {
[18:00:59.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:00:59.949]                   base::names(opts) <- ...future.futureOptionsAdded
[18:00:59.949]                   base::options(opts)
[18:00:59.949]                 }
[18:00:59.949]                 {
[18:00:59.949]                   {
[18:00:59.949]                     base::options(mc.cores = ...future.mc.cores.old)
[18:00:59.949]                     NULL
[18:00:59.949]                   }
[18:00:59.949]                   options(future.plan = NULL)
[18:00:59.949]                   if (is.na(NA_character_)) 
[18:00:59.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:00:59.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:00:59.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:00:59.949]                     .init = FALSE)
[18:00:59.949]                 }
[18:00:59.949]             }
[18:00:59.949]         }
[18:00:59.949]     })
[18:00:59.949]     if (TRUE) {
[18:00:59.949]         base::sink(type = "output", split = FALSE)
[18:00:59.949]         if (TRUE) {
[18:00:59.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:00:59.949]         }
[18:00:59.949]         else {
[18:00:59.949]             ...future.result["stdout"] <- base::list(NULL)
[18:00:59.949]         }
[18:00:59.949]         base::close(...future.stdout)
[18:00:59.949]         ...future.stdout <- NULL
[18:00:59.949]     }
[18:00:59.949]     ...future.result$conditions <- ...future.conditions
[18:00:59.949]     ...future.result$finished <- base::Sys.time()
[18:00:59.949]     ...future.result
[18:00:59.949] }
[18:00:59.954] assign_globals() ...
[18:00:59.954] List of 5
[18:00:59.954]  $ ...future.FUN            :function (x, y)  
[18:00:59.954]  $ MoreArgs                 : NULL
[18:00:59.954]  $ ...future.elements_ii    :List of 2
[18:00:59.954]   ..$ :List of 1
[18:00:59.954]   .. ..$ a: num 1
[18:00:59.954]   ..$ :List of 1
[18:00:59.954]   .. ..$ A: num 10
[18:00:59.954]  $ ...future.seeds_ii       : NULL
[18:00:59.954]  $ ...future.globals.maxSize: NULL
[18:00:59.954]  - attr(*, "where")=List of 5
[18:00:59.954]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:00:59.954]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:00:59.954]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:00:59.954]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:00:59.954]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:00:59.954]  - attr(*, "resolved")= logi FALSE
[18:00:59.954]  - attr(*, "total_size")= num 2088
[18:00:59.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:00:59.954]  - attr(*, "already-done")= logi TRUE
[18:00:59.964] - reassign environment for ‘...future.FUN’
[18:00:59.964] - copied ‘...future.FUN’ to environment
[18:00:59.965] - copied ‘MoreArgs’ to environment
[18:00:59.965] - copied ‘...future.elements_ii’ to environment
[18:00:59.965] - copied ‘...future.seeds_ii’ to environment
[18:00:59.965] - copied ‘...future.globals.maxSize’ to environment
[18:00:59.965] assign_globals() ... done
[18:00:59.966] requestCore(): workers = 2
[18:00:59.969] MulticoreFuture started
[18:00:59.970] - Launch lazy future ... done
[18:00:59.970] run() for ‘MulticoreFuture’ ... done
[18:00:59.971] Created future:
[18:00:59.971] plan(): Setting new future strategy stack:
[18:00:59.972] List of future strategies:
[18:00:59.972] 1. sequential:
[18:00:59.972]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:00:59.972]    - tweaked: FALSE
[18:00:59.972]    - call: NULL
[18:00:59.973] plan(): nbrOfWorkers() = 1
[18:00:59.978] plan(): Setting new future strategy stack:
[18:00:59.978] List of future strategies:
[18:00:59.978] 1. multicore:
[18:00:59.978]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:00:59.978]    - tweaked: FALSE
[18:00:59.978]    - call: plan(strategy)
[18:00:59.971] MulticoreFuture:
[18:00:59.971] Label: ‘future_mapply-1’
[18:00:59.971] Expression:
[18:00:59.971] {
[18:00:59.971]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:00:59.971]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:00:59.971]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:00:59.971]         on.exit(options(oopts), add = TRUE)
[18:00:59.971]     }
[18:00:59.971]     {
[18:00:59.971]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:00:59.971]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:00:59.971]         do.call(mapply, args = args)
[18:00:59.971]     }
[18:00:59.971] }
[18:00:59.971] Lazy evaluation: FALSE
[18:00:59.971] Asynchronous evaluation: TRUE
[18:00:59.971] Local evaluation: TRUE
[18:00:59.971] Environment: R_GlobalEnv
[18:00:59.971] Capture standard output: TRUE
[18:00:59.971] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:00:59.971] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:00:59.971] Packages: <none>
[18:00:59.971] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:00:59.971] Resolved: FALSE
[18:00:59.971] Value: <not collected>
[18:00:59.971] Conditions captured: <none>
[18:00:59.971] Early signaling: FALSE
[18:00:59.971] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:00:59.971] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:00:59.986] Chunk #1 of 2 ... DONE
[18:00:59.987] Chunk #2 of 2 ...
[18:00:59.987]  - Finding globals in '...' for chunk #2 ...
[18:00:59.987] getGlobalsAndPackages() ...
[18:00:59.988] Searching for globals...
[18:00:59.988] plan(): nbrOfWorkers() = 2
[18:00:59.989] 
[18:00:59.989] Searching for globals ... DONE
[18:00:59.989] - globals: [0] <none>
[18:00:59.990] getGlobalsAndPackages() ... DONE
[18:00:59.990]    + additional globals found: [n=0] 
[18:00:59.990]    + additional namespaces needed: [n=0] 
[18:00:59.991]  - Finding globals in '...' for chunk #2 ... DONE
[18:00:59.991]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:00:59.991]  - seeds: <none>
[18:00:59.991]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.992] getGlobalsAndPackages() ...
[18:00:59.992] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.992] Resolving globals: FALSE
[18:00:59.994] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[18:00:59.996] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:00:59.996] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:00:59.997] 
[18:00:59.997] getGlobalsAndPackages() ... DONE
[18:00:59.998] run() for ‘Future’ ...
[18:00:59.999] - state: ‘created’
[18:00:59.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.009] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.010] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.010]   - Field: ‘label’
[18:01:00.011]   - Field: ‘local’
[18:01:00.011]   - Field: ‘owner’
[18:01:00.011]   - Field: ‘envir’
[18:01:00.012]   - Field: ‘workers’
[18:01:00.012]   - Field: ‘packages’
[18:01:00.012]   - Field: ‘gc’
[18:01:00.013]   - Field: ‘job’
[18:01:00.013]   - Field: ‘conditions’
[18:01:00.013]   - Field: ‘expr’
[18:01:00.014]   - Field: ‘uuid’
[18:01:00.014]   - Field: ‘seed’
[18:01:00.014]   - Field: ‘version’
[18:01:00.015]   - Field: ‘result’
[18:01:00.015]   - Field: ‘asynchronous’
[18:01:00.015]   - Field: ‘calls’
[18:01:00.016]   - Field: ‘globals’
[18:01:00.016]   - Field: ‘stdout’
[18:01:00.017]   - Field: ‘earlySignal’
[18:01:00.017]   - Field: ‘lazy’
[18:01:00.017]   - Field: ‘state’
[18:01:00.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.018] - Launch lazy future ...
[18:01:00.019] Packages needed by the future expression (n = 0): <none>
[18:01:00.020] Packages needed by future strategies (n = 0): <none>
[18:01:00.026] {
[18:01:00.026]     {
[18:01:00.026]         {
[18:01:00.026]             ...future.startTime <- base::Sys.time()
[18:01:00.026]             {
[18:01:00.026]                 {
[18:01:00.026]                   {
[18:01:00.026]                     {
[18:01:00.026]                       base::local({
[18:01:00.026]                         has_future <- base::requireNamespace("future", 
[18:01:00.026]                           quietly = TRUE)
[18:01:00.026]                         if (has_future) {
[18:01:00.026]                           ns <- base::getNamespace("future")
[18:01:00.026]                           version <- ns[[".package"]][["version"]]
[18:01:00.026]                           if (is.null(version)) 
[18:01:00.026]                             version <- utils::packageVersion("future")
[18:01:00.026]                         }
[18:01:00.026]                         else {
[18:01:00.026]                           version <- NULL
[18:01:00.026]                         }
[18:01:00.026]                         if (!has_future || version < "1.8.0") {
[18:01:00.026]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.026]                             "", base::R.version$version.string), 
[18:01:00.026]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.026]                               "release", "version")], collapse = " "), 
[18:01:00.026]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.026]                             info)
[18:01:00.026]                           info <- base::paste(info, collapse = "; ")
[18:01:00.026]                           if (!has_future) {
[18:01:00.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.026]                               info)
[18:01:00.026]                           }
[18:01:00.026]                           else {
[18:01:00.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.026]                               info, version)
[18:01:00.026]                           }
[18:01:00.026]                           base::stop(msg)
[18:01:00.026]                         }
[18:01:00.026]                       })
[18:01:00.026]                     }
[18:01:00.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.026]                     base::options(mc.cores = 1L)
[18:01:00.026]                   }
[18:01:00.026]                   ...future.strategy.old <- future::plan("list")
[18:01:00.026]                   options(future.plan = NULL)
[18:01:00.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.026]                 }
[18:01:00.026]                 ...future.workdir <- getwd()
[18:01:00.026]             }
[18:01:00.026]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.026]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.026]         }
[18:01:00.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.026]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:00.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.026]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.026]             base::names(...future.oldOptions))
[18:01:00.026]     }
[18:01:00.026]     if (FALSE) {
[18:01:00.026]     }
[18:01:00.026]     else {
[18:01:00.026]         if (TRUE) {
[18:01:00.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.026]                 open = "w")
[18:01:00.026]         }
[18:01:00.026]         else {
[18:01:00.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.026]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.026]         }
[18:01:00.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.026]             base::sink(type = "output", split = FALSE)
[18:01:00.026]             base::close(...future.stdout)
[18:01:00.026]         }, add = TRUE)
[18:01:00.026]     }
[18:01:00.026]     ...future.frame <- base::sys.nframe()
[18:01:00.026]     ...future.conditions <- base::list()
[18:01:00.026]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.026]     if (FALSE) {
[18:01:00.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.026]     }
[18:01:00.026]     ...future.result <- base::tryCatch({
[18:01:00.026]         base::withCallingHandlers({
[18:01:00.026]             ...future.value <- base::withVisible(base::local({
[18:01:00.026]                 withCallingHandlers({
[18:01:00.026]                   {
[18:01:00.026]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.026]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.026]                       ...future.globals.maxSize)) {
[18:01:00.026]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.026]                       on.exit(options(oopts), add = TRUE)
[18:01:00.026]                     }
[18:01:00.026]                     {
[18:01:00.026]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.026]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.026]                         USE.NAMES = FALSE)
[18:01:00.026]                       do.call(mapply, args = args)
[18:01:00.026]                     }
[18:01:00.026]                   }
[18:01:00.026]                 }, immediateCondition = function(cond) {
[18:01:00.026]                   save_rds <- function (object, pathname, ...) 
[18:01:00.026]                   {
[18:01:00.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.026]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.026]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.026]                         fi_tmp[["mtime"]])
[18:01:00.026]                     }
[18:01:00.026]                     tryCatch({
[18:01:00.026]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.026]                     }, error = function(ex) {
[18:01:00.026]                       msg <- conditionMessage(ex)
[18:01:00.026]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.026]                         fi_tmp[["mtime"]], msg)
[18:01:00.026]                       ex$message <- msg
[18:01:00.026]                       stop(ex)
[18:01:00.026]                     })
[18:01:00.026]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.026]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.026]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.026]                       fi <- file.info(pathname)
[18:01:00.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.026]                         fi[["size"]], fi[["mtime"]])
[18:01:00.026]                       stop(msg)
[18:01:00.026]                     }
[18:01:00.026]                     invisible(pathname)
[18:01:00.026]                   }
[18:01:00.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.026]                     rootPath = tempdir()) 
[18:01:00.026]                   {
[18:01:00.026]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.026]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.026]                       tmpdir = path, fileext = ".rds")
[18:01:00.026]                     save_rds(obj, file)
[18:01:00.026]                   }
[18:01:00.026]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.026]                   {
[18:01:00.026]                     inherits <- base::inherits
[18:01:00.026]                     invokeRestart <- base::invokeRestart
[18:01:00.026]                     is.null <- base::is.null
[18:01:00.026]                     muffled <- FALSE
[18:01:00.026]                     if (inherits(cond, "message")) {
[18:01:00.026]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.026]                       if (muffled) 
[18:01:00.026]                         invokeRestart("muffleMessage")
[18:01:00.026]                     }
[18:01:00.026]                     else if (inherits(cond, "warning")) {
[18:01:00.026]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.026]                       if (muffled) 
[18:01:00.026]                         invokeRestart("muffleWarning")
[18:01:00.026]                     }
[18:01:00.026]                     else if (inherits(cond, "condition")) {
[18:01:00.026]                       if (!is.null(pattern)) {
[18:01:00.026]                         computeRestarts <- base::computeRestarts
[18:01:00.026]                         grepl <- base::grepl
[18:01:00.026]                         restarts <- computeRestarts(cond)
[18:01:00.026]                         for (restart in restarts) {
[18:01:00.026]                           name <- restart$name
[18:01:00.026]                           if (is.null(name)) 
[18:01:00.026]                             next
[18:01:00.026]                           if (!grepl(pattern, name)) 
[18:01:00.026]                             next
[18:01:00.026]                           invokeRestart(restart)
[18:01:00.026]                           muffled <- TRUE
[18:01:00.026]                           break
[18:01:00.026]                         }
[18:01:00.026]                       }
[18:01:00.026]                     }
[18:01:00.026]                     invisible(muffled)
[18:01:00.026]                   }
[18:01:00.026]                   muffleCondition(cond)
[18:01:00.026]                 })
[18:01:00.026]             }))
[18:01:00.026]             future::FutureResult(value = ...future.value$value, 
[18:01:00.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.026]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.026]                     ...future.globalenv.names))
[18:01:00.026]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.026]         }, condition = base::local({
[18:01:00.026]             c <- base::c
[18:01:00.026]             inherits <- base::inherits
[18:01:00.026]             invokeRestart <- base::invokeRestart
[18:01:00.026]             length <- base::length
[18:01:00.026]             list <- base::list
[18:01:00.026]             seq.int <- base::seq.int
[18:01:00.026]             signalCondition <- base::signalCondition
[18:01:00.026]             sys.calls <- base::sys.calls
[18:01:00.026]             `[[` <- base::`[[`
[18:01:00.026]             `+` <- base::`+`
[18:01:00.026]             `<<-` <- base::`<<-`
[18:01:00.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.026]                   3L)]
[18:01:00.026]             }
[18:01:00.026]             function(cond) {
[18:01:00.026]                 is_error <- inherits(cond, "error")
[18:01:00.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.026]                   NULL)
[18:01:00.026]                 if (is_error) {
[18:01:00.026]                   sessionInformation <- function() {
[18:01:00.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.026]                       search = base::search(), system = base::Sys.info())
[18:01:00.026]                   }
[18:01:00.026]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.026]                     cond$call), session = sessionInformation(), 
[18:01:00.026]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.026]                   signalCondition(cond)
[18:01:00.026]                 }
[18:01:00.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.026]                 "immediateCondition"))) {
[18:01:00.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.026]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.026]                   if (TRUE && !signal) {
[18:01:00.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.026]                     {
[18:01:00.026]                       inherits <- base::inherits
[18:01:00.026]                       invokeRestart <- base::invokeRestart
[18:01:00.026]                       is.null <- base::is.null
[18:01:00.026]                       muffled <- FALSE
[18:01:00.026]                       if (inherits(cond, "message")) {
[18:01:00.026]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.026]                         if (muffled) 
[18:01:00.026]                           invokeRestart("muffleMessage")
[18:01:00.026]                       }
[18:01:00.026]                       else if (inherits(cond, "warning")) {
[18:01:00.026]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.026]                         if (muffled) 
[18:01:00.026]                           invokeRestart("muffleWarning")
[18:01:00.026]                       }
[18:01:00.026]                       else if (inherits(cond, "condition")) {
[18:01:00.026]                         if (!is.null(pattern)) {
[18:01:00.026]                           computeRestarts <- base::computeRestarts
[18:01:00.026]                           grepl <- base::grepl
[18:01:00.026]                           restarts <- computeRestarts(cond)
[18:01:00.026]                           for (restart in restarts) {
[18:01:00.026]                             name <- restart$name
[18:01:00.026]                             if (is.null(name)) 
[18:01:00.026]                               next
[18:01:00.026]                             if (!grepl(pattern, name)) 
[18:01:00.026]                               next
[18:01:00.026]                             invokeRestart(restart)
[18:01:00.026]                             muffled <- TRUE
[18:01:00.026]                             break
[18:01:00.026]                           }
[18:01:00.026]                         }
[18:01:00.026]                       }
[18:01:00.026]                       invisible(muffled)
[18:01:00.026]                     }
[18:01:00.026]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.026]                   }
[18:01:00.026]                 }
[18:01:00.026]                 else {
[18:01:00.026]                   if (TRUE) {
[18:01:00.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.026]                     {
[18:01:00.026]                       inherits <- base::inherits
[18:01:00.026]                       invokeRestart <- base::invokeRestart
[18:01:00.026]                       is.null <- base::is.null
[18:01:00.026]                       muffled <- FALSE
[18:01:00.026]                       if (inherits(cond, "message")) {
[18:01:00.026]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.026]                         if (muffled) 
[18:01:00.026]                           invokeRestart("muffleMessage")
[18:01:00.026]                       }
[18:01:00.026]                       else if (inherits(cond, "warning")) {
[18:01:00.026]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.026]                         if (muffled) 
[18:01:00.026]                           invokeRestart("muffleWarning")
[18:01:00.026]                       }
[18:01:00.026]                       else if (inherits(cond, "condition")) {
[18:01:00.026]                         if (!is.null(pattern)) {
[18:01:00.026]                           computeRestarts <- base::computeRestarts
[18:01:00.026]                           grepl <- base::grepl
[18:01:00.026]                           restarts <- computeRestarts(cond)
[18:01:00.026]                           for (restart in restarts) {
[18:01:00.026]                             name <- restart$name
[18:01:00.026]                             if (is.null(name)) 
[18:01:00.026]                               next
[18:01:00.026]                             if (!grepl(pattern, name)) 
[18:01:00.026]                               next
[18:01:00.026]                             invokeRestart(restart)
[18:01:00.026]                             muffled <- TRUE
[18:01:00.026]                             break
[18:01:00.026]                           }
[18:01:00.026]                         }
[18:01:00.026]                       }
[18:01:00.026]                       invisible(muffled)
[18:01:00.026]                     }
[18:01:00.026]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.026]                   }
[18:01:00.026]                 }
[18:01:00.026]             }
[18:01:00.026]         }))
[18:01:00.026]     }, error = function(ex) {
[18:01:00.026]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.026]                 ...future.rng), started = ...future.startTime, 
[18:01:00.026]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.026]             version = "1.8"), class = "FutureResult")
[18:01:00.026]     }, finally = {
[18:01:00.026]         if (!identical(...future.workdir, getwd())) 
[18:01:00.026]             setwd(...future.workdir)
[18:01:00.026]         {
[18:01:00.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.026]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.026]             }
[18:01:00.026]             base::options(...future.oldOptions)
[18:01:00.026]             if (.Platform$OS.type == "windows") {
[18:01:00.026]                 old_names <- names(...future.oldEnvVars)
[18:01:00.026]                 envs <- base::Sys.getenv()
[18:01:00.026]                 names <- names(envs)
[18:01:00.026]                 common <- intersect(names, old_names)
[18:01:00.026]                 added <- setdiff(names, old_names)
[18:01:00.026]                 removed <- setdiff(old_names, names)
[18:01:00.026]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.026]                   envs[common]]
[18:01:00.026]                 NAMES <- toupper(changed)
[18:01:00.026]                 args <- list()
[18:01:00.026]                 for (kk in seq_along(NAMES)) {
[18:01:00.026]                   name <- changed[[kk]]
[18:01:00.026]                   NAME <- NAMES[[kk]]
[18:01:00.026]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.026]                     next
[18:01:00.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.026]                 }
[18:01:00.026]                 NAMES <- toupper(added)
[18:01:00.026]                 for (kk in seq_along(NAMES)) {
[18:01:00.026]                   name <- added[[kk]]
[18:01:00.026]                   NAME <- NAMES[[kk]]
[18:01:00.026]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.026]                     next
[18:01:00.026]                   args[[name]] <- ""
[18:01:00.026]                 }
[18:01:00.026]                 NAMES <- toupper(removed)
[18:01:00.026]                 for (kk in seq_along(NAMES)) {
[18:01:00.026]                   name <- removed[[kk]]
[18:01:00.026]                   NAME <- NAMES[[kk]]
[18:01:00.026]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.026]                     next
[18:01:00.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.026]                 }
[18:01:00.026]                 if (length(args) > 0) 
[18:01:00.026]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.026]             }
[18:01:00.026]             else {
[18:01:00.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.026]             }
[18:01:00.026]             {
[18:01:00.026]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.026]                   0L) {
[18:01:00.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.026]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.026]                   base::options(opts)
[18:01:00.026]                 }
[18:01:00.026]                 {
[18:01:00.026]                   {
[18:01:00.026]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.026]                     NULL
[18:01:00.026]                   }
[18:01:00.026]                   options(future.plan = NULL)
[18:01:00.026]                   if (is.na(NA_character_)) 
[18:01:00.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.026]                     .init = FALSE)
[18:01:00.026]                 }
[18:01:00.026]             }
[18:01:00.026]         }
[18:01:00.026]     })
[18:01:00.026]     if (TRUE) {
[18:01:00.026]         base::sink(type = "output", split = FALSE)
[18:01:00.026]         if (TRUE) {
[18:01:00.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.026]         }
[18:01:00.026]         else {
[18:01:00.026]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.026]         }
[18:01:00.026]         base::close(...future.stdout)
[18:01:00.026]         ...future.stdout <- NULL
[18:01:00.026]     }
[18:01:00.026]     ...future.result$conditions <- ...future.conditions
[18:01:00.026]     ...future.result$finished <- base::Sys.time()
[18:01:00.026]     ...future.result
[18:01:00.026] }
[18:01:00.033] assign_globals() ...
[18:01:00.033] List of 5
[18:01:00.033]  $ ...future.FUN            :function (x, y)  
[18:01:00.033]  $ MoreArgs                 : NULL
[18:01:00.033]  $ ...future.elements_ii    :List of 2
[18:01:00.033]   ..$ :List of 2
[18:01:00.033]   .. ..$ b: num 2
[18:01:00.033]   .. ..$ c: num 3
[18:01:00.033]   ..$ :List of 2
[18:01:00.033]   .. ..$ B: num 0
[18:01:00.033]   .. ..$ C: num -10
[18:01:00.033]  $ ...future.seeds_ii       : NULL
[18:01:00.033]  $ ...future.globals.maxSize: NULL
[18:01:00.033]  - attr(*, "where")=List of 5
[18:01:00.033]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.033]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.033]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.033]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.033]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.033]  - attr(*, "resolved")= logi FALSE
[18:01:00.033]  - attr(*, "total_size")= num 2200
[18:01:00.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.033]  - attr(*, "already-done")= logi TRUE
[18:01:00.054] - reassign environment for ‘...future.FUN’
[18:01:00.055] - copied ‘...future.FUN’ to environment
[18:01:00.055] - copied ‘MoreArgs’ to environment
[18:01:00.055] - copied ‘...future.elements_ii’ to environment
[18:01:00.056] - copied ‘...future.seeds_ii’ to environment
[18:01:00.056] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.056] assign_globals() ... done
[18:01:00.057] requestCore(): workers = 2
[18:01:00.061] MulticoreFuture started
[18:01:00.061] - Launch lazy future ... done
[18:01:00.062] run() for ‘MulticoreFuture’ ... done
[18:01:00.063] Created future:
[18:01:00.063] plan(): Setting new future strategy stack:
[18:01:00.063] List of future strategies:
[18:01:00.063] 1. sequential:
[18:01:00.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.063]    - tweaked: FALSE
[18:01:00.063]    - call: NULL
[18:01:00.067] plan(): nbrOfWorkers() = 1
[18:01:00.072] plan(): Setting new future strategy stack:
[18:01:00.073] List of future strategies:
[18:01:00.073] 1. multicore:
[18:01:00.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.073]    - tweaked: FALSE
[18:01:00.073]    - call: plan(strategy)
[18:01:00.063] MulticoreFuture:
[18:01:00.063] Label: ‘future_mapply-2’
[18:01:00.063] Expression:
[18:01:00.063] {
[18:01:00.063]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.063]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.063]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.063]         on.exit(options(oopts), add = TRUE)
[18:01:00.063]     }
[18:01:00.063]     {
[18:01:00.063]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.063]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.063]         do.call(mapply, args = args)
[18:01:00.063]     }
[18:01:00.063] }
[18:01:00.063] Lazy evaluation: FALSE
[18:01:00.063] Asynchronous evaluation: TRUE
[18:01:00.063] Local evaluation: TRUE
[18:01:00.063] Environment: R_GlobalEnv
[18:01:00.063] Capture standard output: TRUE
[18:01:00.063] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.063] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.063] Packages: <none>
[18:01:00.063] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.063] Resolved: FALSE
[18:01:00.063] Value: <not collected>
[18:01:00.063] Conditions captured: <none>
[18:01:00.063] Early signaling: FALSE
[18:01:00.063] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.063] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.079] Chunk #2 of 2 ... DONE
[18:01:00.079] Launching 2 futures (chunks) ... DONE
[18:01:00.079] Resolving 2 futures (chunks) ...
[18:01:00.081] resolve() on list ...
[18:01:00.081]  recursive: 0
[18:01:00.082]  length: 2
[18:01:00.082] 
[18:01:00.083] Future #1
[18:01:00.083] result() for MulticoreFuture ...
[18:01:00.085] result() for MulticoreFuture ...
[18:01:00.085] result() for MulticoreFuture ... done
[18:01:00.086] result() for MulticoreFuture ... done
[18:01:00.086] result() for MulticoreFuture ...
[18:01:00.086] result() for MulticoreFuture ... done
[18:01:00.087] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:00.087] - nx: 2
[18:01:00.087] - relay: TRUE
[18:01:00.087] - stdout: TRUE
[18:01:00.088] - signal: TRUE
[18:01:00.088] - resignal: FALSE
[18:01:00.088] - force: TRUE
[18:01:00.089] - relayed: [n=2] FALSE, FALSE
[18:01:00.089] - queued futures: [n=2] FALSE, FALSE
[18:01:00.089]  - until=1
[18:01:00.088] plan(): nbrOfWorkers() = 2
[18:01:00.090]  - relaying element #1
[18:01:00.090] result() for MulticoreFuture ...
[18:01:00.090] result() for MulticoreFuture ... done
[18:01:00.091] result() for MulticoreFuture ...
[18:01:00.091] result() for MulticoreFuture ... done
[18:01:00.092] result() for MulticoreFuture ...
[18:01:00.092] result() for MulticoreFuture ... done
[18:01:00.092] result() for MulticoreFuture ...
[18:01:00.093] result() for MulticoreFuture ... done
[18:01:00.093] - relayed: [n=2] TRUE, FALSE
[18:01:00.093] - queued futures: [n=2] TRUE, FALSE
[18:01:00.094] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:00.094]  length: 1 (resolved future 1)
[18:01:00.095] Future #2
[18:01:00.095] result() for MulticoreFuture ...
[18:01:00.097] result() for MulticoreFuture ...
[18:01:00.097] result() for MulticoreFuture ... done
[18:01:00.097] result() for MulticoreFuture ... done
[18:01:00.098] result() for MulticoreFuture ...
[18:01:00.098] result() for MulticoreFuture ... done
[18:01:00.098] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:00.099] - nx: 2
[18:01:00.099] - relay: TRUE
[18:01:00.099] - stdout: TRUE
[18:01:00.099] - signal: TRUE
[18:01:00.100] - resignal: FALSE
[18:01:00.100] - force: TRUE
[18:01:00.100] - relayed: [n=2] TRUE, FALSE
[18:01:00.100] - queued futures: [n=2] TRUE, FALSE
[18:01:00.101]  - until=2
[18:01:00.101]  - relaying element #2
[18:01:00.101] result() for MulticoreFuture ...
[18:01:00.102] result() for MulticoreFuture ... done
[18:01:00.102] result() for MulticoreFuture ...
[18:01:00.102] result() for MulticoreFuture ... done
[18:01:00.103] result() for MulticoreFuture ...
[18:01:00.103] result() for MulticoreFuture ... done
[18:01:00.103] result() for MulticoreFuture ...
[18:01:00.103] result() for MulticoreFuture ... done
[18:01:00.104] - relayed: [n=2] TRUE, TRUE
[18:01:00.104] - queued futures: [n=2] TRUE, TRUE
[18:01:00.104] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:00.104]  length: 0 (resolved future 2)
[18:01:00.105] Relaying remaining futures
[18:01:00.105] signalConditionsASAP(NULL, pos=0) ...
[18:01:00.105] - nx: 2
[18:01:00.105] - relay: TRUE
[18:01:00.105] - stdout: TRUE
[18:01:00.106] - signal: TRUE
[18:01:00.106] - resignal: FALSE
[18:01:00.106] - force: TRUE
[18:01:00.106] - relayed: [n=2] TRUE, TRUE
[18:01:00.106] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:00.107] - relayed: [n=2] TRUE, TRUE
[18:01:00.107] - queued futures: [n=2] TRUE, TRUE
[18:01:00.107] signalConditionsASAP(NULL, pos=0) ... done
[18:01:00.108] resolve() on list ... DONE
[18:01:00.108] result() for MulticoreFuture ...
[18:01:00.108] result() for MulticoreFuture ... done
[18:01:00.108] result() for MulticoreFuture ...
[18:01:00.109] result() for MulticoreFuture ... done
[18:01:00.109] result() for MulticoreFuture ...
[18:01:00.109] result() for MulticoreFuture ... done
[18:01:00.109] result() for MulticoreFuture ...
[18:01:00.110] result() for MulticoreFuture ... done
[18:01:00.110]  - Number of value chunks collected: 2
[18:01:00.111] Resolving 2 futures (chunks) ... DONE
[18:01:00.111] Reducing values from 2 chunks ...
[18:01:00.111]  - Number of values collected after concatenation: 3
[18:01:00.112]  - Number of values expected: 3
[18:01:00.112] Reducing values from 2 chunks ... DONE
[18:01:00.112] future_mapply() ... DONE
- future_.mapply()
[18:01:00.113] future_mapply() ...
[18:01:00.124] Number of chunks: 2
[18:01:00.124] getGlobalsAndPackagesXApply() ...
[18:01:00.124]  - future.globals: TRUE
[18:01:00.124] getGlobalsAndPackages() ...
[18:01:00.125] Searching for globals...
[18:01:00.128] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[18:01:00.129] Searching for globals ... DONE
[18:01:00.129] Resolving globals: FALSE
[18:01:00.130] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[18:01:00.131] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[18:01:00.131] - globals: [1] ‘FUN’
[18:01:00.131] 
[18:01:00.131] getGlobalsAndPackages() ... DONE
[18:01:00.132]  - globals found/used: [n=1] ‘FUN’
[18:01:00.132]  - needed namespaces: [n=0] 
[18:01:00.132] Finding globals ... DONE
[18:01:00.132] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:00.133] List of 2
[18:01:00.133]  $ ...future.FUN:function (x, y)  
[18:01:00.133]  $ MoreArgs     : list()
[18:01:00.133]  - attr(*, "where")=List of 2
[18:01:00.133]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:00.133]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:00.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.133]  - attr(*, "resolved")= logi FALSE
[18:01:00.133]  - attr(*, "total_size")= num NA
[18:01:00.138] Packages to be attached in all futures: [n=0] 
[18:01:00.139] getGlobalsAndPackagesXApply() ... DONE
[18:01:00.139] Number of futures (= number of chunks): 2
[18:01:00.140] Launching 2 futures (chunks) ...
[18:01:00.140] Chunk #1 of 2 ...
[18:01:00.140]  - Finding globals in '...' for chunk #1 ...
[18:01:00.140] getGlobalsAndPackages() ...
[18:01:00.140] Searching for globals...
[18:01:00.141] 
[18:01:00.141] Searching for globals ... DONE
[18:01:00.142] - globals: [0] <none>
[18:01:00.142] getGlobalsAndPackages() ... DONE
[18:01:00.142]    + additional globals found: [n=0] 
[18:01:00.142]    + additional namespaces needed: [n=0] 
[18:01:00.142]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:00.143]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:00.143]  - seeds: <none>
[18:01:00.143]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.143] getGlobalsAndPackages() ...
[18:01:00.143] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.144] Resolving globals: FALSE
[18:01:00.145] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[18:01:00.146] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:00.146] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.146] 
[18:01:00.146] getGlobalsAndPackages() ... DONE
[18:01:00.147] run() for ‘Future’ ...
[18:01:00.147] - state: ‘created’
[18:01:00.147] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.154] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.154]   - Field: ‘label’
[18:01:00.155]   - Field: ‘local’
[18:01:00.155]   - Field: ‘owner’
[18:01:00.155]   - Field: ‘envir’
[18:01:00.155]   - Field: ‘workers’
[18:01:00.155]   - Field: ‘packages’
[18:01:00.156]   - Field: ‘gc’
[18:01:00.156]   - Field: ‘job’
[18:01:00.156]   - Field: ‘conditions’
[18:01:00.156]   - Field: ‘expr’
[18:01:00.157]   - Field: ‘uuid’
[18:01:00.157]   - Field: ‘seed’
[18:01:00.157]   - Field: ‘version’
[18:01:00.157]   - Field: ‘result’
[18:01:00.157]   - Field: ‘asynchronous’
[18:01:00.158]   - Field: ‘calls’
[18:01:00.158]   - Field: ‘globals’
[18:01:00.158]   - Field: ‘stdout’
[18:01:00.158]   - Field: ‘earlySignal’
[18:01:00.158]   - Field: ‘lazy’
[18:01:00.158]   - Field: ‘state’
[18:01:00.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.159] - Launch lazy future ...
[18:01:00.159] Packages needed by the future expression (n = 0): <none>
[18:01:00.160] Packages needed by future strategies (n = 0): <none>
[18:01:00.161] {
[18:01:00.161]     {
[18:01:00.161]         {
[18:01:00.161]             ...future.startTime <- base::Sys.time()
[18:01:00.161]             {
[18:01:00.161]                 {
[18:01:00.161]                   {
[18:01:00.161]                     {
[18:01:00.161]                       base::local({
[18:01:00.161]                         has_future <- base::requireNamespace("future", 
[18:01:00.161]                           quietly = TRUE)
[18:01:00.161]                         if (has_future) {
[18:01:00.161]                           ns <- base::getNamespace("future")
[18:01:00.161]                           version <- ns[[".package"]][["version"]]
[18:01:00.161]                           if (is.null(version)) 
[18:01:00.161]                             version <- utils::packageVersion("future")
[18:01:00.161]                         }
[18:01:00.161]                         else {
[18:01:00.161]                           version <- NULL
[18:01:00.161]                         }
[18:01:00.161]                         if (!has_future || version < "1.8.0") {
[18:01:00.161]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.161]                             "", base::R.version$version.string), 
[18:01:00.161]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.161]                               "release", "version")], collapse = " "), 
[18:01:00.161]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.161]                             info)
[18:01:00.161]                           info <- base::paste(info, collapse = "; ")
[18:01:00.161]                           if (!has_future) {
[18:01:00.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.161]                               info)
[18:01:00.161]                           }
[18:01:00.161]                           else {
[18:01:00.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.161]                               info, version)
[18:01:00.161]                           }
[18:01:00.161]                           base::stop(msg)
[18:01:00.161]                         }
[18:01:00.161]                       })
[18:01:00.161]                     }
[18:01:00.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.161]                     base::options(mc.cores = 1L)
[18:01:00.161]                   }
[18:01:00.161]                   ...future.strategy.old <- future::plan("list")
[18:01:00.161]                   options(future.plan = NULL)
[18:01:00.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.161]                 }
[18:01:00.161]                 ...future.workdir <- getwd()
[18:01:00.161]             }
[18:01:00.161]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.161]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.161]         }
[18:01:00.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.161]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:00.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.161]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.161]             base::names(...future.oldOptions))
[18:01:00.161]     }
[18:01:00.161]     if (FALSE) {
[18:01:00.161]     }
[18:01:00.161]     else {
[18:01:00.161]         if (TRUE) {
[18:01:00.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.161]                 open = "w")
[18:01:00.161]         }
[18:01:00.161]         else {
[18:01:00.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.161]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.161]         }
[18:01:00.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.161]             base::sink(type = "output", split = FALSE)
[18:01:00.161]             base::close(...future.stdout)
[18:01:00.161]         }, add = TRUE)
[18:01:00.161]     }
[18:01:00.161]     ...future.frame <- base::sys.nframe()
[18:01:00.161]     ...future.conditions <- base::list()
[18:01:00.161]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.161]     if (FALSE) {
[18:01:00.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.161]     }
[18:01:00.161]     ...future.result <- base::tryCatch({
[18:01:00.161]         base::withCallingHandlers({
[18:01:00.161]             ...future.value <- base::withVisible(base::local({
[18:01:00.161]                 withCallingHandlers({
[18:01:00.161]                   {
[18:01:00.161]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.161]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.161]                       ...future.globals.maxSize)) {
[18:01:00.161]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.161]                       on.exit(options(oopts), add = TRUE)
[18:01:00.161]                     }
[18:01:00.161]                     {
[18:01:00.161]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.161]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.161]                         USE.NAMES = FALSE)
[18:01:00.161]                       do.call(mapply, args = args)
[18:01:00.161]                     }
[18:01:00.161]                   }
[18:01:00.161]                 }, immediateCondition = function(cond) {
[18:01:00.161]                   save_rds <- function (object, pathname, ...) 
[18:01:00.161]                   {
[18:01:00.161]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.161]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.161]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.161]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.161]                         fi_tmp[["mtime"]])
[18:01:00.161]                     }
[18:01:00.161]                     tryCatch({
[18:01:00.161]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.161]                     }, error = function(ex) {
[18:01:00.161]                       msg <- conditionMessage(ex)
[18:01:00.161]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.161]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.161]                         fi_tmp[["mtime"]], msg)
[18:01:00.161]                       ex$message <- msg
[18:01:00.161]                       stop(ex)
[18:01:00.161]                     })
[18:01:00.161]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.161]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.161]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.161]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.161]                       fi <- file.info(pathname)
[18:01:00.161]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.161]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.161]                         fi[["size"]], fi[["mtime"]])
[18:01:00.161]                       stop(msg)
[18:01:00.161]                     }
[18:01:00.161]                     invisible(pathname)
[18:01:00.161]                   }
[18:01:00.161]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.161]                     rootPath = tempdir()) 
[18:01:00.161]                   {
[18:01:00.161]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.161]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.161]                       tmpdir = path, fileext = ".rds")
[18:01:00.161]                     save_rds(obj, file)
[18:01:00.161]                   }
[18:01:00.161]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.161]                   {
[18:01:00.161]                     inherits <- base::inherits
[18:01:00.161]                     invokeRestart <- base::invokeRestart
[18:01:00.161]                     is.null <- base::is.null
[18:01:00.161]                     muffled <- FALSE
[18:01:00.161]                     if (inherits(cond, "message")) {
[18:01:00.161]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.161]                       if (muffled) 
[18:01:00.161]                         invokeRestart("muffleMessage")
[18:01:00.161]                     }
[18:01:00.161]                     else if (inherits(cond, "warning")) {
[18:01:00.161]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.161]                       if (muffled) 
[18:01:00.161]                         invokeRestart("muffleWarning")
[18:01:00.161]                     }
[18:01:00.161]                     else if (inherits(cond, "condition")) {
[18:01:00.161]                       if (!is.null(pattern)) {
[18:01:00.161]                         computeRestarts <- base::computeRestarts
[18:01:00.161]                         grepl <- base::grepl
[18:01:00.161]                         restarts <- computeRestarts(cond)
[18:01:00.161]                         for (restart in restarts) {
[18:01:00.161]                           name <- restart$name
[18:01:00.161]                           if (is.null(name)) 
[18:01:00.161]                             next
[18:01:00.161]                           if (!grepl(pattern, name)) 
[18:01:00.161]                             next
[18:01:00.161]                           invokeRestart(restart)
[18:01:00.161]                           muffled <- TRUE
[18:01:00.161]                           break
[18:01:00.161]                         }
[18:01:00.161]                       }
[18:01:00.161]                     }
[18:01:00.161]                     invisible(muffled)
[18:01:00.161]                   }
[18:01:00.161]                   muffleCondition(cond)
[18:01:00.161]                 })
[18:01:00.161]             }))
[18:01:00.161]             future::FutureResult(value = ...future.value$value, 
[18:01:00.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.161]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.161]                     ...future.globalenv.names))
[18:01:00.161]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.161]         }, condition = base::local({
[18:01:00.161]             c <- base::c
[18:01:00.161]             inherits <- base::inherits
[18:01:00.161]             invokeRestart <- base::invokeRestart
[18:01:00.161]             length <- base::length
[18:01:00.161]             list <- base::list
[18:01:00.161]             seq.int <- base::seq.int
[18:01:00.161]             signalCondition <- base::signalCondition
[18:01:00.161]             sys.calls <- base::sys.calls
[18:01:00.161]             `[[` <- base::`[[`
[18:01:00.161]             `+` <- base::`+`
[18:01:00.161]             `<<-` <- base::`<<-`
[18:01:00.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.161]                   3L)]
[18:01:00.161]             }
[18:01:00.161]             function(cond) {
[18:01:00.161]                 is_error <- inherits(cond, "error")
[18:01:00.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.161]                   NULL)
[18:01:00.161]                 if (is_error) {
[18:01:00.161]                   sessionInformation <- function() {
[18:01:00.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.161]                       search = base::search(), system = base::Sys.info())
[18:01:00.161]                   }
[18:01:00.161]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.161]                     cond$call), session = sessionInformation(), 
[18:01:00.161]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.161]                   signalCondition(cond)
[18:01:00.161]                 }
[18:01:00.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.161]                 "immediateCondition"))) {
[18:01:00.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.161]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.161]                   if (TRUE && !signal) {
[18:01:00.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.161]                     {
[18:01:00.161]                       inherits <- base::inherits
[18:01:00.161]                       invokeRestart <- base::invokeRestart
[18:01:00.161]                       is.null <- base::is.null
[18:01:00.161]                       muffled <- FALSE
[18:01:00.161]                       if (inherits(cond, "message")) {
[18:01:00.161]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.161]                         if (muffled) 
[18:01:00.161]                           invokeRestart("muffleMessage")
[18:01:00.161]                       }
[18:01:00.161]                       else if (inherits(cond, "warning")) {
[18:01:00.161]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.161]                         if (muffled) 
[18:01:00.161]                           invokeRestart("muffleWarning")
[18:01:00.161]                       }
[18:01:00.161]                       else if (inherits(cond, "condition")) {
[18:01:00.161]                         if (!is.null(pattern)) {
[18:01:00.161]                           computeRestarts <- base::computeRestarts
[18:01:00.161]                           grepl <- base::grepl
[18:01:00.161]                           restarts <- computeRestarts(cond)
[18:01:00.161]                           for (restart in restarts) {
[18:01:00.161]                             name <- restart$name
[18:01:00.161]                             if (is.null(name)) 
[18:01:00.161]                               next
[18:01:00.161]                             if (!grepl(pattern, name)) 
[18:01:00.161]                               next
[18:01:00.161]                             invokeRestart(restart)
[18:01:00.161]                             muffled <- TRUE
[18:01:00.161]                             break
[18:01:00.161]                           }
[18:01:00.161]                         }
[18:01:00.161]                       }
[18:01:00.161]                       invisible(muffled)
[18:01:00.161]                     }
[18:01:00.161]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.161]                   }
[18:01:00.161]                 }
[18:01:00.161]                 else {
[18:01:00.161]                   if (TRUE) {
[18:01:00.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.161]                     {
[18:01:00.161]                       inherits <- base::inherits
[18:01:00.161]                       invokeRestart <- base::invokeRestart
[18:01:00.161]                       is.null <- base::is.null
[18:01:00.161]                       muffled <- FALSE
[18:01:00.161]                       if (inherits(cond, "message")) {
[18:01:00.161]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.161]                         if (muffled) 
[18:01:00.161]                           invokeRestart("muffleMessage")
[18:01:00.161]                       }
[18:01:00.161]                       else if (inherits(cond, "warning")) {
[18:01:00.161]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.161]                         if (muffled) 
[18:01:00.161]                           invokeRestart("muffleWarning")
[18:01:00.161]                       }
[18:01:00.161]                       else if (inherits(cond, "condition")) {
[18:01:00.161]                         if (!is.null(pattern)) {
[18:01:00.161]                           computeRestarts <- base::computeRestarts
[18:01:00.161]                           grepl <- base::grepl
[18:01:00.161]                           restarts <- computeRestarts(cond)
[18:01:00.161]                           for (restart in restarts) {
[18:01:00.161]                             name <- restart$name
[18:01:00.161]                             if (is.null(name)) 
[18:01:00.161]                               next
[18:01:00.161]                             if (!grepl(pattern, name)) 
[18:01:00.161]                               next
[18:01:00.161]                             invokeRestart(restart)
[18:01:00.161]                             muffled <- TRUE
[18:01:00.161]                             break
[18:01:00.161]                           }
[18:01:00.161]                         }
[18:01:00.161]                       }
[18:01:00.161]                       invisible(muffled)
[18:01:00.161]                     }
[18:01:00.161]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.161]                   }
[18:01:00.161]                 }
[18:01:00.161]             }
[18:01:00.161]         }))
[18:01:00.161]     }, error = function(ex) {
[18:01:00.161]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.161]                 ...future.rng), started = ...future.startTime, 
[18:01:00.161]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.161]             version = "1.8"), class = "FutureResult")
[18:01:00.161]     }, finally = {
[18:01:00.161]         if (!identical(...future.workdir, getwd())) 
[18:01:00.161]             setwd(...future.workdir)
[18:01:00.161]         {
[18:01:00.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.161]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.161]             }
[18:01:00.161]             base::options(...future.oldOptions)
[18:01:00.161]             if (.Platform$OS.type == "windows") {
[18:01:00.161]                 old_names <- names(...future.oldEnvVars)
[18:01:00.161]                 envs <- base::Sys.getenv()
[18:01:00.161]                 names <- names(envs)
[18:01:00.161]                 common <- intersect(names, old_names)
[18:01:00.161]                 added <- setdiff(names, old_names)
[18:01:00.161]                 removed <- setdiff(old_names, names)
[18:01:00.161]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.161]                   envs[common]]
[18:01:00.161]                 NAMES <- toupper(changed)
[18:01:00.161]                 args <- list()
[18:01:00.161]                 for (kk in seq_along(NAMES)) {
[18:01:00.161]                   name <- changed[[kk]]
[18:01:00.161]                   NAME <- NAMES[[kk]]
[18:01:00.161]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.161]                     next
[18:01:00.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.161]                 }
[18:01:00.161]                 NAMES <- toupper(added)
[18:01:00.161]                 for (kk in seq_along(NAMES)) {
[18:01:00.161]                   name <- added[[kk]]
[18:01:00.161]                   NAME <- NAMES[[kk]]
[18:01:00.161]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.161]                     next
[18:01:00.161]                   args[[name]] <- ""
[18:01:00.161]                 }
[18:01:00.161]                 NAMES <- toupper(removed)
[18:01:00.161]                 for (kk in seq_along(NAMES)) {
[18:01:00.161]                   name <- removed[[kk]]
[18:01:00.161]                   NAME <- NAMES[[kk]]
[18:01:00.161]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.161]                     next
[18:01:00.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.161]                 }
[18:01:00.161]                 if (length(args) > 0) 
[18:01:00.161]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.161]             }
[18:01:00.161]             else {
[18:01:00.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.161]             }
[18:01:00.161]             {
[18:01:00.161]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.161]                   0L) {
[18:01:00.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.161]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.161]                   base::options(opts)
[18:01:00.161]                 }
[18:01:00.161]                 {
[18:01:00.161]                   {
[18:01:00.161]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.161]                     NULL
[18:01:00.161]                   }
[18:01:00.161]                   options(future.plan = NULL)
[18:01:00.161]                   if (is.na(NA_character_)) 
[18:01:00.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.161]                     .init = FALSE)
[18:01:00.161]                 }
[18:01:00.161]             }
[18:01:00.161]         }
[18:01:00.161]     })
[18:01:00.161]     if (TRUE) {
[18:01:00.161]         base::sink(type = "output", split = FALSE)
[18:01:00.161]         if (TRUE) {
[18:01:00.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.161]         }
[18:01:00.161]         else {
[18:01:00.161]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.161]         }
[18:01:00.161]         base::close(...future.stdout)
[18:01:00.161]         ...future.stdout <- NULL
[18:01:00.161]     }
[18:01:00.161]     ...future.result$conditions <- ...future.conditions
[18:01:00.161]     ...future.result$finished <- base::Sys.time()
[18:01:00.161]     ...future.result
[18:01:00.161] }
[18:01:00.165] assign_globals() ...
[18:01:00.165] List of 5
[18:01:00.165]  $ ...future.FUN            :function (x, y)  
[18:01:00.165]  $ MoreArgs                 : list()
[18:01:00.165]  $ ...future.elements_ii    :List of 2
[18:01:00.165]   ..$ :List of 1
[18:01:00.165]   .. ..$ a: num 1
[18:01:00.165]   ..$ :List of 1
[18:01:00.165]   .. ..$ A: num 10
[18:01:00.165]  $ ...future.seeds_ii       : NULL
[18:01:00.165]  $ ...future.globals.maxSize: NULL
[18:01:00.165]  - attr(*, "where")=List of 5
[18:01:00.165]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.165]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.165]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.165]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.165]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.165]  - attr(*, "resolved")= logi FALSE
[18:01:00.165]  - attr(*, "total_size")= num 2088
[18:01:00.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.165]  - attr(*, "already-done")= logi TRUE
[18:01:00.179] - reassign environment for ‘...future.FUN’
[18:01:00.179] - copied ‘...future.FUN’ to environment
[18:01:00.179] - copied ‘MoreArgs’ to environment
[18:01:00.179] - copied ‘...future.elements_ii’ to environment
[18:01:00.180] - copied ‘...future.seeds_ii’ to environment
[18:01:00.180] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.180] assign_globals() ... done
[18:01:00.180] requestCore(): workers = 2
[18:01:00.184] MulticoreFuture started
[18:01:00.185] - Launch lazy future ... done
[18:01:00.187] plan(): Setting new future strategy stack:
[18:01:00.187] run() for ‘MulticoreFuture’ ... done
[18:01:00.188] Created future:
[18:01:00.188] List of future strategies:
[18:01:00.188] 1. sequential:
[18:01:00.188]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.188]    - tweaked: FALSE
[18:01:00.188]    - call: NULL
[18:01:00.191] plan(): nbrOfWorkers() = 1
[18:01:00.197] plan(): Setting new future strategy stack:
[18:01:00.198] List of future strategies:
[18:01:00.198] 1. multicore:
[18:01:00.198]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.198]    - tweaked: FALSE
[18:01:00.198]    - call: plan(strategy)
[18:01:00.189] MulticoreFuture:
[18:01:00.189] Label: ‘future_.mapply-1’
[18:01:00.189] Expression:
[18:01:00.189] {
[18:01:00.189]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.189]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.189]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.189]         on.exit(options(oopts), add = TRUE)
[18:01:00.189]     }
[18:01:00.189]     {
[18:01:00.189]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.189]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.189]         do.call(mapply, args = args)
[18:01:00.189]     }
[18:01:00.189] }
[18:01:00.189] Lazy evaluation: FALSE
[18:01:00.189] Asynchronous evaluation: TRUE
[18:01:00.189] Local evaluation: TRUE
[18:01:00.189] Environment: R_GlobalEnv
[18:01:00.189] Capture standard output: TRUE
[18:01:00.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.189] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.189] Packages: <none>
[18:01:00.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.189] Resolved: FALSE
[18:01:00.189] Value: <not collected>
[18:01:00.189] Conditions captured: <none>
[18:01:00.189] Early signaling: FALSE
[18:01:00.189] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.189] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.205] Chunk #1 of 2 ... DONE
[18:01:00.206] Chunk #2 of 2 ...
[18:01:00.206]  - Finding globals in '...' for chunk #2 ...
[18:01:00.207] getGlobalsAndPackages() ...
[18:01:00.207] Searching for globals...
[18:01:00.208] 
[18:01:00.208] Searching for globals ... DONE
[18:01:00.208] plan(): nbrOfWorkers() = 2
[18:01:00.209] - globals: [0] <none>
[18:01:00.209] getGlobalsAndPackages() ... DONE
[18:01:00.209]    + additional globals found: [n=0] 
[18:01:00.210]    + additional namespaces needed: [n=0] 
[18:01:00.210]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:00.210]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:00.210]  - seeds: <none>
[18:01:00.211]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.211] getGlobalsAndPackages() ...
[18:01:00.212] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.212] Resolving globals: FALSE
[18:01:00.214] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[18:01:00.215] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:00.216] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.216] 
[18:01:00.216] getGlobalsAndPackages() ... DONE
[18:01:00.218] run() for ‘Future’ ...
[18:01:00.218] - state: ‘created’
[18:01:00.219] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.227] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.227]   - Field: ‘label’
[18:01:00.228]   - Field: ‘local’
[18:01:00.228]   - Field: ‘owner’
[18:01:00.228]   - Field: ‘envir’
[18:01:00.229]   - Field: ‘workers’
[18:01:00.229]   - Field: ‘packages’
[18:01:00.229]   - Field: ‘gc’
[18:01:00.230]   - Field: ‘job’
[18:01:00.230]   - Field: ‘conditions’
[18:01:00.230]   - Field: ‘expr’
[18:01:00.230]   - Field: ‘uuid’
[18:01:00.231]   - Field: ‘seed’
[18:01:00.231]   - Field: ‘version’
[18:01:00.231]   - Field: ‘result’
[18:01:00.232]   - Field: ‘asynchronous’
[18:01:00.232]   - Field: ‘calls’
[18:01:00.232]   - Field: ‘globals’
[18:01:00.232]   - Field: ‘stdout’
[18:01:00.233]   - Field: ‘earlySignal’
[18:01:00.233]   - Field: ‘lazy’
[18:01:00.233]   - Field: ‘state’
[18:01:00.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.234] - Launch lazy future ...
[18:01:00.234] Packages needed by the future expression (n = 0): <none>
[18:01:00.235] Packages needed by future strategies (n = 0): <none>
[18:01:00.236] {
[18:01:00.236]     {
[18:01:00.236]         {
[18:01:00.236]             ...future.startTime <- base::Sys.time()
[18:01:00.236]             {
[18:01:00.236]                 {
[18:01:00.236]                   {
[18:01:00.236]                     {
[18:01:00.236]                       base::local({
[18:01:00.236]                         has_future <- base::requireNamespace("future", 
[18:01:00.236]                           quietly = TRUE)
[18:01:00.236]                         if (has_future) {
[18:01:00.236]                           ns <- base::getNamespace("future")
[18:01:00.236]                           version <- ns[[".package"]][["version"]]
[18:01:00.236]                           if (is.null(version)) 
[18:01:00.236]                             version <- utils::packageVersion("future")
[18:01:00.236]                         }
[18:01:00.236]                         else {
[18:01:00.236]                           version <- NULL
[18:01:00.236]                         }
[18:01:00.236]                         if (!has_future || version < "1.8.0") {
[18:01:00.236]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.236]                             "", base::R.version$version.string), 
[18:01:00.236]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.236]                               "release", "version")], collapse = " "), 
[18:01:00.236]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.236]                             info)
[18:01:00.236]                           info <- base::paste(info, collapse = "; ")
[18:01:00.236]                           if (!has_future) {
[18:01:00.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.236]                               info)
[18:01:00.236]                           }
[18:01:00.236]                           else {
[18:01:00.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.236]                               info, version)
[18:01:00.236]                           }
[18:01:00.236]                           base::stop(msg)
[18:01:00.236]                         }
[18:01:00.236]                       })
[18:01:00.236]                     }
[18:01:00.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.236]                     base::options(mc.cores = 1L)
[18:01:00.236]                   }
[18:01:00.236]                   ...future.strategy.old <- future::plan("list")
[18:01:00.236]                   options(future.plan = NULL)
[18:01:00.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.236]                 }
[18:01:00.236]                 ...future.workdir <- getwd()
[18:01:00.236]             }
[18:01:00.236]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.236]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.236]         }
[18:01:00.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:00.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.236]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.236]             base::names(...future.oldOptions))
[18:01:00.236]     }
[18:01:00.236]     if (FALSE) {
[18:01:00.236]     }
[18:01:00.236]     else {
[18:01:00.236]         if (TRUE) {
[18:01:00.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.236]                 open = "w")
[18:01:00.236]         }
[18:01:00.236]         else {
[18:01:00.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.236]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.236]         }
[18:01:00.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.236]             base::sink(type = "output", split = FALSE)
[18:01:00.236]             base::close(...future.stdout)
[18:01:00.236]         }, add = TRUE)
[18:01:00.236]     }
[18:01:00.236]     ...future.frame <- base::sys.nframe()
[18:01:00.236]     ...future.conditions <- base::list()
[18:01:00.236]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.236]     if (FALSE) {
[18:01:00.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.236]     }
[18:01:00.236]     ...future.result <- base::tryCatch({
[18:01:00.236]         base::withCallingHandlers({
[18:01:00.236]             ...future.value <- base::withVisible(base::local({
[18:01:00.236]                 withCallingHandlers({
[18:01:00.236]                   {
[18:01:00.236]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.236]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.236]                       ...future.globals.maxSize)) {
[18:01:00.236]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.236]                       on.exit(options(oopts), add = TRUE)
[18:01:00.236]                     }
[18:01:00.236]                     {
[18:01:00.236]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.236]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.236]                         USE.NAMES = FALSE)
[18:01:00.236]                       do.call(mapply, args = args)
[18:01:00.236]                     }
[18:01:00.236]                   }
[18:01:00.236]                 }, immediateCondition = function(cond) {
[18:01:00.236]                   save_rds <- function (object, pathname, ...) 
[18:01:00.236]                   {
[18:01:00.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.236]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.236]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.236]                         fi_tmp[["mtime"]])
[18:01:00.236]                     }
[18:01:00.236]                     tryCatch({
[18:01:00.236]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.236]                     }, error = function(ex) {
[18:01:00.236]                       msg <- conditionMessage(ex)
[18:01:00.236]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.236]                         fi_tmp[["mtime"]], msg)
[18:01:00.236]                       ex$message <- msg
[18:01:00.236]                       stop(ex)
[18:01:00.236]                     })
[18:01:00.236]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.236]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.236]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.236]                       fi <- file.info(pathname)
[18:01:00.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.236]                         fi[["size"]], fi[["mtime"]])
[18:01:00.236]                       stop(msg)
[18:01:00.236]                     }
[18:01:00.236]                     invisible(pathname)
[18:01:00.236]                   }
[18:01:00.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.236]                     rootPath = tempdir()) 
[18:01:00.236]                   {
[18:01:00.236]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.236]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.236]                       tmpdir = path, fileext = ".rds")
[18:01:00.236]                     save_rds(obj, file)
[18:01:00.236]                   }
[18:01:00.236]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.236]                   {
[18:01:00.236]                     inherits <- base::inherits
[18:01:00.236]                     invokeRestart <- base::invokeRestart
[18:01:00.236]                     is.null <- base::is.null
[18:01:00.236]                     muffled <- FALSE
[18:01:00.236]                     if (inherits(cond, "message")) {
[18:01:00.236]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.236]                       if (muffled) 
[18:01:00.236]                         invokeRestart("muffleMessage")
[18:01:00.236]                     }
[18:01:00.236]                     else if (inherits(cond, "warning")) {
[18:01:00.236]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.236]                       if (muffled) 
[18:01:00.236]                         invokeRestart("muffleWarning")
[18:01:00.236]                     }
[18:01:00.236]                     else if (inherits(cond, "condition")) {
[18:01:00.236]                       if (!is.null(pattern)) {
[18:01:00.236]                         computeRestarts <- base::computeRestarts
[18:01:00.236]                         grepl <- base::grepl
[18:01:00.236]                         restarts <- computeRestarts(cond)
[18:01:00.236]                         for (restart in restarts) {
[18:01:00.236]                           name <- restart$name
[18:01:00.236]                           if (is.null(name)) 
[18:01:00.236]                             next
[18:01:00.236]                           if (!grepl(pattern, name)) 
[18:01:00.236]                             next
[18:01:00.236]                           invokeRestart(restart)
[18:01:00.236]                           muffled <- TRUE
[18:01:00.236]                           break
[18:01:00.236]                         }
[18:01:00.236]                       }
[18:01:00.236]                     }
[18:01:00.236]                     invisible(muffled)
[18:01:00.236]                   }
[18:01:00.236]                   muffleCondition(cond)
[18:01:00.236]                 })
[18:01:00.236]             }))
[18:01:00.236]             future::FutureResult(value = ...future.value$value, 
[18:01:00.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.236]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.236]                     ...future.globalenv.names))
[18:01:00.236]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.236]         }, condition = base::local({
[18:01:00.236]             c <- base::c
[18:01:00.236]             inherits <- base::inherits
[18:01:00.236]             invokeRestart <- base::invokeRestart
[18:01:00.236]             length <- base::length
[18:01:00.236]             list <- base::list
[18:01:00.236]             seq.int <- base::seq.int
[18:01:00.236]             signalCondition <- base::signalCondition
[18:01:00.236]             sys.calls <- base::sys.calls
[18:01:00.236]             `[[` <- base::`[[`
[18:01:00.236]             `+` <- base::`+`
[18:01:00.236]             `<<-` <- base::`<<-`
[18:01:00.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.236]                   3L)]
[18:01:00.236]             }
[18:01:00.236]             function(cond) {
[18:01:00.236]                 is_error <- inherits(cond, "error")
[18:01:00.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.236]                   NULL)
[18:01:00.236]                 if (is_error) {
[18:01:00.236]                   sessionInformation <- function() {
[18:01:00.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.236]                       search = base::search(), system = base::Sys.info())
[18:01:00.236]                   }
[18:01:00.236]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.236]                     cond$call), session = sessionInformation(), 
[18:01:00.236]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.236]                   signalCondition(cond)
[18:01:00.236]                 }
[18:01:00.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.236]                 "immediateCondition"))) {
[18:01:00.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.236]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.236]                   if (TRUE && !signal) {
[18:01:00.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.236]                     {
[18:01:00.236]                       inherits <- base::inherits
[18:01:00.236]                       invokeRestart <- base::invokeRestart
[18:01:00.236]                       is.null <- base::is.null
[18:01:00.236]                       muffled <- FALSE
[18:01:00.236]                       if (inherits(cond, "message")) {
[18:01:00.236]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.236]                         if (muffled) 
[18:01:00.236]                           invokeRestart("muffleMessage")
[18:01:00.236]                       }
[18:01:00.236]                       else if (inherits(cond, "warning")) {
[18:01:00.236]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.236]                         if (muffled) 
[18:01:00.236]                           invokeRestart("muffleWarning")
[18:01:00.236]                       }
[18:01:00.236]                       else if (inherits(cond, "condition")) {
[18:01:00.236]                         if (!is.null(pattern)) {
[18:01:00.236]                           computeRestarts <- base::computeRestarts
[18:01:00.236]                           grepl <- base::grepl
[18:01:00.236]                           restarts <- computeRestarts(cond)
[18:01:00.236]                           for (restart in restarts) {
[18:01:00.236]                             name <- restart$name
[18:01:00.236]                             if (is.null(name)) 
[18:01:00.236]                               next
[18:01:00.236]                             if (!grepl(pattern, name)) 
[18:01:00.236]                               next
[18:01:00.236]                             invokeRestart(restart)
[18:01:00.236]                             muffled <- TRUE
[18:01:00.236]                             break
[18:01:00.236]                           }
[18:01:00.236]                         }
[18:01:00.236]                       }
[18:01:00.236]                       invisible(muffled)
[18:01:00.236]                     }
[18:01:00.236]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.236]                   }
[18:01:00.236]                 }
[18:01:00.236]                 else {
[18:01:00.236]                   if (TRUE) {
[18:01:00.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.236]                     {
[18:01:00.236]                       inherits <- base::inherits
[18:01:00.236]                       invokeRestart <- base::invokeRestart
[18:01:00.236]                       is.null <- base::is.null
[18:01:00.236]                       muffled <- FALSE
[18:01:00.236]                       if (inherits(cond, "message")) {
[18:01:00.236]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.236]                         if (muffled) 
[18:01:00.236]                           invokeRestart("muffleMessage")
[18:01:00.236]                       }
[18:01:00.236]                       else if (inherits(cond, "warning")) {
[18:01:00.236]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.236]                         if (muffled) 
[18:01:00.236]                           invokeRestart("muffleWarning")
[18:01:00.236]                       }
[18:01:00.236]                       else if (inherits(cond, "condition")) {
[18:01:00.236]                         if (!is.null(pattern)) {
[18:01:00.236]                           computeRestarts <- base::computeRestarts
[18:01:00.236]                           grepl <- base::grepl
[18:01:00.236]                           restarts <- computeRestarts(cond)
[18:01:00.236]                           for (restart in restarts) {
[18:01:00.236]                             name <- restart$name
[18:01:00.236]                             if (is.null(name)) 
[18:01:00.236]                               next
[18:01:00.236]                             if (!grepl(pattern, name)) 
[18:01:00.236]                               next
[18:01:00.236]                             invokeRestart(restart)
[18:01:00.236]                             muffled <- TRUE
[18:01:00.236]                             break
[18:01:00.236]                           }
[18:01:00.236]                         }
[18:01:00.236]                       }
[18:01:00.236]                       invisible(muffled)
[18:01:00.236]                     }
[18:01:00.236]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.236]                   }
[18:01:00.236]                 }
[18:01:00.236]             }
[18:01:00.236]         }))
[18:01:00.236]     }, error = function(ex) {
[18:01:00.236]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.236]                 ...future.rng), started = ...future.startTime, 
[18:01:00.236]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.236]             version = "1.8"), class = "FutureResult")
[18:01:00.236]     }, finally = {
[18:01:00.236]         if (!identical(...future.workdir, getwd())) 
[18:01:00.236]             setwd(...future.workdir)
[18:01:00.236]         {
[18:01:00.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.236]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.236]             }
[18:01:00.236]             base::options(...future.oldOptions)
[18:01:00.236]             if (.Platform$OS.type == "windows") {
[18:01:00.236]                 old_names <- names(...future.oldEnvVars)
[18:01:00.236]                 envs <- base::Sys.getenv()
[18:01:00.236]                 names <- names(envs)
[18:01:00.236]                 common <- intersect(names, old_names)
[18:01:00.236]                 added <- setdiff(names, old_names)
[18:01:00.236]                 removed <- setdiff(old_names, names)
[18:01:00.236]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.236]                   envs[common]]
[18:01:00.236]                 NAMES <- toupper(changed)
[18:01:00.236]                 args <- list()
[18:01:00.236]                 for (kk in seq_along(NAMES)) {
[18:01:00.236]                   name <- changed[[kk]]
[18:01:00.236]                   NAME <- NAMES[[kk]]
[18:01:00.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.236]                     next
[18:01:00.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.236]                 }
[18:01:00.236]                 NAMES <- toupper(added)
[18:01:00.236]                 for (kk in seq_along(NAMES)) {
[18:01:00.236]                   name <- added[[kk]]
[18:01:00.236]                   NAME <- NAMES[[kk]]
[18:01:00.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.236]                     next
[18:01:00.236]                   args[[name]] <- ""
[18:01:00.236]                 }
[18:01:00.236]                 NAMES <- toupper(removed)
[18:01:00.236]                 for (kk in seq_along(NAMES)) {
[18:01:00.236]                   name <- removed[[kk]]
[18:01:00.236]                   NAME <- NAMES[[kk]]
[18:01:00.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.236]                     next
[18:01:00.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.236]                 }
[18:01:00.236]                 if (length(args) > 0) 
[18:01:00.236]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.236]             }
[18:01:00.236]             else {
[18:01:00.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.236]             }
[18:01:00.236]             {
[18:01:00.236]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.236]                   0L) {
[18:01:00.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.236]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.236]                   base::options(opts)
[18:01:00.236]                 }
[18:01:00.236]                 {
[18:01:00.236]                   {
[18:01:00.236]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.236]                     NULL
[18:01:00.236]                   }
[18:01:00.236]                   options(future.plan = NULL)
[18:01:00.236]                   if (is.na(NA_character_)) 
[18:01:00.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.236]                     .init = FALSE)
[18:01:00.236]                 }
[18:01:00.236]             }
[18:01:00.236]         }
[18:01:00.236]     })
[18:01:00.236]     if (TRUE) {
[18:01:00.236]         base::sink(type = "output", split = FALSE)
[18:01:00.236]         if (TRUE) {
[18:01:00.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.236]         }
[18:01:00.236]         else {
[18:01:00.236]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.236]         }
[18:01:00.236]         base::close(...future.stdout)
[18:01:00.236]         ...future.stdout <- NULL
[18:01:00.236]     }
[18:01:00.236]     ...future.result$conditions <- ...future.conditions
[18:01:00.236]     ...future.result$finished <- base::Sys.time()
[18:01:00.236]     ...future.result
[18:01:00.236] }
[18:01:00.242] assign_globals() ...
[18:01:00.243] List of 5
[18:01:00.243]  $ ...future.FUN            :function (x, y)  
[18:01:00.243]  $ MoreArgs                 : list()
[18:01:00.243]  $ ...future.elements_ii    :List of 2
[18:01:00.243]   ..$ :List of 2
[18:01:00.243]   .. ..$ b: num 2
[18:01:00.243]   .. ..$ c: num 3
[18:01:00.243]   ..$ :List of 2
[18:01:00.243]   .. ..$ B: num 0
[18:01:00.243]   .. ..$ C: num -10
[18:01:00.243]  $ ...future.seeds_ii       : NULL
[18:01:00.243]  $ ...future.globals.maxSize: NULL
[18:01:00.243]  - attr(*, "where")=List of 5
[18:01:00.243]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.243]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.243]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.243]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.243]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.243]  - attr(*, "resolved")= logi FALSE
[18:01:00.243]  - attr(*, "total_size")= num 2200
[18:01:00.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.243]  - attr(*, "already-done")= logi TRUE
[18:01:00.259] - reassign environment for ‘...future.FUN’
[18:01:00.260] - copied ‘...future.FUN’ to environment
[18:01:00.260] - copied ‘MoreArgs’ to environment
[18:01:00.260] - copied ‘...future.elements_ii’ to environment
[18:01:00.260] - copied ‘...future.seeds_ii’ to environment
[18:01:00.261] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.261] assign_globals() ... done
[18:01:00.261] requestCore(): workers = 2
[18:01:00.265] MulticoreFuture started
[18:01:00.266] - Launch lazy future ... done
[18:01:00.266] run() for ‘MulticoreFuture’ ... done
[18:01:00.267] Created future:
[18:01:00.267] plan(): Setting new future strategy stack:
[18:01:00.268] List of future strategies:
[18:01:00.268] 1. sequential:
[18:01:00.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.268]    - tweaked: FALSE
[18:01:00.268]    - call: NULL
[18:01:00.270] plan(): nbrOfWorkers() = 1
[18:01:00.274] plan(): Setting new future strategy stack:
[18:01:00.274] List of future strategies:
[18:01:00.274] 1. multicore:
[18:01:00.274]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.274]    - tweaked: FALSE
[18:01:00.274]    - call: plan(strategy)
[18:01:00.267] MulticoreFuture:
[18:01:00.267] Label: ‘future_.mapply-2’
[18:01:00.267] Expression:
[18:01:00.267] {
[18:01:00.267]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.267]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.267]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.267]         on.exit(options(oopts), add = TRUE)
[18:01:00.267]     }
[18:01:00.267]     {
[18:01:00.267]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.267]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.267]         do.call(mapply, args = args)
[18:01:00.267]     }
[18:01:00.267] }
[18:01:00.267] Lazy evaluation: FALSE
[18:01:00.267] Asynchronous evaluation: TRUE
[18:01:00.267] Local evaluation: TRUE
[18:01:00.267] Environment: R_GlobalEnv
[18:01:00.267] Capture standard output: TRUE
[18:01:00.267] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.267] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.267] Packages: <none>
[18:01:00.267] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.267] Resolved: FALSE
[18:01:00.267] Value: <not collected>
[18:01:00.267] Conditions captured: <none>
[18:01:00.267] Early signaling: FALSE
[18:01:00.267] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.267] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.283] Chunk #2 of 2 ... DONE
[18:01:00.284] Launching 2 futures (chunks) ... DONE
[18:01:00.287] Resolving 2 futures (chunks) ...
[18:01:00.287] resolve() on list ...
[18:01:00.288]  recursive: 0
[18:01:00.288]  length: 2
[18:01:00.288] 
[18:01:00.294] plan(): nbrOfWorkers() = 2
[18:01:00.291] Future #1
[18:01:00.298] result() for MulticoreFuture ...
[18:01:00.300] result() for MulticoreFuture ...
[18:01:00.301] result() for MulticoreFuture ... done
[18:01:00.301] result() for MulticoreFuture ... done
[18:01:00.302] result() for MulticoreFuture ...
[18:01:00.302] result() for MulticoreFuture ... done
[18:01:00.303] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:00.303] - nx: 2
[18:01:00.304] - relay: TRUE
[18:01:00.304] - stdout: TRUE
[18:01:00.305] - signal: TRUE
[18:01:00.306] - resignal: FALSE
[18:01:00.306] - force: TRUE
[18:01:00.306] - relayed: [n=2] FALSE, FALSE
[18:01:00.307] - queued futures: [n=2] FALSE, FALSE
[18:01:00.308]  - until=1
[18:01:00.308]  - relaying element #1
[18:01:00.309] result() for MulticoreFuture ...
[18:01:00.309] result() for MulticoreFuture ... done
[18:01:00.310] result() for MulticoreFuture ...
[18:01:00.310] result() for MulticoreFuture ... done
[18:01:00.312] result() for MulticoreFuture ...
[18:01:00.312] result() for MulticoreFuture ... done
[18:01:00.313] result() for MulticoreFuture ...
[18:01:00.313] result() for MulticoreFuture ... done
[18:01:00.313] - relayed: [n=2] TRUE, FALSE
[18:01:00.314] - queued futures: [n=2] TRUE, FALSE
[18:01:00.314] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:00.314]  length: 1 (resolved future 1)
[18:01:00.315] Future #2
[18:01:00.316] result() for MulticoreFuture ...
[18:01:00.317] result() for MulticoreFuture ...
[18:01:00.317] result() for MulticoreFuture ... done
[18:01:00.318] result() for MulticoreFuture ... done
[18:01:00.318] result() for MulticoreFuture ...
[18:01:00.318] result() for MulticoreFuture ... done
[18:01:00.319] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:00.319] - nx: 2
[18:01:00.319] - relay: TRUE
[18:01:00.319] - stdout: TRUE
[18:01:00.320] - signal: TRUE
[18:01:00.320] - resignal: FALSE
[18:01:00.320] - force: TRUE
[18:01:00.320] - relayed: [n=2] TRUE, FALSE
[18:01:00.320] - queued futures: [n=2] TRUE, FALSE
[18:01:00.321]  - until=2
[18:01:00.321]  - relaying element #2
[18:01:00.321] result() for MulticoreFuture ...
[18:01:00.322] result() for MulticoreFuture ... done
[18:01:00.322] result() for MulticoreFuture ...
[18:01:00.322] result() for MulticoreFuture ... done
[18:01:00.323] result() for MulticoreFuture ...
[18:01:00.323] result() for MulticoreFuture ... done
[18:01:00.323] result() for MulticoreFuture ...
[18:01:00.323] result() for MulticoreFuture ... done
[18:01:00.323] - relayed: [n=2] TRUE, TRUE
[18:01:00.324] - queued futures: [n=2] TRUE, TRUE
[18:01:00.324] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:00.324]  length: 0 (resolved future 2)
[18:01:00.324] Relaying remaining futures
[18:01:00.325] signalConditionsASAP(NULL, pos=0) ...
[18:01:00.325] - nx: 2
[18:01:00.325] - relay: TRUE
[18:01:00.325] - stdout: TRUE
[18:01:00.325] - signal: TRUE
[18:01:00.326] - resignal: FALSE
[18:01:00.326] - force: TRUE
[18:01:00.326] - relayed: [n=2] TRUE, TRUE
[18:01:00.326] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:00.327] - relayed: [n=2] TRUE, TRUE
[18:01:00.327] - queued futures: [n=2] TRUE, TRUE
[18:01:00.327] signalConditionsASAP(NULL, pos=0) ... done
[18:01:00.327] resolve() on list ... DONE
[18:01:00.327] result() for MulticoreFuture ...
[18:01:00.328] result() for MulticoreFuture ... done
[18:01:00.328] result() for MulticoreFuture ...
[18:01:00.328] result() for MulticoreFuture ... done
[18:01:00.329] result() for MulticoreFuture ...
[18:01:00.329] result() for MulticoreFuture ... done
[18:01:00.329] result() for MulticoreFuture ...
[18:01:00.329] result() for MulticoreFuture ... done
[18:01:00.330]  - Number of value chunks collected: 2
[18:01:00.330] Resolving 2 futures (chunks) ... DONE
[18:01:00.330] Reducing values from 2 chunks ...
[18:01:00.330]  - Number of values collected after concatenation: 3
[18:01:00.330]  - Number of values expected: 3
[18:01:00.331] Reducing values from 2 chunks ... DONE
[18:01:00.331] future_mapply() ... DONE
[18:01:00.331] future_mapply() ...
[18:01:00.338] Number of chunks: 5
[18:01:00.339] getGlobalsAndPackagesXApply() ...
[18:01:00.339]  - future.globals: TRUE
[18:01:00.339] getGlobalsAndPackages() ...
[18:01:00.339] Searching for globals...
[18:01:00.346] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:00.346] Searching for globals ... DONE
[18:01:00.346] Resolving globals: FALSE
[18:01:00.347] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:00.348] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:00.348] - globals: [1] ‘FUN’
[18:01:00.349] 
[18:01:00.349] getGlobalsAndPackages() ... DONE
[18:01:00.349]  - globals found/used: [n=1] ‘FUN’
[18:01:00.349]  - needed namespaces: [n=0] 
[18:01:00.350] Finding globals ... DONE
[18:01:00.350] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:00.350] List of 2
[18:01:00.350]  $ ...future.FUN:function (C, k)  
[18:01:00.350]  $ MoreArgs     : NULL
[18:01:00.350]  - attr(*, "where")=List of 2
[18:01:00.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:00.350]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:00.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.350]  - attr(*, "resolved")= logi FALSE
[18:01:00.350]  - attr(*, "total_size")= num NA
[18:01:00.356] Packages to be attached in all futures: [n=0] 
[18:01:00.357] getGlobalsAndPackagesXApply() ... DONE
[18:01:00.357] Number of futures (= number of chunks): 5
[18:01:00.357] Launching 5 futures (chunks) ...
[18:01:00.358] Chunk #1 of 5 ...
[18:01:00.358]  - Finding globals in '...' for chunk #1 ...
[18:01:00.358] getGlobalsAndPackages() ...
[18:01:00.358] Searching for globals...
[18:01:00.359] 
[18:01:00.359] Searching for globals ... DONE
[18:01:00.360] - globals: [0] <none>
[18:01:00.360] getGlobalsAndPackages() ... DONE
[18:01:00.360]    + additional globals found: [n=0] 
[18:01:00.360]    + additional namespaces needed: [n=0] 
[18:01:00.361]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:00.361]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:00.361]  - seeds: <none>
[18:01:00.361]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.361] getGlobalsAndPackages() ...
[18:01:00.362] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.362] Resolving globals: FALSE
[18:01:00.363] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:00.364] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:00.364] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.368] 
[18:01:00.368] getGlobalsAndPackages() ... DONE
[18:01:00.368] run() for ‘Future’ ...
[18:01:00.369] - state: ‘created’
[18:01:00.369] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.376] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.376]   - Field: ‘label’
[18:01:00.377]   - Field: ‘local’
[18:01:00.377]   - Field: ‘owner’
[18:01:00.377]   - Field: ‘envir’
[18:01:00.377]   - Field: ‘workers’
[18:01:00.378]   - Field: ‘packages’
[18:01:00.378]   - Field: ‘gc’
[18:01:00.378]   - Field: ‘job’
[18:01:00.379]   - Field: ‘conditions’
[18:01:00.380]   - Field: ‘expr’
[18:01:00.380]   - Field: ‘uuid’
[18:01:00.380]   - Field: ‘seed’
[18:01:00.380]   - Field: ‘version’
[18:01:00.381]   - Field: ‘result’
[18:01:00.381]   - Field: ‘asynchronous’
[18:01:00.381]   - Field: ‘calls’
[18:01:00.381]   - Field: ‘globals’
[18:01:00.381]   - Field: ‘stdout’
[18:01:00.382]   - Field: ‘earlySignal’
[18:01:00.382]   - Field: ‘lazy’
[18:01:00.382]   - Field: ‘state’
[18:01:00.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.383] - Launch lazy future ...
[18:01:00.383] Packages needed by the future expression (n = 0): <none>
[18:01:00.384] Packages needed by future strategies (n = 0): <none>
[18:01:00.385] {
[18:01:00.385]     {
[18:01:00.385]         {
[18:01:00.385]             ...future.startTime <- base::Sys.time()
[18:01:00.385]             {
[18:01:00.385]                 {
[18:01:00.385]                   {
[18:01:00.385]                     {
[18:01:00.385]                       base::local({
[18:01:00.385]                         has_future <- base::requireNamespace("future", 
[18:01:00.385]                           quietly = TRUE)
[18:01:00.385]                         if (has_future) {
[18:01:00.385]                           ns <- base::getNamespace("future")
[18:01:00.385]                           version <- ns[[".package"]][["version"]]
[18:01:00.385]                           if (is.null(version)) 
[18:01:00.385]                             version <- utils::packageVersion("future")
[18:01:00.385]                         }
[18:01:00.385]                         else {
[18:01:00.385]                           version <- NULL
[18:01:00.385]                         }
[18:01:00.385]                         if (!has_future || version < "1.8.0") {
[18:01:00.385]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.385]                             "", base::R.version$version.string), 
[18:01:00.385]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.385]                               "release", "version")], collapse = " "), 
[18:01:00.385]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.385]                             info)
[18:01:00.385]                           info <- base::paste(info, collapse = "; ")
[18:01:00.385]                           if (!has_future) {
[18:01:00.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.385]                               info)
[18:01:00.385]                           }
[18:01:00.385]                           else {
[18:01:00.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.385]                               info, version)
[18:01:00.385]                           }
[18:01:00.385]                           base::stop(msg)
[18:01:00.385]                         }
[18:01:00.385]                       })
[18:01:00.385]                     }
[18:01:00.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.385]                     base::options(mc.cores = 1L)
[18:01:00.385]                   }
[18:01:00.385]                   ...future.strategy.old <- future::plan("list")
[18:01:00.385]                   options(future.plan = NULL)
[18:01:00.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.385]                 }
[18:01:00.385]                 ...future.workdir <- getwd()
[18:01:00.385]             }
[18:01:00.385]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.385]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.385]         }
[18:01:00.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.385]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:00.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.385]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.385]             base::names(...future.oldOptions))
[18:01:00.385]     }
[18:01:00.385]     if (FALSE) {
[18:01:00.385]     }
[18:01:00.385]     else {
[18:01:00.385]         if (TRUE) {
[18:01:00.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.385]                 open = "w")
[18:01:00.385]         }
[18:01:00.385]         else {
[18:01:00.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.385]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.385]         }
[18:01:00.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.385]             base::sink(type = "output", split = FALSE)
[18:01:00.385]             base::close(...future.stdout)
[18:01:00.385]         }, add = TRUE)
[18:01:00.385]     }
[18:01:00.385]     ...future.frame <- base::sys.nframe()
[18:01:00.385]     ...future.conditions <- base::list()
[18:01:00.385]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.385]     if (FALSE) {
[18:01:00.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.385]     }
[18:01:00.385]     ...future.result <- base::tryCatch({
[18:01:00.385]         base::withCallingHandlers({
[18:01:00.385]             ...future.value <- base::withVisible(base::local({
[18:01:00.385]                 withCallingHandlers({
[18:01:00.385]                   {
[18:01:00.385]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.385]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.385]                       ...future.globals.maxSize)) {
[18:01:00.385]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.385]                       on.exit(options(oopts), add = TRUE)
[18:01:00.385]                     }
[18:01:00.385]                     {
[18:01:00.385]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.385]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.385]                         USE.NAMES = FALSE)
[18:01:00.385]                       do.call(mapply, args = args)
[18:01:00.385]                     }
[18:01:00.385]                   }
[18:01:00.385]                 }, immediateCondition = function(cond) {
[18:01:00.385]                   save_rds <- function (object, pathname, ...) 
[18:01:00.385]                   {
[18:01:00.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.385]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.385]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.385]                         fi_tmp[["mtime"]])
[18:01:00.385]                     }
[18:01:00.385]                     tryCatch({
[18:01:00.385]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.385]                     }, error = function(ex) {
[18:01:00.385]                       msg <- conditionMessage(ex)
[18:01:00.385]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.385]                         fi_tmp[["mtime"]], msg)
[18:01:00.385]                       ex$message <- msg
[18:01:00.385]                       stop(ex)
[18:01:00.385]                     })
[18:01:00.385]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.385]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.385]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.385]                       fi <- file.info(pathname)
[18:01:00.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.385]                         fi[["size"]], fi[["mtime"]])
[18:01:00.385]                       stop(msg)
[18:01:00.385]                     }
[18:01:00.385]                     invisible(pathname)
[18:01:00.385]                   }
[18:01:00.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.385]                     rootPath = tempdir()) 
[18:01:00.385]                   {
[18:01:00.385]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.385]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.385]                       tmpdir = path, fileext = ".rds")
[18:01:00.385]                     save_rds(obj, file)
[18:01:00.385]                   }
[18:01:00.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.385]                   {
[18:01:00.385]                     inherits <- base::inherits
[18:01:00.385]                     invokeRestart <- base::invokeRestart
[18:01:00.385]                     is.null <- base::is.null
[18:01:00.385]                     muffled <- FALSE
[18:01:00.385]                     if (inherits(cond, "message")) {
[18:01:00.385]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.385]                       if (muffled) 
[18:01:00.385]                         invokeRestart("muffleMessage")
[18:01:00.385]                     }
[18:01:00.385]                     else if (inherits(cond, "warning")) {
[18:01:00.385]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.385]                       if (muffled) 
[18:01:00.385]                         invokeRestart("muffleWarning")
[18:01:00.385]                     }
[18:01:00.385]                     else if (inherits(cond, "condition")) {
[18:01:00.385]                       if (!is.null(pattern)) {
[18:01:00.385]                         computeRestarts <- base::computeRestarts
[18:01:00.385]                         grepl <- base::grepl
[18:01:00.385]                         restarts <- computeRestarts(cond)
[18:01:00.385]                         for (restart in restarts) {
[18:01:00.385]                           name <- restart$name
[18:01:00.385]                           if (is.null(name)) 
[18:01:00.385]                             next
[18:01:00.385]                           if (!grepl(pattern, name)) 
[18:01:00.385]                             next
[18:01:00.385]                           invokeRestart(restart)
[18:01:00.385]                           muffled <- TRUE
[18:01:00.385]                           break
[18:01:00.385]                         }
[18:01:00.385]                       }
[18:01:00.385]                     }
[18:01:00.385]                     invisible(muffled)
[18:01:00.385]                   }
[18:01:00.385]                   muffleCondition(cond)
[18:01:00.385]                 })
[18:01:00.385]             }))
[18:01:00.385]             future::FutureResult(value = ...future.value$value, 
[18:01:00.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.385]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.385]                     ...future.globalenv.names))
[18:01:00.385]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.385]         }, condition = base::local({
[18:01:00.385]             c <- base::c
[18:01:00.385]             inherits <- base::inherits
[18:01:00.385]             invokeRestart <- base::invokeRestart
[18:01:00.385]             length <- base::length
[18:01:00.385]             list <- base::list
[18:01:00.385]             seq.int <- base::seq.int
[18:01:00.385]             signalCondition <- base::signalCondition
[18:01:00.385]             sys.calls <- base::sys.calls
[18:01:00.385]             `[[` <- base::`[[`
[18:01:00.385]             `+` <- base::`+`
[18:01:00.385]             `<<-` <- base::`<<-`
[18:01:00.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.385]                   3L)]
[18:01:00.385]             }
[18:01:00.385]             function(cond) {
[18:01:00.385]                 is_error <- inherits(cond, "error")
[18:01:00.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.385]                   NULL)
[18:01:00.385]                 if (is_error) {
[18:01:00.385]                   sessionInformation <- function() {
[18:01:00.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.385]                       search = base::search(), system = base::Sys.info())
[18:01:00.385]                   }
[18:01:00.385]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.385]                     cond$call), session = sessionInformation(), 
[18:01:00.385]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.385]                   signalCondition(cond)
[18:01:00.385]                 }
[18:01:00.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.385]                 "immediateCondition"))) {
[18:01:00.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.385]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.385]                   if (TRUE && !signal) {
[18:01:00.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.385]                     {
[18:01:00.385]                       inherits <- base::inherits
[18:01:00.385]                       invokeRestart <- base::invokeRestart
[18:01:00.385]                       is.null <- base::is.null
[18:01:00.385]                       muffled <- FALSE
[18:01:00.385]                       if (inherits(cond, "message")) {
[18:01:00.385]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.385]                         if (muffled) 
[18:01:00.385]                           invokeRestart("muffleMessage")
[18:01:00.385]                       }
[18:01:00.385]                       else if (inherits(cond, "warning")) {
[18:01:00.385]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.385]                         if (muffled) 
[18:01:00.385]                           invokeRestart("muffleWarning")
[18:01:00.385]                       }
[18:01:00.385]                       else if (inherits(cond, "condition")) {
[18:01:00.385]                         if (!is.null(pattern)) {
[18:01:00.385]                           computeRestarts <- base::computeRestarts
[18:01:00.385]                           grepl <- base::grepl
[18:01:00.385]                           restarts <- computeRestarts(cond)
[18:01:00.385]                           for (restart in restarts) {
[18:01:00.385]                             name <- restart$name
[18:01:00.385]                             if (is.null(name)) 
[18:01:00.385]                               next
[18:01:00.385]                             if (!grepl(pattern, name)) 
[18:01:00.385]                               next
[18:01:00.385]                             invokeRestart(restart)
[18:01:00.385]                             muffled <- TRUE
[18:01:00.385]                             break
[18:01:00.385]                           }
[18:01:00.385]                         }
[18:01:00.385]                       }
[18:01:00.385]                       invisible(muffled)
[18:01:00.385]                     }
[18:01:00.385]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.385]                   }
[18:01:00.385]                 }
[18:01:00.385]                 else {
[18:01:00.385]                   if (TRUE) {
[18:01:00.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.385]                     {
[18:01:00.385]                       inherits <- base::inherits
[18:01:00.385]                       invokeRestart <- base::invokeRestart
[18:01:00.385]                       is.null <- base::is.null
[18:01:00.385]                       muffled <- FALSE
[18:01:00.385]                       if (inherits(cond, "message")) {
[18:01:00.385]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.385]                         if (muffled) 
[18:01:00.385]                           invokeRestart("muffleMessage")
[18:01:00.385]                       }
[18:01:00.385]                       else if (inherits(cond, "warning")) {
[18:01:00.385]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.385]                         if (muffled) 
[18:01:00.385]                           invokeRestart("muffleWarning")
[18:01:00.385]                       }
[18:01:00.385]                       else if (inherits(cond, "condition")) {
[18:01:00.385]                         if (!is.null(pattern)) {
[18:01:00.385]                           computeRestarts <- base::computeRestarts
[18:01:00.385]                           grepl <- base::grepl
[18:01:00.385]                           restarts <- computeRestarts(cond)
[18:01:00.385]                           for (restart in restarts) {
[18:01:00.385]                             name <- restart$name
[18:01:00.385]                             if (is.null(name)) 
[18:01:00.385]                               next
[18:01:00.385]                             if (!grepl(pattern, name)) 
[18:01:00.385]                               next
[18:01:00.385]                             invokeRestart(restart)
[18:01:00.385]                             muffled <- TRUE
[18:01:00.385]                             break
[18:01:00.385]                           }
[18:01:00.385]                         }
[18:01:00.385]                       }
[18:01:00.385]                       invisible(muffled)
[18:01:00.385]                     }
[18:01:00.385]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.385]                   }
[18:01:00.385]                 }
[18:01:00.385]             }
[18:01:00.385]         }))
[18:01:00.385]     }, error = function(ex) {
[18:01:00.385]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.385]                 ...future.rng), started = ...future.startTime, 
[18:01:00.385]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.385]             version = "1.8"), class = "FutureResult")
[18:01:00.385]     }, finally = {
[18:01:00.385]         if (!identical(...future.workdir, getwd())) 
[18:01:00.385]             setwd(...future.workdir)
[18:01:00.385]         {
[18:01:00.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.385]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.385]             }
[18:01:00.385]             base::options(...future.oldOptions)
[18:01:00.385]             if (.Platform$OS.type == "windows") {
[18:01:00.385]                 old_names <- names(...future.oldEnvVars)
[18:01:00.385]                 envs <- base::Sys.getenv()
[18:01:00.385]                 names <- names(envs)
[18:01:00.385]                 common <- intersect(names, old_names)
[18:01:00.385]                 added <- setdiff(names, old_names)
[18:01:00.385]                 removed <- setdiff(old_names, names)
[18:01:00.385]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.385]                   envs[common]]
[18:01:00.385]                 NAMES <- toupper(changed)
[18:01:00.385]                 args <- list()
[18:01:00.385]                 for (kk in seq_along(NAMES)) {
[18:01:00.385]                   name <- changed[[kk]]
[18:01:00.385]                   NAME <- NAMES[[kk]]
[18:01:00.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.385]                     next
[18:01:00.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.385]                 }
[18:01:00.385]                 NAMES <- toupper(added)
[18:01:00.385]                 for (kk in seq_along(NAMES)) {
[18:01:00.385]                   name <- added[[kk]]
[18:01:00.385]                   NAME <- NAMES[[kk]]
[18:01:00.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.385]                     next
[18:01:00.385]                   args[[name]] <- ""
[18:01:00.385]                 }
[18:01:00.385]                 NAMES <- toupper(removed)
[18:01:00.385]                 for (kk in seq_along(NAMES)) {
[18:01:00.385]                   name <- removed[[kk]]
[18:01:00.385]                   NAME <- NAMES[[kk]]
[18:01:00.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.385]                     next
[18:01:00.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.385]                 }
[18:01:00.385]                 if (length(args) > 0) 
[18:01:00.385]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.385]             }
[18:01:00.385]             else {
[18:01:00.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.385]             }
[18:01:00.385]             {
[18:01:00.385]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.385]                   0L) {
[18:01:00.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.385]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.385]                   base::options(opts)
[18:01:00.385]                 }
[18:01:00.385]                 {
[18:01:00.385]                   {
[18:01:00.385]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.385]                     NULL
[18:01:00.385]                   }
[18:01:00.385]                   options(future.plan = NULL)
[18:01:00.385]                   if (is.na(NA_character_)) 
[18:01:00.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.385]                     .init = FALSE)
[18:01:00.385]                 }
[18:01:00.385]             }
[18:01:00.385]         }
[18:01:00.385]     })
[18:01:00.385]     if (TRUE) {
[18:01:00.385]         base::sink(type = "output", split = FALSE)
[18:01:00.385]         if (TRUE) {
[18:01:00.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.385]         }
[18:01:00.385]         else {
[18:01:00.385]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.385]         }
[18:01:00.385]         base::close(...future.stdout)
[18:01:00.385]         ...future.stdout <- NULL
[18:01:00.385]     }
[18:01:00.385]     ...future.result$conditions <- ...future.conditions
[18:01:00.385]     ...future.result$finished <- base::Sys.time()
[18:01:00.385]     ...future.result
[18:01:00.385] }
[18:01:00.389] assign_globals() ...
[18:01:00.390] List of 5
[18:01:00.390]  $ ...future.FUN            :function (C, k)  
[18:01:00.390]  $ MoreArgs                 : NULL
[18:01:00.390]  $ ...future.elements_ii    :List of 2
[18:01:00.390]   ..$ :List of 1
[18:01:00.390]   .. ..$ : chr "A"
[18:01:00.390]   ..$ :List of 1
[18:01:00.390]   .. ..$ : int 5
[18:01:00.390]  $ ...future.seeds_ii       : NULL
[18:01:00.390]  $ ...future.globals.maxSize: NULL
[18:01:00.390]  - attr(*, "where")=List of 5
[18:01:00.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.390]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.390]  - attr(*, "resolved")= logi FALSE
[18:01:00.390]  - attr(*, "total_size")= num 3488
[18:01:00.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.390]  - attr(*, "already-done")= logi TRUE
[18:01:00.401] - reassign environment for ‘...future.FUN’
[18:01:00.401] - copied ‘...future.FUN’ to environment
[18:01:00.402] - copied ‘MoreArgs’ to environment
[18:01:00.402] - copied ‘...future.elements_ii’ to environment
[18:01:00.402] - copied ‘...future.seeds_ii’ to environment
[18:01:00.402] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.402] assign_globals() ... done
[18:01:00.403] requestCore(): workers = 2
[18:01:00.406] MulticoreFuture started
[18:01:00.407] - Launch lazy future ... done
[18:01:00.411] plan(): Setting new future strategy stack:
[18:01:00.408] run() for ‘MulticoreFuture’ ... done
[18:01:00.412] Created future:
[18:01:00.411] List of future strategies:
[18:01:00.411] 1. sequential:
[18:01:00.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.411]    - tweaked: FALSE
[18:01:00.411]    - call: NULL
[18:01:00.416] plan(): nbrOfWorkers() = 1
[18:01:00.423] plan(): Setting new future strategy stack:
[18:01:00.423] List of future strategies:
[18:01:00.423] 1. multicore:
[18:01:00.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.423]    - tweaked: FALSE
[18:01:00.423]    - call: plan(strategy)
[18:01:00.413] MulticoreFuture:
[18:01:00.413] Label: ‘future_mapply-1’
[18:01:00.413] Expression:
[18:01:00.413] {
[18:01:00.413]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.413]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.413]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.413]         on.exit(options(oopts), add = TRUE)
[18:01:00.413]     }
[18:01:00.413]     {
[18:01:00.413]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.413]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.413]         do.call(mapply, args = args)
[18:01:00.413]     }
[18:01:00.413] }
[18:01:00.413] Lazy evaluation: FALSE
[18:01:00.413] Asynchronous evaluation: TRUE
[18:01:00.413] Local evaluation: TRUE
[18:01:00.413] Environment: R_GlobalEnv
[18:01:00.413] Capture standard output: TRUE
[18:01:00.413] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.413] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.413] Packages: <none>
[18:01:00.413] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.413] Resolved: FALSE
[18:01:00.413] Value: <not collected>
[18:01:00.413] Conditions captured: <none>
[18:01:00.413] Early signaling: FALSE
[18:01:00.413] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.413] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.432] Chunk #1 of 5 ... DONE
[18:01:00.433] Chunk #2 of 5 ...
[18:01:00.436]  - Finding globals in '...' for chunk #2 ...
[18:01:00.436] getGlobalsAndPackages() ...
[18:01:00.437] Searching for globals...
[18:01:00.436] plan(): nbrOfWorkers() = 2
[18:01:00.439] 
[18:01:00.439] Searching for globals ... DONE
[18:01:00.439] - globals: [0] <none>
[18:01:00.439] getGlobalsAndPackages() ... DONE
[18:01:00.440]    + additional globals found: [n=0] 
[18:01:00.440]    + additional namespaces needed: [n=0] 
[18:01:00.440]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:00.441]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:00.441]  - seeds: <none>
[18:01:00.441]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.442] getGlobalsAndPackages() ...
[18:01:00.442] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.442] Resolving globals: FALSE
[18:01:00.444] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:00.446] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:00.447] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.447] 
[18:01:00.447] getGlobalsAndPackages() ... DONE
[18:01:00.449] run() for ‘Future’ ...
[18:01:00.449] - state: ‘created’
[18:01:00.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.458] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.459]   - Field: ‘label’
[18:01:00.459]   - Field: ‘local’
[18:01:00.460]   - Field: ‘owner’
[18:01:00.460]   - Field: ‘envir’
[18:01:00.460]   - Field: ‘workers’
[18:01:00.461]   - Field: ‘packages’
[18:01:00.461]   - Field: ‘gc’
[18:01:00.461]   - Field: ‘job’
[18:01:00.462]   - Field: ‘conditions’
[18:01:00.462]   - Field: ‘expr’
[18:01:00.462]   - Field: ‘uuid’
[18:01:00.462]   - Field: ‘seed’
[18:01:00.463]   - Field: ‘version’
[18:01:00.463]   - Field: ‘result’
[18:01:00.463]   - Field: ‘asynchronous’
[18:01:00.464]   - Field: ‘calls’
[18:01:00.469]   - Field: ‘globals’
[18:01:00.470]   - Field: ‘stdout’
[18:01:00.470]   - Field: ‘earlySignal’
[18:01:00.471]   - Field: ‘lazy’
[18:01:00.471]   - Field: ‘state’
[18:01:00.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.473] - Launch lazy future ...
[18:01:00.474] Packages needed by the future expression (n = 0): <none>
[18:01:00.475] Packages needed by future strategies (n = 0): <none>
[18:01:00.477] {
[18:01:00.477]     {
[18:01:00.477]         {
[18:01:00.477]             ...future.startTime <- base::Sys.time()
[18:01:00.477]             {
[18:01:00.477]                 {
[18:01:00.477]                   {
[18:01:00.477]                     {
[18:01:00.477]                       base::local({
[18:01:00.477]                         has_future <- base::requireNamespace("future", 
[18:01:00.477]                           quietly = TRUE)
[18:01:00.477]                         if (has_future) {
[18:01:00.477]                           ns <- base::getNamespace("future")
[18:01:00.477]                           version <- ns[[".package"]][["version"]]
[18:01:00.477]                           if (is.null(version)) 
[18:01:00.477]                             version <- utils::packageVersion("future")
[18:01:00.477]                         }
[18:01:00.477]                         else {
[18:01:00.477]                           version <- NULL
[18:01:00.477]                         }
[18:01:00.477]                         if (!has_future || version < "1.8.0") {
[18:01:00.477]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.477]                             "", base::R.version$version.string), 
[18:01:00.477]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.477]                               "release", "version")], collapse = " "), 
[18:01:00.477]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.477]                             info)
[18:01:00.477]                           info <- base::paste(info, collapse = "; ")
[18:01:00.477]                           if (!has_future) {
[18:01:00.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.477]                               info)
[18:01:00.477]                           }
[18:01:00.477]                           else {
[18:01:00.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.477]                               info, version)
[18:01:00.477]                           }
[18:01:00.477]                           base::stop(msg)
[18:01:00.477]                         }
[18:01:00.477]                       })
[18:01:00.477]                     }
[18:01:00.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.477]                     base::options(mc.cores = 1L)
[18:01:00.477]                   }
[18:01:00.477]                   ...future.strategy.old <- future::plan("list")
[18:01:00.477]                   options(future.plan = NULL)
[18:01:00.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.477]                 }
[18:01:00.477]                 ...future.workdir <- getwd()
[18:01:00.477]             }
[18:01:00.477]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.477]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.477]         }
[18:01:00.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.477]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:00.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.477]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.477]             base::names(...future.oldOptions))
[18:01:00.477]     }
[18:01:00.477]     if (FALSE) {
[18:01:00.477]     }
[18:01:00.477]     else {
[18:01:00.477]         if (TRUE) {
[18:01:00.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.477]                 open = "w")
[18:01:00.477]         }
[18:01:00.477]         else {
[18:01:00.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.477]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.477]         }
[18:01:00.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.477]             base::sink(type = "output", split = FALSE)
[18:01:00.477]             base::close(...future.stdout)
[18:01:00.477]         }, add = TRUE)
[18:01:00.477]     }
[18:01:00.477]     ...future.frame <- base::sys.nframe()
[18:01:00.477]     ...future.conditions <- base::list()
[18:01:00.477]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.477]     if (FALSE) {
[18:01:00.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.477]     }
[18:01:00.477]     ...future.result <- base::tryCatch({
[18:01:00.477]         base::withCallingHandlers({
[18:01:00.477]             ...future.value <- base::withVisible(base::local({
[18:01:00.477]                 withCallingHandlers({
[18:01:00.477]                   {
[18:01:00.477]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.477]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.477]                       ...future.globals.maxSize)) {
[18:01:00.477]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.477]                       on.exit(options(oopts), add = TRUE)
[18:01:00.477]                     }
[18:01:00.477]                     {
[18:01:00.477]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.477]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.477]                         USE.NAMES = FALSE)
[18:01:00.477]                       do.call(mapply, args = args)
[18:01:00.477]                     }
[18:01:00.477]                   }
[18:01:00.477]                 }, immediateCondition = function(cond) {
[18:01:00.477]                   save_rds <- function (object, pathname, ...) 
[18:01:00.477]                   {
[18:01:00.477]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.477]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.477]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.477]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.477]                         fi_tmp[["mtime"]])
[18:01:00.477]                     }
[18:01:00.477]                     tryCatch({
[18:01:00.477]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.477]                     }, error = function(ex) {
[18:01:00.477]                       msg <- conditionMessage(ex)
[18:01:00.477]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.477]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.477]                         fi_tmp[["mtime"]], msg)
[18:01:00.477]                       ex$message <- msg
[18:01:00.477]                       stop(ex)
[18:01:00.477]                     })
[18:01:00.477]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.477]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.477]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.477]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.477]                       fi <- file.info(pathname)
[18:01:00.477]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.477]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.477]                         fi[["size"]], fi[["mtime"]])
[18:01:00.477]                       stop(msg)
[18:01:00.477]                     }
[18:01:00.477]                     invisible(pathname)
[18:01:00.477]                   }
[18:01:00.477]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.477]                     rootPath = tempdir()) 
[18:01:00.477]                   {
[18:01:00.477]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.477]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.477]                       tmpdir = path, fileext = ".rds")
[18:01:00.477]                     save_rds(obj, file)
[18:01:00.477]                   }
[18:01:00.477]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.477]                   {
[18:01:00.477]                     inherits <- base::inherits
[18:01:00.477]                     invokeRestart <- base::invokeRestart
[18:01:00.477]                     is.null <- base::is.null
[18:01:00.477]                     muffled <- FALSE
[18:01:00.477]                     if (inherits(cond, "message")) {
[18:01:00.477]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.477]                       if (muffled) 
[18:01:00.477]                         invokeRestart("muffleMessage")
[18:01:00.477]                     }
[18:01:00.477]                     else if (inherits(cond, "warning")) {
[18:01:00.477]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.477]                       if (muffled) 
[18:01:00.477]                         invokeRestart("muffleWarning")
[18:01:00.477]                     }
[18:01:00.477]                     else if (inherits(cond, "condition")) {
[18:01:00.477]                       if (!is.null(pattern)) {
[18:01:00.477]                         computeRestarts <- base::computeRestarts
[18:01:00.477]                         grepl <- base::grepl
[18:01:00.477]                         restarts <- computeRestarts(cond)
[18:01:00.477]                         for (restart in restarts) {
[18:01:00.477]                           name <- restart$name
[18:01:00.477]                           if (is.null(name)) 
[18:01:00.477]                             next
[18:01:00.477]                           if (!grepl(pattern, name)) 
[18:01:00.477]                             next
[18:01:00.477]                           invokeRestart(restart)
[18:01:00.477]                           muffled <- TRUE
[18:01:00.477]                           break
[18:01:00.477]                         }
[18:01:00.477]                       }
[18:01:00.477]                     }
[18:01:00.477]                     invisible(muffled)
[18:01:00.477]                   }
[18:01:00.477]                   muffleCondition(cond)
[18:01:00.477]                 })
[18:01:00.477]             }))
[18:01:00.477]             future::FutureResult(value = ...future.value$value, 
[18:01:00.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.477]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.477]                     ...future.globalenv.names))
[18:01:00.477]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.477]         }, condition = base::local({
[18:01:00.477]             c <- base::c
[18:01:00.477]             inherits <- base::inherits
[18:01:00.477]             invokeRestart <- base::invokeRestart
[18:01:00.477]             length <- base::length
[18:01:00.477]             list <- base::list
[18:01:00.477]             seq.int <- base::seq.int
[18:01:00.477]             signalCondition <- base::signalCondition
[18:01:00.477]             sys.calls <- base::sys.calls
[18:01:00.477]             `[[` <- base::`[[`
[18:01:00.477]             `+` <- base::`+`
[18:01:00.477]             `<<-` <- base::`<<-`
[18:01:00.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.477]                   3L)]
[18:01:00.477]             }
[18:01:00.477]             function(cond) {
[18:01:00.477]                 is_error <- inherits(cond, "error")
[18:01:00.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.477]                   NULL)
[18:01:00.477]                 if (is_error) {
[18:01:00.477]                   sessionInformation <- function() {
[18:01:00.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.477]                       search = base::search(), system = base::Sys.info())
[18:01:00.477]                   }
[18:01:00.477]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.477]                     cond$call), session = sessionInformation(), 
[18:01:00.477]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.477]                   signalCondition(cond)
[18:01:00.477]                 }
[18:01:00.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.477]                 "immediateCondition"))) {
[18:01:00.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.477]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.477]                   if (TRUE && !signal) {
[18:01:00.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.477]                     {
[18:01:00.477]                       inherits <- base::inherits
[18:01:00.477]                       invokeRestart <- base::invokeRestart
[18:01:00.477]                       is.null <- base::is.null
[18:01:00.477]                       muffled <- FALSE
[18:01:00.477]                       if (inherits(cond, "message")) {
[18:01:00.477]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.477]                         if (muffled) 
[18:01:00.477]                           invokeRestart("muffleMessage")
[18:01:00.477]                       }
[18:01:00.477]                       else if (inherits(cond, "warning")) {
[18:01:00.477]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.477]                         if (muffled) 
[18:01:00.477]                           invokeRestart("muffleWarning")
[18:01:00.477]                       }
[18:01:00.477]                       else if (inherits(cond, "condition")) {
[18:01:00.477]                         if (!is.null(pattern)) {
[18:01:00.477]                           computeRestarts <- base::computeRestarts
[18:01:00.477]                           grepl <- base::grepl
[18:01:00.477]                           restarts <- computeRestarts(cond)
[18:01:00.477]                           for (restart in restarts) {
[18:01:00.477]                             name <- restart$name
[18:01:00.477]                             if (is.null(name)) 
[18:01:00.477]                               next
[18:01:00.477]                             if (!grepl(pattern, name)) 
[18:01:00.477]                               next
[18:01:00.477]                             invokeRestart(restart)
[18:01:00.477]                             muffled <- TRUE
[18:01:00.477]                             break
[18:01:00.477]                           }
[18:01:00.477]                         }
[18:01:00.477]                       }
[18:01:00.477]                       invisible(muffled)
[18:01:00.477]                     }
[18:01:00.477]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.477]                   }
[18:01:00.477]                 }
[18:01:00.477]                 else {
[18:01:00.477]                   if (TRUE) {
[18:01:00.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.477]                     {
[18:01:00.477]                       inherits <- base::inherits
[18:01:00.477]                       invokeRestart <- base::invokeRestart
[18:01:00.477]                       is.null <- base::is.null
[18:01:00.477]                       muffled <- FALSE
[18:01:00.477]                       if (inherits(cond, "message")) {
[18:01:00.477]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.477]                         if (muffled) 
[18:01:00.477]                           invokeRestart("muffleMessage")
[18:01:00.477]                       }
[18:01:00.477]                       else if (inherits(cond, "warning")) {
[18:01:00.477]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.477]                         if (muffled) 
[18:01:00.477]                           invokeRestart("muffleWarning")
[18:01:00.477]                       }
[18:01:00.477]                       else if (inherits(cond, "condition")) {
[18:01:00.477]                         if (!is.null(pattern)) {
[18:01:00.477]                           computeRestarts <- base::computeRestarts
[18:01:00.477]                           grepl <- base::grepl
[18:01:00.477]                           restarts <- computeRestarts(cond)
[18:01:00.477]                           for (restart in restarts) {
[18:01:00.477]                             name <- restart$name
[18:01:00.477]                             if (is.null(name)) 
[18:01:00.477]                               next
[18:01:00.477]                             if (!grepl(pattern, name)) 
[18:01:00.477]                               next
[18:01:00.477]                             invokeRestart(restart)
[18:01:00.477]                             muffled <- TRUE
[18:01:00.477]                             break
[18:01:00.477]                           }
[18:01:00.477]                         }
[18:01:00.477]                       }
[18:01:00.477]                       invisible(muffled)
[18:01:00.477]                     }
[18:01:00.477]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.477]                   }
[18:01:00.477]                 }
[18:01:00.477]             }
[18:01:00.477]         }))
[18:01:00.477]     }, error = function(ex) {
[18:01:00.477]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.477]                 ...future.rng), started = ...future.startTime, 
[18:01:00.477]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.477]             version = "1.8"), class = "FutureResult")
[18:01:00.477]     }, finally = {
[18:01:00.477]         if (!identical(...future.workdir, getwd())) 
[18:01:00.477]             setwd(...future.workdir)
[18:01:00.477]         {
[18:01:00.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.477]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.477]             }
[18:01:00.477]             base::options(...future.oldOptions)
[18:01:00.477]             if (.Platform$OS.type == "windows") {
[18:01:00.477]                 old_names <- names(...future.oldEnvVars)
[18:01:00.477]                 envs <- base::Sys.getenv()
[18:01:00.477]                 names <- names(envs)
[18:01:00.477]                 common <- intersect(names, old_names)
[18:01:00.477]                 added <- setdiff(names, old_names)
[18:01:00.477]                 removed <- setdiff(old_names, names)
[18:01:00.477]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.477]                   envs[common]]
[18:01:00.477]                 NAMES <- toupper(changed)
[18:01:00.477]                 args <- list()
[18:01:00.477]                 for (kk in seq_along(NAMES)) {
[18:01:00.477]                   name <- changed[[kk]]
[18:01:00.477]                   NAME <- NAMES[[kk]]
[18:01:00.477]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.477]                     next
[18:01:00.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.477]                 }
[18:01:00.477]                 NAMES <- toupper(added)
[18:01:00.477]                 for (kk in seq_along(NAMES)) {
[18:01:00.477]                   name <- added[[kk]]
[18:01:00.477]                   NAME <- NAMES[[kk]]
[18:01:00.477]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.477]                     next
[18:01:00.477]                   args[[name]] <- ""
[18:01:00.477]                 }
[18:01:00.477]                 NAMES <- toupper(removed)
[18:01:00.477]                 for (kk in seq_along(NAMES)) {
[18:01:00.477]                   name <- removed[[kk]]
[18:01:00.477]                   NAME <- NAMES[[kk]]
[18:01:00.477]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.477]                     next
[18:01:00.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.477]                 }
[18:01:00.477]                 if (length(args) > 0) 
[18:01:00.477]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.477]             }
[18:01:00.477]             else {
[18:01:00.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.477]             }
[18:01:00.477]             {
[18:01:00.477]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.477]                   0L) {
[18:01:00.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.477]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.477]                   base::options(opts)
[18:01:00.477]                 }
[18:01:00.477]                 {
[18:01:00.477]                   {
[18:01:00.477]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.477]                     NULL
[18:01:00.477]                   }
[18:01:00.477]                   options(future.plan = NULL)
[18:01:00.477]                   if (is.na(NA_character_)) 
[18:01:00.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.477]                     .init = FALSE)
[18:01:00.477]                 }
[18:01:00.477]             }
[18:01:00.477]         }
[18:01:00.477]     })
[18:01:00.477]     if (TRUE) {
[18:01:00.477]         base::sink(type = "output", split = FALSE)
[18:01:00.477]         if (TRUE) {
[18:01:00.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.477]         }
[18:01:00.477]         else {
[18:01:00.477]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.477]         }
[18:01:00.477]         base::close(...future.stdout)
[18:01:00.477]         ...future.stdout <- NULL
[18:01:00.477]     }
[18:01:00.477]     ...future.result$conditions <- ...future.conditions
[18:01:00.477]     ...future.result$finished <- base::Sys.time()
[18:01:00.477]     ...future.result
[18:01:00.477] }
[18:01:00.484] assign_globals() ...
[18:01:00.484] List of 5
[18:01:00.484]  $ ...future.FUN            :function (C, k)  
[18:01:00.484]  $ MoreArgs                 : NULL
[18:01:00.484]  $ ...future.elements_ii    :List of 2
[18:01:00.484]   ..$ :List of 1
[18:01:00.484]   .. ..$ : chr "B"
[18:01:00.484]   ..$ :List of 1
[18:01:00.484]   .. ..$ : int 4
[18:01:00.484]  $ ...future.seeds_ii       : NULL
[18:01:00.484]  $ ...future.globals.maxSize: NULL
[18:01:00.484]  - attr(*, "where")=List of 5
[18:01:00.484]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.484]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.484]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.484]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.484]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.484]  - attr(*, "resolved")= logi FALSE
[18:01:00.484]  - attr(*, "total_size")= num 3488
[18:01:00.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.484]  - attr(*, "already-done")= logi TRUE
[18:01:00.503] - reassign environment for ‘...future.FUN’
[18:01:00.503] - copied ‘...future.FUN’ to environment
[18:01:00.504] - copied ‘MoreArgs’ to environment
[18:01:00.504] - copied ‘...future.elements_ii’ to environment
[18:01:00.504] - copied ‘...future.seeds_ii’ to environment
[18:01:00.505] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.505] assign_globals() ... done
[18:01:00.505] requestCore(): workers = 2
[18:01:00.509] MulticoreFuture started
[18:01:00.510] - Launch lazy future ... done
[18:01:00.510] run() for ‘MulticoreFuture’ ... done
[18:01:00.511] Created future:
[18:01:00.511] plan(): Setting new future strategy stack:
[18:01:00.511] List of future strategies:
[18:01:00.511] 1. sequential:
[18:01:00.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.511]    - tweaked: FALSE
[18:01:00.511]    - call: NULL
[18:01:00.513] plan(): nbrOfWorkers() = 1
[18:01:00.517] plan(): Setting new future strategy stack:
[18:01:00.518] List of future strategies:
[18:01:00.518] 1. multicore:
[18:01:00.518]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.518]    - tweaked: FALSE
[18:01:00.518]    - call: plan(strategy)
[18:01:00.511] MulticoreFuture:
[18:01:00.511] Label: ‘future_mapply-2’
[18:01:00.511] Expression:
[18:01:00.511] {
[18:01:00.511]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.511]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.511]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.511]         on.exit(options(oopts), add = TRUE)
[18:01:00.511]     }
[18:01:00.511]     {
[18:01:00.511]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.511]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.511]         do.call(mapply, args = args)
[18:01:00.511]     }
[18:01:00.511] }
[18:01:00.511] Lazy evaluation: FALSE
[18:01:00.511] Asynchronous evaluation: TRUE
[18:01:00.511] Local evaluation: TRUE
[18:01:00.511] Environment: R_GlobalEnv
[18:01:00.511] Capture standard output: TRUE
[18:01:00.511] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.511] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.511] Packages: <none>
[18:01:00.511] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.511] Resolved: FALSE
[18:01:00.511] Value: <not collected>
[18:01:00.511] Conditions captured: <none>
[18:01:00.511] Early signaling: FALSE
[18:01:00.511] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.511] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.526] Chunk #2 of 5 ... DONE
[18:01:00.527] Chunk #3 of 5 ...
[18:01:00.527] plan(): nbrOfWorkers() = 2
[18:01:00.527]  - Finding globals in '...' for chunk #3 ...
[18:01:00.527] getGlobalsAndPackages() ...
[18:01:00.528] Searching for globals...
[18:01:00.529] 
[18:01:00.529] Searching for globals ... DONE
[18:01:00.529] - globals: [0] <none>
[18:01:00.530] getGlobalsAndPackages() ... DONE
[18:01:00.530]    + additional globals found: [n=0] 
[18:01:00.530]    + additional namespaces needed: [n=0] 
[18:01:00.530]  - Finding globals in '...' for chunk #3 ... DONE
[18:01:00.531]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:00.531]  - seeds: <none>
[18:01:00.531]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.532] getGlobalsAndPackages() ...
[18:01:00.532] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.533] Resolving globals: FALSE
[18:01:00.534] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:00.536] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:00.536] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.537] 
[18:01:00.537] getGlobalsAndPackages() ... DONE
[18:01:00.538] run() for ‘Future’ ...
[18:01:00.538] - state: ‘created’
[18:01:00.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.547] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.547] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.548]   - Field: ‘label’
[18:01:00.548]   - Field: ‘local’
[18:01:00.548]   - Field: ‘owner’
[18:01:00.549]   - Field: ‘envir’
[18:01:00.549]   - Field: ‘workers’
[18:01:00.549]   - Field: ‘packages’
[18:01:00.550]   - Field: ‘gc’
[18:01:00.550]   - Field: ‘job’
[18:01:00.550]   - Field: ‘conditions’
[18:01:00.551]   - Field: ‘expr’
[18:01:00.551]   - Field: ‘uuid’
[18:01:00.551]   - Field: ‘seed’
[18:01:00.552]   - Field: ‘version’
[18:01:00.552]   - Field: ‘result’
[18:01:00.552]   - Field: ‘asynchronous’
[18:01:00.553]   - Field: ‘calls’
[18:01:00.553]   - Field: ‘globals’
[18:01:00.553]   - Field: ‘stdout’
[18:01:00.554]   - Field: ‘earlySignal’
[18:01:00.554]   - Field: ‘lazy’
[18:01:00.554]   - Field: ‘state’
[18:01:00.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.555] - Launch lazy future ...
[18:01:00.556] Packages needed by the future expression (n = 0): <none>
[18:01:00.556] Packages needed by future strategies (n = 0): <none>
[18:01:00.558] {
[18:01:00.558]     {
[18:01:00.558]         {
[18:01:00.558]             ...future.startTime <- base::Sys.time()
[18:01:00.558]             {
[18:01:00.558]                 {
[18:01:00.558]                   {
[18:01:00.558]                     {
[18:01:00.558]                       base::local({
[18:01:00.558]                         has_future <- base::requireNamespace("future", 
[18:01:00.558]                           quietly = TRUE)
[18:01:00.558]                         if (has_future) {
[18:01:00.558]                           ns <- base::getNamespace("future")
[18:01:00.558]                           version <- ns[[".package"]][["version"]]
[18:01:00.558]                           if (is.null(version)) 
[18:01:00.558]                             version <- utils::packageVersion("future")
[18:01:00.558]                         }
[18:01:00.558]                         else {
[18:01:00.558]                           version <- NULL
[18:01:00.558]                         }
[18:01:00.558]                         if (!has_future || version < "1.8.0") {
[18:01:00.558]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.558]                             "", base::R.version$version.string), 
[18:01:00.558]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.558]                               "release", "version")], collapse = " "), 
[18:01:00.558]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.558]                             info)
[18:01:00.558]                           info <- base::paste(info, collapse = "; ")
[18:01:00.558]                           if (!has_future) {
[18:01:00.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.558]                               info)
[18:01:00.558]                           }
[18:01:00.558]                           else {
[18:01:00.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.558]                               info, version)
[18:01:00.558]                           }
[18:01:00.558]                           base::stop(msg)
[18:01:00.558]                         }
[18:01:00.558]                       })
[18:01:00.558]                     }
[18:01:00.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.558]                     base::options(mc.cores = 1L)
[18:01:00.558]                   }
[18:01:00.558]                   ...future.strategy.old <- future::plan("list")
[18:01:00.558]                   options(future.plan = NULL)
[18:01:00.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.558]                 }
[18:01:00.558]                 ...future.workdir <- getwd()
[18:01:00.558]             }
[18:01:00.558]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.558]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.558]         }
[18:01:00.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.558]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:00.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.558]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.558]             base::names(...future.oldOptions))
[18:01:00.558]     }
[18:01:00.558]     if (FALSE) {
[18:01:00.558]     }
[18:01:00.558]     else {
[18:01:00.558]         if (TRUE) {
[18:01:00.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.558]                 open = "w")
[18:01:00.558]         }
[18:01:00.558]         else {
[18:01:00.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.558]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.558]         }
[18:01:00.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.558]             base::sink(type = "output", split = FALSE)
[18:01:00.558]             base::close(...future.stdout)
[18:01:00.558]         }, add = TRUE)
[18:01:00.558]     }
[18:01:00.558]     ...future.frame <- base::sys.nframe()
[18:01:00.558]     ...future.conditions <- base::list()
[18:01:00.558]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.558]     if (FALSE) {
[18:01:00.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.558]     }
[18:01:00.558]     ...future.result <- base::tryCatch({
[18:01:00.558]         base::withCallingHandlers({
[18:01:00.558]             ...future.value <- base::withVisible(base::local({
[18:01:00.558]                 withCallingHandlers({
[18:01:00.558]                   {
[18:01:00.558]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.558]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.558]                       ...future.globals.maxSize)) {
[18:01:00.558]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.558]                       on.exit(options(oopts), add = TRUE)
[18:01:00.558]                     }
[18:01:00.558]                     {
[18:01:00.558]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.558]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.558]                         USE.NAMES = FALSE)
[18:01:00.558]                       do.call(mapply, args = args)
[18:01:00.558]                     }
[18:01:00.558]                   }
[18:01:00.558]                 }, immediateCondition = function(cond) {
[18:01:00.558]                   save_rds <- function (object, pathname, ...) 
[18:01:00.558]                   {
[18:01:00.558]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.558]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.558]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.558]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.558]                         fi_tmp[["mtime"]])
[18:01:00.558]                     }
[18:01:00.558]                     tryCatch({
[18:01:00.558]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.558]                     }, error = function(ex) {
[18:01:00.558]                       msg <- conditionMessage(ex)
[18:01:00.558]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.558]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.558]                         fi_tmp[["mtime"]], msg)
[18:01:00.558]                       ex$message <- msg
[18:01:00.558]                       stop(ex)
[18:01:00.558]                     })
[18:01:00.558]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.558]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.558]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.558]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.558]                       fi <- file.info(pathname)
[18:01:00.558]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.558]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.558]                         fi[["size"]], fi[["mtime"]])
[18:01:00.558]                       stop(msg)
[18:01:00.558]                     }
[18:01:00.558]                     invisible(pathname)
[18:01:00.558]                   }
[18:01:00.558]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.558]                     rootPath = tempdir()) 
[18:01:00.558]                   {
[18:01:00.558]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.558]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.558]                       tmpdir = path, fileext = ".rds")
[18:01:00.558]                     save_rds(obj, file)
[18:01:00.558]                   }
[18:01:00.558]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.558]                   {
[18:01:00.558]                     inherits <- base::inherits
[18:01:00.558]                     invokeRestart <- base::invokeRestart
[18:01:00.558]                     is.null <- base::is.null
[18:01:00.558]                     muffled <- FALSE
[18:01:00.558]                     if (inherits(cond, "message")) {
[18:01:00.558]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.558]                       if (muffled) 
[18:01:00.558]                         invokeRestart("muffleMessage")
[18:01:00.558]                     }
[18:01:00.558]                     else if (inherits(cond, "warning")) {
[18:01:00.558]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.558]                       if (muffled) 
[18:01:00.558]                         invokeRestart("muffleWarning")
[18:01:00.558]                     }
[18:01:00.558]                     else if (inherits(cond, "condition")) {
[18:01:00.558]                       if (!is.null(pattern)) {
[18:01:00.558]                         computeRestarts <- base::computeRestarts
[18:01:00.558]                         grepl <- base::grepl
[18:01:00.558]                         restarts <- computeRestarts(cond)
[18:01:00.558]                         for (restart in restarts) {
[18:01:00.558]                           name <- restart$name
[18:01:00.558]                           if (is.null(name)) 
[18:01:00.558]                             next
[18:01:00.558]                           if (!grepl(pattern, name)) 
[18:01:00.558]                             next
[18:01:00.558]                           invokeRestart(restart)
[18:01:00.558]                           muffled <- TRUE
[18:01:00.558]                           break
[18:01:00.558]                         }
[18:01:00.558]                       }
[18:01:00.558]                     }
[18:01:00.558]                     invisible(muffled)
[18:01:00.558]                   }
[18:01:00.558]                   muffleCondition(cond)
[18:01:00.558]                 })
[18:01:00.558]             }))
[18:01:00.558]             future::FutureResult(value = ...future.value$value, 
[18:01:00.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.558]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.558]                     ...future.globalenv.names))
[18:01:00.558]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.558]         }, condition = base::local({
[18:01:00.558]             c <- base::c
[18:01:00.558]             inherits <- base::inherits
[18:01:00.558]             invokeRestart <- base::invokeRestart
[18:01:00.558]             length <- base::length
[18:01:00.558]             list <- base::list
[18:01:00.558]             seq.int <- base::seq.int
[18:01:00.558]             signalCondition <- base::signalCondition
[18:01:00.558]             sys.calls <- base::sys.calls
[18:01:00.558]             `[[` <- base::`[[`
[18:01:00.558]             `+` <- base::`+`
[18:01:00.558]             `<<-` <- base::`<<-`
[18:01:00.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.558]                   3L)]
[18:01:00.558]             }
[18:01:00.558]             function(cond) {
[18:01:00.558]                 is_error <- inherits(cond, "error")
[18:01:00.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.558]                   NULL)
[18:01:00.558]                 if (is_error) {
[18:01:00.558]                   sessionInformation <- function() {
[18:01:00.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.558]                       search = base::search(), system = base::Sys.info())
[18:01:00.558]                   }
[18:01:00.558]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.558]                     cond$call), session = sessionInformation(), 
[18:01:00.558]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.558]                   signalCondition(cond)
[18:01:00.558]                 }
[18:01:00.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.558]                 "immediateCondition"))) {
[18:01:00.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.558]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.558]                   if (TRUE && !signal) {
[18:01:00.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.558]                     {
[18:01:00.558]                       inherits <- base::inherits
[18:01:00.558]                       invokeRestart <- base::invokeRestart
[18:01:00.558]                       is.null <- base::is.null
[18:01:00.558]                       muffled <- FALSE
[18:01:00.558]                       if (inherits(cond, "message")) {
[18:01:00.558]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.558]                         if (muffled) 
[18:01:00.558]                           invokeRestart("muffleMessage")
[18:01:00.558]                       }
[18:01:00.558]                       else if (inherits(cond, "warning")) {
[18:01:00.558]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.558]                         if (muffled) 
[18:01:00.558]                           invokeRestart("muffleWarning")
[18:01:00.558]                       }
[18:01:00.558]                       else if (inherits(cond, "condition")) {
[18:01:00.558]                         if (!is.null(pattern)) {
[18:01:00.558]                           computeRestarts <- base::computeRestarts
[18:01:00.558]                           grepl <- base::grepl
[18:01:00.558]                           restarts <- computeRestarts(cond)
[18:01:00.558]                           for (restart in restarts) {
[18:01:00.558]                             name <- restart$name
[18:01:00.558]                             if (is.null(name)) 
[18:01:00.558]                               next
[18:01:00.558]                             if (!grepl(pattern, name)) 
[18:01:00.558]                               next
[18:01:00.558]                             invokeRestart(restart)
[18:01:00.558]                             muffled <- TRUE
[18:01:00.558]                             break
[18:01:00.558]                           }
[18:01:00.558]                         }
[18:01:00.558]                       }
[18:01:00.558]                       invisible(muffled)
[18:01:00.558]                     }
[18:01:00.558]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.558]                   }
[18:01:00.558]                 }
[18:01:00.558]                 else {
[18:01:00.558]                   if (TRUE) {
[18:01:00.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.558]                     {
[18:01:00.558]                       inherits <- base::inherits
[18:01:00.558]                       invokeRestart <- base::invokeRestart
[18:01:00.558]                       is.null <- base::is.null
[18:01:00.558]                       muffled <- FALSE
[18:01:00.558]                       if (inherits(cond, "message")) {
[18:01:00.558]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.558]                         if (muffled) 
[18:01:00.558]                           invokeRestart("muffleMessage")
[18:01:00.558]                       }
[18:01:00.558]                       else if (inherits(cond, "warning")) {
[18:01:00.558]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.558]                         if (muffled) 
[18:01:00.558]                           invokeRestart("muffleWarning")
[18:01:00.558]                       }
[18:01:00.558]                       else if (inherits(cond, "condition")) {
[18:01:00.558]                         if (!is.null(pattern)) {
[18:01:00.558]                           computeRestarts <- base::computeRestarts
[18:01:00.558]                           grepl <- base::grepl
[18:01:00.558]                           restarts <- computeRestarts(cond)
[18:01:00.558]                           for (restart in restarts) {
[18:01:00.558]                             name <- restart$name
[18:01:00.558]                             if (is.null(name)) 
[18:01:00.558]                               next
[18:01:00.558]                             if (!grepl(pattern, name)) 
[18:01:00.558]                               next
[18:01:00.558]                             invokeRestart(restart)
[18:01:00.558]                             muffled <- TRUE
[18:01:00.558]                             break
[18:01:00.558]                           }
[18:01:00.558]                         }
[18:01:00.558]                       }
[18:01:00.558]                       invisible(muffled)
[18:01:00.558]                     }
[18:01:00.558]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.558]                   }
[18:01:00.558]                 }
[18:01:00.558]             }
[18:01:00.558]         }))
[18:01:00.558]     }, error = function(ex) {
[18:01:00.558]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.558]                 ...future.rng), started = ...future.startTime, 
[18:01:00.558]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.558]             version = "1.8"), class = "FutureResult")
[18:01:00.558]     }, finally = {
[18:01:00.558]         if (!identical(...future.workdir, getwd())) 
[18:01:00.558]             setwd(...future.workdir)
[18:01:00.558]         {
[18:01:00.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.558]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.558]             }
[18:01:00.558]             base::options(...future.oldOptions)
[18:01:00.558]             if (.Platform$OS.type == "windows") {
[18:01:00.558]                 old_names <- names(...future.oldEnvVars)
[18:01:00.558]                 envs <- base::Sys.getenv()
[18:01:00.558]                 names <- names(envs)
[18:01:00.558]                 common <- intersect(names, old_names)
[18:01:00.558]                 added <- setdiff(names, old_names)
[18:01:00.558]                 removed <- setdiff(old_names, names)
[18:01:00.558]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.558]                   envs[common]]
[18:01:00.558]                 NAMES <- toupper(changed)
[18:01:00.558]                 args <- list()
[18:01:00.558]                 for (kk in seq_along(NAMES)) {
[18:01:00.558]                   name <- changed[[kk]]
[18:01:00.558]                   NAME <- NAMES[[kk]]
[18:01:00.558]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.558]                     next
[18:01:00.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.558]                 }
[18:01:00.558]                 NAMES <- toupper(added)
[18:01:00.558]                 for (kk in seq_along(NAMES)) {
[18:01:00.558]                   name <- added[[kk]]
[18:01:00.558]                   NAME <- NAMES[[kk]]
[18:01:00.558]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.558]                     next
[18:01:00.558]                   args[[name]] <- ""
[18:01:00.558]                 }
[18:01:00.558]                 NAMES <- toupper(removed)
[18:01:00.558]                 for (kk in seq_along(NAMES)) {
[18:01:00.558]                   name <- removed[[kk]]
[18:01:00.558]                   NAME <- NAMES[[kk]]
[18:01:00.558]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.558]                     next
[18:01:00.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.558]                 }
[18:01:00.558]                 if (length(args) > 0) 
[18:01:00.558]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.558]             }
[18:01:00.558]             else {
[18:01:00.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.558]             }
[18:01:00.558]             {
[18:01:00.558]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.558]                   0L) {
[18:01:00.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.558]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.558]                   base::options(opts)
[18:01:00.558]                 }
[18:01:00.558]                 {
[18:01:00.558]                   {
[18:01:00.558]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.558]                     NULL
[18:01:00.558]                   }
[18:01:00.558]                   options(future.plan = NULL)
[18:01:00.558]                   if (is.na(NA_character_)) 
[18:01:00.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.558]                     .init = FALSE)
[18:01:00.558]                 }
[18:01:00.558]             }
[18:01:00.558]         }
[18:01:00.558]     })
[18:01:00.558]     if (TRUE) {
[18:01:00.558]         base::sink(type = "output", split = FALSE)
[18:01:00.558]         if (TRUE) {
[18:01:00.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.558]         }
[18:01:00.558]         else {
[18:01:00.558]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.558]         }
[18:01:00.558]         base::close(...future.stdout)
[18:01:00.558]         ...future.stdout <- NULL
[18:01:00.558]     }
[18:01:00.558]     ...future.result$conditions <- ...future.conditions
[18:01:00.558]     ...future.result$finished <- base::Sys.time()
[18:01:00.558]     ...future.result
[18:01:00.558] }
[18:01:00.564] assign_globals() ...
[18:01:00.564] List of 5
[18:01:00.564]  $ ...future.FUN            :function (C, k)  
[18:01:00.564]  $ MoreArgs                 : NULL
[18:01:00.564]  $ ...future.elements_ii    :List of 2
[18:01:00.564]   ..$ :List of 1
[18:01:00.564]   .. ..$ : chr "C"
[18:01:00.564]   ..$ :List of 1
[18:01:00.564]   .. ..$ : int 3
[18:01:00.564]  $ ...future.seeds_ii       : NULL
[18:01:00.564]  $ ...future.globals.maxSize: NULL
[18:01:00.564]  - attr(*, "where")=List of 5
[18:01:00.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.564]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.564]  - attr(*, "resolved")= logi FALSE
[18:01:00.564]  - attr(*, "total_size")= num 3488
[18:01:00.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.564]  - attr(*, "already-done")= logi TRUE
[18:01:00.588] - reassign environment for ‘...future.FUN’
[18:01:00.588] - copied ‘...future.FUN’ to environment
[18:01:00.589] - copied ‘MoreArgs’ to environment
[18:01:00.589] - copied ‘...future.elements_ii’ to environment
[18:01:00.589] - copied ‘...future.seeds_ii’ to environment
[18:01:00.590] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.590] assign_globals() ... done
[18:01:00.590] requestCore(): workers = 2
[18:01:00.591] Poll #1 (0): usedCores() = 2, workers = 2
[18:01:00.602] result() for MulticoreFuture ...
[18:01:00.604] result() for MulticoreFuture ...
[18:01:00.604] result() for MulticoreFuture ... done
[18:01:00.605] result() for MulticoreFuture ... done
[18:01:00.605] result() for MulticoreFuture ...
[18:01:00.605] result() for MulticoreFuture ... done
[18:01:00.610] MulticoreFuture started
[18:01:00.611] - Launch lazy future ... done
[18:01:00.611] run() for ‘MulticoreFuture’ ... done
[18:01:00.612] Created future:
[18:01:00.612] plan(): Setting new future strategy stack:
[18:01:00.613] List of future strategies:
[18:01:00.613] 1. sequential:
[18:01:00.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.613]    - tweaked: FALSE
[18:01:00.613]    - call: NULL
[18:01:00.615] plan(): nbrOfWorkers() = 1
[18:01:00.620] plan(): Setting new future strategy stack:
[18:01:00.621] List of future strategies:
[18:01:00.621] 1. multicore:
[18:01:00.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.621]    - tweaked: FALSE
[18:01:00.621]    - call: plan(strategy)
[18:01:00.613] MulticoreFuture:
[18:01:00.613] Label: ‘future_mapply-3’
[18:01:00.613] Expression:
[18:01:00.613] {
[18:01:00.613]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.613]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.613]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.613]         on.exit(options(oopts), add = TRUE)
[18:01:00.613]     }
[18:01:00.613]     {
[18:01:00.613]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.613]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.613]         do.call(mapply, args = args)
[18:01:00.613]     }
[18:01:00.613] }
[18:01:00.613] Lazy evaluation: FALSE
[18:01:00.613] Asynchronous evaluation: TRUE
[18:01:00.613] Local evaluation: TRUE
[18:01:00.613] Environment: R_GlobalEnv
[18:01:00.613] Capture standard output: TRUE
[18:01:00.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.613] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.613] Packages: <none>
[18:01:00.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.613] Resolved: FALSE
[18:01:00.613] Value: <not collected>
[18:01:00.613] Conditions captured: <none>
[18:01:00.613] Early signaling: FALSE
[18:01:00.613] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.613] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.628] Chunk #3 of 5 ... DONE
[18:01:00.629] Chunk #4 of 5 ...
[18:01:00.629]  - Finding globals in '...' for chunk #4 ...
[18:01:00.629] getGlobalsAndPackages() ...
[18:01:00.630] Searching for globals...
[18:01:00.630] plan(): nbrOfWorkers() = 2
[18:01:00.631] 
[18:01:00.631] Searching for globals ... DONE
[18:01:00.632] - globals: [0] <none>
[18:01:00.632] getGlobalsAndPackages() ... DONE
[18:01:00.632]    + additional globals found: [n=0] 
[18:01:00.633]    + additional namespaces needed: [n=0] 
[18:01:00.633]  - Finding globals in '...' for chunk #4 ... DONE
[18:01:00.633]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:00.633]  - seeds: <none>
[18:01:00.634]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.634] getGlobalsAndPackages() ...
[18:01:00.634] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.635] Resolving globals: FALSE
[18:01:00.636] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:00.638] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:00.638] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.639] 
[18:01:00.639] getGlobalsAndPackages() ... DONE
[18:01:00.640] run() for ‘Future’ ...
[18:01:00.640] - state: ‘created’
[18:01:00.641] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.649] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.650]   - Field: ‘label’
[18:01:00.650]   - Field: ‘local’
[18:01:00.651]   - Field: ‘owner’
[18:01:00.651]   - Field: ‘envir’
[18:01:00.651]   - Field: ‘workers’
[18:01:00.651]   - Field: ‘packages’
[18:01:00.652]   - Field: ‘gc’
[18:01:00.652]   - Field: ‘job’
[18:01:00.652]   - Field: ‘conditions’
[18:01:00.653]   - Field: ‘expr’
[18:01:00.653]   - Field: ‘uuid’
[18:01:00.653]   - Field: ‘seed’
[18:01:00.654]   - Field: ‘version’
[18:01:00.654]   - Field: ‘result’
[18:01:00.654]   - Field: ‘asynchronous’
[18:01:00.655]   - Field: ‘calls’
[18:01:00.655]   - Field: ‘globals’
[18:01:00.655]   - Field: ‘stdout’
[18:01:00.655]   - Field: ‘earlySignal’
[18:01:00.656]   - Field: ‘lazy’
[18:01:00.656]   - Field: ‘state’
[18:01:00.656] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.657] - Launch lazy future ...
[18:01:00.658] Packages needed by the future expression (n = 0): <none>
[18:01:00.658] Packages needed by future strategies (n = 0): <none>
[18:01:00.660] {
[18:01:00.660]     {
[18:01:00.660]         {
[18:01:00.660]             ...future.startTime <- base::Sys.time()
[18:01:00.660]             {
[18:01:00.660]                 {
[18:01:00.660]                   {
[18:01:00.660]                     {
[18:01:00.660]                       base::local({
[18:01:00.660]                         has_future <- base::requireNamespace("future", 
[18:01:00.660]                           quietly = TRUE)
[18:01:00.660]                         if (has_future) {
[18:01:00.660]                           ns <- base::getNamespace("future")
[18:01:00.660]                           version <- ns[[".package"]][["version"]]
[18:01:00.660]                           if (is.null(version)) 
[18:01:00.660]                             version <- utils::packageVersion("future")
[18:01:00.660]                         }
[18:01:00.660]                         else {
[18:01:00.660]                           version <- NULL
[18:01:00.660]                         }
[18:01:00.660]                         if (!has_future || version < "1.8.0") {
[18:01:00.660]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.660]                             "", base::R.version$version.string), 
[18:01:00.660]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.660]                               "release", "version")], collapse = " "), 
[18:01:00.660]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.660]                             info)
[18:01:00.660]                           info <- base::paste(info, collapse = "; ")
[18:01:00.660]                           if (!has_future) {
[18:01:00.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.660]                               info)
[18:01:00.660]                           }
[18:01:00.660]                           else {
[18:01:00.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.660]                               info, version)
[18:01:00.660]                           }
[18:01:00.660]                           base::stop(msg)
[18:01:00.660]                         }
[18:01:00.660]                       })
[18:01:00.660]                     }
[18:01:00.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.660]                     base::options(mc.cores = 1L)
[18:01:00.660]                   }
[18:01:00.660]                   ...future.strategy.old <- future::plan("list")
[18:01:00.660]                   options(future.plan = NULL)
[18:01:00.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.660]                 }
[18:01:00.660]                 ...future.workdir <- getwd()
[18:01:00.660]             }
[18:01:00.660]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.660]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.660]         }
[18:01:00.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.660]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:00.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.660]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.660]             base::names(...future.oldOptions))
[18:01:00.660]     }
[18:01:00.660]     if (FALSE) {
[18:01:00.660]     }
[18:01:00.660]     else {
[18:01:00.660]         if (TRUE) {
[18:01:00.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.660]                 open = "w")
[18:01:00.660]         }
[18:01:00.660]         else {
[18:01:00.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.660]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.660]         }
[18:01:00.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.660]             base::sink(type = "output", split = FALSE)
[18:01:00.660]             base::close(...future.stdout)
[18:01:00.660]         }, add = TRUE)
[18:01:00.660]     }
[18:01:00.660]     ...future.frame <- base::sys.nframe()
[18:01:00.660]     ...future.conditions <- base::list()
[18:01:00.660]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.660]     if (FALSE) {
[18:01:00.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.660]     }
[18:01:00.660]     ...future.result <- base::tryCatch({
[18:01:00.660]         base::withCallingHandlers({
[18:01:00.660]             ...future.value <- base::withVisible(base::local({
[18:01:00.660]                 withCallingHandlers({
[18:01:00.660]                   {
[18:01:00.660]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.660]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.660]                       ...future.globals.maxSize)) {
[18:01:00.660]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.660]                       on.exit(options(oopts), add = TRUE)
[18:01:00.660]                     }
[18:01:00.660]                     {
[18:01:00.660]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.660]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.660]                         USE.NAMES = FALSE)
[18:01:00.660]                       do.call(mapply, args = args)
[18:01:00.660]                     }
[18:01:00.660]                   }
[18:01:00.660]                 }, immediateCondition = function(cond) {
[18:01:00.660]                   save_rds <- function (object, pathname, ...) 
[18:01:00.660]                   {
[18:01:00.660]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.660]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.660]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.660]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.660]                         fi_tmp[["mtime"]])
[18:01:00.660]                     }
[18:01:00.660]                     tryCatch({
[18:01:00.660]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.660]                     }, error = function(ex) {
[18:01:00.660]                       msg <- conditionMessage(ex)
[18:01:00.660]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.660]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.660]                         fi_tmp[["mtime"]], msg)
[18:01:00.660]                       ex$message <- msg
[18:01:00.660]                       stop(ex)
[18:01:00.660]                     })
[18:01:00.660]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.660]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.660]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.660]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.660]                       fi <- file.info(pathname)
[18:01:00.660]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.660]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.660]                         fi[["size"]], fi[["mtime"]])
[18:01:00.660]                       stop(msg)
[18:01:00.660]                     }
[18:01:00.660]                     invisible(pathname)
[18:01:00.660]                   }
[18:01:00.660]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.660]                     rootPath = tempdir()) 
[18:01:00.660]                   {
[18:01:00.660]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.660]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.660]                       tmpdir = path, fileext = ".rds")
[18:01:00.660]                     save_rds(obj, file)
[18:01:00.660]                   }
[18:01:00.660]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.660]                   {
[18:01:00.660]                     inherits <- base::inherits
[18:01:00.660]                     invokeRestart <- base::invokeRestart
[18:01:00.660]                     is.null <- base::is.null
[18:01:00.660]                     muffled <- FALSE
[18:01:00.660]                     if (inherits(cond, "message")) {
[18:01:00.660]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.660]                       if (muffled) 
[18:01:00.660]                         invokeRestart("muffleMessage")
[18:01:00.660]                     }
[18:01:00.660]                     else if (inherits(cond, "warning")) {
[18:01:00.660]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.660]                       if (muffled) 
[18:01:00.660]                         invokeRestart("muffleWarning")
[18:01:00.660]                     }
[18:01:00.660]                     else if (inherits(cond, "condition")) {
[18:01:00.660]                       if (!is.null(pattern)) {
[18:01:00.660]                         computeRestarts <- base::computeRestarts
[18:01:00.660]                         grepl <- base::grepl
[18:01:00.660]                         restarts <- computeRestarts(cond)
[18:01:00.660]                         for (restart in restarts) {
[18:01:00.660]                           name <- restart$name
[18:01:00.660]                           if (is.null(name)) 
[18:01:00.660]                             next
[18:01:00.660]                           if (!grepl(pattern, name)) 
[18:01:00.660]                             next
[18:01:00.660]                           invokeRestart(restart)
[18:01:00.660]                           muffled <- TRUE
[18:01:00.660]                           break
[18:01:00.660]                         }
[18:01:00.660]                       }
[18:01:00.660]                     }
[18:01:00.660]                     invisible(muffled)
[18:01:00.660]                   }
[18:01:00.660]                   muffleCondition(cond)
[18:01:00.660]                 })
[18:01:00.660]             }))
[18:01:00.660]             future::FutureResult(value = ...future.value$value, 
[18:01:00.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.660]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.660]                     ...future.globalenv.names))
[18:01:00.660]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.660]         }, condition = base::local({
[18:01:00.660]             c <- base::c
[18:01:00.660]             inherits <- base::inherits
[18:01:00.660]             invokeRestart <- base::invokeRestart
[18:01:00.660]             length <- base::length
[18:01:00.660]             list <- base::list
[18:01:00.660]             seq.int <- base::seq.int
[18:01:00.660]             signalCondition <- base::signalCondition
[18:01:00.660]             sys.calls <- base::sys.calls
[18:01:00.660]             `[[` <- base::`[[`
[18:01:00.660]             `+` <- base::`+`
[18:01:00.660]             `<<-` <- base::`<<-`
[18:01:00.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.660]                   3L)]
[18:01:00.660]             }
[18:01:00.660]             function(cond) {
[18:01:00.660]                 is_error <- inherits(cond, "error")
[18:01:00.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.660]                   NULL)
[18:01:00.660]                 if (is_error) {
[18:01:00.660]                   sessionInformation <- function() {
[18:01:00.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.660]                       search = base::search(), system = base::Sys.info())
[18:01:00.660]                   }
[18:01:00.660]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.660]                     cond$call), session = sessionInformation(), 
[18:01:00.660]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.660]                   signalCondition(cond)
[18:01:00.660]                 }
[18:01:00.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.660]                 "immediateCondition"))) {
[18:01:00.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.660]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.660]                   if (TRUE && !signal) {
[18:01:00.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.660]                     {
[18:01:00.660]                       inherits <- base::inherits
[18:01:00.660]                       invokeRestart <- base::invokeRestart
[18:01:00.660]                       is.null <- base::is.null
[18:01:00.660]                       muffled <- FALSE
[18:01:00.660]                       if (inherits(cond, "message")) {
[18:01:00.660]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.660]                         if (muffled) 
[18:01:00.660]                           invokeRestart("muffleMessage")
[18:01:00.660]                       }
[18:01:00.660]                       else if (inherits(cond, "warning")) {
[18:01:00.660]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.660]                         if (muffled) 
[18:01:00.660]                           invokeRestart("muffleWarning")
[18:01:00.660]                       }
[18:01:00.660]                       else if (inherits(cond, "condition")) {
[18:01:00.660]                         if (!is.null(pattern)) {
[18:01:00.660]                           computeRestarts <- base::computeRestarts
[18:01:00.660]                           grepl <- base::grepl
[18:01:00.660]                           restarts <- computeRestarts(cond)
[18:01:00.660]                           for (restart in restarts) {
[18:01:00.660]                             name <- restart$name
[18:01:00.660]                             if (is.null(name)) 
[18:01:00.660]                               next
[18:01:00.660]                             if (!grepl(pattern, name)) 
[18:01:00.660]                               next
[18:01:00.660]                             invokeRestart(restart)
[18:01:00.660]                             muffled <- TRUE
[18:01:00.660]                             break
[18:01:00.660]                           }
[18:01:00.660]                         }
[18:01:00.660]                       }
[18:01:00.660]                       invisible(muffled)
[18:01:00.660]                     }
[18:01:00.660]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.660]                   }
[18:01:00.660]                 }
[18:01:00.660]                 else {
[18:01:00.660]                   if (TRUE) {
[18:01:00.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.660]                     {
[18:01:00.660]                       inherits <- base::inherits
[18:01:00.660]                       invokeRestart <- base::invokeRestart
[18:01:00.660]                       is.null <- base::is.null
[18:01:00.660]                       muffled <- FALSE
[18:01:00.660]                       if (inherits(cond, "message")) {
[18:01:00.660]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.660]                         if (muffled) 
[18:01:00.660]                           invokeRestart("muffleMessage")
[18:01:00.660]                       }
[18:01:00.660]                       else if (inherits(cond, "warning")) {
[18:01:00.660]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.660]                         if (muffled) 
[18:01:00.660]                           invokeRestart("muffleWarning")
[18:01:00.660]                       }
[18:01:00.660]                       else if (inherits(cond, "condition")) {
[18:01:00.660]                         if (!is.null(pattern)) {
[18:01:00.660]                           computeRestarts <- base::computeRestarts
[18:01:00.660]                           grepl <- base::grepl
[18:01:00.660]                           restarts <- computeRestarts(cond)
[18:01:00.660]                           for (restart in restarts) {
[18:01:00.660]                             name <- restart$name
[18:01:00.660]                             if (is.null(name)) 
[18:01:00.660]                               next
[18:01:00.660]                             if (!grepl(pattern, name)) 
[18:01:00.660]                               next
[18:01:00.660]                             invokeRestart(restart)
[18:01:00.660]                             muffled <- TRUE
[18:01:00.660]                             break
[18:01:00.660]                           }
[18:01:00.660]                         }
[18:01:00.660]                       }
[18:01:00.660]                       invisible(muffled)
[18:01:00.660]                     }
[18:01:00.660]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.660]                   }
[18:01:00.660]                 }
[18:01:00.660]             }
[18:01:00.660]         }))
[18:01:00.660]     }, error = function(ex) {
[18:01:00.660]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.660]                 ...future.rng), started = ...future.startTime, 
[18:01:00.660]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.660]             version = "1.8"), class = "FutureResult")
[18:01:00.660]     }, finally = {
[18:01:00.660]         if (!identical(...future.workdir, getwd())) 
[18:01:00.660]             setwd(...future.workdir)
[18:01:00.660]         {
[18:01:00.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.660]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.660]             }
[18:01:00.660]             base::options(...future.oldOptions)
[18:01:00.660]             if (.Platform$OS.type == "windows") {
[18:01:00.660]                 old_names <- names(...future.oldEnvVars)
[18:01:00.660]                 envs <- base::Sys.getenv()
[18:01:00.660]                 names <- names(envs)
[18:01:00.660]                 common <- intersect(names, old_names)
[18:01:00.660]                 added <- setdiff(names, old_names)
[18:01:00.660]                 removed <- setdiff(old_names, names)
[18:01:00.660]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.660]                   envs[common]]
[18:01:00.660]                 NAMES <- toupper(changed)
[18:01:00.660]                 args <- list()
[18:01:00.660]                 for (kk in seq_along(NAMES)) {
[18:01:00.660]                   name <- changed[[kk]]
[18:01:00.660]                   NAME <- NAMES[[kk]]
[18:01:00.660]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.660]                     next
[18:01:00.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.660]                 }
[18:01:00.660]                 NAMES <- toupper(added)
[18:01:00.660]                 for (kk in seq_along(NAMES)) {
[18:01:00.660]                   name <- added[[kk]]
[18:01:00.660]                   NAME <- NAMES[[kk]]
[18:01:00.660]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.660]                     next
[18:01:00.660]                   args[[name]] <- ""
[18:01:00.660]                 }
[18:01:00.660]                 NAMES <- toupper(removed)
[18:01:00.660]                 for (kk in seq_along(NAMES)) {
[18:01:00.660]                   name <- removed[[kk]]
[18:01:00.660]                   NAME <- NAMES[[kk]]
[18:01:00.660]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.660]                     next
[18:01:00.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.660]                 }
[18:01:00.660]                 if (length(args) > 0) 
[18:01:00.660]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.660]             }
[18:01:00.660]             else {
[18:01:00.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.660]             }
[18:01:00.660]             {
[18:01:00.660]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.660]                   0L) {
[18:01:00.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.660]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.660]                   base::options(opts)
[18:01:00.660]                 }
[18:01:00.660]                 {
[18:01:00.660]                   {
[18:01:00.660]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.660]                     NULL
[18:01:00.660]                   }
[18:01:00.660]                   options(future.plan = NULL)
[18:01:00.660]                   if (is.na(NA_character_)) 
[18:01:00.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.660]                     .init = FALSE)
[18:01:00.660]                 }
[18:01:00.660]             }
[18:01:00.660]         }
[18:01:00.660]     })
[18:01:00.660]     if (TRUE) {
[18:01:00.660]         base::sink(type = "output", split = FALSE)
[18:01:00.660]         if (TRUE) {
[18:01:00.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.660]         }
[18:01:00.660]         else {
[18:01:00.660]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.660]         }
[18:01:00.660]         base::close(...future.stdout)
[18:01:00.660]         ...future.stdout <- NULL
[18:01:00.660]     }
[18:01:00.660]     ...future.result$conditions <- ...future.conditions
[18:01:00.660]     ...future.result$finished <- base::Sys.time()
[18:01:00.660]     ...future.result
[18:01:00.660] }
[18:01:00.666] assign_globals() ...
[18:01:00.667] List of 5
[18:01:00.667]  $ ...future.FUN            :function (C, k)  
[18:01:00.667]  $ MoreArgs                 : NULL
[18:01:00.667]  $ ...future.elements_ii    :List of 2
[18:01:00.667]   ..$ :List of 1
[18:01:00.667]   .. ..$ : chr "D"
[18:01:00.667]   ..$ :List of 1
[18:01:00.667]   .. ..$ : int 2
[18:01:00.667]  $ ...future.seeds_ii       : NULL
[18:01:00.667]  $ ...future.globals.maxSize: NULL
[18:01:00.667]  - attr(*, "where")=List of 5
[18:01:00.667]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.667]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.667]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.667]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.667]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.667]  - attr(*, "resolved")= logi FALSE
[18:01:00.667]  - attr(*, "total_size")= num 3488
[18:01:00.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.667]  - attr(*, "already-done")= logi TRUE
[18:01:00.690] - reassign environment for ‘...future.FUN’
[18:01:00.690] - copied ‘...future.FUN’ to environment
[18:01:00.690] - copied ‘MoreArgs’ to environment
[18:01:00.691] - copied ‘...future.elements_ii’ to environment
[18:01:00.691] - copied ‘...future.seeds_ii’ to environment
[18:01:00.692] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.692] assign_globals() ... done
[18:01:00.692] requestCore(): workers = 2
[18:01:00.693] Poll #1 (0): usedCores() = 2, workers = 2
[18:01:00.725] result() for MulticoreFuture ...
[18:01:00.727] result() for MulticoreFuture ...
[18:01:00.727] result() for MulticoreFuture ... done
[18:01:00.727] result() for MulticoreFuture ... done
[18:01:00.727] result() for MulticoreFuture ...
[18:01:00.727] result() for MulticoreFuture ... done
[18:01:00.731] MulticoreFuture started
[18:01:00.732] - Launch lazy future ... done
[18:01:00.733] run() for ‘MulticoreFuture’ ... done
[18:01:00.733] Created future:
[18:01:00.733] plan(): Setting new future strategy stack:
[18:01:00.734] List of future strategies:
[18:01:00.734] 1. sequential:
[18:01:00.734]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.734]    - tweaked: FALSE
[18:01:00.734]    - call: NULL
[18:01:00.736] plan(): nbrOfWorkers() = 1
[18:01:00.740] plan(): Setting new future strategy stack:
[18:01:00.741] List of future strategies:
[18:01:00.741] 1. multicore:
[18:01:00.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.741]    - tweaked: FALSE
[18:01:00.741]    - call: plan(strategy)
[18:01:00.734] MulticoreFuture:
[18:01:00.734] Label: ‘future_mapply-4’
[18:01:00.734] Expression:
[18:01:00.734] {
[18:01:00.734]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.734]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.734]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.734]         on.exit(options(oopts), add = TRUE)
[18:01:00.734]     }
[18:01:00.734]     {
[18:01:00.734]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.734]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.734]         do.call(mapply, args = args)
[18:01:00.734]     }
[18:01:00.734] }
[18:01:00.734] Lazy evaluation: FALSE
[18:01:00.734] Asynchronous evaluation: TRUE
[18:01:00.734] Local evaluation: TRUE
[18:01:00.734] Environment: R_GlobalEnv
[18:01:00.734] Capture standard output: TRUE
[18:01:00.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.734] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.734] Packages: <none>
[18:01:00.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.734] Resolved: FALSE
[18:01:00.734] Value: <not collected>
[18:01:00.734] Conditions captured: <none>
[18:01:00.734] Early signaling: FALSE
[18:01:00.734] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.734] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.749] Chunk #4 of 5 ... DONE
[18:01:00.749] Chunk #5 of 5 ...
[18:01:00.749]  - Finding globals in '...' for chunk #5 ...
[18:01:00.750] getGlobalsAndPackages() ...
[18:01:00.750] Searching for globals...
[18:01:00.750] plan(): nbrOfWorkers() = 2
[18:01:00.751] 
[18:01:00.752] Searching for globals ... DONE
[18:01:00.752] - globals: [0] <none>
[18:01:00.752] getGlobalsAndPackages() ... DONE
[18:01:00.752]    + additional globals found: [n=0] 
[18:01:00.753]    + additional namespaces needed: [n=0] 
[18:01:00.753]  - Finding globals in '...' for chunk #5 ... DONE
[18:01:00.753]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:00.753]  - seeds: <none>
[18:01:00.754]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.754] getGlobalsAndPackages() ...
[18:01:00.754] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.755] Resolving globals: FALSE
[18:01:00.757] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:00.758] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:00.759] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.759] 
[18:01:00.760] getGlobalsAndPackages() ... DONE
[18:01:00.761] run() for ‘Future’ ...
[18:01:00.761] - state: ‘created’
[18:01:00.762] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.785]   - Field: ‘label’
[18:01:00.786]   - Field: ‘local’
[18:01:00.786]   - Field: ‘owner’
[18:01:00.786]   - Field: ‘envir’
[18:01:00.786]   - Field: ‘workers’
[18:01:00.787]   - Field: ‘packages’
[18:01:00.787]   - Field: ‘gc’
[18:01:00.787]   - Field: ‘job’
[18:01:00.788]   - Field: ‘conditions’
[18:01:00.788]   - Field: ‘expr’
[18:01:00.788]   - Field: ‘uuid’
[18:01:00.789]   - Field: ‘seed’
[18:01:00.789]   - Field: ‘version’
[18:01:00.790]   - Field: ‘result’
[18:01:00.790]   - Field: ‘asynchronous’
[18:01:00.790]   - Field: ‘calls’
[18:01:00.791]   - Field: ‘globals’
[18:01:00.791]   - Field: ‘stdout’
[18:01:00.791]   - Field: ‘earlySignal’
[18:01:00.792]   - Field: ‘lazy’
[18:01:00.792]   - Field: ‘state’
[18:01:00.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.793] - Launch lazy future ...
[18:01:00.794] Packages needed by the future expression (n = 0): <none>
[18:01:00.794] Packages needed by future strategies (n = 0): <none>
[18:01:00.796] {
[18:01:00.796]     {
[18:01:00.796]         {
[18:01:00.796]             ...future.startTime <- base::Sys.time()
[18:01:00.796]             {
[18:01:00.796]                 {
[18:01:00.796]                   {
[18:01:00.796]                     {
[18:01:00.796]                       base::local({
[18:01:00.796]                         has_future <- base::requireNamespace("future", 
[18:01:00.796]                           quietly = TRUE)
[18:01:00.796]                         if (has_future) {
[18:01:00.796]                           ns <- base::getNamespace("future")
[18:01:00.796]                           version <- ns[[".package"]][["version"]]
[18:01:00.796]                           if (is.null(version)) 
[18:01:00.796]                             version <- utils::packageVersion("future")
[18:01:00.796]                         }
[18:01:00.796]                         else {
[18:01:00.796]                           version <- NULL
[18:01:00.796]                         }
[18:01:00.796]                         if (!has_future || version < "1.8.0") {
[18:01:00.796]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.796]                             "", base::R.version$version.string), 
[18:01:00.796]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.796]                               "release", "version")], collapse = " "), 
[18:01:00.796]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.796]                             info)
[18:01:00.796]                           info <- base::paste(info, collapse = "; ")
[18:01:00.796]                           if (!has_future) {
[18:01:00.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.796]                               info)
[18:01:00.796]                           }
[18:01:00.796]                           else {
[18:01:00.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.796]                               info, version)
[18:01:00.796]                           }
[18:01:00.796]                           base::stop(msg)
[18:01:00.796]                         }
[18:01:00.796]                       })
[18:01:00.796]                     }
[18:01:00.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.796]                     base::options(mc.cores = 1L)
[18:01:00.796]                   }
[18:01:00.796]                   ...future.strategy.old <- future::plan("list")
[18:01:00.796]                   options(future.plan = NULL)
[18:01:00.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.796]                 }
[18:01:00.796]                 ...future.workdir <- getwd()
[18:01:00.796]             }
[18:01:00.796]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.796]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.796]         }
[18:01:00.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.796]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:00.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.796]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.796]             base::names(...future.oldOptions))
[18:01:00.796]     }
[18:01:00.796]     if (FALSE) {
[18:01:00.796]     }
[18:01:00.796]     else {
[18:01:00.796]         if (TRUE) {
[18:01:00.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.796]                 open = "w")
[18:01:00.796]         }
[18:01:00.796]         else {
[18:01:00.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.796]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.796]         }
[18:01:00.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.796]             base::sink(type = "output", split = FALSE)
[18:01:00.796]             base::close(...future.stdout)
[18:01:00.796]         }, add = TRUE)
[18:01:00.796]     }
[18:01:00.796]     ...future.frame <- base::sys.nframe()
[18:01:00.796]     ...future.conditions <- base::list()
[18:01:00.796]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.796]     if (FALSE) {
[18:01:00.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.796]     }
[18:01:00.796]     ...future.result <- base::tryCatch({
[18:01:00.796]         base::withCallingHandlers({
[18:01:00.796]             ...future.value <- base::withVisible(base::local({
[18:01:00.796]                 withCallingHandlers({
[18:01:00.796]                   {
[18:01:00.796]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.796]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.796]                       ...future.globals.maxSize)) {
[18:01:00.796]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.796]                       on.exit(options(oopts), add = TRUE)
[18:01:00.796]                     }
[18:01:00.796]                     {
[18:01:00.796]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.796]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.796]                         USE.NAMES = FALSE)
[18:01:00.796]                       do.call(mapply, args = args)
[18:01:00.796]                     }
[18:01:00.796]                   }
[18:01:00.796]                 }, immediateCondition = function(cond) {
[18:01:00.796]                   save_rds <- function (object, pathname, ...) 
[18:01:00.796]                   {
[18:01:00.796]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.796]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.796]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.796]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.796]                         fi_tmp[["mtime"]])
[18:01:00.796]                     }
[18:01:00.796]                     tryCatch({
[18:01:00.796]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.796]                     }, error = function(ex) {
[18:01:00.796]                       msg <- conditionMessage(ex)
[18:01:00.796]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.796]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.796]                         fi_tmp[["mtime"]], msg)
[18:01:00.796]                       ex$message <- msg
[18:01:00.796]                       stop(ex)
[18:01:00.796]                     })
[18:01:00.796]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.796]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.796]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.796]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.796]                       fi <- file.info(pathname)
[18:01:00.796]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.796]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.796]                         fi[["size"]], fi[["mtime"]])
[18:01:00.796]                       stop(msg)
[18:01:00.796]                     }
[18:01:00.796]                     invisible(pathname)
[18:01:00.796]                   }
[18:01:00.796]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.796]                     rootPath = tempdir()) 
[18:01:00.796]                   {
[18:01:00.796]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.796]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.796]                       tmpdir = path, fileext = ".rds")
[18:01:00.796]                     save_rds(obj, file)
[18:01:00.796]                   }
[18:01:00.796]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.796]                   {
[18:01:00.796]                     inherits <- base::inherits
[18:01:00.796]                     invokeRestart <- base::invokeRestart
[18:01:00.796]                     is.null <- base::is.null
[18:01:00.796]                     muffled <- FALSE
[18:01:00.796]                     if (inherits(cond, "message")) {
[18:01:00.796]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.796]                       if (muffled) 
[18:01:00.796]                         invokeRestart("muffleMessage")
[18:01:00.796]                     }
[18:01:00.796]                     else if (inherits(cond, "warning")) {
[18:01:00.796]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.796]                       if (muffled) 
[18:01:00.796]                         invokeRestart("muffleWarning")
[18:01:00.796]                     }
[18:01:00.796]                     else if (inherits(cond, "condition")) {
[18:01:00.796]                       if (!is.null(pattern)) {
[18:01:00.796]                         computeRestarts <- base::computeRestarts
[18:01:00.796]                         grepl <- base::grepl
[18:01:00.796]                         restarts <- computeRestarts(cond)
[18:01:00.796]                         for (restart in restarts) {
[18:01:00.796]                           name <- restart$name
[18:01:00.796]                           if (is.null(name)) 
[18:01:00.796]                             next
[18:01:00.796]                           if (!grepl(pattern, name)) 
[18:01:00.796]                             next
[18:01:00.796]                           invokeRestart(restart)
[18:01:00.796]                           muffled <- TRUE
[18:01:00.796]                           break
[18:01:00.796]                         }
[18:01:00.796]                       }
[18:01:00.796]                     }
[18:01:00.796]                     invisible(muffled)
[18:01:00.796]                   }
[18:01:00.796]                   muffleCondition(cond)
[18:01:00.796]                 })
[18:01:00.796]             }))
[18:01:00.796]             future::FutureResult(value = ...future.value$value, 
[18:01:00.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.796]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.796]                     ...future.globalenv.names))
[18:01:00.796]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.796]         }, condition = base::local({
[18:01:00.796]             c <- base::c
[18:01:00.796]             inherits <- base::inherits
[18:01:00.796]             invokeRestart <- base::invokeRestart
[18:01:00.796]             length <- base::length
[18:01:00.796]             list <- base::list
[18:01:00.796]             seq.int <- base::seq.int
[18:01:00.796]             signalCondition <- base::signalCondition
[18:01:00.796]             sys.calls <- base::sys.calls
[18:01:00.796]             `[[` <- base::`[[`
[18:01:00.796]             `+` <- base::`+`
[18:01:00.796]             `<<-` <- base::`<<-`
[18:01:00.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.796]                   3L)]
[18:01:00.796]             }
[18:01:00.796]             function(cond) {
[18:01:00.796]                 is_error <- inherits(cond, "error")
[18:01:00.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.796]                   NULL)
[18:01:00.796]                 if (is_error) {
[18:01:00.796]                   sessionInformation <- function() {
[18:01:00.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.796]                       search = base::search(), system = base::Sys.info())
[18:01:00.796]                   }
[18:01:00.796]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.796]                     cond$call), session = sessionInformation(), 
[18:01:00.796]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.796]                   signalCondition(cond)
[18:01:00.796]                 }
[18:01:00.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.796]                 "immediateCondition"))) {
[18:01:00.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.796]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.796]                   if (TRUE && !signal) {
[18:01:00.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.796]                     {
[18:01:00.796]                       inherits <- base::inherits
[18:01:00.796]                       invokeRestart <- base::invokeRestart
[18:01:00.796]                       is.null <- base::is.null
[18:01:00.796]                       muffled <- FALSE
[18:01:00.796]                       if (inherits(cond, "message")) {
[18:01:00.796]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.796]                         if (muffled) 
[18:01:00.796]                           invokeRestart("muffleMessage")
[18:01:00.796]                       }
[18:01:00.796]                       else if (inherits(cond, "warning")) {
[18:01:00.796]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.796]                         if (muffled) 
[18:01:00.796]                           invokeRestart("muffleWarning")
[18:01:00.796]                       }
[18:01:00.796]                       else if (inherits(cond, "condition")) {
[18:01:00.796]                         if (!is.null(pattern)) {
[18:01:00.796]                           computeRestarts <- base::computeRestarts
[18:01:00.796]                           grepl <- base::grepl
[18:01:00.796]                           restarts <- computeRestarts(cond)
[18:01:00.796]                           for (restart in restarts) {
[18:01:00.796]                             name <- restart$name
[18:01:00.796]                             if (is.null(name)) 
[18:01:00.796]                               next
[18:01:00.796]                             if (!grepl(pattern, name)) 
[18:01:00.796]                               next
[18:01:00.796]                             invokeRestart(restart)
[18:01:00.796]                             muffled <- TRUE
[18:01:00.796]                             break
[18:01:00.796]                           }
[18:01:00.796]                         }
[18:01:00.796]                       }
[18:01:00.796]                       invisible(muffled)
[18:01:00.796]                     }
[18:01:00.796]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.796]                   }
[18:01:00.796]                 }
[18:01:00.796]                 else {
[18:01:00.796]                   if (TRUE) {
[18:01:00.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.796]                     {
[18:01:00.796]                       inherits <- base::inherits
[18:01:00.796]                       invokeRestart <- base::invokeRestart
[18:01:00.796]                       is.null <- base::is.null
[18:01:00.796]                       muffled <- FALSE
[18:01:00.796]                       if (inherits(cond, "message")) {
[18:01:00.796]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.796]                         if (muffled) 
[18:01:00.796]                           invokeRestart("muffleMessage")
[18:01:00.796]                       }
[18:01:00.796]                       else if (inherits(cond, "warning")) {
[18:01:00.796]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.796]                         if (muffled) 
[18:01:00.796]                           invokeRestart("muffleWarning")
[18:01:00.796]                       }
[18:01:00.796]                       else if (inherits(cond, "condition")) {
[18:01:00.796]                         if (!is.null(pattern)) {
[18:01:00.796]                           computeRestarts <- base::computeRestarts
[18:01:00.796]                           grepl <- base::grepl
[18:01:00.796]                           restarts <- computeRestarts(cond)
[18:01:00.796]                           for (restart in restarts) {
[18:01:00.796]                             name <- restart$name
[18:01:00.796]                             if (is.null(name)) 
[18:01:00.796]                               next
[18:01:00.796]                             if (!grepl(pattern, name)) 
[18:01:00.796]                               next
[18:01:00.796]                             invokeRestart(restart)
[18:01:00.796]                             muffled <- TRUE
[18:01:00.796]                             break
[18:01:00.796]                           }
[18:01:00.796]                         }
[18:01:00.796]                       }
[18:01:00.796]                       invisible(muffled)
[18:01:00.796]                     }
[18:01:00.796]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.796]                   }
[18:01:00.796]                 }
[18:01:00.796]             }
[18:01:00.796]         }))
[18:01:00.796]     }, error = function(ex) {
[18:01:00.796]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.796]                 ...future.rng), started = ...future.startTime, 
[18:01:00.796]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.796]             version = "1.8"), class = "FutureResult")
[18:01:00.796]     }, finally = {
[18:01:00.796]         if (!identical(...future.workdir, getwd())) 
[18:01:00.796]             setwd(...future.workdir)
[18:01:00.796]         {
[18:01:00.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.796]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.796]             }
[18:01:00.796]             base::options(...future.oldOptions)
[18:01:00.796]             if (.Platform$OS.type == "windows") {
[18:01:00.796]                 old_names <- names(...future.oldEnvVars)
[18:01:00.796]                 envs <- base::Sys.getenv()
[18:01:00.796]                 names <- names(envs)
[18:01:00.796]                 common <- intersect(names, old_names)
[18:01:00.796]                 added <- setdiff(names, old_names)
[18:01:00.796]                 removed <- setdiff(old_names, names)
[18:01:00.796]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.796]                   envs[common]]
[18:01:00.796]                 NAMES <- toupper(changed)
[18:01:00.796]                 args <- list()
[18:01:00.796]                 for (kk in seq_along(NAMES)) {
[18:01:00.796]                   name <- changed[[kk]]
[18:01:00.796]                   NAME <- NAMES[[kk]]
[18:01:00.796]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.796]                     next
[18:01:00.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.796]                 }
[18:01:00.796]                 NAMES <- toupper(added)
[18:01:00.796]                 for (kk in seq_along(NAMES)) {
[18:01:00.796]                   name <- added[[kk]]
[18:01:00.796]                   NAME <- NAMES[[kk]]
[18:01:00.796]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.796]                     next
[18:01:00.796]                   args[[name]] <- ""
[18:01:00.796]                 }
[18:01:00.796]                 NAMES <- toupper(removed)
[18:01:00.796]                 for (kk in seq_along(NAMES)) {
[18:01:00.796]                   name <- removed[[kk]]
[18:01:00.796]                   NAME <- NAMES[[kk]]
[18:01:00.796]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.796]                     next
[18:01:00.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.796]                 }
[18:01:00.796]                 if (length(args) > 0) 
[18:01:00.796]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.796]             }
[18:01:00.796]             else {
[18:01:00.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.796]             }
[18:01:00.796]             {
[18:01:00.796]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.796]                   0L) {
[18:01:00.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.796]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.796]                   base::options(opts)
[18:01:00.796]                 }
[18:01:00.796]                 {
[18:01:00.796]                   {
[18:01:00.796]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.796]                     NULL
[18:01:00.796]                   }
[18:01:00.796]                   options(future.plan = NULL)
[18:01:00.796]                   if (is.na(NA_character_)) 
[18:01:00.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.796]                     .init = FALSE)
[18:01:00.796]                 }
[18:01:00.796]             }
[18:01:00.796]         }
[18:01:00.796]     })
[18:01:00.796]     if (TRUE) {
[18:01:00.796]         base::sink(type = "output", split = FALSE)
[18:01:00.796]         if (TRUE) {
[18:01:00.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.796]         }
[18:01:00.796]         else {
[18:01:00.796]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.796]         }
[18:01:00.796]         base::close(...future.stdout)
[18:01:00.796]         ...future.stdout <- NULL
[18:01:00.796]     }
[18:01:00.796]     ...future.result$conditions <- ...future.conditions
[18:01:00.796]     ...future.result$finished <- base::Sys.time()
[18:01:00.796]     ...future.result
[18:01:00.796] }
[18:01:00.801] assign_globals() ...
[18:01:00.801] List of 5
[18:01:00.801]  $ ...future.FUN            :function (C, k)  
[18:01:00.801]  $ MoreArgs                 : NULL
[18:01:00.801]  $ ...future.elements_ii    :List of 2
[18:01:00.801]   ..$ :List of 1
[18:01:00.801]   .. ..$ : chr "E"
[18:01:00.801]   ..$ :List of 1
[18:01:00.801]   .. ..$ : int 1
[18:01:00.801]  $ ...future.seeds_ii       : NULL
[18:01:00.801]  $ ...future.globals.maxSize: NULL
[18:01:00.801]  - attr(*, "where")=List of 5
[18:01:00.801]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.801]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.801]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.801]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.801]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.801]  - attr(*, "resolved")= logi FALSE
[18:01:00.801]  - attr(*, "total_size")= num 3488
[18:01:00.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.801]  - attr(*, "already-done")= logi TRUE
[18:01:00.816] - reassign environment for ‘...future.FUN’
[18:01:00.816] - copied ‘...future.FUN’ to environment
[18:01:00.816] - copied ‘MoreArgs’ to environment
[18:01:00.817] - copied ‘...future.elements_ii’ to environment
[18:01:00.817] - copied ‘...future.seeds_ii’ to environment
[18:01:00.817] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.817] assign_globals() ... done
[18:01:00.818] requestCore(): workers = 2
[18:01:00.818] Poll #1 (0): usedCores() = 2, workers = 2
[18:01:00.829] result() for MulticoreFuture ...
[18:01:00.830] result() for MulticoreFuture ...
[18:01:00.830] result() for MulticoreFuture ... done
[18:01:00.831] result() for MulticoreFuture ... done
[18:01:00.831] result() for MulticoreFuture ...
[18:01:00.831] result() for MulticoreFuture ... done
[18:01:00.835] MulticoreFuture started
[18:01:00.836] - Launch lazy future ... done
[18:01:00.836] run() for ‘MulticoreFuture’ ... done
[18:01:00.837] Created future:
[18:01:00.837] plan(): Setting new future strategy stack:
[18:01:00.837] List of future strategies:
[18:01:00.837] 1. sequential:
[18:01:00.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.837]    - tweaked: FALSE
[18:01:00.837]    - call: NULL
[18:01:00.840] plan(): nbrOfWorkers() = 1
[18:01:00.844] plan(): Setting new future strategy stack:
[18:01:00.845] List of future strategies:
[18:01:00.845] 1. multicore:
[18:01:00.845]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:00.845]    - tweaked: FALSE
[18:01:00.845]    - call: plan(strategy)
[18:01:00.837] MulticoreFuture:
[18:01:00.837] Label: ‘future_mapply-5’
[18:01:00.837] Expression:
[18:01:00.837] {
[18:01:00.837]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.837]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.837]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.837]         on.exit(options(oopts), add = TRUE)
[18:01:00.837]     }
[18:01:00.837]     {
[18:01:00.837]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.837]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.837]         do.call(mapply, args = args)
[18:01:00.837]     }
[18:01:00.837] }
[18:01:00.837] Lazy evaluation: FALSE
[18:01:00.837] Asynchronous evaluation: TRUE
[18:01:00.837] Local evaluation: TRUE
[18:01:00.837] Environment: R_GlobalEnv
[18:01:00.837] Capture standard output: TRUE
[18:01:00.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.837] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.837] Packages: <none>
[18:01:00.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.837] Resolved: FALSE
[18:01:00.837] Value: <not collected>
[18:01:00.837] Conditions captured: <none>
[18:01:00.837] Early signaling: FALSE
[18:01:00.837] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.837] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.853] Chunk #5 of 5 ... DONE
[18:01:00.854] Launching 5 futures (chunks) ... DONE
[18:01:00.854] Resolving 5 futures (chunks) ...
[18:01:00.854] resolve() on list ...
[18:01:00.854] plan(): nbrOfWorkers() = 2
[18:01:00.855]  recursive: 0
[18:01:00.855]  length: 5
[18:01:00.855] 
[18:01:00.856] Future #1
[18:01:00.856] result() for MulticoreFuture ...
[18:01:00.856] result() for MulticoreFuture ... done
[18:01:00.857] result() for MulticoreFuture ...
[18:01:00.857] result() for MulticoreFuture ... done
[18:01:00.857] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:00.858] - nx: 5
[18:01:00.858] - relay: TRUE
[18:01:00.858] - stdout: TRUE
[18:01:00.858] - signal: TRUE
[18:01:00.859] - resignal: FALSE
[18:01:00.859] - force: TRUE
[18:01:00.859] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[18:01:00.859] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[18:01:00.860]  - until=1
[18:01:00.860]  - relaying element #1
[18:01:00.861] result() for MulticoreFuture ...
[18:01:00.861] result() for MulticoreFuture ... done
[18:01:00.861] result() for MulticoreFuture ...
[18:01:00.861] result() for MulticoreFuture ... done
[18:01:00.862] result() for MulticoreFuture ...
[18:01:00.862] result() for MulticoreFuture ... done
[18:01:00.863] result() for MulticoreFuture ...
[18:01:00.863] result() for MulticoreFuture ... done
[18:01:00.863] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:00.864] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:00.864] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:00.864]  length: 4 (resolved future 1)
[18:01:00.865] Future #2
[18:01:00.865] result() for MulticoreFuture ...
[18:01:00.865] result() for MulticoreFuture ... done
[18:01:00.866] result() for MulticoreFuture ...
[18:01:00.866] result() for MulticoreFuture ... done
[18:01:00.866] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:00.867] - nx: 5
[18:01:00.867] - relay: TRUE
[18:01:00.867] - stdout: TRUE
[18:01:00.867] - signal: TRUE
[18:01:00.868] - resignal: FALSE
[18:01:00.868] - force: TRUE
[18:01:00.868] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:00.869] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:00.869]  - until=2
[18:01:00.869]  - relaying element #2
[18:01:00.869] result() for MulticoreFuture ...
[18:01:00.870] result() for MulticoreFuture ... done
[18:01:00.870] result() for MulticoreFuture ...
[18:01:00.870] result() for MulticoreFuture ... done
[18:01:00.871] result() for MulticoreFuture ...
[18:01:00.871] result() for MulticoreFuture ... done
[18:01:00.872] result() for MulticoreFuture ...
[18:01:00.872] result() for MulticoreFuture ... done
[18:01:00.872] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:00.873] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:00.873] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:00.873]  length: 3 (resolved future 2)
[18:01:00.874] Future #3
[18:01:00.874] result() for MulticoreFuture ...
[18:01:00.874] result() for MulticoreFuture ... done
[18:01:00.875] result() for MulticoreFuture ...
[18:01:00.875] result() for MulticoreFuture ... done
[18:01:00.875] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:01:00.876] - nx: 5
[18:01:00.876] - relay: TRUE
[18:01:00.876] - stdout: TRUE
[18:01:00.876] - signal: TRUE
[18:01:00.877] - resignal: FALSE
[18:01:00.882] - force: TRUE
[18:01:00.883] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:00.883] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:00.884]  - until=3
[18:01:00.885]  - relaying element #3
[18:01:00.885] result() for MulticoreFuture ...
[18:01:00.885] result() for MulticoreFuture ... done
[18:01:00.886] result() for MulticoreFuture ...
[18:01:00.886] result() for MulticoreFuture ... done
[18:01:00.887] result() for MulticoreFuture ...
[18:01:00.888] result() for MulticoreFuture ... done
[18:01:00.888] result() for MulticoreFuture ...
[18:01:00.888] result() for MulticoreFuture ... done
[18:01:00.889] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:00.889] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:00.890] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:01:00.890]  length: 2 (resolved future 3)
[18:01:00.891] Future #4
[18:01:00.891] result() for MulticoreFuture ...
[18:01:00.893] result() for MulticoreFuture ...
[18:01:00.894] result() for MulticoreFuture ... done
[18:01:00.894] result() for MulticoreFuture ... done
[18:01:00.895] result() for MulticoreFuture ...
[18:01:00.895] result() for MulticoreFuture ... done
[18:01:00.895] signalConditionsASAP(MulticoreFuture, pos=4) ...
[18:01:00.896] - nx: 5
[18:01:00.896] - relay: TRUE
[18:01:00.896] - stdout: TRUE
[18:01:00.897] - signal: TRUE
[18:01:00.897] - resignal: FALSE
[18:01:00.897] - force: TRUE
[18:01:00.898] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:00.898] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:00.899]  - until=4
[18:01:00.899]  - relaying element #4
[18:01:00.899] result() for MulticoreFuture ...
[18:01:00.900] result() for MulticoreFuture ... done
[18:01:00.900] result() for MulticoreFuture ...
[18:01:00.900] result() for MulticoreFuture ... done
[18:01:00.901] result() for MulticoreFuture ...
[18:01:00.901] result() for MulticoreFuture ... done
[18:01:00.902] result() for MulticoreFuture ...
[18:01:00.902] result() for MulticoreFuture ... done
[18:01:00.902] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:00.902] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:00.903] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[18:01:00.903]  length: 1 (resolved future 4)
[18:01:00.904] Future #5
[18:01:00.904] result() for MulticoreFuture ...
[18:01:00.905] result() for MulticoreFuture ...
[18:01:00.905] result() for MulticoreFuture ... done
[18:01:00.906] result() for MulticoreFuture ... done
[18:01:00.906] result() for MulticoreFuture ...
[18:01:00.906] result() for MulticoreFuture ... done
[18:01:00.907] signalConditionsASAP(MulticoreFuture, pos=5) ...
[18:01:00.907] - nx: 5
[18:01:00.907] - relay: TRUE
[18:01:00.907] - stdout: TRUE
[18:01:00.908] - signal: TRUE
[18:01:00.908] - resignal: FALSE
[18:01:00.908] - force: TRUE
[18:01:00.908] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:00.909] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:00.909]  - until=5
[18:01:00.909]  - relaying element #5
[18:01:00.909] result() for MulticoreFuture ...
[18:01:00.910] result() for MulticoreFuture ... done
[18:01:00.910] result() for MulticoreFuture ...
[18:01:00.910] result() for MulticoreFuture ... done
[18:01:00.910] result() for MulticoreFuture ...
[18:01:00.911] result() for MulticoreFuture ... done
[18:01:00.911] result() for MulticoreFuture ...
[18:01:00.911] result() for MulticoreFuture ... done
[18:01:00.911] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:00.911] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:00.912] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[18:01:00.912]  length: 0 (resolved future 5)
[18:01:00.912] Relaying remaining futures
[18:01:00.912] signalConditionsASAP(NULL, pos=0) ...
[18:01:00.912] - nx: 5
[18:01:00.913] - relay: TRUE
[18:01:00.913] - stdout: TRUE
[18:01:00.913] - signal: TRUE
[18:01:00.913] - resignal: FALSE
[18:01:00.913] - force: TRUE
[18:01:00.914] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:00.914] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[18:01:00.914] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:00.914] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:00.914] signalConditionsASAP(NULL, pos=0) ... done
[18:01:00.915] resolve() on list ... DONE
[18:01:00.915] result() for MulticoreFuture ...
[18:01:00.915] result() for MulticoreFuture ... done
[18:01:00.915] result() for MulticoreFuture ...
[18:01:00.916] result() for MulticoreFuture ... done
[18:01:00.916] result() for MulticoreFuture ...
[18:01:00.916] result() for MulticoreFuture ... done
[18:01:00.916] result() for MulticoreFuture ...
[18:01:00.916] result() for MulticoreFuture ... done
[18:01:00.917] result() for MulticoreFuture ...
[18:01:00.917] result() for MulticoreFuture ... done
[18:01:00.917] result() for MulticoreFuture ...
[18:01:00.917] result() for MulticoreFuture ... done
[18:01:00.918] result() for MulticoreFuture ...
[18:01:00.918] result() for MulticoreFuture ... done
[18:01:00.918] result() for MulticoreFuture ...
[18:01:00.918] result() for MulticoreFuture ... done
[18:01:00.918] result() for MulticoreFuture ...
[18:01:00.919] result() for MulticoreFuture ... done
[18:01:00.919] result() for MulticoreFuture ...
[18:01:00.919] result() for MulticoreFuture ... done
[18:01:00.919]  - Number of value chunks collected: 5
[18:01:00.919] Resolving 5 futures (chunks) ... DONE
[18:01:00.920] Reducing values from 5 chunks ...
[18:01:00.920]  - Number of values collected after concatenation: 5
[18:01:00.920]  - Number of values expected: 5
[18:01:00.920] Reducing values from 5 chunks ... DONE
[18:01:00.920] future_mapply() ... DONE
[18:01:00.921] future_mapply() ...
[18:01:00.928] Number of chunks: 2
[18:01:00.928] getGlobalsAndPackagesXApply() ...
[18:01:00.928]  - future.globals: TRUE
[18:01:00.928] getGlobalsAndPackages() ...
[18:01:00.929] Searching for globals...
[18:01:00.931] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:00.931] Searching for globals ... DONE
[18:01:00.932] Resolving globals: FALSE
[18:01:00.932] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:00.933] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:00.933] - globals: [1] ‘FUN’
[18:01:00.934] 
[18:01:00.934] getGlobalsAndPackages() ... DONE
[18:01:00.934]  - globals found/used: [n=1] ‘FUN’
[18:01:00.934]  - needed namespaces: [n=0] 
[18:01:00.934] Finding globals ... DONE
[18:01:00.935] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:00.935] List of 2
[18:01:00.935]  $ ...future.FUN:function (C, k)  
[18:01:00.935]  $ MoreArgs     : list()
[18:01:00.935]  - attr(*, "where")=List of 2
[18:01:00.935]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:00.935]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:00.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.935]  - attr(*, "resolved")= logi FALSE
[18:01:00.935]  - attr(*, "total_size")= num NA
[18:01:00.940] Packages to be attached in all futures: [n=0] 
[18:01:00.940] getGlobalsAndPackagesXApply() ... DONE
[18:01:00.941] Number of futures (= number of chunks): 2
[18:01:00.941] Launching 2 futures (chunks) ...
[18:01:00.941] Chunk #1 of 2 ...
[18:01:00.941]  - Finding globals in '...' for chunk #1 ...
[18:01:00.942] getGlobalsAndPackages() ...
[18:01:00.942] Searching for globals...
[18:01:00.945] 
[18:01:00.946] Searching for globals ... DONE
[18:01:00.946] - globals: [0] <none>
[18:01:00.946] getGlobalsAndPackages() ... DONE
[18:01:00.946]    + additional globals found: [n=0] 
[18:01:00.946]    + additional namespaces needed: [n=0] 
[18:01:00.947]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:00.947]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:00.947]  - seeds: <none>
[18:01:00.947]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.948] getGlobalsAndPackages() ...
[18:01:00.948] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.948] Resolving globals: FALSE
[18:01:00.949] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:00.950] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:00.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:00.951] 
[18:01:00.951] getGlobalsAndPackages() ... DONE
[18:01:00.951] run() for ‘Future’ ...
[18:01:00.952] - state: ‘created’
[18:01:00.952] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:00.958] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:00.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:00.959]   - Field: ‘label’
[18:01:00.959]   - Field: ‘local’
[18:01:00.959]   - Field: ‘owner’
[18:01:00.960]   - Field: ‘envir’
[18:01:00.960]   - Field: ‘workers’
[18:01:00.960]   - Field: ‘packages’
[18:01:00.960]   - Field: ‘gc’
[18:01:00.960]   - Field: ‘job’
[18:01:00.961]   - Field: ‘conditions’
[18:01:00.961]   - Field: ‘expr’
[18:01:00.961]   - Field: ‘uuid’
[18:01:00.961]   - Field: ‘seed’
[18:01:00.961]   - Field: ‘version’
[18:01:00.962]   - Field: ‘result’
[18:01:00.962]   - Field: ‘asynchronous’
[18:01:00.962]   - Field: ‘calls’
[18:01:00.962]   - Field: ‘globals’
[18:01:00.962]   - Field: ‘stdout’
[18:01:00.963]   - Field: ‘earlySignal’
[18:01:00.963]   - Field: ‘lazy’
[18:01:00.963]   - Field: ‘state’
[18:01:00.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:00.963] - Launch lazy future ...
[18:01:00.964] Packages needed by the future expression (n = 0): <none>
[18:01:00.964] Packages needed by future strategies (n = 0): <none>
[18:01:00.965] {
[18:01:00.965]     {
[18:01:00.965]         {
[18:01:00.965]             ...future.startTime <- base::Sys.time()
[18:01:00.965]             {
[18:01:00.965]                 {
[18:01:00.965]                   {
[18:01:00.965]                     {
[18:01:00.965]                       base::local({
[18:01:00.965]                         has_future <- base::requireNamespace("future", 
[18:01:00.965]                           quietly = TRUE)
[18:01:00.965]                         if (has_future) {
[18:01:00.965]                           ns <- base::getNamespace("future")
[18:01:00.965]                           version <- ns[[".package"]][["version"]]
[18:01:00.965]                           if (is.null(version)) 
[18:01:00.965]                             version <- utils::packageVersion("future")
[18:01:00.965]                         }
[18:01:00.965]                         else {
[18:01:00.965]                           version <- NULL
[18:01:00.965]                         }
[18:01:00.965]                         if (!has_future || version < "1.8.0") {
[18:01:00.965]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:00.965]                             "", base::R.version$version.string), 
[18:01:00.965]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:00.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:00.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:00.965]                               "release", "version")], collapse = " "), 
[18:01:00.965]                             hostname = base::Sys.info()[["nodename"]])
[18:01:00.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:00.965]                             info)
[18:01:00.965]                           info <- base::paste(info, collapse = "; ")
[18:01:00.965]                           if (!has_future) {
[18:01:00.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:00.965]                               info)
[18:01:00.965]                           }
[18:01:00.965]                           else {
[18:01:00.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:00.965]                               info, version)
[18:01:00.965]                           }
[18:01:00.965]                           base::stop(msg)
[18:01:00.965]                         }
[18:01:00.965]                       })
[18:01:00.965]                     }
[18:01:00.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:00.965]                     base::options(mc.cores = 1L)
[18:01:00.965]                   }
[18:01:00.965]                   ...future.strategy.old <- future::plan("list")
[18:01:00.965]                   options(future.plan = NULL)
[18:01:00.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:00.965]                 }
[18:01:00.965]                 ...future.workdir <- getwd()
[18:01:00.965]             }
[18:01:00.965]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:00.965]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:00.965]         }
[18:01:00.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:00.965]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:00.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:00.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:00.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:00.965]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:00.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:00.965]             base::names(...future.oldOptions))
[18:01:00.965]     }
[18:01:00.965]     if (FALSE) {
[18:01:00.965]     }
[18:01:00.965]     else {
[18:01:00.965]         if (TRUE) {
[18:01:00.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:00.965]                 open = "w")
[18:01:00.965]         }
[18:01:00.965]         else {
[18:01:00.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:00.965]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:00.965]         }
[18:01:00.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:00.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:00.965]             base::sink(type = "output", split = FALSE)
[18:01:00.965]             base::close(...future.stdout)
[18:01:00.965]         }, add = TRUE)
[18:01:00.965]     }
[18:01:00.965]     ...future.frame <- base::sys.nframe()
[18:01:00.965]     ...future.conditions <- base::list()
[18:01:00.965]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:00.965]     if (FALSE) {
[18:01:00.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:00.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:00.965]     }
[18:01:00.965]     ...future.result <- base::tryCatch({
[18:01:00.965]         base::withCallingHandlers({
[18:01:00.965]             ...future.value <- base::withVisible(base::local({
[18:01:00.965]                 withCallingHandlers({
[18:01:00.965]                   {
[18:01:00.965]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.965]                     if (!identical(...future.globals.maxSize.org, 
[18:01:00.965]                       ...future.globals.maxSize)) {
[18:01:00.965]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.965]                       on.exit(options(oopts), add = TRUE)
[18:01:00.965]                     }
[18:01:00.965]                     {
[18:01:00.965]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.965]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:00.965]                         USE.NAMES = FALSE)
[18:01:00.965]                       do.call(mapply, args = args)
[18:01:00.965]                     }
[18:01:00.965]                   }
[18:01:00.965]                 }, immediateCondition = function(cond) {
[18:01:00.965]                   save_rds <- function (object, pathname, ...) 
[18:01:00.965]                   {
[18:01:00.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:00.965]                     if (file_test("-f", pathname_tmp)) {
[18:01:00.965]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:00.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.965]                         fi_tmp[["mtime"]])
[18:01:00.965]                     }
[18:01:00.965]                     tryCatch({
[18:01:00.965]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:00.965]                     }, error = function(ex) {
[18:01:00.965]                       msg <- conditionMessage(ex)
[18:01:00.965]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:00.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.965]                         fi_tmp[["mtime"]], msg)
[18:01:00.965]                       ex$message <- msg
[18:01:00.965]                       stop(ex)
[18:01:00.965]                     })
[18:01:00.965]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:00.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:00.965]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:00.965]                       fi_tmp <- file.info(pathname_tmp)
[18:01:00.965]                       fi <- file.info(pathname)
[18:01:00.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:00.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:00.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:00.965]                         fi[["size"]], fi[["mtime"]])
[18:01:00.965]                       stop(msg)
[18:01:00.965]                     }
[18:01:00.965]                     invisible(pathname)
[18:01:00.965]                   }
[18:01:00.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:00.965]                     rootPath = tempdir()) 
[18:01:00.965]                   {
[18:01:00.965]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:00.965]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:00.965]                       tmpdir = path, fileext = ".rds")
[18:01:00.965]                     save_rds(obj, file)
[18:01:00.965]                   }
[18:01:00.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:00.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.965]                   {
[18:01:00.965]                     inherits <- base::inherits
[18:01:00.965]                     invokeRestart <- base::invokeRestart
[18:01:00.965]                     is.null <- base::is.null
[18:01:00.965]                     muffled <- FALSE
[18:01:00.965]                     if (inherits(cond, "message")) {
[18:01:00.965]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:00.965]                       if (muffled) 
[18:01:00.965]                         invokeRestart("muffleMessage")
[18:01:00.965]                     }
[18:01:00.965]                     else if (inherits(cond, "warning")) {
[18:01:00.965]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:00.965]                       if (muffled) 
[18:01:00.965]                         invokeRestart("muffleWarning")
[18:01:00.965]                     }
[18:01:00.965]                     else if (inherits(cond, "condition")) {
[18:01:00.965]                       if (!is.null(pattern)) {
[18:01:00.965]                         computeRestarts <- base::computeRestarts
[18:01:00.965]                         grepl <- base::grepl
[18:01:00.965]                         restarts <- computeRestarts(cond)
[18:01:00.965]                         for (restart in restarts) {
[18:01:00.965]                           name <- restart$name
[18:01:00.965]                           if (is.null(name)) 
[18:01:00.965]                             next
[18:01:00.965]                           if (!grepl(pattern, name)) 
[18:01:00.965]                             next
[18:01:00.965]                           invokeRestart(restart)
[18:01:00.965]                           muffled <- TRUE
[18:01:00.965]                           break
[18:01:00.965]                         }
[18:01:00.965]                       }
[18:01:00.965]                     }
[18:01:00.965]                     invisible(muffled)
[18:01:00.965]                   }
[18:01:00.965]                   muffleCondition(cond)
[18:01:00.965]                 })
[18:01:00.965]             }))
[18:01:00.965]             future::FutureResult(value = ...future.value$value, 
[18:01:00.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.965]                   ...future.rng), globalenv = if (FALSE) 
[18:01:00.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:00.965]                     ...future.globalenv.names))
[18:01:00.965]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:00.965]         }, condition = base::local({
[18:01:00.965]             c <- base::c
[18:01:00.965]             inherits <- base::inherits
[18:01:00.965]             invokeRestart <- base::invokeRestart
[18:01:00.965]             length <- base::length
[18:01:00.965]             list <- base::list
[18:01:00.965]             seq.int <- base::seq.int
[18:01:00.965]             signalCondition <- base::signalCondition
[18:01:00.965]             sys.calls <- base::sys.calls
[18:01:00.965]             `[[` <- base::`[[`
[18:01:00.965]             `+` <- base::`+`
[18:01:00.965]             `<<-` <- base::`<<-`
[18:01:00.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:00.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:00.965]                   3L)]
[18:01:00.965]             }
[18:01:00.965]             function(cond) {
[18:01:00.965]                 is_error <- inherits(cond, "error")
[18:01:00.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:00.965]                   NULL)
[18:01:00.965]                 if (is_error) {
[18:01:00.965]                   sessionInformation <- function() {
[18:01:00.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:00.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:00.965]                       search = base::search(), system = base::Sys.info())
[18:01:00.965]                   }
[18:01:00.965]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:00.965]                     cond$call), session = sessionInformation(), 
[18:01:00.965]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:00.965]                   signalCondition(cond)
[18:01:00.965]                 }
[18:01:00.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:00.965]                 "immediateCondition"))) {
[18:01:00.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:00.965]                   ...future.conditions[[length(...future.conditions) + 
[18:01:00.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:00.965]                   if (TRUE && !signal) {
[18:01:00.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.965]                     {
[18:01:00.965]                       inherits <- base::inherits
[18:01:00.965]                       invokeRestart <- base::invokeRestart
[18:01:00.965]                       is.null <- base::is.null
[18:01:00.965]                       muffled <- FALSE
[18:01:00.965]                       if (inherits(cond, "message")) {
[18:01:00.965]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.965]                         if (muffled) 
[18:01:00.965]                           invokeRestart("muffleMessage")
[18:01:00.965]                       }
[18:01:00.965]                       else if (inherits(cond, "warning")) {
[18:01:00.965]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.965]                         if (muffled) 
[18:01:00.965]                           invokeRestart("muffleWarning")
[18:01:00.965]                       }
[18:01:00.965]                       else if (inherits(cond, "condition")) {
[18:01:00.965]                         if (!is.null(pattern)) {
[18:01:00.965]                           computeRestarts <- base::computeRestarts
[18:01:00.965]                           grepl <- base::grepl
[18:01:00.965]                           restarts <- computeRestarts(cond)
[18:01:00.965]                           for (restart in restarts) {
[18:01:00.965]                             name <- restart$name
[18:01:00.965]                             if (is.null(name)) 
[18:01:00.965]                               next
[18:01:00.965]                             if (!grepl(pattern, name)) 
[18:01:00.965]                               next
[18:01:00.965]                             invokeRestart(restart)
[18:01:00.965]                             muffled <- TRUE
[18:01:00.965]                             break
[18:01:00.965]                           }
[18:01:00.965]                         }
[18:01:00.965]                       }
[18:01:00.965]                       invisible(muffled)
[18:01:00.965]                     }
[18:01:00.965]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.965]                   }
[18:01:00.965]                 }
[18:01:00.965]                 else {
[18:01:00.965]                   if (TRUE) {
[18:01:00.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:00.965]                     {
[18:01:00.965]                       inherits <- base::inherits
[18:01:00.965]                       invokeRestart <- base::invokeRestart
[18:01:00.965]                       is.null <- base::is.null
[18:01:00.965]                       muffled <- FALSE
[18:01:00.965]                       if (inherits(cond, "message")) {
[18:01:00.965]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:00.965]                         if (muffled) 
[18:01:00.965]                           invokeRestart("muffleMessage")
[18:01:00.965]                       }
[18:01:00.965]                       else if (inherits(cond, "warning")) {
[18:01:00.965]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:00.965]                         if (muffled) 
[18:01:00.965]                           invokeRestart("muffleWarning")
[18:01:00.965]                       }
[18:01:00.965]                       else if (inherits(cond, "condition")) {
[18:01:00.965]                         if (!is.null(pattern)) {
[18:01:00.965]                           computeRestarts <- base::computeRestarts
[18:01:00.965]                           grepl <- base::grepl
[18:01:00.965]                           restarts <- computeRestarts(cond)
[18:01:00.965]                           for (restart in restarts) {
[18:01:00.965]                             name <- restart$name
[18:01:00.965]                             if (is.null(name)) 
[18:01:00.965]                               next
[18:01:00.965]                             if (!grepl(pattern, name)) 
[18:01:00.965]                               next
[18:01:00.965]                             invokeRestart(restart)
[18:01:00.965]                             muffled <- TRUE
[18:01:00.965]                             break
[18:01:00.965]                           }
[18:01:00.965]                         }
[18:01:00.965]                       }
[18:01:00.965]                       invisible(muffled)
[18:01:00.965]                     }
[18:01:00.965]                     muffleCondition(cond, pattern = "^muffle")
[18:01:00.965]                   }
[18:01:00.965]                 }
[18:01:00.965]             }
[18:01:00.965]         }))
[18:01:00.965]     }, error = function(ex) {
[18:01:00.965]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:00.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:00.965]                 ...future.rng), started = ...future.startTime, 
[18:01:00.965]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:00.965]             version = "1.8"), class = "FutureResult")
[18:01:00.965]     }, finally = {
[18:01:00.965]         if (!identical(...future.workdir, getwd())) 
[18:01:00.965]             setwd(...future.workdir)
[18:01:00.965]         {
[18:01:00.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:00.965]                 ...future.oldOptions$nwarnings <- NULL
[18:01:00.965]             }
[18:01:00.965]             base::options(...future.oldOptions)
[18:01:00.965]             if (.Platform$OS.type == "windows") {
[18:01:00.965]                 old_names <- names(...future.oldEnvVars)
[18:01:00.965]                 envs <- base::Sys.getenv()
[18:01:00.965]                 names <- names(envs)
[18:01:00.965]                 common <- intersect(names, old_names)
[18:01:00.965]                 added <- setdiff(names, old_names)
[18:01:00.965]                 removed <- setdiff(old_names, names)
[18:01:00.965]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:00.965]                   envs[common]]
[18:01:00.965]                 NAMES <- toupper(changed)
[18:01:00.965]                 args <- list()
[18:01:00.965]                 for (kk in seq_along(NAMES)) {
[18:01:00.965]                   name <- changed[[kk]]
[18:01:00.965]                   NAME <- NAMES[[kk]]
[18:01:00.965]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.965]                     next
[18:01:00.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.965]                 }
[18:01:00.965]                 NAMES <- toupper(added)
[18:01:00.965]                 for (kk in seq_along(NAMES)) {
[18:01:00.965]                   name <- added[[kk]]
[18:01:00.965]                   NAME <- NAMES[[kk]]
[18:01:00.965]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.965]                     next
[18:01:00.965]                   args[[name]] <- ""
[18:01:00.965]                 }
[18:01:00.965]                 NAMES <- toupper(removed)
[18:01:00.965]                 for (kk in seq_along(NAMES)) {
[18:01:00.965]                   name <- removed[[kk]]
[18:01:00.965]                   NAME <- NAMES[[kk]]
[18:01:00.965]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:00.965]                     next
[18:01:00.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:00.965]                 }
[18:01:00.965]                 if (length(args) > 0) 
[18:01:00.965]                   base::do.call(base::Sys.setenv, args = args)
[18:01:00.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:00.965]             }
[18:01:00.965]             else {
[18:01:00.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:00.965]             }
[18:01:00.965]             {
[18:01:00.965]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:00.965]                   0L) {
[18:01:00.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:00.965]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:00.965]                   base::options(opts)
[18:01:00.965]                 }
[18:01:00.965]                 {
[18:01:00.965]                   {
[18:01:00.965]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:00.965]                     NULL
[18:01:00.965]                   }
[18:01:00.965]                   options(future.plan = NULL)
[18:01:00.965]                   if (is.na(NA_character_)) 
[18:01:00.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:00.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:00.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:00.965]                     .init = FALSE)
[18:01:00.965]                 }
[18:01:00.965]             }
[18:01:00.965]         }
[18:01:00.965]     })
[18:01:00.965]     if (TRUE) {
[18:01:00.965]         base::sink(type = "output", split = FALSE)
[18:01:00.965]         if (TRUE) {
[18:01:00.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:00.965]         }
[18:01:00.965]         else {
[18:01:00.965]             ...future.result["stdout"] <- base::list(NULL)
[18:01:00.965]         }
[18:01:00.965]         base::close(...future.stdout)
[18:01:00.965]         ...future.stdout <- NULL
[18:01:00.965]     }
[18:01:00.965]     ...future.result$conditions <- ...future.conditions
[18:01:00.965]     ...future.result$finished <- base::Sys.time()
[18:01:00.965]     ...future.result
[18:01:00.965] }
[18:01:00.970] assign_globals() ...
[18:01:00.970] List of 5
[18:01:00.970]  $ ...future.FUN            :function (C, k)  
[18:01:00.970]  $ MoreArgs                 : list()
[18:01:00.970]  $ ...future.elements_ii    :List of 2
[18:01:00.970]   ..$ :List of 2
[18:01:00.970]   .. ..$ : chr "A"
[18:01:00.970]   .. ..$ : chr "B"
[18:01:00.970]   ..$ :List of 2
[18:01:00.970]   .. ..$ : int 5
[18:01:00.970]   .. ..$ : int 4
[18:01:00.970]  $ ...future.seeds_ii       : NULL
[18:01:00.970]  $ ...future.globals.maxSize: NULL
[18:01:00.970]  - attr(*, "where")=List of 5
[18:01:00.970]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:00.970]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:00.970]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:00.970]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:00.970]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:00.970]  - attr(*, "resolved")= logi FALSE
[18:01:00.970]  - attr(*, "total_size")= num 3656
[18:01:00.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:00.970]  - attr(*, "already-done")= logi TRUE
[18:01:00.983] - reassign environment for ‘...future.FUN’
[18:01:00.983] - copied ‘...future.FUN’ to environment
[18:01:00.983] - copied ‘MoreArgs’ to environment
[18:01:00.983] - copied ‘...future.elements_ii’ to environment
[18:01:00.984] - copied ‘...future.seeds_ii’ to environment
[18:01:00.984] - copied ‘...future.globals.maxSize’ to environment
[18:01:00.984] assign_globals() ... done
[18:01:00.984] requestCore(): workers = 2
[18:01:00.988] MulticoreFuture started
[18:01:00.989] - Launch lazy future ... done
[18:01:00.989] run() for ‘MulticoreFuture’ ... done
[18:01:00.990] Created future:
[18:01:00.990] plan(): Setting new future strategy stack:
[18:01:00.992] List of future strategies:
[18:01:00.992] 1. sequential:
[18:01:00.992]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:00.992]    - tweaked: FALSE
[18:01:00.992]    - call: NULL
[18:01:00.996] plan(): nbrOfWorkers() = 1
[18:01:01.001] plan(): Setting new future strategy stack:
[18:01:01.001] List of future strategies:
[18:01:01.001] 1. multicore:
[18:01:01.001]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.001]    - tweaked: FALSE
[18:01:01.001]    - call: plan(strategy)
[18:01:00.992] MulticoreFuture:
[18:01:00.992] Label: ‘future_.mapply-1’
[18:01:00.992] Expression:
[18:01:00.992] {
[18:01:00.992]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:00.992]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:00.992]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:00.992]         on.exit(options(oopts), add = TRUE)
[18:01:00.992]     }
[18:01:00.992]     {
[18:01:00.992]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:00.992]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:00.992]         do.call(mapply, args = args)
[18:01:00.992]     }
[18:01:00.992] }
[18:01:00.992] Lazy evaluation: FALSE
[18:01:00.992] Asynchronous evaluation: TRUE
[18:01:00.992] Local evaluation: TRUE
[18:01:00.992] Environment: R_GlobalEnv
[18:01:00.992] Capture standard output: TRUE
[18:01:00.992] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:00.992] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:00.992] Packages: <none>
[18:01:00.992] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:00.992] Resolved: FALSE
[18:01:00.992] Value: <not collected>
[18:01:00.992] Conditions captured: <none>
[18:01:00.992] Early signaling: FALSE
[18:01:00.992] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:00.992] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.008] Chunk #1 of 2 ... DONE
[18:01:01.008] Chunk #2 of 2 ...
[18:01:01.011] plan(): nbrOfWorkers() = 2
[18:01:01.011]  - Finding globals in '...' for chunk #2 ...
[18:01:01.011] getGlobalsAndPackages() ...
[18:01:01.012] Searching for globals...
[18:01:01.013] 
[18:01:01.013] Searching for globals ... DONE
[18:01:01.014] - globals: [0] <none>
[18:01:01.014] getGlobalsAndPackages() ... DONE
[18:01:01.014]    + additional globals found: [n=0] 
[18:01:01.014]    + additional namespaces needed: [n=0] 
[18:01:01.015]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:01.015]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:01.015]  - seeds: <none>
[18:01:01.016]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.016] getGlobalsAndPackages() ...
[18:01:01.016] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.017] Resolving globals: FALSE
[18:01:01.019] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:01.020] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:01.021] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.021] 
[18:01:01.022] getGlobalsAndPackages() ... DONE
[18:01:01.023] run() for ‘Future’ ...
[18:01:01.023] - state: ‘created’
[18:01:01.024] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.038] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.039] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.040]   - Field: ‘label’
[18:01:01.040]   - Field: ‘local’
[18:01:01.041]   - Field: ‘owner’
[18:01:01.041]   - Field: ‘envir’
[18:01:01.042]   - Field: ‘workers’
[18:01:01.042]   - Field: ‘packages’
[18:01:01.043]   - Field: ‘gc’
[18:01:01.043]   - Field: ‘job’
[18:01:01.044]   - Field: ‘conditions’
[18:01:01.044]   - Field: ‘expr’
[18:01:01.045]   - Field: ‘uuid’
[18:01:01.045]   - Field: ‘seed’
[18:01:01.045]   - Field: ‘version’
[18:01:01.046]   - Field: ‘result’
[18:01:01.046]   - Field: ‘asynchronous’
[18:01:01.047]   - Field: ‘calls’
[18:01:01.047]   - Field: ‘globals’
[18:01:01.048]   - Field: ‘stdout’
[18:01:01.048]   - Field: ‘earlySignal’
[18:01:01.049]   - Field: ‘lazy’
[18:01:01.049]   - Field: ‘state’
[18:01:01.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.050] - Launch lazy future ...
[18:01:01.051] Packages needed by the future expression (n = 0): <none>
[18:01:01.051] Packages needed by future strategies (n = 0): <none>
[18:01:01.053] {
[18:01:01.053]     {
[18:01:01.053]         {
[18:01:01.053]             ...future.startTime <- base::Sys.time()
[18:01:01.053]             {
[18:01:01.053]                 {
[18:01:01.053]                   {
[18:01:01.053]                     {
[18:01:01.053]                       base::local({
[18:01:01.053]                         has_future <- base::requireNamespace("future", 
[18:01:01.053]                           quietly = TRUE)
[18:01:01.053]                         if (has_future) {
[18:01:01.053]                           ns <- base::getNamespace("future")
[18:01:01.053]                           version <- ns[[".package"]][["version"]]
[18:01:01.053]                           if (is.null(version)) 
[18:01:01.053]                             version <- utils::packageVersion("future")
[18:01:01.053]                         }
[18:01:01.053]                         else {
[18:01:01.053]                           version <- NULL
[18:01:01.053]                         }
[18:01:01.053]                         if (!has_future || version < "1.8.0") {
[18:01:01.053]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.053]                             "", base::R.version$version.string), 
[18:01:01.053]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.053]                               "release", "version")], collapse = " "), 
[18:01:01.053]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.053]                             info)
[18:01:01.053]                           info <- base::paste(info, collapse = "; ")
[18:01:01.053]                           if (!has_future) {
[18:01:01.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.053]                               info)
[18:01:01.053]                           }
[18:01:01.053]                           else {
[18:01:01.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.053]                               info, version)
[18:01:01.053]                           }
[18:01:01.053]                           base::stop(msg)
[18:01:01.053]                         }
[18:01:01.053]                       })
[18:01:01.053]                     }
[18:01:01.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.053]                     base::options(mc.cores = 1L)
[18:01:01.053]                   }
[18:01:01.053]                   ...future.strategy.old <- future::plan("list")
[18:01:01.053]                   options(future.plan = NULL)
[18:01:01.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.053]                 }
[18:01:01.053]                 ...future.workdir <- getwd()
[18:01:01.053]             }
[18:01:01.053]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.053]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.053]         }
[18:01:01.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.053]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:01.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.053]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.053]             base::names(...future.oldOptions))
[18:01:01.053]     }
[18:01:01.053]     if (FALSE) {
[18:01:01.053]     }
[18:01:01.053]     else {
[18:01:01.053]         if (TRUE) {
[18:01:01.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.053]                 open = "w")
[18:01:01.053]         }
[18:01:01.053]         else {
[18:01:01.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.053]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.053]         }
[18:01:01.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.053]             base::sink(type = "output", split = FALSE)
[18:01:01.053]             base::close(...future.stdout)
[18:01:01.053]         }, add = TRUE)
[18:01:01.053]     }
[18:01:01.053]     ...future.frame <- base::sys.nframe()
[18:01:01.053]     ...future.conditions <- base::list()
[18:01:01.053]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.053]     if (FALSE) {
[18:01:01.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.053]     }
[18:01:01.053]     ...future.result <- base::tryCatch({
[18:01:01.053]         base::withCallingHandlers({
[18:01:01.053]             ...future.value <- base::withVisible(base::local({
[18:01:01.053]                 withCallingHandlers({
[18:01:01.053]                   {
[18:01:01.053]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.053]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.053]                       ...future.globals.maxSize)) {
[18:01:01.053]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.053]                       on.exit(options(oopts), add = TRUE)
[18:01:01.053]                     }
[18:01:01.053]                     {
[18:01:01.053]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.053]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.053]                         USE.NAMES = FALSE)
[18:01:01.053]                       do.call(mapply, args = args)
[18:01:01.053]                     }
[18:01:01.053]                   }
[18:01:01.053]                 }, immediateCondition = function(cond) {
[18:01:01.053]                   save_rds <- function (object, pathname, ...) 
[18:01:01.053]                   {
[18:01:01.053]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.053]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.053]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.053]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.053]                         fi_tmp[["mtime"]])
[18:01:01.053]                     }
[18:01:01.053]                     tryCatch({
[18:01:01.053]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.053]                     }, error = function(ex) {
[18:01:01.053]                       msg <- conditionMessage(ex)
[18:01:01.053]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.053]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.053]                         fi_tmp[["mtime"]], msg)
[18:01:01.053]                       ex$message <- msg
[18:01:01.053]                       stop(ex)
[18:01:01.053]                     })
[18:01:01.053]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.053]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.053]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.053]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.053]                       fi <- file.info(pathname)
[18:01:01.053]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.053]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.053]                         fi[["size"]], fi[["mtime"]])
[18:01:01.053]                       stop(msg)
[18:01:01.053]                     }
[18:01:01.053]                     invisible(pathname)
[18:01:01.053]                   }
[18:01:01.053]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.053]                     rootPath = tempdir()) 
[18:01:01.053]                   {
[18:01:01.053]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.053]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.053]                       tmpdir = path, fileext = ".rds")
[18:01:01.053]                     save_rds(obj, file)
[18:01:01.053]                   }
[18:01:01.053]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.053]                   {
[18:01:01.053]                     inherits <- base::inherits
[18:01:01.053]                     invokeRestart <- base::invokeRestart
[18:01:01.053]                     is.null <- base::is.null
[18:01:01.053]                     muffled <- FALSE
[18:01:01.053]                     if (inherits(cond, "message")) {
[18:01:01.053]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.053]                       if (muffled) 
[18:01:01.053]                         invokeRestart("muffleMessage")
[18:01:01.053]                     }
[18:01:01.053]                     else if (inherits(cond, "warning")) {
[18:01:01.053]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.053]                       if (muffled) 
[18:01:01.053]                         invokeRestart("muffleWarning")
[18:01:01.053]                     }
[18:01:01.053]                     else if (inherits(cond, "condition")) {
[18:01:01.053]                       if (!is.null(pattern)) {
[18:01:01.053]                         computeRestarts <- base::computeRestarts
[18:01:01.053]                         grepl <- base::grepl
[18:01:01.053]                         restarts <- computeRestarts(cond)
[18:01:01.053]                         for (restart in restarts) {
[18:01:01.053]                           name <- restart$name
[18:01:01.053]                           if (is.null(name)) 
[18:01:01.053]                             next
[18:01:01.053]                           if (!grepl(pattern, name)) 
[18:01:01.053]                             next
[18:01:01.053]                           invokeRestart(restart)
[18:01:01.053]                           muffled <- TRUE
[18:01:01.053]                           break
[18:01:01.053]                         }
[18:01:01.053]                       }
[18:01:01.053]                     }
[18:01:01.053]                     invisible(muffled)
[18:01:01.053]                   }
[18:01:01.053]                   muffleCondition(cond)
[18:01:01.053]                 })
[18:01:01.053]             }))
[18:01:01.053]             future::FutureResult(value = ...future.value$value, 
[18:01:01.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.053]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.053]                     ...future.globalenv.names))
[18:01:01.053]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.053]         }, condition = base::local({
[18:01:01.053]             c <- base::c
[18:01:01.053]             inherits <- base::inherits
[18:01:01.053]             invokeRestart <- base::invokeRestart
[18:01:01.053]             length <- base::length
[18:01:01.053]             list <- base::list
[18:01:01.053]             seq.int <- base::seq.int
[18:01:01.053]             signalCondition <- base::signalCondition
[18:01:01.053]             sys.calls <- base::sys.calls
[18:01:01.053]             `[[` <- base::`[[`
[18:01:01.053]             `+` <- base::`+`
[18:01:01.053]             `<<-` <- base::`<<-`
[18:01:01.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.053]                   3L)]
[18:01:01.053]             }
[18:01:01.053]             function(cond) {
[18:01:01.053]                 is_error <- inherits(cond, "error")
[18:01:01.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.053]                   NULL)
[18:01:01.053]                 if (is_error) {
[18:01:01.053]                   sessionInformation <- function() {
[18:01:01.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.053]                       search = base::search(), system = base::Sys.info())
[18:01:01.053]                   }
[18:01:01.053]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.053]                     cond$call), session = sessionInformation(), 
[18:01:01.053]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.053]                   signalCondition(cond)
[18:01:01.053]                 }
[18:01:01.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.053]                 "immediateCondition"))) {
[18:01:01.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.053]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.053]                   if (TRUE && !signal) {
[18:01:01.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.053]                     {
[18:01:01.053]                       inherits <- base::inherits
[18:01:01.053]                       invokeRestart <- base::invokeRestart
[18:01:01.053]                       is.null <- base::is.null
[18:01:01.053]                       muffled <- FALSE
[18:01:01.053]                       if (inherits(cond, "message")) {
[18:01:01.053]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.053]                         if (muffled) 
[18:01:01.053]                           invokeRestart("muffleMessage")
[18:01:01.053]                       }
[18:01:01.053]                       else if (inherits(cond, "warning")) {
[18:01:01.053]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.053]                         if (muffled) 
[18:01:01.053]                           invokeRestart("muffleWarning")
[18:01:01.053]                       }
[18:01:01.053]                       else if (inherits(cond, "condition")) {
[18:01:01.053]                         if (!is.null(pattern)) {
[18:01:01.053]                           computeRestarts <- base::computeRestarts
[18:01:01.053]                           grepl <- base::grepl
[18:01:01.053]                           restarts <- computeRestarts(cond)
[18:01:01.053]                           for (restart in restarts) {
[18:01:01.053]                             name <- restart$name
[18:01:01.053]                             if (is.null(name)) 
[18:01:01.053]                               next
[18:01:01.053]                             if (!grepl(pattern, name)) 
[18:01:01.053]                               next
[18:01:01.053]                             invokeRestart(restart)
[18:01:01.053]                             muffled <- TRUE
[18:01:01.053]                             break
[18:01:01.053]                           }
[18:01:01.053]                         }
[18:01:01.053]                       }
[18:01:01.053]                       invisible(muffled)
[18:01:01.053]                     }
[18:01:01.053]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.053]                   }
[18:01:01.053]                 }
[18:01:01.053]                 else {
[18:01:01.053]                   if (TRUE) {
[18:01:01.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.053]                     {
[18:01:01.053]                       inherits <- base::inherits
[18:01:01.053]                       invokeRestart <- base::invokeRestart
[18:01:01.053]                       is.null <- base::is.null
[18:01:01.053]                       muffled <- FALSE
[18:01:01.053]                       if (inherits(cond, "message")) {
[18:01:01.053]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.053]                         if (muffled) 
[18:01:01.053]                           invokeRestart("muffleMessage")
[18:01:01.053]                       }
[18:01:01.053]                       else if (inherits(cond, "warning")) {
[18:01:01.053]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.053]                         if (muffled) 
[18:01:01.053]                           invokeRestart("muffleWarning")
[18:01:01.053]                       }
[18:01:01.053]                       else if (inherits(cond, "condition")) {
[18:01:01.053]                         if (!is.null(pattern)) {
[18:01:01.053]                           computeRestarts <- base::computeRestarts
[18:01:01.053]                           grepl <- base::grepl
[18:01:01.053]                           restarts <- computeRestarts(cond)
[18:01:01.053]                           for (restart in restarts) {
[18:01:01.053]                             name <- restart$name
[18:01:01.053]                             if (is.null(name)) 
[18:01:01.053]                               next
[18:01:01.053]                             if (!grepl(pattern, name)) 
[18:01:01.053]                               next
[18:01:01.053]                             invokeRestart(restart)
[18:01:01.053]                             muffled <- TRUE
[18:01:01.053]                             break
[18:01:01.053]                           }
[18:01:01.053]                         }
[18:01:01.053]                       }
[18:01:01.053]                       invisible(muffled)
[18:01:01.053]                     }
[18:01:01.053]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.053]                   }
[18:01:01.053]                 }
[18:01:01.053]             }
[18:01:01.053]         }))
[18:01:01.053]     }, error = function(ex) {
[18:01:01.053]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.053]                 ...future.rng), started = ...future.startTime, 
[18:01:01.053]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.053]             version = "1.8"), class = "FutureResult")
[18:01:01.053]     }, finally = {
[18:01:01.053]         if (!identical(...future.workdir, getwd())) 
[18:01:01.053]             setwd(...future.workdir)
[18:01:01.053]         {
[18:01:01.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.053]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.053]             }
[18:01:01.053]             base::options(...future.oldOptions)
[18:01:01.053]             if (.Platform$OS.type == "windows") {
[18:01:01.053]                 old_names <- names(...future.oldEnvVars)
[18:01:01.053]                 envs <- base::Sys.getenv()
[18:01:01.053]                 names <- names(envs)
[18:01:01.053]                 common <- intersect(names, old_names)
[18:01:01.053]                 added <- setdiff(names, old_names)
[18:01:01.053]                 removed <- setdiff(old_names, names)
[18:01:01.053]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.053]                   envs[common]]
[18:01:01.053]                 NAMES <- toupper(changed)
[18:01:01.053]                 args <- list()
[18:01:01.053]                 for (kk in seq_along(NAMES)) {
[18:01:01.053]                   name <- changed[[kk]]
[18:01:01.053]                   NAME <- NAMES[[kk]]
[18:01:01.053]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.053]                     next
[18:01:01.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.053]                 }
[18:01:01.053]                 NAMES <- toupper(added)
[18:01:01.053]                 for (kk in seq_along(NAMES)) {
[18:01:01.053]                   name <- added[[kk]]
[18:01:01.053]                   NAME <- NAMES[[kk]]
[18:01:01.053]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.053]                     next
[18:01:01.053]                   args[[name]] <- ""
[18:01:01.053]                 }
[18:01:01.053]                 NAMES <- toupper(removed)
[18:01:01.053]                 for (kk in seq_along(NAMES)) {
[18:01:01.053]                   name <- removed[[kk]]
[18:01:01.053]                   NAME <- NAMES[[kk]]
[18:01:01.053]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.053]                     next
[18:01:01.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.053]                 }
[18:01:01.053]                 if (length(args) > 0) 
[18:01:01.053]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.053]             }
[18:01:01.053]             else {
[18:01:01.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.053]             }
[18:01:01.053]             {
[18:01:01.053]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.053]                   0L) {
[18:01:01.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.053]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.053]                   base::options(opts)
[18:01:01.053]                 }
[18:01:01.053]                 {
[18:01:01.053]                   {
[18:01:01.053]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.053]                     NULL
[18:01:01.053]                   }
[18:01:01.053]                   options(future.plan = NULL)
[18:01:01.053]                   if (is.na(NA_character_)) 
[18:01:01.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.053]                     .init = FALSE)
[18:01:01.053]                 }
[18:01:01.053]             }
[18:01:01.053]         }
[18:01:01.053]     })
[18:01:01.053]     if (TRUE) {
[18:01:01.053]         base::sink(type = "output", split = FALSE)
[18:01:01.053]         if (TRUE) {
[18:01:01.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.053]         }
[18:01:01.053]         else {
[18:01:01.053]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.053]         }
[18:01:01.053]         base::close(...future.stdout)
[18:01:01.053]         ...future.stdout <- NULL
[18:01:01.053]     }
[18:01:01.053]     ...future.result$conditions <- ...future.conditions
[18:01:01.053]     ...future.result$finished <- base::Sys.time()
[18:01:01.053]     ...future.result
[18:01:01.053] }
[18:01:01.059] assign_globals() ...
[18:01:01.059] List of 5
[18:01:01.059]  $ ...future.FUN            :function (C, k)  
[18:01:01.059]  $ MoreArgs                 : list()
[18:01:01.059]  $ ...future.elements_ii    :List of 2
[18:01:01.059]   ..$ :List of 3
[18:01:01.059]   .. ..$ : chr "C"
[18:01:01.059]   .. ..$ : chr "D"
[18:01:01.059]   .. ..$ : chr "E"
[18:01:01.059]   ..$ :List of 3
[18:01:01.059]   .. ..$ : int 3
[18:01:01.059]   .. ..$ : int 2
[18:01:01.059]   .. ..$ : int 1
[18:01:01.059]  $ ...future.seeds_ii       : NULL
[18:01:01.059]  $ ...future.globals.maxSize: NULL
[18:01:01.059]  - attr(*, "where")=List of 5
[18:01:01.059]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.059]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.059]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.059]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.059]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.059]  - attr(*, "resolved")= logi FALSE
[18:01:01.059]  - attr(*, "total_size")= num 3824
[18:01:01.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.059]  - attr(*, "already-done")= logi TRUE
[18:01:01.078] - reassign environment for ‘...future.FUN’
[18:01:01.078] - copied ‘...future.FUN’ to environment
[18:01:01.078] - copied ‘MoreArgs’ to environment
[18:01:01.079] - copied ‘...future.elements_ii’ to environment
[18:01:01.079] - copied ‘...future.seeds_ii’ to environment
[18:01:01.079] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.079] assign_globals() ... done
[18:01:01.080] requestCore(): workers = 2
[18:01:01.083] MulticoreFuture started
[18:01:01.084] - Launch lazy future ... done
[18:01:01.085] run() for ‘MulticoreFuture’ ... done
[18:01:01.085] Created future:
[18:01:01.085] plan(): Setting new future strategy stack:
[18:01:01.086] List of future strategies:
[18:01:01.086] 1. sequential:
[18:01:01.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.086]    - tweaked: FALSE
[18:01:01.086]    - call: NULL
[18:01:01.088] plan(): nbrOfWorkers() = 1
[18:01:01.092] plan(): Setting new future strategy stack:
[18:01:01.093] List of future strategies:
[18:01:01.093] 1. multicore:
[18:01:01.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.093]    - tweaked: FALSE
[18:01:01.093]    - call: plan(strategy)
[18:01:01.086] MulticoreFuture:
[18:01:01.086] Label: ‘future_.mapply-2’
[18:01:01.086] Expression:
[18:01:01.086] {
[18:01:01.086]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.086]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.086]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.086]         on.exit(options(oopts), add = TRUE)
[18:01:01.086]     }
[18:01:01.086]     {
[18:01:01.086]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.086]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.086]         do.call(mapply, args = args)
[18:01:01.086]     }
[18:01:01.086] }
[18:01:01.086] Lazy evaluation: FALSE
[18:01:01.086] Asynchronous evaluation: TRUE
[18:01:01.086] Local evaluation: TRUE
[18:01:01.086] Environment: R_GlobalEnv
[18:01:01.086] Capture standard output: TRUE
[18:01:01.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.086] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.086] Packages: <none>
[18:01:01.086] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.086] Resolved: FALSE
[18:01:01.086] Value: <not collected>
[18:01:01.086] Conditions captured: <none>
[18:01:01.086] Early signaling: FALSE
[18:01:01.086] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.086] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.101] Chunk #2 of 2 ... DONE
[18:01:01.101] Launching 2 futures (chunks) ... DONE
[18:01:01.101] Resolving 2 futures (chunks) ...
[18:01:01.102] resolve() on list ...
[18:01:01.102]  recursive: 0
[18:01:01.102]  length: 2
[18:01:01.102] plan(): nbrOfWorkers() = 2
[18:01:01.102] 
[18:01:01.103] Future #1
[18:01:01.104] result() for MulticoreFuture ...
[18:01:01.106] result() for MulticoreFuture ...
[18:01:01.106] result() for MulticoreFuture ... done
[18:01:01.106] result() for MulticoreFuture ... done
[18:01:01.106] result() for MulticoreFuture ...
[18:01:01.107] result() for MulticoreFuture ... done
[18:01:01.107] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:01.107] - nx: 2
[18:01:01.108] - relay: TRUE
[18:01:01.108] - stdout: TRUE
[18:01:01.108] - signal: TRUE
[18:01:01.109] - resignal: FALSE
[18:01:01.109] - force: TRUE
[18:01:01.109] - relayed: [n=2] FALSE, FALSE
[18:01:01.110] - queued futures: [n=2] FALSE, FALSE
[18:01:01.110]  - until=1
[18:01:01.110]  - relaying element #1
[18:01:01.111] result() for MulticoreFuture ...
[18:01:01.111] result() for MulticoreFuture ... done
[18:01:01.111] result() for MulticoreFuture ...
[18:01:01.112] result() for MulticoreFuture ... done
[18:01:01.112] result() for MulticoreFuture ...
[18:01:01.112] result() for MulticoreFuture ... done
[18:01:01.113] result() for MulticoreFuture ...
[18:01:01.113] result() for MulticoreFuture ... done
[18:01:01.113] - relayed: [n=2] TRUE, FALSE
[18:01:01.114] - queued futures: [n=2] TRUE, FALSE
[18:01:01.114] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:01.114]  length: 1 (resolved future 1)
[18:01:01.115] Future #2
[18:01:01.115] result() for MulticoreFuture ...
[18:01:01.117] result() for MulticoreFuture ...
[18:01:01.117] result() for MulticoreFuture ... done
[18:01:01.117] result() for MulticoreFuture ... done
[18:01:01.118] result() for MulticoreFuture ...
[18:01:01.118] result() for MulticoreFuture ... done
[18:01:01.119] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:01.119] - nx: 2
[18:01:01.119] - relay: TRUE
[18:01:01.120] - stdout: TRUE
[18:01:01.120] - signal: TRUE
[18:01:01.120] - resignal: FALSE
[18:01:01.120] - force: TRUE
[18:01:01.120] - relayed: [n=2] TRUE, FALSE
[18:01:01.121] - queued futures: [n=2] TRUE, FALSE
[18:01:01.121]  - until=2
[18:01:01.121]  - relaying element #2
[18:01:01.121] result() for MulticoreFuture ...
[18:01:01.122] result() for MulticoreFuture ... done
[18:01:01.122] result() for MulticoreFuture ...
[18:01:01.122] result() for MulticoreFuture ... done
[18:01:01.122] result() for MulticoreFuture ...
[18:01:01.123] result() for MulticoreFuture ... done
[18:01:01.123] result() for MulticoreFuture ...
[18:01:01.123] result() for MulticoreFuture ... done
[18:01:01.123] - relayed: [n=2] TRUE, TRUE
[18:01:01.124] - queued futures: [n=2] TRUE, TRUE
[18:01:01.124] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:01.124]  length: 0 (resolved future 2)
[18:01:01.124] Relaying remaining futures
[18:01:01.125] signalConditionsASAP(NULL, pos=0) ...
[18:01:01.125] - nx: 2
[18:01:01.125] - relay: TRUE
[18:01:01.129] - stdout: TRUE
[18:01:01.129] - signal: TRUE
[18:01:01.130] - resignal: FALSE
[18:01:01.130] - force: TRUE
[18:01:01.130] - relayed: [n=2] TRUE, TRUE
[18:01:01.131] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:01.131] - relayed: [n=2] TRUE, TRUE
[18:01:01.131] - queued futures: [n=2] TRUE, TRUE
[18:01:01.132] signalConditionsASAP(NULL, pos=0) ... done
[18:01:01.132] resolve() on list ... DONE
[18:01:01.132] result() for MulticoreFuture ...
[18:01:01.132] result() for MulticoreFuture ... done
[18:01:01.133] result() for MulticoreFuture ...
[18:01:01.133] result() for MulticoreFuture ... done
[18:01:01.133] result() for MulticoreFuture ...
[18:01:01.134] result() for MulticoreFuture ... done
[18:01:01.134] result() for MulticoreFuture ...
[18:01:01.134] result() for MulticoreFuture ... done
[18:01:01.134]  - Number of value chunks collected: 2
[18:01:01.135] Resolving 2 futures (chunks) ... DONE
[18:01:01.135] Reducing values from 2 chunks ...
[18:01:01.135]  - Number of values collected after concatenation: 5
[18:01:01.135]  - Number of values expected: 5
[18:01:01.136] Reducing values from 2 chunks ... DONE
[18:01:01.136] future_mapply() ... DONE
[18:01:01.137] future_mapply() ...
[18:01:01.144] Number of chunks: 3
[18:01:01.145] Index remapping (attribute 'ordering'): [n = 5] 5, 2, 4, 1, 3
[18:01:01.145] getGlobalsAndPackagesXApply() ...
[18:01:01.145]  - future.globals: TRUE
[18:01:01.146] getGlobalsAndPackages() ...
[18:01:01.146] Searching for globals...
[18:01:01.149] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:01.149] Searching for globals ... DONE
[18:01:01.149] Resolving globals: FALSE
[18:01:01.150] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:01.151] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:01.151] - globals: [1] ‘FUN’
[18:01:01.151] 
[18:01:01.152] getGlobalsAndPackages() ... DONE
[18:01:01.152]  - globals found/used: [n=1] ‘FUN’
[18:01:01.152]  - needed namespaces: [n=0] 
[18:01:01.152] Finding globals ... DONE
[18:01:01.153] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:01.153] List of 2
[18:01:01.153]  $ ...future.FUN:function (C, k)  
[18:01:01.153]  $ MoreArgs     : NULL
[18:01:01.153]  - attr(*, "where")=List of 2
[18:01:01.153]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:01.153]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:01.153]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.153]  - attr(*, "resolved")= logi FALSE
[18:01:01.153]  - attr(*, "total_size")= num NA
[18:01:01.158] Packages to be attached in all futures: [n=0] 
[18:01:01.159] getGlobalsAndPackagesXApply() ... DONE
[18:01:01.159] Number of futures (= number of chunks): 3
[18:01:01.159] Launching 3 futures (chunks) ...
[18:01:01.160] Chunk #1 of 3 ...
[18:01:01.160]  - Finding globals in '...' for chunk #1 ...
[18:01:01.160] getGlobalsAndPackages() ...
[18:01:01.160] Searching for globals...
[18:01:01.161] 
[18:01:01.161] Searching for globals ... DONE
[18:01:01.161] - globals: [0] <none>
[18:01:01.162] getGlobalsAndPackages() ... DONE
[18:01:01.162]    + additional globals found: [n=0] 
[18:01:01.162]    + additional namespaces needed: [n=0] 
[18:01:01.162]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:01.162]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:01:01.163]  - seeds: <none>
[18:01:01.163]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.163] getGlobalsAndPackages() ...
[18:01:01.163] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.164] Resolving globals: FALSE
[18:01:01.165] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:01.166] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:01.166] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.166] 
[18:01:01.166] getGlobalsAndPackages() ... DONE
[18:01:01.167] run() for ‘Future’ ...
[18:01:01.167] - state: ‘created’
[18:01:01.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.174] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.175]   - Field: ‘label’
[18:01:01.175]   - Field: ‘local’
[18:01:01.175]   - Field: ‘owner’
[18:01:01.175]   - Field: ‘envir’
[18:01:01.176]   - Field: ‘workers’
[18:01:01.176]   - Field: ‘packages’
[18:01:01.176]   - Field: ‘gc’
[18:01:01.176]   - Field: ‘job’
[18:01:01.176]   - Field: ‘conditions’
[18:01:01.177]   - Field: ‘expr’
[18:01:01.177]   - Field: ‘uuid’
[18:01:01.177]   - Field: ‘seed’
[18:01:01.177]   - Field: ‘version’
[18:01:01.177]   - Field: ‘result’
[18:01:01.178]   - Field: ‘asynchronous’
[18:01:01.178]   - Field: ‘calls’
[18:01:01.178]   - Field: ‘globals’
[18:01:01.178]   - Field: ‘stdout’
[18:01:01.178]   - Field: ‘earlySignal’
[18:01:01.179]   - Field: ‘lazy’
[18:01:01.179]   - Field: ‘state’
[18:01:01.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.179] - Launch lazy future ...
[18:01:01.180] Packages needed by the future expression (n = 0): <none>
[18:01:01.180] Packages needed by future strategies (n = 0): <none>
[18:01:01.181] {
[18:01:01.181]     {
[18:01:01.181]         {
[18:01:01.181]             ...future.startTime <- base::Sys.time()
[18:01:01.181]             {
[18:01:01.181]                 {
[18:01:01.181]                   {
[18:01:01.181]                     {
[18:01:01.181]                       base::local({
[18:01:01.181]                         has_future <- base::requireNamespace("future", 
[18:01:01.181]                           quietly = TRUE)
[18:01:01.181]                         if (has_future) {
[18:01:01.181]                           ns <- base::getNamespace("future")
[18:01:01.181]                           version <- ns[[".package"]][["version"]]
[18:01:01.181]                           if (is.null(version)) 
[18:01:01.181]                             version <- utils::packageVersion("future")
[18:01:01.181]                         }
[18:01:01.181]                         else {
[18:01:01.181]                           version <- NULL
[18:01:01.181]                         }
[18:01:01.181]                         if (!has_future || version < "1.8.0") {
[18:01:01.181]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.181]                             "", base::R.version$version.string), 
[18:01:01.181]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.181]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.181]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.181]                               "release", "version")], collapse = " "), 
[18:01:01.181]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.181]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.181]                             info)
[18:01:01.181]                           info <- base::paste(info, collapse = "; ")
[18:01:01.181]                           if (!has_future) {
[18:01:01.181]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.181]                               info)
[18:01:01.181]                           }
[18:01:01.181]                           else {
[18:01:01.181]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.181]                               info, version)
[18:01:01.181]                           }
[18:01:01.181]                           base::stop(msg)
[18:01:01.181]                         }
[18:01:01.181]                       })
[18:01:01.181]                     }
[18:01:01.181]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.181]                     base::options(mc.cores = 1L)
[18:01:01.181]                   }
[18:01:01.181]                   ...future.strategy.old <- future::plan("list")
[18:01:01.181]                   options(future.plan = NULL)
[18:01:01.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.181]                 }
[18:01:01.181]                 ...future.workdir <- getwd()
[18:01:01.181]             }
[18:01:01.181]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.181]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.181]         }
[18:01:01.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.181]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:01:01.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.181]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.181]             base::names(...future.oldOptions))
[18:01:01.181]     }
[18:01:01.181]     if (FALSE) {
[18:01:01.181]     }
[18:01:01.181]     else {
[18:01:01.181]         if (TRUE) {
[18:01:01.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.181]                 open = "w")
[18:01:01.181]         }
[18:01:01.181]         else {
[18:01:01.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.181]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.181]         }
[18:01:01.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.181]             base::sink(type = "output", split = FALSE)
[18:01:01.181]             base::close(...future.stdout)
[18:01:01.181]         }, add = TRUE)
[18:01:01.181]     }
[18:01:01.181]     ...future.frame <- base::sys.nframe()
[18:01:01.181]     ...future.conditions <- base::list()
[18:01:01.181]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.181]     if (FALSE) {
[18:01:01.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.181]     }
[18:01:01.181]     ...future.result <- base::tryCatch({
[18:01:01.181]         base::withCallingHandlers({
[18:01:01.181]             ...future.value <- base::withVisible(base::local({
[18:01:01.181]                 withCallingHandlers({
[18:01:01.181]                   {
[18:01:01.181]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.181]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.181]                       ...future.globals.maxSize)) {
[18:01:01.181]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.181]                       on.exit(options(oopts), add = TRUE)
[18:01:01.181]                     }
[18:01:01.181]                     {
[18:01:01.181]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.181]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.181]                         USE.NAMES = FALSE)
[18:01:01.181]                       do.call(mapply, args = args)
[18:01:01.181]                     }
[18:01:01.181]                   }
[18:01:01.181]                 }, immediateCondition = function(cond) {
[18:01:01.181]                   save_rds <- function (object, pathname, ...) 
[18:01:01.181]                   {
[18:01:01.181]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.181]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.181]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.181]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.181]                         fi_tmp[["mtime"]])
[18:01:01.181]                     }
[18:01:01.181]                     tryCatch({
[18:01:01.181]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.181]                     }, error = function(ex) {
[18:01:01.181]                       msg <- conditionMessage(ex)
[18:01:01.181]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.181]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.181]                         fi_tmp[["mtime"]], msg)
[18:01:01.181]                       ex$message <- msg
[18:01:01.181]                       stop(ex)
[18:01:01.181]                     })
[18:01:01.181]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.181]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.181]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.181]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.181]                       fi <- file.info(pathname)
[18:01:01.181]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.181]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.181]                         fi[["size"]], fi[["mtime"]])
[18:01:01.181]                       stop(msg)
[18:01:01.181]                     }
[18:01:01.181]                     invisible(pathname)
[18:01:01.181]                   }
[18:01:01.181]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.181]                     rootPath = tempdir()) 
[18:01:01.181]                   {
[18:01:01.181]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.181]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.181]                       tmpdir = path, fileext = ".rds")
[18:01:01.181]                     save_rds(obj, file)
[18:01:01.181]                   }
[18:01:01.181]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.181]                   {
[18:01:01.181]                     inherits <- base::inherits
[18:01:01.181]                     invokeRestart <- base::invokeRestart
[18:01:01.181]                     is.null <- base::is.null
[18:01:01.181]                     muffled <- FALSE
[18:01:01.181]                     if (inherits(cond, "message")) {
[18:01:01.181]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.181]                       if (muffled) 
[18:01:01.181]                         invokeRestart("muffleMessage")
[18:01:01.181]                     }
[18:01:01.181]                     else if (inherits(cond, "warning")) {
[18:01:01.181]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.181]                       if (muffled) 
[18:01:01.181]                         invokeRestart("muffleWarning")
[18:01:01.181]                     }
[18:01:01.181]                     else if (inherits(cond, "condition")) {
[18:01:01.181]                       if (!is.null(pattern)) {
[18:01:01.181]                         computeRestarts <- base::computeRestarts
[18:01:01.181]                         grepl <- base::grepl
[18:01:01.181]                         restarts <- computeRestarts(cond)
[18:01:01.181]                         for (restart in restarts) {
[18:01:01.181]                           name <- restart$name
[18:01:01.181]                           if (is.null(name)) 
[18:01:01.181]                             next
[18:01:01.181]                           if (!grepl(pattern, name)) 
[18:01:01.181]                             next
[18:01:01.181]                           invokeRestart(restart)
[18:01:01.181]                           muffled <- TRUE
[18:01:01.181]                           break
[18:01:01.181]                         }
[18:01:01.181]                       }
[18:01:01.181]                     }
[18:01:01.181]                     invisible(muffled)
[18:01:01.181]                   }
[18:01:01.181]                   muffleCondition(cond)
[18:01:01.181]                 })
[18:01:01.181]             }))
[18:01:01.181]             future::FutureResult(value = ...future.value$value, 
[18:01:01.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.181]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.181]                     ...future.globalenv.names))
[18:01:01.181]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.181]         }, condition = base::local({
[18:01:01.181]             c <- base::c
[18:01:01.181]             inherits <- base::inherits
[18:01:01.181]             invokeRestart <- base::invokeRestart
[18:01:01.181]             length <- base::length
[18:01:01.181]             list <- base::list
[18:01:01.181]             seq.int <- base::seq.int
[18:01:01.181]             signalCondition <- base::signalCondition
[18:01:01.181]             sys.calls <- base::sys.calls
[18:01:01.181]             `[[` <- base::`[[`
[18:01:01.181]             `+` <- base::`+`
[18:01:01.181]             `<<-` <- base::`<<-`
[18:01:01.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.181]                   3L)]
[18:01:01.181]             }
[18:01:01.181]             function(cond) {
[18:01:01.181]                 is_error <- inherits(cond, "error")
[18:01:01.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.181]                   NULL)
[18:01:01.181]                 if (is_error) {
[18:01:01.181]                   sessionInformation <- function() {
[18:01:01.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.181]                       search = base::search(), system = base::Sys.info())
[18:01:01.181]                   }
[18:01:01.181]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.181]                     cond$call), session = sessionInformation(), 
[18:01:01.181]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.181]                   signalCondition(cond)
[18:01:01.181]                 }
[18:01:01.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.181]                 "immediateCondition"))) {
[18:01:01.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.181]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.181]                   if (TRUE && !signal) {
[18:01:01.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.181]                     {
[18:01:01.181]                       inherits <- base::inherits
[18:01:01.181]                       invokeRestart <- base::invokeRestart
[18:01:01.181]                       is.null <- base::is.null
[18:01:01.181]                       muffled <- FALSE
[18:01:01.181]                       if (inherits(cond, "message")) {
[18:01:01.181]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.181]                         if (muffled) 
[18:01:01.181]                           invokeRestart("muffleMessage")
[18:01:01.181]                       }
[18:01:01.181]                       else if (inherits(cond, "warning")) {
[18:01:01.181]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.181]                         if (muffled) 
[18:01:01.181]                           invokeRestart("muffleWarning")
[18:01:01.181]                       }
[18:01:01.181]                       else if (inherits(cond, "condition")) {
[18:01:01.181]                         if (!is.null(pattern)) {
[18:01:01.181]                           computeRestarts <- base::computeRestarts
[18:01:01.181]                           grepl <- base::grepl
[18:01:01.181]                           restarts <- computeRestarts(cond)
[18:01:01.181]                           for (restart in restarts) {
[18:01:01.181]                             name <- restart$name
[18:01:01.181]                             if (is.null(name)) 
[18:01:01.181]                               next
[18:01:01.181]                             if (!grepl(pattern, name)) 
[18:01:01.181]                               next
[18:01:01.181]                             invokeRestart(restart)
[18:01:01.181]                             muffled <- TRUE
[18:01:01.181]                             break
[18:01:01.181]                           }
[18:01:01.181]                         }
[18:01:01.181]                       }
[18:01:01.181]                       invisible(muffled)
[18:01:01.181]                     }
[18:01:01.181]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.181]                   }
[18:01:01.181]                 }
[18:01:01.181]                 else {
[18:01:01.181]                   if (TRUE) {
[18:01:01.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.181]                     {
[18:01:01.181]                       inherits <- base::inherits
[18:01:01.181]                       invokeRestart <- base::invokeRestart
[18:01:01.181]                       is.null <- base::is.null
[18:01:01.181]                       muffled <- FALSE
[18:01:01.181]                       if (inherits(cond, "message")) {
[18:01:01.181]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.181]                         if (muffled) 
[18:01:01.181]                           invokeRestart("muffleMessage")
[18:01:01.181]                       }
[18:01:01.181]                       else if (inherits(cond, "warning")) {
[18:01:01.181]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.181]                         if (muffled) 
[18:01:01.181]                           invokeRestart("muffleWarning")
[18:01:01.181]                       }
[18:01:01.181]                       else if (inherits(cond, "condition")) {
[18:01:01.181]                         if (!is.null(pattern)) {
[18:01:01.181]                           computeRestarts <- base::computeRestarts
[18:01:01.181]                           grepl <- base::grepl
[18:01:01.181]                           restarts <- computeRestarts(cond)
[18:01:01.181]                           for (restart in restarts) {
[18:01:01.181]                             name <- restart$name
[18:01:01.181]                             if (is.null(name)) 
[18:01:01.181]                               next
[18:01:01.181]                             if (!grepl(pattern, name)) 
[18:01:01.181]                               next
[18:01:01.181]                             invokeRestart(restart)
[18:01:01.181]                             muffled <- TRUE
[18:01:01.181]                             break
[18:01:01.181]                           }
[18:01:01.181]                         }
[18:01:01.181]                       }
[18:01:01.181]                       invisible(muffled)
[18:01:01.181]                     }
[18:01:01.181]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.181]                   }
[18:01:01.181]                 }
[18:01:01.181]             }
[18:01:01.181]         }))
[18:01:01.181]     }, error = function(ex) {
[18:01:01.181]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.181]                 ...future.rng), started = ...future.startTime, 
[18:01:01.181]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.181]             version = "1.8"), class = "FutureResult")
[18:01:01.181]     }, finally = {
[18:01:01.181]         if (!identical(...future.workdir, getwd())) 
[18:01:01.181]             setwd(...future.workdir)
[18:01:01.181]         {
[18:01:01.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.181]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.181]             }
[18:01:01.181]             base::options(...future.oldOptions)
[18:01:01.181]             if (.Platform$OS.type == "windows") {
[18:01:01.181]                 old_names <- names(...future.oldEnvVars)
[18:01:01.181]                 envs <- base::Sys.getenv()
[18:01:01.181]                 names <- names(envs)
[18:01:01.181]                 common <- intersect(names, old_names)
[18:01:01.181]                 added <- setdiff(names, old_names)
[18:01:01.181]                 removed <- setdiff(old_names, names)
[18:01:01.181]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.181]                   envs[common]]
[18:01:01.181]                 NAMES <- toupper(changed)
[18:01:01.181]                 args <- list()
[18:01:01.181]                 for (kk in seq_along(NAMES)) {
[18:01:01.181]                   name <- changed[[kk]]
[18:01:01.181]                   NAME <- NAMES[[kk]]
[18:01:01.181]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.181]                     next
[18:01:01.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.181]                 }
[18:01:01.181]                 NAMES <- toupper(added)
[18:01:01.181]                 for (kk in seq_along(NAMES)) {
[18:01:01.181]                   name <- added[[kk]]
[18:01:01.181]                   NAME <- NAMES[[kk]]
[18:01:01.181]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.181]                     next
[18:01:01.181]                   args[[name]] <- ""
[18:01:01.181]                 }
[18:01:01.181]                 NAMES <- toupper(removed)
[18:01:01.181]                 for (kk in seq_along(NAMES)) {
[18:01:01.181]                   name <- removed[[kk]]
[18:01:01.181]                   NAME <- NAMES[[kk]]
[18:01:01.181]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.181]                     next
[18:01:01.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.181]                 }
[18:01:01.181]                 if (length(args) > 0) 
[18:01:01.181]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.181]             }
[18:01:01.181]             else {
[18:01:01.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.181]             }
[18:01:01.181]             {
[18:01:01.181]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.181]                   0L) {
[18:01:01.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.181]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.181]                   base::options(opts)
[18:01:01.181]                 }
[18:01:01.181]                 {
[18:01:01.181]                   {
[18:01:01.181]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.181]                     NULL
[18:01:01.181]                   }
[18:01:01.181]                   options(future.plan = NULL)
[18:01:01.181]                   if (is.na(NA_character_)) 
[18:01:01.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.181]                     .init = FALSE)
[18:01:01.181]                 }
[18:01:01.181]             }
[18:01:01.181]         }
[18:01:01.181]     })
[18:01:01.181]     if (TRUE) {
[18:01:01.181]         base::sink(type = "output", split = FALSE)
[18:01:01.181]         if (TRUE) {
[18:01:01.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.181]         }
[18:01:01.181]         else {
[18:01:01.181]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.181]         }
[18:01:01.181]         base::close(...future.stdout)
[18:01:01.181]         ...future.stdout <- NULL
[18:01:01.181]     }
[18:01:01.181]     ...future.result$conditions <- ...future.conditions
[18:01:01.181]     ...future.result$finished <- base::Sys.time()
[18:01:01.181]     ...future.result
[18:01:01.181] }
[18:01:01.185] assign_globals() ...
[18:01:01.185] List of 5
[18:01:01.185]  $ ...future.FUN            :function (C, k)  
[18:01:01.185]  $ MoreArgs                 : NULL
[18:01:01.185]  $ ...future.elements_ii    :List of 2
[18:01:01.185]   ..$ :List of 2
[18:01:01.185]   .. ..$ : chr "E"
[18:01:01.185]   .. ..$ : chr "B"
[18:01:01.185]   ..$ :List of 2
[18:01:01.185]   .. ..$ : int 1
[18:01:01.185]   .. ..$ : int 4
[18:01:01.185]  $ ...future.seeds_ii       : NULL
[18:01:01.185]  $ ...future.globals.maxSize: NULL
[18:01:01.185]  - attr(*, "where")=List of 5
[18:01:01.185]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.185]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.185]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.185]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.185]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.185]  - attr(*, "resolved")= logi FALSE
[18:01:01.185]  - attr(*, "total_size")= num 3656
[18:01:01.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.185]  - attr(*, "already-done")= logi TRUE
[18:01:01.200] - reassign environment for ‘...future.FUN’
[18:01:01.201] - copied ‘...future.FUN’ to environment
[18:01:01.201] - copied ‘MoreArgs’ to environment
[18:01:01.201] - copied ‘...future.elements_ii’ to environment
[18:01:01.201] - copied ‘...future.seeds_ii’ to environment
[18:01:01.202] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.202] assign_globals() ... done
[18:01:01.202] requestCore(): workers = 2
[18:01:01.206] MulticoreFuture started
[18:01:01.207] - Launch lazy future ... done
[18:01:01.208] run() for ‘MulticoreFuture’ ... done
[18:01:01.210] Created future:
[18:01:01.212] plan(): Setting new future strategy stack:
[18:01:01.213] List of future strategies:
[18:01:01.213] 1. sequential:
[18:01:01.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.213]    - tweaked: FALSE
[18:01:01.213]    - call: NULL
[18:01:01.215] plan(): nbrOfWorkers() = 1
[18:01:01.220] plan(): Setting new future strategy stack:
[18:01:01.220] List of future strategies:
[18:01:01.220] 1. multicore:
[18:01:01.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.220]    - tweaked: FALSE
[18:01:01.220]    - call: plan(strategy)
[18:01:01.211] MulticoreFuture:
[18:01:01.211] Label: ‘future_mapply-1’
[18:01:01.211] Expression:
[18:01:01.211] {
[18:01:01.211]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.211]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.211]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.211]         on.exit(options(oopts), add = TRUE)
[18:01:01.211]     }
[18:01:01.211]     {
[18:01:01.211]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.211]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.211]         do.call(mapply, args = args)
[18:01:01.211]     }
[18:01:01.211] }
[18:01:01.211] Lazy evaluation: FALSE
[18:01:01.211] Asynchronous evaluation: TRUE
[18:01:01.211] Local evaluation: TRUE
[18:01:01.211] Environment: R_GlobalEnv
[18:01:01.211] Capture standard output: TRUE
[18:01:01.211] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.211] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.211] Packages: <none>
[18:01:01.211] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.211] Resolved: FALSE
[18:01:01.211] Value: <not collected>
[18:01:01.211] Conditions captured: <none>
[18:01:01.211] Early signaling: FALSE
[18:01:01.211] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.211] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.227] Chunk #1 of 3 ... DONE
[18:01:01.227] Chunk #2 of 3 ...
[18:01:01.228]  - Finding globals in '...' for chunk #2 ...
[18:01:01.228] getGlobalsAndPackages() ...
[18:01:01.228] Searching for globals...
[18:01:01.230] 
[18:01:01.230] Searching for globals ... DONE
[18:01:01.230] plan(): nbrOfWorkers() = 2
[18:01:01.230] - globals: [0] <none>
[18:01:01.230] getGlobalsAndPackages() ... DONE
[18:01:01.231]    + additional globals found: [n=0] 
[18:01:01.231]    + additional namespaces needed: [n=0] 
[18:01:01.231]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:01.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:01:01.232]  - seeds: <none>
[18:01:01.232]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.233] getGlobalsAndPackages() ...
[18:01:01.233] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.234] Resolving globals: FALSE
[18:01:01.236] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:01.237] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:01.238] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.238] 
[18:01:01.239] getGlobalsAndPackages() ... DONE
[18:01:01.240] run() for ‘Future’ ...
[18:01:01.240] - state: ‘created’
[18:01:01.241] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.249] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.249] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.250]   - Field: ‘label’
[18:01:01.250]   - Field: ‘local’
[18:01:01.251]   - Field: ‘owner’
[18:01:01.251]   - Field: ‘envir’
[18:01:01.251]   - Field: ‘workers’
[18:01:01.251]   - Field: ‘packages’
[18:01:01.252]   - Field: ‘gc’
[18:01:01.252]   - Field: ‘job’
[18:01:01.252]   - Field: ‘conditions’
[18:01:01.253]   - Field: ‘expr’
[18:01:01.253]   - Field: ‘uuid’
[18:01:01.253]   - Field: ‘seed’
[18:01:01.254]   - Field: ‘version’
[18:01:01.254]   - Field: ‘result’
[18:01:01.254]   - Field: ‘asynchronous’
[18:01:01.255]   - Field: ‘calls’
[18:01:01.255]   - Field: ‘globals’
[18:01:01.255]   - Field: ‘stdout’
[18:01:01.256]   - Field: ‘earlySignal’
[18:01:01.256]   - Field: ‘lazy’
[18:01:01.256]   - Field: ‘state’
[18:01:01.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.257] - Launch lazy future ...
[18:01:01.258] Packages needed by the future expression (n = 0): <none>
[18:01:01.259] Packages needed by future strategies (n = 0): <none>
[18:01:01.260] {
[18:01:01.260]     {
[18:01:01.260]         {
[18:01:01.260]             ...future.startTime <- base::Sys.time()
[18:01:01.260]             {
[18:01:01.260]                 {
[18:01:01.260]                   {
[18:01:01.260]                     {
[18:01:01.260]                       base::local({
[18:01:01.260]                         has_future <- base::requireNamespace("future", 
[18:01:01.260]                           quietly = TRUE)
[18:01:01.260]                         if (has_future) {
[18:01:01.260]                           ns <- base::getNamespace("future")
[18:01:01.260]                           version <- ns[[".package"]][["version"]]
[18:01:01.260]                           if (is.null(version)) 
[18:01:01.260]                             version <- utils::packageVersion("future")
[18:01:01.260]                         }
[18:01:01.260]                         else {
[18:01:01.260]                           version <- NULL
[18:01:01.260]                         }
[18:01:01.260]                         if (!has_future || version < "1.8.0") {
[18:01:01.260]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.260]                             "", base::R.version$version.string), 
[18:01:01.260]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.260]                               "release", "version")], collapse = " "), 
[18:01:01.260]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.260]                             info)
[18:01:01.260]                           info <- base::paste(info, collapse = "; ")
[18:01:01.260]                           if (!has_future) {
[18:01:01.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.260]                               info)
[18:01:01.260]                           }
[18:01:01.260]                           else {
[18:01:01.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.260]                               info, version)
[18:01:01.260]                           }
[18:01:01.260]                           base::stop(msg)
[18:01:01.260]                         }
[18:01:01.260]                       })
[18:01:01.260]                     }
[18:01:01.260]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.260]                     base::options(mc.cores = 1L)
[18:01:01.260]                   }
[18:01:01.260]                   ...future.strategy.old <- future::plan("list")
[18:01:01.260]                   options(future.plan = NULL)
[18:01:01.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.260]                 }
[18:01:01.260]                 ...future.workdir <- getwd()
[18:01:01.260]             }
[18:01:01.260]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.260]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.260]         }
[18:01:01.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.260]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:01:01.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.260]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.260]             base::names(...future.oldOptions))
[18:01:01.260]     }
[18:01:01.260]     if (FALSE) {
[18:01:01.260]     }
[18:01:01.260]     else {
[18:01:01.260]         if (TRUE) {
[18:01:01.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.260]                 open = "w")
[18:01:01.260]         }
[18:01:01.260]         else {
[18:01:01.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.260]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.260]         }
[18:01:01.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.260]             base::sink(type = "output", split = FALSE)
[18:01:01.260]             base::close(...future.stdout)
[18:01:01.260]         }, add = TRUE)
[18:01:01.260]     }
[18:01:01.260]     ...future.frame <- base::sys.nframe()
[18:01:01.260]     ...future.conditions <- base::list()
[18:01:01.260]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.260]     if (FALSE) {
[18:01:01.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.260]     }
[18:01:01.260]     ...future.result <- base::tryCatch({
[18:01:01.260]         base::withCallingHandlers({
[18:01:01.260]             ...future.value <- base::withVisible(base::local({
[18:01:01.260]                 withCallingHandlers({
[18:01:01.260]                   {
[18:01:01.260]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.260]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.260]                       ...future.globals.maxSize)) {
[18:01:01.260]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.260]                       on.exit(options(oopts), add = TRUE)
[18:01:01.260]                     }
[18:01:01.260]                     {
[18:01:01.260]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.260]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.260]                         USE.NAMES = FALSE)
[18:01:01.260]                       do.call(mapply, args = args)
[18:01:01.260]                     }
[18:01:01.260]                   }
[18:01:01.260]                 }, immediateCondition = function(cond) {
[18:01:01.260]                   save_rds <- function (object, pathname, ...) 
[18:01:01.260]                   {
[18:01:01.260]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.260]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.260]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.260]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.260]                         fi_tmp[["mtime"]])
[18:01:01.260]                     }
[18:01:01.260]                     tryCatch({
[18:01:01.260]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.260]                     }, error = function(ex) {
[18:01:01.260]                       msg <- conditionMessage(ex)
[18:01:01.260]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.260]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.260]                         fi_tmp[["mtime"]], msg)
[18:01:01.260]                       ex$message <- msg
[18:01:01.260]                       stop(ex)
[18:01:01.260]                     })
[18:01:01.260]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.260]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.260]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.260]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.260]                       fi <- file.info(pathname)
[18:01:01.260]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.260]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.260]                         fi[["size"]], fi[["mtime"]])
[18:01:01.260]                       stop(msg)
[18:01:01.260]                     }
[18:01:01.260]                     invisible(pathname)
[18:01:01.260]                   }
[18:01:01.260]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.260]                     rootPath = tempdir()) 
[18:01:01.260]                   {
[18:01:01.260]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.260]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.260]                       tmpdir = path, fileext = ".rds")
[18:01:01.260]                     save_rds(obj, file)
[18:01:01.260]                   }
[18:01:01.260]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.260]                   {
[18:01:01.260]                     inherits <- base::inherits
[18:01:01.260]                     invokeRestart <- base::invokeRestart
[18:01:01.260]                     is.null <- base::is.null
[18:01:01.260]                     muffled <- FALSE
[18:01:01.260]                     if (inherits(cond, "message")) {
[18:01:01.260]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.260]                       if (muffled) 
[18:01:01.260]                         invokeRestart("muffleMessage")
[18:01:01.260]                     }
[18:01:01.260]                     else if (inherits(cond, "warning")) {
[18:01:01.260]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.260]                       if (muffled) 
[18:01:01.260]                         invokeRestart("muffleWarning")
[18:01:01.260]                     }
[18:01:01.260]                     else if (inherits(cond, "condition")) {
[18:01:01.260]                       if (!is.null(pattern)) {
[18:01:01.260]                         computeRestarts <- base::computeRestarts
[18:01:01.260]                         grepl <- base::grepl
[18:01:01.260]                         restarts <- computeRestarts(cond)
[18:01:01.260]                         for (restart in restarts) {
[18:01:01.260]                           name <- restart$name
[18:01:01.260]                           if (is.null(name)) 
[18:01:01.260]                             next
[18:01:01.260]                           if (!grepl(pattern, name)) 
[18:01:01.260]                             next
[18:01:01.260]                           invokeRestart(restart)
[18:01:01.260]                           muffled <- TRUE
[18:01:01.260]                           break
[18:01:01.260]                         }
[18:01:01.260]                       }
[18:01:01.260]                     }
[18:01:01.260]                     invisible(muffled)
[18:01:01.260]                   }
[18:01:01.260]                   muffleCondition(cond)
[18:01:01.260]                 })
[18:01:01.260]             }))
[18:01:01.260]             future::FutureResult(value = ...future.value$value, 
[18:01:01.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.260]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.260]                     ...future.globalenv.names))
[18:01:01.260]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.260]         }, condition = base::local({
[18:01:01.260]             c <- base::c
[18:01:01.260]             inherits <- base::inherits
[18:01:01.260]             invokeRestart <- base::invokeRestart
[18:01:01.260]             length <- base::length
[18:01:01.260]             list <- base::list
[18:01:01.260]             seq.int <- base::seq.int
[18:01:01.260]             signalCondition <- base::signalCondition
[18:01:01.260]             sys.calls <- base::sys.calls
[18:01:01.260]             `[[` <- base::`[[`
[18:01:01.260]             `+` <- base::`+`
[18:01:01.260]             `<<-` <- base::`<<-`
[18:01:01.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.260]                   3L)]
[18:01:01.260]             }
[18:01:01.260]             function(cond) {
[18:01:01.260]                 is_error <- inherits(cond, "error")
[18:01:01.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.260]                   NULL)
[18:01:01.260]                 if (is_error) {
[18:01:01.260]                   sessionInformation <- function() {
[18:01:01.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.260]                       search = base::search(), system = base::Sys.info())
[18:01:01.260]                   }
[18:01:01.260]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.260]                     cond$call), session = sessionInformation(), 
[18:01:01.260]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.260]                   signalCondition(cond)
[18:01:01.260]                 }
[18:01:01.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.260]                 "immediateCondition"))) {
[18:01:01.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.260]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.260]                   if (TRUE && !signal) {
[18:01:01.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.260]                     {
[18:01:01.260]                       inherits <- base::inherits
[18:01:01.260]                       invokeRestart <- base::invokeRestart
[18:01:01.260]                       is.null <- base::is.null
[18:01:01.260]                       muffled <- FALSE
[18:01:01.260]                       if (inherits(cond, "message")) {
[18:01:01.260]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.260]                         if (muffled) 
[18:01:01.260]                           invokeRestart("muffleMessage")
[18:01:01.260]                       }
[18:01:01.260]                       else if (inherits(cond, "warning")) {
[18:01:01.260]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.260]                         if (muffled) 
[18:01:01.260]                           invokeRestart("muffleWarning")
[18:01:01.260]                       }
[18:01:01.260]                       else if (inherits(cond, "condition")) {
[18:01:01.260]                         if (!is.null(pattern)) {
[18:01:01.260]                           computeRestarts <- base::computeRestarts
[18:01:01.260]                           grepl <- base::grepl
[18:01:01.260]                           restarts <- computeRestarts(cond)
[18:01:01.260]                           for (restart in restarts) {
[18:01:01.260]                             name <- restart$name
[18:01:01.260]                             if (is.null(name)) 
[18:01:01.260]                               next
[18:01:01.260]                             if (!grepl(pattern, name)) 
[18:01:01.260]                               next
[18:01:01.260]                             invokeRestart(restart)
[18:01:01.260]                             muffled <- TRUE
[18:01:01.260]                             break
[18:01:01.260]                           }
[18:01:01.260]                         }
[18:01:01.260]                       }
[18:01:01.260]                       invisible(muffled)
[18:01:01.260]                     }
[18:01:01.260]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.260]                   }
[18:01:01.260]                 }
[18:01:01.260]                 else {
[18:01:01.260]                   if (TRUE) {
[18:01:01.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.260]                     {
[18:01:01.260]                       inherits <- base::inherits
[18:01:01.260]                       invokeRestart <- base::invokeRestart
[18:01:01.260]                       is.null <- base::is.null
[18:01:01.260]                       muffled <- FALSE
[18:01:01.260]                       if (inherits(cond, "message")) {
[18:01:01.260]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.260]                         if (muffled) 
[18:01:01.260]                           invokeRestart("muffleMessage")
[18:01:01.260]                       }
[18:01:01.260]                       else if (inherits(cond, "warning")) {
[18:01:01.260]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.260]                         if (muffled) 
[18:01:01.260]                           invokeRestart("muffleWarning")
[18:01:01.260]                       }
[18:01:01.260]                       else if (inherits(cond, "condition")) {
[18:01:01.260]                         if (!is.null(pattern)) {
[18:01:01.260]                           computeRestarts <- base::computeRestarts
[18:01:01.260]                           grepl <- base::grepl
[18:01:01.260]                           restarts <- computeRestarts(cond)
[18:01:01.260]                           for (restart in restarts) {
[18:01:01.260]                             name <- restart$name
[18:01:01.260]                             if (is.null(name)) 
[18:01:01.260]                               next
[18:01:01.260]                             if (!grepl(pattern, name)) 
[18:01:01.260]                               next
[18:01:01.260]                             invokeRestart(restart)
[18:01:01.260]                             muffled <- TRUE
[18:01:01.260]                             break
[18:01:01.260]                           }
[18:01:01.260]                         }
[18:01:01.260]                       }
[18:01:01.260]                       invisible(muffled)
[18:01:01.260]                     }
[18:01:01.260]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.260]                   }
[18:01:01.260]                 }
[18:01:01.260]             }
[18:01:01.260]         }))
[18:01:01.260]     }, error = function(ex) {
[18:01:01.260]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.260]                 ...future.rng), started = ...future.startTime, 
[18:01:01.260]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.260]             version = "1.8"), class = "FutureResult")
[18:01:01.260]     }, finally = {
[18:01:01.260]         if (!identical(...future.workdir, getwd())) 
[18:01:01.260]             setwd(...future.workdir)
[18:01:01.260]         {
[18:01:01.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.260]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.260]             }
[18:01:01.260]             base::options(...future.oldOptions)
[18:01:01.260]             if (.Platform$OS.type == "windows") {
[18:01:01.260]                 old_names <- names(...future.oldEnvVars)
[18:01:01.260]                 envs <- base::Sys.getenv()
[18:01:01.260]                 names <- names(envs)
[18:01:01.260]                 common <- intersect(names, old_names)
[18:01:01.260]                 added <- setdiff(names, old_names)
[18:01:01.260]                 removed <- setdiff(old_names, names)
[18:01:01.260]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.260]                   envs[common]]
[18:01:01.260]                 NAMES <- toupper(changed)
[18:01:01.260]                 args <- list()
[18:01:01.260]                 for (kk in seq_along(NAMES)) {
[18:01:01.260]                   name <- changed[[kk]]
[18:01:01.260]                   NAME <- NAMES[[kk]]
[18:01:01.260]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.260]                     next
[18:01:01.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.260]                 }
[18:01:01.260]                 NAMES <- toupper(added)
[18:01:01.260]                 for (kk in seq_along(NAMES)) {
[18:01:01.260]                   name <- added[[kk]]
[18:01:01.260]                   NAME <- NAMES[[kk]]
[18:01:01.260]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.260]                     next
[18:01:01.260]                   args[[name]] <- ""
[18:01:01.260]                 }
[18:01:01.260]                 NAMES <- toupper(removed)
[18:01:01.260]                 for (kk in seq_along(NAMES)) {
[18:01:01.260]                   name <- removed[[kk]]
[18:01:01.260]                   NAME <- NAMES[[kk]]
[18:01:01.260]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.260]                     next
[18:01:01.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.260]                 }
[18:01:01.260]                 if (length(args) > 0) 
[18:01:01.260]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.260]             }
[18:01:01.260]             else {
[18:01:01.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.260]             }
[18:01:01.260]             {
[18:01:01.260]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.260]                   0L) {
[18:01:01.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.260]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.260]                   base::options(opts)
[18:01:01.260]                 }
[18:01:01.260]                 {
[18:01:01.260]                   {
[18:01:01.260]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.260]                     NULL
[18:01:01.260]                   }
[18:01:01.260]                   options(future.plan = NULL)
[18:01:01.260]                   if (is.na(NA_character_)) 
[18:01:01.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.260]                     .init = FALSE)
[18:01:01.260]                 }
[18:01:01.260]             }
[18:01:01.260]         }
[18:01:01.260]     })
[18:01:01.260]     if (TRUE) {
[18:01:01.260]         base::sink(type = "output", split = FALSE)
[18:01:01.260]         if (TRUE) {
[18:01:01.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.260]         }
[18:01:01.260]         else {
[18:01:01.260]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.260]         }
[18:01:01.260]         base::close(...future.stdout)
[18:01:01.260]         ...future.stdout <- NULL
[18:01:01.260]     }
[18:01:01.260]     ...future.result$conditions <- ...future.conditions
[18:01:01.260]     ...future.result$finished <- base::Sys.time()
[18:01:01.260]     ...future.result
[18:01:01.260] }
[18:01:01.267] assign_globals() ...
[18:01:01.268] List of 5
[18:01:01.268]  $ ...future.FUN            :function (C, k)  
[18:01:01.268]  $ MoreArgs                 : NULL
[18:01:01.268]  $ ...future.elements_ii    :List of 2
[18:01:01.268]   ..$ :List of 1
[18:01:01.268]   .. ..$ : chr "D"
[18:01:01.268]   ..$ :List of 1
[18:01:01.268]   .. ..$ : int 2
[18:01:01.268]  $ ...future.seeds_ii       : NULL
[18:01:01.268]  $ ...future.globals.maxSize: NULL
[18:01:01.268]  - attr(*, "where")=List of 5
[18:01:01.268]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.268]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.268]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.268]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.268]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.268]  - attr(*, "resolved")= logi FALSE
[18:01:01.268]  - attr(*, "total_size")= num 3488
[18:01:01.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.268]  - attr(*, "already-done")= logi TRUE
[18:01:01.290] - reassign environment for ‘...future.FUN’
[18:01:01.290] - copied ‘...future.FUN’ to environment
[18:01:01.291] - copied ‘MoreArgs’ to environment
[18:01:01.291] - copied ‘...future.elements_ii’ to environment
[18:01:01.292] - copied ‘...future.seeds_ii’ to environment
[18:01:01.292] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.292] assign_globals() ... done
[18:01:01.293] requestCore(): workers = 2
[18:01:01.299] MulticoreFuture started
[18:01:01.303] - Launch lazy future ... done
[18:01:01.305] plan(): Setting new future strategy stack:
[18:01:01.304] run() for ‘MulticoreFuture’ ... done
[18:01:01.307] Created future:
[18:01:01.306] List of future strategies:
[18:01:01.306] 1. sequential:
[18:01:01.306]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.306]    - tweaked: FALSE
[18:01:01.306]    - call: NULL
[18:01:01.316] plan(): nbrOfWorkers() = 1
[18:01:01.326] plan(): Setting new future strategy stack:
[18:01:01.327] List of future strategies:
[18:01:01.327] 1. multicore:
[18:01:01.327]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.327]    - tweaked: FALSE
[18:01:01.327]    - call: plan(strategy)
[18:01:01.308] MulticoreFuture:
[18:01:01.308] Label: ‘future_mapply-2’
[18:01:01.308] Expression:
[18:01:01.308] {
[18:01:01.308]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.308]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.308]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.308]         on.exit(options(oopts), add = TRUE)
[18:01:01.308]     }
[18:01:01.308]     {
[18:01:01.308]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.308]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.308]         do.call(mapply, args = args)
[18:01:01.308]     }
[18:01:01.308] }
[18:01:01.308] Lazy evaluation: FALSE
[18:01:01.308] Asynchronous evaluation: TRUE
[18:01:01.308] Local evaluation: TRUE
[18:01:01.308] Environment: R_GlobalEnv
[18:01:01.308] Capture standard output: TRUE
[18:01:01.308] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.308] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.308] Packages: <none>
[18:01:01.308] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.308] Resolved: FALSE
[18:01:01.308] Value: <not collected>
[18:01:01.308] Conditions captured: <none>
[18:01:01.308] Early signaling: FALSE
[18:01:01.308] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.308] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.333] Chunk #2 of 3 ... DONE
[18:01:01.334] Chunk #3 of 3 ...
[18:01:01.334]  - Finding globals in '...' for chunk #3 ...
[18:01:01.335] getGlobalsAndPackages() ...
[18:01:01.335] Searching for globals...
[18:01:01.337] 
[18:01:01.337] Searching for globals ... DONE
[18:01:01.338] - globals: [0] <none>
[18:01:01.338] getGlobalsAndPackages() ... DONE
[18:01:01.338] plan(): nbrOfWorkers() = 2
[18:01:01.339]    + additional globals found: [n=0] 
[18:01:01.339]    + additional namespaces needed: [n=0] 
[18:01:01.339]  - Finding globals in '...' for chunk #3 ... DONE
[18:01:01.340]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:01:01.342]  - seeds: <none>
[18:01:01.342]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.343] getGlobalsAndPackages() ...
[18:01:01.344] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.344] Resolving globals: FALSE
[18:01:01.346] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:01.347] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:01.348] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.348] 
[18:01:01.349] getGlobalsAndPackages() ... DONE
[18:01:01.350] run() for ‘Future’ ...
[18:01:01.350] - state: ‘created’
[18:01:01.350] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.359] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.360]   - Field: ‘label’
[18:01:01.360]   - Field: ‘local’
[18:01:01.360]   - Field: ‘owner’
[18:01:01.361]   - Field: ‘envir’
[18:01:01.361]   - Field: ‘workers’
[18:01:01.361]   - Field: ‘packages’
[18:01:01.361]   - Field: ‘gc’
[18:01:01.362]   - Field: ‘job’
[18:01:01.362]   - Field: ‘conditions’
[18:01:01.362]   - Field: ‘expr’
[18:01:01.363]   - Field: ‘uuid’
[18:01:01.363]   - Field: ‘seed’
[18:01:01.363]   - Field: ‘version’
[18:01:01.363]   - Field: ‘result’
[18:01:01.364]   - Field: ‘asynchronous’
[18:01:01.364]   - Field: ‘calls’
[18:01:01.364]   - Field: ‘globals’
[18:01:01.364]   - Field: ‘stdout’
[18:01:01.365]   - Field: ‘earlySignal’
[18:01:01.365]   - Field: ‘lazy’
[18:01:01.365]   - Field: ‘state’
[18:01:01.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.366] - Launch lazy future ...
[18:01:01.367] Packages needed by the future expression (n = 0): <none>
[18:01:01.367] Packages needed by future strategies (n = 0): <none>
[18:01:01.368] {
[18:01:01.368]     {
[18:01:01.368]         {
[18:01:01.368]             ...future.startTime <- base::Sys.time()
[18:01:01.368]             {
[18:01:01.368]                 {
[18:01:01.368]                   {
[18:01:01.368]                     {
[18:01:01.368]                       base::local({
[18:01:01.368]                         has_future <- base::requireNamespace("future", 
[18:01:01.368]                           quietly = TRUE)
[18:01:01.368]                         if (has_future) {
[18:01:01.368]                           ns <- base::getNamespace("future")
[18:01:01.368]                           version <- ns[[".package"]][["version"]]
[18:01:01.368]                           if (is.null(version)) 
[18:01:01.368]                             version <- utils::packageVersion("future")
[18:01:01.368]                         }
[18:01:01.368]                         else {
[18:01:01.368]                           version <- NULL
[18:01:01.368]                         }
[18:01:01.368]                         if (!has_future || version < "1.8.0") {
[18:01:01.368]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.368]                             "", base::R.version$version.string), 
[18:01:01.368]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.368]                               "release", "version")], collapse = " "), 
[18:01:01.368]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.368]                             info)
[18:01:01.368]                           info <- base::paste(info, collapse = "; ")
[18:01:01.368]                           if (!has_future) {
[18:01:01.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.368]                               info)
[18:01:01.368]                           }
[18:01:01.368]                           else {
[18:01:01.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.368]                               info, version)
[18:01:01.368]                           }
[18:01:01.368]                           base::stop(msg)
[18:01:01.368]                         }
[18:01:01.368]                       })
[18:01:01.368]                     }
[18:01:01.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.368]                     base::options(mc.cores = 1L)
[18:01:01.368]                   }
[18:01:01.368]                   ...future.strategy.old <- future::plan("list")
[18:01:01.368]                   options(future.plan = NULL)
[18:01:01.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.368]                 }
[18:01:01.368]                 ...future.workdir <- getwd()
[18:01:01.368]             }
[18:01:01.368]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.368]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.368]         }
[18:01:01.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.368]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:01:01.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.368]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.368]             base::names(...future.oldOptions))
[18:01:01.368]     }
[18:01:01.368]     if (FALSE) {
[18:01:01.368]     }
[18:01:01.368]     else {
[18:01:01.368]         if (TRUE) {
[18:01:01.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.368]                 open = "w")
[18:01:01.368]         }
[18:01:01.368]         else {
[18:01:01.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.368]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.368]         }
[18:01:01.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.368]             base::sink(type = "output", split = FALSE)
[18:01:01.368]             base::close(...future.stdout)
[18:01:01.368]         }, add = TRUE)
[18:01:01.368]     }
[18:01:01.368]     ...future.frame <- base::sys.nframe()
[18:01:01.368]     ...future.conditions <- base::list()
[18:01:01.368]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.368]     if (FALSE) {
[18:01:01.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.368]     }
[18:01:01.368]     ...future.result <- base::tryCatch({
[18:01:01.368]         base::withCallingHandlers({
[18:01:01.368]             ...future.value <- base::withVisible(base::local({
[18:01:01.368]                 withCallingHandlers({
[18:01:01.368]                   {
[18:01:01.368]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.368]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.368]                       ...future.globals.maxSize)) {
[18:01:01.368]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.368]                       on.exit(options(oopts), add = TRUE)
[18:01:01.368]                     }
[18:01:01.368]                     {
[18:01:01.368]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.368]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.368]                         USE.NAMES = FALSE)
[18:01:01.368]                       do.call(mapply, args = args)
[18:01:01.368]                     }
[18:01:01.368]                   }
[18:01:01.368]                 }, immediateCondition = function(cond) {
[18:01:01.368]                   save_rds <- function (object, pathname, ...) 
[18:01:01.368]                   {
[18:01:01.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.368]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.368]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.368]                         fi_tmp[["mtime"]])
[18:01:01.368]                     }
[18:01:01.368]                     tryCatch({
[18:01:01.368]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.368]                     }, error = function(ex) {
[18:01:01.368]                       msg <- conditionMessage(ex)
[18:01:01.368]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.368]                         fi_tmp[["mtime"]], msg)
[18:01:01.368]                       ex$message <- msg
[18:01:01.368]                       stop(ex)
[18:01:01.368]                     })
[18:01:01.368]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.368]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.368]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.368]                       fi <- file.info(pathname)
[18:01:01.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.368]                         fi[["size"]], fi[["mtime"]])
[18:01:01.368]                       stop(msg)
[18:01:01.368]                     }
[18:01:01.368]                     invisible(pathname)
[18:01:01.368]                   }
[18:01:01.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.368]                     rootPath = tempdir()) 
[18:01:01.368]                   {
[18:01:01.368]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.368]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.368]                       tmpdir = path, fileext = ".rds")
[18:01:01.368]                     save_rds(obj, file)
[18:01:01.368]                   }
[18:01:01.368]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.368]                   {
[18:01:01.368]                     inherits <- base::inherits
[18:01:01.368]                     invokeRestart <- base::invokeRestart
[18:01:01.368]                     is.null <- base::is.null
[18:01:01.368]                     muffled <- FALSE
[18:01:01.368]                     if (inherits(cond, "message")) {
[18:01:01.368]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.368]                       if (muffled) 
[18:01:01.368]                         invokeRestart("muffleMessage")
[18:01:01.368]                     }
[18:01:01.368]                     else if (inherits(cond, "warning")) {
[18:01:01.368]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.368]                       if (muffled) 
[18:01:01.368]                         invokeRestart("muffleWarning")
[18:01:01.368]                     }
[18:01:01.368]                     else if (inherits(cond, "condition")) {
[18:01:01.368]                       if (!is.null(pattern)) {
[18:01:01.368]                         computeRestarts <- base::computeRestarts
[18:01:01.368]                         grepl <- base::grepl
[18:01:01.368]                         restarts <- computeRestarts(cond)
[18:01:01.368]                         for (restart in restarts) {
[18:01:01.368]                           name <- restart$name
[18:01:01.368]                           if (is.null(name)) 
[18:01:01.368]                             next
[18:01:01.368]                           if (!grepl(pattern, name)) 
[18:01:01.368]                             next
[18:01:01.368]                           invokeRestart(restart)
[18:01:01.368]                           muffled <- TRUE
[18:01:01.368]                           break
[18:01:01.368]                         }
[18:01:01.368]                       }
[18:01:01.368]                     }
[18:01:01.368]                     invisible(muffled)
[18:01:01.368]                   }
[18:01:01.368]                   muffleCondition(cond)
[18:01:01.368]                 })
[18:01:01.368]             }))
[18:01:01.368]             future::FutureResult(value = ...future.value$value, 
[18:01:01.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.368]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.368]                     ...future.globalenv.names))
[18:01:01.368]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.368]         }, condition = base::local({
[18:01:01.368]             c <- base::c
[18:01:01.368]             inherits <- base::inherits
[18:01:01.368]             invokeRestart <- base::invokeRestart
[18:01:01.368]             length <- base::length
[18:01:01.368]             list <- base::list
[18:01:01.368]             seq.int <- base::seq.int
[18:01:01.368]             signalCondition <- base::signalCondition
[18:01:01.368]             sys.calls <- base::sys.calls
[18:01:01.368]             `[[` <- base::`[[`
[18:01:01.368]             `+` <- base::`+`
[18:01:01.368]             `<<-` <- base::`<<-`
[18:01:01.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.368]                   3L)]
[18:01:01.368]             }
[18:01:01.368]             function(cond) {
[18:01:01.368]                 is_error <- inherits(cond, "error")
[18:01:01.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.368]                   NULL)
[18:01:01.368]                 if (is_error) {
[18:01:01.368]                   sessionInformation <- function() {
[18:01:01.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.368]                       search = base::search(), system = base::Sys.info())
[18:01:01.368]                   }
[18:01:01.368]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.368]                     cond$call), session = sessionInformation(), 
[18:01:01.368]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.368]                   signalCondition(cond)
[18:01:01.368]                 }
[18:01:01.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.368]                 "immediateCondition"))) {
[18:01:01.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.368]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.368]                   if (TRUE && !signal) {
[18:01:01.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.368]                     {
[18:01:01.368]                       inherits <- base::inherits
[18:01:01.368]                       invokeRestart <- base::invokeRestart
[18:01:01.368]                       is.null <- base::is.null
[18:01:01.368]                       muffled <- FALSE
[18:01:01.368]                       if (inherits(cond, "message")) {
[18:01:01.368]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.368]                         if (muffled) 
[18:01:01.368]                           invokeRestart("muffleMessage")
[18:01:01.368]                       }
[18:01:01.368]                       else if (inherits(cond, "warning")) {
[18:01:01.368]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.368]                         if (muffled) 
[18:01:01.368]                           invokeRestart("muffleWarning")
[18:01:01.368]                       }
[18:01:01.368]                       else if (inherits(cond, "condition")) {
[18:01:01.368]                         if (!is.null(pattern)) {
[18:01:01.368]                           computeRestarts <- base::computeRestarts
[18:01:01.368]                           grepl <- base::grepl
[18:01:01.368]                           restarts <- computeRestarts(cond)
[18:01:01.368]                           for (restart in restarts) {
[18:01:01.368]                             name <- restart$name
[18:01:01.368]                             if (is.null(name)) 
[18:01:01.368]                               next
[18:01:01.368]                             if (!grepl(pattern, name)) 
[18:01:01.368]                               next
[18:01:01.368]                             invokeRestart(restart)
[18:01:01.368]                             muffled <- TRUE
[18:01:01.368]                             break
[18:01:01.368]                           }
[18:01:01.368]                         }
[18:01:01.368]                       }
[18:01:01.368]                       invisible(muffled)
[18:01:01.368]                     }
[18:01:01.368]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.368]                   }
[18:01:01.368]                 }
[18:01:01.368]                 else {
[18:01:01.368]                   if (TRUE) {
[18:01:01.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.368]                     {
[18:01:01.368]                       inherits <- base::inherits
[18:01:01.368]                       invokeRestart <- base::invokeRestart
[18:01:01.368]                       is.null <- base::is.null
[18:01:01.368]                       muffled <- FALSE
[18:01:01.368]                       if (inherits(cond, "message")) {
[18:01:01.368]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.368]                         if (muffled) 
[18:01:01.368]                           invokeRestart("muffleMessage")
[18:01:01.368]                       }
[18:01:01.368]                       else if (inherits(cond, "warning")) {
[18:01:01.368]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.368]                         if (muffled) 
[18:01:01.368]                           invokeRestart("muffleWarning")
[18:01:01.368]                       }
[18:01:01.368]                       else if (inherits(cond, "condition")) {
[18:01:01.368]                         if (!is.null(pattern)) {
[18:01:01.368]                           computeRestarts <- base::computeRestarts
[18:01:01.368]                           grepl <- base::grepl
[18:01:01.368]                           restarts <- computeRestarts(cond)
[18:01:01.368]                           for (restart in restarts) {
[18:01:01.368]                             name <- restart$name
[18:01:01.368]                             if (is.null(name)) 
[18:01:01.368]                               next
[18:01:01.368]                             if (!grepl(pattern, name)) 
[18:01:01.368]                               next
[18:01:01.368]                             invokeRestart(restart)
[18:01:01.368]                             muffled <- TRUE
[18:01:01.368]                             break
[18:01:01.368]                           }
[18:01:01.368]                         }
[18:01:01.368]                       }
[18:01:01.368]                       invisible(muffled)
[18:01:01.368]                     }
[18:01:01.368]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.368]                   }
[18:01:01.368]                 }
[18:01:01.368]             }
[18:01:01.368]         }))
[18:01:01.368]     }, error = function(ex) {
[18:01:01.368]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.368]                 ...future.rng), started = ...future.startTime, 
[18:01:01.368]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.368]             version = "1.8"), class = "FutureResult")
[18:01:01.368]     }, finally = {
[18:01:01.368]         if (!identical(...future.workdir, getwd())) 
[18:01:01.368]             setwd(...future.workdir)
[18:01:01.368]         {
[18:01:01.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.368]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.368]             }
[18:01:01.368]             base::options(...future.oldOptions)
[18:01:01.368]             if (.Platform$OS.type == "windows") {
[18:01:01.368]                 old_names <- names(...future.oldEnvVars)
[18:01:01.368]                 envs <- base::Sys.getenv()
[18:01:01.368]                 names <- names(envs)
[18:01:01.368]                 common <- intersect(names, old_names)
[18:01:01.368]                 added <- setdiff(names, old_names)
[18:01:01.368]                 removed <- setdiff(old_names, names)
[18:01:01.368]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.368]                   envs[common]]
[18:01:01.368]                 NAMES <- toupper(changed)
[18:01:01.368]                 args <- list()
[18:01:01.368]                 for (kk in seq_along(NAMES)) {
[18:01:01.368]                   name <- changed[[kk]]
[18:01:01.368]                   NAME <- NAMES[[kk]]
[18:01:01.368]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.368]                     next
[18:01:01.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.368]                 }
[18:01:01.368]                 NAMES <- toupper(added)
[18:01:01.368]                 for (kk in seq_along(NAMES)) {
[18:01:01.368]                   name <- added[[kk]]
[18:01:01.368]                   NAME <- NAMES[[kk]]
[18:01:01.368]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.368]                     next
[18:01:01.368]                   args[[name]] <- ""
[18:01:01.368]                 }
[18:01:01.368]                 NAMES <- toupper(removed)
[18:01:01.368]                 for (kk in seq_along(NAMES)) {
[18:01:01.368]                   name <- removed[[kk]]
[18:01:01.368]                   NAME <- NAMES[[kk]]
[18:01:01.368]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.368]                     next
[18:01:01.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.368]                 }
[18:01:01.368]                 if (length(args) > 0) 
[18:01:01.368]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.368]             }
[18:01:01.368]             else {
[18:01:01.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.368]             }
[18:01:01.368]             {
[18:01:01.368]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.368]                   0L) {
[18:01:01.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.368]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.368]                   base::options(opts)
[18:01:01.368]                 }
[18:01:01.368]                 {
[18:01:01.368]                   {
[18:01:01.368]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.368]                     NULL
[18:01:01.368]                   }
[18:01:01.368]                   options(future.plan = NULL)
[18:01:01.368]                   if (is.na(NA_character_)) 
[18:01:01.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.368]                     .init = FALSE)
[18:01:01.368]                 }
[18:01:01.368]             }
[18:01:01.368]         }
[18:01:01.368]     })
[18:01:01.368]     if (TRUE) {
[18:01:01.368]         base::sink(type = "output", split = FALSE)
[18:01:01.368]         if (TRUE) {
[18:01:01.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.368]         }
[18:01:01.368]         else {
[18:01:01.368]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.368]         }
[18:01:01.368]         base::close(...future.stdout)
[18:01:01.368]         ...future.stdout <- NULL
[18:01:01.368]     }
[18:01:01.368]     ...future.result$conditions <- ...future.conditions
[18:01:01.368]     ...future.result$finished <- base::Sys.time()
[18:01:01.368]     ...future.result
[18:01:01.368] }
[18:01:01.376] assign_globals() ...
[18:01:01.377] List of 5
[18:01:01.377]  $ ...future.FUN            :function (C, k)  
[18:01:01.377]  $ MoreArgs                 : NULL
[18:01:01.377]  $ ...future.elements_ii    :List of 2
[18:01:01.377]   ..$ :List of 2
[18:01:01.377]   .. ..$ : chr "A"
[18:01:01.377]   .. ..$ : chr "C"
[18:01:01.377]   ..$ :List of 2
[18:01:01.377]   .. ..$ : int 5
[18:01:01.377]   .. ..$ : int 3
[18:01:01.377]  $ ...future.seeds_ii       : NULL
[18:01:01.377]  $ ...future.globals.maxSize: NULL
[18:01:01.377]  - attr(*, "where")=List of 5
[18:01:01.377]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.377]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.377]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.377]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.377]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.377]  - attr(*, "resolved")= logi FALSE
[18:01:01.377]  - attr(*, "total_size")= num 3656
[18:01:01.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.377]  - attr(*, "already-done")= logi TRUE
[18:01:01.392] - reassign environment for ‘...future.FUN’
[18:01:01.392] - copied ‘...future.FUN’ to environment
[18:01:01.392] - copied ‘MoreArgs’ to environment
[18:01:01.393] - copied ‘...future.elements_ii’ to environment
[18:01:01.393] - copied ‘...future.seeds_ii’ to environment
[18:01:01.393] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.393] assign_globals() ... done
[18:01:01.394] requestCore(): workers = 2
[18:01:01.394] Poll #1 (0): usedCores() = 2, workers = 2
[18:01:01.405] result() for MulticoreFuture ...
[18:01:01.408] result() for MulticoreFuture ...
[18:01:01.409] result() for MulticoreFuture ... done
[18:01:01.409] result() for MulticoreFuture ... done
[18:01:01.409] result() for MulticoreFuture ...
[18:01:01.410] result() for MulticoreFuture ... done
[18:01:01.414] MulticoreFuture started
[18:01:01.415] - Launch lazy future ... done
[18:01:01.415] run() for ‘MulticoreFuture’ ... done
[18:01:01.416] plan(): Setting new future strategy stack:
[18:01:01.416] Created future:
[18:01:01.416] List of future strategies:
[18:01:01.416] 1. sequential:
[18:01:01.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.416]    - tweaked: FALSE
[18:01:01.416]    - call: NULL
[18:01:01.426] plan(): nbrOfWorkers() = 1
[18:01:01.432] plan(): Setting new future strategy stack:
[18:01:01.433] List of future strategies:
[18:01:01.433] 1. multicore:
[18:01:01.433]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.433]    - tweaked: FALSE
[18:01:01.433]    - call: plan(strategy)
[18:01:01.423] MulticoreFuture:
[18:01:01.423] Label: ‘future_mapply-3’
[18:01:01.423] Expression:
[18:01:01.423] {
[18:01:01.423]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.423]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.423]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.423]         on.exit(options(oopts), add = TRUE)
[18:01:01.423]     }
[18:01:01.423]     {
[18:01:01.423]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.423]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.423]         do.call(mapply, args = args)
[18:01:01.423]     }
[18:01:01.423] }
[18:01:01.423] Lazy evaluation: FALSE
[18:01:01.423] Asynchronous evaluation: TRUE
[18:01:01.423] Local evaluation: TRUE
[18:01:01.423] Environment: R_GlobalEnv
[18:01:01.423] Capture standard output: TRUE
[18:01:01.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.423] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.423] Packages: <none>
[18:01:01.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.423] Resolved: FALSE
[18:01:01.423] Value: <not collected>
[18:01:01.423] Conditions captured: <none>
[18:01:01.423] Early signaling: FALSE
[18:01:01.423] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.423] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.441] Chunk #3 of 3 ... DONE
[18:01:01.441] Launching 3 futures (chunks) ... DONE
[18:01:01.442] Resolving 3 futures (chunks) ...
[18:01:01.442] resolve() on list ...
[18:01:01.443]  recursive: 0
[18:01:01.443]  length: 3
[18:01:01.444] 
[18:01:01.444] plan(): nbrOfWorkers() = 2
[18:01:01.444] Future #1
[18:01:01.445] result() for MulticoreFuture ...
[18:01:01.445] result() for MulticoreFuture ... done
[18:01:01.445] result() for MulticoreFuture ...
[18:01:01.446] result() for MulticoreFuture ... done
[18:01:01.446] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:01.446] - nx: 3
[18:01:01.447] - relay: TRUE
[18:01:01.447] - stdout: TRUE
[18:01:01.447] - signal: TRUE
[18:01:01.448] - resignal: FALSE
[18:01:01.448] - force: TRUE
[18:01:01.448] - relayed: [n=3] FALSE, FALSE, FALSE
[18:01:01.449] - queued futures: [n=3] FALSE, FALSE, FALSE
[18:01:01.450]  - until=1
[18:01:01.450]  - relaying element #1
[18:01:01.451] result() for MulticoreFuture ...
[18:01:01.451] result() for MulticoreFuture ... done
[18:01:01.451] result() for MulticoreFuture ...
[18:01:01.452] result() for MulticoreFuture ... done
[18:01:01.453] result() for MulticoreFuture ...
[18:01:01.453] result() for MulticoreFuture ... done
[18:01:01.453] result() for MulticoreFuture ...
[18:01:01.454] result() for MulticoreFuture ... done
[18:01:01.454] - relayed: [n=3] TRUE, FALSE, FALSE
[18:01:01.454] - queued futures: [n=3] TRUE, FALSE, FALSE
[18:01:01.455] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:01.455]  length: 2 (resolved future 1)
[18:01:01.456] Future #2
[18:01:01.456] result() for MulticoreFuture ...
[18:01:01.458] result() for MulticoreFuture ...
[18:01:01.458] result() for MulticoreFuture ... done
[18:01:01.458] result() for MulticoreFuture ... done
[18:01:01.459] result() for MulticoreFuture ...
[18:01:01.459] result() for MulticoreFuture ... done
[18:01:01.459] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:01.460] - nx: 3
[18:01:01.460] - relay: TRUE
[18:01:01.460] - stdout: TRUE
[18:01:01.460] - signal: TRUE
[18:01:01.461] - resignal: FALSE
[18:01:01.461] - force: TRUE
[18:01:01.461] - relayed: [n=3] TRUE, FALSE, FALSE
[18:01:01.462] - queued futures: [n=3] TRUE, FALSE, FALSE
[18:01:01.462]  - until=2
[18:01:01.462]  - relaying element #2
[18:01:01.462] result() for MulticoreFuture ...
[18:01:01.463] result() for MulticoreFuture ... done
[18:01:01.463] result() for MulticoreFuture ...
[18:01:01.463] result() for MulticoreFuture ... done
[18:01:01.464] result() for MulticoreFuture ...
[18:01:01.464] result() for MulticoreFuture ... done
[18:01:01.465] result() for MulticoreFuture ...
[18:01:01.465] result() for MulticoreFuture ... done
[18:01:01.465] - relayed: [n=3] TRUE, TRUE, FALSE
[18:01:01.466] - queued futures: [n=3] TRUE, TRUE, FALSE
[18:01:01.466] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:01.466]  length: 1 (resolved future 2)
[18:01:01.467] Future #3
[18:01:01.467] result() for MulticoreFuture ...
[18:01:01.468] result() for MulticoreFuture ...
[18:01:01.469] result() for MulticoreFuture ... done
[18:01:01.469] result() for MulticoreFuture ... done
[18:01:01.469] result() for MulticoreFuture ...
[18:01:01.470] result() for MulticoreFuture ... done
[18:01:01.470] signalConditionsASAP(MulticoreFuture, pos=3) ...
[18:01:01.470] - nx: 3
[18:01:01.470] - relay: TRUE
[18:01:01.471] - stdout: TRUE
[18:01:01.471] - signal: TRUE
[18:01:01.471] - resignal: FALSE
[18:01:01.471] - force: TRUE
[18:01:01.471] - relayed: [n=3] TRUE, TRUE, FALSE
[18:01:01.472] - queued futures: [n=3] TRUE, TRUE, FALSE
[18:01:01.472]  - until=3
[18:01:01.473]  - relaying element #3
[18:01:01.473] result() for MulticoreFuture ...
[18:01:01.473] result() for MulticoreFuture ... done
[18:01:01.473] result() for MulticoreFuture ...
[18:01:01.473] result() for MulticoreFuture ... done
[18:01:01.474] result() for MulticoreFuture ...
[18:01:01.474] result() for MulticoreFuture ... done
[18:01:01.474] result() for MulticoreFuture ...
[18:01:01.474] result() for MulticoreFuture ... done
[18:01:01.475] - relayed: [n=3] TRUE, TRUE, TRUE
[18:01:01.475] - queued futures: [n=3] TRUE, TRUE, TRUE
[18:01:01.475] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[18:01:01.475]  length: 0 (resolved future 3)
[18:01:01.475] Relaying remaining futures
[18:01:01.476] signalConditionsASAP(NULL, pos=0) ...
[18:01:01.476] - nx: 3
[18:01:01.476] - relay: TRUE
[18:01:01.476] - stdout: TRUE
[18:01:01.476] - signal: TRUE
[18:01:01.477] - resignal: FALSE
[18:01:01.477] - force: TRUE
[18:01:01.477] - relayed: [n=3] TRUE, TRUE, TRUE
[18:01:01.477] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[18:01:01.477] - relayed: [n=3] TRUE, TRUE, TRUE
[18:01:01.478] - queued futures: [n=3] TRUE, TRUE, TRUE
[18:01:01.478] signalConditionsASAP(NULL, pos=0) ... done
[18:01:01.478] resolve() on list ... DONE
[18:01:01.478] result() for MulticoreFuture ...
[18:01:01.478] result() for MulticoreFuture ... done
[18:01:01.479] result() for MulticoreFuture ...
[18:01:01.479] result() for MulticoreFuture ... done
[18:01:01.479] result() for MulticoreFuture ...
[18:01:01.479] result() for MulticoreFuture ... done
[18:01:01.480] result() for MulticoreFuture ...
[18:01:01.480] result() for MulticoreFuture ... done
[18:01:01.480] result() for MulticoreFuture ...
[18:01:01.480] result() for MulticoreFuture ... done
[18:01:01.480] result() for MulticoreFuture ...
[18:01:01.481] result() for MulticoreFuture ... done
[18:01:01.481]  - Number of value chunks collected: 3
[18:01:01.481] Resolving 3 futures (chunks) ... DONE
[18:01:01.481] Reducing values from 3 chunks ...
[18:01:01.481]  - Number of values collected after concatenation: 5
[18:01:01.482]  - Number of values expected: 5
[18:01:01.482] Reverse index remapping (attribute 'ordering'): [n = 5] 4, 2, 5, 3, 1
[18:01:01.482] Reducing values from 3 chunks ... DONE
[18:01:01.482] future_mapply() ... DONE
[18:01:01.483] future_mapply() ...
[18:01:01.490] Number of chunks: 2
[18:01:01.490] getGlobalsAndPackagesXApply() ...
[18:01:01.490]  - future.globals: TRUE
[18:01:01.491] getGlobalsAndPackages() ...
[18:01:01.491] Searching for globals...
[18:01:01.494] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:01.494] Searching for globals ... DONE
[18:01:01.494] Resolving globals: FALSE
[18:01:01.495] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:01.496] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:01.496] - globals: [1] ‘FUN’
[18:01:01.496] 
[18:01:01.496] getGlobalsAndPackages() ... DONE
[18:01:01.497]  - globals found/used: [n=1] ‘FUN’
[18:01:01.497]  - needed namespaces: [n=0] 
[18:01:01.497] Finding globals ... DONE
[18:01:01.497] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:01.498] List of 2
[18:01:01.498]  $ ...future.FUN:function (C, k)  
[18:01:01.498]  $ MoreArgs     : list()
[18:01:01.498]  - attr(*, "where")=List of 2
[18:01:01.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:01.498]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:01.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.498]  - attr(*, "resolved")= logi FALSE
[18:01:01.498]  - attr(*, "total_size")= num NA
[18:01:01.506] Packages to be attached in all futures: [n=0] 
[18:01:01.506] getGlobalsAndPackagesXApply() ... DONE
[18:01:01.507] Number of futures (= number of chunks): 2
[18:01:01.507] Launching 2 futures (chunks) ...
[18:01:01.507] Chunk #1 of 2 ...
[18:01:01.507]  - Finding globals in '...' for chunk #1 ...
[18:01:01.508] getGlobalsAndPackages() ...
[18:01:01.508] Searching for globals...
[18:01:01.509] 
[18:01:01.509] Searching for globals ... DONE
[18:01:01.509] - globals: [0] <none>
[18:01:01.509] getGlobalsAndPackages() ... DONE
[18:01:01.509]    + additional globals found: [n=0] 
[18:01:01.510]    + additional namespaces needed: [n=0] 
[18:01:01.510]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:01.510]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:01.510]  - seeds: <none>
[18:01:01.510]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.511] getGlobalsAndPackages() ...
[18:01:01.511] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.511] Resolving globals: FALSE
[18:01:01.512] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:01.513] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:01.513] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.514] 
[18:01:01.514] getGlobalsAndPackages() ... DONE
[18:01:01.514] run() for ‘Future’ ...
[18:01:01.515] - state: ‘created’
[18:01:01.515] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.521] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.522] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.522]   - Field: ‘label’
[18:01:01.522]   - Field: ‘local’
[18:01:01.522]   - Field: ‘owner’
[18:01:01.523]   - Field: ‘envir’
[18:01:01.523]   - Field: ‘workers’
[18:01:01.523]   - Field: ‘packages’
[18:01:01.523]   - Field: ‘gc’
[18:01:01.523]   - Field: ‘job’
[18:01:01.524]   - Field: ‘conditions’
[18:01:01.524]   - Field: ‘expr’
[18:01:01.524]   - Field: ‘uuid’
[18:01:01.524]   - Field: ‘seed’
[18:01:01.524]   - Field: ‘version’
[18:01:01.525]   - Field: ‘result’
[18:01:01.525]   - Field: ‘asynchronous’
[18:01:01.525]   - Field: ‘calls’
[18:01:01.525]   - Field: ‘globals’
[18:01:01.525]   - Field: ‘stdout’
[18:01:01.526]   - Field: ‘earlySignal’
[18:01:01.526]   - Field: ‘lazy’
[18:01:01.526]   - Field: ‘state’
[18:01:01.526] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.526] - Launch lazy future ...
[18:01:01.527] Packages needed by the future expression (n = 0): <none>
[18:01:01.527] Packages needed by future strategies (n = 0): <none>
[18:01:01.529] {
[18:01:01.529]     {
[18:01:01.529]         {
[18:01:01.529]             ...future.startTime <- base::Sys.time()
[18:01:01.529]             {
[18:01:01.529]                 {
[18:01:01.529]                   {
[18:01:01.529]                     {
[18:01:01.529]                       base::local({
[18:01:01.529]                         has_future <- base::requireNamespace("future", 
[18:01:01.529]                           quietly = TRUE)
[18:01:01.529]                         if (has_future) {
[18:01:01.529]                           ns <- base::getNamespace("future")
[18:01:01.529]                           version <- ns[[".package"]][["version"]]
[18:01:01.529]                           if (is.null(version)) 
[18:01:01.529]                             version <- utils::packageVersion("future")
[18:01:01.529]                         }
[18:01:01.529]                         else {
[18:01:01.529]                           version <- NULL
[18:01:01.529]                         }
[18:01:01.529]                         if (!has_future || version < "1.8.0") {
[18:01:01.529]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.529]                             "", base::R.version$version.string), 
[18:01:01.529]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.529]                               "release", "version")], collapse = " "), 
[18:01:01.529]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.529]                             info)
[18:01:01.529]                           info <- base::paste(info, collapse = "; ")
[18:01:01.529]                           if (!has_future) {
[18:01:01.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.529]                               info)
[18:01:01.529]                           }
[18:01:01.529]                           else {
[18:01:01.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.529]                               info, version)
[18:01:01.529]                           }
[18:01:01.529]                           base::stop(msg)
[18:01:01.529]                         }
[18:01:01.529]                       })
[18:01:01.529]                     }
[18:01:01.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.529]                     base::options(mc.cores = 1L)
[18:01:01.529]                   }
[18:01:01.529]                   ...future.strategy.old <- future::plan("list")
[18:01:01.529]                   options(future.plan = NULL)
[18:01:01.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.529]                 }
[18:01:01.529]                 ...future.workdir <- getwd()
[18:01:01.529]             }
[18:01:01.529]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.529]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.529]         }
[18:01:01.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.529]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:01.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.529]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.529]             base::names(...future.oldOptions))
[18:01:01.529]     }
[18:01:01.529]     if (FALSE) {
[18:01:01.529]     }
[18:01:01.529]     else {
[18:01:01.529]         if (TRUE) {
[18:01:01.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.529]                 open = "w")
[18:01:01.529]         }
[18:01:01.529]         else {
[18:01:01.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.529]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.529]         }
[18:01:01.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.529]             base::sink(type = "output", split = FALSE)
[18:01:01.529]             base::close(...future.stdout)
[18:01:01.529]         }, add = TRUE)
[18:01:01.529]     }
[18:01:01.529]     ...future.frame <- base::sys.nframe()
[18:01:01.529]     ...future.conditions <- base::list()
[18:01:01.529]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.529]     if (FALSE) {
[18:01:01.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.529]     }
[18:01:01.529]     ...future.result <- base::tryCatch({
[18:01:01.529]         base::withCallingHandlers({
[18:01:01.529]             ...future.value <- base::withVisible(base::local({
[18:01:01.529]                 withCallingHandlers({
[18:01:01.529]                   {
[18:01:01.529]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.529]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.529]                       ...future.globals.maxSize)) {
[18:01:01.529]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.529]                       on.exit(options(oopts), add = TRUE)
[18:01:01.529]                     }
[18:01:01.529]                     {
[18:01:01.529]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.529]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.529]                         USE.NAMES = FALSE)
[18:01:01.529]                       do.call(mapply, args = args)
[18:01:01.529]                     }
[18:01:01.529]                   }
[18:01:01.529]                 }, immediateCondition = function(cond) {
[18:01:01.529]                   save_rds <- function (object, pathname, ...) 
[18:01:01.529]                   {
[18:01:01.529]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.529]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.529]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.529]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.529]                         fi_tmp[["mtime"]])
[18:01:01.529]                     }
[18:01:01.529]                     tryCatch({
[18:01:01.529]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.529]                     }, error = function(ex) {
[18:01:01.529]                       msg <- conditionMessage(ex)
[18:01:01.529]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.529]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.529]                         fi_tmp[["mtime"]], msg)
[18:01:01.529]                       ex$message <- msg
[18:01:01.529]                       stop(ex)
[18:01:01.529]                     })
[18:01:01.529]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.529]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.529]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.529]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.529]                       fi <- file.info(pathname)
[18:01:01.529]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.529]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.529]                         fi[["size"]], fi[["mtime"]])
[18:01:01.529]                       stop(msg)
[18:01:01.529]                     }
[18:01:01.529]                     invisible(pathname)
[18:01:01.529]                   }
[18:01:01.529]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.529]                     rootPath = tempdir()) 
[18:01:01.529]                   {
[18:01:01.529]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.529]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.529]                       tmpdir = path, fileext = ".rds")
[18:01:01.529]                     save_rds(obj, file)
[18:01:01.529]                   }
[18:01:01.529]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.529]                   {
[18:01:01.529]                     inherits <- base::inherits
[18:01:01.529]                     invokeRestart <- base::invokeRestart
[18:01:01.529]                     is.null <- base::is.null
[18:01:01.529]                     muffled <- FALSE
[18:01:01.529]                     if (inherits(cond, "message")) {
[18:01:01.529]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.529]                       if (muffled) 
[18:01:01.529]                         invokeRestart("muffleMessage")
[18:01:01.529]                     }
[18:01:01.529]                     else if (inherits(cond, "warning")) {
[18:01:01.529]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.529]                       if (muffled) 
[18:01:01.529]                         invokeRestart("muffleWarning")
[18:01:01.529]                     }
[18:01:01.529]                     else if (inherits(cond, "condition")) {
[18:01:01.529]                       if (!is.null(pattern)) {
[18:01:01.529]                         computeRestarts <- base::computeRestarts
[18:01:01.529]                         grepl <- base::grepl
[18:01:01.529]                         restarts <- computeRestarts(cond)
[18:01:01.529]                         for (restart in restarts) {
[18:01:01.529]                           name <- restart$name
[18:01:01.529]                           if (is.null(name)) 
[18:01:01.529]                             next
[18:01:01.529]                           if (!grepl(pattern, name)) 
[18:01:01.529]                             next
[18:01:01.529]                           invokeRestart(restart)
[18:01:01.529]                           muffled <- TRUE
[18:01:01.529]                           break
[18:01:01.529]                         }
[18:01:01.529]                       }
[18:01:01.529]                     }
[18:01:01.529]                     invisible(muffled)
[18:01:01.529]                   }
[18:01:01.529]                   muffleCondition(cond)
[18:01:01.529]                 })
[18:01:01.529]             }))
[18:01:01.529]             future::FutureResult(value = ...future.value$value, 
[18:01:01.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.529]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.529]                     ...future.globalenv.names))
[18:01:01.529]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.529]         }, condition = base::local({
[18:01:01.529]             c <- base::c
[18:01:01.529]             inherits <- base::inherits
[18:01:01.529]             invokeRestart <- base::invokeRestart
[18:01:01.529]             length <- base::length
[18:01:01.529]             list <- base::list
[18:01:01.529]             seq.int <- base::seq.int
[18:01:01.529]             signalCondition <- base::signalCondition
[18:01:01.529]             sys.calls <- base::sys.calls
[18:01:01.529]             `[[` <- base::`[[`
[18:01:01.529]             `+` <- base::`+`
[18:01:01.529]             `<<-` <- base::`<<-`
[18:01:01.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.529]                   3L)]
[18:01:01.529]             }
[18:01:01.529]             function(cond) {
[18:01:01.529]                 is_error <- inherits(cond, "error")
[18:01:01.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.529]                   NULL)
[18:01:01.529]                 if (is_error) {
[18:01:01.529]                   sessionInformation <- function() {
[18:01:01.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.529]                       search = base::search(), system = base::Sys.info())
[18:01:01.529]                   }
[18:01:01.529]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.529]                     cond$call), session = sessionInformation(), 
[18:01:01.529]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.529]                   signalCondition(cond)
[18:01:01.529]                 }
[18:01:01.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.529]                 "immediateCondition"))) {
[18:01:01.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.529]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.529]                   if (TRUE && !signal) {
[18:01:01.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.529]                     {
[18:01:01.529]                       inherits <- base::inherits
[18:01:01.529]                       invokeRestart <- base::invokeRestart
[18:01:01.529]                       is.null <- base::is.null
[18:01:01.529]                       muffled <- FALSE
[18:01:01.529]                       if (inherits(cond, "message")) {
[18:01:01.529]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.529]                         if (muffled) 
[18:01:01.529]                           invokeRestart("muffleMessage")
[18:01:01.529]                       }
[18:01:01.529]                       else if (inherits(cond, "warning")) {
[18:01:01.529]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.529]                         if (muffled) 
[18:01:01.529]                           invokeRestart("muffleWarning")
[18:01:01.529]                       }
[18:01:01.529]                       else if (inherits(cond, "condition")) {
[18:01:01.529]                         if (!is.null(pattern)) {
[18:01:01.529]                           computeRestarts <- base::computeRestarts
[18:01:01.529]                           grepl <- base::grepl
[18:01:01.529]                           restarts <- computeRestarts(cond)
[18:01:01.529]                           for (restart in restarts) {
[18:01:01.529]                             name <- restart$name
[18:01:01.529]                             if (is.null(name)) 
[18:01:01.529]                               next
[18:01:01.529]                             if (!grepl(pattern, name)) 
[18:01:01.529]                               next
[18:01:01.529]                             invokeRestart(restart)
[18:01:01.529]                             muffled <- TRUE
[18:01:01.529]                             break
[18:01:01.529]                           }
[18:01:01.529]                         }
[18:01:01.529]                       }
[18:01:01.529]                       invisible(muffled)
[18:01:01.529]                     }
[18:01:01.529]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.529]                   }
[18:01:01.529]                 }
[18:01:01.529]                 else {
[18:01:01.529]                   if (TRUE) {
[18:01:01.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.529]                     {
[18:01:01.529]                       inherits <- base::inherits
[18:01:01.529]                       invokeRestart <- base::invokeRestart
[18:01:01.529]                       is.null <- base::is.null
[18:01:01.529]                       muffled <- FALSE
[18:01:01.529]                       if (inherits(cond, "message")) {
[18:01:01.529]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.529]                         if (muffled) 
[18:01:01.529]                           invokeRestart("muffleMessage")
[18:01:01.529]                       }
[18:01:01.529]                       else if (inherits(cond, "warning")) {
[18:01:01.529]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.529]                         if (muffled) 
[18:01:01.529]                           invokeRestart("muffleWarning")
[18:01:01.529]                       }
[18:01:01.529]                       else if (inherits(cond, "condition")) {
[18:01:01.529]                         if (!is.null(pattern)) {
[18:01:01.529]                           computeRestarts <- base::computeRestarts
[18:01:01.529]                           grepl <- base::grepl
[18:01:01.529]                           restarts <- computeRestarts(cond)
[18:01:01.529]                           for (restart in restarts) {
[18:01:01.529]                             name <- restart$name
[18:01:01.529]                             if (is.null(name)) 
[18:01:01.529]                               next
[18:01:01.529]                             if (!grepl(pattern, name)) 
[18:01:01.529]                               next
[18:01:01.529]                             invokeRestart(restart)
[18:01:01.529]                             muffled <- TRUE
[18:01:01.529]                             break
[18:01:01.529]                           }
[18:01:01.529]                         }
[18:01:01.529]                       }
[18:01:01.529]                       invisible(muffled)
[18:01:01.529]                     }
[18:01:01.529]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.529]                   }
[18:01:01.529]                 }
[18:01:01.529]             }
[18:01:01.529]         }))
[18:01:01.529]     }, error = function(ex) {
[18:01:01.529]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.529]                 ...future.rng), started = ...future.startTime, 
[18:01:01.529]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.529]             version = "1.8"), class = "FutureResult")
[18:01:01.529]     }, finally = {
[18:01:01.529]         if (!identical(...future.workdir, getwd())) 
[18:01:01.529]             setwd(...future.workdir)
[18:01:01.529]         {
[18:01:01.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.529]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.529]             }
[18:01:01.529]             base::options(...future.oldOptions)
[18:01:01.529]             if (.Platform$OS.type == "windows") {
[18:01:01.529]                 old_names <- names(...future.oldEnvVars)
[18:01:01.529]                 envs <- base::Sys.getenv()
[18:01:01.529]                 names <- names(envs)
[18:01:01.529]                 common <- intersect(names, old_names)
[18:01:01.529]                 added <- setdiff(names, old_names)
[18:01:01.529]                 removed <- setdiff(old_names, names)
[18:01:01.529]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.529]                   envs[common]]
[18:01:01.529]                 NAMES <- toupper(changed)
[18:01:01.529]                 args <- list()
[18:01:01.529]                 for (kk in seq_along(NAMES)) {
[18:01:01.529]                   name <- changed[[kk]]
[18:01:01.529]                   NAME <- NAMES[[kk]]
[18:01:01.529]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.529]                     next
[18:01:01.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.529]                 }
[18:01:01.529]                 NAMES <- toupper(added)
[18:01:01.529]                 for (kk in seq_along(NAMES)) {
[18:01:01.529]                   name <- added[[kk]]
[18:01:01.529]                   NAME <- NAMES[[kk]]
[18:01:01.529]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.529]                     next
[18:01:01.529]                   args[[name]] <- ""
[18:01:01.529]                 }
[18:01:01.529]                 NAMES <- toupper(removed)
[18:01:01.529]                 for (kk in seq_along(NAMES)) {
[18:01:01.529]                   name <- removed[[kk]]
[18:01:01.529]                   NAME <- NAMES[[kk]]
[18:01:01.529]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.529]                     next
[18:01:01.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.529]                 }
[18:01:01.529]                 if (length(args) > 0) 
[18:01:01.529]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.529]             }
[18:01:01.529]             else {
[18:01:01.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.529]             }
[18:01:01.529]             {
[18:01:01.529]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.529]                   0L) {
[18:01:01.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.529]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.529]                   base::options(opts)
[18:01:01.529]                 }
[18:01:01.529]                 {
[18:01:01.529]                   {
[18:01:01.529]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.529]                     NULL
[18:01:01.529]                   }
[18:01:01.529]                   options(future.plan = NULL)
[18:01:01.529]                   if (is.na(NA_character_)) 
[18:01:01.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.529]                     .init = FALSE)
[18:01:01.529]                 }
[18:01:01.529]             }
[18:01:01.529]         }
[18:01:01.529]     })
[18:01:01.529]     if (TRUE) {
[18:01:01.529]         base::sink(type = "output", split = FALSE)
[18:01:01.529]         if (TRUE) {
[18:01:01.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.529]         }
[18:01:01.529]         else {
[18:01:01.529]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.529]         }
[18:01:01.529]         base::close(...future.stdout)
[18:01:01.529]         ...future.stdout <- NULL
[18:01:01.529]     }
[18:01:01.529]     ...future.result$conditions <- ...future.conditions
[18:01:01.529]     ...future.result$finished <- base::Sys.time()
[18:01:01.529]     ...future.result
[18:01:01.529] }
[18:01:01.534] assign_globals() ...
[18:01:01.534] List of 5
[18:01:01.534]  $ ...future.FUN            :function (C, k)  
[18:01:01.534]  $ MoreArgs                 : list()
[18:01:01.534]  $ ...future.elements_ii    :List of 2
[18:01:01.534]   ..$ :List of 2
[18:01:01.534]   .. ..$ : chr "A"
[18:01:01.534]   .. ..$ : chr "B"
[18:01:01.534]   ..$ :List of 2
[18:01:01.534]   .. ..$ : int 5
[18:01:01.534]   .. ..$ : int 4
[18:01:01.534]  $ ...future.seeds_ii       : NULL
[18:01:01.534]  $ ...future.globals.maxSize: NULL
[18:01:01.534]  - attr(*, "where")=List of 5
[18:01:01.534]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.534]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.534]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.534]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.534]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.534]  - attr(*, "resolved")= logi FALSE
[18:01:01.534]  - attr(*, "total_size")= num 3656
[18:01:01.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.534]  - attr(*, "already-done")= logi TRUE
[18:01:01.546] - reassign environment for ‘...future.FUN’
[18:01:01.546] - copied ‘...future.FUN’ to environment
[18:01:01.546] - copied ‘MoreArgs’ to environment
[18:01:01.547] - copied ‘...future.elements_ii’ to environment
[18:01:01.547] - copied ‘...future.seeds_ii’ to environment
[18:01:01.547] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.547] assign_globals() ... done
[18:01:01.548] requestCore(): workers = 2
[18:01:01.551] MulticoreFuture started
[18:01:01.552] - Launch lazy future ... done
[18:01:01.552] run() for ‘MulticoreFuture’ ... done
[18:01:01.553] Created future:
[18:01:01.553] plan(): Setting new future strategy stack:
[18:01:01.553] List of future strategies:
[18:01:01.553] 1. sequential:
[18:01:01.553]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.553]    - tweaked: FALSE
[18:01:01.553]    - call: NULL
[18:01:01.555] plan(): nbrOfWorkers() = 1
[18:01:01.560] plan(): Setting new future strategy stack:
[18:01:01.560] List of future strategies:
[18:01:01.560] 1. multicore:
[18:01:01.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.560]    - tweaked: FALSE
[18:01:01.560]    - call: plan(strategy)
[18:01:01.553] MulticoreFuture:
[18:01:01.553] Label: ‘future_.mapply-1’
[18:01:01.553] Expression:
[18:01:01.553] {
[18:01:01.553]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.553]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.553]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.553]         on.exit(options(oopts), add = TRUE)
[18:01:01.553]     }
[18:01:01.553]     {
[18:01:01.553]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.553]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.553]         do.call(mapply, args = args)
[18:01:01.553]     }
[18:01:01.553] }
[18:01:01.553] Lazy evaluation: FALSE
[18:01:01.553] Asynchronous evaluation: TRUE
[18:01:01.553] Local evaluation: TRUE
[18:01:01.553] Environment: R_GlobalEnv
[18:01:01.553] Capture standard output: TRUE
[18:01:01.553] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.553] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.553] Packages: <none>
[18:01:01.553] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.553] Resolved: FALSE
[18:01:01.553] Value: <not collected>
[18:01:01.553] Conditions captured: <none>
[18:01:01.553] Early signaling: FALSE
[18:01:01.553] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.553] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.568] Chunk #1 of 2 ... DONE
[18:01:01.569] Chunk #2 of 2 ...
[18:01:01.569]  - Finding globals in '...' for chunk #2 ...
[18:01:01.570] getGlobalsAndPackages() ...
[18:01:01.570] Searching for globals...
[18:01:01.575] 
[18:01:01.576] Searching for globals ... DONE
[18:01:01.577] - globals: [0] <none>
[18:01:01.577] getGlobalsAndPackages() ... DONE
[18:01:01.578]    + additional globals found: [n=0] 
[18:01:01.579]    + additional namespaces needed: [n=0] 
[18:01:01.580]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:01.580]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:01.581]  - seeds: <none>
[18:01:01.582]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.583] getGlobalsAndPackages() ...
[18:01:01.583] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.584] plan(): nbrOfWorkers() = 2
[18:01:01.584] Resolving globals: FALSE
[18:01:01.587] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:01.589] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:01.590] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.590] 
[18:01:01.591] getGlobalsAndPackages() ... DONE
[18:01:01.592] run() for ‘Future’ ...
[18:01:01.593] - state: ‘created’
[18:01:01.593] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.603] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.604]   - Field: ‘label’
[18:01:01.605]   - Field: ‘local’
[18:01:01.605]   - Field: ‘owner’
[18:01:01.605]   - Field: ‘envir’
[18:01:01.606]   - Field: ‘workers’
[18:01:01.606]   - Field: ‘packages’
[18:01:01.606]   - Field: ‘gc’
[18:01:01.607]   - Field: ‘job’
[18:01:01.607]   - Field: ‘conditions’
[18:01:01.607]   - Field: ‘expr’
[18:01:01.607]   - Field: ‘uuid’
[18:01:01.608]   - Field: ‘seed’
[18:01:01.608]   - Field: ‘version’
[18:01:01.608]   - Field: ‘result’
[18:01:01.609]   - Field: ‘asynchronous’
[18:01:01.609]   - Field: ‘calls’
[18:01:01.609]   - Field: ‘globals’
[18:01:01.610]   - Field: ‘stdout’
[18:01:01.610]   - Field: ‘earlySignal’
[18:01:01.610]   - Field: ‘lazy’
[18:01:01.610]   - Field: ‘state’
[18:01:01.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.611] - Launch lazy future ...
[18:01:01.612] Packages needed by the future expression (n = 0): <none>
[18:01:01.613] Packages needed by future strategies (n = 0): <none>
[18:01:01.614] {
[18:01:01.614]     {
[18:01:01.614]         {
[18:01:01.614]             ...future.startTime <- base::Sys.time()
[18:01:01.614]             {
[18:01:01.614]                 {
[18:01:01.614]                   {
[18:01:01.614]                     {
[18:01:01.614]                       base::local({
[18:01:01.614]                         has_future <- base::requireNamespace("future", 
[18:01:01.614]                           quietly = TRUE)
[18:01:01.614]                         if (has_future) {
[18:01:01.614]                           ns <- base::getNamespace("future")
[18:01:01.614]                           version <- ns[[".package"]][["version"]]
[18:01:01.614]                           if (is.null(version)) 
[18:01:01.614]                             version <- utils::packageVersion("future")
[18:01:01.614]                         }
[18:01:01.614]                         else {
[18:01:01.614]                           version <- NULL
[18:01:01.614]                         }
[18:01:01.614]                         if (!has_future || version < "1.8.0") {
[18:01:01.614]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.614]                             "", base::R.version$version.string), 
[18:01:01.614]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.614]                               "release", "version")], collapse = " "), 
[18:01:01.614]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.614]                             info)
[18:01:01.614]                           info <- base::paste(info, collapse = "; ")
[18:01:01.614]                           if (!has_future) {
[18:01:01.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.614]                               info)
[18:01:01.614]                           }
[18:01:01.614]                           else {
[18:01:01.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.614]                               info, version)
[18:01:01.614]                           }
[18:01:01.614]                           base::stop(msg)
[18:01:01.614]                         }
[18:01:01.614]                       })
[18:01:01.614]                     }
[18:01:01.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.614]                     base::options(mc.cores = 1L)
[18:01:01.614]                   }
[18:01:01.614]                   ...future.strategy.old <- future::plan("list")
[18:01:01.614]                   options(future.plan = NULL)
[18:01:01.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.614]                 }
[18:01:01.614]                 ...future.workdir <- getwd()
[18:01:01.614]             }
[18:01:01.614]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.614]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.614]         }
[18:01:01.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.614]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:01.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.614]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.614]             base::names(...future.oldOptions))
[18:01:01.614]     }
[18:01:01.614]     if (FALSE) {
[18:01:01.614]     }
[18:01:01.614]     else {
[18:01:01.614]         if (TRUE) {
[18:01:01.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.614]                 open = "w")
[18:01:01.614]         }
[18:01:01.614]         else {
[18:01:01.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.614]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.614]         }
[18:01:01.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.614]             base::sink(type = "output", split = FALSE)
[18:01:01.614]             base::close(...future.stdout)
[18:01:01.614]         }, add = TRUE)
[18:01:01.614]     }
[18:01:01.614]     ...future.frame <- base::sys.nframe()
[18:01:01.614]     ...future.conditions <- base::list()
[18:01:01.614]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.614]     if (FALSE) {
[18:01:01.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.614]     }
[18:01:01.614]     ...future.result <- base::tryCatch({
[18:01:01.614]         base::withCallingHandlers({
[18:01:01.614]             ...future.value <- base::withVisible(base::local({
[18:01:01.614]                 withCallingHandlers({
[18:01:01.614]                   {
[18:01:01.614]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.614]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.614]                       ...future.globals.maxSize)) {
[18:01:01.614]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.614]                       on.exit(options(oopts), add = TRUE)
[18:01:01.614]                     }
[18:01:01.614]                     {
[18:01:01.614]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.614]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.614]                         USE.NAMES = FALSE)
[18:01:01.614]                       do.call(mapply, args = args)
[18:01:01.614]                     }
[18:01:01.614]                   }
[18:01:01.614]                 }, immediateCondition = function(cond) {
[18:01:01.614]                   save_rds <- function (object, pathname, ...) 
[18:01:01.614]                   {
[18:01:01.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.614]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.614]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.614]                         fi_tmp[["mtime"]])
[18:01:01.614]                     }
[18:01:01.614]                     tryCatch({
[18:01:01.614]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.614]                     }, error = function(ex) {
[18:01:01.614]                       msg <- conditionMessage(ex)
[18:01:01.614]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.614]                         fi_tmp[["mtime"]], msg)
[18:01:01.614]                       ex$message <- msg
[18:01:01.614]                       stop(ex)
[18:01:01.614]                     })
[18:01:01.614]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.614]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.614]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.614]                       fi <- file.info(pathname)
[18:01:01.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.614]                         fi[["size"]], fi[["mtime"]])
[18:01:01.614]                       stop(msg)
[18:01:01.614]                     }
[18:01:01.614]                     invisible(pathname)
[18:01:01.614]                   }
[18:01:01.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.614]                     rootPath = tempdir()) 
[18:01:01.614]                   {
[18:01:01.614]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.614]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.614]                       tmpdir = path, fileext = ".rds")
[18:01:01.614]                     save_rds(obj, file)
[18:01:01.614]                   }
[18:01:01.614]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.614]                   {
[18:01:01.614]                     inherits <- base::inherits
[18:01:01.614]                     invokeRestart <- base::invokeRestart
[18:01:01.614]                     is.null <- base::is.null
[18:01:01.614]                     muffled <- FALSE
[18:01:01.614]                     if (inherits(cond, "message")) {
[18:01:01.614]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.614]                       if (muffled) 
[18:01:01.614]                         invokeRestart("muffleMessage")
[18:01:01.614]                     }
[18:01:01.614]                     else if (inherits(cond, "warning")) {
[18:01:01.614]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.614]                       if (muffled) 
[18:01:01.614]                         invokeRestart("muffleWarning")
[18:01:01.614]                     }
[18:01:01.614]                     else if (inherits(cond, "condition")) {
[18:01:01.614]                       if (!is.null(pattern)) {
[18:01:01.614]                         computeRestarts <- base::computeRestarts
[18:01:01.614]                         grepl <- base::grepl
[18:01:01.614]                         restarts <- computeRestarts(cond)
[18:01:01.614]                         for (restart in restarts) {
[18:01:01.614]                           name <- restart$name
[18:01:01.614]                           if (is.null(name)) 
[18:01:01.614]                             next
[18:01:01.614]                           if (!grepl(pattern, name)) 
[18:01:01.614]                             next
[18:01:01.614]                           invokeRestart(restart)
[18:01:01.614]                           muffled <- TRUE
[18:01:01.614]                           break
[18:01:01.614]                         }
[18:01:01.614]                       }
[18:01:01.614]                     }
[18:01:01.614]                     invisible(muffled)
[18:01:01.614]                   }
[18:01:01.614]                   muffleCondition(cond)
[18:01:01.614]                 })
[18:01:01.614]             }))
[18:01:01.614]             future::FutureResult(value = ...future.value$value, 
[18:01:01.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.614]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.614]                     ...future.globalenv.names))
[18:01:01.614]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.614]         }, condition = base::local({
[18:01:01.614]             c <- base::c
[18:01:01.614]             inherits <- base::inherits
[18:01:01.614]             invokeRestart <- base::invokeRestart
[18:01:01.614]             length <- base::length
[18:01:01.614]             list <- base::list
[18:01:01.614]             seq.int <- base::seq.int
[18:01:01.614]             signalCondition <- base::signalCondition
[18:01:01.614]             sys.calls <- base::sys.calls
[18:01:01.614]             `[[` <- base::`[[`
[18:01:01.614]             `+` <- base::`+`
[18:01:01.614]             `<<-` <- base::`<<-`
[18:01:01.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.614]                   3L)]
[18:01:01.614]             }
[18:01:01.614]             function(cond) {
[18:01:01.614]                 is_error <- inherits(cond, "error")
[18:01:01.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.614]                   NULL)
[18:01:01.614]                 if (is_error) {
[18:01:01.614]                   sessionInformation <- function() {
[18:01:01.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.614]                       search = base::search(), system = base::Sys.info())
[18:01:01.614]                   }
[18:01:01.614]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.614]                     cond$call), session = sessionInformation(), 
[18:01:01.614]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.614]                   signalCondition(cond)
[18:01:01.614]                 }
[18:01:01.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.614]                 "immediateCondition"))) {
[18:01:01.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.614]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.614]                   if (TRUE && !signal) {
[18:01:01.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.614]                     {
[18:01:01.614]                       inherits <- base::inherits
[18:01:01.614]                       invokeRestart <- base::invokeRestart
[18:01:01.614]                       is.null <- base::is.null
[18:01:01.614]                       muffled <- FALSE
[18:01:01.614]                       if (inherits(cond, "message")) {
[18:01:01.614]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.614]                         if (muffled) 
[18:01:01.614]                           invokeRestart("muffleMessage")
[18:01:01.614]                       }
[18:01:01.614]                       else if (inherits(cond, "warning")) {
[18:01:01.614]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.614]                         if (muffled) 
[18:01:01.614]                           invokeRestart("muffleWarning")
[18:01:01.614]                       }
[18:01:01.614]                       else if (inherits(cond, "condition")) {
[18:01:01.614]                         if (!is.null(pattern)) {
[18:01:01.614]                           computeRestarts <- base::computeRestarts
[18:01:01.614]                           grepl <- base::grepl
[18:01:01.614]                           restarts <- computeRestarts(cond)
[18:01:01.614]                           for (restart in restarts) {
[18:01:01.614]                             name <- restart$name
[18:01:01.614]                             if (is.null(name)) 
[18:01:01.614]                               next
[18:01:01.614]                             if (!grepl(pattern, name)) 
[18:01:01.614]                               next
[18:01:01.614]                             invokeRestart(restart)
[18:01:01.614]                             muffled <- TRUE
[18:01:01.614]                             break
[18:01:01.614]                           }
[18:01:01.614]                         }
[18:01:01.614]                       }
[18:01:01.614]                       invisible(muffled)
[18:01:01.614]                     }
[18:01:01.614]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.614]                   }
[18:01:01.614]                 }
[18:01:01.614]                 else {
[18:01:01.614]                   if (TRUE) {
[18:01:01.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.614]                     {
[18:01:01.614]                       inherits <- base::inherits
[18:01:01.614]                       invokeRestart <- base::invokeRestart
[18:01:01.614]                       is.null <- base::is.null
[18:01:01.614]                       muffled <- FALSE
[18:01:01.614]                       if (inherits(cond, "message")) {
[18:01:01.614]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.614]                         if (muffled) 
[18:01:01.614]                           invokeRestart("muffleMessage")
[18:01:01.614]                       }
[18:01:01.614]                       else if (inherits(cond, "warning")) {
[18:01:01.614]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.614]                         if (muffled) 
[18:01:01.614]                           invokeRestart("muffleWarning")
[18:01:01.614]                       }
[18:01:01.614]                       else if (inherits(cond, "condition")) {
[18:01:01.614]                         if (!is.null(pattern)) {
[18:01:01.614]                           computeRestarts <- base::computeRestarts
[18:01:01.614]                           grepl <- base::grepl
[18:01:01.614]                           restarts <- computeRestarts(cond)
[18:01:01.614]                           for (restart in restarts) {
[18:01:01.614]                             name <- restart$name
[18:01:01.614]                             if (is.null(name)) 
[18:01:01.614]                               next
[18:01:01.614]                             if (!grepl(pattern, name)) 
[18:01:01.614]                               next
[18:01:01.614]                             invokeRestart(restart)
[18:01:01.614]                             muffled <- TRUE
[18:01:01.614]                             break
[18:01:01.614]                           }
[18:01:01.614]                         }
[18:01:01.614]                       }
[18:01:01.614]                       invisible(muffled)
[18:01:01.614]                     }
[18:01:01.614]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.614]                   }
[18:01:01.614]                 }
[18:01:01.614]             }
[18:01:01.614]         }))
[18:01:01.614]     }, error = function(ex) {
[18:01:01.614]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.614]                 ...future.rng), started = ...future.startTime, 
[18:01:01.614]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.614]             version = "1.8"), class = "FutureResult")
[18:01:01.614]     }, finally = {
[18:01:01.614]         if (!identical(...future.workdir, getwd())) 
[18:01:01.614]             setwd(...future.workdir)
[18:01:01.614]         {
[18:01:01.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.614]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.614]             }
[18:01:01.614]             base::options(...future.oldOptions)
[18:01:01.614]             if (.Platform$OS.type == "windows") {
[18:01:01.614]                 old_names <- names(...future.oldEnvVars)
[18:01:01.614]                 envs <- base::Sys.getenv()
[18:01:01.614]                 names <- names(envs)
[18:01:01.614]                 common <- intersect(names, old_names)
[18:01:01.614]                 added <- setdiff(names, old_names)
[18:01:01.614]                 removed <- setdiff(old_names, names)
[18:01:01.614]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.614]                   envs[common]]
[18:01:01.614]                 NAMES <- toupper(changed)
[18:01:01.614]                 args <- list()
[18:01:01.614]                 for (kk in seq_along(NAMES)) {
[18:01:01.614]                   name <- changed[[kk]]
[18:01:01.614]                   NAME <- NAMES[[kk]]
[18:01:01.614]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.614]                     next
[18:01:01.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.614]                 }
[18:01:01.614]                 NAMES <- toupper(added)
[18:01:01.614]                 for (kk in seq_along(NAMES)) {
[18:01:01.614]                   name <- added[[kk]]
[18:01:01.614]                   NAME <- NAMES[[kk]]
[18:01:01.614]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.614]                     next
[18:01:01.614]                   args[[name]] <- ""
[18:01:01.614]                 }
[18:01:01.614]                 NAMES <- toupper(removed)
[18:01:01.614]                 for (kk in seq_along(NAMES)) {
[18:01:01.614]                   name <- removed[[kk]]
[18:01:01.614]                   NAME <- NAMES[[kk]]
[18:01:01.614]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.614]                     next
[18:01:01.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.614]                 }
[18:01:01.614]                 if (length(args) > 0) 
[18:01:01.614]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.614]             }
[18:01:01.614]             else {
[18:01:01.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.614]             }
[18:01:01.614]             {
[18:01:01.614]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.614]                   0L) {
[18:01:01.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.614]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.614]                   base::options(opts)
[18:01:01.614]                 }
[18:01:01.614]                 {
[18:01:01.614]                   {
[18:01:01.614]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.614]                     NULL
[18:01:01.614]                   }
[18:01:01.614]                   options(future.plan = NULL)
[18:01:01.614]                   if (is.na(NA_character_)) 
[18:01:01.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.614]                     .init = FALSE)
[18:01:01.614]                 }
[18:01:01.614]             }
[18:01:01.614]         }
[18:01:01.614]     })
[18:01:01.614]     if (TRUE) {
[18:01:01.614]         base::sink(type = "output", split = FALSE)
[18:01:01.614]         if (TRUE) {
[18:01:01.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.614]         }
[18:01:01.614]         else {
[18:01:01.614]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.614]         }
[18:01:01.614]         base::close(...future.stdout)
[18:01:01.614]         ...future.stdout <- NULL
[18:01:01.614]     }
[18:01:01.614]     ...future.result$conditions <- ...future.conditions
[18:01:01.614]     ...future.result$finished <- base::Sys.time()
[18:01:01.614]     ...future.result
[18:01:01.614] }
[18:01:01.620] assign_globals() ...
[18:01:01.620] List of 5
[18:01:01.620]  $ ...future.FUN            :function (C, k)  
[18:01:01.620]  $ MoreArgs                 : list()
[18:01:01.620]  $ ...future.elements_ii    :List of 2
[18:01:01.620]   ..$ :List of 3
[18:01:01.620]   .. ..$ : chr "C"
[18:01:01.620]   .. ..$ : chr "D"
[18:01:01.620]   .. ..$ : chr "E"
[18:01:01.620]   ..$ :List of 3
[18:01:01.620]   .. ..$ : int 3
[18:01:01.620]   .. ..$ : int 2
[18:01:01.620]   .. ..$ : int 1
[18:01:01.620]  $ ...future.seeds_ii       : NULL
[18:01:01.620]  $ ...future.globals.maxSize: NULL
[18:01:01.620]  - attr(*, "where")=List of 5
[18:01:01.620]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.620]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.620]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.620]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.620]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.620]  - attr(*, "resolved")= logi FALSE
[18:01:01.620]  - attr(*, "total_size")= num 3824
[18:01:01.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.620]  - attr(*, "already-done")= logi TRUE
[18:01:01.636] - reassign environment for ‘...future.FUN’
[18:01:01.636] - copied ‘...future.FUN’ to environment
[18:01:01.637] - copied ‘MoreArgs’ to environment
[18:01:01.637] - copied ‘...future.elements_ii’ to environment
[18:01:01.637] - copied ‘...future.seeds_ii’ to environment
[18:01:01.637] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.638] assign_globals() ... done
[18:01:01.638] requestCore(): workers = 2
[18:01:01.642] MulticoreFuture started
[18:01:01.642] - Launch lazy future ... done
[18:01:01.643] run() for ‘MulticoreFuture’ ... done
[18:01:01.643] plan(): Setting new future strategy stack:
[18:01:01.644] Created future:
[18:01:01.644] List of future strategies:
[18:01:01.644] 1. sequential:
[18:01:01.644]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.644]    - tweaked: FALSE
[18:01:01.644]    - call: NULL
[18:01:01.646] plan(): nbrOfWorkers() = 1
[18:01:01.650] plan(): Setting new future strategy stack:
[18:01:01.651] List of future strategies:
[18:01:01.651] 1. multicore:
[18:01:01.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.651]    - tweaked: FALSE
[18:01:01.651]    - call: plan(strategy)
[18:01:01.644] MulticoreFuture:
[18:01:01.644] Label: ‘future_.mapply-2’
[18:01:01.644] Expression:
[18:01:01.644] {
[18:01:01.644]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.644]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.644]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.644]         on.exit(options(oopts), add = TRUE)
[18:01:01.644]     }
[18:01:01.644]     {
[18:01:01.644]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.644]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.644]         do.call(mapply, args = args)
[18:01:01.644]     }
[18:01:01.644] }
[18:01:01.644] Lazy evaluation: FALSE
[18:01:01.644] Asynchronous evaluation: TRUE
[18:01:01.644] Local evaluation: TRUE
[18:01:01.644] Environment: R_GlobalEnv
[18:01:01.644] Capture standard output: TRUE
[18:01:01.644] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.644] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.644] Packages: <none>
[18:01:01.644] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.644] Resolved: FALSE
[18:01:01.644] Value: <not collected>
[18:01:01.644] Conditions captured: <none>
[18:01:01.644] Early signaling: FALSE
[18:01:01.644] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.644] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.659] Chunk #2 of 2 ... DONE
[18:01:01.659] Launching 2 futures (chunks) ... DONE
[18:01:01.660] Resolving 2 futures (chunks) ...
[18:01:01.660] plan(): nbrOfWorkers() = 2
[18:01:01.660] resolve() on list ...
[18:01:01.660]  recursive: 0
[18:01:01.661]  length: 2
[18:01:01.661] 
[18:01:01.662] Future #1
[18:01:01.662] result() for MulticoreFuture ...
[18:01:01.664] result() for MulticoreFuture ...
[18:01:01.664] result() for MulticoreFuture ... done
[18:01:01.664] result() for MulticoreFuture ... done
[18:01:01.665] result() for MulticoreFuture ...
[18:01:01.665] result() for MulticoreFuture ... done
[18:01:01.665] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:01.666] - nx: 2
[18:01:01.666] - relay: TRUE
[18:01:01.666] - stdout: TRUE
[18:01:01.667] - signal: TRUE
[18:01:01.667] - resignal: FALSE
[18:01:01.667] - force: TRUE
[18:01:01.668] - relayed: [n=2] FALSE, FALSE
[18:01:01.668] - queued futures: [n=2] FALSE, FALSE
[18:01:01.668]  - until=1
[18:01:01.669]  - relaying element #1
[18:01:01.669] result() for MulticoreFuture ...
[18:01:01.669] result() for MulticoreFuture ... done
[18:01:01.670] result() for MulticoreFuture ...
[18:01:01.675] result() for MulticoreFuture ... done
[18:01:01.676] result() for MulticoreFuture ...
[18:01:01.677] result() for MulticoreFuture ... done
[18:01:01.678] result() for MulticoreFuture ...
[18:01:01.679] result() for MulticoreFuture ... done
[18:01:01.679] - relayed: [n=2] TRUE, FALSE
[18:01:01.680] - queued futures: [n=2] TRUE, FALSE
[18:01:01.680] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:01.681]  length: 1 (resolved future 1)
[18:01:01.682] Future #2
[18:01:01.683] result() for MulticoreFuture ...
[18:01:01.685] result() for MulticoreFuture ...
[18:01:01.685] result() for MulticoreFuture ... done
[18:01:01.686] result() for MulticoreFuture ... done
[18:01:01.686] result() for MulticoreFuture ...
[18:01:01.687] result() for MulticoreFuture ... done
[18:01:01.687] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:01.687] - nx: 2
[18:01:01.688] - relay: TRUE
[18:01:01.688] - stdout: TRUE
[18:01:01.688] - signal: TRUE
[18:01:01.688] - resignal: FALSE
[18:01:01.689] - force: TRUE
[18:01:01.689] - relayed: [n=2] TRUE, FALSE
[18:01:01.689] - queued futures: [n=2] TRUE, FALSE
[18:01:01.690]  - until=2
[18:01:01.690]  - relaying element #2
[18:01:01.690] result() for MulticoreFuture ...
[18:01:01.690] result() for MulticoreFuture ... done
[18:01:01.691] result() for MulticoreFuture ...
[18:01:01.691] result() for MulticoreFuture ... done
[18:01:01.691] result() for MulticoreFuture ...
[18:01:01.692] result() for MulticoreFuture ... done
[18:01:01.692] result() for MulticoreFuture ...
[18:01:01.692] result() for MulticoreFuture ... done
[18:01:01.692] - relayed: [n=2] TRUE, TRUE
[18:01:01.693] - queued futures: [n=2] TRUE, TRUE
[18:01:01.693] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:01.693]  length: 0 (resolved future 2)
[18:01:01.693] Relaying remaining futures
[18:01:01.694] signalConditionsASAP(NULL, pos=0) ...
[18:01:01.694] - nx: 2
[18:01:01.694] - relay: TRUE
[18:01:01.694] - stdout: TRUE
[18:01:01.694] - signal: TRUE
[18:01:01.695] - resignal: FALSE
[18:01:01.695] - force: TRUE
[18:01:01.695] - relayed: [n=2] TRUE, TRUE
[18:01:01.695] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:01.696] - relayed: [n=2] TRUE, TRUE
[18:01:01.696] - queued futures: [n=2] TRUE, TRUE
[18:01:01.696] signalConditionsASAP(NULL, pos=0) ... done
[18:01:01.696] resolve() on list ... DONE
[18:01:01.696] result() for MulticoreFuture ...
[18:01:01.697] result() for MulticoreFuture ... done
[18:01:01.697] result() for MulticoreFuture ...
[18:01:01.697] result() for MulticoreFuture ... done
[18:01:01.697] result() for MulticoreFuture ...
[18:01:01.698] result() for MulticoreFuture ... done
[18:01:01.698] result() for MulticoreFuture ...
[18:01:01.698] result() for MulticoreFuture ... done
[18:01:01.698]  - Number of value chunks collected: 2
[18:01:01.698] Resolving 2 futures (chunks) ... DONE
[18:01:01.699] Reducing values from 2 chunks ...
[18:01:01.699]  - Number of values collected after concatenation: 5
[18:01:01.699]  - Number of values expected: 5
[18:01:01.699] Reducing values from 2 chunks ... DONE
[18:01:01.700] future_mapply() ... DONE
[18:01:01.700] future_mapply() ...
[18:01:01.707] Number of chunks: 2
[18:01:01.708] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[18:01:01.708] getGlobalsAndPackagesXApply() ...
[18:01:01.708]  - future.globals: TRUE
[18:01:01.708] getGlobalsAndPackages() ...
[18:01:01.709] Searching for globals...
[18:01:01.711] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:01.712] Searching for globals ... DONE
[18:01:01.712] Resolving globals: FALSE
[18:01:01.713] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:01.713] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:01.714] - globals: [1] ‘FUN’
[18:01:01.714] 
[18:01:01.714] getGlobalsAndPackages() ... DONE
[18:01:01.714]  - globals found/used: [n=1] ‘FUN’
[18:01:01.714]  - needed namespaces: [n=0] 
[18:01:01.715] Finding globals ... DONE
[18:01:01.715] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:01.715] List of 2
[18:01:01.715]  $ ...future.FUN:function (C, k)  
[18:01:01.715]  $ MoreArgs     : NULL
[18:01:01.715]  - attr(*, "where")=List of 2
[18:01:01.715]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:01.715]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:01.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.715]  - attr(*, "resolved")= logi FALSE
[18:01:01.715]  - attr(*, "total_size")= num NA
[18:01:01.721] Packages to be attached in all futures: [n=0] 
[18:01:01.721] getGlobalsAndPackagesXApply() ... DONE
[18:01:01.721] Number of futures (= number of chunks): 2
[18:01:01.722] Launching 2 futures (chunks) ...
[18:01:01.722] Chunk #1 of 2 ...
[18:01:01.722]  - Finding globals in '...' for chunk #1 ...
[18:01:01.722] getGlobalsAndPackages() ...
[18:01:01.722] Searching for globals...
[18:01:01.723] 
[18:01:01.723] Searching for globals ... DONE
[18:01:01.724] - globals: [0] <none>
[18:01:01.724] getGlobalsAndPackages() ... DONE
[18:01:01.724]    + additional globals found: [n=0] 
[18:01:01.724]    + additional namespaces needed: [n=0] 
[18:01:01.724]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:01.724]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:01.725]  - seeds: <none>
[18:01:01.725]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.725] getGlobalsAndPackages() ...
[18:01:01.725] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.726] Resolving globals: FALSE
[18:01:01.727] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:01.727] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:01.728] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.728] 
[18:01:01.728] getGlobalsAndPackages() ... DONE
[18:01:01.729] run() for ‘Future’ ...
[18:01:01.729] - state: ‘created’
[18:01:01.729] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.739]   - Field: ‘label’
[18:01:01.739]   - Field: ‘local’
[18:01:01.740]   - Field: ‘owner’
[18:01:01.740]   - Field: ‘envir’
[18:01:01.740]   - Field: ‘workers’
[18:01:01.740]   - Field: ‘packages’
[18:01:01.740]   - Field: ‘gc’
[18:01:01.741]   - Field: ‘job’
[18:01:01.741]   - Field: ‘conditions’
[18:01:01.741]   - Field: ‘expr’
[18:01:01.741]   - Field: ‘uuid’
[18:01:01.742]   - Field: ‘seed’
[18:01:01.742]   - Field: ‘version’
[18:01:01.742]   - Field: ‘result’
[18:01:01.742]   - Field: ‘asynchronous’
[18:01:01.742]   - Field: ‘calls’
[18:01:01.743]   - Field: ‘globals’
[18:01:01.743]   - Field: ‘stdout’
[18:01:01.743]   - Field: ‘earlySignal’
[18:01:01.743]   - Field: ‘lazy’
[18:01:01.743]   - Field: ‘state’
[18:01:01.744] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.744] - Launch lazy future ...
[18:01:01.744] Packages needed by the future expression (n = 0): <none>
[18:01:01.745] Packages needed by future strategies (n = 0): <none>
[18:01:01.746] {
[18:01:01.746]     {
[18:01:01.746]         {
[18:01:01.746]             ...future.startTime <- base::Sys.time()
[18:01:01.746]             {
[18:01:01.746]                 {
[18:01:01.746]                   {
[18:01:01.746]                     {
[18:01:01.746]                       base::local({
[18:01:01.746]                         has_future <- base::requireNamespace("future", 
[18:01:01.746]                           quietly = TRUE)
[18:01:01.746]                         if (has_future) {
[18:01:01.746]                           ns <- base::getNamespace("future")
[18:01:01.746]                           version <- ns[[".package"]][["version"]]
[18:01:01.746]                           if (is.null(version)) 
[18:01:01.746]                             version <- utils::packageVersion("future")
[18:01:01.746]                         }
[18:01:01.746]                         else {
[18:01:01.746]                           version <- NULL
[18:01:01.746]                         }
[18:01:01.746]                         if (!has_future || version < "1.8.0") {
[18:01:01.746]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.746]                             "", base::R.version$version.string), 
[18:01:01.746]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.746]                               "release", "version")], collapse = " "), 
[18:01:01.746]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.746]                             info)
[18:01:01.746]                           info <- base::paste(info, collapse = "; ")
[18:01:01.746]                           if (!has_future) {
[18:01:01.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.746]                               info)
[18:01:01.746]                           }
[18:01:01.746]                           else {
[18:01:01.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.746]                               info, version)
[18:01:01.746]                           }
[18:01:01.746]                           base::stop(msg)
[18:01:01.746]                         }
[18:01:01.746]                       })
[18:01:01.746]                     }
[18:01:01.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.746]                     base::options(mc.cores = 1L)
[18:01:01.746]                   }
[18:01:01.746]                   ...future.strategy.old <- future::plan("list")
[18:01:01.746]                   options(future.plan = NULL)
[18:01:01.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.746]                 }
[18:01:01.746]                 ...future.workdir <- getwd()
[18:01:01.746]             }
[18:01:01.746]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.746]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.746]         }
[18:01:01.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.746]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:01.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.746]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.746]             base::names(...future.oldOptions))
[18:01:01.746]     }
[18:01:01.746]     if (FALSE) {
[18:01:01.746]     }
[18:01:01.746]     else {
[18:01:01.746]         if (TRUE) {
[18:01:01.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.746]                 open = "w")
[18:01:01.746]         }
[18:01:01.746]         else {
[18:01:01.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.746]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.746]         }
[18:01:01.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.746]             base::sink(type = "output", split = FALSE)
[18:01:01.746]             base::close(...future.stdout)
[18:01:01.746]         }, add = TRUE)
[18:01:01.746]     }
[18:01:01.746]     ...future.frame <- base::sys.nframe()
[18:01:01.746]     ...future.conditions <- base::list()
[18:01:01.746]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.746]     if (FALSE) {
[18:01:01.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.746]     }
[18:01:01.746]     ...future.result <- base::tryCatch({
[18:01:01.746]         base::withCallingHandlers({
[18:01:01.746]             ...future.value <- base::withVisible(base::local({
[18:01:01.746]                 withCallingHandlers({
[18:01:01.746]                   {
[18:01:01.746]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.746]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.746]                       ...future.globals.maxSize)) {
[18:01:01.746]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.746]                       on.exit(options(oopts), add = TRUE)
[18:01:01.746]                     }
[18:01:01.746]                     {
[18:01:01.746]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.746]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.746]                         USE.NAMES = FALSE)
[18:01:01.746]                       do.call(mapply, args = args)
[18:01:01.746]                     }
[18:01:01.746]                   }
[18:01:01.746]                 }, immediateCondition = function(cond) {
[18:01:01.746]                   save_rds <- function (object, pathname, ...) 
[18:01:01.746]                   {
[18:01:01.746]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.746]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.746]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.746]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.746]                         fi_tmp[["mtime"]])
[18:01:01.746]                     }
[18:01:01.746]                     tryCatch({
[18:01:01.746]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.746]                     }, error = function(ex) {
[18:01:01.746]                       msg <- conditionMessage(ex)
[18:01:01.746]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.746]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.746]                         fi_tmp[["mtime"]], msg)
[18:01:01.746]                       ex$message <- msg
[18:01:01.746]                       stop(ex)
[18:01:01.746]                     })
[18:01:01.746]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.746]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.746]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.746]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.746]                       fi <- file.info(pathname)
[18:01:01.746]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.746]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.746]                         fi[["size"]], fi[["mtime"]])
[18:01:01.746]                       stop(msg)
[18:01:01.746]                     }
[18:01:01.746]                     invisible(pathname)
[18:01:01.746]                   }
[18:01:01.746]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.746]                     rootPath = tempdir()) 
[18:01:01.746]                   {
[18:01:01.746]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.746]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.746]                       tmpdir = path, fileext = ".rds")
[18:01:01.746]                     save_rds(obj, file)
[18:01:01.746]                   }
[18:01:01.746]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.746]                   {
[18:01:01.746]                     inherits <- base::inherits
[18:01:01.746]                     invokeRestart <- base::invokeRestart
[18:01:01.746]                     is.null <- base::is.null
[18:01:01.746]                     muffled <- FALSE
[18:01:01.746]                     if (inherits(cond, "message")) {
[18:01:01.746]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.746]                       if (muffled) 
[18:01:01.746]                         invokeRestart("muffleMessage")
[18:01:01.746]                     }
[18:01:01.746]                     else if (inherits(cond, "warning")) {
[18:01:01.746]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.746]                       if (muffled) 
[18:01:01.746]                         invokeRestart("muffleWarning")
[18:01:01.746]                     }
[18:01:01.746]                     else if (inherits(cond, "condition")) {
[18:01:01.746]                       if (!is.null(pattern)) {
[18:01:01.746]                         computeRestarts <- base::computeRestarts
[18:01:01.746]                         grepl <- base::grepl
[18:01:01.746]                         restarts <- computeRestarts(cond)
[18:01:01.746]                         for (restart in restarts) {
[18:01:01.746]                           name <- restart$name
[18:01:01.746]                           if (is.null(name)) 
[18:01:01.746]                             next
[18:01:01.746]                           if (!grepl(pattern, name)) 
[18:01:01.746]                             next
[18:01:01.746]                           invokeRestart(restart)
[18:01:01.746]                           muffled <- TRUE
[18:01:01.746]                           break
[18:01:01.746]                         }
[18:01:01.746]                       }
[18:01:01.746]                     }
[18:01:01.746]                     invisible(muffled)
[18:01:01.746]                   }
[18:01:01.746]                   muffleCondition(cond)
[18:01:01.746]                 })
[18:01:01.746]             }))
[18:01:01.746]             future::FutureResult(value = ...future.value$value, 
[18:01:01.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.746]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.746]                     ...future.globalenv.names))
[18:01:01.746]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.746]         }, condition = base::local({
[18:01:01.746]             c <- base::c
[18:01:01.746]             inherits <- base::inherits
[18:01:01.746]             invokeRestart <- base::invokeRestart
[18:01:01.746]             length <- base::length
[18:01:01.746]             list <- base::list
[18:01:01.746]             seq.int <- base::seq.int
[18:01:01.746]             signalCondition <- base::signalCondition
[18:01:01.746]             sys.calls <- base::sys.calls
[18:01:01.746]             `[[` <- base::`[[`
[18:01:01.746]             `+` <- base::`+`
[18:01:01.746]             `<<-` <- base::`<<-`
[18:01:01.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.746]                   3L)]
[18:01:01.746]             }
[18:01:01.746]             function(cond) {
[18:01:01.746]                 is_error <- inherits(cond, "error")
[18:01:01.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.746]                   NULL)
[18:01:01.746]                 if (is_error) {
[18:01:01.746]                   sessionInformation <- function() {
[18:01:01.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.746]                       search = base::search(), system = base::Sys.info())
[18:01:01.746]                   }
[18:01:01.746]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.746]                     cond$call), session = sessionInformation(), 
[18:01:01.746]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.746]                   signalCondition(cond)
[18:01:01.746]                 }
[18:01:01.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.746]                 "immediateCondition"))) {
[18:01:01.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.746]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.746]                   if (TRUE && !signal) {
[18:01:01.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.746]                     {
[18:01:01.746]                       inherits <- base::inherits
[18:01:01.746]                       invokeRestart <- base::invokeRestart
[18:01:01.746]                       is.null <- base::is.null
[18:01:01.746]                       muffled <- FALSE
[18:01:01.746]                       if (inherits(cond, "message")) {
[18:01:01.746]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.746]                         if (muffled) 
[18:01:01.746]                           invokeRestart("muffleMessage")
[18:01:01.746]                       }
[18:01:01.746]                       else if (inherits(cond, "warning")) {
[18:01:01.746]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.746]                         if (muffled) 
[18:01:01.746]                           invokeRestart("muffleWarning")
[18:01:01.746]                       }
[18:01:01.746]                       else if (inherits(cond, "condition")) {
[18:01:01.746]                         if (!is.null(pattern)) {
[18:01:01.746]                           computeRestarts <- base::computeRestarts
[18:01:01.746]                           grepl <- base::grepl
[18:01:01.746]                           restarts <- computeRestarts(cond)
[18:01:01.746]                           for (restart in restarts) {
[18:01:01.746]                             name <- restart$name
[18:01:01.746]                             if (is.null(name)) 
[18:01:01.746]                               next
[18:01:01.746]                             if (!grepl(pattern, name)) 
[18:01:01.746]                               next
[18:01:01.746]                             invokeRestart(restart)
[18:01:01.746]                             muffled <- TRUE
[18:01:01.746]                             break
[18:01:01.746]                           }
[18:01:01.746]                         }
[18:01:01.746]                       }
[18:01:01.746]                       invisible(muffled)
[18:01:01.746]                     }
[18:01:01.746]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.746]                   }
[18:01:01.746]                 }
[18:01:01.746]                 else {
[18:01:01.746]                   if (TRUE) {
[18:01:01.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.746]                     {
[18:01:01.746]                       inherits <- base::inherits
[18:01:01.746]                       invokeRestart <- base::invokeRestart
[18:01:01.746]                       is.null <- base::is.null
[18:01:01.746]                       muffled <- FALSE
[18:01:01.746]                       if (inherits(cond, "message")) {
[18:01:01.746]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.746]                         if (muffled) 
[18:01:01.746]                           invokeRestart("muffleMessage")
[18:01:01.746]                       }
[18:01:01.746]                       else if (inherits(cond, "warning")) {
[18:01:01.746]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.746]                         if (muffled) 
[18:01:01.746]                           invokeRestart("muffleWarning")
[18:01:01.746]                       }
[18:01:01.746]                       else if (inherits(cond, "condition")) {
[18:01:01.746]                         if (!is.null(pattern)) {
[18:01:01.746]                           computeRestarts <- base::computeRestarts
[18:01:01.746]                           grepl <- base::grepl
[18:01:01.746]                           restarts <- computeRestarts(cond)
[18:01:01.746]                           for (restart in restarts) {
[18:01:01.746]                             name <- restart$name
[18:01:01.746]                             if (is.null(name)) 
[18:01:01.746]                               next
[18:01:01.746]                             if (!grepl(pattern, name)) 
[18:01:01.746]                               next
[18:01:01.746]                             invokeRestart(restart)
[18:01:01.746]                             muffled <- TRUE
[18:01:01.746]                             break
[18:01:01.746]                           }
[18:01:01.746]                         }
[18:01:01.746]                       }
[18:01:01.746]                       invisible(muffled)
[18:01:01.746]                     }
[18:01:01.746]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.746]                   }
[18:01:01.746]                 }
[18:01:01.746]             }
[18:01:01.746]         }))
[18:01:01.746]     }, error = function(ex) {
[18:01:01.746]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.746]                 ...future.rng), started = ...future.startTime, 
[18:01:01.746]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.746]             version = "1.8"), class = "FutureResult")
[18:01:01.746]     }, finally = {
[18:01:01.746]         if (!identical(...future.workdir, getwd())) 
[18:01:01.746]             setwd(...future.workdir)
[18:01:01.746]         {
[18:01:01.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.746]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.746]             }
[18:01:01.746]             base::options(...future.oldOptions)
[18:01:01.746]             if (.Platform$OS.type == "windows") {
[18:01:01.746]                 old_names <- names(...future.oldEnvVars)
[18:01:01.746]                 envs <- base::Sys.getenv()
[18:01:01.746]                 names <- names(envs)
[18:01:01.746]                 common <- intersect(names, old_names)
[18:01:01.746]                 added <- setdiff(names, old_names)
[18:01:01.746]                 removed <- setdiff(old_names, names)
[18:01:01.746]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.746]                   envs[common]]
[18:01:01.746]                 NAMES <- toupper(changed)
[18:01:01.746]                 args <- list()
[18:01:01.746]                 for (kk in seq_along(NAMES)) {
[18:01:01.746]                   name <- changed[[kk]]
[18:01:01.746]                   NAME <- NAMES[[kk]]
[18:01:01.746]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.746]                     next
[18:01:01.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.746]                 }
[18:01:01.746]                 NAMES <- toupper(added)
[18:01:01.746]                 for (kk in seq_along(NAMES)) {
[18:01:01.746]                   name <- added[[kk]]
[18:01:01.746]                   NAME <- NAMES[[kk]]
[18:01:01.746]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.746]                     next
[18:01:01.746]                   args[[name]] <- ""
[18:01:01.746]                 }
[18:01:01.746]                 NAMES <- toupper(removed)
[18:01:01.746]                 for (kk in seq_along(NAMES)) {
[18:01:01.746]                   name <- removed[[kk]]
[18:01:01.746]                   NAME <- NAMES[[kk]]
[18:01:01.746]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.746]                     next
[18:01:01.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.746]                 }
[18:01:01.746]                 if (length(args) > 0) 
[18:01:01.746]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.746]             }
[18:01:01.746]             else {
[18:01:01.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.746]             }
[18:01:01.746]             {
[18:01:01.746]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.746]                   0L) {
[18:01:01.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.746]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.746]                   base::options(opts)
[18:01:01.746]                 }
[18:01:01.746]                 {
[18:01:01.746]                   {
[18:01:01.746]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.746]                     NULL
[18:01:01.746]                   }
[18:01:01.746]                   options(future.plan = NULL)
[18:01:01.746]                   if (is.na(NA_character_)) 
[18:01:01.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.746]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.746]                     .init = FALSE)
[18:01:01.746]                 }
[18:01:01.746]             }
[18:01:01.746]         }
[18:01:01.746]     })
[18:01:01.746]     if (TRUE) {
[18:01:01.746]         base::sink(type = "output", split = FALSE)
[18:01:01.746]         if (TRUE) {
[18:01:01.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.746]         }
[18:01:01.746]         else {
[18:01:01.746]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.746]         }
[18:01:01.746]         base::close(...future.stdout)
[18:01:01.746]         ...future.stdout <- NULL
[18:01:01.746]     }
[18:01:01.746]     ...future.result$conditions <- ...future.conditions
[18:01:01.746]     ...future.result$finished <- base::Sys.time()
[18:01:01.746]     ...future.result
[18:01:01.746] }
[18:01:01.750] assign_globals() ...
[18:01:01.750] List of 5
[18:01:01.750]  $ ...future.FUN            :function (C, k)  
[18:01:01.750]  $ MoreArgs                 : NULL
[18:01:01.750]  $ ...future.elements_ii    :List of 2
[18:01:01.750]   ..$ :List of 2
[18:01:01.750]   .. ..$ : chr "E"
[18:01:01.750]   .. ..$ : chr "D"
[18:01:01.750]   ..$ :List of 2
[18:01:01.750]   .. ..$ : int 1
[18:01:01.750]   .. ..$ : int 2
[18:01:01.750]  $ ...future.seeds_ii       : NULL
[18:01:01.750]  $ ...future.globals.maxSize: NULL
[18:01:01.750]  - attr(*, "where")=List of 5
[18:01:01.750]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.750]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.750]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.750]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.750]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.750]  - attr(*, "resolved")= logi FALSE
[18:01:01.750]  - attr(*, "total_size")= num 3656
[18:01:01.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.750]  - attr(*, "already-done")= logi TRUE
[18:01:01.762] - reassign environment for ‘...future.FUN’
[18:01:01.762] - copied ‘...future.FUN’ to environment
[18:01:01.762] - copied ‘MoreArgs’ to environment
[18:01:01.762] - copied ‘...future.elements_ii’ to environment
[18:01:01.763] - copied ‘...future.seeds_ii’ to environment
[18:01:01.763] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.763] assign_globals() ... done
[18:01:01.763] requestCore(): workers = 2
[18:01:01.767] MulticoreFuture started
[18:01:01.768] - Launch lazy future ... done
[18:01:01.768] run() for ‘MulticoreFuture’ ... done
[18:01:01.769] Created future:
[18:01:01.769] plan(): Setting new future strategy stack:
[18:01:01.769] List of future strategies:
[18:01:01.769] 1. sequential:
[18:01:01.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.769]    - tweaked: FALSE
[18:01:01.769]    - call: NULL
[18:01:01.772] plan(): nbrOfWorkers() = 1
[18:01:01.776] plan(): Setting new future strategy stack:
[18:01:01.777] List of future strategies:
[18:01:01.777] 1. multicore:
[18:01:01.777]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.777]    - tweaked: FALSE
[18:01:01.777]    - call: plan(strategy)
[18:01:01.769] MulticoreFuture:
[18:01:01.769] Label: ‘future_mapply-1’
[18:01:01.769] Expression:
[18:01:01.769] {
[18:01:01.769]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.769]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.769]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.769]         on.exit(options(oopts), add = TRUE)
[18:01:01.769]     }
[18:01:01.769]     {
[18:01:01.769]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.769]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.769]         do.call(mapply, args = args)
[18:01:01.769]     }
[18:01:01.769] }
[18:01:01.769] Lazy evaluation: FALSE
[18:01:01.769] Asynchronous evaluation: TRUE
[18:01:01.769] Local evaluation: TRUE
[18:01:01.769] Environment: R_GlobalEnv
[18:01:01.769] Capture standard output: TRUE
[18:01:01.769] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.769] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.769] Packages: <none>
[18:01:01.769] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.769] Resolved: FALSE
[18:01:01.769] Value: <not collected>
[18:01:01.769] Conditions captured: <none>
[18:01:01.769] Early signaling: FALSE
[18:01:01.769] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.769] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.784] Chunk #1 of 2 ... DONE
[18:01:01.785] Chunk #2 of 2 ...
[18:01:01.785]  - Finding globals in '...' for chunk #2 ...
[18:01:01.786] getGlobalsAndPackages() ...
[18:01:01.786] Searching for globals...
[18:01:01.787] plan(): nbrOfWorkers() = 2
[18:01:01.787] 
[18:01:01.787] Searching for globals ... DONE
[18:01:01.788] - globals: [0] <none>
[18:01:01.788] getGlobalsAndPackages() ... DONE
[18:01:01.788]    + additional globals found: [n=0] 
[18:01:01.788]    + additional namespaces needed: [n=0] 
[18:01:01.789]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:01.789]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:01.789]  - seeds: <none>
[18:01:01.790]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.790] getGlobalsAndPackages() ...
[18:01:01.790] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.791] Resolving globals: FALSE
[18:01:01.792] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:01.794] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:01.795] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.795] 
[18:01:01.795] getGlobalsAndPackages() ... DONE
[18:01:01.796] run() for ‘Future’ ...
[18:01:01.797] - state: ‘created’
[18:01:01.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.807]   - Field: ‘label’
[18:01:01.808]   - Field: ‘local’
[18:01:01.808]   - Field: ‘owner’
[18:01:01.809]   - Field: ‘envir’
[18:01:01.809]   - Field: ‘workers’
[18:01:01.809]   - Field: ‘packages’
[18:01:01.810]   - Field: ‘gc’
[18:01:01.810]   - Field: ‘job’
[18:01:01.810]   - Field: ‘conditions’
[18:01:01.811]   - Field: ‘expr’
[18:01:01.811]   - Field: ‘uuid’
[18:01:01.811]   - Field: ‘seed’
[18:01:01.812]   - Field: ‘version’
[18:01:01.812]   - Field: ‘result’
[18:01:01.812]   - Field: ‘asynchronous’
[18:01:01.813]   - Field: ‘calls’
[18:01:01.813]   - Field: ‘globals’
[18:01:01.813]   - Field: ‘stdout’
[18:01:01.814]   - Field: ‘earlySignal’
[18:01:01.814]   - Field: ‘lazy’
[18:01:01.815]   - Field: ‘state’
[18:01:01.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.821] - Launch lazy future ...
[18:01:01.823] Packages needed by the future expression (n = 0): <none>
[18:01:01.823] Packages needed by future strategies (n = 0): <none>
[18:01:01.826] {
[18:01:01.826]     {
[18:01:01.826]         {
[18:01:01.826]             ...future.startTime <- base::Sys.time()
[18:01:01.826]             {
[18:01:01.826]                 {
[18:01:01.826]                   {
[18:01:01.826]                     {
[18:01:01.826]                       base::local({
[18:01:01.826]                         has_future <- base::requireNamespace("future", 
[18:01:01.826]                           quietly = TRUE)
[18:01:01.826]                         if (has_future) {
[18:01:01.826]                           ns <- base::getNamespace("future")
[18:01:01.826]                           version <- ns[[".package"]][["version"]]
[18:01:01.826]                           if (is.null(version)) 
[18:01:01.826]                             version <- utils::packageVersion("future")
[18:01:01.826]                         }
[18:01:01.826]                         else {
[18:01:01.826]                           version <- NULL
[18:01:01.826]                         }
[18:01:01.826]                         if (!has_future || version < "1.8.0") {
[18:01:01.826]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.826]                             "", base::R.version$version.string), 
[18:01:01.826]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.826]                               "release", "version")], collapse = " "), 
[18:01:01.826]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.826]                             info)
[18:01:01.826]                           info <- base::paste(info, collapse = "; ")
[18:01:01.826]                           if (!has_future) {
[18:01:01.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.826]                               info)
[18:01:01.826]                           }
[18:01:01.826]                           else {
[18:01:01.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.826]                               info, version)
[18:01:01.826]                           }
[18:01:01.826]                           base::stop(msg)
[18:01:01.826]                         }
[18:01:01.826]                       })
[18:01:01.826]                     }
[18:01:01.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.826]                     base::options(mc.cores = 1L)
[18:01:01.826]                   }
[18:01:01.826]                   ...future.strategy.old <- future::plan("list")
[18:01:01.826]                   options(future.plan = NULL)
[18:01:01.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.826]                 }
[18:01:01.826]                 ...future.workdir <- getwd()
[18:01:01.826]             }
[18:01:01.826]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.826]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.826]         }
[18:01:01.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.826]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:01.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.826]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.826]             base::names(...future.oldOptions))
[18:01:01.826]     }
[18:01:01.826]     if (FALSE) {
[18:01:01.826]     }
[18:01:01.826]     else {
[18:01:01.826]         if (TRUE) {
[18:01:01.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.826]                 open = "w")
[18:01:01.826]         }
[18:01:01.826]         else {
[18:01:01.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.826]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.826]         }
[18:01:01.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.826]             base::sink(type = "output", split = FALSE)
[18:01:01.826]             base::close(...future.stdout)
[18:01:01.826]         }, add = TRUE)
[18:01:01.826]     }
[18:01:01.826]     ...future.frame <- base::sys.nframe()
[18:01:01.826]     ...future.conditions <- base::list()
[18:01:01.826]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.826]     if (FALSE) {
[18:01:01.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.826]     }
[18:01:01.826]     ...future.result <- base::tryCatch({
[18:01:01.826]         base::withCallingHandlers({
[18:01:01.826]             ...future.value <- base::withVisible(base::local({
[18:01:01.826]                 withCallingHandlers({
[18:01:01.826]                   {
[18:01:01.826]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.826]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.826]                       ...future.globals.maxSize)) {
[18:01:01.826]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.826]                       on.exit(options(oopts), add = TRUE)
[18:01:01.826]                     }
[18:01:01.826]                     {
[18:01:01.826]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.826]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.826]                         USE.NAMES = FALSE)
[18:01:01.826]                       do.call(mapply, args = args)
[18:01:01.826]                     }
[18:01:01.826]                   }
[18:01:01.826]                 }, immediateCondition = function(cond) {
[18:01:01.826]                   save_rds <- function (object, pathname, ...) 
[18:01:01.826]                   {
[18:01:01.826]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.826]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.826]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.826]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.826]                         fi_tmp[["mtime"]])
[18:01:01.826]                     }
[18:01:01.826]                     tryCatch({
[18:01:01.826]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.826]                     }, error = function(ex) {
[18:01:01.826]                       msg <- conditionMessage(ex)
[18:01:01.826]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.826]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.826]                         fi_tmp[["mtime"]], msg)
[18:01:01.826]                       ex$message <- msg
[18:01:01.826]                       stop(ex)
[18:01:01.826]                     })
[18:01:01.826]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.826]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.826]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.826]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.826]                       fi <- file.info(pathname)
[18:01:01.826]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.826]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.826]                         fi[["size"]], fi[["mtime"]])
[18:01:01.826]                       stop(msg)
[18:01:01.826]                     }
[18:01:01.826]                     invisible(pathname)
[18:01:01.826]                   }
[18:01:01.826]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.826]                     rootPath = tempdir()) 
[18:01:01.826]                   {
[18:01:01.826]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.826]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.826]                       tmpdir = path, fileext = ".rds")
[18:01:01.826]                     save_rds(obj, file)
[18:01:01.826]                   }
[18:01:01.826]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.826]                   {
[18:01:01.826]                     inherits <- base::inherits
[18:01:01.826]                     invokeRestart <- base::invokeRestart
[18:01:01.826]                     is.null <- base::is.null
[18:01:01.826]                     muffled <- FALSE
[18:01:01.826]                     if (inherits(cond, "message")) {
[18:01:01.826]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.826]                       if (muffled) 
[18:01:01.826]                         invokeRestart("muffleMessage")
[18:01:01.826]                     }
[18:01:01.826]                     else if (inherits(cond, "warning")) {
[18:01:01.826]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.826]                       if (muffled) 
[18:01:01.826]                         invokeRestart("muffleWarning")
[18:01:01.826]                     }
[18:01:01.826]                     else if (inherits(cond, "condition")) {
[18:01:01.826]                       if (!is.null(pattern)) {
[18:01:01.826]                         computeRestarts <- base::computeRestarts
[18:01:01.826]                         grepl <- base::grepl
[18:01:01.826]                         restarts <- computeRestarts(cond)
[18:01:01.826]                         for (restart in restarts) {
[18:01:01.826]                           name <- restart$name
[18:01:01.826]                           if (is.null(name)) 
[18:01:01.826]                             next
[18:01:01.826]                           if (!grepl(pattern, name)) 
[18:01:01.826]                             next
[18:01:01.826]                           invokeRestart(restart)
[18:01:01.826]                           muffled <- TRUE
[18:01:01.826]                           break
[18:01:01.826]                         }
[18:01:01.826]                       }
[18:01:01.826]                     }
[18:01:01.826]                     invisible(muffled)
[18:01:01.826]                   }
[18:01:01.826]                   muffleCondition(cond)
[18:01:01.826]                 })
[18:01:01.826]             }))
[18:01:01.826]             future::FutureResult(value = ...future.value$value, 
[18:01:01.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.826]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.826]                     ...future.globalenv.names))
[18:01:01.826]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.826]         }, condition = base::local({
[18:01:01.826]             c <- base::c
[18:01:01.826]             inherits <- base::inherits
[18:01:01.826]             invokeRestart <- base::invokeRestart
[18:01:01.826]             length <- base::length
[18:01:01.826]             list <- base::list
[18:01:01.826]             seq.int <- base::seq.int
[18:01:01.826]             signalCondition <- base::signalCondition
[18:01:01.826]             sys.calls <- base::sys.calls
[18:01:01.826]             `[[` <- base::`[[`
[18:01:01.826]             `+` <- base::`+`
[18:01:01.826]             `<<-` <- base::`<<-`
[18:01:01.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.826]                   3L)]
[18:01:01.826]             }
[18:01:01.826]             function(cond) {
[18:01:01.826]                 is_error <- inherits(cond, "error")
[18:01:01.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.826]                   NULL)
[18:01:01.826]                 if (is_error) {
[18:01:01.826]                   sessionInformation <- function() {
[18:01:01.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.826]                       search = base::search(), system = base::Sys.info())
[18:01:01.826]                   }
[18:01:01.826]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.826]                     cond$call), session = sessionInformation(), 
[18:01:01.826]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.826]                   signalCondition(cond)
[18:01:01.826]                 }
[18:01:01.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.826]                 "immediateCondition"))) {
[18:01:01.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.826]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.826]                   if (TRUE && !signal) {
[18:01:01.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.826]                     {
[18:01:01.826]                       inherits <- base::inherits
[18:01:01.826]                       invokeRestart <- base::invokeRestart
[18:01:01.826]                       is.null <- base::is.null
[18:01:01.826]                       muffled <- FALSE
[18:01:01.826]                       if (inherits(cond, "message")) {
[18:01:01.826]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.826]                         if (muffled) 
[18:01:01.826]                           invokeRestart("muffleMessage")
[18:01:01.826]                       }
[18:01:01.826]                       else if (inherits(cond, "warning")) {
[18:01:01.826]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.826]                         if (muffled) 
[18:01:01.826]                           invokeRestart("muffleWarning")
[18:01:01.826]                       }
[18:01:01.826]                       else if (inherits(cond, "condition")) {
[18:01:01.826]                         if (!is.null(pattern)) {
[18:01:01.826]                           computeRestarts <- base::computeRestarts
[18:01:01.826]                           grepl <- base::grepl
[18:01:01.826]                           restarts <- computeRestarts(cond)
[18:01:01.826]                           for (restart in restarts) {
[18:01:01.826]                             name <- restart$name
[18:01:01.826]                             if (is.null(name)) 
[18:01:01.826]                               next
[18:01:01.826]                             if (!grepl(pattern, name)) 
[18:01:01.826]                               next
[18:01:01.826]                             invokeRestart(restart)
[18:01:01.826]                             muffled <- TRUE
[18:01:01.826]                             break
[18:01:01.826]                           }
[18:01:01.826]                         }
[18:01:01.826]                       }
[18:01:01.826]                       invisible(muffled)
[18:01:01.826]                     }
[18:01:01.826]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.826]                   }
[18:01:01.826]                 }
[18:01:01.826]                 else {
[18:01:01.826]                   if (TRUE) {
[18:01:01.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.826]                     {
[18:01:01.826]                       inherits <- base::inherits
[18:01:01.826]                       invokeRestart <- base::invokeRestart
[18:01:01.826]                       is.null <- base::is.null
[18:01:01.826]                       muffled <- FALSE
[18:01:01.826]                       if (inherits(cond, "message")) {
[18:01:01.826]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.826]                         if (muffled) 
[18:01:01.826]                           invokeRestart("muffleMessage")
[18:01:01.826]                       }
[18:01:01.826]                       else if (inherits(cond, "warning")) {
[18:01:01.826]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.826]                         if (muffled) 
[18:01:01.826]                           invokeRestart("muffleWarning")
[18:01:01.826]                       }
[18:01:01.826]                       else if (inherits(cond, "condition")) {
[18:01:01.826]                         if (!is.null(pattern)) {
[18:01:01.826]                           computeRestarts <- base::computeRestarts
[18:01:01.826]                           grepl <- base::grepl
[18:01:01.826]                           restarts <- computeRestarts(cond)
[18:01:01.826]                           for (restart in restarts) {
[18:01:01.826]                             name <- restart$name
[18:01:01.826]                             if (is.null(name)) 
[18:01:01.826]                               next
[18:01:01.826]                             if (!grepl(pattern, name)) 
[18:01:01.826]                               next
[18:01:01.826]                             invokeRestart(restart)
[18:01:01.826]                             muffled <- TRUE
[18:01:01.826]                             break
[18:01:01.826]                           }
[18:01:01.826]                         }
[18:01:01.826]                       }
[18:01:01.826]                       invisible(muffled)
[18:01:01.826]                     }
[18:01:01.826]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.826]                   }
[18:01:01.826]                 }
[18:01:01.826]             }
[18:01:01.826]         }))
[18:01:01.826]     }, error = function(ex) {
[18:01:01.826]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.826]                 ...future.rng), started = ...future.startTime, 
[18:01:01.826]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.826]             version = "1.8"), class = "FutureResult")
[18:01:01.826]     }, finally = {
[18:01:01.826]         if (!identical(...future.workdir, getwd())) 
[18:01:01.826]             setwd(...future.workdir)
[18:01:01.826]         {
[18:01:01.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.826]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.826]             }
[18:01:01.826]             base::options(...future.oldOptions)
[18:01:01.826]             if (.Platform$OS.type == "windows") {
[18:01:01.826]                 old_names <- names(...future.oldEnvVars)
[18:01:01.826]                 envs <- base::Sys.getenv()
[18:01:01.826]                 names <- names(envs)
[18:01:01.826]                 common <- intersect(names, old_names)
[18:01:01.826]                 added <- setdiff(names, old_names)
[18:01:01.826]                 removed <- setdiff(old_names, names)
[18:01:01.826]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.826]                   envs[common]]
[18:01:01.826]                 NAMES <- toupper(changed)
[18:01:01.826]                 args <- list()
[18:01:01.826]                 for (kk in seq_along(NAMES)) {
[18:01:01.826]                   name <- changed[[kk]]
[18:01:01.826]                   NAME <- NAMES[[kk]]
[18:01:01.826]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.826]                     next
[18:01:01.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.826]                 }
[18:01:01.826]                 NAMES <- toupper(added)
[18:01:01.826]                 for (kk in seq_along(NAMES)) {
[18:01:01.826]                   name <- added[[kk]]
[18:01:01.826]                   NAME <- NAMES[[kk]]
[18:01:01.826]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.826]                     next
[18:01:01.826]                   args[[name]] <- ""
[18:01:01.826]                 }
[18:01:01.826]                 NAMES <- toupper(removed)
[18:01:01.826]                 for (kk in seq_along(NAMES)) {
[18:01:01.826]                   name <- removed[[kk]]
[18:01:01.826]                   NAME <- NAMES[[kk]]
[18:01:01.826]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.826]                     next
[18:01:01.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.826]                 }
[18:01:01.826]                 if (length(args) > 0) 
[18:01:01.826]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.826]             }
[18:01:01.826]             else {
[18:01:01.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.826]             }
[18:01:01.826]             {
[18:01:01.826]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.826]                   0L) {
[18:01:01.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.826]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.826]                   base::options(opts)
[18:01:01.826]                 }
[18:01:01.826]                 {
[18:01:01.826]                   {
[18:01:01.826]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.826]                     NULL
[18:01:01.826]                   }
[18:01:01.826]                   options(future.plan = NULL)
[18:01:01.826]                   if (is.na(NA_character_)) 
[18:01:01.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.826]                     .init = FALSE)
[18:01:01.826]                 }
[18:01:01.826]             }
[18:01:01.826]         }
[18:01:01.826]     })
[18:01:01.826]     if (TRUE) {
[18:01:01.826]         base::sink(type = "output", split = FALSE)
[18:01:01.826]         if (TRUE) {
[18:01:01.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.826]         }
[18:01:01.826]         else {
[18:01:01.826]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.826]         }
[18:01:01.826]         base::close(...future.stdout)
[18:01:01.826]         ...future.stdout <- NULL
[18:01:01.826]     }
[18:01:01.826]     ...future.result$conditions <- ...future.conditions
[18:01:01.826]     ...future.result$finished <- base::Sys.time()
[18:01:01.826]     ...future.result
[18:01:01.826] }
[18:01:01.833] assign_globals() ...
[18:01:01.833] List of 5
[18:01:01.833]  $ ...future.FUN            :function (C, k)  
[18:01:01.833]  $ MoreArgs                 : NULL
[18:01:01.833]  $ ...future.elements_ii    :List of 2
[18:01:01.833]   ..$ :List of 3
[18:01:01.833]   .. ..$ : chr "C"
[18:01:01.833]   .. ..$ : chr "B"
[18:01:01.833]   .. ..$ : chr "A"
[18:01:01.833]   ..$ :List of 3
[18:01:01.833]   .. ..$ : int 3
[18:01:01.833]   .. ..$ : int 4
[18:01:01.833]   .. ..$ : int 5
[18:01:01.833]  $ ...future.seeds_ii       : NULL
[18:01:01.833]  $ ...future.globals.maxSize: NULL
[18:01:01.833]  - attr(*, "where")=List of 5
[18:01:01.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.833]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.833]  - attr(*, "resolved")= logi FALSE
[18:01:01.833]  - attr(*, "total_size")= num 3824
[18:01:01.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.833]  - attr(*, "already-done")= logi TRUE
[18:01:01.856] - reassign environment for ‘...future.FUN’
[18:01:01.856] - copied ‘...future.FUN’ to environment
[18:01:01.856] - copied ‘MoreArgs’ to environment
[18:01:01.857] - copied ‘...future.elements_ii’ to environment
[18:01:01.857] - copied ‘...future.seeds_ii’ to environment
[18:01:01.857] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.858] assign_globals() ... done
[18:01:01.858] requestCore(): workers = 2
[18:01:01.862] MulticoreFuture started
[18:01:01.863] - Launch lazy future ... done
[18:01:01.863] run() for ‘MulticoreFuture’ ... done
[18:01:01.864] Created future:
[18:01:01.864] plan(): Setting new future strategy stack:
[18:01:01.866] List of future strategies:
[18:01:01.866] 1. sequential:
[18:01:01.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.866]    - tweaked: FALSE
[18:01:01.866]    - call: NULL
[18:01:01.870] plan(): nbrOfWorkers() = 1
[18:01:01.875] plan(): Setting new future strategy stack:
[18:01:01.875] List of future strategies:
[18:01:01.875] 1. multicore:
[18:01:01.875]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:01.875]    - tweaked: FALSE
[18:01:01.875]    - call: plan(strategy)
[18:01:01.864] MulticoreFuture:
[18:01:01.864] Label: ‘future_mapply-2’
[18:01:01.864] Expression:
[18:01:01.864] {
[18:01:01.864]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.864]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.864]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.864]         on.exit(options(oopts), add = TRUE)
[18:01:01.864]     }
[18:01:01.864]     {
[18:01:01.864]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.864]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.864]         do.call(mapply, args = args)
[18:01:01.864]     }
[18:01:01.864] }
[18:01:01.864] Lazy evaluation: FALSE
[18:01:01.864] Asynchronous evaluation: TRUE
[18:01:01.864] Local evaluation: TRUE
[18:01:01.864] Environment: R_GlobalEnv
[18:01:01.864] Capture standard output: TRUE
[18:01:01.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.864] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.864] Packages: <none>
[18:01:01.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.864] Resolved: FALSE
[18:01:01.864] Value: <not collected>
[18:01:01.864] Conditions captured: <none>
[18:01:01.864] Early signaling: FALSE
[18:01:01.864] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.864] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.880] Chunk #2 of 2 ... DONE
[18:01:01.880] Launching 2 futures (chunks) ... DONE
[18:01:01.881] Resolving 2 futures (chunks) ...
[18:01:01.881] resolve() on list ...
[18:01:01.882]  recursive: 0
[18:01:01.882]  length: 2
[18:01:01.882] 
[18:01:01.883] Future #1
[18:01:01.883] result() for MulticoreFuture ...
[18:01:01.887] result() for MulticoreFuture ...
[18:01:01.890] result() for MulticoreFuture ... done
[18:01:01.890] result() for MulticoreFuture ... done
[18:01:01.891] result() for MulticoreFuture ...
[18:01:01.891] result() for MulticoreFuture ... done
[18:01:01.891] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:01.889] plan(): nbrOfWorkers() = 2
[18:01:01.892] - nx: 2
[18:01:01.893] - relay: TRUE
[18:01:01.893] - stdout: TRUE
[18:01:01.893] - signal: TRUE
[18:01:01.893] - resignal: FALSE
[18:01:01.894] - force: TRUE
[18:01:01.894] - relayed: [n=2] FALSE, FALSE
[18:01:01.894] - queued futures: [n=2] FALSE, FALSE
[18:01:01.895]  - until=1
[18:01:01.895]  - relaying element #1
[18:01:01.896] result() for MulticoreFuture ...
[18:01:01.896] result() for MulticoreFuture ... done
[18:01:01.896] result() for MulticoreFuture ...
[18:01:01.897] result() for MulticoreFuture ... done
[18:01:01.897] result() for MulticoreFuture ...
[18:01:01.897] result() for MulticoreFuture ... done
[18:01:01.898] result() for MulticoreFuture ...
[18:01:01.898] result() for MulticoreFuture ... done
[18:01:01.898] - relayed: [n=2] TRUE, FALSE
[18:01:01.899] - queued futures: [n=2] TRUE, FALSE
[18:01:01.899] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:01.899]  length: 1 (resolved future 1)
[18:01:01.900] Future #2
[18:01:01.900] result() for MulticoreFuture ...
[18:01:01.902] result() for MulticoreFuture ...
[18:01:01.903] result() for MulticoreFuture ... done
[18:01:01.903] result() for MulticoreFuture ... done
[18:01:01.903] result() for MulticoreFuture ...
[18:01:01.904] result() for MulticoreFuture ... done
[18:01:01.905] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:01.906] - nx: 2
[18:01:01.906] - relay: TRUE
[18:01:01.906] - stdout: TRUE
[18:01:01.907] - signal: TRUE
[18:01:01.907] - resignal: FALSE
[18:01:01.907] - force: TRUE
[18:01:01.907] - relayed: [n=2] TRUE, FALSE
[18:01:01.907] - queued futures: [n=2] TRUE, FALSE
[18:01:01.908]  - until=2
[18:01:01.908]  - relaying element #2
[18:01:01.908] result() for MulticoreFuture ...
[18:01:01.908] result() for MulticoreFuture ... done
[18:01:01.909] result() for MulticoreFuture ...
[18:01:01.909] result() for MulticoreFuture ... done
[18:01:01.909] result() for MulticoreFuture ...
[18:01:01.910] result() for MulticoreFuture ... done
[18:01:01.910] result() for MulticoreFuture ...
[18:01:01.910] result() for MulticoreFuture ... done
[18:01:01.910] - relayed: [n=2] TRUE, TRUE
[18:01:01.910] - queued futures: [n=2] TRUE, TRUE
[18:01:01.911] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:01.911]  length: 0 (resolved future 2)
[18:01:01.911] Relaying remaining futures
[18:01:01.911] signalConditionsASAP(NULL, pos=0) ...
[18:01:01.912] - nx: 2
[18:01:01.912] - relay: TRUE
[18:01:01.912] - stdout: TRUE
[18:01:01.912] - signal: TRUE
[18:01:01.912] - resignal: FALSE
[18:01:01.913] - force: TRUE
[18:01:01.913] - relayed: [n=2] TRUE, TRUE
[18:01:01.913] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:01.914] - relayed: [n=2] TRUE, TRUE
[18:01:01.914] - queued futures: [n=2] TRUE, TRUE
[18:01:01.914] signalConditionsASAP(NULL, pos=0) ... done
[18:01:01.914] resolve() on list ... DONE
[18:01:01.915] result() for MulticoreFuture ...
[18:01:01.915] result() for MulticoreFuture ... done
[18:01:01.915] result() for MulticoreFuture ...
[18:01:01.915] result() for MulticoreFuture ... done
[18:01:01.916] result() for MulticoreFuture ...
[18:01:01.920] result() for MulticoreFuture ... done
[18:01:01.920] result() for MulticoreFuture ...
[18:01:01.920] result() for MulticoreFuture ... done
[18:01:01.921]  - Number of value chunks collected: 2
[18:01:01.921] Resolving 2 futures (chunks) ... DONE
[18:01:01.921] Reducing values from 2 chunks ...
[18:01:01.922]  - Number of values collected after concatenation: 5
[18:01:01.922]  - Number of values expected: 5
[18:01:01.922] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[18:01:01.923] Reducing values from 2 chunks ... DONE
[18:01:01.923] future_mapply() ... DONE
[18:01:01.924] future_mapply() ...
[18:01:01.931] Number of chunks: 2
[18:01:01.931] getGlobalsAndPackagesXApply() ...
[18:01:01.932]  - future.globals: TRUE
[18:01:01.932] getGlobalsAndPackages() ...
[18:01:01.932] Searching for globals...
[18:01:01.936] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:01.936] Searching for globals ... DONE
[18:01:01.936] Resolving globals: FALSE
[18:01:01.937] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:01.938] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:01.938] - globals: [1] ‘FUN’
[18:01:01.938] 
[18:01:01.938] getGlobalsAndPackages() ... DONE
[18:01:01.939]  - globals found/used: [n=1] ‘FUN’
[18:01:01.939]  - needed namespaces: [n=0] 
[18:01:01.939] Finding globals ... DONE
[18:01:01.939] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:01.940] List of 2
[18:01:01.940]  $ ...future.FUN:function (C, k)  
[18:01:01.940]  $ MoreArgs     : list()
[18:01:01.940]  - attr(*, "where")=List of 2
[18:01:01.940]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:01.940]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:01.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.940]  - attr(*, "resolved")= logi FALSE
[18:01:01.940]  - attr(*, "total_size")= num NA
[18:01:01.945] Packages to be attached in all futures: [n=0] 
[18:01:01.946] getGlobalsAndPackagesXApply() ... DONE
[18:01:01.946] Number of futures (= number of chunks): 2
[18:01:01.946] Launching 2 futures (chunks) ...
[18:01:01.947] Chunk #1 of 2 ...
[18:01:01.947]  - Finding globals in '...' for chunk #1 ...
[18:01:01.947] getGlobalsAndPackages() ...
[18:01:01.947] Searching for globals...
[18:01:01.948] 
[18:01:01.948] Searching for globals ... DONE
[18:01:01.948] - globals: [0] <none>
[18:01:01.948] getGlobalsAndPackages() ... DONE
[18:01:01.949]    + additional globals found: [n=0] 
[18:01:01.949]    + additional namespaces needed: [n=0] 
[18:01:01.949]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:01.949]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:01.949]  - seeds: <none>
[18:01:01.950]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.950] getGlobalsAndPackages() ...
[18:01:01.950] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.950] Resolving globals: FALSE
[18:01:01.951] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:01.952] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:01.952] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:01.953] 
[18:01:01.953] getGlobalsAndPackages() ... DONE
[18:01:01.954] run() for ‘Future’ ...
[18:01:01.954] - state: ‘created’
[18:01:01.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:01.960] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:01.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:01.961]   - Field: ‘label’
[18:01:01.961]   - Field: ‘local’
[18:01:01.961]   - Field: ‘owner’
[18:01:01.962]   - Field: ‘envir’
[18:01:01.962]   - Field: ‘workers’
[18:01:01.962]   - Field: ‘packages’
[18:01:01.962]   - Field: ‘gc’
[18:01:01.962]   - Field: ‘job’
[18:01:01.963]   - Field: ‘conditions’
[18:01:01.963]   - Field: ‘expr’
[18:01:01.963]   - Field: ‘uuid’
[18:01:01.963]   - Field: ‘seed’
[18:01:01.964]   - Field: ‘version’
[18:01:01.964]   - Field: ‘result’
[18:01:01.964]   - Field: ‘asynchronous’
[18:01:01.964]   - Field: ‘calls’
[18:01:01.964]   - Field: ‘globals’
[18:01:01.965]   - Field: ‘stdout’
[18:01:01.965]   - Field: ‘earlySignal’
[18:01:01.965]   - Field: ‘lazy’
[18:01:01.965]   - Field: ‘state’
[18:01:01.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:01.966] - Launch lazy future ...
[18:01:01.966] Packages needed by the future expression (n = 0): <none>
[18:01:01.966] Packages needed by future strategies (n = 0): <none>
[18:01:01.967] {
[18:01:01.967]     {
[18:01:01.967]         {
[18:01:01.967]             ...future.startTime <- base::Sys.time()
[18:01:01.967]             {
[18:01:01.967]                 {
[18:01:01.967]                   {
[18:01:01.967]                     {
[18:01:01.967]                       base::local({
[18:01:01.967]                         has_future <- base::requireNamespace("future", 
[18:01:01.967]                           quietly = TRUE)
[18:01:01.967]                         if (has_future) {
[18:01:01.967]                           ns <- base::getNamespace("future")
[18:01:01.967]                           version <- ns[[".package"]][["version"]]
[18:01:01.967]                           if (is.null(version)) 
[18:01:01.967]                             version <- utils::packageVersion("future")
[18:01:01.967]                         }
[18:01:01.967]                         else {
[18:01:01.967]                           version <- NULL
[18:01:01.967]                         }
[18:01:01.967]                         if (!has_future || version < "1.8.0") {
[18:01:01.967]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:01.967]                             "", base::R.version$version.string), 
[18:01:01.967]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:01.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:01.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:01.967]                               "release", "version")], collapse = " "), 
[18:01:01.967]                             hostname = base::Sys.info()[["nodename"]])
[18:01:01.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:01.967]                             info)
[18:01:01.967]                           info <- base::paste(info, collapse = "; ")
[18:01:01.967]                           if (!has_future) {
[18:01:01.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:01.967]                               info)
[18:01:01.967]                           }
[18:01:01.967]                           else {
[18:01:01.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:01.967]                               info, version)
[18:01:01.967]                           }
[18:01:01.967]                           base::stop(msg)
[18:01:01.967]                         }
[18:01:01.967]                       })
[18:01:01.967]                     }
[18:01:01.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:01.967]                     base::options(mc.cores = 1L)
[18:01:01.967]                   }
[18:01:01.967]                   ...future.strategy.old <- future::plan("list")
[18:01:01.967]                   options(future.plan = NULL)
[18:01:01.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:01.967]                 }
[18:01:01.967]                 ...future.workdir <- getwd()
[18:01:01.967]             }
[18:01:01.967]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:01.967]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:01.967]         }
[18:01:01.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:01.967]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:01.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:01.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:01.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:01.967]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:01.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:01.967]             base::names(...future.oldOptions))
[18:01:01.967]     }
[18:01:01.967]     if (FALSE) {
[18:01:01.967]     }
[18:01:01.967]     else {
[18:01:01.967]         if (TRUE) {
[18:01:01.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:01.967]                 open = "w")
[18:01:01.967]         }
[18:01:01.967]         else {
[18:01:01.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:01.967]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:01.967]         }
[18:01:01.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:01.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:01.967]             base::sink(type = "output", split = FALSE)
[18:01:01.967]             base::close(...future.stdout)
[18:01:01.967]         }, add = TRUE)
[18:01:01.967]     }
[18:01:01.967]     ...future.frame <- base::sys.nframe()
[18:01:01.967]     ...future.conditions <- base::list()
[18:01:01.967]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:01.967]     if (FALSE) {
[18:01:01.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:01.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:01.967]     }
[18:01:01.967]     ...future.result <- base::tryCatch({
[18:01:01.967]         base::withCallingHandlers({
[18:01:01.967]             ...future.value <- base::withVisible(base::local({
[18:01:01.967]                 withCallingHandlers({
[18:01:01.967]                   {
[18:01:01.967]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.967]                     if (!identical(...future.globals.maxSize.org, 
[18:01:01.967]                       ...future.globals.maxSize)) {
[18:01:01.967]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.967]                       on.exit(options(oopts), add = TRUE)
[18:01:01.967]                     }
[18:01:01.967]                     {
[18:01:01.967]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.967]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:01.967]                         USE.NAMES = FALSE)
[18:01:01.967]                       do.call(mapply, args = args)
[18:01:01.967]                     }
[18:01:01.967]                   }
[18:01:01.967]                 }, immediateCondition = function(cond) {
[18:01:01.967]                   save_rds <- function (object, pathname, ...) 
[18:01:01.967]                   {
[18:01:01.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:01.967]                     if (file_test("-f", pathname_tmp)) {
[18:01:01.967]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:01.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.967]                         fi_tmp[["mtime"]])
[18:01:01.967]                     }
[18:01:01.967]                     tryCatch({
[18:01:01.967]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:01.967]                     }, error = function(ex) {
[18:01:01.967]                       msg <- conditionMessage(ex)
[18:01:01.967]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:01.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.967]                         fi_tmp[["mtime"]], msg)
[18:01:01.967]                       ex$message <- msg
[18:01:01.967]                       stop(ex)
[18:01:01.967]                     })
[18:01:01.967]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:01.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:01.967]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:01.967]                       fi_tmp <- file.info(pathname_tmp)
[18:01:01.967]                       fi <- file.info(pathname)
[18:01:01.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:01.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:01.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:01.967]                         fi[["size"]], fi[["mtime"]])
[18:01:01.967]                       stop(msg)
[18:01:01.967]                     }
[18:01:01.967]                     invisible(pathname)
[18:01:01.967]                   }
[18:01:01.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:01.967]                     rootPath = tempdir()) 
[18:01:01.967]                   {
[18:01:01.967]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:01.967]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:01.967]                       tmpdir = path, fileext = ".rds")
[18:01:01.967]                     save_rds(obj, file)
[18:01:01.967]                   }
[18:01:01.967]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:01.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.967]                   {
[18:01:01.967]                     inherits <- base::inherits
[18:01:01.967]                     invokeRestart <- base::invokeRestart
[18:01:01.967]                     is.null <- base::is.null
[18:01:01.967]                     muffled <- FALSE
[18:01:01.967]                     if (inherits(cond, "message")) {
[18:01:01.967]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:01.967]                       if (muffled) 
[18:01:01.967]                         invokeRestart("muffleMessage")
[18:01:01.967]                     }
[18:01:01.967]                     else if (inherits(cond, "warning")) {
[18:01:01.967]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:01.967]                       if (muffled) 
[18:01:01.967]                         invokeRestart("muffleWarning")
[18:01:01.967]                     }
[18:01:01.967]                     else if (inherits(cond, "condition")) {
[18:01:01.967]                       if (!is.null(pattern)) {
[18:01:01.967]                         computeRestarts <- base::computeRestarts
[18:01:01.967]                         grepl <- base::grepl
[18:01:01.967]                         restarts <- computeRestarts(cond)
[18:01:01.967]                         for (restart in restarts) {
[18:01:01.967]                           name <- restart$name
[18:01:01.967]                           if (is.null(name)) 
[18:01:01.967]                             next
[18:01:01.967]                           if (!grepl(pattern, name)) 
[18:01:01.967]                             next
[18:01:01.967]                           invokeRestart(restart)
[18:01:01.967]                           muffled <- TRUE
[18:01:01.967]                           break
[18:01:01.967]                         }
[18:01:01.967]                       }
[18:01:01.967]                     }
[18:01:01.967]                     invisible(muffled)
[18:01:01.967]                   }
[18:01:01.967]                   muffleCondition(cond)
[18:01:01.967]                 })
[18:01:01.967]             }))
[18:01:01.967]             future::FutureResult(value = ...future.value$value, 
[18:01:01.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.967]                   ...future.rng), globalenv = if (FALSE) 
[18:01:01.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:01.967]                     ...future.globalenv.names))
[18:01:01.967]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:01.967]         }, condition = base::local({
[18:01:01.967]             c <- base::c
[18:01:01.967]             inherits <- base::inherits
[18:01:01.967]             invokeRestart <- base::invokeRestart
[18:01:01.967]             length <- base::length
[18:01:01.967]             list <- base::list
[18:01:01.967]             seq.int <- base::seq.int
[18:01:01.967]             signalCondition <- base::signalCondition
[18:01:01.967]             sys.calls <- base::sys.calls
[18:01:01.967]             `[[` <- base::`[[`
[18:01:01.967]             `+` <- base::`+`
[18:01:01.967]             `<<-` <- base::`<<-`
[18:01:01.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:01.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:01.967]                   3L)]
[18:01:01.967]             }
[18:01:01.967]             function(cond) {
[18:01:01.967]                 is_error <- inherits(cond, "error")
[18:01:01.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:01.967]                   NULL)
[18:01:01.967]                 if (is_error) {
[18:01:01.967]                   sessionInformation <- function() {
[18:01:01.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:01.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:01.967]                       search = base::search(), system = base::Sys.info())
[18:01:01.967]                   }
[18:01:01.967]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:01.967]                     cond$call), session = sessionInformation(), 
[18:01:01.967]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:01.967]                   signalCondition(cond)
[18:01:01.967]                 }
[18:01:01.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:01.967]                 "immediateCondition"))) {
[18:01:01.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:01.967]                   ...future.conditions[[length(...future.conditions) + 
[18:01:01.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:01.967]                   if (TRUE && !signal) {
[18:01:01.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.967]                     {
[18:01:01.967]                       inherits <- base::inherits
[18:01:01.967]                       invokeRestart <- base::invokeRestart
[18:01:01.967]                       is.null <- base::is.null
[18:01:01.967]                       muffled <- FALSE
[18:01:01.967]                       if (inherits(cond, "message")) {
[18:01:01.967]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.967]                         if (muffled) 
[18:01:01.967]                           invokeRestart("muffleMessage")
[18:01:01.967]                       }
[18:01:01.967]                       else if (inherits(cond, "warning")) {
[18:01:01.967]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.967]                         if (muffled) 
[18:01:01.967]                           invokeRestart("muffleWarning")
[18:01:01.967]                       }
[18:01:01.967]                       else if (inherits(cond, "condition")) {
[18:01:01.967]                         if (!is.null(pattern)) {
[18:01:01.967]                           computeRestarts <- base::computeRestarts
[18:01:01.967]                           grepl <- base::grepl
[18:01:01.967]                           restarts <- computeRestarts(cond)
[18:01:01.967]                           for (restart in restarts) {
[18:01:01.967]                             name <- restart$name
[18:01:01.967]                             if (is.null(name)) 
[18:01:01.967]                               next
[18:01:01.967]                             if (!grepl(pattern, name)) 
[18:01:01.967]                               next
[18:01:01.967]                             invokeRestart(restart)
[18:01:01.967]                             muffled <- TRUE
[18:01:01.967]                             break
[18:01:01.967]                           }
[18:01:01.967]                         }
[18:01:01.967]                       }
[18:01:01.967]                       invisible(muffled)
[18:01:01.967]                     }
[18:01:01.967]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.967]                   }
[18:01:01.967]                 }
[18:01:01.967]                 else {
[18:01:01.967]                   if (TRUE) {
[18:01:01.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:01.967]                     {
[18:01:01.967]                       inherits <- base::inherits
[18:01:01.967]                       invokeRestart <- base::invokeRestart
[18:01:01.967]                       is.null <- base::is.null
[18:01:01.967]                       muffled <- FALSE
[18:01:01.967]                       if (inherits(cond, "message")) {
[18:01:01.967]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:01.967]                         if (muffled) 
[18:01:01.967]                           invokeRestart("muffleMessage")
[18:01:01.967]                       }
[18:01:01.967]                       else if (inherits(cond, "warning")) {
[18:01:01.967]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:01.967]                         if (muffled) 
[18:01:01.967]                           invokeRestart("muffleWarning")
[18:01:01.967]                       }
[18:01:01.967]                       else if (inherits(cond, "condition")) {
[18:01:01.967]                         if (!is.null(pattern)) {
[18:01:01.967]                           computeRestarts <- base::computeRestarts
[18:01:01.967]                           grepl <- base::grepl
[18:01:01.967]                           restarts <- computeRestarts(cond)
[18:01:01.967]                           for (restart in restarts) {
[18:01:01.967]                             name <- restart$name
[18:01:01.967]                             if (is.null(name)) 
[18:01:01.967]                               next
[18:01:01.967]                             if (!grepl(pattern, name)) 
[18:01:01.967]                               next
[18:01:01.967]                             invokeRestart(restart)
[18:01:01.967]                             muffled <- TRUE
[18:01:01.967]                             break
[18:01:01.967]                           }
[18:01:01.967]                         }
[18:01:01.967]                       }
[18:01:01.967]                       invisible(muffled)
[18:01:01.967]                     }
[18:01:01.967]                     muffleCondition(cond, pattern = "^muffle")
[18:01:01.967]                   }
[18:01:01.967]                 }
[18:01:01.967]             }
[18:01:01.967]         }))
[18:01:01.967]     }, error = function(ex) {
[18:01:01.967]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:01.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:01.967]                 ...future.rng), started = ...future.startTime, 
[18:01:01.967]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:01.967]             version = "1.8"), class = "FutureResult")
[18:01:01.967]     }, finally = {
[18:01:01.967]         if (!identical(...future.workdir, getwd())) 
[18:01:01.967]             setwd(...future.workdir)
[18:01:01.967]         {
[18:01:01.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:01.967]                 ...future.oldOptions$nwarnings <- NULL
[18:01:01.967]             }
[18:01:01.967]             base::options(...future.oldOptions)
[18:01:01.967]             if (.Platform$OS.type == "windows") {
[18:01:01.967]                 old_names <- names(...future.oldEnvVars)
[18:01:01.967]                 envs <- base::Sys.getenv()
[18:01:01.967]                 names <- names(envs)
[18:01:01.967]                 common <- intersect(names, old_names)
[18:01:01.967]                 added <- setdiff(names, old_names)
[18:01:01.967]                 removed <- setdiff(old_names, names)
[18:01:01.967]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:01.967]                   envs[common]]
[18:01:01.967]                 NAMES <- toupper(changed)
[18:01:01.967]                 args <- list()
[18:01:01.967]                 for (kk in seq_along(NAMES)) {
[18:01:01.967]                   name <- changed[[kk]]
[18:01:01.967]                   NAME <- NAMES[[kk]]
[18:01:01.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.967]                     next
[18:01:01.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.967]                 }
[18:01:01.967]                 NAMES <- toupper(added)
[18:01:01.967]                 for (kk in seq_along(NAMES)) {
[18:01:01.967]                   name <- added[[kk]]
[18:01:01.967]                   NAME <- NAMES[[kk]]
[18:01:01.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.967]                     next
[18:01:01.967]                   args[[name]] <- ""
[18:01:01.967]                 }
[18:01:01.967]                 NAMES <- toupper(removed)
[18:01:01.967]                 for (kk in seq_along(NAMES)) {
[18:01:01.967]                   name <- removed[[kk]]
[18:01:01.967]                   NAME <- NAMES[[kk]]
[18:01:01.967]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:01.967]                     next
[18:01:01.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:01.967]                 }
[18:01:01.967]                 if (length(args) > 0) 
[18:01:01.967]                   base::do.call(base::Sys.setenv, args = args)
[18:01:01.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:01.967]             }
[18:01:01.967]             else {
[18:01:01.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:01.967]             }
[18:01:01.967]             {
[18:01:01.967]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:01.967]                   0L) {
[18:01:01.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:01.967]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:01.967]                   base::options(opts)
[18:01:01.967]                 }
[18:01:01.967]                 {
[18:01:01.967]                   {
[18:01:01.967]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:01.967]                     NULL
[18:01:01.967]                   }
[18:01:01.967]                   options(future.plan = NULL)
[18:01:01.967]                   if (is.na(NA_character_)) 
[18:01:01.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:01.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:01.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:01.967]                     .init = FALSE)
[18:01:01.967]                 }
[18:01:01.967]             }
[18:01:01.967]         }
[18:01:01.967]     })
[18:01:01.967]     if (TRUE) {
[18:01:01.967]         base::sink(type = "output", split = FALSE)
[18:01:01.967]         if (TRUE) {
[18:01:01.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:01.967]         }
[18:01:01.967]         else {
[18:01:01.967]             ...future.result["stdout"] <- base::list(NULL)
[18:01:01.967]         }
[18:01:01.967]         base::close(...future.stdout)
[18:01:01.967]         ...future.stdout <- NULL
[18:01:01.967]     }
[18:01:01.967]     ...future.result$conditions <- ...future.conditions
[18:01:01.967]     ...future.result$finished <- base::Sys.time()
[18:01:01.967]     ...future.result
[18:01:01.967] }
[18:01:01.972] assign_globals() ...
[18:01:01.973] List of 5
[18:01:01.973]  $ ...future.FUN            :function (C, k)  
[18:01:01.973]  $ MoreArgs                 : list()
[18:01:01.973]  $ ...future.elements_ii    :List of 2
[18:01:01.973]   ..$ :List of 2
[18:01:01.973]   .. ..$ : chr "A"
[18:01:01.973]   .. ..$ : chr "B"
[18:01:01.973]   ..$ :List of 2
[18:01:01.973]   .. ..$ : int 5
[18:01:01.973]   .. ..$ : int 4
[18:01:01.973]  $ ...future.seeds_ii       : NULL
[18:01:01.973]  $ ...future.globals.maxSize: NULL
[18:01:01.973]  - attr(*, "where")=List of 5
[18:01:01.973]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:01.973]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:01.973]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:01.973]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:01.973]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:01.973]  - attr(*, "resolved")= logi FALSE
[18:01:01.973]  - attr(*, "total_size")= num 3656
[18:01:01.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:01.973]  - attr(*, "already-done")= logi TRUE
[18:01:01.988] - reassign environment for ‘...future.FUN’
[18:01:01.988] - copied ‘...future.FUN’ to environment
[18:01:01.988] - copied ‘MoreArgs’ to environment
[18:01:01.988] - copied ‘...future.elements_ii’ to environment
[18:01:01.989] - copied ‘...future.seeds_ii’ to environment
[18:01:01.989] - copied ‘...future.globals.maxSize’ to environment
[18:01:01.989] assign_globals() ... done
[18:01:01.989] requestCore(): workers = 2
[18:01:01.993] MulticoreFuture started
[18:01:01.994] - Launch lazy future ... done
[18:01:01.995] run() for ‘MulticoreFuture’ ... done
[18:01:01.995] plan(): Setting new future strategy stack:
[18:01:01.996] Created future:
[18:01:01.996] List of future strategies:
[18:01:01.996] 1. sequential:
[18:01:01.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:01.996]    - tweaked: FALSE
[18:01:01.996]    - call: NULL
[18:01:01.998] plan(): nbrOfWorkers() = 1
[18:01:02.003] plan(): Setting new future strategy stack:
[18:01:02.004] List of future strategies:
[18:01:02.004] 1. multicore:
[18:01:02.004]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.004]    - tweaked: FALSE
[18:01:02.004]    - call: plan(strategy)
[18:01:01.996] MulticoreFuture:
[18:01:01.996] Label: ‘future_.mapply-1’
[18:01:01.996] Expression:
[18:01:01.996] {
[18:01:01.996]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:01.996]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:01.996]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:01.996]         on.exit(options(oopts), add = TRUE)
[18:01:01.996]     }
[18:01:01.996]     {
[18:01:01.996]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:01.996]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:01.996]         do.call(mapply, args = args)
[18:01:01.996]     }
[18:01:01.996] }
[18:01:01.996] Lazy evaluation: FALSE
[18:01:01.996] Asynchronous evaluation: TRUE
[18:01:01.996] Local evaluation: TRUE
[18:01:01.996] Environment: R_GlobalEnv
[18:01:01.996] Capture standard output: TRUE
[18:01:01.996] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:01.996] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:01.996] Packages: <none>
[18:01:01.996] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:01.996] Resolved: FALSE
[18:01:01.996] Value: <not collected>
[18:01:01.996] Conditions captured: <none>
[18:01:01.996] Early signaling: FALSE
[18:01:01.996] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:01.996] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.012] Chunk #1 of 2 ... DONE
[18:01:02.012] Chunk #2 of 2 ...
[18:01:02.013]  - Finding globals in '...' for chunk #2 ...
[18:01:02.013] getGlobalsAndPackages() ...
[18:01:02.013] Searching for globals...
[18:01:02.014] plan(): nbrOfWorkers() = 2
[18:01:02.014] 
[18:01:02.015] Searching for globals ... DONE
[18:01:02.015] - globals: [0] <none>
[18:01:02.015] getGlobalsAndPackages() ... DONE
[18:01:02.016]    + additional globals found: [n=0] 
[18:01:02.016]    + additional namespaces needed: [n=0] 
[18:01:02.016]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:02.017]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.017]  - seeds: <none>
[18:01:02.017]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.018] getGlobalsAndPackages() ...
[18:01:02.018] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.018] Resolving globals: FALSE
[18:01:02.020] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:02.022] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:02.023] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.023] 
[18:01:02.023] getGlobalsAndPackages() ... DONE
[18:01:02.024] run() for ‘Future’ ...
[18:01:02.025] - state: ‘created’
[18:01:02.025] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.033] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.034] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.034]   - Field: ‘label’
[18:01:02.034]   - Field: ‘local’
[18:01:02.035]   - Field: ‘owner’
[18:01:02.035]   - Field: ‘envir’
[18:01:02.035]   - Field: ‘workers’
[18:01:02.036]   - Field: ‘packages’
[18:01:02.036]   - Field: ‘gc’
[18:01:02.036]   - Field: ‘job’
[18:01:02.037]   - Field: ‘conditions’
[18:01:02.037]   - Field: ‘expr’
[18:01:02.037]   - Field: ‘uuid’
[18:01:02.037]   - Field: ‘seed’
[18:01:02.038]   - Field: ‘version’
[18:01:02.038]   - Field: ‘result’
[18:01:02.038]   - Field: ‘asynchronous’
[18:01:02.039]   - Field: ‘calls’
[18:01:02.039]   - Field: ‘globals’
[18:01:02.039]   - Field: ‘stdout’
[18:01:02.040]   - Field: ‘earlySignal’
[18:01:02.040]   - Field: ‘lazy’
[18:01:02.040]   - Field: ‘state’
[18:01:02.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.041] - Launch lazy future ...
[18:01:02.042] Packages needed by the future expression (n = 0): <none>
[18:01:02.042] Packages needed by future strategies (n = 0): <none>
[18:01:02.043] {
[18:01:02.043]     {
[18:01:02.043]         {
[18:01:02.043]             ...future.startTime <- base::Sys.time()
[18:01:02.043]             {
[18:01:02.043]                 {
[18:01:02.043]                   {
[18:01:02.043]                     {
[18:01:02.043]                       base::local({
[18:01:02.043]                         has_future <- base::requireNamespace("future", 
[18:01:02.043]                           quietly = TRUE)
[18:01:02.043]                         if (has_future) {
[18:01:02.043]                           ns <- base::getNamespace("future")
[18:01:02.043]                           version <- ns[[".package"]][["version"]]
[18:01:02.043]                           if (is.null(version)) 
[18:01:02.043]                             version <- utils::packageVersion("future")
[18:01:02.043]                         }
[18:01:02.043]                         else {
[18:01:02.043]                           version <- NULL
[18:01:02.043]                         }
[18:01:02.043]                         if (!has_future || version < "1.8.0") {
[18:01:02.043]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.043]                             "", base::R.version$version.string), 
[18:01:02.043]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.043]                               "release", "version")], collapse = " "), 
[18:01:02.043]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.043]                             info)
[18:01:02.043]                           info <- base::paste(info, collapse = "; ")
[18:01:02.043]                           if (!has_future) {
[18:01:02.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.043]                               info)
[18:01:02.043]                           }
[18:01:02.043]                           else {
[18:01:02.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.043]                               info, version)
[18:01:02.043]                           }
[18:01:02.043]                           base::stop(msg)
[18:01:02.043]                         }
[18:01:02.043]                       })
[18:01:02.043]                     }
[18:01:02.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.043]                     base::options(mc.cores = 1L)
[18:01:02.043]                   }
[18:01:02.043]                   ...future.strategy.old <- future::plan("list")
[18:01:02.043]                   options(future.plan = NULL)
[18:01:02.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.043]                 }
[18:01:02.043]                 ...future.workdir <- getwd()
[18:01:02.043]             }
[18:01:02.043]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.043]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.043]         }
[18:01:02.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.043]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.043]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.043]             base::names(...future.oldOptions))
[18:01:02.043]     }
[18:01:02.043]     if (FALSE) {
[18:01:02.043]     }
[18:01:02.043]     else {
[18:01:02.043]         if (TRUE) {
[18:01:02.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.043]                 open = "w")
[18:01:02.043]         }
[18:01:02.043]         else {
[18:01:02.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.043]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.043]         }
[18:01:02.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.043]             base::sink(type = "output", split = FALSE)
[18:01:02.043]             base::close(...future.stdout)
[18:01:02.043]         }, add = TRUE)
[18:01:02.043]     }
[18:01:02.043]     ...future.frame <- base::sys.nframe()
[18:01:02.043]     ...future.conditions <- base::list()
[18:01:02.043]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.043]     if (FALSE) {
[18:01:02.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.043]     }
[18:01:02.043]     ...future.result <- base::tryCatch({
[18:01:02.043]         base::withCallingHandlers({
[18:01:02.043]             ...future.value <- base::withVisible(base::local({
[18:01:02.043]                 withCallingHandlers({
[18:01:02.043]                   {
[18:01:02.043]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.043]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.043]                       ...future.globals.maxSize)) {
[18:01:02.043]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.043]                       on.exit(options(oopts), add = TRUE)
[18:01:02.043]                     }
[18:01:02.043]                     {
[18:01:02.043]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.043]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.043]                         USE.NAMES = FALSE)
[18:01:02.043]                       do.call(mapply, args = args)
[18:01:02.043]                     }
[18:01:02.043]                   }
[18:01:02.043]                 }, immediateCondition = function(cond) {
[18:01:02.043]                   save_rds <- function (object, pathname, ...) 
[18:01:02.043]                   {
[18:01:02.043]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.043]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.043]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.043]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.043]                         fi_tmp[["mtime"]])
[18:01:02.043]                     }
[18:01:02.043]                     tryCatch({
[18:01:02.043]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.043]                     }, error = function(ex) {
[18:01:02.043]                       msg <- conditionMessage(ex)
[18:01:02.043]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.043]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.043]                         fi_tmp[["mtime"]], msg)
[18:01:02.043]                       ex$message <- msg
[18:01:02.043]                       stop(ex)
[18:01:02.043]                     })
[18:01:02.043]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.043]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.043]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.043]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.043]                       fi <- file.info(pathname)
[18:01:02.043]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.043]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.043]                         fi[["size"]], fi[["mtime"]])
[18:01:02.043]                       stop(msg)
[18:01:02.043]                     }
[18:01:02.043]                     invisible(pathname)
[18:01:02.043]                   }
[18:01:02.043]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.043]                     rootPath = tempdir()) 
[18:01:02.043]                   {
[18:01:02.043]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.043]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.043]                       tmpdir = path, fileext = ".rds")
[18:01:02.043]                     save_rds(obj, file)
[18:01:02.043]                   }
[18:01:02.043]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.043]                   {
[18:01:02.043]                     inherits <- base::inherits
[18:01:02.043]                     invokeRestart <- base::invokeRestart
[18:01:02.043]                     is.null <- base::is.null
[18:01:02.043]                     muffled <- FALSE
[18:01:02.043]                     if (inherits(cond, "message")) {
[18:01:02.043]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.043]                       if (muffled) 
[18:01:02.043]                         invokeRestart("muffleMessage")
[18:01:02.043]                     }
[18:01:02.043]                     else if (inherits(cond, "warning")) {
[18:01:02.043]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.043]                       if (muffled) 
[18:01:02.043]                         invokeRestart("muffleWarning")
[18:01:02.043]                     }
[18:01:02.043]                     else if (inherits(cond, "condition")) {
[18:01:02.043]                       if (!is.null(pattern)) {
[18:01:02.043]                         computeRestarts <- base::computeRestarts
[18:01:02.043]                         grepl <- base::grepl
[18:01:02.043]                         restarts <- computeRestarts(cond)
[18:01:02.043]                         for (restart in restarts) {
[18:01:02.043]                           name <- restart$name
[18:01:02.043]                           if (is.null(name)) 
[18:01:02.043]                             next
[18:01:02.043]                           if (!grepl(pattern, name)) 
[18:01:02.043]                             next
[18:01:02.043]                           invokeRestart(restart)
[18:01:02.043]                           muffled <- TRUE
[18:01:02.043]                           break
[18:01:02.043]                         }
[18:01:02.043]                       }
[18:01:02.043]                     }
[18:01:02.043]                     invisible(muffled)
[18:01:02.043]                   }
[18:01:02.043]                   muffleCondition(cond)
[18:01:02.043]                 })
[18:01:02.043]             }))
[18:01:02.043]             future::FutureResult(value = ...future.value$value, 
[18:01:02.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.043]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.043]                     ...future.globalenv.names))
[18:01:02.043]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.043]         }, condition = base::local({
[18:01:02.043]             c <- base::c
[18:01:02.043]             inherits <- base::inherits
[18:01:02.043]             invokeRestart <- base::invokeRestart
[18:01:02.043]             length <- base::length
[18:01:02.043]             list <- base::list
[18:01:02.043]             seq.int <- base::seq.int
[18:01:02.043]             signalCondition <- base::signalCondition
[18:01:02.043]             sys.calls <- base::sys.calls
[18:01:02.043]             `[[` <- base::`[[`
[18:01:02.043]             `+` <- base::`+`
[18:01:02.043]             `<<-` <- base::`<<-`
[18:01:02.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.043]                   3L)]
[18:01:02.043]             }
[18:01:02.043]             function(cond) {
[18:01:02.043]                 is_error <- inherits(cond, "error")
[18:01:02.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.043]                   NULL)
[18:01:02.043]                 if (is_error) {
[18:01:02.043]                   sessionInformation <- function() {
[18:01:02.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.043]                       search = base::search(), system = base::Sys.info())
[18:01:02.043]                   }
[18:01:02.043]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.043]                     cond$call), session = sessionInformation(), 
[18:01:02.043]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.043]                   signalCondition(cond)
[18:01:02.043]                 }
[18:01:02.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.043]                 "immediateCondition"))) {
[18:01:02.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.043]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.043]                   if (TRUE && !signal) {
[18:01:02.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.043]                     {
[18:01:02.043]                       inherits <- base::inherits
[18:01:02.043]                       invokeRestart <- base::invokeRestart
[18:01:02.043]                       is.null <- base::is.null
[18:01:02.043]                       muffled <- FALSE
[18:01:02.043]                       if (inherits(cond, "message")) {
[18:01:02.043]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.043]                         if (muffled) 
[18:01:02.043]                           invokeRestart("muffleMessage")
[18:01:02.043]                       }
[18:01:02.043]                       else if (inherits(cond, "warning")) {
[18:01:02.043]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.043]                         if (muffled) 
[18:01:02.043]                           invokeRestart("muffleWarning")
[18:01:02.043]                       }
[18:01:02.043]                       else if (inherits(cond, "condition")) {
[18:01:02.043]                         if (!is.null(pattern)) {
[18:01:02.043]                           computeRestarts <- base::computeRestarts
[18:01:02.043]                           grepl <- base::grepl
[18:01:02.043]                           restarts <- computeRestarts(cond)
[18:01:02.043]                           for (restart in restarts) {
[18:01:02.043]                             name <- restart$name
[18:01:02.043]                             if (is.null(name)) 
[18:01:02.043]                               next
[18:01:02.043]                             if (!grepl(pattern, name)) 
[18:01:02.043]                               next
[18:01:02.043]                             invokeRestart(restart)
[18:01:02.043]                             muffled <- TRUE
[18:01:02.043]                             break
[18:01:02.043]                           }
[18:01:02.043]                         }
[18:01:02.043]                       }
[18:01:02.043]                       invisible(muffled)
[18:01:02.043]                     }
[18:01:02.043]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.043]                   }
[18:01:02.043]                 }
[18:01:02.043]                 else {
[18:01:02.043]                   if (TRUE) {
[18:01:02.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.043]                     {
[18:01:02.043]                       inherits <- base::inherits
[18:01:02.043]                       invokeRestart <- base::invokeRestart
[18:01:02.043]                       is.null <- base::is.null
[18:01:02.043]                       muffled <- FALSE
[18:01:02.043]                       if (inherits(cond, "message")) {
[18:01:02.043]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.043]                         if (muffled) 
[18:01:02.043]                           invokeRestart("muffleMessage")
[18:01:02.043]                       }
[18:01:02.043]                       else if (inherits(cond, "warning")) {
[18:01:02.043]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.043]                         if (muffled) 
[18:01:02.043]                           invokeRestart("muffleWarning")
[18:01:02.043]                       }
[18:01:02.043]                       else if (inherits(cond, "condition")) {
[18:01:02.043]                         if (!is.null(pattern)) {
[18:01:02.043]                           computeRestarts <- base::computeRestarts
[18:01:02.043]                           grepl <- base::grepl
[18:01:02.043]                           restarts <- computeRestarts(cond)
[18:01:02.043]                           for (restart in restarts) {
[18:01:02.043]                             name <- restart$name
[18:01:02.043]                             if (is.null(name)) 
[18:01:02.043]                               next
[18:01:02.043]                             if (!grepl(pattern, name)) 
[18:01:02.043]                               next
[18:01:02.043]                             invokeRestart(restart)
[18:01:02.043]                             muffled <- TRUE
[18:01:02.043]                             break
[18:01:02.043]                           }
[18:01:02.043]                         }
[18:01:02.043]                       }
[18:01:02.043]                       invisible(muffled)
[18:01:02.043]                     }
[18:01:02.043]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.043]                   }
[18:01:02.043]                 }
[18:01:02.043]             }
[18:01:02.043]         }))
[18:01:02.043]     }, error = function(ex) {
[18:01:02.043]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.043]                 ...future.rng), started = ...future.startTime, 
[18:01:02.043]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.043]             version = "1.8"), class = "FutureResult")
[18:01:02.043]     }, finally = {
[18:01:02.043]         if (!identical(...future.workdir, getwd())) 
[18:01:02.043]             setwd(...future.workdir)
[18:01:02.043]         {
[18:01:02.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.043]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.043]             }
[18:01:02.043]             base::options(...future.oldOptions)
[18:01:02.043]             if (.Platform$OS.type == "windows") {
[18:01:02.043]                 old_names <- names(...future.oldEnvVars)
[18:01:02.043]                 envs <- base::Sys.getenv()
[18:01:02.043]                 names <- names(envs)
[18:01:02.043]                 common <- intersect(names, old_names)
[18:01:02.043]                 added <- setdiff(names, old_names)
[18:01:02.043]                 removed <- setdiff(old_names, names)
[18:01:02.043]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.043]                   envs[common]]
[18:01:02.043]                 NAMES <- toupper(changed)
[18:01:02.043]                 args <- list()
[18:01:02.043]                 for (kk in seq_along(NAMES)) {
[18:01:02.043]                   name <- changed[[kk]]
[18:01:02.043]                   NAME <- NAMES[[kk]]
[18:01:02.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.043]                     next
[18:01:02.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.043]                 }
[18:01:02.043]                 NAMES <- toupper(added)
[18:01:02.043]                 for (kk in seq_along(NAMES)) {
[18:01:02.043]                   name <- added[[kk]]
[18:01:02.043]                   NAME <- NAMES[[kk]]
[18:01:02.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.043]                     next
[18:01:02.043]                   args[[name]] <- ""
[18:01:02.043]                 }
[18:01:02.043]                 NAMES <- toupper(removed)
[18:01:02.043]                 for (kk in seq_along(NAMES)) {
[18:01:02.043]                   name <- removed[[kk]]
[18:01:02.043]                   NAME <- NAMES[[kk]]
[18:01:02.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.043]                     next
[18:01:02.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.043]                 }
[18:01:02.043]                 if (length(args) > 0) 
[18:01:02.043]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.043]             }
[18:01:02.043]             else {
[18:01:02.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.043]             }
[18:01:02.043]             {
[18:01:02.043]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.043]                   0L) {
[18:01:02.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.043]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.043]                   base::options(opts)
[18:01:02.043]                 }
[18:01:02.043]                 {
[18:01:02.043]                   {
[18:01:02.043]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.043]                     NULL
[18:01:02.043]                   }
[18:01:02.043]                   options(future.plan = NULL)
[18:01:02.043]                   if (is.na(NA_character_)) 
[18:01:02.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.043]                     .init = FALSE)
[18:01:02.043]                 }
[18:01:02.043]             }
[18:01:02.043]         }
[18:01:02.043]     })
[18:01:02.043]     if (TRUE) {
[18:01:02.043]         base::sink(type = "output", split = FALSE)
[18:01:02.043]         if (TRUE) {
[18:01:02.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.043]         }
[18:01:02.043]         else {
[18:01:02.043]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.043]         }
[18:01:02.043]         base::close(...future.stdout)
[18:01:02.043]         ...future.stdout <- NULL
[18:01:02.043]     }
[18:01:02.043]     ...future.result$conditions <- ...future.conditions
[18:01:02.043]     ...future.result$finished <- base::Sys.time()
[18:01:02.043]     ...future.result
[18:01:02.043] }
[18:01:02.050] assign_globals() ...
[18:01:02.050] List of 5
[18:01:02.050]  $ ...future.FUN            :function (C, k)  
[18:01:02.050]  $ MoreArgs                 : list()
[18:01:02.050]  $ ...future.elements_ii    :List of 2
[18:01:02.050]   ..$ :List of 3
[18:01:02.050]   .. ..$ : chr "C"
[18:01:02.050]   .. ..$ : chr "D"
[18:01:02.050]   .. ..$ : chr "E"
[18:01:02.050]   ..$ :List of 3
[18:01:02.050]   .. ..$ : int 3
[18:01:02.050]   .. ..$ : int 2
[18:01:02.050]   .. ..$ : int 1
[18:01:02.050]  $ ...future.seeds_ii       : NULL
[18:01:02.050]  $ ...future.globals.maxSize: NULL
[18:01:02.050]  - attr(*, "where")=List of 5
[18:01:02.050]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.050]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.050]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.050]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.050]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.050]  - attr(*, "resolved")= logi FALSE
[18:01:02.050]  - attr(*, "total_size")= num 3824
[18:01:02.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.050]  - attr(*, "already-done")= logi TRUE
[18:01:02.076] - reassign environment for ‘...future.FUN’
[18:01:02.077] - copied ‘...future.FUN’ to environment
[18:01:02.077] - copied ‘MoreArgs’ to environment
[18:01:02.077] - copied ‘...future.elements_ii’ to environment
[18:01:02.078] - copied ‘...future.seeds_ii’ to environment
[18:01:02.078] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.078] assign_globals() ... done
[18:01:02.079] requestCore(): workers = 2
[18:01:02.083] MulticoreFuture started
[18:01:02.084] - Launch lazy future ... done
[18:01:02.085] plan(): Setting new future strategy stack:
[18:01:02.085] run() for ‘MulticoreFuture’ ... done
[18:01:02.087] Created future:
[18:01:02.086] List of future strategies:
[18:01:02.086] 1. sequential:
[18:01:02.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.086]    - tweaked: FALSE
[18:01:02.086]    - call: NULL
[18:01:02.089] plan(): nbrOfWorkers() = 1
[18:01:02.094] plan(): Setting new future strategy stack:
[18:01:02.095] List of future strategies:
[18:01:02.095] 1. multicore:
[18:01:02.095]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.095]    - tweaked: FALSE
[18:01:02.095]    - call: plan(strategy)
[18:01:02.087] MulticoreFuture:
[18:01:02.087] Label: ‘future_.mapply-2’
[18:01:02.087] Expression:
[18:01:02.087] {
[18:01:02.087]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.087]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.087]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.087]         on.exit(options(oopts), add = TRUE)
[18:01:02.087]     }
[18:01:02.087]     {
[18:01:02.087]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.087]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.087]         do.call(mapply, args = args)
[18:01:02.087]     }
[18:01:02.087] }
[18:01:02.087] Lazy evaluation: FALSE
[18:01:02.087] Asynchronous evaluation: TRUE
[18:01:02.087] Local evaluation: TRUE
[18:01:02.087] Environment: R_GlobalEnv
[18:01:02.087] Capture standard output: TRUE
[18:01:02.087] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.087] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.087] Packages: <none>
[18:01:02.087] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.087] Resolved: FALSE
[18:01:02.087] Value: <not collected>
[18:01:02.087] Conditions captured: <none>
[18:01:02.087] Early signaling: FALSE
[18:01:02.087] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.087] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.104] Chunk #2 of 2 ... DONE
[18:01:02.106] plan(): nbrOfWorkers() = 2
[18:01:02.105] Launching 2 futures (chunks) ... DONE
[18:01:02.107] Resolving 2 futures (chunks) ...
[18:01:02.108] resolve() on list ...
[18:01:02.108]  recursive: 0
[18:01:02.108]  length: 2
[18:01:02.108] 
[18:01:02.109] Future #1
[18:01:02.110] result() for MulticoreFuture ...
[18:01:02.113] result() for MulticoreFuture ...
[18:01:02.114] result() for MulticoreFuture ... done
[18:01:02.114] result() for MulticoreFuture ... done
[18:01:02.114] result() for MulticoreFuture ...
[18:01:02.115] result() for MulticoreFuture ... done
[18:01:02.115] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:02.116] - nx: 2
[18:01:02.116] - relay: TRUE
[18:01:02.117] - stdout: TRUE
[18:01:02.119] - signal: TRUE
[18:01:02.120] - resignal: FALSE
[18:01:02.120] - force: TRUE
[18:01:02.121] - relayed: [n=2] FALSE, FALSE
[18:01:02.121] - queued futures: [n=2] FALSE, FALSE
[18:01:02.121]  - until=1
[18:01:02.122]  - relaying element #1
[18:01:02.122] result() for MulticoreFuture ...
[18:01:02.123] result() for MulticoreFuture ... done
[18:01:02.123] result() for MulticoreFuture ...
[18:01:02.123] result() for MulticoreFuture ... done
[18:01:02.124] result() for MulticoreFuture ...
[18:01:02.124] result() for MulticoreFuture ... done
[18:01:02.125] result() for MulticoreFuture ...
[18:01:02.125] result() for MulticoreFuture ... done
[18:01:02.125] - relayed: [n=2] TRUE, FALSE
[18:01:02.126] - queued futures: [n=2] TRUE, FALSE
[18:01:02.126] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:02.126]  length: 1 (resolved future 1)
[18:01:02.127] Future #2
[18:01:02.127] result() for MulticoreFuture ...
[18:01:02.129] result() for MulticoreFuture ...
[18:01:02.129] result() for MulticoreFuture ... done
[18:01:02.130] result() for MulticoreFuture ... done
[18:01:02.130] result() for MulticoreFuture ...
[18:01:02.130] result() for MulticoreFuture ... done
[18:01:02.131] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:02.131] - nx: 2
[18:01:02.131] - relay: TRUE
[18:01:02.131] - stdout: TRUE
[18:01:02.132] - signal: TRUE
[18:01:02.132] - resignal: FALSE
[18:01:02.132] - force: TRUE
[18:01:02.133] - relayed: [n=2] TRUE, FALSE
[18:01:02.133] - queued futures: [n=2] TRUE, FALSE
[18:01:02.133]  - until=2
[18:01:02.133]  - relaying element #2
[18:01:02.134] result() for MulticoreFuture ...
[18:01:02.134] result() for MulticoreFuture ... done
[18:01:02.134] result() for MulticoreFuture ...
[18:01:02.134] result() for MulticoreFuture ... done
[18:01:02.135] result() for MulticoreFuture ...
[18:01:02.135] result() for MulticoreFuture ... done
[18:01:02.135] result() for MulticoreFuture ...
[18:01:02.135] result() for MulticoreFuture ... done
[18:01:02.136] - relayed: [n=2] TRUE, TRUE
[18:01:02.136] - queued futures: [n=2] TRUE, TRUE
[18:01:02.136] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:02.136]  length: 0 (resolved future 2)
[18:01:02.137] Relaying remaining futures
[18:01:02.137] signalConditionsASAP(NULL, pos=0) ...
[18:01:02.137] - nx: 2
[18:01:02.137] - relay: TRUE
[18:01:02.138] - stdout: TRUE
[18:01:02.138] - signal: TRUE
[18:01:02.138] - resignal: FALSE
[18:01:02.138] - force: TRUE
[18:01:02.138] - relayed: [n=2] TRUE, TRUE
[18:01:02.139] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:02.139] - relayed: [n=2] TRUE, TRUE
[18:01:02.139] - queued futures: [n=2] TRUE, TRUE
[18:01:02.139] signalConditionsASAP(NULL, pos=0) ... done
[18:01:02.140] resolve() on list ... DONE
[18:01:02.140] result() for MulticoreFuture ...
[18:01:02.140] result() for MulticoreFuture ... done
[18:01:02.140] result() for MulticoreFuture ...
[18:01:02.141] result() for MulticoreFuture ... done
[18:01:02.141] result() for MulticoreFuture ...
[18:01:02.141] result() for MulticoreFuture ... done
[18:01:02.142] result() for MulticoreFuture ...
[18:01:02.142] result() for MulticoreFuture ... done
[18:01:02.142]  - Number of value chunks collected: 2
[18:01:02.142] Resolving 2 futures (chunks) ... DONE
[18:01:02.143] Reducing values from 2 chunks ...
[18:01:02.143]  - Number of values collected after concatenation: 5
[18:01:02.143]  - Number of values expected: 5
[18:01:02.143] Reducing values from 2 chunks ... DONE
[18:01:02.143] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[18:01:02.144] future_mapply() ...
[18:01:02.151] Number of chunks: 1
[18:01:02.152] getGlobalsAndPackagesXApply() ...
[18:01:02.152]  - future.globals: TRUE
[18:01:02.152] getGlobalsAndPackages() ...
[18:01:02.152] Searching for globals...
[18:01:02.155] - globals found: [1] ‘FUN’
[18:01:02.155] Searching for globals ... DONE
[18:01:02.156] Resolving globals: FALSE
[18:01:02.157] The total size of the 1 globals is 848 bytes (848 bytes)
[18:01:02.157] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:01:02.161] - globals: [1] ‘FUN’
[18:01:02.161] 
[18:01:02.162] getGlobalsAndPackages() ... DONE
[18:01:02.162]  - globals found/used: [n=1] ‘FUN’
[18:01:02.162]  - needed namespaces: [n=0] 
[18:01:02.163] Finding globals ... DONE
[18:01:02.163] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:02.164] List of 2
[18:01:02.164]  $ ...future.FUN:function (x)  
[18:01:02.164]  $ MoreArgs     : NULL
[18:01:02.164]  - attr(*, "where")=List of 2
[18:01:02.164]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:02.164]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:02.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.164]  - attr(*, "resolved")= logi FALSE
[18:01:02.164]  - attr(*, "total_size")= num NA
[18:01:02.170] Packages to be attached in all futures: [n=0] 
[18:01:02.171] getGlobalsAndPackagesXApply() ... DONE
[18:01:02.171] Number of futures (= number of chunks): 1
[18:01:02.172] Launching 1 futures (chunks) ...
[18:01:02.172] Chunk #1 of 1 ...
[18:01:02.172]  - Finding globals in '...' for chunk #1 ...
[18:01:02.172] getGlobalsAndPackages() ...
[18:01:02.173] Searching for globals...
[18:01:02.173] 
[18:01:02.173] Searching for globals ... DONE
[18:01:02.174] - globals: [0] <none>
[18:01:02.174] getGlobalsAndPackages() ... DONE
[18:01:02.174]    + additional globals found: [n=0] 
[18:01:02.174]    + additional namespaces needed: [n=0] 
[18:01:02.174]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:02.175]  - seeds: <none>
[18:01:02.175]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.175] getGlobalsAndPackages() ...
[18:01:02.175] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.176] Resolving globals: FALSE
[18:01:02.177] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[18:01:02.178] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:02.178] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.178] 
[18:01:02.179] getGlobalsAndPackages() ... DONE
[18:01:02.179] run() for ‘Future’ ...
[18:01:02.179] - state: ‘created’
[18:01:02.180] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.186] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.187]   - Field: ‘label’
[18:01:02.187]   - Field: ‘local’
[18:01:02.187]   - Field: ‘owner’
[18:01:02.188]   - Field: ‘envir’
[18:01:02.188]   - Field: ‘workers’
[18:01:02.188]   - Field: ‘packages’
[18:01:02.188]   - Field: ‘gc’
[18:01:02.188]   - Field: ‘job’
[18:01:02.189]   - Field: ‘conditions’
[18:01:02.189]   - Field: ‘expr’
[18:01:02.189]   - Field: ‘uuid’
[18:01:02.189]   - Field: ‘seed’
[18:01:02.190]   - Field: ‘version’
[18:01:02.190]   - Field: ‘result’
[18:01:02.190]   - Field: ‘asynchronous’
[18:01:02.190]   - Field: ‘calls’
[18:01:02.190]   - Field: ‘globals’
[18:01:02.191]   - Field: ‘stdout’
[18:01:02.191]   - Field: ‘earlySignal’
[18:01:02.191]   - Field: ‘lazy’
[18:01:02.191]   - Field: ‘state’
[18:01:02.191] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.192] - Launch lazy future ...
[18:01:02.192] Packages needed by the future expression (n = 0): <none>
[18:01:02.192] Packages needed by future strategies (n = 0): <none>
[18:01:02.193] {
[18:01:02.193]     {
[18:01:02.193]         {
[18:01:02.193]             ...future.startTime <- base::Sys.time()
[18:01:02.193]             {
[18:01:02.193]                 {
[18:01:02.193]                   {
[18:01:02.193]                     {
[18:01:02.193]                       base::local({
[18:01:02.193]                         has_future <- base::requireNamespace("future", 
[18:01:02.193]                           quietly = TRUE)
[18:01:02.193]                         if (has_future) {
[18:01:02.193]                           ns <- base::getNamespace("future")
[18:01:02.193]                           version <- ns[[".package"]][["version"]]
[18:01:02.193]                           if (is.null(version)) 
[18:01:02.193]                             version <- utils::packageVersion("future")
[18:01:02.193]                         }
[18:01:02.193]                         else {
[18:01:02.193]                           version <- NULL
[18:01:02.193]                         }
[18:01:02.193]                         if (!has_future || version < "1.8.0") {
[18:01:02.193]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.193]                             "", base::R.version$version.string), 
[18:01:02.193]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.193]                               "release", "version")], collapse = " "), 
[18:01:02.193]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.193]                             info)
[18:01:02.193]                           info <- base::paste(info, collapse = "; ")
[18:01:02.193]                           if (!has_future) {
[18:01:02.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.193]                               info)
[18:01:02.193]                           }
[18:01:02.193]                           else {
[18:01:02.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.193]                               info, version)
[18:01:02.193]                           }
[18:01:02.193]                           base::stop(msg)
[18:01:02.193]                         }
[18:01:02.193]                       })
[18:01:02.193]                     }
[18:01:02.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.193]                     base::options(mc.cores = 1L)
[18:01:02.193]                   }
[18:01:02.193]                   ...future.strategy.old <- future::plan("list")
[18:01:02.193]                   options(future.plan = NULL)
[18:01:02.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.193]                 }
[18:01:02.193]                 ...future.workdir <- getwd()
[18:01:02.193]             }
[18:01:02.193]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.193]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.193]         }
[18:01:02.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:02.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.193]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.193]             base::names(...future.oldOptions))
[18:01:02.193]     }
[18:01:02.193]     if (FALSE) {
[18:01:02.193]     }
[18:01:02.193]     else {
[18:01:02.193]         if (TRUE) {
[18:01:02.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.193]                 open = "w")
[18:01:02.193]         }
[18:01:02.193]         else {
[18:01:02.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.193]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.193]         }
[18:01:02.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.193]             base::sink(type = "output", split = FALSE)
[18:01:02.193]             base::close(...future.stdout)
[18:01:02.193]         }, add = TRUE)
[18:01:02.193]     }
[18:01:02.193]     ...future.frame <- base::sys.nframe()
[18:01:02.193]     ...future.conditions <- base::list()
[18:01:02.193]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.193]     if (FALSE) {
[18:01:02.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.193]     }
[18:01:02.193]     ...future.result <- base::tryCatch({
[18:01:02.193]         base::withCallingHandlers({
[18:01:02.193]             ...future.value <- base::withVisible(base::local({
[18:01:02.193]                 withCallingHandlers({
[18:01:02.193]                   {
[18:01:02.193]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.193]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.193]                       ...future.globals.maxSize)) {
[18:01:02.193]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.193]                       on.exit(options(oopts), add = TRUE)
[18:01:02.193]                     }
[18:01:02.193]                     {
[18:01:02.193]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.193]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.193]                         USE.NAMES = FALSE)
[18:01:02.193]                       do.call(mapply, args = args)
[18:01:02.193]                     }
[18:01:02.193]                   }
[18:01:02.193]                 }, immediateCondition = function(cond) {
[18:01:02.193]                   save_rds <- function (object, pathname, ...) 
[18:01:02.193]                   {
[18:01:02.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.193]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.193]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.193]                         fi_tmp[["mtime"]])
[18:01:02.193]                     }
[18:01:02.193]                     tryCatch({
[18:01:02.193]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.193]                     }, error = function(ex) {
[18:01:02.193]                       msg <- conditionMessage(ex)
[18:01:02.193]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.193]                         fi_tmp[["mtime"]], msg)
[18:01:02.193]                       ex$message <- msg
[18:01:02.193]                       stop(ex)
[18:01:02.193]                     })
[18:01:02.193]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.193]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.193]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.193]                       fi <- file.info(pathname)
[18:01:02.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.193]                         fi[["size"]], fi[["mtime"]])
[18:01:02.193]                       stop(msg)
[18:01:02.193]                     }
[18:01:02.193]                     invisible(pathname)
[18:01:02.193]                   }
[18:01:02.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.193]                     rootPath = tempdir()) 
[18:01:02.193]                   {
[18:01:02.193]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.193]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.193]                       tmpdir = path, fileext = ".rds")
[18:01:02.193]                     save_rds(obj, file)
[18:01:02.193]                   }
[18:01:02.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.193]                   {
[18:01:02.193]                     inherits <- base::inherits
[18:01:02.193]                     invokeRestart <- base::invokeRestart
[18:01:02.193]                     is.null <- base::is.null
[18:01:02.193]                     muffled <- FALSE
[18:01:02.193]                     if (inherits(cond, "message")) {
[18:01:02.193]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.193]                       if (muffled) 
[18:01:02.193]                         invokeRestart("muffleMessage")
[18:01:02.193]                     }
[18:01:02.193]                     else if (inherits(cond, "warning")) {
[18:01:02.193]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.193]                       if (muffled) 
[18:01:02.193]                         invokeRestart("muffleWarning")
[18:01:02.193]                     }
[18:01:02.193]                     else if (inherits(cond, "condition")) {
[18:01:02.193]                       if (!is.null(pattern)) {
[18:01:02.193]                         computeRestarts <- base::computeRestarts
[18:01:02.193]                         grepl <- base::grepl
[18:01:02.193]                         restarts <- computeRestarts(cond)
[18:01:02.193]                         for (restart in restarts) {
[18:01:02.193]                           name <- restart$name
[18:01:02.193]                           if (is.null(name)) 
[18:01:02.193]                             next
[18:01:02.193]                           if (!grepl(pattern, name)) 
[18:01:02.193]                             next
[18:01:02.193]                           invokeRestart(restart)
[18:01:02.193]                           muffled <- TRUE
[18:01:02.193]                           break
[18:01:02.193]                         }
[18:01:02.193]                       }
[18:01:02.193]                     }
[18:01:02.193]                     invisible(muffled)
[18:01:02.193]                   }
[18:01:02.193]                   muffleCondition(cond)
[18:01:02.193]                 })
[18:01:02.193]             }))
[18:01:02.193]             future::FutureResult(value = ...future.value$value, 
[18:01:02.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.193]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.193]                     ...future.globalenv.names))
[18:01:02.193]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.193]         }, condition = base::local({
[18:01:02.193]             c <- base::c
[18:01:02.193]             inherits <- base::inherits
[18:01:02.193]             invokeRestart <- base::invokeRestart
[18:01:02.193]             length <- base::length
[18:01:02.193]             list <- base::list
[18:01:02.193]             seq.int <- base::seq.int
[18:01:02.193]             signalCondition <- base::signalCondition
[18:01:02.193]             sys.calls <- base::sys.calls
[18:01:02.193]             `[[` <- base::`[[`
[18:01:02.193]             `+` <- base::`+`
[18:01:02.193]             `<<-` <- base::`<<-`
[18:01:02.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.193]                   3L)]
[18:01:02.193]             }
[18:01:02.193]             function(cond) {
[18:01:02.193]                 is_error <- inherits(cond, "error")
[18:01:02.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.193]                   NULL)
[18:01:02.193]                 if (is_error) {
[18:01:02.193]                   sessionInformation <- function() {
[18:01:02.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.193]                       search = base::search(), system = base::Sys.info())
[18:01:02.193]                   }
[18:01:02.193]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.193]                     cond$call), session = sessionInformation(), 
[18:01:02.193]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.193]                   signalCondition(cond)
[18:01:02.193]                 }
[18:01:02.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.193]                 "immediateCondition"))) {
[18:01:02.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.193]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.193]                   if (TRUE && !signal) {
[18:01:02.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.193]                     {
[18:01:02.193]                       inherits <- base::inherits
[18:01:02.193]                       invokeRestart <- base::invokeRestart
[18:01:02.193]                       is.null <- base::is.null
[18:01:02.193]                       muffled <- FALSE
[18:01:02.193]                       if (inherits(cond, "message")) {
[18:01:02.193]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.193]                         if (muffled) 
[18:01:02.193]                           invokeRestart("muffleMessage")
[18:01:02.193]                       }
[18:01:02.193]                       else if (inherits(cond, "warning")) {
[18:01:02.193]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.193]                         if (muffled) 
[18:01:02.193]                           invokeRestart("muffleWarning")
[18:01:02.193]                       }
[18:01:02.193]                       else if (inherits(cond, "condition")) {
[18:01:02.193]                         if (!is.null(pattern)) {
[18:01:02.193]                           computeRestarts <- base::computeRestarts
[18:01:02.193]                           grepl <- base::grepl
[18:01:02.193]                           restarts <- computeRestarts(cond)
[18:01:02.193]                           for (restart in restarts) {
[18:01:02.193]                             name <- restart$name
[18:01:02.193]                             if (is.null(name)) 
[18:01:02.193]                               next
[18:01:02.193]                             if (!grepl(pattern, name)) 
[18:01:02.193]                               next
[18:01:02.193]                             invokeRestart(restart)
[18:01:02.193]                             muffled <- TRUE
[18:01:02.193]                             break
[18:01:02.193]                           }
[18:01:02.193]                         }
[18:01:02.193]                       }
[18:01:02.193]                       invisible(muffled)
[18:01:02.193]                     }
[18:01:02.193]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.193]                   }
[18:01:02.193]                 }
[18:01:02.193]                 else {
[18:01:02.193]                   if (TRUE) {
[18:01:02.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.193]                     {
[18:01:02.193]                       inherits <- base::inherits
[18:01:02.193]                       invokeRestart <- base::invokeRestart
[18:01:02.193]                       is.null <- base::is.null
[18:01:02.193]                       muffled <- FALSE
[18:01:02.193]                       if (inherits(cond, "message")) {
[18:01:02.193]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.193]                         if (muffled) 
[18:01:02.193]                           invokeRestart("muffleMessage")
[18:01:02.193]                       }
[18:01:02.193]                       else if (inherits(cond, "warning")) {
[18:01:02.193]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.193]                         if (muffled) 
[18:01:02.193]                           invokeRestart("muffleWarning")
[18:01:02.193]                       }
[18:01:02.193]                       else if (inherits(cond, "condition")) {
[18:01:02.193]                         if (!is.null(pattern)) {
[18:01:02.193]                           computeRestarts <- base::computeRestarts
[18:01:02.193]                           grepl <- base::grepl
[18:01:02.193]                           restarts <- computeRestarts(cond)
[18:01:02.193]                           for (restart in restarts) {
[18:01:02.193]                             name <- restart$name
[18:01:02.193]                             if (is.null(name)) 
[18:01:02.193]                               next
[18:01:02.193]                             if (!grepl(pattern, name)) 
[18:01:02.193]                               next
[18:01:02.193]                             invokeRestart(restart)
[18:01:02.193]                             muffled <- TRUE
[18:01:02.193]                             break
[18:01:02.193]                           }
[18:01:02.193]                         }
[18:01:02.193]                       }
[18:01:02.193]                       invisible(muffled)
[18:01:02.193]                     }
[18:01:02.193]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.193]                   }
[18:01:02.193]                 }
[18:01:02.193]             }
[18:01:02.193]         }))
[18:01:02.193]     }, error = function(ex) {
[18:01:02.193]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.193]                 ...future.rng), started = ...future.startTime, 
[18:01:02.193]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.193]             version = "1.8"), class = "FutureResult")
[18:01:02.193]     }, finally = {
[18:01:02.193]         if (!identical(...future.workdir, getwd())) 
[18:01:02.193]             setwd(...future.workdir)
[18:01:02.193]         {
[18:01:02.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.193]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.193]             }
[18:01:02.193]             base::options(...future.oldOptions)
[18:01:02.193]             if (.Platform$OS.type == "windows") {
[18:01:02.193]                 old_names <- names(...future.oldEnvVars)
[18:01:02.193]                 envs <- base::Sys.getenv()
[18:01:02.193]                 names <- names(envs)
[18:01:02.193]                 common <- intersect(names, old_names)
[18:01:02.193]                 added <- setdiff(names, old_names)
[18:01:02.193]                 removed <- setdiff(old_names, names)
[18:01:02.193]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.193]                   envs[common]]
[18:01:02.193]                 NAMES <- toupper(changed)
[18:01:02.193]                 args <- list()
[18:01:02.193]                 for (kk in seq_along(NAMES)) {
[18:01:02.193]                   name <- changed[[kk]]
[18:01:02.193]                   NAME <- NAMES[[kk]]
[18:01:02.193]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.193]                     next
[18:01:02.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.193]                 }
[18:01:02.193]                 NAMES <- toupper(added)
[18:01:02.193]                 for (kk in seq_along(NAMES)) {
[18:01:02.193]                   name <- added[[kk]]
[18:01:02.193]                   NAME <- NAMES[[kk]]
[18:01:02.193]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.193]                     next
[18:01:02.193]                   args[[name]] <- ""
[18:01:02.193]                 }
[18:01:02.193]                 NAMES <- toupper(removed)
[18:01:02.193]                 for (kk in seq_along(NAMES)) {
[18:01:02.193]                   name <- removed[[kk]]
[18:01:02.193]                   NAME <- NAMES[[kk]]
[18:01:02.193]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.193]                     next
[18:01:02.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.193]                 }
[18:01:02.193]                 if (length(args) > 0) 
[18:01:02.193]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.193]             }
[18:01:02.193]             else {
[18:01:02.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.193]             }
[18:01:02.193]             {
[18:01:02.193]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.193]                   0L) {
[18:01:02.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.193]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.193]                   base::options(opts)
[18:01:02.193]                 }
[18:01:02.193]                 {
[18:01:02.193]                   {
[18:01:02.193]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.193]                     NULL
[18:01:02.193]                   }
[18:01:02.193]                   options(future.plan = NULL)
[18:01:02.193]                   if (is.na(NA_character_)) 
[18:01:02.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.193]                     .init = FALSE)
[18:01:02.193]                 }
[18:01:02.193]             }
[18:01:02.193]         }
[18:01:02.193]     })
[18:01:02.193]     if (TRUE) {
[18:01:02.193]         base::sink(type = "output", split = FALSE)
[18:01:02.193]         if (TRUE) {
[18:01:02.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.193]         }
[18:01:02.193]         else {
[18:01:02.193]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.193]         }
[18:01:02.193]         base::close(...future.stdout)
[18:01:02.193]         ...future.stdout <- NULL
[18:01:02.193]     }
[18:01:02.193]     ...future.result$conditions <- ...future.conditions
[18:01:02.193]     ...future.result$finished <- base::Sys.time()
[18:01:02.193]     ...future.result
[18:01:02.193] }
[18:01:02.199] assign_globals() ...
[18:01:02.199] List of 5
[18:01:02.199]  $ ...future.FUN            :function (x)  
[18:01:02.199]  $ MoreArgs                 : NULL
[18:01:02.199]  $ ...future.elements_ii    :List of 1
[18:01:02.199]   ..$ :List of 1
[18:01:02.199]   .. ..$ : Date[1:1], format: "2018-06-01"
[18:01:02.199]  $ ...future.seeds_ii       : NULL
[18:01:02.199]  $ ...future.globals.maxSize: NULL
[18:01:02.199]  - attr(*, "where")=List of 5
[18:01:02.199]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.199]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.199]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.199]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.199]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.199]  - attr(*, "resolved")= logi FALSE
[18:01:02.199]  - attr(*, "total_size")= num 1128
[18:01:02.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.199]  - attr(*, "already-done")= logi TRUE
[18:01:02.210] - copied ‘...future.FUN’ to environment
[18:01:02.210] - copied ‘MoreArgs’ to environment
[18:01:02.210] - copied ‘...future.elements_ii’ to environment
[18:01:02.210] - copied ‘...future.seeds_ii’ to environment
[18:01:02.211] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.211] assign_globals() ... done
[18:01:02.211] requestCore(): workers = 2
[18:01:02.215] MulticoreFuture started
[18:01:02.218] - Launch lazy future ... done
[18:01:02.218] run() for ‘MulticoreFuture’ ... done
[18:01:02.219] Created future:
[18:01:02.220] plan(): Setting new future strategy stack:
[18:01:02.221] List of future strategies:
[18:01:02.221] 1. sequential:
[18:01:02.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.221]    - tweaked: FALSE
[18:01:02.221]    - call: NULL
[18:01:02.234] plan(): nbrOfWorkers() = 1
[18:01:02.239] plan(): Setting new future strategy stack:
[18:01:02.240] List of future strategies:
[18:01:02.240] 1. multicore:
[18:01:02.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.240]    - tweaked: FALSE
[18:01:02.240]    - call: plan(strategy)
[18:01:02.220] MulticoreFuture:
[18:01:02.220] Label: ‘future_mapply-1’
[18:01:02.220] Expression:
[18:01:02.220] {
[18:01:02.220]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.220]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.220]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.220]         on.exit(options(oopts), add = TRUE)
[18:01:02.220]     }
[18:01:02.220]     {
[18:01:02.220]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.220]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.220]         do.call(mapply, args = args)
[18:01:02.220]     }
[18:01:02.220] }
[18:01:02.220] Lazy evaluation: FALSE
[18:01:02.220] Asynchronous evaluation: TRUE
[18:01:02.220] Local evaluation: TRUE
[18:01:02.220] Environment: R_GlobalEnv
[18:01:02.220] Capture standard output: TRUE
[18:01:02.220] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.220] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.220] Packages: <none>
[18:01:02.220] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.220] Resolved: FALSE
[18:01:02.220] Value: <not collected>
[18:01:02.220] Conditions captured: <none>
[18:01:02.220] Early signaling: FALSE
[18:01:02.220] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.220] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.248] Chunk #1 of 1 ... DONE
[18:01:02.249] Launching 1 futures (chunks) ... DONE
[18:01:02.249] Resolving 1 futures (chunks) ...
[18:01:02.250] resolve() on list ...
[18:01:02.250]  recursive: 0
[18:01:02.250]  length: 1
[18:01:02.251] 
[18:01:02.252] plan(): nbrOfWorkers() = 2
[18:01:02.253] Future #1
[18:01:02.254] result() for MulticoreFuture ...
[18:01:02.255] result() for MulticoreFuture ...
[18:01:02.256] result() for MulticoreFuture ... done
[18:01:02.256] result() for MulticoreFuture ... done
[18:01:02.257] result() for MulticoreFuture ...
[18:01:02.257] result() for MulticoreFuture ... done
[18:01:02.258] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:02.259] - nx: 1
[18:01:02.259] - relay: TRUE
[18:01:02.259] - stdout: TRUE
[18:01:02.260] - signal: TRUE
[18:01:02.260] - resignal: FALSE
[18:01:02.260] - force: TRUE
[18:01:02.261] - relayed: [n=1] FALSE
[18:01:02.261] - queued futures: [n=1] FALSE
[18:01:02.261]  - until=1
[18:01:02.261]  - relaying element #1
[18:01:02.262] result() for MulticoreFuture ...
[18:01:02.262] result() for MulticoreFuture ... done
[18:01:02.262] result() for MulticoreFuture ...
[18:01:02.263] result() for MulticoreFuture ... done
[18:01:02.263] result() for MulticoreFuture ...
[18:01:02.263] result() for MulticoreFuture ... done
[18:01:02.264] result() for MulticoreFuture ...
[18:01:02.264] result() for MulticoreFuture ... done
[18:01:02.264] - relayed: [n=1] TRUE
[18:01:02.264] - queued futures: [n=1] TRUE
[18:01:02.265] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:02.265]  length: 0 (resolved future 1)
[18:01:02.265] Relaying remaining futures
[18:01:02.265] signalConditionsASAP(NULL, pos=0) ...
[18:01:02.266] - nx: 1
[18:01:02.266] - relay: TRUE
[18:01:02.266] - stdout: TRUE
[18:01:02.266] - signal: TRUE
[18:01:02.266] - resignal: FALSE
[18:01:02.267] - force: TRUE
[18:01:02.267] - relayed: [n=1] TRUE
[18:01:02.267] - queued futures: [n=1] TRUE
 - flush all
[18:01:02.267] - relayed: [n=1] TRUE
[18:01:02.268] - queued futures: [n=1] TRUE
[18:01:02.268] signalConditionsASAP(NULL, pos=0) ... done
[18:01:02.268] resolve() on list ... DONE
[18:01:02.268] result() for MulticoreFuture ...
[18:01:02.269] result() for MulticoreFuture ... done
[18:01:02.269] result() for MulticoreFuture ...
[18:01:02.269] result() for MulticoreFuture ... done
[18:01:02.269]  - Number of value chunks collected: 1
[18:01:02.270] Resolving 1 futures (chunks) ... DONE
[18:01:02.270] Reducing values from 1 chunks ...
[18:01:02.270]  - Number of values collected after concatenation: 1
[18:01:02.270]  - Number of values expected: 1
[18:01:02.271] Reducing values from 1 chunks ... DONE
[18:01:02.271] future_mapply() ... DONE
[18:01:02.271] future_mapply() ...
[18:01:02.278] Number of chunks: 1
[18:01:02.278] getGlobalsAndPackagesXApply() ...
[18:01:02.278]  - future.globals: TRUE
[18:01:02.279] getGlobalsAndPackages() ...
[18:01:02.279] Searching for globals...
[18:01:02.281] - globals found: [1] ‘FUN’
[18:01:02.282] Searching for globals ... DONE
[18:01:02.282] Resolving globals: FALSE
[18:01:02.283] The total size of the 1 globals is 848 bytes (848 bytes)
[18:01:02.284] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:01:02.284] - globals: [1] ‘FUN’
[18:01:02.284] 
[18:01:02.284] getGlobalsAndPackages() ... DONE
[18:01:02.285]  - globals found/used: [n=1] ‘FUN’
[18:01:02.285]  - needed namespaces: [n=0] 
[18:01:02.285] Finding globals ... DONE
[18:01:02.285] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:02.286] List of 2
[18:01:02.286]  $ ...future.FUN:function (x)  
[18:01:02.286]  $ MoreArgs     : list()
[18:01:02.286]  - attr(*, "where")=List of 2
[18:01:02.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:02.286]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:02.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.286]  - attr(*, "resolved")= logi FALSE
[18:01:02.286]  - attr(*, "total_size")= num NA
[18:01:02.291] Packages to be attached in all futures: [n=0] 
[18:01:02.291] getGlobalsAndPackagesXApply() ... DONE
[18:01:02.292] Number of futures (= number of chunks): 1
[18:01:02.292] Launching 1 futures (chunks) ...
[18:01:02.292] Chunk #1 of 1 ...
[18:01:02.293]  - Finding globals in '...' for chunk #1 ...
[18:01:02.293] getGlobalsAndPackages() ...
[18:01:02.293] Searching for globals...
[18:01:02.294] 
[18:01:02.294] Searching for globals ... DONE
[18:01:02.294] - globals: [0] <none>
[18:01:02.294] getGlobalsAndPackages() ... DONE
[18:01:02.295]    + additional globals found: [n=0] 
[18:01:02.295]    + additional namespaces needed: [n=0] 
[18:01:02.295]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:02.295]  - seeds: <none>
[18:01:02.295]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.296] getGlobalsAndPackages() ...
[18:01:02.296] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.296] Resolving globals: FALSE
[18:01:02.297] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[18:01:02.298] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:02.298] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.299] 
[18:01:02.299] getGlobalsAndPackages() ... DONE
[18:01:02.300] run() for ‘Future’ ...
[18:01:02.300] - state: ‘created’
[18:01:02.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.309] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.310]   - Field: ‘label’
[18:01:02.310]   - Field: ‘local’
[18:01:02.310]   - Field: ‘owner’
[18:01:02.311]   - Field: ‘envir’
[18:01:02.311]   - Field: ‘workers’
[18:01:02.311]   - Field: ‘packages’
[18:01:02.311]   - Field: ‘gc’
[18:01:02.311]   - Field: ‘job’
[18:01:02.312]   - Field: ‘conditions’
[18:01:02.312]   - Field: ‘expr’
[18:01:02.312]   - Field: ‘uuid’
[18:01:02.312]   - Field: ‘seed’
[18:01:02.313]   - Field: ‘version’
[18:01:02.313]   - Field: ‘result’
[18:01:02.313]   - Field: ‘asynchronous’
[18:01:02.313]   - Field: ‘calls’
[18:01:02.313]   - Field: ‘globals’
[18:01:02.314]   - Field: ‘stdout’
[18:01:02.314]   - Field: ‘earlySignal’
[18:01:02.314]   - Field: ‘lazy’
[18:01:02.314]   - Field: ‘state’
[18:01:02.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.315] - Launch lazy future ...
[18:01:02.315] Packages needed by the future expression (n = 0): <none>
[18:01:02.315] Packages needed by future strategies (n = 0): <none>
[18:01:02.316] {
[18:01:02.316]     {
[18:01:02.316]         {
[18:01:02.316]             ...future.startTime <- base::Sys.time()
[18:01:02.316]             {
[18:01:02.316]                 {
[18:01:02.316]                   {
[18:01:02.316]                     {
[18:01:02.316]                       base::local({
[18:01:02.316]                         has_future <- base::requireNamespace("future", 
[18:01:02.316]                           quietly = TRUE)
[18:01:02.316]                         if (has_future) {
[18:01:02.316]                           ns <- base::getNamespace("future")
[18:01:02.316]                           version <- ns[[".package"]][["version"]]
[18:01:02.316]                           if (is.null(version)) 
[18:01:02.316]                             version <- utils::packageVersion("future")
[18:01:02.316]                         }
[18:01:02.316]                         else {
[18:01:02.316]                           version <- NULL
[18:01:02.316]                         }
[18:01:02.316]                         if (!has_future || version < "1.8.0") {
[18:01:02.316]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.316]                             "", base::R.version$version.string), 
[18:01:02.316]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.316]                               "release", "version")], collapse = " "), 
[18:01:02.316]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.316]                             info)
[18:01:02.316]                           info <- base::paste(info, collapse = "; ")
[18:01:02.316]                           if (!has_future) {
[18:01:02.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.316]                               info)
[18:01:02.316]                           }
[18:01:02.316]                           else {
[18:01:02.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.316]                               info, version)
[18:01:02.316]                           }
[18:01:02.316]                           base::stop(msg)
[18:01:02.316]                         }
[18:01:02.316]                       })
[18:01:02.316]                     }
[18:01:02.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.316]                     base::options(mc.cores = 1L)
[18:01:02.316]                   }
[18:01:02.316]                   ...future.strategy.old <- future::plan("list")
[18:01:02.316]                   options(future.plan = NULL)
[18:01:02.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.316]                 }
[18:01:02.316]                 ...future.workdir <- getwd()
[18:01:02.316]             }
[18:01:02.316]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.316]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.316]         }
[18:01:02.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:02.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.316]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.316]             base::names(...future.oldOptions))
[18:01:02.316]     }
[18:01:02.316]     if (FALSE) {
[18:01:02.316]     }
[18:01:02.316]     else {
[18:01:02.316]         if (TRUE) {
[18:01:02.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.316]                 open = "w")
[18:01:02.316]         }
[18:01:02.316]         else {
[18:01:02.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.316]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.316]         }
[18:01:02.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.316]             base::sink(type = "output", split = FALSE)
[18:01:02.316]             base::close(...future.stdout)
[18:01:02.316]         }, add = TRUE)
[18:01:02.316]     }
[18:01:02.316]     ...future.frame <- base::sys.nframe()
[18:01:02.316]     ...future.conditions <- base::list()
[18:01:02.316]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.316]     if (FALSE) {
[18:01:02.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.316]     }
[18:01:02.316]     ...future.result <- base::tryCatch({
[18:01:02.316]         base::withCallingHandlers({
[18:01:02.316]             ...future.value <- base::withVisible(base::local({
[18:01:02.316]                 withCallingHandlers({
[18:01:02.316]                   {
[18:01:02.316]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.316]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.316]                       ...future.globals.maxSize)) {
[18:01:02.316]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.316]                       on.exit(options(oopts), add = TRUE)
[18:01:02.316]                     }
[18:01:02.316]                     {
[18:01:02.316]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.316]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.316]                         USE.NAMES = FALSE)
[18:01:02.316]                       do.call(mapply, args = args)
[18:01:02.316]                     }
[18:01:02.316]                   }
[18:01:02.316]                 }, immediateCondition = function(cond) {
[18:01:02.316]                   save_rds <- function (object, pathname, ...) 
[18:01:02.316]                   {
[18:01:02.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.316]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.316]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.316]                         fi_tmp[["mtime"]])
[18:01:02.316]                     }
[18:01:02.316]                     tryCatch({
[18:01:02.316]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.316]                     }, error = function(ex) {
[18:01:02.316]                       msg <- conditionMessage(ex)
[18:01:02.316]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.316]                         fi_tmp[["mtime"]], msg)
[18:01:02.316]                       ex$message <- msg
[18:01:02.316]                       stop(ex)
[18:01:02.316]                     })
[18:01:02.316]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.316]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.316]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.316]                       fi <- file.info(pathname)
[18:01:02.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.316]                         fi[["size"]], fi[["mtime"]])
[18:01:02.316]                       stop(msg)
[18:01:02.316]                     }
[18:01:02.316]                     invisible(pathname)
[18:01:02.316]                   }
[18:01:02.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.316]                     rootPath = tempdir()) 
[18:01:02.316]                   {
[18:01:02.316]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.316]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.316]                       tmpdir = path, fileext = ".rds")
[18:01:02.316]                     save_rds(obj, file)
[18:01:02.316]                   }
[18:01:02.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.316]                   {
[18:01:02.316]                     inherits <- base::inherits
[18:01:02.316]                     invokeRestart <- base::invokeRestart
[18:01:02.316]                     is.null <- base::is.null
[18:01:02.316]                     muffled <- FALSE
[18:01:02.316]                     if (inherits(cond, "message")) {
[18:01:02.316]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.316]                       if (muffled) 
[18:01:02.316]                         invokeRestart("muffleMessage")
[18:01:02.316]                     }
[18:01:02.316]                     else if (inherits(cond, "warning")) {
[18:01:02.316]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.316]                       if (muffled) 
[18:01:02.316]                         invokeRestart("muffleWarning")
[18:01:02.316]                     }
[18:01:02.316]                     else if (inherits(cond, "condition")) {
[18:01:02.316]                       if (!is.null(pattern)) {
[18:01:02.316]                         computeRestarts <- base::computeRestarts
[18:01:02.316]                         grepl <- base::grepl
[18:01:02.316]                         restarts <- computeRestarts(cond)
[18:01:02.316]                         for (restart in restarts) {
[18:01:02.316]                           name <- restart$name
[18:01:02.316]                           if (is.null(name)) 
[18:01:02.316]                             next
[18:01:02.316]                           if (!grepl(pattern, name)) 
[18:01:02.316]                             next
[18:01:02.316]                           invokeRestart(restart)
[18:01:02.316]                           muffled <- TRUE
[18:01:02.316]                           break
[18:01:02.316]                         }
[18:01:02.316]                       }
[18:01:02.316]                     }
[18:01:02.316]                     invisible(muffled)
[18:01:02.316]                   }
[18:01:02.316]                   muffleCondition(cond)
[18:01:02.316]                 })
[18:01:02.316]             }))
[18:01:02.316]             future::FutureResult(value = ...future.value$value, 
[18:01:02.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.316]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.316]                     ...future.globalenv.names))
[18:01:02.316]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.316]         }, condition = base::local({
[18:01:02.316]             c <- base::c
[18:01:02.316]             inherits <- base::inherits
[18:01:02.316]             invokeRestart <- base::invokeRestart
[18:01:02.316]             length <- base::length
[18:01:02.316]             list <- base::list
[18:01:02.316]             seq.int <- base::seq.int
[18:01:02.316]             signalCondition <- base::signalCondition
[18:01:02.316]             sys.calls <- base::sys.calls
[18:01:02.316]             `[[` <- base::`[[`
[18:01:02.316]             `+` <- base::`+`
[18:01:02.316]             `<<-` <- base::`<<-`
[18:01:02.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.316]                   3L)]
[18:01:02.316]             }
[18:01:02.316]             function(cond) {
[18:01:02.316]                 is_error <- inherits(cond, "error")
[18:01:02.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.316]                   NULL)
[18:01:02.316]                 if (is_error) {
[18:01:02.316]                   sessionInformation <- function() {
[18:01:02.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.316]                       search = base::search(), system = base::Sys.info())
[18:01:02.316]                   }
[18:01:02.316]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.316]                     cond$call), session = sessionInformation(), 
[18:01:02.316]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.316]                   signalCondition(cond)
[18:01:02.316]                 }
[18:01:02.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.316]                 "immediateCondition"))) {
[18:01:02.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.316]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.316]                   if (TRUE && !signal) {
[18:01:02.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.316]                     {
[18:01:02.316]                       inherits <- base::inherits
[18:01:02.316]                       invokeRestart <- base::invokeRestart
[18:01:02.316]                       is.null <- base::is.null
[18:01:02.316]                       muffled <- FALSE
[18:01:02.316]                       if (inherits(cond, "message")) {
[18:01:02.316]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.316]                         if (muffled) 
[18:01:02.316]                           invokeRestart("muffleMessage")
[18:01:02.316]                       }
[18:01:02.316]                       else if (inherits(cond, "warning")) {
[18:01:02.316]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.316]                         if (muffled) 
[18:01:02.316]                           invokeRestart("muffleWarning")
[18:01:02.316]                       }
[18:01:02.316]                       else if (inherits(cond, "condition")) {
[18:01:02.316]                         if (!is.null(pattern)) {
[18:01:02.316]                           computeRestarts <- base::computeRestarts
[18:01:02.316]                           grepl <- base::grepl
[18:01:02.316]                           restarts <- computeRestarts(cond)
[18:01:02.316]                           for (restart in restarts) {
[18:01:02.316]                             name <- restart$name
[18:01:02.316]                             if (is.null(name)) 
[18:01:02.316]                               next
[18:01:02.316]                             if (!grepl(pattern, name)) 
[18:01:02.316]                               next
[18:01:02.316]                             invokeRestart(restart)
[18:01:02.316]                             muffled <- TRUE
[18:01:02.316]                             break
[18:01:02.316]                           }
[18:01:02.316]                         }
[18:01:02.316]                       }
[18:01:02.316]                       invisible(muffled)
[18:01:02.316]                     }
[18:01:02.316]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.316]                   }
[18:01:02.316]                 }
[18:01:02.316]                 else {
[18:01:02.316]                   if (TRUE) {
[18:01:02.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.316]                     {
[18:01:02.316]                       inherits <- base::inherits
[18:01:02.316]                       invokeRestart <- base::invokeRestart
[18:01:02.316]                       is.null <- base::is.null
[18:01:02.316]                       muffled <- FALSE
[18:01:02.316]                       if (inherits(cond, "message")) {
[18:01:02.316]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.316]                         if (muffled) 
[18:01:02.316]                           invokeRestart("muffleMessage")
[18:01:02.316]                       }
[18:01:02.316]                       else if (inherits(cond, "warning")) {
[18:01:02.316]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.316]                         if (muffled) 
[18:01:02.316]                           invokeRestart("muffleWarning")
[18:01:02.316]                       }
[18:01:02.316]                       else if (inherits(cond, "condition")) {
[18:01:02.316]                         if (!is.null(pattern)) {
[18:01:02.316]                           computeRestarts <- base::computeRestarts
[18:01:02.316]                           grepl <- base::grepl
[18:01:02.316]                           restarts <- computeRestarts(cond)
[18:01:02.316]                           for (restart in restarts) {
[18:01:02.316]                             name <- restart$name
[18:01:02.316]                             if (is.null(name)) 
[18:01:02.316]                               next
[18:01:02.316]                             if (!grepl(pattern, name)) 
[18:01:02.316]                               next
[18:01:02.316]                             invokeRestart(restart)
[18:01:02.316]                             muffled <- TRUE
[18:01:02.316]                             break
[18:01:02.316]                           }
[18:01:02.316]                         }
[18:01:02.316]                       }
[18:01:02.316]                       invisible(muffled)
[18:01:02.316]                     }
[18:01:02.316]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.316]                   }
[18:01:02.316]                 }
[18:01:02.316]             }
[18:01:02.316]         }))
[18:01:02.316]     }, error = function(ex) {
[18:01:02.316]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.316]                 ...future.rng), started = ...future.startTime, 
[18:01:02.316]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.316]             version = "1.8"), class = "FutureResult")
[18:01:02.316]     }, finally = {
[18:01:02.316]         if (!identical(...future.workdir, getwd())) 
[18:01:02.316]             setwd(...future.workdir)
[18:01:02.316]         {
[18:01:02.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.316]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.316]             }
[18:01:02.316]             base::options(...future.oldOptions)
[18:01:02.316]             if (.Platform$OS.type == "windows") {
[18:01:02.316]                 old_names <- names(...future.oldEnvVars)
[18:01:02.316]                 envs <- base::Sys.getenv()
[18:01:02.316]                 names <- names(envs)
[18:01:02.316]                 common <- intersect(names, old_names)
[18:01:02.316]                 added <- setdiff(names, old_names)
[18:01:02.316]                 removed <- setdiff(old_names, names)
[18:01:02.316]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.316]                   envs[common]]
[18:01:02.316]                 NAMES <- toupper(changed)
[18:01:02.316]                 args <- list()
[18:01:02.316]                 for (kk in seq_along(NAMES)) {
[18:01:02.316]                   name <- changed[[kk]]
[18:01:02.316]                   NAME <- NAMES[[kk]]
[18:01:02.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.316]                     next
[18:01:02.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.316]                 }
[18:01:02.316]                 NAMES <- toupper(added)
[18:01:02.316]                 for (kk in seq_along(NAMES)) {
[18:01:02.316]                   name <- added[[kk]]
[18:01:02.316]                   NAME <- NAMES[[kk]]
[18:01:02.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.316]                     next
[18:01:02.316]                   args[[name]] <- ""
[18:01:02.316]                 }
[18:01:02.316]                 NAMES <- toupper(removed)
[18:01:02.316]                 for (kk in seq_along(NAMES)) {
[18:01:02.316]                   name <- removed[[kk]]
[18:01:02.316]                   NAME <- NAMES[[kk]]
[18:01:02.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.316]                     next
[18:01:02.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.316]                 }
[18:01:02.316]                 if (length(args) > 0) 
[18:01:02.316]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.316]             }
[18:01:02.316]             else {
[18:01:02.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.316]             }
[18:01:02.316]             {
[18:01:02.316]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.316]                   0L) {
[18:01:02.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.316]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.316]                   base::options(opts)
[18:01:02.316]                 }
[18:01:02.316]                 {
[18:01:02.316]                   {
[18:01:02.316]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.316]                     NULL
[18:01:02.316]                   }
[18:01:02.316]                   options(future.plan = NULL)
[18:01:02.316]                   if (is.na(NA_character_)) 
[18:01:02.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.316]                     .init = FALSE)
[18:01:02.316]                 }
[18:01:02.316]             }
[18:01:02.316]         }
[18:01:02.316]     })
[18:01:02.316]     if (TRUE) {
[18:01:02.316]         base::sink(type = "output", split = FALSE)
[18:01:02.316]         if (TRUE) {
[18:01:02.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.316]         }
[18:01:02.316]         else {
[18:01:02.316]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.316]         }
[18:01:02.316]         base::close(...future.stdout)
[18:01:02.316]         ...future.stdout <- NULL
[18:01:02.316]     }
[18:01:02.316]     ...future.result$conditions <- ...future.conditions
[18:01:02.316]     ...future.result$finished <- base::Sys.time()
[18:01:02.316]     ...future.result
[18:01:02.316] }
[18:01:02.321] assign_globals() ...
[18:01:02.321] List of 5
[18:01:02.321]  $ ...future.FUN            :function (x)  
[18:01:02.321]  $ MoreArgs                 : list()
[18:01:02.321]  $ ...future.elements_ii    :List of 1
[18:01:02.321]   ..$ :List of 1
[18:01:02.321]   .. ..$ : Date[1:1], format: "2018-06-01"
[18:01:02.321]  $ ...future.seeds_ii       : NULL
[18:01:02.321]  $ ...future.globals.maxSize: NULL
[18:01:02.321]  - attr(*, "where")=List of 5
[18:01:02.321]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.321]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.321]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.321]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.321]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.321]  - attr(*, "resolved")= logi FALSE
[18:01:02.321]  - attr(*, "total_size")= num 1128
[18:01:02.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.321]  - attr(*, "already-done")= logi TRUE
[18:01:02.331] - copied ‘...future.FUN’ to environment
[18:01:02.331] - copied ‘MoreArgs’ to environment
[18:01:02.331] - copied ‘...future.elements_ii’ to environment
[18:01:02.331] - copied ‘...future.seeds_ii’ to environment
[18:01:02.331] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.332] assign_globals() ... done
[18:01:02.332] requestCore(): workers = 2
[18:01:02.336] MulticoreFuture started
[18:01:02.337] - Launch lazy future ... done
[18:01:02.337] run() for ‘MulticoreFuture’ ... done
[18:01:02.338] plan(): Setting new future strategy stack:
[18:01:02.338] Created future:
[18:01:02.338] List of future strategies:
[18:01:02.338] 1. sequential:
[18:01:02.338]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.338]    - tweaked: FALSE
[18:01:02.338]    - call: NULL
[18:01:02.340] plan(): nbrOfWorkers() = 1
[18:01:02.347] plan(): Setting new future strategy stack:
[18:01:02.347] List of future strategies:
[18:01:02.347] 1. multicore:
[18:01:02.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.347]    - tweaked: FALSE
[18:01:02.347]    - call: plan(strategy)
[18:01:02.338] MulticoreFuture:
[18:01:02.338] Label: ‘future_.mapply-1’
[18:01:02.338] Expression:
[18:01:02.338] {
[18:01:02.338]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.338]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.338]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.338]         on.exit(options(oopts), add = TRUE)
[18:01:02.338]     }
[18:01:02.338]     {
[18:01:02.338]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.338]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.338]         do.call(mapply, args = args)
[18:01:02.338]     }
[18:01:02.338] }
[18:01:02.338] Lazy evaluation: FALSE
[18:01:02.338] Asynchronous evaluation: TRUE
[18:01:02.338] Local evaluation: TRUE
[18:01:02.338] Environment: R_GlobalEnv
[18:01:02.338] Capture standard output: TRUE
[18:01:02.338] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.338] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.338] Packages: <none>
[18:01:02.338] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.338] Resolved: FALSE
[18:01:02.338] Value: <not collected>
[18:01:02.338] Conditions captured: <none>
[18:01:02.338] Early signaling: FALSE
[18:01:02.338] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.338] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.354] Chunk #1 of 1 ... DONE
[18:01:02.354] Launching 1 futures (chunks) ... DONE
[18:01:02.354] Resolving 1 futures (chunks) ...
[18:01:02.355] resolve() on list ...
[18:01:02.355]  recursive: 0
[18:01:02.355]  length: 1
[18:01:02.356] 
[18:01:02.358] plan(): nbrOfWorkers() = 2
[18:01:02.359] Future #1
[18:01:02.359] result() for MulticoreFuture ...
[18:01:02.361] result() for MulticoreFuture ...
[18:01:02.361] result() for MulticoreFuture ... done
[18:01:02.361] result() for MulticoreFuture ... done
[18:01:02.362] result() for MulticoreFuture ...
[18:01:02.362] result() for MulticoreFuture ... done
[18:01:02.362] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:02.362] - nx: 1
[18:01:02.363] - relay: TRUE
[18:01:02.363] - stdout: TRUE
[18:01:02.363] - signal: TRUE
[18:01:02.363] - resignal: FALSE
[18:01:02.364] - force: TRUE
[18:01:02.364] - relayed: [n=1] FALSE
[18:01:02.364] - queued futures: [n=1] FALSE
[18:01:02.364]  - until=1
[18:01:02.365]  - relaying element #1
[18:01:02.365] result() for MulticoreFuture ...
[18:01:02.365] result() for MulticoreFuture ... done
[18:01:02.365] result() for MulticoreFuture ...
[18:01:02.366] result() for MulticoreFuture ... done
[18:01:02.366] result() for MulticoreFuture ...
[18:01:02.366] result() for MulticoreFuture ... done
[18:01:02.366] result() for MulticoreFuture ...
[18:01:02.367] result() for MulticoreFuture ... done
[18:01:02.367] - relayed: [n=1] TRUE
[18:01:02.367] - queued futures: [n=1] TRUE
[18:01:02.367] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:02.368]  length: 0 (resolved future 1)
[18:01:02.368] Relaying remaining futures
[18:01:02.368] signalConditionsASAP(NULL, pos=0) ...
[18:01:02.368] - nx: 1
[18:01:02.369] - relay: TRUE
[18:01:02.369] - stdout: TRUE
[18:01:02.369] - signal: TRUE
[18:01:02.369] - resignal: FALSE
[18:01:02.369] - force: TRUE
[18:01:02.370] - relayed: [n=1] TRUE
[18:01:02.370] - queued futures: [n=1] TRUE
 - flush all
[18:01:02.370] - relayed: [n=1] TRUE
[18:01:02.371] - queued futures: [n=1] TRUE
[18:01:02.371] signalConditionsASAP(NULL, pos=0) ... done
[18:01:02.371] resolve() on list ... DONE
[18:01:02.371] result() for MulticoreFuture ...
[18:01:02.372] result() for MulticoreFuture ... done
[18:01:02.372] result() for MulticoreFuture ...
[18:01:02.372] result() for MulticoreFuture ... done
[18:01:02.372]  - Number of value chunks collected: 1
[18:01:02.373] Resolving 1 futures (chunks) ... DONE
[18:01:02.373] Reducing values from 1 chunks ...
[18:01:02.373]  - Number of values collected after concatenation: 1
[18:01:02.373]  - Number of values expected: 1
[18:01:02.374] Reducing values from 1 chunks ... DONE
[18:01:02.374] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[18:01:02.374] future_mapply() ...
[18:01:02.386] Number of chunks: 2
[18:01:02.387] getGlobalsAndPackagesXApply() ...
[18:01:02.387]  - future.globals: TRUE
[18:01:02.387] getGlobalsAndPackages() ...
[18:01:02.387] Searching for globals...
[18:01:02.390] - globals found: [1] ‘FUN’
[18:01:02.391] Searching for globals ... DONE
[18:01:02.391] Resolving globals: FALSE
[18:01:02.392] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:01:02.392] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:01:02.393] - globals: [1] ‘FUN’
[18:01:02.393] 
[18:01:02.393] getGlobalsAndPackages() ... DONE
[18:01:02.394]  - globals found/used: [n=1] ‘FUN’
[18:01:02.394]  - needed namespaces: [n=0] 
[18:01:02.394] Finding globals ... DONE
[18:01:02.395] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:02.395] List of 2
[18:01:02.395]  $ ...future.FUN:function (x, y)  
[18:01:02.395]  $ MoreArgs     :List of 1
[18:01:02.395]   ..$ y: int [1:2] 3 4
[18:01:02.395]  - attr(*, "where")=List of 2
[18:01:02.395]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:02.395]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:02.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.395]  - attr(*, "resolved")= logi FALSE
[18:01:02.395]  - attr(*, "total_size")= num NA
[18:01:02.402] Packages to be attached in all futures: [n=0] 
[18:01:02.402] getGlobalsAndPackagesXApply() ... DONE
[18:01:02.402] Number of futures (= number of chunks): 2
[18:01:02.403] Launching 2 futures (chunks) ...
[18:01:02.403] Chunk #1 of 2 ...
[18:01:02.403]  - Finding globals in '...' for chunk #1 ...
[18:01:02.403] getGlobalsAndPackages() ...
[18:01:02.404] Searching for globals...
[18:01:02.404] 
[18:01:02.405] Searching for globals ... DONE
[18:01:02.405] - globals: [0] <none>
[18:01:02.405] getGlobalsAndPackages() ... DONE
[18:01:02.405]    + additional globals found: [n=0] 
[18:01:02.405]    + additional namespaces needed: [n=0] 
[18:01:02.406]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:02.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.406]  - seeds: <none>
[18:01:02.406]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.407] getGlobalsAndPackages() ...
[18:01:02.407] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.407] Resolving globals: FALSE
[18:01:02.408] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:02.409] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:02.409] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.410] 
[18:01:02.410] getGlobalsAndPackages() ... DONE
[18:01:02.410] run() for ‘Future’ ...
[18:01:02.411] - state: ‘created’
[18:01:02.411] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.417] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.418]   - Field: ‘label’
[18:01:02.418]   - Field: ‘local’
[18:01:02.418]   - Field: ‘owner’
[18:01:02.418]   - Field: ‘envir’
[18:01:02.419]   - Field: ‘workers’
[18:01:02.419]   - Field: ‘packages’
[18:01:02.419]   - Field: ‘gc’
[18:01:02.419]   - Field: ‘job’
[18:01:02.419]   - Field: ‘conditions’
[18:01:02.420]   - Field: ‘expr’
[18:01:02.420]   - Field: ‘uuid’
[18:01:02.420]   - Field: ‘seed’
[18:01:02.420]   - Field: ‘version’
[18:01:02.420]   - Field: ‘result’
[18:01:02.421]   - Field: ‘asynchronous’
[18:01:02.421]   - Field: ‘calls’
[18:01:02.421]   - Field: ‘globals’
[18:01:02.421]   - Field: ‘stdout’
[18:01:02.421]   - Field: ‘earlySignal’
[18:01:02.422]   - Field: ‘lazy’
[18:01:02.422]   - Field: ‘state’
[18:01:02.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.422] - Launch lazy future ...
[18:01:02.423] Packages needed by the future expression (n = 0): <none>
[18:01:02.423] Packages needed by future strategies (n = 0): <none>
[18:01:02.424] {
[18:01:02.424]     {
[18:01:02.424]         {
[18:01:02.424]             ...future.startTime <- base::Sys.time()
[18:01:02.424]             {
[18:01:02.424]                 {
[18:01:02.424]                   {
[18:01:02.424]                     {
[18:01:02.424]                       base::local({
[18:01:02.424]                         has_future <- base::requireNamespace("future", 
[18:01:02.424]                           quietly = TRUE)
[18:01:02.424]                         if (has_future) {
[18:01:02.424]                           ns <- base::getNamespace("future")
[18:01:02.424]                           version <- ns[[".package"]][["version"]]
[18:01:02.424]                           if (is.null(version)) 
[18:01:02.424]                             version <- utils::packageVersion("future")
[18:01:02.424]                         }
[18:01:02.424]                         else {
[18:01:02.424]                           version <- NULL
[18:01:02.424]                         }
[18:01:02.424]                         if (!has_future || version < "1.8.0") {
[18:01:02.424]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.424]                             "", base::R.version$version.string), 
[18:01:02.424]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.424]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.424]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.424]                               "release", "version")], collapse = " "), 
[18:01:02.424]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.424]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.424]                             info)
[18:01:02.424]                           info <- base::paste(info, collapse = "; ")
[18:01:02.424]                           if (!has_future) {
[18:01:02.424]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.424]                               info)
[18:01:02.424]                           }
[18:01:02.424]                           else {
[18:01:02.424]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.424]                               info, version)
[18:01:02.424]                           }
[18:01:02.424]                           base::stop(msg)
[18:01:02.424]                         }
[18:01:02.424]                       })
[18:01:02.424]                     }
[18:01:02.424]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.424]                     base::options(mc.cores = 1L)
[18:01:02.424]                   }
[18:01:02.424]                   ...future.strategy.old <- future::plan("list")
[18:01:02.424]                   options(future.plan = NULL)
[18:01:02.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.424]                 }
[18:01:02.424]                 ...future.workdir <- getwd()
[18:01:02.424]             }
[18:01:02.424]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.424]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.424]         }
[18:01:02.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.424]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.424]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.424]             base::names(...future.oldOptions))
[18:01:02.424]     }
[18:01:02.424]     if (FALSE) {
[18:01:02.424]     }
[18:01:02.424]     else {
[18:01:02.424]         if (TRUE) {
[18:01:02.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.424]                 open = "w")
[18:01:02.424]         }
[18:01:02.424]         else {
[18:01:02.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.424]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.424]         }
[18:01:02.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.424]             base::sink(type = "output", split = FALSE)
[18:01:02.424]             base::close(...future.stdout)
[18:01:02.424]         }, add = TRUE)
[18:01:02.424]     }
[18:01:02.424]     ...future.frame <- base::sys.nframe()
[18:01:02.424]     ...future.conditions <- base::list()
[18:01:02.424]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.424]     if (FALSE) {
[18:01:02.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.424]     }
[18:01:02.424]     ...future.result <- base::tryCatch({
[18:01:02.424]         base::withCallingHandlers({
[18:01:02.424]             ...future.value <- base::withVisible(base::local({
[18:01:02.424]                 withCallingHandlers({
[18:01:02.424]                   {
[18:01:02.424]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.424]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.424]                       ...future.globals.maxSize)) {
[18:01:02.424]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.424]                       on.exit(options(oopts), add = TRUE)
[18:01:02.424]                     }
[18:01:02.424]                     {
[18:01:02.424]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.424]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.424]                         USE.NAMES = FALSE)
[18:01:02.424]                       do.call(mapply, args = args)
[18:01:02.424]                     }
[18:01:02.424]                   }
[18:01:02.424]                 }, immediateCondition = function(cond) {
[18:01:02.424]                   save_rds <- function (object, pathname, ...) 
[18:01:02.424]                   {
[18:01:02.424]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.424]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.424]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.424]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.424]                         fi_tmp[["mtime"]])
[18:01:02.424]                     }
[18:01:02.424]                     tryCatch({
[18:01:02.424]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.424]                     }, error = function(ex) {
[18:01:02.424]                       msg <- conditionMessage(ex)
[18:01:02.424]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.424]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.424]                         fi_tmp[["mtime"]], msg)
[18:01:02.424]                       ex$message <- msg
[18:01:02.424]                       stop(ex)
[18:01:02.424]                     })
[18:01:02.424]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.424]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.424]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.424]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.424]                       fi <- file.info(pathname)
[18:01:02.424]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.424]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.424]                         fi[["size"]], fi[["mtime"]])
[18:01:02.424]                       stop(msg)
[18:01:02.424]                     }
[18:01:02.424]                     invisible(pathname)
[18:01:02.424]                   }
[18:01:02.424]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.424]                     rootPath = tempdir()) 
[18:01:02.424]                   {
[18:01:02.424]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.424]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.424]                       tmpdir = path, fileext = ".rds")
[18:01:02.424]                     save_rds(obj, file)
[18:01:02.424]                   }
[18:01:02.424]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.424]                   {
[18:01:02.424]                     inherits <- base::inherits
[18:01:02.424]                     invokeRestart <- base::invokeRestart
[18:01:02.424]                     is.null <- base::is.null
[18:01:02.424]                     muffled <- FALSE
[18:01:02.424]                     if (inherits(cond, "message")) {
[18:01:02.424]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.424]                       if (muffled) 
[18:01:02.424]                         invokeRestart("muffleMessage")
[18:01:02.424]                     }
[18:01:02.424]                     else if (inherits(cond, "warning")) {
[18:01:02.424]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.424]                       if (muffled) 
[18:01:02.424]                         invokeRestart("muffleWarning")
[18:01:02.424]                     }
[18:01:02.424]                     else if (inherits(cond, "condition")) {
[18:01:02.424]                       if (!is.null(pattern)) {
[18:01:02.424]                         computeRestarts <- base::computeRestarts
[18:01:02.424]                         grepl <- base::grepl
[18:01:02.424]                         restarts <- computeRestarts(cond)
[18:01:02.424]                         for (restart in restarts) {
[18:01:02.424]                           name <- restart$name
[18:01:02.424]                           if (is.null(name)) 
[18:01:02.424]                             next
[18:01:02.424]                           if (!grepl(pattern, name)) 
[18:01:02.424]                             next
[18:01:02.424]                           invokeRestart(restart)
[18:01:02.424]                           muffled <- TRUE
[18:01:02.424]                           break
[18:01:02.424]                         }
[18:01:02.424]                       }
[18:01:02.424]                     }
[18:01:02.424]                     invisible(muffled)
[18:01:02.424]                   }
[18:01:02.424]                   muffleCondition(cond)
[18:01:02.424]                 })
[18:01:02.424]             }))
[18:01:02.424]             future::FutureResult(value = ...future.value$value, 
[18:01:02.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.424]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.424]                     ...future.globalenv.names))
[18:01:02.424]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.424]         }, condition = base::local({
[18:01:02.424]             c <- base::c
[18:01:02.424]             inherits <- base::inherits
[18:01:02.424]             invokeRestart <- base::invokeRestart
[18:01:02.424]             length <- base::length
[18:01:02.424]             list <- base::list
[18:01:02.424]             seq.int <- base::seq.int
[18:01:02.424]             signalCondition <- base::signalCondition
[18:01:02.424]             sys.calls <- base::sys.calls
[18:01:02.424]             `[[` <- base::`[[`
[18:01:02.424]             `+` <- base::`+`
[18:01:02.424]             `<<-` <- base::`<<-`
[18:01:02.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.424]                   3L)]
[18:01:02.424]             }
[18:01:02.424]             function(cond) {
[18:01:02.424]                 is_error <- inherits(cond, "error")
[18:01:02.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.424]                   NULL)
[18:01:02.424]                 if (is_error) {
[18:01:02.424]                   sessionInformation <- function() {
[18:01:02.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.424]                       search = base::search(), system = base::Sys.info())
[18:01:02.424]                   }
[18:01:02.424]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.424]                     cond$call), session = sessionInformation(), 
[18:01:02.424]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.424]                   signalCondition(cond)
[18:01:02.424]                 }
[18:01:02.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.424]                 "immediateCondition"))) {
[18:01:02.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.424]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.424]                   if (TRUE && !signal) {
[18:01:02.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.424]                     {
[18:01:02.424]                       inherits <- base::inherits
[18:01:02.424]                       invokeRestart <- base::invokeRestart
[18:01:02.424]                       is.null <- base::is.null
[18:01:02.424]                       muffled <- FALSE
[18:01:02.424]                       if (inherits(cond, "message")) {
[18:01:02.424]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.424]                         if (muffled) 
[18:01:02.424]                           invokeRestart("muffleMessage")
[18:01:02.424]                       }
[18:01:02.424]                       else if (inherits(cond, "warning")) {
[18:01:02.424]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.424]                         if (muffled) 
[18:01:02.424]                           invokeRestart("muffleWarning")
[18:01:02.424]                       }
[18:01:02.424]                       else if (inherits(cond, "condition")) {
[18:01:02.424]                         if (!is.null(pattern)) {
[18:01:02.424]                           computeRestarts <- base::computeRestarts
[18:01:02.424]                           grepl <- base::grepl
[18:01:02.424]                           restarts <- computeRestarts(cond)
[18:01:02.424]                           for (restart in restarts) {
[18:01:02.424]                             name <- restart$name
[18:01:02.424]                             if (is.null(name)) 
[18:01:02.424]                               next
[18:01:02.424]                             if (!grepl(pattern, name)) 
[18:01:02.424]                               next
[18:01:02.424]                             invokeRestart(restart)
[18:01:02.424]                             muffled <- TRUE
[18:01:02.424]                             break
[18:01:02.424]                           }
[18:01:02.424]                         }
[18:01:02.424]                       }
[18:01:02.424]                       invisible(muffled)
[18:01:02.424]                     }
[18:01:02.424]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.424]                   }
[18:01:02.424]                 }
[18:01:02.424]                 else {
[18:01:02.424]                   if (TRUE) {
[18:01:02.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.424]                     {
[18:01:02.424]                       inherits <- base::inherits
[18:01:02.424]                       invokeRestart <- base::invokeRestart
[18:01:02.424]                       is.null <- base::is.null
[18:01:02.424]                       muffled <- FALSE
[18:01:02.424]                       if (inherits(cond, "message")) {
[18:01:02.424]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.424]                         if (muffled) 
[18:01:02.424]                           invokeRestart("muffleMessage")
[18:01:02.424]                       }
[18:01:02.424]                       else if (inherits(cond, "warning")) {
[18:01:02.424]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.424]                         if (muffled) 
[18:01:02.424]                           invokeRestart("muffleWarning")
[18:01:02.424]                       }
[18:01:02.424]                       else if (inherits(cond, "condition")) {
[18:01:02.424]                         if (!is.null(pattern)) {
[18:01:02.424]                           computeRestarts <- base::computeRestarts
[18:01:02.424]                           grepl <- base::grepl
[18:01:02.424]                           restarts <- computeRestarts(cond)
[18:01:02.424]                           for (restart in restarts) {
[18:01:02.424]                             name <- restart$name
[18:01:02.424]                             if (is.null(name)) 
[18:01:02.424]                               next
[18:01:02.424]                             if (!grepl(pattern, name)) 
[18:01:02.424]                               next
[18:01:02.424]                             invokeRestart(restart)
[18:01:02.424]                             muffled <- TRUE
[18:01:02.424]                             break
[18:01:02.424]                           }
[18:01:02.424]                         }
[18:01:02.424]                       }
[18:01:02.424]                       invisible(muffled)
[18:01:02.424]                     }
[18:01:02.424]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.424]                   }
[18:01:02.424]                 }
[18:01:02.424]             }
[18:01:02.424]         }))
[18:01:02.424]     }, error = function(ex) {
[18:01:02.424]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.424]                 ...future.rng), started = ...future.startTime, 
[18:01:02.424]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.424]             version = "1.8"), class = "FutureResult")
[18:01:02.424]     }, finally = {
[18:01:02.424]         if (!identical(...future.workdir, getwd())) 
[18:01:02.424]             setwd(...future.workdir)
[18:01:02.424]         {
[18:01:02.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.424]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.424]             }
[18:01:02.424]             base::options(...future.oldOptions)
[18:01:02.424]             if (.Platform$OS.type == "windows") {
[18:01:02.424]                 old_names <- names(...future.oldEnvVars)
[18:01:02.424]                 envs <- base::Sys.getenv()
[18:01:02.424]                 names <- names(envs)
[18:01:02.424]                 common <- intersect(names, old_names)
[18:01:02.424]                 added <- setdiff(names, old_names)
[18:01:02.424]                 removed <- setdiff(old_names, names)
[18:01:02.424]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.424]                   envs[common]]
[18:01:02.424]                 NAMES <- toupper(changed)
[18:01:02.424]                 args <- list()
[18:01:02.424]                 for (kk in seq_along(NAMES)) {
[18:01:02.424]                   name <- changed[[kk]]
[18:01:02.424]                   NAME <- NAMES[[kk]]
[18:01:02.424]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.424]                     next
[18:01:02.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.424]                 }
[18:01:02.424]                 NAMES <- toupper(added)
[18:01:02.424]                 for (kk in seq_along(NAMES)) {
[18:01:02.424]                   name <- added[[kk]]
[18:01:02.424]                   NAME <- NAMES[[kk]]
[18:01:02.424]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.424]                     next
[18:01:02.424]                   args[[name]] <- ""
[18:01:02.424]                 }
[18:01:02.424]                 NAMES <- toupper(removed)
[18:01:02.424]                 for (kk in seq_along(NAMES)) {
[18:01:02.424]                   name <- removed[[kk]]
[18:01:02.424]                   NAME <- NAMES[[kk]]
[18:01:02.424]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.424]                     next
[18:01:02.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.424]                 }
[18:01:02.424]                 if (length(args) > 0) 
[18:01:02.424]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.424]             }
[18:01:02.424]             else {
[18:01:02.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.424]             }
[18:01:02.424]             {
[18:01:02.424]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.424]                   0L) {
[18:01:02.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.424]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.424]                   base::options(opts)
[18:01:02.424]                 }
[18:01:02.424]                 {
[18:01:02.424]                   {
[18:01:02.424]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.424]                     NULL
[18:01:02.424]                   }
[18:01:02.424]                   options(future.plan = NULL)
[18:01:02.424]                   if (is.na(NA_character_)) 
[18:01:02.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.424]                     .init = FALSE)
[18:01:02.424]                 }
[18:01:02.424]             }
[18:01:02.424]         }
[18:01:02.424]     })
[18:01:02.424]     if (TRUE) {
[18:01:02.424]         base::sink(type = "output", split = FALSE)
[18:01:02.424]         if (TRUE) {
[18:01:02.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.424]         }
[18:01:02.424]         else {
[18:01:02.424]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.424]         }
[18:01:02.424]         base::close(...future.stdout)
[18:01:02.424]         ...future.stdout <- NULL
[18:01:02.424]     }
[18:01:02.424]     ...future.result$conditions <- ...future.conditions
[18:01:02.424]     ...future.result$finished <- base::Sys.time()
[18:01:02.424]     ...future.result
[18:01:02.424] }
[18:01:02.428] assign_globals() ...
[18:01:02.429] List of 5
[18:01:02.429]  $ ...future.FUN            :function (x, y)  
[18:01:02.429]  $ MoreArgs                 :List of 1
[18:01:02.429]   ..$ y: int [1:2] 3 4
[18:01:02.429]  $ ...future.elements_ii    :List of 1
[18:01:02.429]   ..$ x:List of 1
[18:01:02.429]   .. ..$ : int 1
[18:01:02.429]  $ ...future.seeds_ii       : NULL
[18:01:02.429]  $ ...future.globals.maxSize: NULL
[18:01:02.429]  - attr(*, "where")=List of 5
[18:01:02.429]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.429]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.429]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.429]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.429]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.429]  - attr(*, "resolved")= logi FALSE
[18:01:02.429]  - attr(*, "total_size")= num 1816
[18:01:02.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.429]  - attr(*, "already-done")= logi TRUE
[18:01:02.442] - reassign environment for ‘...future.FUN’
[18:01:02.443] - copied ‘...future.FUN’ to environment
[18:01:02.443] - copied ‘MoreArgs’ to environment
[18:01:02.443] - copied ‘...future.elements_ii’ to environment
[18:01:02.443] - copied ‘...future.seeds_ii’ to environment
[18:01:02.444] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.444] assign_globals() ... done
[18:01:02.444] requestCore(): workers = 2
[18:01:02.448] MulticoreFuture started
[18:01:02.449] - Launch lazy future ... done
[18:01:02.450] run() for ‘MulticoreFuture’ ... done
[18:01:02.451] plan(): Setting new future strategy stack:
[18:01:02.452] Created future:
[18:01:02.452] List of future strategies:
[18:01:02.452] 1. sequential:
[18:01:02.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.452]    - tweaked: FALSE
[18:01:02.452]    - call: NULL
[18:01:02.455] plan(): nbrOfWorkers() = 1
[18:01:02.461] plan(): Setting new future strategy stack:
[18:01:02.461] List of future strategies:
[18:01:02.461] 1. multicore:
[18:01:02.461]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.461]    - tweaked: FALSE
[18:01:02.461]    - call: plan(strategy)
[18:01:02.453] MulticoreFuture:
[18:01:02.453] Label: ‘future_mapply-1’
[18:01:02.453] Expression:
[18:01:02.453] {
[18:01:02.453]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.453]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.453]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.453]         on.exit(options(oopts), add = TRUE)
[18:01:02.453]     }
[18:01:02.453]     {
[18:01:02.453]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.453]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.453]         do.call(mapply, args = args)
[18:01:02.453]     }
[18:01:02.453] }
[18:01:02.453] Lazy evaluation: FALSE
[18:01:02.453] Asynchronous evaluation: TRUE
[18:01:02.453] Local evaluation: TRUE
[18:01:02.453] Environment: R_GlobalEnv
[18:01:02.453] Capture standard output: TRUE
[18:01:02.453] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.453] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.453] Packages: <none>
[18:01:02.453] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.453] Resolved: FALSE
[18:01:02.453] Value: <not collected>
[18:01:02.453] Conditions captured: <none>
[18:01:02.453] Early signaling: FALSE
[18:01:02.453] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.453] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.469] Chunk #1 of 2 ... DONE
[18:01:02.470] Chunk #2 of 2 ...
[18:01:02.470]  - Finding globals in '...' for chunk #2 ...
[18:01:02.470] getGlobalsAndPackages() ...
[18:01:02.471] Searching for globals...
[18:01:02.472] plan(): nbrOfWorkers() = 2
[18:01:02.472] 
[18:01:02.472] Searching for globals ... DONE
[18:01:02.472] - globals: [0] <none>
[18:01:02.473] getGlobalsAndPackages() ... DONE
[18:01:02.473]    + additional globals found: [n=0] 
[18:01:02.473]    + additional namespaces needed: [n=0] 
[18:01:02.474]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:02.474]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.474]  - seeds: <none>
[18:01:02.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.475] getGlobalsAndPackages() ...
[18:01:02.475] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.476] Resolving globals: FALSE
[18:01:02.477] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:02.479] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:02.480] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.482] 
[18:01:02.482] getGlobalsAndPackages() ... DONE
[18:01:02.483] run() for ‘Future’ ...
[18:01:02.484] - state: ‘created’
[18:01:02.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.493]   - Field: ‘label’
[18:01:02.494]   - Field: ‘local’
[18:01:02.494]   - Field: ‘owner’
[18:01:02.495]   - Field: ‘envir’
[18:01:02.495]   - Field: ‘workers’
[18:01:02.495]   - Field: ‘packages’
[18:01:02.496]   - Field: ‘gc’
[18:01:02.496]   - Field: ‘job’
[18:01:02.496]   - Field: ‘conditions’
[18:01:02.497]   - Field: ‘expr’
[18:01:02.497]   - Field: ‘uuid’
[18:01:02.497]   - Field: ‘seed’
[18:01:02.498]   - Field: ‘version’
[18:01:02.498]   - Field: ‘result’
[18:01:02.498]   - Field: ‘asynchronous’
[18:01:02.498]   - Field: ‘calls’
[18:01:02.499]   - Field: ‘globals’
[18:01:02.500]   - Field: ‘stdout’
[18:01:02.500]   - Field: ‘earlySignal’
[18:01:02.501]   - Field: ‘lazy’
[18:01:02.501]   - Field: ‘state’
[18:01:02.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.502] - Launch lazy future ...
[18:01:02.502] Packages needed by the future expression (n = 0): <none>
[18:01:02.503] Packages needed by future strategies (n = 0): <none>
[18:01:02.505] {
[18:01:02.505]     {
[18:01:02.505]         {
[18:01:02.505]             ...future.startTime <- base::Sys.time()
[18:01:02.505]             {
[18:01:02.505]                 {
[18:01:02.505]                   {
[18:01:02.505]                     {
[18:01:02.505]                       base::local({
[18:01:02.505]                         has_future <- base::requireNamespace("future", 
[18:01:02.505]                           quietly = TRUE)
[18:01:02.505]                         if (has_future) {
[18:01:02.505]                           ns <- base::getNamespace("future")
[18:01:02.505]                           version <- ns[[".package"]][["version"]]
[18:01:02.505]                           if (is.null(version)) 
[18:01:02.505]                             version <- utils::packageVersion("future")
[18:01:02.505]                         }
[18:01:02.505]                         else {
[18:01:02.505]                           version <- NULL
[18:01:02.505]                         }
[18:01:02.505]                         if (!has_future || version < "1.8.0") {
[18:01:02.505]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.505]                             "", base::R.version$version.string), 
[18:01:02.505]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.505]                               "release", "version")], collapse = " "), 
[18:01:02.505]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.505]                             info)
[18:01:02.505]                           info <- base::paste(info, collapse = "; ")
[18:01:02.505]                           if (!has_future) {
[18:01:02.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.505]                               info)
[18:01:02.505]                           }
[18:01:02.505]                           else {
[18:01:02.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.505]                               info, version)
[18:01:02.505]                           }
[18:01:02.505]                           base::stop(msg)
[18:01:02.505]                         }
[18:01:02.505]                       })
[18:01:02.505]                     }
[18:01:02.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.505]                     base::options(mc.cores = 1L)
[18:01:02.505]                   }
[18:01:02.505]                   ...future.strategy.old <- future::plan("list")
[18:01:02.505]                   options(future.plan = NULL)
[18:01:02.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.505]                 }
[18:01:02.505]                 ...future.workdir <- getwd()
[18:01:02.505]             }
[18:01:02.505]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.505]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.505]         }
[18:01:02.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.505]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.505]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.505]             base::names(...future.oldOptions))
[18:01:02.505]     }
[18:01:02.505]     if (FALSE) {
[18:01:02.505]     }
[18:01:02.505]     else {
[18:01:02.505]         if (TRUE) {
[18:01:02.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.505]                 open = "w")
[18:01:02.505]         }
[18:01:02.505]         else {
[18:01:02.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.505]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.505]         }
[18:01:02.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.505]             base::sink(type = "output", split = FALSE)
[18:01:02.505]             base::close(...future.stdout)
[18:01:02.505]         }, add = TRUE)
[18:01:02.505]     }
[18:01:02.505]     ...future.frame <- base::sys.nframe()
[18:01:02.505]     ...future.conditions <- base::list()
[18:01:02.505]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.505]     if (FALSE) {
[18:01:02.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.505]     }
[18:01:02.505]     ...future.result <- base::tryCatch({
[18:01:02.505]         base::withCallingHandlers({
[18:01:02.505]             ...future.value <- base::withVisible(base::local({
[18:01:02.505]                 withCallingHandlers({
[18:01:02.505]                   {
[18:01:02.505]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.505]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.505]                       ...future.globals.maxSize)) {
[18:01:02.505]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.505]                       on.exit(options(oopts), add = TRUE)
[18:01:02.505]                     }
[18:01:02.505]                     {
[18:01:02.505]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.505]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.505]                         USE.NAMES = FALSE)
[18:01:02.505]                       do.call(mapply, args = args)
[18:01:02.505]                     }
[18:01:02.505]                   }
[18:01:02.505]                 }, immediateCondition = function(cond) {
[18:01:02.505]                   save_rds <- function (object, pathname, ...) 
[18:01:02.505]                   {
[18:01:02.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.505]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.505]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.505]                         fi_tmp[["mtime"]])
[18:01:02.505]                     }
[18:01:02.505]                     tryCatch({
[18:01:02.505]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.505]                     }, error = function(ex) {
[18:01:02.505]                       msg <- conditionMessage(ex)
[18:01:02.505]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.505]                         fi_tmp[["mtime"]], msg)
[18:01:02.505]                       ex$message <- msg
[18:01:02.505]                       stop(ex)
[18:01:02.505]                     })
[18:01:02.505]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.505]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.505]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.505]                       fi <- file.info(pathname)
[18:01:02.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.505]                         fi[["size"]], fi[["mtime"]])
[18:01:02.505]                       stop(msg)
[18:01:02.505]                     }
[18:01:02.505]                     invisible(pathname)
[18:01:02.505]                   }
[18:01:02.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.505]                     rootPath = tempdir()) 
[18:01:02.505]                   {
[18:01:02.505]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.505]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.505]                       tmpdir = path, fileext = ".rds")
[18:01:02.505]                     save_rds(obj, file)
[18:01:02.505]                   }
[18:01:02.505]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.505]                   {
[18:01:02.505]                     inherits <- base::inherits
[18:01:02.505]                     invokeRestart <- base::invokeRestart
[18:01:02.505]                     is.null <- base::is.null
[18:01:02.505]                     muffled <- FALSE
[18:01:02.505]                     if (inherits(cond, "message")) {
[18:01:02.505]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.505]                       if (muffled) 
[18:01:02.505]                         invokeRestart("muffleMessage")
[18:01:02.505]                     }
[18:01:02.505]                     else if (inherits(cond, "warning")) {
[18:01:02.505]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.505]                       if (muffled) 
[18:01:02.505]                         invokeRestart("muffleWarning")
[18:01:02.505]                     }
[18:01:02.505]                     else if (inherits(cond, "condition")) {
[18:01:02.505]                       if (!is.null(pattern)) {
[18:01:02.505]                         computeRestarts <- base::computeRestarts
[18:01:02.505]                         grepl <- base::grepl
[18:01:02.505]                         restarts <- computeRestarts(cond)
[18:01:02.505]                         for (restart in restarts) {
[18:01:02.505]                           name <- restart$name
[18:01:02.505]                           if (is.null(name)) 
[18:01:02.505]                             next
[18:01:02.505]                           if (!grepl(pattern, name)) 
[18:01:02.505]                             next
[18:01:02.505]                           invokeRestart(restart)
[18:01:02.505]                           muffled <- TRUE
[18:01:02.505]                           break
[18:01:02.505]                         }
[18:01:02.505]                       }
[18:01:02.505]                     }
[18:01:02.505]                     invisible(muffled)
[18:01:02.505]                   }
[18:01:02.505]                   muffleCondition(cond)
[18:01:02.505]                 })
[18:01:02.505]             }))
[18:01:02.505]             future::FutureResult(value = ...future.value$value, 
[18:01:02.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.505]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.505]                     ...future.globalenv.names))
[18:01:02.505]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.505]         }, condition = base::local({
[18:01:02.505]             c <- base::c
[18:01:02.505]             inherits <- base::inherits
[18:01:02.505]             invokeRestart <- base::invokeRestart
[18:01:02.505]             length <- base::length
[18:01:02.505]             list <- base::list
[18:01:02.505]             seq.int <- base::seq.int
[18:01:02.505]             signalCondition <- base::signalCondition
[18:01:02.505]             sys.calls <- base::sys.calls
[18:01:02.505]             `[[` <- base::`[[`
[18:01:02.505]             `+` <- base::`+`
[18:01:02.505]             `<<-` <- base::`<<-`
[18:01:02.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.505]                   3L)]
[18:01:02.505]             }
[18:01:02.505]             function(cond) {
[18:01:02.505]                 is_error <- inherits(cond, "error")
[18:01:02.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.505]                   NULL)
[18:01:02.505]                 if (is_error) {
[18:01:02.505]                   sessionInformation <- function() {
[18:01:02.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.505]                       search = base::search(), system = base::Sys.info())
[18:01:02.505]                   }
[18:01:02.505]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.505]                     cond$call), session = sessionInformation(), 
[18:01:02.505]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.505]                   signalCondition(cond)
[18:01:02.505]                 }
[18:01:02.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.505]                 "immediateCondition"))) {
[18:01:02.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.505]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.505]                   if (TRUE && !signal) {
[18:01:02.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.505]                     {
[18:01:02.505]                       inherits <- base::inherits
[18:01:02.505]                       invokeRestart <- base::invokeRestart
[18:01:02.505]                       is.null <- base::is.null
[18:01:02.505]                       muffled <- FALSE
[18:01:02.505]                       if (inherits(cond, "message")) {
[18:01:02.505]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.505]                         if (muffled) 
[18:01:02.505]                           invokeRestart("muffleMessage")
[18:01:02.505]                       }
[18:01:02.505]                       else if (inherits(cond, "warning")) {
[18:01:02.505]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.505]                         if (muffled) 
[18:01:02.505]                           invokeRestart("muffleWarning")
[18:01:02.505]                       }
[18:01:02.505]                       else if (inherits(cond, "condition")) {
[18:01:02.505]                         if (!is.null(pattern)) {
[18:01:02.505]                           computeRestarts <- base::computeRestarts
[18:01:02.505]                           grepl <- base::grepl
[18:01:02.505]                           restarts <- computeRestarts(cond)
[18:01:02.505]                           for (restart in restarts) {
[18:01:02.505]                             name <- restart$name
[18:01:02.505]                             if (is.null(name)) 
[18:01:02.505]                               next
[18:01:02.505]                             if (!grepl(pattern, name)) 
[18:01:02.505]                               next
[18:01:02.505]                             invokeRestart(restart)
[18:01:02.505]                             muffled <- TRUE
[18:01:02.505]                             break
[18:01:02.505]                           }
[18:01:02.505]                         }
[18:01:02.505]                       }
[18:01:02.505]                       invisible(muffled)
[18:01:02.505]                     }
[18:01:02.505]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.505]                   }
[18:01:02.505]                 }
[18:01:02.505]                 else {
[18:01:02.505]                   if (TRUE) {
[18:01:02.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.505]                     {
[18:01:02.505]                       inherits <- base::inherits
[18:01:02.505]                       invokeRestart <- base::invokeRestart
[18:01:02.505]                       is.null <- base::is.null
[18:01:02.505]                       muffled <- FALSE
[18:01:02.505]                       if (inherits(cond, "message")) {
[18:01:02.505]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.505]                         if (muffled) 
[18:01:02.505]                           invokeRestart("muffleMessage")
[18:01:02.505]                       }
[18:01:02.505]                       else if (inherits(cond, "warning")) {
[18:01:02.505]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.505]                         if (muffled) 
[18:01:02.505]                           invokeRestart("muffleWarning")
[18:01:02.505]                       }
[18:01:02.505]                       else if (inherits(cond, "condition")) {
[18:01:02.505]                         if (!is.null(pattern)) {
[18:01:02.505]                           computeRestarts <- base::computeRestarts
[18:01:02.505]                           grepl <- base::grepl
[18:01:02.505]                           restarts <- computeRestarts(cond)
[18:01:02.505]                           for (restart in restarts) {
[18:01:02.505]                             name <- restart$name
[18:01:02.505]                             if (is.null(name)) 
[18:01:02.505]                               next
[18:01:02.505]                             if (!grepl(pattern, name)) 
[18:01:02.505]                               next
[18:01:02.505]                             invokeRestart(restart)
[18:01:02.505]                             muffled <- TRUE
[18:01:02.505]                             break
[18:01:02.505]                           }
[18:01:02.505]                         }
[18:01:02.505]                       }
[18:01:02.505]                       invisible(muffled)
[18:01:02.505]                     }
[18:01:02.505]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.505]                   }
[18:01:02.505]                 }
[18:01:02.505]             }
[18:01:02.505]         }))
[18:01:02.505]     }, error = function(ex) {
[18:01:02.505]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.505]                 ...future.rng), started = ...future.startTime, 
[18:01:02.505]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.505]             version = "1.8"), class = "FutureResult")
[18:01:02.505]     }, finally = {
[18:01:02.505]         if (!identical(...future.workdir, getwd())) 
[18:01:02.505]             setwd(...future.workdir)
[18:01:02.505]         {
[18:01:02.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.505]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.505]             }
[18:01:02.505]             base::options(...future.oldOptions)
[18:01:02.505]             if (.Platform$OS.type == "windows") {
[18:01:02.505]                 old_names <- names(...future.oldEnvVars)
[18:01:02.505]                 envs <- base::Sys.getenv()
[18:01:02.505]                 names <- names(envs)
[18:01:02.505]                 common <- intersect(names, old_names)
[18:01:02.505]                 added <- setdiff(names, old_names)
[18:01:02.505]                 removed <- setdiff(old_names, names)
[18:01:02.505]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.505]                   envs[common]]
[18:01:02.505]                 NAMES <- toupper(changed)
[18:01:02.505]                 args <- list()
[18:01:02.505]                 for (kk in seq_along(NAMES)) {
[18:01:02.505]                   name <- changed[[kk]]
[18:01:02.505]                   NAME <- NAMES[[kk]]
[18:01:02.505]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.505]                     next
[18:01:02.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.505]                 }
[18:01:02.505]                 NAMES <- toupper(added)
[18:01:02.505]                 for (kk in seq_along(NAMES)) {
[18:01:02.505]                   name <- added[[kk]]
[18:01:02.505]                   NAME <- NAMES[[kk]]
[18:01:02.505]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.505]                     next
[18:01:02.505]                   args[[name]] <- ""
[18:01:02.505]                 }
[18:01:02.505]                 NAMES <- toupper(removed)
[18:01:02.505]                 for (kk in seq_along(NAMES)) {
[18:01:02.505]                   name <- removed[[kk]]
[18:01:02.505]                   NAME <- NAMES[[kk]]
[18:01:02.505]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.505]                     next
[18:01:02.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.505]                 }
[18:01:02.505]                 if (length(args) > 0) 
[18:01:02.505]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.505]             }
[18:01:02.505]             else {
[18:01:02.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.505]             }
[18:01:02.505]             {
[18:01:02.505]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.505]                   0L) {
[18:01:02.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.505]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.505]                   base::options(opts)
[18:01:02.505]                 }
[18:01:02.505]                 {
[18:01:02.505]                   {
[18:01:02.505]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.505]                     NULL
[18:01:02.505]                   }
[18:01:02.505]                   options(future.plan = NULL)
[18:01:02.505]                   if (is.na(NA_character_)) 
[18:01:02.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.505]                     .init = FALSE)
[18:01:02.505]                 }
[18:01:02.505]             }
[18:01:02.505]         }
[18:01:02.505]     })
[18:01:02.505]     if (TRUE) {
[18:01:02.505]         base::sink(type = "output", split = FALSE)
[18:01:02.505]         if (TRUE) {
[18:01:02.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.505]         }
[18:01:02.505]         else {
[18:01:02.505]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.505]         }
[18:01:02.505]         base::close(...future.stdout)
[18:01:02.505]         ...future.stdout <- NULL
[18:01:02.505]     }
[18:01:02.505]     ...future.result$conditions <- ...future.conditions
[18:01:02.505]     ...future.result$finished <- base::Sys.time()
[18:01:02.505]     ...future.result
[18:01:02.505] }
[18:01:02.512] assign_globals() ...
[18:01:02.512] List of 5
[18:01:02.512]  $ ...future.FUN            :function (x, y)  
[18:01:02.512]  $ MoreArgs                 :List of 1
[18:01:02.512]   ..$ y: int [1:2] 3 4
[18:01:02.512]  $ ...future.elements_ii    :List of 1
[18:01:02.512]   ..$ x:List of 1
[18:01:02.512]   .. ..$ : int 2
[18:01:02.512]  $ ...future.seeds_ii       : NULL
[18:01:02.512]  $ ...future.globals.maxSize: NULL
[18:01:02.512]  - attr(*, "where")=List of 5
[18:01:02.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.512]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.512]  - attr(*, "resolved")= logi FALSE
[18:01:02.512]  - attr(*, "total_size")= num 1816
[18:01:02.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.512]  - attr(*, "already-done")= logi TRUE
[18:01:02.537] - reassign environment for ‘...future.FUN’
[18:01:02.537] - copied ‘...future.FUN’ to environment
[18:01:02.537] - copied ‘MoreArgs’ to environment
[18:01:02.537] - copied ‘...future.elements_ii’ to environment
[18:01:02.538] - copied ‘...future.seeds_ii’ to environment
[18:01:02.538] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.538] assign_globals() ... done
[18:01:02.538] requestCore(): workers = 2
[18:01:02.542] MulticoreFuture started
[18:01:02.544] - Launch lazy future ... done
[18:01:02.545] plan(): Setting new future strategy stack:
[18:01:02.545] run() for ‘MulticoreFuture’ ... done
[18:01:02.546] Created future:
[18:01:02.546] List of future strategies:
[18:01:02.546] 1. sequential:
[18:01:02.546]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.546]    - tweaked: FALSE
[18:01:02.546]    - call: NULL
[18:01:02.549] plan(): nbrOfWorkers() = 1
[18:01:02.556] plan(): Setting new future strategy stack:
[18:01:02.556] List of future strategies:
[18:01:02.556] 1. multicore:
[18:01:02.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.556]    - tweaked: FALSE
[18:01:02.556]    - call: plan(strategy)
[18:01:02.547] MulticoreFuture:
[18:01:02.547] Label: ‘future_mapply-2’
[18:01:02.547] Expression:
[18:01:02.547] {
[18:01:02.547]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.547]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.547]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.547]         on.exit(options(oopts), add = TRUE)
[18:01:02.547]     }
[18:01:02.547]     {
[18:01:02.547]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.547]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.547]         do.call(mapply, args = args)
[18:01:02.547]     }
[18:01:02.547] }
[18:01:02.547] Lazy evaluation: FALSE
[18:01:02.547] Asynchronous evaluation: TRUE
[18:01:02.547] Local evaluation: TRUE
[18:01:02.547] Environment: R_GlobalEnv
[18:01:02.547] Capture standard output: TRUE
[18:01:02.547] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.547] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.547] Packages: <none>
[18:01:02.547] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.547] Resolved: FALSE
[18:01:02.547] Value: <not collected>
[18:01:02.547] Conditions captured: <none>
[18:01:02.547] Early signaling: FALSE
[18:01:02.547] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.547] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.568] Chunk #2 of 2 ... DONE
[18:01:02.568] Launching 2 futures (chunks) ... DONE
[18:01:02.568] plan(): nbrOfWorkers() = 2
[18:01:02.569] Resolving 2 futures (chunks) ...
[18:01:02.569] resolve() on list ...
[18:01:02.570]  recursive: 0
[18:01:02.570]  length: 2
[18:01:02.570] 
[18:01:02.571] Future #1
[18:01:02.572] result() for MulticoreFuture ...
[18:01:02.574] result() for MulticoreFuture ...
[18:01:02.574] result() for MulticoreFuture ... done
[18:01:02.577] result() for MulticoreFuture ... done
[18:01:02.578] result() for MulticoreFuture ...
[18:01:02.578] result() for MulticoreFuture ... done
[18:01:02.579] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:02.581] - nx: 2
[18:01:02.582] - relay: TRUE
[18:01:02.582] - stdout: TRUE
[18:01:02.582] - signal: TRUE
[18:01:02.583] - resignal: FALSE
[18:01:02.583] - force: TRUE
[18:01:02.584] - relayed: [n=2] FALSE, FALSE
[18:01:02.584] - queued futures: [n=2] FALSE, FALSE
[18:01:02.585]  - until=1
[18:01:02.585]  - relaying element #1
[18:01:02.586] result() for MulticoreFuture ...
[18:01:02.586] result() for MulticoreFuture ... done
[18:01:02.587] result() for MulticoreFuture ...
[18:01:02.588] result() for MulticoreFuture ... done
[18:01:02.588] result() for MulticoreFuture ...
[18:01:02.589] result() for MulticoreFuture ... done
[18:01:02.589] result() for MulticoreFuture ...
[18:01:02.589] result() for MulticoreFuture ... done
[18:01:02.590] - relayed: [n=2] TRUE, FALSE
[18:01:02.590] - queued futures: [n=2] TRUE, FALSE
[18:01:02.591] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:02.591]  length: 1 (resolved future 1)
[18:01:02.592] Future #2
[18:01:02.592] result() for MulticoreFuture ...
[18:01:02.593] result() for MulticoreFuture ...
[18:01:02.594] result() for MulticoreFuture ... done
[18:01:02.594] result() for MulticoreFuture ... done
[18:01:02.594] result() for MulticoreFuture ...
[18:01:02.595] result() for MulticoreFuture ... done
[18:01:02.595] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:02.595] - nx: 2
[18:01:02.595] - relay: TRUE
[18:01:02.596] - stdout: TRUE
[18:01:02.596] - signal: TRUE
[18:01:02.596] - resignal: FALSE
[18:01:02.597] - force: TRUE
[18:01:02.597] - relayed: [n=2] TRUE, FALSE
[18:01:02.597] - queued futures: [n=2] TRUE, FALSE
[18:01:02.597]  - until=2
[18:01:02.598]  - relaying element #2
[18:01:02.598] result() for MulticoreFuture ...
[18:01:02.598] result() for MulticoreFuture ... done
[18:01:02.598] result() for MulticoreFuture ...
[18:01:02.599] result() for MulticoreFuture ... done
[18:01:02.599] result() for MulticoreFuture ...
[18:01:02.599] result() for MulticoreFuture ... done
[18:01:02.599] result() for MulticoreFuture ...
[18:01:02.600] result() for MulticoreFuture ... done
[18:01:02.600] - relayed: [n=2] TRUE, TRUE
[18:01:02.600] - queued futures: [n=2] TRUE, TRUE
[18:01:02.600] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:02.601]  length: 0 (resolved future 2)
[18:01:02.601] Relaying remaining futures
[18:01:02.601] signalConditionsASAP(NULL, pos=0) ...
[18:01:02.601] - nx: 2
[18:01:02.601] - relay: TRUE
[18:01:02.601] - stdout: TRUE
[18:01:02.602] - signal: TRUE
[18:01:02.602] - resignal: FALSE
[18:01:02.602] - force: TRUE
[18:01:02.602] - relayed: [n=2] TRUE, TRUE
[18:01:02.602] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:02.603] - relayed: [n=2] TRUE, TRUE
[18:01:02.603] - queued futures: [n=2] TRUE, TRUE
[18:01:02.603] signalConditionsASAP(NULL, pos=0) ... done
[18:01:02.603] resolve() on list ... DONE
[18:01:02.604] result() for MulticoreFuture ...
[18:01:02.604] result() for MulticoreFuture ... done
[18:01:02.604] result() for MulticoreFuture ...
[18:01:02.604] result() for MulticoreFuture ... done
[18:01:02.605] result() for MulticoreFuture ...
[18:01:02.605] result() for MulticoreFuture ... done
[18:01:02.605] result() for MulticoreFuture ...
[18:01:02.605] result() for MulticoreFuture ... done
[18:01:02.605]  - Number of value chunks collected: 2
[18:01:02.606] Resolving 2 futures (chunks) ... DONE
[18:01:02.606] Reducing values from 2 chunks ...
[18:01:02.606]  - Number of values collected after concatenation: 2
[18:01:02.606]  - Number of values expected: 2
[18:01:02.606] Reducing values from 2 chunks ... DONE
[18:01:02.607] future_mapply() ... DONE
[18:01:02.607] future_mapply() ...
[18:01:02.607] Generating random seeds ...
[18:01:02.607] Generating random seed streams for 2 elements ...
[18:01:02.608] Generating random seed streams for 2 elements ... DONE
[18:01:02.608] Generating random seeds ... DONE
[18:01:02.608] Will set RNG state on exit: 10407, 1045937781, 17499034, 24920035, -65150472, -1168778898, 85963198
[18:01:02.615] Number of chunks: 2
[18:01:02.615] getGlobalsAndPackagesXApply() ...
[18:01:02.616]  - future.globals: TRUE
[18:01:02.616] getGlobalsAndPackages() ...
[18:01:02.616] Searching for globals...
[18:01:02.618] - globals found: [1] ‘FUN’
[18:01:02.619] Searching for globals ... DONE
[18:01:02.619] Resolving globals: FALSE
[18:01:02.619] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:01:02.620] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:01:02.620] - globals: [1] ‘FUN’
[18:01:02.621] 
[18:01:02.621] getGlobalsAndPackages() ... DONE
[18:01:02.621]  - globals found/used: [n=1] ‘FUN’
[18:01:02.621]  - needed namespaces: [n=0] 
[18:01:02.621] Finding globals ... DONE
[18:01:02.622] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:02.622] List of 2
[18:01:02.622]  $ ...future.FUN:function (x, y)  
[18:01:02.622]  $ MoreArgs     :List of 1
[18:01:02.622]   ..$ y: int [1:2] 3 4
[18:01:02.622]  - attr(*, "where")=List of 2
[18:01:02.622]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:02.622]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:02.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.622]  - attr(*, "resolved")= logi FALSE
[18:01:02.622]  - attr(*, "total_size")= num NA
[18:01:02.632] Packages to be attached in all futures: [n=0] 
[18:01:02.632] getGlobalsAndPackagesXApply() ... DONE
[18:01:02.632] Number of futures (= number of chunks): 2
[18:01:02.633] Launching 2 futures (chunks) ...
[18:01:02.633] Chunk #1 of 2 ...
[18:01:02.633]  - Finding globals in '...' for chunk #1 ...
[18:01:02.633] getGlobalsAndPackages() ...
[18:01:02.633] Searching for globals...
[18:01:02.634] 
[18:01:02.634] Searching for globals ... DONE
[18:01:02.635] - globals: [0] <none>
[18:01:02.635] getGlobalsAndPackages() ... DONE
[18:01:02.635]    + additional globals found: [n=0] 
[18:01:02.635]    + additional namespaces needed: [n=0] 
[18:01:02.635]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:02.636]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.636]  - seeds: [1] <seeds>
[18:01:02.636]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.636] getGlobalsAndPackages() ...
[18:01:02.636] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.637] Resolving globals: FALSE
[18:01:02.638] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[18:01:02.639] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:01:02.639] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.639] 
[18:01:02.639] getGlobalsAndPackages() ... DONE
[18:01:02.640] run() for ‘Future’ ...
[18:01:02.640] - state: ‘created’
[18:01:02.641] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.647] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.648]   - Field: ‘label’
[18:01:02.648]   - Field: ‘local’
[18:01:02.648]   - Field: ‘owner’
[18:01:02.648]   - Field: ‘envir’
[18:01:02.649]   - Field: ‘workers’
[18:01:02.649]   - Field: ‘packages’
[18:01:02.649]   - Field: ‘gc’
[18:01:02.649]   - Field: ‘job’
[18:01:02.650]   - Field: ‘conditions’
[18:01:02.650]   - Field: ‘expr’
[18:01:02.650]   - Field: ‘uuid’
[18:01:02.650]   - Field: ‘seed’
[18:01:02.650]   - Field: ‘version’
[18:01:02.651]   - Field: ‘result’
[18:01:02.651]   - Field: ‘asynchronous’
[18:01:02.651]   - Field: ‘calls’
[18:01:02.651]   - Field: ‘globals’
[18:01:02.651]   - Field: ‘stdout’
[18:01:02.651]   - Field: ‘earlySignal’
[18:01:02.652]   - Field: ‘lazy’
[18:01:02.652]   - Field: ‘state’
[18:01:02.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.652] - Launch lazy future ...
[18:01:02.653] Packages needed by the future expression (n = 0): <none>
[18:01:02.653] Packages needed by future strategies (n = 0): <none>
[18:01:02.654] {
[18:01:02.654]     {
[18:01:02.654]         {
[18:01:02.654]             ...future.startTime <- base::Sys.time()
[18:01:02.654]             {
[18:01:02.654]                 {
[18:01:02.654]                   {
[18:01:02.654]                     {
[18:01:02.654]                       base::local({
[18:01:02.654]                         has_future <- base::requireNamespace("future", 
[18:01:02.654]                           quietly = TRUE)
[18:01:02.654]                         if (has_future) {
[18:01:02.654]                           ns <- base::getNamespace("future")
[18:01:02.654]                           version <- ns[[".package"]][["version"]]
[18:01:02.654]                           if (is.null(version)) 
[18:01:02.654]                             version <- utils::packageVersion("future")
[18:01:02.654]                         }
[18:01:02.654]                         else {
[18:01:02.654]                           version <- NULL
[18:01:02.654]                         }
[18:01:02.654]                         if (!has_future || version < "1.8.0") {
[18:01:02.654]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.654]                             "", base::R.version$version.string), 
[18:01:02.654]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.654]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.654]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.654]                               "release", "version")], collapse = " "), 
[18:01:02.654]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.654]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.654]                             info)
[18:01:02.654]                           info <- base::paste(info, collapse = "; ")
[18:01:02.654]                           if (!has_future) {
[18:01:02.654]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.654]                               info)
[18:01:02.654]                           }
[18:01:02.654]                           else {
[18:01:02.654]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.654]                               info, version)
[18:01:02.654]                           }
[18:01:02.654]                           base::stop(msg)
[18:01:02.654]                         }
[18:01:02.654]                       })
[18:01:02.654]                     }
[18:01:02.654]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.654]                     base::options(mc.cores = 1L)
[18:01:02.654]                   }
[18:01:02.654]                   ...future.strategy.old <- future::plan("list")
[18:01:02.654]                   options(future.plan = NULL)
[18:01:02.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.654]                 }
[18:01:02.654]                 ...future.workdir <- getwd()
[18:01:02.654]             }
[18:01:02.654]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.654]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.654]         }
[18:01:02.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.654]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.654]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.654]             base::names(...future.oldOptions))
[18:01:02.654]     }
[18:01:02.654]     if (FALSE) {
[18:01:02.654]     }
[18:01:02.654]     else {
[18:01:02.654]         if (TRUE) {
[18:01:02.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.654]                 open = "w")
[18:01:02.654]         }
[18:01:02.654]         else {
[18:01:02.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.654]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.654]         }
[18:01:02.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.654]             base::sink(type = "output", split = FALSE)
[18:01:02.654]             base::close(...future.stdout)
[18:01:02.654]         }, add = TRUE)
[18:01:02.654]     }
[18:01:02.654]     ...future.frame <- base::sys.nframe()
[18:01:02.654]     ...future.conditions <- base::list()
[18:01:02.654]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.654]     if (FALSE) {
[18:01:02.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.654]     }
[18:01:02.654]     ...future.result <- base::tryCatch({
[18:01:02.654]         base::withCallingHandlers({
[18:01:02.654]             ...future.value <- base::withVisible(base::local({
[18:01:02.654]                 withCallingHandlers({
[18:01:02.654]                   {
[18:01:02.654]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.654]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.654]                       ...future.globals.maxSize)) {
[18:01:02.654]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.654]                       on.exit(options(oopts), add = TRUE)
[18:01:02.654]                     }
[18:01:02.654]                     {
[18:01:02.654]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:02.654]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:02.654]                           envir = globalenv(), inherits = FALSE)
[18:01:02.654]                         ...future.FUN(...)
[18:01:02.654]                       }
[18:01:02.654]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:02.654]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:02.654]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.654]                         USE.NAMES = FALSE)
[18:01:02.654]                       do.call(mapply, args = args)
[18:01:02.654]                     }
[18:01:02.654]                   }
[18:01:02.654]                 }, immediateCondition = function(cond) {
[18:01:02.654]                   save_rds <- function (object, pathname, ...) 
[18:01:02.654]                   {
[18:01:02.654]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.654]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.654]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.654]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.654]                         fi_tmp[["mtime"]])
[18:01:02.654]                     }
[18:01:02.654]                     tryCatch({
[18:01:02.654]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.654]                     }, error = function(ex) {
[18:01:02.654]                       msg <- conditionMessage(ex)
[18:01:02.654]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.654]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.654]                         fi_tmp[["mtime"]], msg)
[18:01:02.654]                       ex$message <- msg
[18:01:02.654]                       stop(ex)
[18:01:02.654]                     })
[18:01:02.654]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.654]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.654]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.654]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.654]                       fi <- file.info(pathname)
[18:01:02.654]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.654]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.654]                         fi[["size"]], fi[["mtime"]])
[18:01:02.654]                       stop(msg)
[18:01:02.654]                     }
[18:01:02.654]                     invisible(pathname)
[18:01:02.654]                   }
[18:01:02.654]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.654]                     rootPath = tempdir()) 
[18:01:02.654]                   {
[18:01:02.654]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.654]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.654]                       tmpdir = path, fileext = ".rds")
[18:01:02.654]                     save_rds(obj, file)
[18:01:02.654]                   }
[18:01:02.654]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.654]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.654]                   {
[18:01:02.654]                     inherits <- base::inherits
[18:01:02.654]                     invokeRestart <- base::invokeRestart
[18:01:02.654]                     is.null <- base::is.null
[18:01:02.654]                     muffled <- FALSE
[18:01:02.654]                     if (inherits(cond, "message")) {
[18:01:02.654]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.654]                       if (muffled) 
[18:01:02.654]                         invokeRestart("muffleMessage")
[18:01:02.654]                     }
[18:01:02.654]                     else if (inherits(cond, "warning")) {
[18:01:02.654]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.654]                       if (muffled) 
[18:01:02.654]                         invokeRestart("muffleWarning")
[18:01:02.654]                     }
[18:01:02.654]                     else if (inherits(cond, "condition")) {
[18:01:02.654]                       if (!is.null(pattern)) {
[18:01:02.654]                         computeRestarts <- base::computeRestarts
[18:01:02.654]                         grepl <- base::grepl
[18:01:02.654]                         restarts <- computeRestarts(cond)
[18:01:02.654]                         for (restart in restarts) {
[18:01:02.654]                           name <- restart$name
[18:01:02.654]                           if (is.null(name)) 
[18:01:02.654]                             next
[18:01:02.654]                           if (!grepl(pattern, name)) 
[18:01:02.654]                             next
[18:01:02.654]                           invokeRestart(restart)
[18:01:02.654]                           muffled <- TRUE
[18:01:02.654]                           break
[18:01:02.654]                         }
[18:01:02.654]                       }
[18:01:02.654]                     }
[18:01:02.654]                     invisible(muffled)
[18:01:02.654]                   }
[18:01:02.654]                   muffleCondition(cond)
[18:01:02.654]                 })
[18:01:02.654]             }))
[18:01:02.654]             future::FutureResult(value = ...future.value$value, 
[18:01:02.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.654]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.654]                     ...future.globalenv.names))
[18:01:02.654]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.654]         }, condition = base::local({
[18:01:02.654]             c <- base::c
[18:01:02.654]             inherits <- base::inherits
[18:01:02.654]             invokeRestart <- base::invokeRestart
[18:01:02.654]             length <- base::length
[18:01:02.654]             list <- base::list
[18:01:02.654]             seq.int <- base::seq.int
[18:01:02.654]             signalCondition <- base::signalCondition
[18:01:02.654]             sys.calls <- base::sys.calls
[18:01:02.654]             `[[` <- base::`[[`
[18:01:02.654]             `+` <- base::`+`
[18:01:02.654]             `<<-` <- base::`<<-`
[18:01:02.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.654]                   3L)]
[18:01:02.654]             }
[18:01:02.654]             function(cond) {
[18:01:02.654]                 is_error <- inherits(cond, "error")
[18:01:02.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.654]                   NULL)
[18:01:02.654]                 if (is_error) {
[18:01:02.654]                   sessionInformation <- function() {
[18:01:02.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.654]                       search = base::search(), system = base::Sys.info())
[18:01:02.654]                   }
[18:01:02.654]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.654]                     cond$call), session = sessionInformation(), 
[18:01:02.654]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.654]                   signalCondition(cond)
[18:01:02.654]                 }
[18:01:02.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.654]                 "immediateCondition"))) {
[18:01:02.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.654]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.654]                   if (TRUE && !signal) {
[18:01:02.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.654]                     {
[18:01:02.654]                       inherits <- base::inherits
[18:01:02.654]                       invokeRestart <- base::invokeRestart
[18:01:02.654]                       is.null <- base::is.null
[18:01:02.654]                       muffled <- FALSE
[18:01:02.654]                       if (inherits(cond, "message")) {
[18:01:02.654]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.654]                         if (muffled) 
[18:01:02.654]                           invokeRestart("muffleMessage")
[18:01:02.654]                       }
[18:01:02.654]                       else if (inherits(cond, "warning")) {
[18:01:02.654]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.654]                         if (muffled) 
[18:01:02.654]                           invokeRestart("muffleWarning")
[18:01:02.654]                       }
[18:01:02.654]                       else if (inherits(cond, "condition")) {
[18:01:02.654]                         if (!is.null(pattern)) {
[18:01:02.654]                           computeRestarts <- base::computeRestarts
[18:01:02.654]                           grepl <- base::grepl
[18:01:02.654]                           restarts <- computeRestarts(cond)
[18:01:02.654]                           for (restart in restarts) {
[18:01:02.654]                             name <- restart$name
[18:01:02.654]                             if (is.null(name)) 
[18:01:02.654]                               next
[18:01:02.654]                             if (!grepl(pattern, name)) 
[18:01:02.654]                               next
[18:01:02.654]                             invokeRestart(restart)
[18:01:02.654]                             muffled <- TRUE
[18:01:02.654]                             break
[18:01:02.654]                           }
[18:01:02.654]                         }
[18:01:02.654]                       }
[18:01:02.654]                       invisible(muffled)
[18:01:02.654]                     }
[18:01:02.654]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.654]                   }
[18:01:02.654]                 }
[18:01:02.654]                 else {
[18:01:02.654]                   if (TRUE) {
[18:01:02.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.654]                     {
[18:01:02.654]                       inherits <- base::inherits
[18:01:02.654]                       invokeRestart <- base::invokeRestart
[18:01:02.654]                       is.null <- base::is.null
[18:01:02.654]                       muffled <- FALSE
[18:01:02.654]                       if (inherits(cond, "message")) {
[18:01:02.654]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.654]                         if (muffled) 
[18:01:02.654]                           invokeRestart("muffleMessage")
[18:01:02.654]                       }
[18:01:02.654]                       else if (inherits(cond, "warning")) {
[18:01:02.654]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.654]                         if (muffled) 
[18:01:02.654]                           invokeRestart("muffleWarning")
[18:01:02.654]                       }
[18:01:02.654]                       else if (inherits(cond, "condition")) {
[18:01:02.654]                         if (!is.null(pattern)) {
[18:01:02.654]                           computeRestarts <- base::computeRestarts
[18:01:02.654]                           grepl <- base::grepl
[18:01:02.654]                           restarts <- computeRestarts(cond)
[18:01:02.654]                           for (restart in restarts) {
[18:01:02.654]                             name <- restart$name
[18:01:02.654]                             if (is.null(name)) 
[18:01:02.654]                               next
[18:01:02.654]                             if (!grepl(pattern, name)) 
[18:01:02.654]                               next
[18:01:02.654]                             invokeRestart(restart)
[18:01:02.654]                             muffled <- TRUE
[18:01:02.654]                             break
[18:01:02.654]                           }
[18:01:02.654]                         }
[18:01:02.654]                       }
[18:01:02.654]                       invisible(muffled)
[18:01:02.654]                     }
[18:01:02.654]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.654]                   }
[18:01:02.654]                 }
[18:01:02.654]             }
[18:01:02.654]         }))
[18:01:02.654]     }, error = function(ex) {
[18:01:02.654]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.654]                 ...future.rng), started = ...future.startTime, 
[18:01:02.654]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.654]             version = "1.8"), class = "FutureResult")
[18:01:02.654]     }, finally = {
[18:01:02.654]         if (!identical(...future.workdir, getwd())) 
[18:01:02.654]             setwd(...future.workdir)
[18:01:02.654]         {
[18:01:02.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.654]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.654]             }
[18:01:02.654]             base::options(...future.oldOptions)
[18:01:02.654]             if (.Platform$OS.type == "windows") {
[18:01:02.654]                 old_names <- names(...future.oldEnvVars)
[18:01:02.654]                 envs <- base::Sys.getenv()
[18:01:02.654]                 names <- names(envs)
[18:01:02.654]                 common <- intersect(names, old_names)
[18:01:02.654]                 added <- setdiff(names, old_names)
[18:01:02.654]                 removed <- setdiff(old_names, names)
[18:01:02.654]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.654]                   envs[common]]
[18:01:02.654]                 NAMES <- toupper(changed)
[18:01:02.654]                 args <- list()
[18:01:02.654]                 for (kk in seq_along(NAMES)) {
[18:01:02.654]                   name <- changed[[kk]]
[18:01:02.654]                   NAME <- NAMES[[kk]]
[18:01:02.654]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.654]                     next
[18:01:02.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.654]                 }
[18:01:02.654]                 NAMES <- toupper(added)
[18:01:02.654]                 for (kk in seq_along(NAMES)) {
[18:01:02.654]                   name <- added[[kk]]
[18:01:02.654]                   NAME <- NAMES[[kk]]
[18:01:02.654]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.654]                     next
[18:01:02.654]                   args[[name]] <- ""
[18:01:02.654]                 }
[18:01:02.654]                 NAMES <- toupper(removed)
[18:01:02.654]                 for (kk in seq_along(NAMES)) {
[18:01:02.654]                   name <- removed[[kk]]
[18:01:02.654]                   NAME <- NAMES[[kk]]
[18:01:02.654]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.654]                     next
[18:01:02.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.654]                 }
[18:01:02.654]                 if (length(args) > 0) 
[18:01:02.654]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.654]             }
[18:01:02.654]             else {
[18:01:02.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.654]             }
[18:01:02.654]             {
[18:01:02.654]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.654]                   0L) {
[18:01:02.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.654]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.654]                   base::options(opts)
[18:01:02.654]                 }
[18:01:02.654]                 {
[18:01:02.654]                   {
[18:01:02.654]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.654]                     NULL
[18:01:02.654]                   }
[18:01:02.654]                   options(future.plan = NULL)
[18:01:02.654]                   if (is.na(NA_character_)) 
[18:01:02.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.654]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.654]                     .init = FALSE)
[18:01:02.654]                 }
[18:01:02.654]             }
[18:01:02.654]         }
[18:01:02.654]     })
[18:01:02.654]     if (TRUE) {
[18:01:02.654]         base::sink(type = "output", split = FALSE)
[18:01:02.654]         if (TRUE) {
[18:01:02.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.654]         }
[18:01:02.654]         else {
[18:01:02.654]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.654]         }
[18:01:02.654]         base::close(...future.stdout)
[18:01:02.654]         ...future.stdout <- NULL
[18:01:02.654]     }
[18:01:02.654]     ...future.result$conditions <- ...future.conditions
[18:01:02.654]     ...future.result$finished <- base::Sys.time()
[18:01:02.654]     ...future.result
[18:01:02.654] }
[18:01:02.659] assign_globals() ...
[18:01:02.659] List of 5
[18:01:02.659]  $ ...future.FUN            :function (x, y)  
[18:01:02.659]  $ MoreArgs                 :List of 1
[18:01:02.659]   ..$ y: int [1:2] 3 4
[18:01:02.659]  $ ...future.elements_ii    :List of 1
[18:01:02.659]   ..$ x:List of 1
[18:01:02.659]   .. ..$ : int 1
[18:01:02.659]  $ ...future.seeds_ii       :List of 1
[18:01:02.659]   ..$ : int [1:7] 10407 2005298240 -865085701 -1868974702 -135787310 778150089 804132632
[18:01:02.659]  $ ...future.globals.maxSize: NULL
[18:01:02.659]  - attr(*, "where")=List of 5
[18:01:02.659]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.659]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.659]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.659]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.659]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.659]  - attr(*, "resolved")= logi FALSE
[18:01:02.659]  - attr(*, "total_size")= num 1896
[18:01:02.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.659]  - attr(*, "already-done")= logi TRUE
[18:01:02.670] - reassign environment for ‘...future.FUN’
[18:01:02.670] - copied ‘...future.FUN’ to environment
[18:01:02.670] - copied ‘MoreArgs’ to environment
[18:01:02.670] - copied ‘...future.elements_ii’ to environment
[18:01:02.671] - copied ‘...future.seeds_ii’ to environment
[18:01:02.671] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.671] assign_globals() ... done
[18:01:02.671] requestCore(): workers = 2
[18:01:02.675] MulticoreFuture started
[18:01:02.676] - Launch lazy future ... done
[18:01:02.676] run() for ‘MulticoreFuture’ ... done
[18:01:02.677] Created future:
[18:01:02.677] plan(): Setting new future strategy stack:
[18:01:02.677] List of future strategies:
[18:01:02.677] 1. sequential:
[18:01:02.677]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.677]    - tweaked: FALSE
[18:01:02.677]    - call: NULL
[18:01:02.679] plan(): nbrOfWorkers() = 1
[18:01:02.684] plan(): Setting new future strategy stack:
[18:01:02.684] List of future strategies:
[18:01:02.684] 1. multicore:
[18:01:02.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.684]    - tweaked: FALSE
[18:01:02.684]    - call: plan(strategy)
[18:01:02.677] MulticoreFuture:
[18:01:02.677] Label: ‘future_mapply-1’
[18:01:02.677] Expression:
[18:01:02.677] {
[18:01:02.677]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.677]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.677]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.677]         on.exit(options(oopts), add = TRUE)
[18:01:02.677]     }
[18:01:02.677]     {
[18:01:02.677]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:02.677]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:02.677]                 inherits = FALSE)
[18:01:02.677]             ...future.FUN(...)
[18:01:02.677]         }
[18:01:02.677]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:02.677]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:02.677]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.677]         do.call(mapply, args = args)
[18:01:02.677]     }
[18:01:02.677] }
[18:01:02.677] Lazy evaluation: FALSE
[18:01:02.677] Asynchronous evaluation: TRUE
[18:01:02.677] Local evaluation: TRUE
[18:01:02.677] Environment: R_GlobalEnv
[18:01:02.677] Capture standard output: TRUE
[18:01:02.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.677] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.677] Packages: <none>
[18:01:02.677] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:02.677] Resolved: FALSE
[18:01:02.677] Value: <not collected>
[18:01:02.677] Conditions captured: <none>
[18:01:02.677] Early signaling: FALSE
[18:01:02.677] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.677] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.692] Chunk #1 of 2 ... DONE
[18:01:02.693] Chunk #2 of 2 ...
[18:01:02.693]  - Finding globals in '...' for chunk #2 ...
[18:01:02.694] getGlobalsAndPackages() ...
[18:01:02.694] Searching for globals...
[18:01:02.695] plan(): nbrOfWorkers() = 2
[18:01:02.695] 
[18:01:02.695] Searching for globals ... DONE
[18:01:02.696] - globals: [0] <none>
[18:01:02.696] getGlobalsAndPackages() ... DONE
[18:01:02.696]    + additional globals found: [n=0] 
[18:01:02.696]    + additional namespaces needed: [n=0] 
[18:01:02.697]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:02.697]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.697]  - seeds: [1] <seeds>
[18:01:02.698]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.698] getGlobalsAndPackages() ...
[18:01:02.698] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.699] Resolving globals: FALSE
[18:01:02.707] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[18:01:02.709] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:01:02.710] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.711] 
[18:01:02.711] getGlobalsAndPackages() ... DONE
[18:01:02.713] run() for ‘Future’ ...
[18:01:02.713] - state: ‘created’
[18:01:02.714] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.725] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.726]   - Field: ‘label’
[18:01:02.726]   - Field: ‘local’
[18:01:02.727]   - Field: ‘owner’
[18:01:02.727]   - Field: ‘envir’
[18:01:02.727]   - Field: ‘workers’
[18:01:02.728]   - Field: ‘packages’
[18:01:02.728]   - Field: ‘gc’
[18:01:02.729]   - Field: ‘job’
[18:01:02.729]   - Field: ‘conditions’
[18:01:02.730]   - Field: ‘expr’
[18:01:02.730]   - Field: ‘uuid’
[18:01:02.730]   - Field: ‘seed’
[18:01:02.731]   - Field: ‘version’
[18:01:02.731]   - Field: ‘result’
[18:01:02.732]   - Field: ‘asynchronous’
[18:01:02.732]   - Field: ‘calls’
[18:01:02.732]   - Field: ‘globals’
[18:01:02.733]   - Field: ‘stdout’
[18:01:02.733]   - Field: ‘earlySignal’
[18:01:02.733]   - Field: ‘lazy’
[18:01:02.734]   - Field: ‘state’
[18:01:02.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.735] - Launch lazy future ...
[18:01:02.736] Packages needed by the future expression (n = 0): <none>
[18:01:02.736] Packages needed by future strategies (n = 0): <none>
[18:01:02.738] {
[18:01:02.738]     {
[18:01:02.738]         {
[18:01:02.738]             ...future.startTime <- base::Sys.time()
[18:01:02.738]             {
[18:01:02.738]                 {
[18:01:02.738]                   {
[18:01:02.738]                     {
[18:01:02.738]                       base::local({
[18:01:02.738]                         has_future <- base::requireNamespace("future", 
[18:01:02.738]                           quietly = TRUE)
[18:01:02.738]                         if (has_future) {
[18:01:02.738]                           ns <- base::getNamespace("future")
[18:01:02.738]                           version <- ns[[".package"]][["version"]]
[18:01:02.738]                           if (is.null(version)) 
[18:01:02.738]                             version <- utils::packageVersion("future")
[18:01:02.738]                         }
[18:01:02.738]                         else {
[18:01:02.738]                           version <- NULL
[18:01:02.738]                         }
[18:01:02.738]                         if (!has_future || version < "1.8.0") {
[18:01:02.738]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.738]                             "", base::R.version$version.string), 
[18:01:02.738]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.738]                               "release", "version")], collapse = " "), 
[18:01:02.738]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.738]                             info)
[18:01:02.738]                           info <- base::paste(info, collapse = "; ")
[18:01:02.738]                           if (!has_future) {
[18:01:02.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.738]                               info)
[18:01:02.738]                           }
[18:01:02.738]                           else {
[18:01:02.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.738]                               info, version)
[18:01:02.738]                           }
[18:01:02.738]                           base::stop(msg)
[18:01:02.738]                         }
[18:01:02.738]                       })
[18:01:02.738]                     }
[18:01:02.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.738]                     base::options(mc.cores = 1L)
[18:01:02.738]                   }
[18:01:02.738]                   ...future.strategy.old <- future::plan("list")
[18:01:02.738]                   options(future.plan = NULL)
[18:01:02.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.738]                 }
[18:01:02.738]                 ...future.workdir <- getwd()
[18:01:02.738]             }
[18:01:02.738]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.738]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.738]         }
[18:01:02.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.738]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.738]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.738]             base::names(...future.oldOptions))
[18:01:02.738]     }
[18:01:02.738]     if (FALSE) {
[18:01:02.738]     }
[18:01:02.738]     else {
[18:01:02.738]         if (TRUE) {
[18:01:02.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.738]                 open = "w")
[18:01:02.738]         }
[18:01:02.738]         else {
[18:01:02.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.738]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.738]         }
[18:01:02.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.738]             base::sink(type = "output", split = FALSE)
[18:01:02.738]             base::close(...future.stdout)
[18:01:02.738]         }, add = TRUE)
[18:01:02.738]     }
[18:01:02.738]     ...future.frame <- base::sys.nframe()
[18:01:02.738]     ...future.conditions <- base::list()
[18:01:02.738]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.738]     if (FALSE) {
[18:01:02.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.738]     }
[18:01:02.738]     ...future.result <- base::tryCatch({
[18:01:02.738]         base::withCallingHandlers({
[18:01:02.738]             ...future.value <- base::withVisible(base::local({
[18:01:02.738]                 withCallingHandlers({
[18:01:02.738]                   {
[18:01:02.738]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.738]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.738]                       ...future.globals.maxSize)) {
[18:01:02.738]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.738]                       on.exit(options(oopts), add = TRUE)
[18:01:02.738]                     }
[18:01:02.738]                     {
[18:01:02.738]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:02.738]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:02.738]                           envir = globalenv(), inherits = FALSE)
[18:01:02.738]                         ...future.FUN(...)
[18:01:02.738]                       }
[18:01:02.738]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:02.738]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:02.738]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.738]                         USE.NAMES = FALSE)
[18:01:02.738]                       do.call(mapply, args = args)
[18:01:02.738]                     }
[18:01:02.738]                   }
[18:01:02.738]                 }, immediateCondition = function(cond) {
[18:01:02.738]                   save_rds <- function (object, pathname, ...) 
[18:01:02.738]                   {
[18:01:02.738]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.738]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.738]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.738]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.738]                         fi_tmp[["mtime"]])
[18:01:02.738]                     }
[18:01:02.738]                     tryCatch({
[18:01:02.738]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.738]                     }, error = function(ex) {
[18:01:02.738]                       msg <- conditionMessage(ex)
[18:01:02.738]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.738]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.738]                         fi_tmp[["mtime"]], msg)
[18:01:02.738]                       ex$message <- msg
[18:01:02.738]                       stop(ex)
[18:01:02.738]                     })
[18:01:02.738]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.738]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.738]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.738]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.738]                       fi <- file.info(pathname)
[18:01:02.738]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.738]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.738]                         fi[["size"]], fi[["mtime"]])
[18:01:02.738]                       stop(msg)
[18:01:02.738]                     }
[18:01:02.738]                     invisible(pathname)
[18:01:02.738]                   }
[18:01:02.738]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.738]                     rootPath = tempdir()) 
[18:01:02.738]                   {
[18:01:02.738]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.738]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.738]                       tmpdir = path, fileext = ".rds")
[18:01:02.738]                     save_rds(obj, file)
[18:01:02.738]                   }
[18:01:02.738]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.738]                   {
[18:01:02.738]                     inherits <- base::inherits
[18:01:02.738]                     invokeRestart <- base::invokeRestart
[18:01:02.738]                     is.null <- base::is.null
[18:01:02.738]                     muffled <- FALSE
[18:01:02.738]                     if (inherits(cond, "message")) {
[18:01:02.738]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.738]                       if (muffled) 
[18:01:02.738]                         invokeRestart("muffleMessage")
[18:01:02.738]                     }
[18:01:02.738]                     else if (inherits(cond, "warning")) {
[18:01:02.738]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.738]                       if (muffled) 
[18:01:02.738]                         invokeRestart("muffleWarning")
[18:01:02.738]                     }
[18:01:02.738]                     else if (inherits(cond, "condition")) {
[18:01:02.738]                       if (!is.null(pattern)) {
[18:01:02.738]                         computeRestarts <- base::computeRestarts
[18:01:02.738]                         grepl <- base::grepl
[18:01:02.738]                         restarts <- computeRestarts(cond)
[18:01:02.738]                         for (restart in restarts) {
[18:01:02.738]                           name <- restart$name
[18:01:02.738]                           if (is.null(name)) 
[18:01:02.738]                             next
[18:01:02.738]                           if (!grepl(pattern, name)) 
[18:01:02.738]                             next
[18:01:02.738]                           invokeRestart(restart)
[18:01:02.738]                           muffled <- TRUE
[18:01:02.738]                           break
[18:01:02.738]                         }
[18:01:02.738]                       }
[18:01:02.738]                     }
[18:01:02.738]                     invisible(muffled)
[18:01:02.738]                   }
[18:01:02.738]                   muffleCondition(cond)
[18:01:02.738]                 })
[18:01:02.738]             }))
[18:01:02.738]             future::FutureResult(value = ...future.value$value, 
[18:01:02.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.738]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.738]                     ...future.globalenv.names))
[18:01:02.738]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.738]         }, condition = base::local({
[18:01:02.738]             c <- base::c
[18:01:02.738]             inherits <- base::inherits
[18:01:02.738]             invokeRestart <- base::invokeRestart
[18:01:02.738]             length <- base::length
[18:01:02.738]             list <- base::list
[18:01:02.738]             seq.int <- base::seq.int
[18:01:02.738]             signalCondition <- base::signalCondition
[18:01:02.738]             sys.calls <- base::sys.calls
[18:01:02.738]             `[[` <- base::`[[`
[18:01:02.738]             `+` <- base::`+`
[18:01:02.738]             `<<-` <- base::`<<-`
[18:01:02.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.738]                   3L)]
[18:01:02.738]             }
[18:01:02.738]             function(cond) {
[18:01:02.738]                 is_error <- inherits(cond, "error")
[18:01:02.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.738]                   NULL)
[18:01:02.738]                 if (is_error) {
[18:01:02.738]                   sessionInformation <- function() {
[18:01:02.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.738]                       search = base::search(), system = base::Sys.info())
[18:01:02.738]                   }
[18:01:02.738]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.738]                     cond$call), session = sessionInformation(), 
[18:01:02.738]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.738]                   signalCondition(cond)
[18:01:02.738]                 }
[18:01:02.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.738]                 "immediateCondition"))) {
[18:01:02.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.738]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.738]                   if (TRUE && !signal) {
[18:01:02.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.738]                     {
[18:01:02.738]                       inherits <- base::inherits
[18:01:02.738]                       invokeRestart <- base::invokeRestart
[18:01:02.738]                       is.null <- base::is.null
[18:01:02.738]                       muffled <- FALSE
[18:01:02.738]                       if (inherits(cond, "message")) {
[18:01:02.738]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.738]                         if (muffled) 
[18:01:02.738]                           invokeRestart("muffleMessage")
[18:01:02.738]                       }
[18:01:02.738]                       else if (inherits(cond, "warning")) {
[18:01:02.738]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.738]                         if (muffled) 
[18:01:02.738]                           invokeRestart("muffleWarning")
[18:01:02.738]                       }
[18:01:02.738]                       else if (inherits(cond, "condition")) {
[18:01:02.738]                         if (!is.null(pattern)) {
[18:01:02.738]                           computeRestarts <- base::computeRestarts
[18:01:02.738]                           grepl <- base::grepl
[18:01:02.738]                           restarts <- computeRestarts(cond)
[18:01:02.738]                           for (restart in restarts) {
[18:01:02.738]                             name <- restart$name
[18:01:02.738]                             if (is.null(name)) 
[18:01:02.738]                               next
[18:01:02.738]                             if (!grepl(pattern, name)) 
[18:01:02.738]                               next
[18:01:02.738]                             invokeRestart(restart)
[18:01:02.738]                             muffled <- TRUE
[18:01:02.738]                             break
[18:01:02.738]                           }
[18:01:02.738]                         }
[18:01:02.738]                       }
[18:01:02.738]                       invisible(muffled)
[18:01:02.738]                     }
[18:01:02.738]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.738]                   }
[18:01:02.738]                 }
[18:01:02.738]                 else {
[18:01:02.738]                   if (TRUE) {
[18:01:02.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.738]                     {
[18:01:02.738]                       inherits <- base::inherits
[18:01:02.738]                       invokeRestart <- base::invokeRestart
[18:01:02.738]                       is.null <- base::is.null
[18:01:02.738]                       muffled <- FALSE
[18:01:02.738]                       if (inherits(cond, "message")) {
[18:01:02.738]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.738]                         if (muffled) 
[18:01:02.738]                           invokeRestart("muffleMessage")
[18:01:02.738]                       }
[18:01:02.738]                       else if (inherits(cond, "warning")) {
[18:01:02.738]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.738]                         if (muffled) 
[18:01:02.738]                           invokeRestart("muffleWarning")
[18:01:02.738]                       }
[18:01:02.738]                       else if (inherits(cond, "condition")) {
[18:01:02.738]                         if (!is.null(pattern)) {
[18:01:02.738]                           computeRestarts <- base::computeRestarts
[18:01:02.738]                           grepl <- base::grepl
[18:01:02.738]                           restarts <- computeRestarts(cond)
[18:01:02.738]                           for (restart in restarts) {
[18:01:02.738]                             name <- restart$name
[18:01:02.738]                             if (is.null(name)) 
[18:01:02.738]                               next
[18:01:02.738]                             if (!grepl(pattern, name)) 
[18:01:02.738]                               next
[18:01:02.738]                             invokeRestart(restart)
[18:01:02.738]                             muffled <- TRUE
[18:01:02.738]                             break
[18:01:02.738]                           }
[18:01:02.738]                         }
[18:01:02.738]                       }
[18:01:02.738]                       invisible(muffled)
[18:01:02.738]                     }
[18:01:02.738]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.738]                   }
[18:01:02.738]                 }
[18:01:02.738]             }
[18:01:02.738]         }))
[18:01:02.738]     }, error = function(ex) {
[18:01:02.738]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.738]                 ...future.rng), started = ...future.startTime, 
[18:01:02.738]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.738]             version = "1.8"), class = "FutureResult")
[18:01:02.738]     }, finally = {
[18:01:02.738]         if (!identical(...future.workdir, getwd())) 
[18:01:02.738]             setwd(...future.workdir)
[18:01:02.738]         {
[18:01:02.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.738]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.738]             }
[18:01:02.738]             base::options(...future.oldOptions)
[18:01:02.738]             if (.Platform$OS.type == "windows") {
[18:01:02.738]                 old_names <- names(...future.oldEnvVars)
[18:01:02.738]                 envs <- base::Sys.getenv()
[18:01:02.738]                 names <- names(envs)
[18:01:02.738]                 common <- intersect(names, old_names)
[18:01:02.738]                 added <- setdiff(names, old_names)
[18:01:02.738]                 removed <- setdiff(old_names, names)
[18:01:02.738]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.738]                   envs[common]]
[18:01:02.738]                 NAMES <- toupper(changed)
[18:01:02.738]                 args <- list()
[18:01:02.738]                 for (kk in seq_along(NAMES)) {
[18:01:02.738]                   name <- changed[[kk]]
[18:01:02.738]                   NAME <- NAMES[[kk]]
[18:01:02.738]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.738]                     next
[18:01:02.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.738]                 }
[18:01:02.738]                 NAMES <- toupper(added)
[18:01:02.738]                 for (kk in seq_along(NAMES)) {
[18:01:02.738]                   name <- added[[kk]]
[18:01:02.738]                   NAME <- NAMES[[kk]]
[18:01:02.738]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.738]                     next
[18:01:02.738]                   args[[name]] <- ""
[18:01:02.738]                 }
[18:01:02.738]                 NAMES <- toupper(removed)
[18:01:02.738]                 for (kk in seq_along(NAMES)) {
[18:01:02.738]                   name <- removed[[kk]]
[18:01:02.738]                   NAME <- NAMES[[kk]]
[18:01:02.738]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.738]                     next
[18:01:02.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.738]                 }
[18:01:02.738]                 if (length(args) > 0) 
[18:01:02.738]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.738]             }
[18:01:02.738]             else {
[18:01:02.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.738]             }
[18:01:02.738]             {
[18:01:02.738]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.738]                   0L) {
[18:01:02.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.738]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.738]                   base::options(opts)
[18:01:02.738]                 }
[18:01:02.738]                 {
[18:01:02.738]                   {
[18:01:02.738]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.738]                     NULL
[18:01:02.738]                   }
[18:01:02.738]                   options(future.plan = NULL)
[18:01:02.738]                   if (is.na(NA_character_)) 
[18:01:02.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.738]                     .init = FALSE)
[18:01:02.738]                 }
[18:01:02.738]             }
[18:01:02.738]         }
[18:01:02.738]     })
[18:01:02.738]     if (TRUE) {
[18:01:02.738]         base::sink(type = "output", split = FALSE)
[18:01:02.738]         if (TRUE) {
[18:01:02.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.738]         }
[18:01:02.738]         else {
[18:01:02.738]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.738]         }
[18:01:02.738]         base::close(...future.stdout)
[18:01:02.738]         ...future.stdout <- NULL
[18:01:02.738]     }
[18:01:02.738]     ...future.result$conditions <- ...future.conditions
[18:01:02.738]     ...future.result$finished <- base::Sys.time()
[18:01:02.738]     ...future.result
[18:01:02.738] }
[18:01:02.744] assign_globals() ...
[18:01:02.744] List of 5
[18:01:02.744]  $ ...future.FUN            :function (x, y)  
[18:01:02.744]  $ MoreArgs                 :List of 1
[18:01:02.744]   ..$ y: int [1:2] 3 4
[18:01:02.744]  $ ...future.elements_ii    :List of 1
[18:01:02.744]   ..$ x:List of 1
[18:01:02.744]   .. ..$ : int 2
[18:01:02.744]  $ ...future.seeds_ii       :List of 1
[18:01:02.744]   ..$ : int [1:7] 10407 127215552 -2091796 -1035913148 -827166400 818150426 403598120
[18:01:02.744]  $ ...future.globals.maxSize: NULL
[18:01:02.744]  - attr(*, "where")=List of 5
[18:01:02.744]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.744]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.744]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.744]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.744]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.744]  - attr(*, "resolved")= logi FALSE
[18:01:02.744]  - attr(*, "total_size")= num 1896
[18:01:02.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.744]  - attr(*, "already-done")= logi TRUE
[18:01:02.759] - reassign environment for ‘...future.FUN’
[18:01:02.759] - copied ‘...future.FUN’ to environment
[18:01:02.760] - copied ‘MoreArgs’ to environment
[18:01:02.760] - copied ‘...future.elements_ii’ to environment
[18:01:02.760] - copied ‘...future.seeds_ii’ to environment
[18:01:02.760] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.761] assign_globals() ... done
[18:01:02.761] requestCore(): workers = 2
[18:01:02.765] MulticoreFuture started
[18:01:02.765] - Launch lazy future ... done
[18:01:02.766] run() for ‘MulticoreFuture’ ... done
[18:01:02.766] Created future:
[18:01:02.766] plan(): Setting new future strategy stack:
[18:01:02.767] List of future strategies:
[18:01:02.767] 1. sequential:
[18:01:02.767]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.767]    - tweaked: FALSE
[18:01:02.767]    - call: NULL
[18:01:02.769] plan(): nbrOfWorkers() = 1
[18:01:02.774] plan(): Setting new future strategy stack:
[18:01:02.774] List of future strategies:
[18:01:02.774] 1. multicore:
[18:01:02.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.774]    - tweaked: FALSE
[18:01:02.774]    - call: plan(strategy)
[18:01:02.767] MulticoreFuture:
[18:01:02.767] Label: ‘future_mapply-2’
[18:01:02.767] Expression:
[18:01:02.767] {
[18:01:02.767]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.767]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.767]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.767]         on.exit(options(oopts), add = TRUE)
[18:01:02.767]     }
[18:01:02.767]     {
[18:01:02.767]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:02.767]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:02.767]                 inherits = FALSE)
[18:01:02.767]             ...future.FUN(...)
[18:01:02.767]         }
[18:01:02.767]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:02.767]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:02.767]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.767]         do.call(mapply, args = args)
[18:01:02.767]     }
[18:01:02.767] }
[18:01:02.767] Lazy evaluation: FALSE
[18:01:02.767] Asynchronous evaluation: TRUE
[18:01:02.767] Local evaluation: TRUE
[18:01:02.767] Environment: R_GlobalEnv
[18:01:02.767] Capture standard output: TRUE
[18:01:02.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.767] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.767] Packages: <none>
[18:01:02.767] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:02.767] Resolved: FALSE
[18:01:02.767] Value: <not collected>
[18:01:02.767] Conditions captured: <none>
[18:01:02.767] Early signaling: FALSE
[18:01:02.767] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.767] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.782] Chunk #2 of 2 ... DONE
[18:01:02.782] Launching 2 futures (chunks) ... DONE
[18:01:02.783] Resolving 2 futures (chunks) ...
[18:01:02.784] plan(): nbrOfWorkers() = 2
[18:01:02.785] resolve() on list ...
[18:01:02.785]  recursive: 0
[18:01:02.785]  length: 2
[18:01:02.786] 
[18:01:02.787] Future #1
[18:01:02.787] result() for MulticoreFuture ...
[18:01:02.792] result() for MulticoreFuture ...
[18:01:02.792] result() for MulticoreFuture ... done
[18:01:02.792] result() for MulticoreFuture ... done
[18:01:02.792] result() for MulticoreFuture ...
[18:01:02.793] result() for MulticoreFuture ... done
[18:01:02.793] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:02.794] - nx: 2
[18:01:02.796] - relay: TRUE
[18:01:02.796] - stdout: TRUE
[18:01:02.796] - signal: TRUE
[18:01:02.797] - resignal: FALSE
[18:01:02.797] - force: TRUE
[18:01:02.797] - relayed: [n=2] FALSE, FALSE
[18:01:02.798] - queued futures: [n=2] FALSE, FALSE
[18:01:02.798]  - until=1
[18:01:02.798]  - relaying element #1
[18:01:02.799] result() for MulticoreFuture ...
[18:01:02.799] result() for MulticoreFuture ... done
[18:01:02.800] result() for MulticoreFuture ...
[18:01:02.800] result() for MulticoreFuture ... done
[18:01:02.800] result() for MulticoreFuture ...
[18:01:02.801] result() for MulticoreFuture ... done
[18:01:02.801] result() for MulticoreFuture ...
[18:01:02.802] result() for MulticoreFuture ... done
[18:01:02.802] - relayed: [n=2] TRUE, FALSE
[18:01:02.802] - queued futures: [n=2] TRUE, FALSE
[18:01:02.803] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:02.803]  length: 1 (resolved future 1)
[18:01:02.804] Future #2
[18:01:02.804] result() for MulticoreFuture ...
[18:01:02.806] result() for MulticoreFuture ...
[18:01:02.807] result() for MulticoreFuture ... done
[18:01:02.808] result() for MulticoreFuture ... done
[18:01:02.810] result() for MulticoreFuture ...
[18:01:02.810] result() for MulticoreFuture ... done
[18:01:02.811] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:02.811] - nx: 2
[18:01:02.811] - relay: TRUE
[18:01:02.817] - stdout: TRUE
[18:01:02.818] - signal: TRUE
[18:01:02.818] - resignal: FALSE
[18:01:02.818] - force: TRUE
[18:01:02.819] - relayed: [n=2] TRUE, FALSE
[18:01:02.819] - queued futures: [n=2] TRUE, FALSE
[18:01:02.820]  - until=2
[18:01:02.820]  - relaying element #2
[18:01:02.820] result() for MulticoreFuture ...
[18:01:02.821] result() for MulticoreFuture ... done
[18:01:02.821] result() for MulticoreFuture ...
[18:01:02.821] result() for MulticoreFuture ... done
[18:01:02.822] result() for MulticoreFuture ...
[18:01:02.822] result() for MulticoreFuture ... done
[18:01:02.822] result() for MulticoreFuture ...
[18:01:02.822] result() for MulticoreFuture ... done
[18:01:02.823] - relayed: [n=2] TRUE, TRUE
[18:01:02.823] - queued futures: [n=2] TRUE, TRUE
[18:01:02.823] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:02.824]  length: 0 (resolved future 2)
[18:01:02.824] Relaying remaining futures
[18:01:02.824] signalConditionsASAP(NULL, pos=0) ...
[18:01:02.825] - nx: 2
[18:01:02.825] - relay: TRUE
[18:01:02.825] - stdout: TRUE
[18:01:02.826] - signal: TRUE
[18:01:02.826] - resignal: FALSE
[18:01:02.826] - force: TRUE
[18:01:02.826] - relayed: [n=2] TRUE, TRUE
[18:01:02.827] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:02.827] - relayed: [n=2] TRUE, TRUE
[18:01:02.827] - queued futures: [n=2] TRUE, TRUE
[18:01:02.827] signalConditionsASAP(NULL, pos=0) ... done
[18:01:02.828] resolve() on list ... DONE
[18:01:02.828] result() for MulticoreFuture ...
[18:01:02.828] result() for MulticoreFuture ... done
[18:01:02.829] result() for MulticoreFuture ...
[18:01:02.829] result() for MulticoreFuture ... done
[18:01:02.829] result() for MulticoreFuture ...
[18:01:02.829] result() for MulticoreFuture ... done
[18:01:02.830] result() for MulticoreFuture ...
[18:01:02.830] result() for MulticoreFuture ... done
[18:01:02.830]  - Number of value chunks collected: 2
[18:01:02.831] Resolving 2 futures (chunks) ... DONE
[18:01:02.831] Reducing values from 2 chunks ...
[18:01:02.831]  - Number of values collected after concatenation: 2
[18:01:02.831]  - Number of values expected: 2
[18:01:02.832] Reducing values from 2 chunks ... DONE
[18:01:02.832] future_mapply() ... DONE
[18:01:02.832] future_mapply() ...
[18:01:02.840] Number of chunks: 2
[18:01:02.840] getGlobalsAndPackagesXApply() ...
[18:01:02.841]  - future.globals: TRUE
[18:01:02.841] getGlobalsAndPackages() ...
[18:01:02.841] Searching for globals...
[18:01:02.844] - globals found: [1] ‘FUN’
[18:01:02.844] Searching for globals ... DONE
[18:01:02.845] Resolving globals: FALSE
[18:01:02.845] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:01:02.846] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:01:02.847] - globals: [1] ‘FUN’
[18:01:02.847] 
[18:01:02.847] getGlobalsAndPackages() ... DONE
[18:01:02.847]  - globals found/used: [n=1] ‘FUN’
[18:01:02.848]  - needed namespaces: [n=0] 
[18:01:02.848] Finding globals ... DONE
[18:01:02.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:02.849] List of 2
[18:01:02.849]  $ ...future.FUN:function (x, y)  
[18:01:02.849]  $ MoreArgs     :List of 1
[18:01:02.849]   ..$ y: int [1:2] 3 4
[18:01:02.849]  - attr(*, "where")=List of 2
[18:01:02.849]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:02.849]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:02.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.849]  - attr(*, "resolved")= logi FALSE
[18:01:02.849]  - attr(*, "total_size")= num NA
[18:01:02.856] Packages to be attached in all futures: [n=0] 
[18:01:02.856] getGlobalsAndPackagesXApply() ... DONE
[18:01:02.856] Number of futures (= number of chunks): 2
[18:01:02.857] Launching 2 futures (chunks) ...
[18:01:02.857] Chunk #1 of 2 ...
[18:01:02.857]  - Finding globals in '...' for chunk #1 ...
[18:01:02.857] getGlobalsAndPackages() ...
[18:01:02.858] Searching for globals...
[18:01:02.858] 
[18:01:02.858] Searching for globals ... DONE
[18:01:02.859] - globals: [0] <none>
[18:01:02.859] getGlobalsAndPackages() ... DONE
[18:01:02.859]    + additional globals found: [n=0] 
[18:01:02.859]    + additional namespaces needed: [n=0] 
[18:01:02.860]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:02.860]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.860]  - seeds: <none>
[18:01:02.860]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.861] getGlobalsAndPackages() ...
[18:01:02.861] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.861] Resolving globals: FALSE
[18:01:02.863] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:02.864] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:02.864] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.864] 
[18:01:02.864] getGlobalsAndPackages() ... DONE
[18:01:02.865] run() for ‘Future’ ...
[18:01:02.865] - state: ‘created’
[18:01:02.866] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.872] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.873] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.873]   - Field: ‘label’
[18:01:02.873]   - Field: ‘local’
[18:01:02.873]   - Field: ‘owner’
[18:01:02.874]   - Field: ‘envir’
[18:01:02.874]   - Field: ‘workers’
[18:01:02.874]   - Field: ‘packages’
[18:01:02.874]   - Field: ‘gc’
[18:01:02.875]   - Field: ‘job’
[18:01:02.875]   - Field: ‘conditions’
[18:01:02.875]   - Field: ‘expr’
[18:01:02.875]   - Field: ‘uuid’
[18:01:02.875]   - Field: ‘seed’
[18:01:02.876]   - Field: ‘version’
[18:01:02.876]   - Field: ‘result’
[18:01:02.876]   - Field: ‘asynchronous’
[18:01:02.876]   - Field: ‘calls’
[18:01:02.877]   - Field: ‘globals’
[18:01:02.880]   - Field: ‘stdout’
[18:01:02.880]   - Field: ‘earlySignal’
[18:01:02.881]   - Field: ‘lazy’
[18:01:02.881]   - Field: ‘state’
[18:01:02.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.881] - Launch lazy future ...
[18:01:02.882] Packages needed by the future expression (n = 0): <none>
[18:01:02.882] Packages needed by future strategies (n = 0): <none>
[18:01:02.883] {
[18:01:02.883]     {
[18:01:02.883]         {
[18:01:02.883]             ...future.startTime <- base::Sys.time()
[18:01:02.883]             {
[18:01:02.883]                 {
[18:01:02.883]                   {
[18:01:02.883]                     {
[18:01:02.883]                       base::local({
[18:01:02.883]                         has_future <- base::requireNamespace("future", 
[18:01:02.883]                           quietly = TRUE)
[18:01:02.883]                         if (has_future) {
[18:01:02.883]                           ns <- base::getNamespace("future")
[18:01:02.883]                           version <- ns[[".package"]][["version"]]
[18:01:02.883]                           if (is.null(version)) 
[18:01:02.883]                             version <- utils::packageVersion("future")
[18:01:02.883]                         }
[18:01:02.883]                         else {
[18:01:02.883]                           version <- NULL
[18:01:02.883]                         }
[18:01:02.883]                         if (!has_future || version < "1.8.0") {
[18:01:02.883]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.883]                             "", base::R.version$version.string), 
[18:01:02.883]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.883]                               "release", "version")], collapse = " "), 
[18:01:02.883]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.883]                             info)
[18:01:02.883]                           info <- base::paste(info, collapse = "; ")
[18:01:02.883]                           if (!has_future) {
[18:01:02.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.883]                               info)
[18:01:02.883]                           }
[18:01:02.883]                           else {
[18:01:02.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.883]                               info, version)
[18:01:02.883]                           }
[18:01:02.883]                           base::stop(msg)
[18:01:02.883]                         }
[18:01:02.883]                       })
[18:01:02.883]                     }
[18:01:02.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.883]                     base::options(mc.cores = 1L)
[18:01:02.883]                   }
[18:01:02.883]                   ...future.strategy.old <- future::plan("list")
[18:01:02.883]                   options(future.plan = NULL)
[18:01:02.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.883]                 }
[18:01:02.883]                 ...future.workdir <- getwd()
[18:01:02.883]             }
[18:01:02.883]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.883]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.883]         }
[18:01:02.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.883]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.883]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.883]             base::names(...future.oldOptions))
[18:01:02.883]     }
[18:01:02.883]     if (FALSE) {
[18:01:02.883]     }
[18:01:02.883]     else {
[18:01:02.883]         if (TRUE) {
[18:01:02.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.883]                 open = "w")
[18:01:02.883]         }
[18:01:02.883]         else {
[18:01:02.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.883]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.883]         }
[18:01:02.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.883]             base::sink(type = "output", split = FALSE)
[18:01:02.883]             base::close(...future.stdout)
[18:01:02.883]         }, add = TRUE)
[18:01:02.883]     }
[18:01:02.883]     ...future.frame <- base::sys.nframe()
[18:01:02.883]     ...future.conditions <- base::list()
[18:01:02.883]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.883]     if (FALSE) {
[18:01:02.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.883]     }
[18:01:02.883]     ...future.result <- base::tryCatch({
[18:01:02.883]         base::withCallingHandlers({
[18:01:02.883]             ...future.value <- base::withVisible(base::local({
[18:01:02.883]                 withCallingHandlers({
[18:01:02.883]                   {
[18:01:02.883]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.883]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.883]                       ...future.globals.maxSize)) {
[18:01:02.883]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.883]                       on.exit(options(oopts), add = TRUE)
[18:01:02.883]                     }
[18:01:02.883]                     {
[18:01:02.883]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.883]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.883]                         USE.NAMES = FALSE)
[18:01:02.883]                       do.call(mapply, args = args)
[18:01:02.883]                     }
[18:01:02.883]                   }
[18:01:02.883]                 }, immediateCondition = function(cond) {
[18:01:02.883]                   save_rds <- function (object, pathname, ...) 
[18:01:02.883]                   {
[18:01:02.883]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.883]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.883]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.883]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.883]                         fi_tmp[["mtime"]])
[18:01:02.883]                     }
[18:01:02.883]                     tryCatch({
[18:01:02.883]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.883]                     }, error = function(ex) {
[18:01:02.883]                       msg <- conditionMessage(ex)
[18:01:02.883]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.883]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.883]                         fi_tmp[["mtime"]], msg)
[18:01:02.883]                       ex$message <- msg
[18:01:02.883]                       stop(ex)
[18:01:02.883]                     })
[18:01:02.883]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.883]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.883]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.883]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.883]                       fi <- file.info(pathname)
[18:01:02.883]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.883]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.883]                         fi[["size"]], fi[["mtime"]])
[18:01:02.883]                       stop(msg)
[18:01:02.883]                     }
[18:01:02.883]                     invisible(pathname)
[18:01:02.883]                   }
[18:01:02.883]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.883]                     rootPath = tempdir()) 
[18:01:02.883]                   {
[18:01:02.883]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.883]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.883]                       tmpdir = path, fileext = ".rds")
[18:01:02.883]                     save_rds(obj, file)
[18:01:02.883]                   }
[18:01:02.883]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.883]                   {
[18:01:02.883]                     inherits <- base::inherits
[18:01:02.883]                     invokeRestart <- base::invokeRestart
[18:01:02.883]                     is.null <- base::is.null
[18:01:02.883]                     muffled <- FALSE
[18:01:02.883]                     if (inherits(cond, "message")) {
[18:01:02.883]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.883]                       if (muffled) 
[18:01:02.883]                         invokeRestart("muffleMessage")
[18:01:02.883]                     }
[18:01:02.883]                     else if (inherits(cond, "warning")) {
[18:01:02.883]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.883]                       if (muffled) 
[18:01:02.883]                         invokeRestart("muffleWarning")
[18:01:02.883]                     }
[18:01:02.883]                     else if (inherits(cond, "condition")) {
[18:01:02.883]                       if (!is.null(pattern)) {
[18:01:02.883]                         computeRestarts <- base::computeRestarts
[18:01:02.883]                         grepl <- base::grepl
[18:01:02.883]                         restarts <- computeRestarts(cond)
[18:01:02.883]                         for (restart in restarts) {
[18:01:02.883]                           name <- restart$name
[18:01:02.883]                           if (is.null(name)) 
[18:01:02.883]                             next
[18:01:02.883]                           if (!grepl(pattern, name)) 
[18:01:02.883]                             next
[18:01:02.883]                           invokeRestart(restart)
[18:01:02.883]                           muffled <- TRUE
[18:01:02.883]                           break
[18:01:02.883]                         }
[18:01:02.883]                       }
[18:01:02.883]                     }
[18:01:02.883]                     invisible(muffled)
[18:01:02.883]                   }
[18:01:02.883]                   muffleCondition(cond)
[18:01:02.883]                 })
[18:01:02.883]             }))
[18:01:02.883]             future::FutureResult(value = ...future.value$value, 
[18:01:02.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.883]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.883]                     ...future.globalenv.names))
[18:01:02.883]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.883]         }, condition = base::local({
[18:01:02.883]             c <- base::c
[18:01:02.883]             inherits <- base::inherits
[18:01:02.883]             invokeRestart <- base::invokeRestart
[18:01:02.883]             length <- base::length
[18:01:02.883]             list <- base::list
[18:01:02.883]             seq.int <- base::seq.int
[18:01:02.883]             signalCondition <- base::signalCondition
[18:01:02.883]             sys.calls <- base::sys.calls
[18:01:02.883]             `[[` <- base::`[[`
[18:01:02.883]             `+` <- base::`+`
[18:01:02.883]             `<<-` <- base::`<<-`
[18:01:02.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.883]                   3L)]
[18:01:02.883]             }
[18:01:02.883]             function(cond) {
[18:01:02.883]                 is_error <- inherits(cond, "error")
[18:01:02.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.883]                   NULL)
[18:01:02.883]                 if (is_error) {
[18:01:02.883]                   sessionInformation <- function() {
[18:01:02.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.883]                       search = base::search(), system = base::Sys.info())
[18:01:02.883]                   }
[18:01:02.883]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.883]                     cond$call), session = sessionInformation(), 
[18:01:02.883]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.883]                   signalCondition(cond)
[18:01:02.883]                 }
[18:01:02.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.883]                 "immediateCondition"))) {
[18:01:02.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.883]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.883]                   if (TRUE && !signal) {
[18:01:02.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.883]                     {
[18:01:02.883]                       inherits <- base::inherits
[18:01:02.883]                       invokeRestart <- base::invokeRestart
[18:01:02.883]                       is.null <- base::is.null
[18:01:02.883]                       muffled <- FALSE
[18:01:02.883]                       if (inherits(cond, "message")) {
[18:01:02.883]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.883]                         if (muffled) 
[18:01:02.883]                           invokeRestart("muffleMessage")
[18:01:02.883]                       }
[18:01:02.883]                       else if (inherits(cond, "warning")) {
[18:01:02.883]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.883]                         if (muffled) 
[18:01:02.883]                           invokeRestart("muffleWarning")
[18:01:02.883]                       }
[18:01:02.883]                       else if (inherits(cond, "condition")) {
[18:01:02.883]                         if (!is.null(pattern)) {
[18:01:02.883]                           computeRestarts <- base::computeRestarts
[18:01:02.883]                           grepl <- base::grepl
[18:01:02.883]                           restarts <- computeRestarts(cond)
[18:01:02.883]                           for (restart in restarts) {
[18:01:02.883]                             name <- restart$name
[18:01:02.883]                             if (is.null(name)) 
[18:01:02.883]                               next
[18:01:02.883]                             if (!grepl(pattern, name)) 
[18:01:02.883]                               next
[18:01:02.883]                             invokeRestart(restart)
[18:01:02.883]                             muffled <- TRUE
[18:01:02.883]                             break
[18:01:02.883]                           }
[18:01:02.883]                         }
[18:01:02.883]                       }
[18:01:02.883]                       invisible(muffled)
[18:01:02.883]                     }
[18:01:02.883]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.883]                   }
[18:01:02.883]                 }
[18:01:02.883]                 else {
[18:01:02.883]                   if (TRUE) {
[18:01:02.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.883]                     {
[18:01:02.883]                       inherits <- base::inherits
[18:01:02.883]                       invokeRestart <- base::invokeRestart
[18:01:02.883]                       is.null <- base::is.null
[18:01:02.883]                       muffled <- FALSE
[18:01:02.883]                       if (inherits(cond, "message")) {
[18:01:02.883]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.883]                         if (muffled) 
[18:01:02.883]                           invokeRestart("muffleMessage")
[18:01:02.883]                       }
[18:01:02.883]                       else if (inherits(cond, "warning")) {
[18:01:02.883]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.883]                         if (muffled) 
[18:01:02.883]                           invokeRestart("muffleWarning")
[18:01:02.883]                       }
[18:01:02.883]                       else if (inherits(cond, "condition")) {
[18:01:02.883]                         if (!is.null(pattern)) {
[18:01:02.883]                           computeRestarts <- base::computeRestarts
[18:01:02.883]                           grepl <- base::grepl
[18:01:02.883]                           restarts <- computeRestarts(cond)
[18:01:02.883]                           for (restart in restarts) {
[18:01:02.883]                             name <- restart$name
[18:01:02.883]                             if (is.null(name)) 
[18:01:02.883]                               next
[18:01:02.883]                             if (!grepl(pattern, name)) 
[18:01:02.883]                               next
[18:01:02.883]                             invokeRestart(restart)
[18:01:02.883]                             muffled <- TRUE
[18:01:02.883]                             break
[18:01:02.883]                           }
[18:01:02.883]                         }
[18:01:02.883]                       }
[18:01:02.883]                       invisible(muffled)
[18:01:02.883]                     }
[18:01:02.883]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.883]                   }
[18:01:02.883]                 }
[18:01:02.883]             }
[18:01:02.883]         }))
[18:01:02.883]     }, error = function(ex) {
[18:01:02.883]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.883]                 ...future.rng), started = ...future.startTime, 
[18:01:02.883]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.883]             version = "1.8"), class = "FutureResult")
[18:01:02.883]     }, finally = {
[18:01:02.883]         if (!identical(...future.workdir, getwd())) 
[18:01:02.883]             setwd(...future.workdir)
[18:01:02.883]         {
[18:01:02.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.883]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.883]             }
[18:01:02.883]             base::options(...future.oldOptions)
[18:01:02.883]             if (.Platform$OS.type == "windows") {
[18:01:02.883]                 old_names <- names(...future.oldEnvVars)
[18:01:02.883]                 envs <- base::Sys.getenv()
[18:01:02.883]                 names <- names(envs)
[18:01:02.883]                 common <- intersect(names, old_names)
[18:01:02.883]                 added <- setdiff(names, old_names)
[18:01:02.883]                 removed <- setdiff(old_names, names)
[18:01:02.883]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.883]                   envs[common]]
[18:01:02.883]                 NAMES <- toupper(changed)
[18:01:02.883]                 args <- list()
[18:01:02.883]                 for (kk in seq_along(NAMES)) {
[18:01:02.883]                   name <- changed[[kk]]
[18:01:02.883]                   NAME <- NAMES[[kk]]
[18:01:02.883]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.883]                     next
[18:01:02.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.883]                 }
[18:01:02.883]                 NAMES <- toupper(added)
[18:01:02.883]                 for (kk in seq_along(NAMES)) {
[18:01:02.883]                   name <- added[[kk]]
[18:01:02.883]                   NAME <- NAMES[[kk]]
[18:01:02.883]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.883]                     next
[18:01:02.883]                   args[[name]] <- ""
[18:01:02.883]                 }
[18:01:02.883]                 NAMES <- toupper(removed)
[18:01:02.883]                 for (kk in seq_along(NAMES)) {
[18:01:02.883]                   name <- removed[[kk]]
[18:01:02.883]                   NAME <- NAMES[[kk]]
[18:01:02.883]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.883]                     next
[18:01:02.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.883]                 }
[18:01:02.883]                 if (length(args) > 0) 
[18:01:02.883]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.883]             }
[18:01:02.883]             else {
[18:01:02.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.883]             }
[18:01:02.883]             {
[18:01:02.883]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.883]                   0L) {
[18:01:02.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.883]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.883]                   base::options(opts)
[18:01:02.883]                 }
[18:01:02.883]                 {
[18:01:02.883]                   {
[18:01:02.883]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.883]                     NULL
[18:01:02.883]                   }
[18:01:02.883]                   options(future.plan = NULL)
[18:01:02.883]                   if (is.na(NA_character_)) 
[18:01:02.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.883]                     .init = FALSE)
[18:01:02.883]                 }
[18:01:02.883]             }
[18:01:02.883]         }
[18:01:02.883]     })
[18:01:02.883]     if (TRUE) {
[18:01:02.883]         base::sink(type = "output", split = FALSE)
[18:01:02.883]         if (TRUE) {
[18:01:02.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.883]         }
[18:01:02.883]         else {
[18:01:02.883]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.883]         }
[18:01:02.883]         base::close(...future.stdout)
[18:01:02.883]         ...future.stdout <- NULL
[18:01:02.883]     }
[18:01:02.883]     ...future.result$conditions <- ...future.conditions
[18:01:02.883]     ...future.result$finished <- base::Sys.time()
[18:01:02.883]     ...future.result
[18:01:02.883] }
[18:01:02.889] assign_globals() ...
[18:01:02.889] List of 5
[18:01:02.889]  $ ...future.FUN            :function (x, y)  
[18:01:02.889]  $ MoreArgs                 :List of 1
[18:01:02.889]   ..$ y: int [1:2] 3 4
[18:01:02.889]  $ ...future.elements_ii    :List of 1
[18:01:02.889]   ..$ x:List of 1
[18:01:02.889]   .. ..$ : int 1
[18:01:02.889]  $ ...future.seeds_ii       : NULL
[18:01:02.889]  $ ...future.globals.maxSize: NULL
[18:01:02.889]  - attr(*, "where")=List of 5
[18:01:02.889]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.889]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.889]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.889]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.889]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.889]  - attr(*, "resolved")= logi FALSE
[18:01:02.889]  - attr(*, "total_size")= num 1816
[18:01:02.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.889]  - attr(*, "already-done")= logi TRUE
[18:01:02.901] - reassign environment for ‘...future.FUN’
[18:01:02.901] - copied ‘...future.FUN’ to environment
[18:01:02.901] - copied ‘MoreArgs’ to environment
[18:01:02.901] - copied ‘...future.elements_ii’ to environment
[18:01:02.902] - copied ‘...future.seeds_ii’ to environment
[18:01:02.902] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.902] assign_globals() ... done
[18:01:02.902] requestCore(): workers = 2
[18:01:02.906] MulticoreFuture started
[18:01:02.907] - Launch lazy future ... done
[18:01:02.908] run() for ‘MulticoreFuture’ ... done
[18:01:02.908] plan(): Setting new future strategy stack:
[18:01:02.908] Created future:
[18:01:02.908] List of future strategies:
[18:01:02.908] 1. sequential:
[18:01:02.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.908]    - tweaked: FALSE
[18:01:02.908]    - call: NULL
[18:01:02.911] plan(): nbrOfWorkers() = 1
[18:01:02.915] plan(): Setting new future strategy stack:
[18:01:02.916] List of future strategies:
[18:01:02.916] 1. multicore:
[18:01:02.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:02.916]    - tweaked: FALSE
[18:01:02.916]    - call: plan(strategy)
[18:01:02.909] MulticoreFuture:
[18:01:02.909] Label: ‘future_.mapply-1’
[18:01:02.909] Expression:
[18:01:02.909] {
[18:01:02.909]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.909]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.909]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.909]         on.exit(options(oopts), add = TRUE)
[18:01:02.909]     }
[18:01:02.909]     {
[18:01:02.909]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.909]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.909]         do.call(mapply, args = args)
[18:01:02.909]     }
[18:01:02.909] }
[18:01:02.909] Lazy evaluation: FALSE
[18:01:02.909] Asynchronous evaluation: TRUE
[18:01:02.909] Local evaluation: TRUE
[18:01:02.909] Environment: R_GlobalEnv
[18:01:02.909] Capture standard output: TRUE
[18:01:02.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.909] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.909] Packages: <none>
[18:01:02.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.909] Resolved: FALSE
[18:01:02.909] Value: <not collected>
[18:01:02.909] Conditions captured: <none>
[18:01:02.909] Early signaling: FALSE
[18:01:02.909] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.909] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.924] Chunk #1 of 2 ... DONE
[18:01:02.924] Chunk #2 of 2 ...
[18:01:02.925]  - Finding globals in '...' for chunk #2 ...
[18:01:02.925] getGlobalsAndPackages() ...
[18:01:02.925] plan(): nbrOfWorkers() = 2
[18:01:02.925] Searching for globals...
[18:01:02.927] 
[18:01:02.927] Searching for globals ... DONE
[18:01:02.927] - globals: [0] <none>
[18:01:02.927] getGlobalsAndPackages() ... DONE
[18:01:02.928]    + additional globals found: [n=0] 
[18:01:02.928]    + additional namespaces needed: [n=0] 
[18:01:02.928]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:02.928]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:02.929]  - seeds: <none>
[18:01:02.929]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.930] getGlobalsAndPackages() ...
[18:01:02.930] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.930] Resolving globals: FALSE
[18:01:02.932] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:02.934] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:02.934] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:02.934] 
[18:01:02.935] getGlobalsAndPackages() ... DONE
[18:01:02.936] run() for ‘Future’ ...
[18:01:02.936] - state: ‘created’
[18:01:02.936] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:02.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:02.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:02.945]   - Field: ‘label’
[18:01:02.946]   - Field: ‘local’
[18:01:02.946]   - Field: ‘owner’
[18:01:02.946]   - Field: ‘envir’
[18:01:02.947]   - Field: ‘workers’
[18:01:02.947]   - Field: ‘packages’
[18:01:02.947]   - Field: ‘gc’
[18:01:02.948]   - Field: ‘job’
[18:01:02.948]   - Field: ‘conditions’
[18:01:02.948]   - Field: ‘expr’
[18:01:02.949]   - Field: ‘uuid’
[18:01:02.949]   - Field: ‘seed’
[18:01:02.949]   - Field: ‘version’
[18:01:02.950]   - Field: ‘result’
[18:01:02.950]   - Field: ‘asynchronous’
[18:01:02.950]   - Field: ‘calls’
[18:01:02.951]   - Field: ‘globals’
[18:01:02.951]   - Field: ‘stdout’
[18:01:02.951]   - Field: ‘earlySignal’
[18:01:02.952]   - Field: ‘lazy’
[18:01:02.952]   - Field: ‘state’
[18:01:02.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:02.953] - Launch lazy future ...
[18:01:02.953] Packages needed by the future expression (n = 0): <none>
[18:01:02.954] Packages needed by future strategies (n = 0): <none>
[18:01:02.956] {
[18:01:02.956]     {
[18:01:02.956]         {
[18:01:02.956]             ...future.startTime <- base::Sys.time()
[18:01:02.956]             {
[18:01:02.956]                 {
[18:01:02.956]                   {
[18:01:02.956]                     {
[18:01:02.956]                       base::local({
[18:01:02.956]                         has_future <- base::requireNamespace("future", 
[18:01:02.956]                           quietly = TRUE)
[18:01:02.956]                         if (has_future) {
[18:01:02.956]                           ns <- base::getNamespace("future")
[18:01:02.956]                           version <- ns[[".package"]][["version"]]
[18:01:02.956]                           if (is.null(version)) 
[18:01:02.956]                             version <- utils::packageVersion("future")
[18:01:02.956]                         }
[18:01:02.956]                         else {
[18:01:02.956]                           version <- NULL
[18:01:02.956]                         }
[18:01:02.956]                         if (!has_future || version < "1.8.0") {
[18:01:02.956]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:02.956]                             "", base::R.version$version.string), 
[18:01:02.956]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:02.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:02.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:02.956]                               "release", "version")], collapse = " "), 
[18:01:02.956]                             hostname = base::Sys.info()[["nodename"]])
[18:01:02.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:02.956]                             info)
[18:01:02.956]                           info <- base::paste(info, collapse = "; ")
[18:01:02.956]                           if (!has_future) {
[18:01:02.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:02.956]                               info)
[18:01:02.956]                           }
[18:01:02.956]                           else {
[18:01:02.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:02.956]                               info, version)
[18:01:02.956]                           }
[18:01:02.956]                           base::stop(msg)
[18:01:02.956]                         }
[18:01:02.956]                       })
[18:01:02.956]                     }
[18:01:02.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:02.956]                     base::options(mc.cores = 1L)
[18:01:02.956]                   }
[18:01:02.956]                   ...future.strategy.old <- future::plan("list")
[18:01:02.956]                   options(future.plan = NULL)
[18:01:02.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:02.956]                 }
[18:01:02.956]                 ...future.workdir <- getwd()
[18:01:02.956]             }
[18:01:02.956]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:02.956]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:02.956]         }
[18:01:02.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:02.956]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:02.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:02.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:02.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:02.956]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:02.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:02.956]             base::names(...future.oldOptions))
[18:01:02.956]     }
[18:01:02.956]     if (FALSE) {
[18:01:02.956]     }
[18:01:02.956]     else {
[18:01:02.956]         if (TRUE) {
[18:01:02.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:02.956]                 open = "w")
[18:01:02.956]         }
[18:01:02.956]         else {
[18:01:02.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:02.956]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:02.956]         }
[18:01:02.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:02.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:02.956]             base::sink(type = "output", split = FALSE)
[18:01:02.956]             base::close(...future.stdout)
[18:01:02.956]         }, add = TRUE)
[18:01:02.956]     }
[18:01:02.956]     ...future.frame <- base::sys.nframe()
[18:01:02.956]     ...future.conditions <- base::list()
[18:01:02.956]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:02.956]     if (FALSE) {
[18:01:02.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:02.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:02.956]     }
[18:01:02.956]     ...future.result <- base::tryCatch({
[18:01:02.956]         base::withCallingHandlers({
[18:01:02.956]             ...future.value <- base::withVisible(base::local({
[18:01:02.956]                 withCallingHandlers({
[18:01:02.956]                   {
[18:01:02.956]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.956]                     if (!identical(...future.globals.maxSize.org, 
[18:01:02.956]                       ...future.globals.maxSize)) {
[18:01:02.956]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.956]                       on.exit(options(oopts), add = TRUE)
[18:01:02.956]                     }
[18:01:02.956]                     {
[18:01:02.956]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.956]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:02.956]                         USE.NAMES = FALSE)
[18:01:02.956]                       do.call(mapply, args = args)
[18:01:02.956]                     }
[18:01:02.956]                   }
[18:01:02.956]                 }, immediateCondition = function(cond) {
[18:01:02.956]                   save_rds <- function (object, pathname, ...) 
[18:01:02.956]                   {
[18:01:02.956]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:02.956]                     if (file_test("-f", pathname_tmp)) {
[18:01:02.956]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.956]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:02.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.956]                         fi_tmp[["mtime"]])
[18:01:02.956]                     }
[18:01:02.956]                     tryCatch({
[18:01:02.956]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:02.956]                     }, error = function(ex) {
[18:01:02.956]                       msg <- conditionMessage(ex)
[18:01:02.956]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.956]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:02.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.956]                         fi_tmp[["mtime"]], msg)
[18:01:02.956]                       ex$message <- msg
[18:01:02.956]                       stop(ex)
[18:01:02.956]                     })
[18:01:02.956]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:02.956]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:02.956]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:02.956]                       fi_tmp <- file.info(pathname_tmp)
[18:01:02.956]                       fi <- file.info(pathname)
[18:01:02.956]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:02.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:02.956]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:02.956]                         fi[["size"]], fi[["mtime"]])
[18:01:02.956]                       stop(msg)
[18:01:02.956]                     }
[18:01:02.956]                     invisible(pathname)
[18:01:02.956]                   }
[18:01:02.956]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:02.956]                     rootPath = tempdir()) 
[18:01:02.956]                   {
[18:01:02.956]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:02.956]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:02.956]                       tmpdir = path, fileext = ".rds")
[18:01:02.956]                     save_rds(obj, file)
[18:01:02.956]                   }
[18:01:02.956]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:02.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.956]                   {
[18:01:02.956]                     inherits <- base::inherits
[18:01:02.956]                     invokeRestart <- base::invokeRestart
[18:01:02.956]                     is.null <- base::is.null
[18:01:02.956]                     muffled <- FALSE
[18:01:02.956]                     if (inherits(cond, "message")) {
[18:01:02.956]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:02.956]                       if (muffled) 
[18:01:02.956]                         invokeRestart("muffleMessage")
[18:01:02.956]                     }
[18:01:02.956]                     else if (inherits(cond, "warning")) {
[18:01:02.956]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:02.956]                       if (muffled) 
[18:01:02.956]                         invokeRestart("muffleWarning")
[18:01:02.956]                     }
[18:01:02.956]                     else if (inherits(cond, "condition")) {
[18:01:02.956]                       if (!is.null(pattern)) {
[18:01:02.956]                         computeRestarts <- base::computeRestarts
[18:01:02.956]                         grepl <- base::grepl
[18:01:02.956]                         restarts <- computeRestarts(cond)
[18:01:02.956]                         for (restart in restarts) {
[18:01:02.956]                           name <- restart$name
[18:01:02.956]                           if (is.null(name)) 
[18:01:02.956]                             next
[18:01:02.956]                           if (!grepl(pattern, name)) 
[18:01:02.956]                             next
[18:01:02.956]                           invokeRestart(restart)
[18:01:02.956]                           muffled <- TRUE
[18:01:02.956]                           break
[18:01:02.956]                         }
[18:01:02.956]                       }
[18:01:02.956]                     }
[18:01:02.956]                     invisible(muffled)
[18:01:02.956]                   }
[18:01:02.956]                   muffleCondition(cond)
[18:01:02.956]                 })
[18:01:02.956]             }))
[18:01:02.956]             future::FutureResult(value = ...future.value$value, 
[18:01:02.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.956]                   ...future.rng), globalenv = if (FALSE) 
[18:01:02.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:02.956]                     ...future.globalenv.names))
[18:01:02.956]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:02.956]         }, condition = base::local({
[18:01:02.956]             c <- base::c
[18:01:02.956]             inherits <- base::inherits
[18:01:02.956]             invokeRestart <- base::invokeRestart
[18:01:02.956]             length <- base::length
[18:01:02.956]             list <- base::list
[18:01:02.956]             seq.int <- base::seq.int
[18:01:02.956]             signalCondition <- base::signalCondition
[18:01:02.956]             sys.calls <- base::sys.calls
[18:01:02.956]             `[[` <- base::`[[`
[18:01:02.956]             `+` <- base::`+`
[18:01:02.956]             `<<-` <- base::`<<-`
[18:01:02.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:02.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:02.956]                   3L)]
[18:01:02.956]             }
[18:01:02.956]             function(cond) {
[18:01:02.956]                 is_error <- inherits(cond, "error")
[18:01:02.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:02.956]                   NULL)
[18:01:02.956]                 if (is_error) {
[18:01:02.956]                   sessionInformation <- function() {
[18:01:02.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:02.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:02.956]                       search = base::search(), system = base::Sys.info())
[18:01:02.956]                   }
[18:01:02.956]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:02.956]                     cond$call), session = sessionInformation(), 
[18:01:02.956]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:02.956]                   signalCondition(cond)
[18:01:02.956]                 }
[18:01:02.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:02.956]                 "immediateCondition"))) {
[18:01:02.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:02.956]                   ...future.conditions[[length(...future.conditions) + 
[18:01:02.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:02.956]                   if (TRUE && !signal) {
[18:01:02.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.956]                     {
[18:01:02.956]                       inherits <- base::inherits
[18:01:02.956]                       invokeRestart <- base::invokeRestart
[18:01:02.956]                       is.null <- base::is.null
[18:01:02.956]                       muffled <- FALSE
[18:01:02.956]                       if (inherits(cond, "message")) {
[18:01:02.956]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.956]                         if (muffled) 
[18:01:02.956]                           invokeRestart("muffleMessage")
[18:01:02.956]                       }
[18:01:02.956]                       else if (inherits(cond, "warning")) {
[18:01:02.956]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.956]                         if (muffled) 
[18:01:02.956]                           invokeRestart("muffleWarning")
[18:01:02.956]                       }
[18:01:02.956]                       else if (inherits(cond, "condition")) {
[18:01:02.956]                         if (!is.null(pattern)) {
[18:01:02.956]                           computeRestarts <- base::computeRestarts
[18:01:02.956]                           grepl <- base::grepl
[18:01:02.956]                           restarts <- computeRestarts(cond)
[18:01:02.956]                           for (restart in restarts) {
[18:01:02.956]                             name <- restart$name
[18:01:02.956]                             if (is.null(name)) 
[18:01:02.956]                               next
[18:01:02.956]                             if (!grepl(pattern, name)) 
[18:01:02.956]                               next
[18:01:02.956]                             invokeRestart(restart)
[18:01:02.956]                             muffled <- TRUE
[18:01:02.956]                             break
[18:01:02.956]                           }
[18:01:02.956]                         }
[18:01:02.956]                       }
[18:01:02.956]                       invisible(muffled)
[18:01:02.956]                     }
[18:01:02.956]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.956]                   }
[18:01:02.956]                 }
[18:01:02.956]                 else {
[18:01:02.956]                   if (TRUE) {
[18:01:02.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:02.956]                     {
[18:01:02.956]                       inherits <- base::inherits
[18:01:02.956]                       invokeRestart <- base::invokeRestart
[18:01:02.956]                       is.null <- base::is.null
[18:01:02.956]                       muffled <- FALSE
[18:01:02.956]                       if (inherits(cond, "message")) {
[18:01:02.956]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:02.956]                         if (muffled) 
[18:01:02.956]                           invokeRestart("muffleMessage")
[18:01:02.956]                       }
[18:01:02.956]                       else if (inherits(cond, "warning")) {
[18:01:02.956]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:02.956]                         if (muffled) 
[18:01:02.956]                           invokeRestart("muffleWarning")
[18:01:02.956]                       }
[18:01:02.956]                       else if (inherits(cond, "condition")) {
[18:01:02.956]                         if (!is.null(pattern)) {
[18:01:02.956]                           computeRestarts <- base::computeRestarts
[18:01:02.956]                           grepl <- base::grepl
[18:01:02.956]                           restarts <- computeRestarts(cond)
[18:01:02.956]                           for (restart in restarts) {
[18:01:02.956]                             name <- restart$name
[18:01:02.956]                             if (is.null(name)) 
[18:01:02.956]                               next
[18:01:02.956]                             if (!grepl(pattern, name)) 
[18:01:02.956]                               next
[18:01:02.956]                             invokeRestart(restart)
[18:01:02.956]                             muffled <- TRUE
[18:01:02.956]                             break
[18:01:02.956]                           }
[18:01:02.956]                         }
[18:01:02.956]                       }
[18:01:02.956]                       invisible(muffled)
[18:01:02.956]                     }
[18:01:02.956]                     muffleCondition(cond, pattern = "^muffle")
[18:01:02.956]                   }
[18:01:02.956]                 }
[18:01:02.956]             }
[18:01:02.956]         }))
[18:01:02.956]     }, error = function(ex) {
[18:01:02.956]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:02.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:02.956]                 ...future.rng), started = ...future.startTime, 
[18:01:02.956]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:02.956]             version = "1.8"), class = "FutureResult")
[18:01:02.956]     }, finally = {
[18:01:02.956]         if (!identical(...future.workdir, getwd())) 
[18:01:02.956]             setwd(...future.workdir)
[18:01:02.956]         {
[18:01:02.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:02.956]                 ...future.oldOptions$nwarnings <- NULL
[18:01:02.956]             }
[18:01:02.956]             base::options(...future.oldOptions)
[18:01:02.956]             if (.Platform$OS.type == "windows") {
[18:01:02.956]                 old_names <- names(...future.oldEnvVars)
[18:01:02.956]                 envs <- base::Sys.getenv()
[18:01:02.956]                 names <- names(envs)
[18:01:02.956]                 common <- intersect(names, old_names)
[18:01:02.956]                 added <- setdiff(names, old_names)
[18:01:02.956]                 removed <- setdiff(old_names, names)
[18:01:02.956]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:02.956]                   envs[common]]
[18:01:02.956]                 NAMES <- toupper(changed)
[18:01:02.956]                 args <- list()
[18:01:02.956]                 for (kk in seq_along(NAMES)) {
[18:01:02.956]                   name <- changed[[kk]]
[18:01:02.956]                   NAME <- NAMES[[kk]]
[18:01:02.956]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.956]                     next
[18:01:02.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.956]                 }
[18:01:02.956]                 NAMES <- toupper(added)
[18:01:02.956]                 for (kk in seq_along(NAMES)) {
[18:01:02.956]                   name <- added[[kk]]
[18:01:02.956]                   NAME <- NAMES[[kk]]
[18:01:02.956]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.956]                     next
[18:01:02.956]                   args[[name]] <- ""
[18:01:02.956]                 }
[18:01:02.956]                 NAMES <- toupper(removed)
[18:01:02.956]                 for (kk in seq_along(NAMES)) {
[18:01:02.956]                   name <- removed[[kk]]
[18:01:02.956]                   NAME <- NAMES[[kk]]
[18:01:02.956]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:02.956]                     next
[18:01:02.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:02.956]                 }
[18:01:02.956]                 if (length(args) > 0) 
[18:01:02.956]                   base::do.call(base::Sys.setenv, args = args)
[18:01:02.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:02.956]             }
[18:01:02.956]             else {
[18:01:02.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:02.956]             }
[18:01:02.956]             {
[18:01:02.956]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:02.956]                   0L) {
[18:01:02.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:02.956]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:02.956]                   base::options(opts)
[18:01:02.956]                 }
[18:01:02.956]                 {
[18:01:02.956]                   {
[18:01:02.956]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:02.956]                     NULL
[18:01:02.956]                   }
[18:01:02.956]                   options(future.plan = NULL)
[18:01:02.956]                   if (is.na(NA_character_)) 
[18:01:02.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:02.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:02.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:02.956]                     .init = FALSE)
[18:01:02.956]                 }
[18:01:02.956]             }
[18:01:02.956]         }
[18:01:02.956]     })
[18:01:02.956]     if (TRUE) {
[18:01:02.956]         base::sink(type = "output", split = FALSE)
[18:01:02.956]         if (TRUE) {
[18:01:02.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:02.956]         }
[18:01:02.956]         else {
[18:01:02.956]             ...future.result["stdout"] <- base::list(NULL)
[18:01:02.956]         }
[18:01:02.956]         base::close(...future.stdout)
[18:01:02.956]         ...future.stdout <- NULL
[18:01:02.956]     }
[18:01:02.956]     ...future.result$conditions <- ...future.conditions
[18:01:02.956]     ...future.result$finished <- base::Sys.time()
[18:01:02.956]     ...future.result
[18:01:02.956] }
[18:01:02.963] assign_globals() ...
[18:01:02.963] List of 5
[18:01:02.963]  $ ...future.FUN            :function (x, y)  
[18:01:02.963]  $ MoreArgs                 :List of 1
[18:01:02.963]   ..$ y: int [1:2] 3 4
[18:01:02.963]  $ ...future.elements_ii    :List of 1
[18:01:02.963]   ..$ x:List of 1
[18:01:02.963]   .. ..$ : int 2
[18:01:02.963]  $ ...future.seeds_ii       : NULL
[18:01:02.963]  $ ...future.globals.maxSize: NULL
[18:01:02.963]  - attr(*, "where")=List of 5
[18:01:02.963]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:02.963]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:02.963]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:02.963]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:02.963]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:02.963]  - attr(*, "resolved")= logi FALSE
[18:01:02.963]  - attr(*, "total_size")= num 1816
[18:01:02.963]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:02.963]  - attr(*, "already-done")= logi TRUE
[18:01:02.989] - reassign environment for ‘...future.FUN’
[18:01:02.989] - copied ‘...future.FUN’ to environment
[18:01:02.989] - copied ‘MoreArgs’ to environment
[18:01:02.990] - copied ‘...future.elements_ii’ to environment
[18:01:02.990] - copied ‘...future.seeds_ii’ to environment
[18:01:02.990] - copied ‘...future.globals.maxSize’ to environment
[18:01:02.991] assign_globals() ... done
[18:01:02.991] requestCore(): workers = 2
[18:01:02.995] MulticoreFuture started
[18:01:02.996] - Launch lazy future ... done
[18:01:02.997] plan(): Setting new future strategy stack:
[18:01:02.998] run() for ‘MulticoreFuture’ ... done
[18:01:02.999] Created future:
[18:01:02.998] List of future strategies:
[18:01:02.998] 1. sequential:
[18:01:02.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:02.998]    - tweaked: FALSE
[18:01:02.998]    - call: NULL
[18:01:03.002] plan(): nbrOfWorkers() = 1
[18:01:03.007] plan(): Setting new future strategy stack:
[18:01:03.007] List of future strategies:
[18:01:03.007] 1. multicore:
[18:01:03.007]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.007]    - tweaked: FALSE
[18:01:03.007]    - call: plan(strategy)
[18:01:02.999] MulticoreFuture:
[18:01:02.999] Label: ‘future_.mapply-2’
[18:01:02.999] Expression:
[18:01:02.999] {
[18:01:02.999]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:02.999]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:02.999]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:02.999]         on.exit(options(oopts), add = TRUE)
[18:01:02.999]     }
[18:01:02.999]     {
[18:01:02.999]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:02.999]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:02.999]         do.call(mapply, args = args)
[18:01:02.999]     }
[18:01:02.999] }
[18:01:02.999] Lazy evaluation: FALSE
[18:01:02.999] Asynchronous evaluation: TRUE
[18:01:02.999] Local evaluation: TRUE
[18:01:02.999] Environment: R_GlobalEnv
[18:01:02.999] Capture standard output: TRUE
[18:01:02.999] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:02.999] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:02.999] Packages: <none>
[18:01:02.999] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:02.999] Resolved: FALSE
[18:01:02.999] Value: <not collected>
[18:01:02.999] Conditions captured: <none>
[18:01:02.999] Early signaling: FALSE
[18:01:02.999] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:02.999] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.016] Chunk #2 of 2 ... DONE
[18:01:03.016] Launching 2 futures (chunks) ... DONE
[18:01:03.016] Resolving 2 futures (chunks) ...
[18:01:03.017] resolve() on list ...
[18:01:03.017]  recursive: 0
[18:01:03.017]  length: 2
[18:01:03.018] plan(): nbrOfWorkers() = 2
[18:01:03.018] 
[18:01:03.019] Future #1
[18:01:03.019] result() for MulticoreFuture ...
[18:01:03.021] result() for MulticoreFuture ...
[18:01:03.021] result() for MulticoreFuture ... done
[18:01:03.022] result() for MulticoreFuture ... done
[18:01:03.022] result() for MulticoreFuture ...
[18:01:03.022] result() for MulticoreFuture ... done
[18:01:03.023] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:03.023] - nx: 2
[18:01:03.023] - relay: TRUE
[18:01:03.024] - stdout: TRUE
[18:01:03.024] - signal: TRUE
[18:01:03.024] - resignal: FALSE
[18:01:03.025] - force: TRUE
[18:01:03.025] - relayed: [n=2] FALSE, FALSE
[18:01:03.025] - queued futures: [n=2] FALSE, FALSE
[18:01:03.026]  - until=1
[18:01:03.026]  - relaying element #1
[18:01:03.027] result() for MulticoreFuture ...
[18:01:03.027] result() for MulticoreFuture ... done
[18:01:03.027] result() for MulticoreFuture ...
[18:01:03.028] result() for MulticoreFuture ... done
[18:01:03.028] result() for MulticoreFuture ...
[18:01:03.029] result() for MulticoreFuture ... done
[18:01:03.029] result() for MulticoreFuture ...
[18:01:03.029] result() for MulticoreFuture ... done
[18:01:03.030] - relayed: [n=2] TRUE, FALSE
[18:01:03.030] - queued futures: [n=2] TRUE, FALSE
[18:01:03.030] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:03.031]  length: 1 (resolved future 1)
[18:01:03.031] Future #2
[18:01:03.032] result() for MulticoreFuture ...
[18:01:03.033] result() for MulticoreFuture ...
[18:01:03.033] result() for MulticoreFuture ... done
[18:01:03.034] result() for MulticoreFuture ... done
[18:01:03.034] result() for MulticoreFuture ...
[18:01:03.034] result() for MulticoreFuture ... done
[18:01:03.035] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:03.035] - nx: 2
[18:01:03.035] - relay: TRUE
[18:01:03.035] - stdout: TRUE
[18:01:03.036] - signal: TRUE
[18:01:03.036] - resignal: FALSE
[18:01:03.036] - force: TRUE
[18:01:03.036] - relayed: [n=2] TRUE, FALSE
[18:01:03.036] - queued futures: [n=2] TRUE, FALSE
[18:01:03.037]  - until=2
[18:01:03.037]  - relaying element #2
[18:01:03.037] result() for MulticoreFuture ...
[18:01:03.037] result() for MulticoreFuture ... done
[18:01:03.038] result() for MulticoreFuture ...
[18:01:03.038] result() for MulticoreFuture ... done
[18:01:03.038] result() for MulticoreFuture ...
[18:01:03.038] result() for MulticoreFuture ... done
[18:01:03.039] result() for MulticoreFuture ...
[18:01:03.039] result() for MulticoreFuture ... done
[18:01:03.039] - relayed: [n=2] TRUE, TRUE
[18:01:03.039] - queued futures: [n=2] TRUE, TRUE
[18:01:03.039] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:03.040]  length: 0 (resolved future 2)
[18:01:03.040] Relaying remaining futures
[18:01:03.040] signalConditionsASAP(NULL, pos=0) ...
[18:01:03.040] - nx: 2
[18:01:03.041] - relay: TRUE
[18:01:03.041] - stdout: TRUE
[18:01:03.041] - signal: TRUE
[18:01:03.041] - resignal: FALSE
[18:01:03.041] - force: TRUE
[18:01:03.042] - relayed: [n=2] TRUE, TRUE
[18:01:03.042] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:03.042] - relayed: [n=2] TRUE, TRUE
[18:01:03.042] - queued futures: [n=2] TRUE, TRUE
[18:01:03.043] signalConditionsASAP(NULL, pos=0) ... done
[18:01:03.043] resolve() on list ... DONE
[18:01:03.043] result() for MulticoreFuture ...
[18:01:03.043] result() for MulticoreFuture ... done
[18:01:03.044] result() for MulticoreFuture ...
[18:01:03.044] result() for MulticoreFuture ... done
[18:01:03.044] result() for MulticoreFuture ...
[18:01:03.044] result() for MulticoreFuture ... done
[18:01:03.044] result() for MulticoreFuture ...
[18:01:03.045] result() for MulticoreFuture ... done
[18:01:03.045]  - Number of value chunks collected: 2
[18:01:03.045] Resolving 2 futures (chunks) ... DONE
[18:01:03.045] Reducing values from 2 chunks ...
[18:01:03.046]  - Number of values collected after concatenation: 2
[18:01:03.046]  - Number of values expected: 2
[18:01:03.046] Reducing values from 2 chunks ... DONE
[18:01:03.046] future_mapply() ... DONE
- Recycle arguments to same length ...
[18:01:03.047] future_mapply() ...
[18:01:03.054] Number of chunks: 2
[18:01:03.054] getGlobalsAndPackagesXApply() ...
[18:01:03.054]  - future.globals: TRUE
[18:01:03.055] getGlobalsAndPackages() ...
[18:01:03.055] Searching for globals...
[18:01:03.056] - globals found: [1] ‘FUN’
[18:01:03.057] Searching for globals ... DONE
[18:01:03.057] Resolving globals: FALSE
[18:01:03.061] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:03.062] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:03.062] - globals: [1] ‘FUN’
[18:01:03.062] 
[18:01:03.063] getGlobalsAndPackages() ... DONE
[18:01:03.063]  - globals found/used: [n=1] ‘FUN’
[18:01:03.063]  - needed namespaces: [n=0] 
[18:01:03.063] Finding globals ... DONE
[18:01:03.064] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:03.064] List of 2
[18:01:03.064]  $ ...future.FUN:function (x, ...)  
[18:01:03.064]  $ MoreArgs     : NULL
[18:01:03.064]  - attr(*, "where")=List of 2
[18:01:03.064]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:03.064]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:03.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.064]  - attr(*, "resolved")= logi FALSE
[18:01:03.064]  - attr(*, "total_size")= num NA
[18:01:03.070] Packages to be attached in all futures: [n=0] 
[18:01:03.071] getGlobalsAndPackagesXApply() ... DONE
[18:01:03.071] Number of futures (= number of chunks): 2
[18:01:03.071] Launching 2 futures (chunks) ...
[18:01:03.071] Chunk #1 of 2 ...
[18:01:03.072]  - Finding globals in '...' for chunk #1 ...
[18:01:03.072] getGlobalsAndPackages() ...
[18:01:03.072] Searching for globals...
[18:01:03.073] 
[18:01:03.073] Searching for globals ... DONE
[18:01:03.073] - globals: [0] <none>
[18:01:03.074] getGlobalsAndPackages() ... DONE
[18:01:03.074]    + additional globals found: [n=0] 
[18:01:03.074]    + additional namespaces needed: [n=0] 
[18:01:03.074]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:03.074]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.075]  - seeds: <none>
[18:01:03.075]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.075] getGlobalsAndPackages() ...
[18:01:03.075] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.076] Resolving globals: FALSE
[18:01:03.077] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:03.077] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:03.078] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.078] 
[18:01:03.078] getGlobalsAndPackages() ... DONE
[18:01:03.079] run() for ‘Future’ ...
[18:01:03.079] - state: ‘created’
[18:01:03.079] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.086]   - Field: ‘label’
[18:01:03.086]   - Field: ‘local’
[18:01:03.087]   - Field: ‘owner’
[18:01:03.087]   - Field: ‘envir’
[18:01:03.087]   - Field: ‘workers’
[18:01:03.087]   - Field: ‘packages’
[18:01:03.087]   - Field: ‘gc’
[18:01:03.088]   - Field: ‘job’
[18:01:03.088]   - Field: ‘conditions’
[18:01:03.088]   - Field: ‘expr’
[18:01:03.088]   - Field: ‘uuid’
[18:01:03.088]   - Field: ‘seed’
[18:01:03.089]   - Field: ‘version’
[18:01:03.089]   - Field: ‘result’
[18:01:03.089]   - Field: ‘asynchronous’
[18:01:03.089]   - Field: ‘calls’
[18:01:03.089]   - Field: ‘globals’
[18:01:03.090]   - Field: ‘stdout’
[18:01:03.090]   - Field: ‘earlySignal’
[18:01:03.090]   - Field: ‘lazy’
[18:01:03.090]   - Field: ‘state’
[18:01:03.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.091] - Launch lazy future ...
[18:01:03.091] Packages needed by the future expression (n = 0): <none>
[18:01:03.091] Packages needed by future strategies (n = 0): <none>
[18:01:03.092] {
[18:01:03.092]     {
[18:01:03.092]         {
[18:01:03.092]             ...future.startTime <- base::Sys.time()
[18:01:03.092]             {
[18:01:03.092]                 {
[18:01:03.092]                   {
[18:01:03.092]                     {
[18:01:03.092]                       base::local({
[18:01:03.092]                         has_future <- base::requireNamespace("future", 
[18:01:03.092]                           quietly = TRUE)
[18:01:03.092]                         if (has_future) {
[18:01:03.092]                           ns <- base::getNamespace("future")
[18:01:03.092]                           version <- ns[[".package"]][["version"]]
[18:01:03.092]                           if (is.null(version)) 
[18:01:03.092]                             version <- utils::packageVersion("future")
[18:01:03.092]                         }
[18:01:03.092]                         else {
[18:01:03.092]                           version <- NULL
[18:01:03.092]                         }
[18:01:03.092]                         if (!has_future || version < "1.8.0") {
[18:01:03.092]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.092]                             "", base::R.version$version.string), 
[18:01:03.092]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:03.092]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:03.092]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.092]                               "release", "version")], collapse = " "), 
[18:01:03.092]                             hostname = base::Sys.info()[["nodename"]])
[18:01:03.092]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.092]                             info)
[18:01:03.092]                           info <- base::paste(info, collapse = "; ")
[18:01:03.092]                           if (!has_future) {
[18:01:03.092]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.092]                               info)
[18:01:03.092]                           }
[18:01:03.092]                           else {
[18:01:03.092]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.092]                               info, version)
[18:01:03.092]                           }
[18:01:03.092]                           base::stop(msg)
[18:01:03.092]                         }
[18:01:03.092]                       })
[18:01:03.092]                     }
[18:01:03.092]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.092]                     base::options(mc.cores = 1L)
[18:01:03.092]                   }
[18:01:03.092]                   ...future.strategy.old <- future::plan("list")
[18:01:03.092]                   options(future.plan = NULL)
[18:01:03.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.092]                 }
[18:01:03.092]                 ...future.workdir <- getwd()
[18:01:03.092]             }
[18:01:03.092]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.092]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.092]         }
[18:01:03.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.092]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.092]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.092]             base::names(...future.oldOptions))
[18:01:03.092]     }
[18:01:03.092]     if (FALSE) {
[18:01:03.092]     }
[18:01:03.092]     else {
[18:01:03.092]         if (TRUE) {
[18:01:03.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.092]                 open = "w")
[18:01:03.092]         }
[18:01:03.092]         else {
[18:01:03.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.092]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.092]         }
[18:01:03.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.092]             base::sink(type = "output", split = FALSE)
[18:01:03.092]             base::close(...future.stdout)
[18:01:03.092]         }, add = TRUE)
[18:01:03.092]     }
[18:01:03.092]     ...future.frame <- base::sys.nframe()
[18:01:03.092]     ...future.conditions <- base::list()
[18:01:03.092]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.092]     if (FALSE) {
[18:01:03.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.092]     }
[18:01:03.092]     ...future.result <- base::tryCatch({
[18:01:03.092]         base::withCallingHandlers({
[18:01:03.092]             ...future.value <- base::withVisible(base::local({
[18:01:03.092]                 withCallingHandlers({
[18:01:03.092]                   {
[18:01:03.092]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.092]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.092]                       ...future.globals.maxSize)) {
[18:01:03.092]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.092]                       on.exit(options(oopts), add = TRUE)
[18:01:03.092]                     }
[18:01:03.092]                     {
[18:01:03.092]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.092]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.092]                         USE.NAMES = FALSE)
[18:01:03.092]                       do.call(mapply, args = args)
[18:01:03.092]                     }
[18:01:03.092]                   }
[18:01:03.092]                 }, immediateCondition = function(cond) {
[18:01:03.092]                   save_rds <- function (object, pathname, ...) 
[18:01:03.092]                   {
[18:01:03.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.092]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.092]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.092]                         fi_tmp[["mtime"]])
[18:01:03.092]                     }
[18:01:03.092]                     tryCatch({
[18:01:03.092]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.092]                     }, error = function(ex) {
[18:01:03.092]                       msg <- conditionMessage(ex)
[18:01:03.092]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.092]                         fi_tmp[["mtime"]], msg)
[18:01:03.092]                       ex$message <- msg
[18:01:03.092]                       stop(ex)
[18:01:03.092]                     })
[18:01:03.092]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.092]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.092]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.092]                       fi <- file.info(pathname)
[18:01:03.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.092]                         fi[["size"]], fi[["mtime"]])
[18:01:03.092]                       stop(msg)
[18:01:03.092]                     }
[18:01:03.092]                     invisible(pathname)
[18:01:03.092]                   }
[18:01:03.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.092]                     rootPath = tempdir()) 
[18:01:03.092]                   {
[18:01:03.092]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.092]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.092]                       tmpdir = path, fileext = ".rds")
[18:01:03.092]                     save_rds(obj, file)
[18:01:03.092]                   }
[18:01:03.092]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.092]                   {
[18:01:03.092]                     inherits <- base::inherits
[18:01:03.092]                     invokeRestart <- base::invokeRestart
[18:01:03.092]                     is.null <- base::is.null
[18:01:03.092]                     muffled <- FALSE
[18:01:03.092]                     if (inherits(cond, "message")) {
[18:01:03.092]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.092]                       if (muffled) 
[18:01:03.092]                         invokeRestart("muffleMessage")
[18:01:03.092]                     }
[18:01:03.092]                     else if (inherits(cond, "warning")) {
[18:01:03.092]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.092]                       if (muffled) 
[18:01:03.092]                         invokeRestart("muffleWarning")
[18:01:03.092]                     }
[18:01:03.092]                     else if (inherits(cond, "condition")) {
[18:01:03.092]                       if (!is.null(pattern)) {
[18:01:03.092]                         computeRestarts <- base::computeRestarts
[18:01:03.092]                         grepl <- base::grepl
[18:01:03.092]                         restarts <- computeRestarts(cond)
[18:01:03.092]                         for (restart in restarts) {
[18:01:03.092]                           name <- restart$name
[18:01:03.092]                           if (is.null(name)) 
[18:01:03.092]                             next
[18:01:03.092]                           if (!grepl(pattern, name)) 
[18:01:03.092]                             next
[18:01:03.092]                           invokeRestart(restart)
[18:01:03.092]                           muffled <- TRUE
[18:01:03.092]                           break
[18:01:03.092]                         }
[18:01:03.092]                       }
[18:01:03.092]                     }
[18:01:03.092]                     invisible(muffled)
[18:01:03.092]                   }
[18:01:03.092]                   muffleCondition(cond)
[18:01:03.092]                 })
[18:01:03.092]             }))
[18:01:03.092]             future::FutureResult(value = ...future.value$value, 
[18:01:03.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.092]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.092]                     ...future.globalenv.names))
[18:01:03.092]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.092]         }, condition = base::local({
[18:01:03.092]             c <- base::c
[18:01:03.092]             inherits <- base::inherits
[18:01:03.092]             invokeRestart <- base::invokeRestart
[18:01:03.092]             length <- base::length
[18:01:03.092]             list <- base::list
[18:01:03.092]             seq.int <- base::seq.int
[18:01:03.092]             signalCondition <- base::signalCondition
[18:01:03.092]             sys.calls <- base::sys.calls
[18:01:03.092]             `[[` <- base::`[[`
[18:01:03.092]             `+` <- base::`+`
[18:01:03.092]             `<<-` <- base::`<<-`
[18:01:03.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.092]                   3L)]
[18:01:03.092]             }
[18:01:03.092]             function(cond) {
[18:01:03.092]                 is_error <- inherits(cond, "error")
[18:01:03.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.092]                   NULL)
[18:01:03.092]                 if (is_error) {
[18:01:03.092]                   sessionInformation <- function() {
[18:01:03.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.092]                       search = base::search(), system = base::Sys.info())
[18:01:03.092]                   }
[18:01:03.092]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.092]                     cond$call), session = sessionInformation(), 
[18:01:03.092]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.092]                   signalCondition(cond)
[18:01:03.092]                 }
[18:01:03.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.092]                 "immediateCondition"))) {
[18:01:03.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.092]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.092]                   if (TRUE && !signal) {
[18:01:03.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.092]                     {
[18:01:03.092]                       inherits <- base::inherits
[18:01:03.092]                       invokeRestart <- base::invokeRestart
[18:01:03.092]                       is.null <- base::is.null
[18:01:03.092]                       muffled <- FALSE
[18:01:03.092]                       if (inherits(cond, "message")) {
[18:01:03.092]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.092]                         if (muffled) 
[18:01:03.092]                           invokeRestart("muffleMessage")
[18:01:03.092]                       }
[18:01:03.092]                       else if (inherits(cond, "warning")) {
[18:01:03.092]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.092]                         if (muffled) 
[18:01:03.092]                           invokeRestart("muffleWarning")
[18:01:03.092]                       }
[18:01:03.092]                       else if (inherits(cond, "condition")) {
[18:01:03.092]                         if (!is.null(pattern)) {
[18:01:03.092]                           computeRestarts <- base::computeRestarts
[18:01:03.092]                           grepl <- base::grepl
[18:01:03.092]                           restarts <- computeRestarts(cond)
[18:01:03.092]                           for (restart in restarts) {
[18:01:03.092]                             name <- restart$name
[18:01:03.092]                             if (is.null(name)) 
[18:01:03.092]                               next
[18:01:03.092]                             if (!grepl(pattern, name)) 
[18:01:03.092]                               next
[18:01:03.092]                             invokeRestart(restart)
[18:01:03.092]                             muffled <- TRUE
[18:01:03.092]                             break
[18:01:03.092]                           }
[18:01:03.092]                         }
[18:01:03.092]                       }
[18:01:03.092]                       invisible(muffled)
[18:01:03.092]                     }
[18:01:03.092]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.092]                   }
[18:01:03.092]                 }
[18:01:03.092]                 else {
[18:01:03.092]                   if (TRUE) {
[18:01:03.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.092]                     {
[18:01:03.092]                       inherits <- base::inherits
[18:01:03.092]                       invokeRestart <- base::invokeRestart
[18:01:03.092]                       is.null <- base::is.null
[18:01:03.092]                       muffled <- FALSE
[18:01:03.092]                       if (inherits(cond, "message")) {
[18:01:03.092]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.092]                         if (muffled) 
[18:01:03.092]                           invokeRestart("muffleMessage")
[18:01:03.092]                       }
[18:01:03.092]                       else if (inherits(cond, "warning")) {
[18:01:03.092]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.092]                         if (muffled) 
[18:01:03.092]                           invokeRestart("muffleWarning")
[18:01:03.092]                       }
[18:01:03.092]                       else if (inherits(cond, "condition")) {
[18:01:03.092]                         if (!is.null(pattern)) {
[18:01:03.092]                           computeRestarts <- base::computeRestarts
[18:01:03.092]                           grepl <- base::grepl
[18:01:03.092]                           restarts <- computeRestarts(cond)
[18:01:03.092]                           for (restart in restarts) {
[18:01:03.092]                             name <- restart$name
[18:01:03.092]                             if (is.null(name)) 
[18:01:03.092]                               next
[18:01:03.092]                             if (!grepl(pattern, name)) 
[18:01:03.092]                               next
[18:01:03.092]                             invokeRestart(restart)
[18:01:03.092]                             muffled <- TRUE
[18:01:03.092]                             break
[18:01:03.092]                           }
[18:01:03.092]                         }
[18:01:03.092]                       }
[18:01:03.092]                       invisible(muffled)
[18:01:03.092]                     }
[18:01:03.092]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.092]                   }
[18:01:03.092]                 }
[18:01:03.092]             }
[18:01:03.092]         }))
[18:01:03.092]     }, error = function(ex) {
[18:01:03.092]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.092]                 ...future.rng), started = ...future.startTime, 
[18:01:03.092]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.092]             version = "1.8"), class = "FutureResult")
[18:01:03.092]     }, finally = {
[18:01:03.092]         if (!identical(...future.workdir, getwd())) 
[18:01:03.092]             setwd(...future.workdir)
[18:01:03.092]         {
[18:01:03.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.092]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.092]             }
[18:01:03.092]             base::options(...future.oldOptions)
[18:01:03.092]             if (.Platform$OS.type == "windows") {
[18:01:03.092]                 old_names <- names(...future.oldEnvVars)
[18:01:03.092]                 envs <- base::Sys.getenv()
[18:01:03.092]                 names <- names(envs)
[18:01:03.092]                 common <- intersect(names, old_names)
[18:01:03.092]                 added <- setdiff(names, old_names)
[18:01:03.092]                 removed <- setdiff(old_names, names)
[18:01:03.092]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.092]                   envs[common]]
[18:01:03.092]                 NAMES <- toupper(changed)
[18:01:03.092]                 args <- list()
[18:01:03.092]                 for (kk in seq_along(NAMES)) {
[18:01:03.092]                   name <- changed[[kk]]
[18:01:03.092]                   NAME <- NAMES[[kk]]
[18:01:03.092]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.092]                     next
[18:01:03.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.092]                 }
[18:01:03.092]                 NAMES <- toupper(added)
[18:01:03.092]                 for (kk in seq_along(NAMES)) {
[18:01:03.092]                   name <- added[[kk]]
[18:01:03.092]                   NAME <- NAMES[[kk]]
[18:01:03.092]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.092]                     next
[18:01:03.092]                   args[[name]] <- ""
[18:01:03.092]                 }
[18:01:03.092]                 NAMES <- toupper(removed)
[18:01:03.092]                 for (kk in seq_along(NAMES)) {
[18:01:03.092]                   name <- removed[[kk]]
[18:01:03.092]                   NAME <- NAMES[[kk]]
[18:01:03.092]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.092]                     next
[18:01:03.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.092]                 }
[18:01:03.092]                 if (length(args) > 0) 
[18:01:03.092]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.092]             }
[18:01:03.092]             else {
[18:01:03.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.092]             }
[18:01:03.092]             {
[18:01:03.092]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.092]                   0L) {
[18:01:03.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.092]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.092]                   base::options(opts)
[18:01:03.092]                 }
[18:01:03.092]                 {
[18:01:03.092]                   {
[18:01:03.092]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.092]                     NULL
[18:01:03.092]                   }
[18:01:03.092]                   options(future.plan = NULL)
[18:01:03.092]                   if (is.na(NA_character_)) 
[18:01:03.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.092]                     .init = FALSE)
[18:01:03.092]                 }
[18:01:03.092]             }
[18:01:03.092]         }
[18:01:03.092]     })
[18:01:03.092]     if (TRUE) {
[18:01:03.092]         base::sink(type = "output", split = FALSE)
[18:01:03.092]         if (TRUE) {
[18:01:03.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.092]         }
[18:01:03.092]         else {
[18:01:03.092]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.092]         }
[18:01:03.092]         base::close(...future.stdout)
[18:01:03.092]         ...future.stdout <- NULL
[18:01:03.092]     }
[18:01:03.092]     ...future.result$conditions <- ...future.conditions
[18:01:03.092]     ...future.result$finished <- base::Sys.time()
[18:01:03.092]     ...future.result
[18:01:03.092] }
[18:01:03.097] assign_globals() ...
[18:01:03.097] List of 5
[18:01:03.097]  $ ...future.FUN            :function (x, ...)  
[18:01:03.097]  $ MoreArgs                 : NULL
[18:01:03.097]  $ ...future.elements_ii    :List of 2
[18:01:03.097]   ..$ :List of 2
[18:01:03.097]   .. ..$ : int 1
[18:01:03.097]   .. ..$ : int 2
[18:01:03.097]   ..$ :List of 2
[18:01:03.097]   .. ..$ : int 2
[18:01:03.097]   .. ..$ : int 1
[18:01:03.097]  $ ...future.seeds_ii       : NULL
[18:01:03.097]  $ ...future.globals.maxSize: NULL
[18:01:03.097]  - attr(*, "where")=List of 5
[18:01:03.097]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.097]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.097]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.097]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.097]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.097]  - attr(*, "resolved")= logi FALSE
[18:01:03.097]  - attr(*, "total_size")= num 280
[18:01:03.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.097]  - attr(*, "already-done")= logi TRUE
[18:01:03.112] - copied ‘...future.FUN’ to environment
[18:01:03.113] - copied ‘MoreArgs’ to environment
[18:01:03.113] - copied ‘...future.elements_ii’ to environment
[18:01:03.113] - copied ‘...future.seeds_ii’ to environment
[18:01:03.113] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.113] assign_globals() ... done
[18:01:03.114] requestCore(): workers = 2
[18:01:03.118] MulticoreFuture started
[18:01:03.119] - Launch lazy future ... done
[18:01:03.120] plan(): Setting new future strategy stack:
[18:01:03.120] run() for ‘MulticoreFuture’ ... done
[18:01:03.121] Created future:
[18:01:03.121] List of future strategies:
[18:01:03.121] 1. sequential:
[18:01:03.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.121]    - tweaked: FALSE
[18:01:03.121]    - call: NULL
[18:01:03.125] plan(): nbrOfWorkers() = 1
[18:01:03.131] plan(): Setting new future strategy stack:
[18:01:03.132] List of future strategies:
[18:01:03.132] 1. multicore:
[18:01:03.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.132]    - tweaked: FALSE
[18:01:03.132]    - call: plan(strategy)
[18:01:03.122] MulticoreFuture:
[18:01:03.122] Label: ‘future_mapply-1’
[18:01:03.122] Expression:
[18:01:03.122] {
[18:01:03.122]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.122]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.122]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.122]         on.exit(options(oopts), add = TRUE)
[18:01:03.122]     }
[18:01:03.122]     {
[18:01:03.122]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.122]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.122]         do.call(mapply, args = args)
[18:01:03.122]     }
[18:01:03.122] }
[18:01:03.122] Lazy evaluation: FALSE
[18:01:03.122] Asynchronous evaluation: TRUE
[18:01:03.122] Local evaluation: TRUE
[18:01:03.122] Environment: R_GlobalEnv
[18:01:03.122] Capture standard output: TRUE
[18:01:03.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.122] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.122] Packages: <none>
[18:01:03.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:03.122] Resolved: FALSE
[18:01:03.122] Value: <not collected>
[18:01:03.122] Conditions captured: <none>
[18:01:03.122] Early signaling: FALSE
[18:01:03.122] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.122] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.139] Chunk #1 of 2 ... DONE
[18:01:03.140] Chunk #2 of 2 ...
[18:01:03.140]  - Finding globals in '...' for chunk #2 ...
[18:01:03.141] getGlobalsAndPackages() ...
[18:01:03.141] Searching for globals...
[18:01:03.143] 
[18:01:03.143] Searching for globals ... DONE
[18:01:03.143] - globals: [0] <none>
[18:01:03.144] getGlobalsAndPackages() ... DONE
[18:01:03.144]    + additional globals found: [n=0] 
[18:01:03.144] plan(): nbrOfWorkers() = 2
[18:01:03.144]    + additional namespaces needed: [n=0] 
[18:01:03.145]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:03.145]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.145]  - seeds: <none>
[18:01:03.146]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.146] getGlobalsAndPackages() ...
[18:01:03.147] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.149] Resolving globals: FALSE
[18:01:03.152] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:03.154] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:03.154] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.155] 
[18:01:03.155] getGlobalsAndPackages() ... DONE
[18:01:03.157] run() for ‘Future’ ...
[18:01:03.157] - state: ‘created’
[18:01:03.158] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.167]   - Field: ‘label’
[18:01:03.167]   - Field: ‘local’
[18:01:03.168]   - Field: ‘owner’
[18:01:03.168]   - Field: ‘envir’
[18:01:03.168]   - Field: ‘workers’
[18:01:03.169]   - Field: ‘packages’
[18:01:03.169]   - Field: ‘gc’
[18:01:03.170]   - Field: ‘job’
[18:01:03.170]   - Field: ‘conditions’
[18:01:03.170]   - Field: ‘expr’
[18:01:03.171]   - Field: ‘uuid’
[18:01:03.171]   - Field: ‘seed’
[18:01:03.171]   - Field: ‘version’
[18:01:03.172]   - Field: ‘result’
[18:01:03.172]   - Field: ‘asynchronous’
[18:01:03.172]   - Field: ‘calls’
[18:01:03.173]   - Field: ‘globals’
[18:01:03.173]   - Field: ‘stdout’
[18:01:03.173]   - Field: ‘earlySignal’
[18:01:03.174]   - Field: ‘lazy’
[18:01:03.174]   - Field: ‘state’
[18:01:03.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.175] - Launch lazy future ...
[18:01:03.176] Packages needed by the future expression (n = 0): <none>
[18:01:03.176] Packages needed by future strategies (n = 0): <none>
[18:01:03.177] {
[18:01:03.177]     {
[18:01:03.177]         {
[18:01:03.177]             ...future.startTime <- base::Sys.time()
[18:01:03.177]             {
[18:01:03.177]                 {
[18:01:03.177]                   {
[18:01:03.177]                     {
[18:01:03.177]                       base::local({
[18:01:03.177]                         has_future <- base::requireNamespace("future", 
[18:01:03.177]                           quietly = TRUE)
[18:01:03.177]                         if (has_future) {
[18:01:03.177]                           ns <- base::getNamespace("future")
[18:01:03.177]                           version <- ns[[".package"]][["version"]]
[18:01:03.177]                           if (is.null(version)) 
[18:01:03.177]                             version <- utils::packageVersion("future")
[18:01:03.177]                         }
[18:01:03.177]                         else {
[18:01:03.177]                           version <- NULL
[18:01:03.177]                         }
[18:01:03.177]                         if (!has_future || version < "1.8.0") {
[18:01:03.177]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.177]                             "", base::R.version$version.string), 
[18:01:03.177]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:03.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:03.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.177]                               "release", "version")], collapse = " "), 
[18:01:03.177]                             hostname = base::Sys.info()[["nodename"]])
[18:01:03.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.177]                             info)
[18:01:03.177]                           info <- base::paste(info, collapse = "; ")
[18:01:03.177]                           if (!has_future) {
[18:01:03.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.177]                               info)
[18:01:03.177]                           }
[18:01:03.177]                           else {
[18:01:03.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.177]                               info, version)
[18:01:03.177]                           }
[18:01:03.177]                           base::stop(msg)
[18:01:03.177]                         }
[18:01:03.177]                       })
[18:01:03.177]                     }
[18:01:03.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.177]                     base::options(mc.cores = 1L)
[18:01:03.177]                   }
[18:01:03.177]                   ...future.strategy.old <- future::plan("list")
[18:01:03.177]                   options(future.plan = NULL)
[18:01:03.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.177]                 }
[18:01:03.177]                 ...future.workdir <- getwd()
[18:01:03.177]             }
[18:01:03.177]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.177]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.177]         }
[18:01:03.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.177]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.177]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.177]             base::names(...future.oldOptions))
[18:01:03.177]     }
[18:01:03.177]     if (FALSE) {
[18:01:03.177]     }
[18:01:03.177]     else {
[18:01:03.177]         if (TRUE) {
[18:01:03.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.177]                 open = "w")
[18:01:03.177]         }
[18:01:03.177]         else {
[18:01:03.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.177]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.177]         }
[18:01:03.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.177]             base::sink(type = "output", split = FALSE)
[18:01:03.177]             base::close(...future.stdout)
[18:01:03.177]         }, add = TRUE)
[18:01:03.177]     }
[18:01:03.177]     ...future.frame <- base::sys.nframe()
[18:01:03.177]     ...future.conditions <- base::list()
[18:01:03.177]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.177]     if (FALSE) {
[18:01:03.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.177]     }
[18:01:03.177]     ...future.result <- base::tryCatch({
[18:01:03.177]         base::withCallingHandlers({
[18:01:03.177]             ...future.value <- base::withVisible(base::local({
[18:01:03.177]                 withCallingHandlers({
[18:01:03.177]                   {
[18:01:03.177]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.177]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.177]                       ...future.globals.maxSize)) {
[18:01:03.177]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.177]                       on.exit(options(oopts), add = TRUE)
[18:01:03.177]                     }
[18:01:03.177]                     {
[18:01:03.177]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.177]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.177]                         USE.NAMES = FALSE)
[18:01:03.177]                       do.call(mapply, args = args)
[18:01:03.177]                     }
[18:01:03.177]                   }
[18:01:03.177]                 }, immediateCondition = function(cond) {
[18:01:03.177]                   save_rds <- function (object, pathname, ...) 
[18:01:03.177]                   {
[18:01:03.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.177]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.177]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.177]                         fi_tmp[["mtime"]])
[18:01:03.177]                     }
[18:01:03.177]                     tryCatch({
[18:01:03.177]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.177]                     }, error = function(ex) {
[18:01:03.177]                       msg <- conditionMessage(ex)
[18:01:03.177]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.177]                         fi_tmp[["mtime"]], msg)
[18:01:03.177]                       ex$message <- msg
[18:01:03.177]                       stop(ex)
[18:01:03.177]                     })
[18:01:03.177]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.177]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.177]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.177]                       fi <- file.info(pathname)
[18:01:03.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.177]                         fi[["size"]], fi[["mtime"]])
[18:01:03.177]                       stop(msg)
[18:01:03.177]                     }
[18:01:03.177]                     invisible(pathname)
[18:01:03.177]                   }
[18:01:03.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.177]                     rootPath = tempdir()) 
[18:01:03.177]                   {
[18:01:03.177]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.177]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.177]                       tmpdir = path, fileext = ".rds")
[18:01:03.177]                     save_rds(obj, file)
[18:01:03.177]                   }
[18:01:03.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.177]                   {
[18:01:03.177]                     inherits <- base::inherits
[18:01:03.177]                     invokeRestart <- base::invokeRestart
[18:01:03.177]                     is.null <- base::is.null
[18:01:03.177]                     muffled <- FALSE
[18:01:03.177]                     if (inherits(cond, "message")) {
[18:01:03.177]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.177]                       if (muffled) 
[18:01:03.177]                         invokeRestart("muffleMessage")
[18:01:03.177]                     }
[18:01:03.177]                     else if (inherits(cond, "warning")) {
[18:01:03.177]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.177]                       if (muffled) 
[18:01:03.177]                         invokeRestart("muffleWarning")
[18:01:03.177]                     }
[18:01:03.177]                     else if (inherits(cond, "condition")) {
[18:01:03.177]                       if (!is.null(pattern)) {
[18:01:03.177]                         computeRestarts <- base::computeRestarts
[18:01:03.177]                         grepl <- base::grepl
[18:01:03.177]                         restarts <- computeRestarts(cond)
[18:01:03.177]                         for (restart in restarts) {
[18:01:03.177]                           name <- restart$name
[18:01:03.177]                           if (is.null(name)) 
[18:01:03.177]                             next
[18:01:03.177]                           if (!grepl(pattern, name)) 
[18:01:03.177]                             next
[18:01:03.177]                           invokeRestart(restart)
[18:01:03.177]                           muffled <- TRUE
[18:01:03.177]                           break
[18:01:03.177]                         }
[18:01:03.177]                       }
[18:01:03.177]                     }
[18:01:03.177]                     invisible(muffled)
[18:01:03.177]                   }
[18:01:03.177]                   muffleCondition(cond)
[18:01:03.177]                 })
[18:01:03.177]             }))
[18:01:03.177]             future::FutureResult(value = ...future.value$value, 
[18:01:03.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.177]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.177]                     ...future.globalenv.names))
[18:01:03.177]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.177]         }, condition = base::local({
[18:01:03.177]             c <- base::c
[18:01:03.177]             inherits <- base::inherits
[18:01:03.177]             invokeRestart <- base::invokeRestart
[18:01:03.177]             length <- base::length
[18:01:03.177]             list <- base::list
[18:01:03.177]             seq.int <- base::seq.int
[18:01:03.177]             signalCondition <- base::signalCondition
[18:01:03.177]             sys.calls <- base::sys.calls
[18:01:03.177]             `[[` <- base::`[[`
[18:01:03.177]             `+` <- base::`+`
[18:01:03.177]             `<<-` <- base::`<<-`
[18:01:03.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.177]                   3L)]
[18:01:03.177]             }
[18:01:03.177]             function(cond) {
[18:01:03.177]                 is_error <- inherits(cond, "error")
[18:01:03.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.177]                   NULL)
[18:01:03.177]                 if (is_error) {
[18:01:03.177]                   sessionInformation <- function() {
[18:01:03.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.177]                       search = base::search(), system = base::Sys.info())
[18:01:03.177]                   }
[18:01:03.177]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.177]                     cond$call), session = sessionInformation(), 
[18:01:03.177]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.177]                   signalCondition(cond)
[18:01:03.177]                 }
[18:01:03.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.177]                 "immediateCondition"))) {
[18:01:03.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.177]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.177]                   if (TRUE && !signal) {
[18:01:03.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.177]                     {
[18:01:03.177]                       inherits <- base::inherits
[18:01:03.177]                       invokeRestart <- base::invokeRestart
[18:01:03.177]                       is.null <- base::is.null
[18:01:03.177]                       muffled <- FALSE
[18:01:03.177]                       if (inherits(cond, "message")) {
[18:01:03.177]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.177]                         if (muffled) 
[18:01:03.177]                           invokeRestart("muffleMessage")
[18:01:03.177]                       }
[18:01:03.177]                       else if (inherits(cond, "warning")) {
[18:01:03.177]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.177]                         if (muffled) 
[18:01:03.177]                           invokeRestart("muffleWarning")
[18:01:03.177]                       }
[18:01:03.177]                       else if (inherits(cond, "condition")) {
[18:01:03.177]                         if (!is.null(pattern)) {
[18:01:03.177]                           computeRestarts <- base::computeRestarts
[18:01:03.177]                           grepl <- base::grepl
[18:01:03.177]                           restarts <- computeRestarts(cond)
[18:01:03.177]                           for (restart in restarts) {
[18:01:03.177]                             name <- restart$name
[18:01:03.177]                             if (is.null(name)) 
[18:01:03.177]                               next
[18:01:03.177]                             if (!grepl(pattern, name)) 
[18:01:03.177]                               next
[18:01:03.177]                             invokeRestart(restart)
[18:01:03.177]                             muffled <- TRUE
[18:01:03.177]                             break
[18:01:03.177]                           }
[18:01:03.177]                         }
[18:01:03.177]                       }
[18:01:03.177]                       invisible(muffled)
[18:01:03.177]                     }
[18:01:03.177]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.177]                   }
[18:01:03.177]                 }
[18:01:03.177]                 else {
[18:01:03.177]                   if (TRUE) {
[18:01:03.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.177]                     {
[18:01:03.177]                       inherits <- base::inherits
[18:01:03.177]                       invokeRestart <- base::invokeRestart
[18:01:03.177]                       is.null <- base::is.null
[18:01:03.177]                       muffled <- FALSE
[18:01:03.177]                       if (inherits(cond, "message")) {
[18:01:03.177]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.177]                         if (muffled) 
[18:01:03.177]                           invokeRestart("muffleMessage")
[18:01:03.177]                       }
[18:01:03.177]                       else if (inherits(cond, "warning")) {
[18:01:03.177]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.177]                         if (muffled) 
[18:01:03.177]                           invokeRestart("muffleWarning")
[18:01:03.177]                       }
[18:01:03.177]                       else if (inherits(cond, "condition")) {
[18:01:03.177]                         if (!is.null(pattern)) {
[18:01:03.177]                           computeRestarts <- base::computeRestarts
[18:01:03.177]                           grepl <- base::grepl
[18:01:03.177]                           restarts <- computeRestarts(cond)
[18:01:03.177]                           for (restart in restarts) {
[18:01:03.177]                             name <- restart$name
[18:01:03.177]                             if (is.null(name)) 
[18:01:03.177]                               next
[18:01:03.177]                             if (!grepl(pattern, name)) 
[18:01:03.177]                               next
[18:01:03.177]                             invokeRestart(restart)
[18:01:03.177]                             muffled <- TRUE
[18:01:03.177]                             break
[18:01:03.177]                           }
[18:01:03.177]                         }
[18:01:03.177]                       }
[18:01:03.177]                       invisible(muffled)
[18:01:03.177]                     }
[18:01:03.177]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.177]                   }
[18:01:03.177]                 }
[18:01:03.177]             }
[18:01:03.177]         }))
[18:01:03.177]     }, error = function(ex) {
[18:01:03.177]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.177]                 ...future.rng), started = ...future.startTime, 
[18:01:03.177]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.177]             version = "1.8"), class = "FutureResult")
[18:01:03.177]     }, finally = {
[18:01:03.177]         if (!identical(...future.workdir, getwd())) 
[18:01:03.177]             setwd(...future.workdir)
[18:01:03.177]         {
[18:01:03.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.177]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.177]             }
[18:01:03.177]             base::options(...future.oldOptions)
[18:01:03.177]             if (.Platform$OS.type == "windows") {
[18:01:03.177]                 old_names <- names(...future.oldEnvVars)
[18:01:03.177]                 envs <- base::Sys.getenv()
[18:01:03.177]                 names <- names(envs)
[18:01:03.177]                 common <- intersect(names, old_names)
[18:01:03.177]                 added <- setdiff(names, old_names)
[18:01:03.177]                 removed <- setdiff(old_names, names)
[18:01:03.177]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.177]                   envs[common]]
[18:01:03.177]                 NAMES <- toupper(changed)
[18:01:03.177]                 args <- list()
[18:01:03.177]                 for (kk in seq_along(NAMES)) {
[18:01:03.177]                   name <- changed[[kk]]
[18:01:03.177]                   NAME <- NAMES[[kk]]
[18:01:03.177]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.177]                     next
[18:01:03.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.177]                 }
[18:01:03.177]                 NAMES <- toupper(added)
[18:01:03.177]                 for (kk in seq_along(NAMES)) {
[18:01:03.177]                   name <- added[[kk]]
[18:01:03.177]                   NAME <- NAMES[[kk]]
[18:01:03.177]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.177]                     next
[18:01:03.177]                   args[[name]] <- ""
[18:01:03.177]                 }
[18:01:03.177]                 NAMES <- toupper(removed)
[18:01:03.177]                 for (kk in seq_along(NAMES)) {
[18:01:03.177]                   name <- removed[[kk]]
[18:01:03.177]                   NAME <- NAMES[[kk]]
[18:01:03.177]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.177]                     next
[18:01:03.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.177]                 }
[18:01:03.177]                 if (length(args) > 0) 
[18:01:03.177]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.177]             }
[18:01:03.177]             else {
[18:01:03.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.177]             }
[18:01:03.177]             {
[18:01:03.177]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.177]                   0L) {
[18:01:03.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.177]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.177]                   base::options(opts)
[18:01:03.177]                 }
[18:01:03.177]                 {
[18:01:03.177]                   {
[18:01:03.177]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.177]                     NULL
[18:01:03.177]                   }
[18:01:03.177]                   options(future.plan = NULL)
[18:01:03.177]                   if (is.na(NA_character_)) 
[18:01:03.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.177]                     .init = FALSE)
[18:01:03.177]                 }
[18:01:03.177]             }
[18:01:03.177]         }
[18:01:03.177]     })
[18:01:03.177]     if (TRUE) {
[18:01:03.177]         base::sink(type = "output", split = FALSE)
[18:01:03.177]         if (TRUE) {
[18:01:03.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.177]         }
[18:01:03.177]         else {
[18:01:03.177]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.177]         }
[18:01:03.177]         base::close(...future.stdout)
[18:01:03.177]         ...future.stdout <- NULL
[18:01:03.177]     }
[18:01:03.177]     ...future.result$conditions <- ...future.conditions
[18:01:03.177]     ...future.result$finished <- base::Sys.time()
[18:01:03.177]     ...future.result
[18:01:03.177] }
[18:01:03.185] assign_globals() ...
[18:01:03.185] List of 5
[18:01:03.185]  $ ...future.FUN            :function (x, ...)  
[18:01:03.185]  $ MoreArgs                 : NULL
[18:01:03.185]  $ ...future.elements_ii    :List of 2
[18:01:03.185]   ..$ :List of 2
[18:01:03.185]   .. ..$ : int 3
[18:01:03.185]   .. ..$ : int 4
[18:01:03.185]   ..$ :List of 2
[18:01:03.185]   .. ..$ : int 2
[18:01:03.185]   .. ..$ : int 1
[18:01:03.185]  $ ...future.seeds_ii       : NULL
[18:01:03.185]  $ ...future.globals.maxSize: NULL
[18:01:03.185]  - attr(*, "where")=List of 5
[18:01:03.185]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.185]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.185]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.185]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.185]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.185]  - attr(*, "resolved")= logi FALSE
[18:01:03.185]  - attr(*, "total_size")= num 280
[18:01:03.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.185]  - attr(*, "already-done")= logi TRUE
[18:01:03.200] - copied ‘...future.FUN’ to environment
[18:01:03.201] - copied ‘MoreArgs’ to environment
[18:01:03.201] - copied ‘...future.elements_ii’ to environment
[18:01:03.201] - copied ‘...future.seeds_ii’ to environment
[18:01:03.201] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.202] assign_globals() ... done
[18:01:03.202] requestCore(): workers = 2
[18:01:03.208] MulticoreFuture started
[18:01:03.209] - Launch lazy future ... done
[18:01:03.211] plan(): Setting new future strategy stack:
[18:01:03.209] run() for ‘MulticoreFuture’ ... done
[18:01:03.212] Created future:
[18:01:03.211] List of future strategies:
[18:01:03.211] 1. sequential:
[18:01:03.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.211]    - tweaked: FALSE
[18:01:03.211]    - call: NULL
[18:01:03.216] plan(): nbrOfWorkers() = 1
[18:01:03.230] plan(): Setting new future strategy stack:
[18:01:03.231] List of future strategies:
[18:01:03.231] 1. multicore:
[18:01:03.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.231]    - tweaked: FALSE
[18:01:03.231]    - call: plan(strategy)
[18:01:03.213] MulticoreFuture:
[18:01:03.213] Label: ‘future_mapply-2’
[18:01:03.213] Expression:
[18:01:03.213] {
[18:01:03.213]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.213]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.213]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.213]         on.exit(options(oopts), add = TRUE)
[18:01:03.213]     }
[18:01:03.213]     {
[18:01:03.213]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.213]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.213]         do.call(mapply, args = args)
[18:01:03.213]     }
[18:01:03.213] }
[18:01:03.213] Lazy evaluation: FALSE
[18:01:03.213] Asynchronous evaluation: TRUE
[18:01:03.213] Local evaluation: TRUE
[18:01:03.213] Environment: R_GlobalEnv
[18:01:03.213] Capture standard output: TRUE
[18:01:03.213] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.213] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.213] Packages: <none>
[18:01:03.213] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:03.213] Resolved: FALSE
[18:01:03.213] Value: <not collected>
[18:01:03.213] Conditions captured: <none>
[18:01:03.213] Early signaling: FALSE
[18:01:03.213] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.213] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.239] Chunk #2 of 2 ... DONE
[18:01:03.239] Launching 2 futures (chunks) ... DONE
[18:01:03.239] Resolving 2 futures (chunks) ...
[18:01:03.240] resolve() on list ...
[18:01:03.241]  recursive: 0
[18:01:03.241]  length: 2
[18:01:03.241] 
[18:01:03.242] Future #1
[18:01:03.243] result() for MulticoreFuture ...
[18:01:03.243] plan(): nbrOfWorkers() = 2
[18:01:03.244] result() for MulticoreFuture ...
[18:01:03.245] result() for MulticoreFuture ... done
[18:01:03.245] result() for MulticoreFuture ... done
[18:01:03.246] result() for MulticoreFuture ...
[18:01:03.246] result() for MulticoreFuture ... done
[18:01:03.247] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:03.247] - nx: 2
[18:01:03.248] - relay: TRUE
[18:01:03.248] - stdout: TRUE
[18:01:03.248] - signal: TRUE
[18:01:03.249] - resignal: FALSE
[18:01:03.249] - force: TRUE
[18:01:03.250] - relayed: [n=2] FALSE, FALSE
[18:01:03.250] - queued futures: [n=2] FALSE, FALSE
[18:01:03.251]  - until=1
[18:01:03.251]  - relaying element #1
[18:01:03.251] result() for MulticoreFuture ...
[18:01:03.252] result() for MulticoreFuture ... done
[18:01:03.252] result() for MulticoreFuture ...
[18:01:03.252] result() for MulticoreFuture ... done
[18:01:03.253] result() for MulticoreFuture ...
[18:01:03.253] result() for MulticoreFuture ... done
[18:01:03.254] result() for MulticoreFuture ...
[18:01:03.254] result() for MulticoreFuture ... done
[18:01:03.255] - relayed: [n=2] TRUE, FALSE
[18:01:03.255] - queued futures: [n=2] TRUE, FALSE
[18:01:03.255] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:03.256]  length: 1 (resolved future 1)
[18:01:03.256] Future #2
[18:01:03.257] result() for MulticoreFuture ...
[18:01:03.259] result() for MulticoreFuture ...
[18:01:03.259] result() for MulticoreFuture ... done
[18:01:03.259] result() for MulticoreFuture ... done
[18:01:03.260] result() for MulticoreFuture ...
[18:01:03.260] result() for MulticoreFuture ... done
[18:01:03.260] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:03.261] - nx: 2
[18:01:03.261] - relay: TRUE
[18:01:03.261] - stdout: TRUE
[18:01:03.261] - signal: TRUE
[18:01:03.262] - resignal: FALSE
[18:01:03.262] - force: TRUE
[18:01:03.262] - relayed: [n=2] TRUE, FALSE
[18:01:03.262] - queued futures: [n=2] TRUE, FALSE
[18:01:03.263]  - until=2
[18:01:03.263]  - relaying element #2
[18:01:03.263] result() for MulticoreFuture ...
[18:01:03.263] result() for MulticoreFuture ... done
[18:01:03.263] result() for MulticoreFuture ...
[18:01:03.264] result() for MulticoreFuture ... done
[18:01:03.264] result() for MulticoreFuture ...
[18:01:03.264] result() for MulticoreFuture ... done
[18:01:03.264] result() for MulticoreFuture ...
[18:01:03.265] result() for MulticoreFuture ... done
[18:01:03.265] - relayed: [n=2] TRUE, TRUE
[18:01:03.265] - queued futures: [n=2] TRUE, TRUE
[18:01:03.265] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:03.266]  length: 0 (resolved future 2)
[18:01:03.266] Relaying remaining futures
[18:01:03.266] signalConditionsASAP(NULL, pos=0) ...
[18:01:03.266] - nx: 2
[18:01:03.267] - relay: TRUE
[18:01:03.267] - stdout: TRUE
[18:01:03.267] - signal: TRUE
[18:01:03.267] - resignal: FALSE
[18:01:03.267] - force: TRUE
[18:01:03.268] - relayed: [n=2] TRUE, TRUE
[18:01:03.268] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:03.268] - relayed: [n=2] TRUE, TRUE
[18:01:03.268] - queued futures: [n=2] TRUE, TRUE
[18:01:03.268] signalConditionsASAP(NULL, pos=0) ... done
[18:01:03.269] resolve() on list ... DONE
[18:01:03.269] result() for MulticoreFuture ...
[18:01:03.269] result() for MulticoreFuture ... done
[18:01:03.269] result() for MulticoreFuture ...
[18:01:03.270] result() for MulticoreFuture ... done
[18:01:03.270] result() for MulticoreFuture ...
[18:01:03.270] result() for MulticoreFuture ... done
[18:01:03.270] result() for MulticoreFuture ...
[18:01:03.270] result() for MulticoreFuture ... done
[18:01:03.271]  - Number of value chunks collected: 2
[18:01:03.271] Resolving 2 futures (chunks) ... DONE
[18:01:03.271] Reducing values from 2 chunks ...
[18:01:03.271]  - Number of values collected after concatenation: 4
[18:01:03.271]  - Number of values expected: 4
[18:01:03.272] Reducing values from 2 chunks ... DONE
[18:01:03.272] future_mapply() ... DONE
- Parallel RNG ...
[18:01:03.272] future_mapply() ...
[18:01:03.273] Generating random seeds ...
[18:01:03.273] Generating random seed streams for 4 elements ...
[18:01:03.273] Generating random seed streams for 4 elements ... DONE
[18:01:03.273] Generating random seeds ... DONE
[18:01:03.274] Will set RNG state on exit: 10407, 24920035, -136088852, -1629779828, 85963198, 1969343818, -1958893774
[18:01:03.280] Number of chunks: 2
[18:01:03.281] getGlobalsAndPackagesXApply() ...
[18:01:03.281]  - future.globals: TRUE
[18:01:03.281] getGlobalsAndPackages() ...
[18:01:03.281] Searching for globals...
[18:01:03.284] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[18:01:03.284] Searching for globals ... DONE
[18:01:03.285] Resolving globals: FALSE
[18:01:03.286] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[18:01:03.287] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[18:01:03.287] - globals: [1] ‘FUN’
[18:01:03.287] - packages: [1] ‘stats’
[18:01:03.287] getGlobalsAndPackages() ... DONE
[18:01:03.288]  - globals found/used: [n=1] ‘FUN’
[18:01:03.288]  - needed namespaces: [n=1] ‘stats’
[18:01:03.288] Finding globals ... DONE
[18:01:03.288] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:03.289] List of 2
[18:01:03.289]  $ ...future.FUN:function (n, min = 0, max = 1)  
[18:01:03.289]  $ MoreArgs     :List of 1
[18:01:03.289]   ..$ min: num 1
[18:01:03.289]  - attr(*, "where")=List of 2
[18:01:03.289]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:03.289]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:03.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.289]  - attr(*, "resolved")= logi FALSE
[18:01:03.289]  - attr(*, "total_size")= num NA
[18:01:03.298] Packages to be attached in all futures: [n=1] ‘stats’
[18:01:03.298] getGlobalsAndPackagesXApply() ... DONE
[18:01:03.299] Number of futures (= number of chunks): 2
[18:01:03.299] Launching 2 futures (chunks) ...
[18:01:03.299] Chunk #1 of 2 ...
[18:01:03.300]  - Finding globals in '...' for chunk #1 ...
[18:01:03.300] getGlobalsAndPackages() ...
[18:01:03.300] Searching for globals...
[18:01:03.301] 
[18:01:03.301] Searching for globals ... DONE
[18:01:03.301] - globals: [0] <none>
[18:01:03.301] getGlobalsAndPackages() ... DONE
[18:01:03.302]    + additional globals found: [n=0] 
[18:01:03.302]    + additional namespaces needed: [n=0] 
[18:01:03.302]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:03.302]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.302]  - seeds: [2] <seeds>
[18:01:03.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.303] getGlobalsAndPackages() ...
[18:01:03.303] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.303] Resolving globals: FALSE
[18:01:03.304] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[18:01:03.305] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[18:01:03.306] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.306] - packages: [1] ‘stats’
[18:01:03.306] getGlobalsAndPackages() ... DONE
[18:01:03.307] run() for ‘Future’ ...
[18:01:03.307] - state: ‘created’
[18:01:03.307] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.314] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.315]   - Field: ‘label’
[18:01:03.315]   - Field: ‘local’
[18:01:03.315]   - Field: ‘owner’
[18:01:03.315]   - Field: ‘envir’
[18:01:03.316]   - Field: ‘workers’
[18:01:03.316]   - Field: ‘packages’
[18:01:03.316]   - Field: ‘gc’
[18:01:03.316]   - Field: ‘job’
[18:01:03.316]   - Field: ‘conditions’
[18:01:03.317]   - Field: ‘expr’
[18:01:03.317]   - Field: ‘uuid’
[18:01:03.317]   - Field: ‘seed’
[18:01:03.317]   - Field: ‘version’
[18:01:03.317]   - Field: ‘result’
[18:01:03.318]   - Field: ‘asynchronous’
[18:01:03.318]   - Field: ‘calls’
[18:01:03.318]   - Field: ‘globals’
[18:01:03.318]   - Field: ‘stdout’
[18:01:03.318]   - Field: ‘earlySignal’
[18:01:03.319]   - Field: ‘lazy’
[18:01:03.319]   - Field: ‘state’
[18:01:03.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.319] - Launch lazy future ...
[18:01:03.320] Packages needed by the future expression (n = 1): ‘stats’
[18:01:03.320] Packages needed by future strategies (n = 0): <none>
[18:01:03.321] {
[18:01:03.321]     {
[18:01:03.321]         {
[18:01:03.321]             ...future.startTime <- base::Sys.time()
[18:01:03.321]             {
[18:01:03.321]                 {
[18:01:03.321]                   {
[18:01:03.321]                     {
[18:01:03.321]                       {
[18:01:03.321]                         base::local({
[18:01:03.321]                           has_future <- base::requireNamespace("future", 
[18:01:03.321]                             quietly = TRUE)
[18:01:03.321]                           if (has_future) {
[18:01:03.321]                             ns <- base::getNamespace("future")
[18:01:03.321]                             version <- ns[[".package"]][["version"]]
[18:01:03.321]                             if (is.null(version)) 
[18:01:03.321]                               version <- utils::packageVersion("future")
[18:01:03.321]                           }
[18:01:03.321]                           else {
[18:01:03.321]                             version <- NULL
[18:01:03.321]                           }
[18:01:03.321]                           if (!has_future || version < "1.8.0") {
[18:01:03.321]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.321]                               "", base::R.version$version.string), 
[18:01:03.321]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:03.321]                                 base::R.version$platform, 8 * 
[18:01:03.321]                                   base::.Machine$sizeof.pointer), 
[18:01:03.321]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.321]                                 "release", "version")], collapse = " "), 
[18:01:03.321]                               hostname = base::Sys.info()[["nodename"]])
[18:01:03.321]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.321]                               info)
[18:01:03.321]                             info <- base::paste(info, collapse = "; ")
[18:01:03.321]                             if (!has_future) {
[18:01:03.321]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.321]                                 info)
[18:01:03.321]                             }
[18:01:03.321]                             else {
[18:01:03.321]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.321]                                 info, version)
[18:01:03.321]                             }
[18:01:03.321]                             base::stop(msg)
[18:01:03.321]                           }
[18:01:03.321]                         })
[18:01:03.321]                       }
[18:01:03.321]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.321]                       base::options(mc.cores = 1L)
[18:01:03.321]                     }
[18:01:03.321]                     base::local({
[18:01:03.321]                       for (pkg in "stats") {
[18:01:03.321]                         base::loadNamespace(pkg)
[18:01:03.321]                         base::library(pkg, character.only = TRUE)
[18:01:03.321]                       }
[18:01:03.321]                     })
[18:01:03.321]                   }
[18:01:03.321]                   ...future.strategy.old <- future::plan("list")
[18:01:03.321]                   options(future.plan = NULL)
[18:01:03.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.321]                 }
[18:01:03.321]                 ...future.workdir <- getwd()
[18:01:03.321]             }
[18:01:03.321]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.321]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.321]         }
[18:01:03.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.321]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.321]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.321]             base::names(...future.oldOptions))
[18:01:03.321]     }
[18:01:03.321]     if (FALSE) {
[18:01:03.321]     }
[18:01:03.321]     else {
[18:01:03.321]         if (TRUE) {
[18:01:03.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.321]                 open = "w")
[18:01:03.321]         }
[18:01:03.321]         else {
[18:01:03.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.321]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.321]         }
[18:01:03.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.321]             base::sink(type = "output", split = FALSE)
[18:01:03.321]             base::close(...future.stdout)
[18:01:03.321]         }, add = TRUE)
[18:01:03.321]     }
[18:01:03.321]     ...future.frame <- base::sys.nframe()
[18:01:03.321]     ...future.conditions <- base::list()
[18:01:03.321]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.321]     if (FALSE) {
[18:01:03.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.321]     }
[18:01:03.321]     ...future.result <- base::tryCatch({
[18:01:03.321]         base::withCallingHandlers({
[18:01:03.321]             ...future.value <- base::withVisible(base::local({
[18:01:03.321]                 withCallingHandlers({
[18:01:03.321]                   {
[18:01:03.321]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.321]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.321]                       ...future.globals.maxSize)) {
[18:01:03.321]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.321]                       on.exit(options(oopts), add = TRUE)
[18:01:03.321]                     }
[18:01:03.321]                     {
[18:01:03.321]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:03.321]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:03.321]                           envir = globalenv(), inherits = FALSE)
[18:01:03.321]                         ...future.FUN(...)
[18:01:03.321]                       }
[18:01:03.321]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:03.321]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:03.321]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.321]                         USE.NAMES = FALSE)
[18:01:03.321]                       do.call(mapply, args = args)
[18:01:03.321]                     }
[18:01:03.321]                   }
[18:01:03.321]                 }, immediateCondition = function(cond) {
[18:01:03.321]                   save_rds <- function (object, pathname, ...) 
[18:01:03.321]                   {
[18:01:03.321]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.321]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.321]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.321]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.321]                         fi_tmp[["mtime"]])
[18:01:03.321]                     }
[18:01:03.321]                     tryCatch({
[18:01:03.321]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.321]                     }, error = function(ex) {
[18:01:03.321]                       msg <- conditionMessage(ex)
[18:01:03.321]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.321]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.321]                         fi_tmp[["mtime"]], msg)
[18:01:03.321]                       ex$message <- msg
[18:01:03.321]                       stop(ex)
[18:01:03.321]                     })
[18:01:03.321]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.321]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.321]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.321]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.321]                       fi <- file.info(pathname)
[18:01:03.321]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.321]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.321]                         fi[["size"]], fi[["mtime"]])
[18:01:03.321]                       stop(msg)
[18:01:03.321]                     }
[18:01:03.321]                     invisible(pathname)
[18:01:03.321]                   }
[18:01:03.321]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.321]                     rootPath = tempdir()) 
[18:01:03.321]                   {
[18:01:03.321]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.321]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.321]                       tmpdir = path, fileext = ".rds")
[18:01:03.321]                     save_rds(obj, file)
[18:01:03.321]                   }
[18:01:03.321]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.321]                   {
[18:01:03.321]                     inherits <- base::inherits
[18:01:03.321]                     invokeRestart <- base::invokeRestart
[18:01:03.321]                     is.null <- base::is.null
[18:01:03.321]                     muffled <- FALSE
[18:01:03.321]                     if (inherits(cond, "message")) {
[18:01:03.321]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.321]                       if (muffled) 
[18:01:03.321]                         invokeRestart("muffleMessage")
[18:01:03.321]                     }
[18:01:03.321]                     else if (inherits(cond, "warning")) {
[18:01:03.321]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.321]                       if (muffled) 
[18:01:03.321]                         invokeRestart("muffleWarning")
[18:01:03.321]                     }
[18:01:03.321]                     else if (inherits(cond, "condition")) {
[18:01:03.321]                       if (!is.null(pattern)) {
[18:01:03.321]                         computeRestarts <- base::computeRestarts
[18:01:03.321]                         grepl <- base::grepl
[18:01:03.321]                         restarts <- computeRestarts(cond)
[18:01:03.321]                         for (restart in restarts) {
[18:01:03.321]                           name <- restart$name
[18:01:03.321]                           if (is.null(name)) 
[18:01:03.321]                             next
[18:01:03.321]                           if (!grepl(pattern, name)) 
[18:01:03.321]                             next
[18:01:03.321]                           invokeRestart(restart)
[18:01:03.321]                           muffled <- TRUE
[18:01:03.321]                           break
[18:01:03.321]                         }
[18:01:03.321]                       }
[18:01:03.321]                     }
[18:01:03.321]                     invisible(muffled)
[18:01:03.321]                   }
[18:01:03.321]                   muffleCondition(cond)
[18:01:03.321]                 })
[18:01:03.321]             }))
[18:01:03.321]             future::FutureResult(value = ...future.value$value, 
[18:01:03.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.321]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.321]                     ...future.globalenv.names))
[18:01:03.321]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.321]         }, condition = base::local({
[18:01:03.321]             c <- base::c
[18:01:03.321]             inherits <- base::inherits
[18:01:03.321]             invokeRestart <- base::invokeRestart
[18:01:03.321]             length <- base::length
[18:01:03.321]             list <- base::list
[18:01:03.321]             seq.int <- base::seq.int
[18:01:03.321]             signalCondition <- base::signalCondition
[18:01:03.321]             sys.calls <- base::sys.calls
[18:01:03.321]             `[[` <- base::`[[`
[18:01:03.321]             `+` <- base::`+`
[18:01:03.321]             `<<-` <- base::`<<-`
[18:01:03.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.321]                   3L)]
[18:01:03.321]             }
[18:01:03.321]             function(cond) {
[18:01:03.321]                 is_error <- inherits(cond, "error")
[18:01:03.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.321]                   NULL)
[18:01:03.321]                 if (is_error) {
[18:01:03.321]                   sessionInformation <- function() {
[18:01:03.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.321]                       search = base::search(), system = base::Sys.info())
[18:01:03.321]                   }
[18:01:03.321]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.321]                     cond$call), session = sessionInformation(), 
[18:01:03.321]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.321]                   signalCondition(cond)
[18:01:03.321]                 }
[18:01:03.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.321]                 "immediateCondition"))) {
[18:01:03.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.321]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.321]                   if (TRUE && !signal) {
[18:01:03.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.321]                     {
[18:01:03.321]                       inherits <- base::inherits
[18:01:03.321]                       invokeRestart <- base::invokeRestart
[18:01:03.321]                       is.null <- base::is.null
[18:01:03.321]                       muffled <- FALSE
[18:01:03.321]                       if (inherits(cond, "message")) {
[18:01:03.321]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.321]                         if (muffled) 
[18:01:03.321]                           invokeRestart("muffleMessage")
[18:01:03.321]                       }
[18:01:03.321]                       else if (inherits(cond, "warning")) {
[18:01:03.321]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.321]                         if (muffled) 
[18:01:03.321]                           invokeRestart("muffleWarning")
[18:01:03.321]                       }
[18:01:03.321]                       else if (inherits(cond, "condition")) {
[18:01:03.321]                         if (!is.null(pattern)) {
[18:01:03.321]                           computeRestarts <- base::computeRestarts
[18:01:03.321]                           grepl <- base::grepl
[18:01:03.321]                           restarts <- computeRestarts(cond)
[18:01:03.321]                           for (restart in restarts) {
[18:01:03.321]                             name <- restart$name
[18:01:03.321]                             if (is.null(name)) 
[18:01:03.321]                               next
[18:01:03.321]                             if (!grepl(pattern, name)) 
[18:01:03.321]                               next
[18:01:03.321]                             invokeRestart(restart)
[18:01:03.321]                             muffled <- TRUE
[18:01:03.321]                             break
[18:01:03.321]                           }
[18:01:03.321]                         }
[18:01:03.321]                       }
[18:01:03.321]                       invisible(muffled)
[18:01:03.321]                     }
[18:01:03.321]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.321]                   }
[18:01:03.321]                 }
[18:01:03.321]                 else {
[18:01:03.321]                   if (TRUE) {
[18:01:03.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.321]                     {
[18:01:03.321]                       inherits <- base::inherits
[18:01:03.321]                       invokeRestart <- base::invokeRestart
[18:01:03.321]                       is.null <- base::is.null
[18:01:03.321]                       muffled <- FALSE
[18:01:03.321]                       if (inherits(cond, "message")) {
[18:01:03.321]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.321]                         if (muffled) 
[18:01:03.321]                           invokeRestart("muffleMessage")
[18:01:03.321]                       }
[18:01:03.321]                       else if (inherits(cond, "warning")) {
[18:01:03.321]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.321]                         if (muffled) 
[18:01:03.321]                           invokeRestart("muffleWarning")
[18:01:03.321]                       }
[18:01:03.321]                       else if (inherits(cond, "condition")) {
[18:01:03.321]                         if (!is.null(pattern)) {
[18:01:03.321]                           computeRestarts <- base::computeRestarts
[18:01:03.321]                           grepl <- base::grepl
[18:01:03.321]                           restarts <- computeRestarts(cond)
[18:01:03.321]                           for (restart in restarts) {
[18:01:03.321]                             name <- restart$name
[18:01:03.321]                             if (is.null(name)) 
[18:01:03.321]                               next
[18:01:03.321]                             if (!grepl(pattern, name)) 
[18:01:03.321]                               next
[18:01:03.321]                             invokeRestart(restart)
[18:01:03.321]                             muffled <- TRUE
[18:01:03.321]                             break
[18:01:03.321]                           }
[18:01:03.321]                         }
[18:01:03.321]                       }
[18:01:03.321]                       invisible(muffled)
[18:01:03.321]                     }
[18:01:03.321]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.321]                   }
[18:01:03.321]                 }
[18:01:03.321]             }
[18:01:03.321]         }))
[18:01:03.321]     }, error = function(ex) {
[18:01:03.321]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.321]                 ...future.rng), started = ...future.startTime, 
[18:01:03.321]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.321]             version = "1.8"), class = "FutureResult")
[18:01:03.321]     }, finally = {
[18:01:03.321]         if (!identical(...future.workdir, getwd())) 
[18:01:03.321]             setwd(...future.workdir)
[18:01:03.321]         {
[18:01:03.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.321]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.321]             }
[18:01:03.321]             base::options(...future.oldOptions)
[18:01:03.321]             if (.Platform$OS.type == "windows") {
[18:01:03.321]                 old_names <- names(...future.oldEnvVars)
[18:01:03.321]                 envs <- base::Sys.getenv()
[18:01:03.321]                 names <- names(envs)
[18:01:03.321]                 common <- intersect(names, old_names)
[18:01:03.321]                 added <- setdiff(names, old_names)
[18:01:03.321]                 removed <- setdiff(old_names, names)
[18:01:03.321]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.321]                   envs[common]]
[18:01:03.321]                 NAMES <- toupper(changed)
[18:01:03.321]                 args <- list()
[18:01:03.321]                 for (kk in seq_along(NAMES)) {
[18:01:03.321]                   name <- changed[[kk]]
[18:01:03.321]                   NAME <- NAMES[[kk]]
[18:01:03.321]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.321]                     next
[18:01:03.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.321]                 }
[18:01:03.321]                 NAMES <- toupper(added)
[18:01:03.321]                 for (kk in seq_along(NAMES)) {
[18:01:03.321]                   name <- added[[kk]]
[18:01:03.321]                   NAME <- NAMES[[kk]]
[18:01:03.321]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.321]                     next
[18:01:03.321]                   args[[name]] <- ""
[18:01:03.321]                 }
[18:01:03.321]                 NAMES <- toupper(removed)
[18:01:03.321]                 for (kk in seq_along(NAMES)) {
[18:01:03.321]                   name <- removed[[kk]]
[18:01:03.321]                   NAME <- NAMES[[kk]]
[18:01:03.321]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.321]                     next
[18:01:03.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.321]                 }
[18:01:03.321]                 if (length(args) > 0) 
[18:01:03.321]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.321]             }
[18:01:03.321]             else {
[18:01:03.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.321]             }
[18:01:03.321]             {
[18:01:03.321]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.321]                   0L) {
[18:01:03.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.321]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.321]                   base::options(opts)
[18:01:03.321]                 }
[18:01:03.321]                 {
[18:01:03.321]                   {
[18:01:03.321]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.321]                     NULL
[18:01:03.321]                   }
[18:01:03.321]                   options(future.plan = NULL)
[18:01:03.321]                   if (is.na(NA_character_)) 
[18:01:03.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.321]                     .init = FALSE)
[18:01:03.321]                 }
[18:01:03.321]             }
[18:01:03.321]         }
[18:01:03.321]     })
[18:01:03.321]     if (TRUE) {
[18:01:03.321]         base::sink(type = "output", split = FALSE)
[18:01:03.321]         if (TRUE) {
[18:01:03.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.321]         }
[18:01:03.321]         else {
[18:01:03.321]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.321]         }
[18:01:03.321]         base::close(...future.stdout)
[18:01:03.321]         ...future.stdout <- NULL
[18:01:03.321]     }
[18:01:03.321]     ...future.result$conditions <- ...future.conditions
[18:01:03.321]     ...future.result$finished <- base::Sys.time()
[18:01:03.321]     ...future.result
[18:01:03.321] }
[18:01:03.326] assign_globals() ...
[18:01:03.326] List of 5
[18:01:03.326]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[18:01:03.326]  $ MoreArgs                 :List of 1
[18:01:03.326]   ..$ min: num 1
[18:01:03.326]  $ ...future.elements_ii    :List of 2
[18:01:03.326]   ..$ n  :List of 2
[18:01:03.326]   .. ..$ : int 1
[18:01:03.326]   .. ..$ : int 2
[18:01:03.326]   ..$ max:List of 2
[18:01:03.326]   .. ..$ : int 2
[18:01:03.326]   .. ..$ : int 3
[18:01:03.326]  $ ...future.seeds_ii       :List of 2
[18:01:03.326]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[18:01:03.326]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[18:01:03.326]  $ ...future.globals.maxSize: NULL
[18:01:03.326]  - attr(*, "where")=List of 5
[18:01:03.326]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.326]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.326]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.326]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.326]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.326]  - attr(*, "resolved")= logi FALSE
[18:01:03.326]  - attr(*, "total_size")= num 2528
[18:01:03.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.326]  - attr(*, "already-done")= logi TRUE
[18:01:03.340] - copied ‘...future.FUN’ to environment
[18:01:03.340] - copied ‘MoreArgs’ to environment
[18:01:03.340] - copied ‘...future.elements_ii’ to environment
[18:01:03.340] - copied ‘...future.seeds_ii’ to environment
[18:01:03.340] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.341] assign_globals() ... done
[18:01:03.341] requestCore(): workers = 2
[18:01:03.345] MulticoreFuture started
[18:01:03.346] - Launch lazy future ... done
[18:01:03.346] run() for ‘MulticoreFuture’ ... done
[18:01:03.347] Created future:
[18:01:03.348] plan(): Setting new future strategy stack:
[18:01:03.349] List of future strategies:
[18:01:03.349] 1. sequential:
[18:01:03.349]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.349]    - tweaked: FALSE
[18:01:03.349]    - call: NULL
[18:01:03.358] plan(): nbrOfWorkers() = 1
[18:01:03.364] plan(): Setting new future strategy stack:
[18:01:03.365] List of future strategies:
[18:01:03.365] 1. multicore:
[18:01:03.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.365]    - tweaked: FALSE
[18:01:03.365]    - call: plan(strategy)
[18:01:03.347] MulticoreFuture:
[18:01:03.347] Label: ‘future_mapply-1’
[18:01:03.347] Expression:
[18:01:03.347] {
[18:01:03.347]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.347]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.347]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.347]         on.exit(options(oopts), add = TRUE)
[18:01:03.347]     }
[18:01:03.347]     {
[18:01:03.347]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:03.347]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:03.347]                 inherits = FALSE)
[18:01:03.347]             ...future.FUN(...)
[18:01:03.347]         }
[18:01:03.347]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:03.347]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:03.347]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.347]         do.call(mapply, args = args)
[18:01:03.347]     }
[18:01:03.347] }
[18:01:03.347] Lazy evaluation: FALSE
[18:01:03.347] Asynchronous evaluation: TRUE
[18:01:03.347] Local evaluation: TRUE
[18:01:03.347] Environment: R_GlobalEnv
[18:01:03.347] Capture standard output: TRUE
[18:01:03.347] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.347] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.347] Packages: 1 packages (‘stats’)
[18:01:03.347] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:03.347] Resolved: FALSE
[18:01:03.347] Value: <not collected>
[18:01:03.347] Conditions captured: <none>
[18:01:03.347] Early signaling: FALSE
[18:01:03.347] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.347] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.371] Chunk #1 of 2 ... DONE
[18:01:03.371] Chunk #2 of 2 ...
[18:01:03.372]  - Finding globals in '...' for chunk #2 ...
[18:01:03.372] getGlobalsAndPackages() ...
[18:01:03.373] Searching for globals...
[18:01:03.375] 
[18:01:03.376] Searching for globals ... DONE
[18:01:03.376] - globals: [0] <none>
[18:01:03.378] getGlobalsAndPackages() ... DONE
[18:01:03.379]    + additional globals found: [n=0] 
[18:01:03.379]    + additional namespaces needed: [n=0] 
[18:01:03.380]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:03.380]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.381]  - seeds: [2] <seeds>
[18:01:03.381]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.382] getGlobalsAndPackages() ...
[18:01:03.382] plan(): nbrOfWorkers() = 2
[18:01:03.382] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.383] Resolving globals: FALSE
[18:01:03.385] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[18:01:03.387] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[18:01:03.388] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.388] - packages: [1] ‘stats’
[18:01:03.389] getGlobalsAndPackages() ... DONE
[18:01:03.390] run() for ‘Future’ ...
[18:01:03.390] - state: ‘created’
[18:01:03.391] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.399] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.400]   - Field: ‘label’
[18:01:03.401]   - Field: ‘local’
[18:01:03.401]   - Field: ‘owner’
[18:01:03.401]   - Field: ‘envir’
[18:01:03.402]   - Field: ‘workers’
[18:01:03.402]   - Field: ‘packages’
[18:01:03.402]   - Field: ‘gc’
[18:01:03.402]   - Field: ‘job’
[18:01:03.403]   - Field: ‘conditions’
[18:01:03.403]   - Field: ‘expr’
[18:01:03.403]   - Field: ‘uuid’
[18:01:03.403]   - Field: ‘seed’
[18:01:03.404]   - Field: ‘version’
[18:01:03.404]   - Field: ‘result’
[18:01:03.404]   - Field: ‘asynchronous’
[18:01:03.405]   - Field: ‘calls’
[18:01:03.405]   - Field: ‘globals’
[18:01:03.405]   - Field: ‘stdout’
[18:01:03.406]   - Field: ‘earlySignal’
[18:01:03.406]   - Field: ‘lazy’
[18:01:03.406]   - Field: ‘state’
[18:01:03.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.407] - Launch lazy future ...
[18:01:03.408] Packages needed by the future expression (n = 1): ‘stats’
[18:01:03.408] Packages needed by future strategies (n = 0): <none>
[18:01:03.410] {
[18:01:03.410]     {
[18:01:03.410]         {
[18:01:03.410]             ...future.startTime <- base::Sys.time()
[18:01:03.410]             {
[18:01:03.410]                 {
[18:01:03.410]                   {
[18:01:03.410]                     {
[18:01:03.410]                       {
[18:01:03.410]                         base::local({
[18:01:03.410]                           has_future <- base::requireNamespace("future", 
[18:01:03.410]                             quietly = TRUE)
[18:01:03.410]                           if (has_future) {
[18:01:03.410]                             ns <- base::getNamespace("future")
[18:01:03.410]                             version <- ns[[".package"]][["version"]]
[18:01:03.410]                             if (is.null(version)) 
[18:01:03.410]                               version <- utils::packageVersion("future")
[18:01:03.410]                           }
[18:01:03.410]                           else {
[18:01:03.410]                             version <- NULL
[18:01:03.410]                           }
[18:01:03.410]                           if (!has_future || version < "1.8.0") {
[18:01:03.410]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.410]                               "", base::R.version$version.string), 
[18:01:03.410]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:03.410]                                 base::R.version$platform, 8 * 
[18:01:03.410]                                   base::.Machine$sizeof.pointer), 
[18:01:03.410]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.410]                                 "release", "version")], collapse = " "), 
[18:01:03.410]                               hostname = base::Sys.info()[["nodename"]])
[18:01:03.410]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.410]                               info)
[18:01:03.410]                             info <- base::paste(info, collapse = "; ")
[18:01:03.410]                             if (!has_future) {
[18:01:03.410]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.410]                                 info)
[18:01:03.410]                             }
[18:01:03.410]                             else {
[18:01:03.410]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.410]                                 info, version)
[18:01:03.410]                             }
[18:01:03.410]                             base::stop(msg)
[18:01:03.410]                           }
[18:01:03.410]                         })
[18:01:03.410]                       }
[18:01:03.410]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.410]                       base::options(mc.cores = 1L)
[18:01:03.410]                     }
[18:01:03.410]                     base::local({
[18:01:03.410]                       for (pkg in "stats") {
[18:01:03.410]                         base::loadNamespace(pkg)
[18:01:03.410]                         base::library(pkg, character.only = TRUE)
[18:01:03.410]                       }
[18:01:03.410]                     })
[18:01:03.410]                   }
[18:01:03.410]                   ...future.strategy.old <- future::plan("list")
[18:01:03.410]                   options(future.plan = NULL)
[18:01:03.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.410]                 }
[18:01:03.410]                 ...future.workdir <- getwd()
[18:01:03.410]             }
[18:01:03.410]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.410]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.410]         }
[18:01:03.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.410]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.410]             base::names(...future.oldOptions))
[18:01:03.410]     }
[18:01:03.410]     if (FALSE) {
[18:01:03.410]     }
[18:01:03.410]     else {
[18:01:03.410]         if (TRUE) {
[18:01:03.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.410]                 open = "w")
[18:01:03.410]         }
[18:01:03.410]         else {
[18:01:03.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.410]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.410]         }
[18:01:03.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.410]             base::sink(type = "output", split = FALSE)
[18:01:03.410]             base::close(...future.stdout)
[18:01:03.410]         }, add = TRUE)
[18:01:03.410]     }
[18:01:03.410]     ...future.frame <- base::sys.nframe()
[18:01:03.410]     ...future.conditions <- base::list()
[18:01:03.410]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.410]     if (FALSE) {
[18:01:03.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.410]     }
[18:01:03.410]     ...future.result <- base::tryCatch({
[18:01:03.410]         base::withCallingHandlers({
[18:01:03.410]             ...future.value <- base::withVisible(base::local({
[18:01:03.410]                 withCallingHandlers({
[18:01:03.410]                   {
[18:01:03.410]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.410]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.410]                       ...future.globals.maxSize)) {
[18:01:03.410]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.410]                       on.exit(options(oopts), add = TRUE)
[18:01:03.410]                     }
[18:01:03.410]                     {
[18:01:03.410]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:03.410]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:03.410]                           envir = globalenv(), inherits = FALSE)
[18:01:03.410]                         ...future.FUN(...)
[18:01:03.410]                       }
[18:01:03.410]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:03.410]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:03.410]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.410]                         USE.NAMES = FALSE)
[18:01:03.410]                       do.call(mapply, args = args)
[18:01:03.410]                     }
[18:01:03.410]                   }
[18:01:03.410]                 }, immediateCondition = function(cond) {
[18:01:03.410]                   save_rds <- function (object, pathname, ...) 
[18:01:03.410]                   {
[18:01:03.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.410]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.410]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.410]                         fi_tmp[["mtime"]])
[18:01:03.410]                     }
[18:01:03.410]                     tryCatch({
[18:01:03.410]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.410]                     }, error = function(ex) {
[18:01:03.410]                       msg <- conditionMessage(ex)
[18:01:03.410]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.410]                         fi_tmp[["mtime"]], msg)
[18:01:03.410]                       ex$message <- msg
[18:01:03.410]                       stop(ex)
[18:01:03.410]                     })
[18:01:03.410]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.410]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.410]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.410]                       fi <- file.info(pathname)
[18:01:03.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.410]                         fi[["size"]], fi[["mtime"]])
[18:01:03.410]                       stop(msg)
[18:01:03.410]                     }
[18:01:03.410]                     invisible(pathname)
[18:01:03.410]                   }
[18:01:03.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.410]                     rootPath = tempdir()) 
[18:01:03.410]                   {
[18:01:03.410]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.410]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.410]                       tmpdir = path, fileext = ".rds")
[18:01:03.410]                     save_rds(obj, file)
[18:01:03.410]                   }
[18:01:03.410]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.410]                   {
[18:01:03.410]                     inherits <- base::inherits
[18:01:03.410]                     invokeRestart <- base::invokeRestart
[18:01:03.410]                     is.null <- base::is.null
[18:01:03.410]                     muffled <- FALSE
[18:01:03.410]                     if (inherits(cond, "message")) {
[18:01:03.410]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.410]                       if (muffled) 
[18:01:03.410]                         invokeRestart("muffleMessage")
[18:01:03.410]                     }
[18:01:03.410]                     else if (inherits(cond, "warning")) {
[18:01:03.410]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.410]                       if (muffled) 
[18:01:03.410]                         invokeRestart("muffleWarning")
[18:01:03.410]                     }
[18:01:03.410]                     else if (inherits(cond, "condition")) {
[18:01:03.410]                       if (!is.null(pattern)) {
[18:01:03.410]                         computeRestarts <- base::computeRestarts
[18:01:03.410]                         grepl <- base::grepl
[18:01:03.410]                         restarts <- computeRestarts(cond)
[18:01:03.410]                         for (restart in restarts) {
[18:01:03.410]                           name <- restart$name
[18:01:03.410]                           if (is.null(name)) 
[18:01:03.410]                             next
[18:01:03.410]                           if (!grepl(pattern, name)) 
[18:01:03.410]                             next
[18:01:03.410]                           invokeRestart(restart)
[18:01:03.410]                           muffled <- TRUE
[18:01:03.410]                           break
[18:01:03.410]                         }
[18:01:03.410]                       }
[18:01:03.410]                     }
[18:01:03.410]                     invisible(muffled)
[18:01:03.410]                   }
[18:01:03.410]                   muffleCondition(cond)
[18:01:03.410]                 })
[18:01:03.410]             }))
[18:01:03.410]             future::FutureResult(value = ...future.value$value, 
[18:01:03.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.410]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.410]                     ...future.globalenv.names))
[18:01:03.410]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.410]         }, condition = base::local({
[18:01:03.410]             c <- base::c
[18:01:03.410]             inherits <- base::inherits
[18:01:03.410]             invokeRestart <- base::invokeRestart
[18:01:03.410]             length <- base::length
[18:01:03.410]             list <- base::list
[18:01:03.410]             seq.int <- base::seq.int
[18:01:03.410]             signalCondition <- base::signalCondition
[18:01:03.410]             sys.calls <- base::sys.calls
[18:01:03.410]             `[[` <- base::`[[`
[18:01:03.410]             `+` <- base::`+`
[18:01:03.410]             `<<-` <- base::`<<-`
[18:01:03.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.410]                   3L)]
[18:01:03.410]             }
[18:01:03.410]             function(cond) {
[18:01:03.410]                 is_error <- inherits(cond, "error")
[18:01:03.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.410]                   NULL)
[18:01:03.410]                 if (is_error) {
[18:01:03.410]                   sessionInformation <- function() {
[18:01:03.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.410]                       search = base::search(), system = base::Sys.info())
[18:01:03.410]                   }
[18:01:03.410]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.410]                     cond$call), session = sessionInformation(), 
[18:01:03.410]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.410]                   signalCondition(cond)
[18:01:03.410]                 }
[18:01:03.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.410]                 "immediateCondition"))) {
[18:01:03.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.410]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.410]                   if (TRUE && !signal) {
[18:01:03.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.410]                     {
[18:01:03.410]                       inherits <- base::inherits
[18:01:03.410]                       invokeRestart <- base::invokeRestart
[18:01:03.410]                       is.null <- base::is.null
[18:01:03.410]                       muffled <- FALSE
[18:01:03.410]                       if (inherits(cond, "message")) {
[18:01:03.410]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.410]                         if (muffled) 
[18:01:03.410]                           invokeRestart("muffleMessage")
[18:01:03.410]                       }
[18:01:03.410]                       else if (inherits(cond, "warning")) {
[18:01:03.410]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.410]                         if (muffled) 
[18:01:03.410]                           invokeRestart("muffleWarning")
[18:01:03.410]                       }
[18:01:03.410]                       else if (inherits(cond, "condition")) {
[18:01:03.410]                         if (!is.null(pattern)) {
[18:01:03.410]                           computeRestarts <- base::computeRestarts
[18:01:03.410]                           grepl <- base::grepl
[18:01:03.410]                           restarts <- computeRestarts(cond)
[18:01:03.410]                           for (restart in restarts) {
[18:01:03.410]                             name <- restart$name
[18:01:03.410]                             if (is.null(name)) 
[18:01:03.410]                               next
[18:01:03.410]                             if (!grepl(pattern, name)) 
[18:01:03.410]                               next
[18:01:03.410]                             invokeRestart(restart)
[18:01:03.410]                             muffled <- TRUE
[18:01:03.410]                             break
[18:01:03.410]                           }
[18:01:03.410]                         }
[18:01:03.410]                       }
[18:01:03.410]                       invisible(muffled)
[18:01:03.410]                     }
[18:01:03.410]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.410]                   }
[18:01:03.410]                 }
[18:01:03.410]                 else {
[18:01:03.410]                   if (TRUE) {
[18:01:03.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.410]                     {
[18:01:03.410]                       inherits <- base::inherits
[18:01:03.410]                       invokeRestart <- base::invokeRestart
[18:01:03.410]                       is.null <- base::is.null
[18:01:03.410]                       muffled <- FALSE
[18:01:03.410]                       if (inherits(cond, "message")) {
[18:01:03.410]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.410]                         if (muffled) 
[18:01:03.410]                           invokeRestart("muffleMessage")
[18:01:03.410]                       }
[18:01:03.410]                       else if (inherits(cond, "warning")) {
[18:01:03.410]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.410]                         if (muffled) 
[18:01:03.410]                           invokeRestart("muffleWarning")
[18:01:03.410]                       }
[18:01:03.410]                       else if (inherits(cond, "condition")) {
[18:01:03.410]                         if (!is.null(pattern)) {
[18:01:03.410]                           computeRestarts <- base::computeRestarts
[18:01:03.410]                           grepl <- base::grepl
[18:01:03.410]                           restarts <- computeRestarts(cond)
[18:01:03.410]                           for (restart in restarts) {
[18:01:03.410]                             name <- restart$name
[18:01:03.410]                             if (is.null(name)) 
[18:01:03.410]                               next
[18:01:03.410]                             if (!grepl(pattern, name)) 
[18:01:03.410]                               next
[18:01:03.410]                             invokeRestart(restart)
[18:01:03.410]                             muffled <- TRUE
[18:01:03.410]                             break
[18:01:03.410]                           }
[18:01:03.410]                         }
[18:01:03.410]                       }
[18:01:03.410]                       invisible(muffled)
[18:01:03.410]                     }
[18:01:03.410]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.410]                   }
[18:01:03.410]                 }
[18:01:03.410]             }
[18:01:03.410]         }))
[18:01:03.410]     }, error = function(ex) {
[18:01:03.410]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.410]                 ...future.rng), started = ...future.startTime, 
[18:01:03.410]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.410]             version = "1.8"), class = "FutureResult")
[18:01:03.410]     }, finally = {
[18:01:03.410]         if (!identical(...future.workdir, getwd())) 
[18:01:03.410]             setwd(...future.workdir)
[18:01:03.410]         {
[18:01:03.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.410]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.410]             }
[18:01:03.410]             base::options(...future.oldOptions)
[18:01:03.410]             if (.Platform$OS.type == "windows") {
[18:01:03.410]                 old_names <- names(...future.oldEnvVars)
[18:01:03.410]                 envs <- base::Sys.getenv()
[18:01:03.410]                 names <- names(envs)
[18:01:03.410]                 common <- intersect(names, old_names)
[18:01:03.410]                 added <- setdiff(names, old_names)
[18:01:03.410]                 removed <- setdiff(old_names, names)
[18:01:03.410]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.410]                   envs[common]]
[18:01:03.410]                 NAMES <- toupper(changed)
[18:01:03.410]                 args <- list()
[18:01:03.410]                 for (kk in seq_along(NAMES)) {
[18:01:03.410]                   name <- changed[[kk]]
[18:01:03.410]                   NAME <- NAMES[[kk]]
[18:01:03.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.410]                     next
[18:01:03.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.410]                 }
[18:01:03.410]                 NAMES <- toupper(added)
[18:01:03.410]                 for (kk in seq_along(NAMES)) {
[18:01:03.410]                   name <- added[[kk]]
[18:01:03.410]                   NAME <- NAMES[[kk]]
[18:01:03.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.410]                     next
[18:01:03.410]                   args[[name]] <- ""
[18:01:03.410]                 }
[18:01:03.410]                 NAMES <- toupper(removed)
[18:01:03.410]                 for (kk in seq_along(NAMES)) {
[18:01:03.410]                   name <- removed[[kk]]
[18:01:03.410]                   NAME <- NAMES[[kk]]
[18:01:03.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.410]                     next
[18:01:03.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.410]                 }
[18:01:03.410]                 if (length(args) > 0) 
[18:01:03.410]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.410]             }
[18:01:03.410]             else {
[18:01:03.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.410]             }
[18:01:03.410]             {
[18:01:03.410]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.410]                   0L) {
[18:01:03.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.410]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.410]                   base::options(opts)
[18:01:03.410]                 }
[18:01:03.410]                 {
[18:01:03.410]                   {
[18:01:03.410]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.410]                     NULL
[18:01:03.410]                   }
[18:01:03.410]                   options(future.plan = NULL)
[18:01:03.410]                   if (is.na(NA_character_)) 
[18:01:03.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.410]                     .init = FALSE)
[18:01:03.410]                 }
[18:01:03.410]             }
[18:01:03.410]         }
[18:01:03.410]     })
[18:01:03.410]     if (TRUE) {
[18:01:03.410]         base::sink(type = "output", split = FALSE)
[18:01:03.410]         if (TRUE) {
[18:01:03.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.410]         }
[18:01:03.410]         else {
[18:01:03.410]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.410]         }
[18:01:03.410]         base::close(...future.stdout)
[18:01:03.410]         ...future.stdout <- NULL
[18:01:03.410]     }
[18:01:03.410]     ...future.result$conditions <- ...future.conditions
[18:01:03.410]     ...future.result$finished <- base::Sys.time()
[18:01:03.410]     ...future.result
[18:01:03.410] }
[18:01:03.415] assign_globals() ...
[18:01:03.416] List of 5
[18:01:03.416]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[18:01:03.416]  $ MoreArgs                 :List of 1
[18:01:03.416]   ..$ min: num 1
[18:01:03.416]  $ ...future.elements_ii    :List of 2
[18:01:03.416]   ..$ n  :List of 2
[18:01:03.416]   .. ..$ : int 3
[18:01:03.416]   .. ..$ : int 4
[18:01:03.416]   ..$ max:List of 2
[18:01:03.416]   .. ..$ : int 4
[18:01:03.416]   .. ..$ : int 5
[18:01:03.416]  $ ...future.seeds_ii       :List of 2
[18:01:03.416]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[18:01:03.416]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[18:01:03.416]  $ ...future.globals.maxSize: NULL
[18:01:03.416]  - attr(*, "where")=List of 5
[18:01:03.416]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.416]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.416]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.416]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.416]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.416]  - attr(*, "resolved")= logi FALSE
[18:01:03.416]  - attr(*, "total_size")= num 2528
[18:01:03.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.416]  - attr(*, "already-done")= logi TRUE
[18:01:03.432] - copied ‘...future.FUN’ to environment
[18:01:03.433] - copied ‘MoreArgs’ to environment
[18:01:03.433] - copied ‘...future.elements_ii’ to environment
[18:01:03.433] - copied ‘...future.seeds_ii’ to environment
[18:01:03.433] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.434] assign_globals() ... done
[18:01:03.434] requestCore(): workers = 2
[18:01:03.438] MulticoreFuture started
[18:01:03.439] - Launch lazy future ... done
[18:01:03.439] run() for ‘MulticoreFuture’ ... done
[18:01:03.440] Created future:
[18:01:03.442] plan(): Setting new future strategy stack:
[18:01:03.445] List of future strategies:
[18:01:03.445] 1. sequential:
[18:01:03.445]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.445]    - tweaked: FALSE
[18:01:03.445]    - call: NULL
[18:01:03.458] plan(): nbrOfWorkers() = 1
[18:01:03.440] MulticoreFuture:
[18:01:03.440] Label: ‘future_mapply-2’
[18:01:03.440] Expression:
[18:01:03.440] {
[18:01:03.440]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.440]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.440]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.440]         on.exit(options(oopts), add = TRUE)
[18:01:03.440]     }
[18:01:03.440]     {
[18:01:03.440]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:03.440]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:03.440]                 inherits = FALSE)
[18:01:03.440]             ...future.FUN(...)
[18:01:03.440]         }
[18:01:03.440]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:03.440]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:03.440]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.440]         do.call(mapply, args = args)
[18:01:03.440]     }
[18:01:03.440] }
[18:01:03.440] Lazy evaluation: FALSE
[18:01:03.440] Asynchronous evaluation: TRUE
[18:01:03.440] Local evaluation: TRUE
[18:01:03.440] Environment: R_GlobalEnv
[18:01:03.440] Capture standard output: TRUE
[18:01:03.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.440] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.440] Packages: 1 packages (‘stats’)
[18:01:03.440] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:03.440] Resolved: FALSE
[18:01:03.440] Value: <not collected>
[18:01:03.440] Conditions captured: <none>
[18:01:03.440] Early signaling: FALSE
[18:01:03.440] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.466] plan(): Setting new future strategy stack:
[18:01:03.464] Chunk #2 of 2 ... DONE
[18:01:03.468] Launching 2 futures (chunks) ... DONE
[18:01:03.468] Resolving 2 futures (chunks) ...
[18:01:03.469] resolve() on list ...
[18:01:03.469]  recursive: 0
[18:01:03.467] List of future strategies:
[18:01:03.467] 1. multicore:
[18:01:03.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.467]    - tweaked: FALSE
[18:01:03.467]    - call: plan(strategy)
[18:01:03.470]  length: 2
[18:01:03.473] 
[18:01:03.476] Future #1
[18:01:03.476] result() for MulticoreFuture ...
[18:01:03.479] result() for MulticoreFuture ...
[18:01:03.480] result() for MulticoreFuture ... done
[18:01:03.481] result() for MulticoreFuture ... done
[18:01:03.481] result() for MulticoreFuture ...
[18:01:03.482] result() for MulticoreFuture ... done
[18:01:03.486] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:03.487] - nx: 2
[18:01:03.487] - relay: TRUE
[18:01:03.486] plan(): nbrOfWorkers() = 2
[18:01:03.488] - stdout: TRUE
[18:01:03.489] - signal: TRUE
[18:01:03.489] - resignal: FALSE
[18:01:03.490] - force: TRUE
[18:01:03.490] - relayed: [n=2] FALSE, FALSE
[18:01:03.491] - queued futures: [n=2] FALSE, FALSE
[18:01:03.491]  - until=1
[18:01:03.491]  - relaying element #1
[18:01:03.492] result() for MulticoreFuture ...
[18:01:03.492] result() for MulticoreFuture ... done
[18:01:03.493] result() for MulticoreFuture ...
[18:01:03.493] result() for MulticoreFuture ... done
[18:01:03.494] result() for MulticoreFuture ...
[18:01:03.494] result() for MulticoreFuture ... done
[18:01:03.495] result() for MulticoreFuture ...
[18:01:03.495] result() for MulticoreFuture ... done
[18:01:03.496] - relayed: [n=2] TRUE, FALSE
[18:01:03.496] - queued futures: [n=2] TRUE, FALSE
[18:01:03.496] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:03.497]  length: 1 (resolved future 1)
[18:01:03.498] Future #2
[18:01:03.498] result() for MulticoreFuture ...
[18:01:03.500] result() for MulticoreFuture ...
[18:01:03.501] result() for MulticoreFuture ... done
[18:01:03.501] result() for MulticoreFuture ... done
[18:01:03.501] result() for MulticoreFuture ...
[18:01:03.504] result() for MulticoreFuture ... done
[18:01:03.504] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:03.505] - nx: 2
[18:01:03.505] - relay: TRUE
[18:01:03.505] - stdout: TRUE
[18:01:03.505] - signal: TRUE
[18:01:03.506] - resignal: FALSE
[18:01:03.508] - force: TRUE
[18:01:03.508] - relayed: [n=2] TRUE, FALSE
[18:01:03.508] - queued futures: [n=2] TRUE, FALSE
[18:01:03.509]  - until=2
[18:01:03.509]  - relaying element #2
[18:01:03.509] result() for MulticoreFuture ...
[18:01:03.509] result() for MulticoreFuture ... done
[18:01:03.509] result() for MulticoreFuture ...
[18:01:03.510] result() for MulticoreFuture ... done
[18:01:03.510] result() for MulticoreFuture ...
[18:01:03.510] result() for MulticoreFuture ... done
[18:01:03.511] result() for MulticoreFuture ...
[18:01:03.511] result() for MulticoreFuture ... done
[18:01:03.511] - relayed: [n=2] TRUE, TRUE
[18:01:03.511] - queued futures: [n=2] TRUE, TRUE
[18:01:03.512] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:03.512]  length: 0 (resolved future 2)
[18:01:03.512] Relaying remaining futures
[18:01:03.512] signalConditionsASAP(NULL, pos=0) ...
[18:01:03.512] - nx: 2
[18:01:03.513] - relay: TRUE
[18:01:03.513] - stdout: TRUE
[18:01:03.513] - signal: TRUE
[18:01:03.513] - resignal: FALSE
[18:01:03.513] - force: TRUE
[18:01:03.514] - relayed: [n=2] TRUE, TRUE
[18:01:03.514] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:03.514] - relayed: [n=2] TRUE, TRUE
[18:01:03.515] - queued futures: [n=2] TRUE, TRUE
[18:01:03.515] signalConditionsASAP(NULL, pos=0) ... done
[18:01:03.515] resolve() on list ... DONE
[18:01:03.515] result() for MulticoreFuture ...
[18:01:03.516] result() for MulticoreFuture ... done
[18:01:03.516] result() for MulticoreFuture ...
[18:01:03.516] result() for MulticoreFuture ... done
[18:01:03.516] result() for MulticoreFuture ...
[18:01:03.516] result() for MulticoreFuture ... done
[18:01:03.517] result() for MulticoreFuture ...
[18:01:03.517] result() for MulticoreFuture ... done
[18:01:03.517]  - Number of value chunks collected: 2
[18:01:03.517] Resolving 2 futures (chunks) ... DONE
[18:01:03.518] Reducing values from 2 chunks ...
[18:01:03.518]  - Number of values collected after concatenation: 4
[18:01:03.518]  - Number of values expected: 4
[18:01:03.518] Reducing values from 2 chunks ... DONE
[18:01:03.518] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[18:01:03.520] future_mapply() ...
[18:01:03.527] Number of chunks: 2
[18:01:03.527] getGlobalsAndPackagesXApply() ...
[18:01:03.527]  - future.globals: TRUE
[18:01:03.528] getGlobalsAndPackages() ...
[18:01:03.528] Searching for globals...
[18:01:03.531] - globals found: [2] ‘FUN’, ‘UseMethod’
[18:01:03.531] Searching for globals ... DONE
[18:01:03.531] Resolving globals: FALSE
[18:01:03.532] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[18:01:03.533] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[18:01:03.533] - globals: [1] ‘FUN’
[18:01:03.534] - packages: [1] ‘stats’
[18:01:03.534] getGlobalsAndPackages() ... DONE
[18:01:03.534]  - globals found/used: [n=1] ‘FUN’
[18:01:03.534]  - needed namespaces: [n=1] ‘stats’
[18:01:03.534] Finding globals ... DONE
[18:01:03.535] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:03.535] List of 2
[18:01:03.535]  $ ...future.FUN:function (x, w, ...)  
[18:01:03.535]  $ MoreArgs     : NULL
[18:01:03.535]  - attr(*, "where")=List of 2
[18:01:03.535]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:03.535]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:03.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.535]  - attr(*, "resolved")= logi FALSE
[18:01:03.535]  - attr(*, "total_size")= num NA
[18:01:03.545] Packages to be attached in all futures: [n=1] ‘stats’
[18:01:03.545] getGlobalsAndPackagesXApply() ... DONE
[18:01:03.546] Number of futures (= number of chunks): 2
[18:01:03.546] Launching 2 futures (chunks) ...
[18:01:03.546] Chunk #1 of 2 ...
[18:01:03.546]  - Finding globals in '...' for chunk #1 ...
[18:01:03.547] getGlobalsAndPackages() ...
[18:01:03.547] Searching for globals...
[18:01:03.548] 
[18:01:03.548] Searching for globals ... DONE
[18:01:03.548] - globals: [0] <none>
[18:01:03.548] getGlobalsAndPackages() ... DONE
[18:01:03.549]    + additional globals found: [n=0] 
[18:01:03.549]    + additional namespaces needed: [n=0] 
[18:01:03.549]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:03.549]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.550]  - seeds: <none>
[18:01:03.550]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.550] getGlobalsAndPackages() ...
[18:01:03.550] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.551] Resolving globals: FALSE
[18:01:03.552] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[18:01:03.553] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:03.554] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.554] - packages: [1] ‘stats’
[18:01:03.554] getGlobalsAndPackages() ... DONE
[18:01:03.555] run() for ‘Future’ ...
[18:01:03.555] - state: ‘created’
[18:01:03.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.562] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.563]   - Field: ‘label’
[18:01:03.563]   - Field: ‘local’
[18:01:03.563]   - Field: ‘owner’
[18:01:03.563]   - Field: ‘envir’
[18:01:03.564]   - Field: ‘workers’
[18:01:03.564]   - Field: ‘packages’
[18:01:03.564]   - Field: ‘gc’
[18:01:03.564]   - Field: ‘job’
[18:01:03.565]   - Field: ‘conditions’
[18:01:03.565]   - Field: ‘expr’
[18:01:03.565]   - Field: ‘uuid’
[18:01:03.565]   - Field: ‘seed’
[18:01:03.565]   - Field: ‘version’
[18:01:03.566]   - Field: ‘result’
[18:01:03.566]   - Field: ‘asynchronous’
[18:01:03.566]   - Field: ‘calls’
[18:01:03.566]   - Field: ‘globals’
[18:01:03.566]   - Field: ‘stdout’
[18:01:03.567]   - Field: ‘earlySignal’
[18:01:03.567]   - Field: ‘lazy’
[18:01:03.567]   - Field: ‘state’
[18:01:03.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.568] - Launch lazy future ...
[18:01:03.568] Packages needed by the future expression (n = 1): ‘stats’
[18:01:03.569] Packages needed by future strategies (n = 0): <none>
[18:01:03.570] {
[18:01:03.570]     {
[18:01:03.570]         {
[18:01:03.570]             ...future.startTime <- base::Sys.time()
[18:01:03.570]             {
[18:01:03.570]                 {
[18:01:03.570]                   {
[18:01:03.570]                     {
[18:01:03.570]                       {
[18:01:03.570]                         base::local({
[18:01:03.570]                           has_future <- base::requireNamespace("future", 
[18:01:03.570]                             quietly = TRUE)
[18:01:03.570]                           if (has_future) {
[18:01:03.570]                             ns <- base::getNamespace("future")
[18:01:03.570]                             version <- ns[[".package"]][["version"]]
[18:01:03.570]                             if (is.null(version)) 
[18:01:03.570]                               version <- utils::packageVersion("future")
[18:01:03.570]                           }
[18:01:03.570]                           else {
[18:01:03.570]                             version <- NULL
[18:01:03.570]                           }
[18:01:03.570]                           if (!has_future || version < "1.8.0") {
[18:01:03.570]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.570]                               "", base::R.version$version.string), 
[18:01:03.570]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:03.570]                                 base::R.version$platform, 8 * 
[18:01:03.570]                                   base::.Machine$sizeof.pointer), 
[18:01:03.570]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.570]                                 "release", "version")], collapse = " "), 
[18:01:03.570]                               hostname = base::Sys.info()[["nodename"]])
[18:01:03.570]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.570]                               info)
[18:01:03.570]                             info <- base::paste(info, collapse = "; ")
[18:01:03.570]                             if (!has_future) {
[18:01:03.570]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.570]                                 info)
[18:01:03.570]                             }
[18:01:03.570]                             else {
[18:01:03.570]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.570]                                 info, version)
[18:01:03.570]                             }
[18:01:03.570]                             base::stop(msg)
[18:01:03.570]                           }
[18:01:03.570]                         })
[18:01:03.570]                       }
[18:01:03.570]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.570]                       base::options(mc.cores = 1L)
[18:01:03.570]                     }
[18:01:03.570]                     base::local({
[18:01:03.570]                       for (pkg in "stats") {
[18:01:03.570]                         base::loadNamespace(pkg)
[18:01:03.570]                         base::library(pkg, character.only = TRUE)
[18:01:03.570]                       }
[18:01:03.570]                     })
[18:01:03.570]                   }
[18:01:03.570]                   ...future.strategy.old <- future::plan("list")
[18:01:03.570]                   options(future.plan = NULL)
[18:01:03.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.570]                 }
[18:01:03.570]                 ...future.workdir <- getwd()
[18:01:03.570]             }
[18:01:03.570]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.570]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.570]         }
[18:01:03.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.570]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.570]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.570]             base::names(...future.oldOptions))
[18:01:03.570]     }
[18:01:03.570]     if (FALSE) {
[18:01:03.570]     }
[18:01:03.570]     else {
[18:01:03.570]         if (TRUE) {
[18:01:03.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.570]                 open = "w")
[18:01:03.570]         }
[18:01:03.570]         else {
[18:01:03.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.570]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.570]         }
[18:01:03.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.570]             base::sink(type = "output", split = FALSE)
[18:01:03.570]             base::close(...future.stdout)
[18:01:03.570]         }, add = TRUE)
[18:01:03.570]     }
[18:01:03.570]     ...future.frame <- base::sys.nframe()
[18:01:03.570]     ...future.conditions <- base::list()
[18:01:03.570]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.570]     if (FALSE) {
[18:01:03.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.570]     }
[18:01:03.570]     ...future.result <- base::tryCatch({
[18:01:03.570]         base::withCallingHandlers({
[18:01:03.570]             ...future.value <- base::withVisible(base::local({
[18:01:03.570]                 withCallingHandlers({
[18:01:03.570]                   {
[18:01:03.570]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.570]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.570]                       ...future.globals.maxSize)) {
[18:01:03.570]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.570]                       on.exit(options(oopts), add = TRUE)
[18:01:03.570]                     }
[18:01:03.570]                     {
[18:01:03.570]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.570]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.570]                         USE.NAMES = FALSE)
[18:01:03.570]                       do.call(mapply, args = args)
[18:01:03.570]                     }
[18:01:03.570]                   }
[18:01:03.570]                 }, immediateCondition = function(cond) {
[18:01:03.570]                   save_rds <- function (object, pathname, ...) 
[18:01:03.570]                   {
[18:01:03.570]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.570]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.570]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.570]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.570]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.570]                         fi_tmp[["mtime"]])
[18:01:03.570]                     }
[18:01:03.570]                     tryCatch({
[18:01:03.570]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.570]                     }, error = function(ex) {
[18:01:03.570]                       msg <- conditionMessage(ex)
[18:01:03.570]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.570]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.570]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.570]                         fi_tmp[["mtime"]], msg)
[18:01:03.570]                       ex$message <- msg
[18:01:03.570]                       stop(ex)
[18:01:03.570]                     })
[18:01:03.570]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.570]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.570]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.570]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.570]                       fi <- file.info(pathname)
[18:01:03.570]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.570]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.570]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.570]                         fi[["size"]], fi[["mtime"]])
[18:01:03.570]                       stop(msg)
[18:01:03.570]                     }
[18:01:03.570]                     invisible(pathname)
[18:01:03.570]                   }
[18:01:03.570]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.570]                     rootPath = tempdir()) 
[18:01:03.570]                   {
[18:01:03.570]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.570]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.570]                       tmpdir = path, fileext = ".rds")
[18:01:03.570]                     save_rds(obj, file)
[18:01:03.570]                   }
[18:01:03.570]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.570]                   {
[18:01:03.570]                     inherits <- base::inherits
[18:01:03.570]                     invokeRestart <- base::invokeRestart
[18:01:03.570]                     is.null <- base::is.null
[18:01:03.570]                     muffled <- FALSE
[18:01:03.570]                     if (inherits(cond, "message")) {
[18:01:03.570]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.570]                       if (muffled) 
[18:01:03.570]                         invokeRestart("muffleMessage")
[18:01:03.570]                     }
[18:01:03.570]                     else if (inherits(cond, "warning")) {
[18:01:03.570]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.570]                       if (muffled) 
[18:01:03.570]                         invokeRestart("muffleWarning")
[18:01:03.570]                     }
[18:01:03.570]                     else if (inherits(cond, "condition")) {
[18:01:03.570]                       if (!is.null(pattern)) {
[18:01:03.570]                         computeRestarts <- base::computeRestarts
[18:01:03.570]                         grepl <- base::grepl
[18:01:03.570]                         restarts <- computeRestarts(cond)
[18:01:03.570]                         for (restart in restarts) {
[18:01:03.570]                           name <- restart$name
[18:01:03.570]                           if (is.null(name)) 
[18:01:03.570]                             next
[18:01:03.570]                           if (!grepl(pattern, name)) 
[18:01:03.570]                             next
[18:01:03.570]                           invokeRestart(restart)
[18:01:03.570]                           muffled <- TRUE
[18:01:03.570]                           break
[18:01:03.570]                         }
[18:01:03.570]                       }
[18:01:03.570]                     }
[18:01:03.570]                     invisible(muffled)
[18:01:03.570]                   }
[18:01:03.570]                   muffleCondition(cond)
[18:01:03.570]                 })
[18:01:03.570]             }))
[18:01:03.570]             future::FutureResult(value = ...future.value$value, 
[18:01:03.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.570]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.570]                     ...future.globalenv.names))
[18:01:03.570]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.570]         }, condition = base::local({
[18:01:03.570]             c <- base::c
[18:01:03.570]             inherits <- base::inherits
[18:01:03.570]             invokeRestart <- base::invokeRestart
[18:01:03.570]             length <- base::length
[18:01:03.570]             list <- base::list
[18:01:03.570]             seq.int <- base::seq.int
[18:01:03.570]             signalCondition <- base::signalCondition
[18:01:03.570]             sys.calls <- base::sys.calls
[18:01:03.570]             `[[` <- base::`[[`
[18:01:03.570]             `+` <- base::`+`
[18:01:03.570]             `<<-` <- base::`<<-`
[18:01:03.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.570]                   3L)]
[18:01:03.570]             }
[18:01:03.570]             function(cond) {
[18:01:03.570]                 is_error <- inherits(cond, "error")
[18:01:03.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.570]                   NULL)
[18:01:03.570]                 if (is_error) {
[18:01:03.570]                   sessionInformation <- function() {
[18:01:03.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.570]                       search = base::search(), system = base::Sys.info())
[18:01:03.570]                   }
[18:01:03.570]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.570]                     cond$call), session = sessionInformation(), 
[18:01:03.570]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.570]                   signalCondition(cond)
[18:01:03.570]                 }
[18:01:03.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.570]                 "immediateCondition"))) {
[18:01:03.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.570]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.570]                   if (TRUE && !signal) {
[18:01:03.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.570]                     {
[18:01:03.570]                       inherits <- base::inherits
[18:01:03.570]                       invokeRestart <- base::invokeRestart
[18:01:03.570]                       is.null <- base::is.null
[18:01:03.570]                       muffled <- FALSE
[18:01:03.570]                       if (inherits(cond, "message")) {
[18:01:03.570]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.570]                         if (muffled) 
[18:01:03.570]                           invokeRestart("muffleMessage")
[18:01:03.570]                       }
[18:01:03.570]                       else if (inherits(cond, "warning")) {
[18:01:03.570]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.570]                         if (muffled) 
[18:01:03.570]                           invokeRestart("muffleWarning")
[18:01:03.570]                       }
[18:01:03.570]                       else if (inherits(cond, "condition")) {
[18:01:03.570]                         if (!is.null(pattern)) {
[18:01:03.570]                           computeRestarts <- base::computeRestarts
[18:01:03.570]                           grepl <- base::grepl
[18:01:03.570]                           restarts <- computeRestarts(cond)
[18:01:03.570]                           for (restart in restarts) {
[18:01:03.570]                             name <- restart$name
[18:01:03.570]                             if (is.null(name)) 
[18:01:03.570]                               next
[18:01:03.570]                             if (!grepl(pattern, name)) 
[18:01:03.570]                               next
[18:01:03.570]                             invokeRestart(restart)
[18:01:03.570]                             muffled <- TRUE
[18:01:03.570]                             break
[18:01:03.570]                           }
[18:01:03.570]                         }
[18:01:03.570]                       }
[18:01:03.570]                       invisible(muffled)
[18:01:03.570]                     }
[18:01:03.570]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.570]                   }
[18:01:03.570]                 }
[18:01:03.570]                 else {
[18:01:03.570]                   if (TRUE) {
[18:01:03.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.570]                     {
[18:01:03.570]                       inherits <- base::inherits
[18:01:03.570]                       invokeRestart <- base::invokeRestart
[18:01:03.570]                       is.null <- base::is.null
[18:01:03.570]                       muffled <- FALSE
[18:01:03.570]                       if (inherits(cond, "message")) {
[18:01:03.570]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.570]                         if (muffled) 
[18:01:03.570]                           invokeRestart("muffleMessage")
[18:01:03.570]                       }
[18:01:03.570]                       else if (inherits(cond, "warning")) {
[18:01:03.570]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.570]                         if (muffled) 
[18:01:03.570]                           invokeRestart("muffleWarning")
[18:01:03.570]                       }
[18:01:03.570]                       else if (inherits(cond, "condition")) {
[18:01:03.570]                         if (!is.null(pattern)) {
[18:01:03.570]                           computeRestarts <- base::computeRestarts
[18:01:03.570]                           grepl <- base::grepl
[18:01:03.570]                           restarts <- computeRestarts(cond)
[18:01:03.570]                           for (restart in restarts) {
[18:01:03.570]                             name <- restart$name
[18:01:03.570]                             if (is.null(name)) 
[18:01:03.570]                               next
[18:01:03.570]                             if (!grepl(pattern, name)) 
[18:01:03.570]                               next
[18:01:03.570]                             invokeRestart(restart)
[18:01:03.570]                             muffled <- TRUE
[18:01:03.570]                             break
[18:01:03.570]                           }
[18:01:03.570]                         }
[18:01:03.570]                       }
[18:01:03.570]                       invisible(muffled)
[18:01:03.570]                     }
[18:01:03.570]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.570]                   }
[18:01:03.570]                 }
[18:01:03.570]             }
[18:01:03.570]         }))
[18:01:03.570]     }, error = function(ex) {
[18:01:03.570]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.570]                 ...future.rng), started = ...future.startTime, 
[18:01:03.570]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.570]             version = "1.8"), class = "FutureResult")
[18:01:03.570]     }, finally = {
[18:01:03.570]         if (!identical(...future.workdir, getwd())) 
[18:01:03.570]             setwd(...future.workdir)
[18:01:03.570]         {
[18:01:03.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.570]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.570]             }
[18:01:03.570]             base::options(...future.oldOptions)
[18:01:03.570]             if (.Platform$OS.type == "windows") {
[18:01:03.570]                 old_names <- names(...future.oldEnvVars)
[18:01:03.570]                 envs <- base::Sys.getenv()
[18:01:03.570]                 names <- names(envs)
[18:01:03.570]                 common <- intersect(names, old_names)
[18:01:03.570]                 added <- setdiff(names, old_names)
[18:01:03.570]                 removed <- setdiff(old_names, names)
[18:01:03.570]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.570]                   envs[common]]
[18:01:03.570]                 NAMES <- toupper(changed)
[18:01:03.570]                 args <- list()
[18:01:03.570]                 for (kk in seq_along(NAMES)) {
[18:01:03.570]                   name <- changed[[kk]]
[18:01:03.570]                   NAME <- NAMES[[kk]]
[18:01:03.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.570]                     next
[18:01:03.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.570]                 }
[18:01:03.570]                 NAMES <- toupper(added)
[18:01:03.570]                 for (kk in seq_along(NAMES)) {
[18:01:03.570]                   name <- added[[kk]]
[18:01:03.570]                   NAME <- NAMES[[kk]]
[18:01:03.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.570]                     next
[18:01:03.570]                   args[[name]] <- ""
[18:01:03.570]                 }
[18:01:03.570]                 NAMES <- toupper(removed)
[18:01:03.570]                 for (kk in seq_along(NAMES)) {
[18:01:03.570]                   name <- removed[[kk]]
[18:01:03.570]                   NAME <- NAMES[[kk]]
[18:01:03.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.570]                     next
[18:01:03.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.570]                 }
[18:01:03.570]                 if (length(args) > 0) 
[18:01:03.570]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.570]             }
[18:01:03.570]             else {
[18:01:03.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.570]             }
[18:01:03.570]             {
[18:01:03.570]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.570]                   0L) {
[18:01:03.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.570]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.570]                   base::options(opts)
[18:01:03.570]                 }
[18:01:03.570]                 {
[18:01:03.570]                   {
[18:01:03.570]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.570]                     NULL
[18:01:03.570]                   }
[18:01:03.570]                   options(future.plan = NULL)
[18:01:03.570]                   if (is.na(NA_character_)) 
[18:01:03.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.570]                     .init = FALSE)
[18:01:03.570]                 }
[18:01:03.570]             }
[18:01:03.570]         }
[18:01:03.570]     })
[18:01:03.570]     if (TRUE) {
[18:01:03.570]         base::sink(type = "output", split = FALSE)
[18:01:03.570]         if (TRUE) {
[18:01:03.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.570]         }
[18:01:03.570]         else {
[18:01:03.570]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.570]         }
[18:01:03.570]         base::close(...future.stdout)
[18:01:03.570]         ...future.stdout <- NULL
[18:01:03.570]     }
[18:01:03.570]     ...future.result$conditions <- ...future.conditions
[18:01:03.570]     ...future.result$finished <- base::Sys.time()
[18:01:03.570]     ...future.result
[18:01:03.570] }
[18:01:03.575] assign_globals() ...
[18:01:03.575] List of 5
[18:01:03.575]  $ ...future.FUN            :function (x, w, ...)  
[18:01:03.575]  $ MoreArgs                 : NULL
[18:01:03.575]  $ ...future.elements_ii    :List of 2
[18:01:03.575]   ..$ :List of 2
[18:01:03.575]   .. ..$ : num [1:10] 0.346 0.324 0.513 0.153 0.932 ...
[18:01:03.575]   .. ..$ : num [1:10] 0.488 0.516 0.606 0.289 0.56 ...
[18:01:03.575]   ..$ :List of 2
[18:01:03.575]   .. ..$ : num [1:10] 6 7 9 4 9 7 7 8 5 6
[18:01:03.575]   .. ..$ : num [1:10] 7 6 6 5 5 4 8 8 3 5
[18:01:03.575]  $ ...future.seeds_ii       : NULL
[18:01:03.575]  $ ...future.globals.maxSize: NULL
[18:01:03.575]  - attr(*, "where")=List of 5
[18:01:03.575]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.575]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.575]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.575]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.575]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.575]  - attr(*, "resolved")= logi FALSE
[18:01:03.575]  - attr(*, "total_size")= num 2120
[18:01:03.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.575]  - attr(*, "already-done")= logi TRUE
[18:01:03.588] - copied ‘...future.FUN’ to environment
[18:01:03.588] - copied ‘MoreArgs’ to environment
[18:01:03.589] - copied ‘...future.elements_ii’ to environment
[18:01:03.589] - copied ‘...future.seeds_ii’ to environment
[18:01:03.589] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.589] assign_globals() ... done
[18:01:03.590] requestCore(): workers = 2
[18:01:03.594] MulticoreFuture started
[18:01:03.594] - Launch lazy future ... done
[18:01:03.595] run() for ‘MulticoreFuture’ ... done
[18:01:03.596] Created future:
[18:01:03.596] plan(): Setting new future strategy stack:
[18:01:03.597] List of future strategies:
[18:01:03.597] 1. sequential:
[18:01:03.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.597]    - tweaked: FALSE
[18:01:03.597]    - call: NULL
[18:01:03.599] plan(): nbrOfWorkers() = 1
[18:01:03.603] plan(): Setting new future strategy stack:
[18:01:03.596] MulticoreFuture:
[18:01:03.596] Label: ‘future_Map-1’
[18:01:03.596] Expression:
[18:01:03.596] {
[18:01:03.596]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.596]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.596]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.596]         on.exit(options(oopts), add = TRUE)
[18:01:03.596]     }
[18:01:03.596]     {
[18:01:03.596]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.596]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.596]         do.call(mapply, args = args)
[18:01:03.596]     }
[18:01:03.596] }
[18:01:03.596] Lazy evaluation: FALSE
[18:01:03.596] Asynchronous evaluation: TRUE
[18:01:03.596] Local evaluation: TRUE
[18:01:03.596] Environment: R_GlobalEnv
[18:01:03.596] Capture standard output: TRUE
[18:01:03.596] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.596] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.596] Packages: 1 packages (‘stats’)
[18:01:03.596] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:03.596] Resolved: FALSE
[18:01:03.596] Value: <not collected>
[18:01:03.596] Conditions captured: <none>
[18:01:03.596] Early signaling: FALSE
[18:01:03.596] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.596] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.611] Chunk #1 of 2 ... DONE
[18:01:03.612] Chunk #2 of 2 ...
[18:01:03.603] List of future strategies:
[18:01:03.603] 1. multicore:
[18:01:03.603]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.603]    - tweaked: FALSE
[18:01:03.603]    - call: plan(strategy)
[18:01:03.612]  - Finding globals in '...' for chunk #2 ...
[18:01:03.612] getGlobalsAndPackages() ...
[18:01:03.613] Searching for globals...
[18:01:03.619] 
[18:01:03.619] Searching for globals ... DONE
[18:01:03.620] - globals: [0] <none>
[18:01:03.620] getGlobalsAndPackages() ... DONE
[18:01:03.621]    + additional globals found: [n=0] 
[18:01:03.621]    + additional namespaces needed: [n=0] 
[18:01:03.622]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:03.622]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.623]  - seeds: <none>
[18:01:03.623] plan(): nbrOfWorkers() = 2
[18:01:03.623]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.624] getGlobalsAndPackages() ...
[18:01:03.624] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.627] Resolving globals: FALSE
[18:01:03.630] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[18:01:03.632] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:03.633] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.634] - packages: [1] ‘stats’
[18:01:03.634] getGlobalsAndPackages() ... DONE
[18:01:03.635] run() for ‘Future’ ...
[18:01:03.636] - state: ‘created’
[18:01:03.637] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.647] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.648]   - Field: ‘label’
[18:01:03.649]   - Field: ‘local’
[18:01:03.649]   - Field: ‘owner’
[18:01:03.650]   - Field: ‘envir’
[18:01:03.650]   - Field: ‘workers’
[18:01:03.650]   - Field: ‘packages’
[18:01:03.651]   - Field: ‘gc’
[18:01:03.651]   - Field: ‘job’
[18:01:03.651]   - Field: ‘conditions’
[18:01:03.652]   - Field: ‘expr’
[18:01:03.652]   - Field: ‘uuid’
[18:01:03.653]   - Field: ‘seed’
[18:01:03.653]   - Field: ‘version’
[18:01:03.653]   - Field: ‘result’
[18:01:03.654]   - Field: ‘asynchronous’
[18:01:03.654]   - Field: ‘calls’
[18:01:03.654]   - Field: ‘globals’
[18:01:03.654]   - Field: ‘stdout’
[18:01:03.655]   - Field: ‘earlySignal’
[18:01:03.655]   - Field: ‘lazy’
[18:01:03.655]   - Field: ‘state’
[18:01:03.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.656] - Launch lazy future ...
[18:01:03.656] Packages needed by the future expression (n = 1): ‘stats’
[18:01:03.657] Packages needed by future strategies (n = 0): <none>
[18:01:03.659] {
[18:01:03.659]     {
[18:01:03.659]         {
[18:01:03.659]             ...future.startTime <- base::Sys.time()
[18:01:03.659]             {
[18:01:03.659]                 {
[18:01:03.659]                   {
[18:01:03.659]                     {
[18:01:03.659]                       {
[18:01:03.659]                         base::local({
[18:01:03.659]                           has_future <- base::requireNamespace("future", 
[18:01:03.659]                             quietly = TRUE)
[18:01:03.659]                           if (has_future) {
[18:01:03.659]                             ns <- base::getNamespace("future")
[18:01:03.659]                             version <- ns[[".package"]][["version"]]
[18:01:03.659]                             if (is.null(version)) 
[18:01:03.659]                               version <- utils::packageVersion("future")
[18:01:03.659]                           }
[18:01:03.659]                           else {
[18:01:03.659]                             version <- NULL
[18:01:03.659]                           }
[18:01:03.659]                           if (!has_future || version < "1.8.0") {
[18:01:03.659]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.659]                               "", base::R.version$version.string), 
[18:01:03.659]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:03.659]                                 base::R.version$platform, 8 * 
[18:01:03.659]                                   base::.Machine$sizeof.pointer), 
[18:01:03.659]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.659]                                 "release", "version")], collapse = " "), 
[18:01:03.659]                               hostname = base::Sys.info()[["nodename"]])
[18:01:03.659]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.659]                               info)
[18:01:03.659]                             info <- base::paste(info, collapse = "; ")
[18:01:03.659]                             if (!has_future) {
[18:01:03.659]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.659]                                 info)
[18:01:03.659]                             }
[18:01:03.659]                             else {
[18:01:03.659]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.659]                                 info, version)
[18:01:03.659]                             }
[18:01:03.659]                             base::stop(msg)
[18:01:03.659]                           }
[18:01:03.659]                         })
[18:01:03.659]                       }
[18:01:03.659]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.659]                       base::options(mc.cores = 1L)
[18:01:03.659]                     }
[18:01:03.659]                     base::local({
[18:01:03.659]                       for (pkg in "stats") {
[18:01:03.659]                         base::loadNamespace(pkg)
[18:01:03.659]                         base::library(pkg, character.only = TRUE)
[18:01:03.659]                       }
[18:01:03.659]                     })
[18:01:03.659]                   }
[18:01:03.659]                   ...future.strategy.old <- future::plan("list")
[18:01:03.659]                   options(future.plan = NULL)
[18:01:03.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.659]                 }
[18:01:03.659]                 ...future.workdir <- getwd()
[18:01:03.659]             }
[18:01:03.659]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.659]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.659]         }
[18:01:03.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.659]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.659]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.659]             base::names(...future.oldOptions))
[18:01:03.659]     }
[18:01:03.659]     if (FALSE) {
[18:01:03.659]     }
[18:01:03.659]     else {
[18:01:03.659]         if (TRUE) {
[18:01:03.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.659]                 open = "w")
[18:01:03.659]         }
[18:01:03.659]         else {
[18:01:03.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.659]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.659]         }
[18:01:03.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.659]             base::sink(type = "output", split = FALSE)
[18:01:03.659]             base::close(...future.stdout)
[18:01:03.659]         }, add = TRUE)
[18:01:03.659]     }
[18:01:03.659]     ...future.frame <- base::sys.nframe()
[18:01:03.659]     ...future.conditions <- base::list()
[18:01:03.659]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.659]     if (FALSE) {
[18:01:03.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.659]     }
[18:01:03.659]     ...future.result <- base::tryCatch({
[18:01:03.659]         base::withCallingHandlers({
[18:01:03.659]             ...future.value <- base::withVisible(base::local({
[18:01:03.659]                 withCallingHandlers({
[18:01:03.659]                   {
[18:01:03.659]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.659]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.659]                       ...future.globals.maxSize)) {
[18:01:03.659]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.659]                       on.exit(options(oopts), add = TRUE)
[18:01:03.659]                     }
[18:01:03.659]                     {
[18:01:03.659]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.659]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.659]                         USE.NAMES = FALSE)
[18:01:03.659]                       do.call(mapply, args = args)
[18:01:03.659]                     }
[18:01:03.659]                   }
[18:01:03.659]                 }, immediateCondition = function(cond) {
[18:01:03.659]                   save_rds <- function (object, pathname, ...) 
[18:01:03.659]                   {
[18:01:03.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.659]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.659]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.659]                         fi_tmp[["mtime"]])
[18:01:03.659]                     }
[18:01:03.659]                     tryCatch({
[18:01:03.659]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.659]                     }, error = function(ex) {
[18:01:03.659]                       msg <- conditionMessage(ex)
[18:01:03.659]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.659]                         fi_tmp[["mtime"]], msg)
[18:01:03.659]                       ex$message <- msg
[18:01:03.659]                       stop(ex)
[18:01:03.659]                     })
[18:01:03.659]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.659]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.659]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.659]                       fi <- file.info(pathname)
[18:01:03.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.659]                         fi[["size"]], fi[["mtime"]])
[18:01:03.659]                       stop(msg)
[18:01:03.659]                     }
[18:01:03.659]                     invisible(pathname)
[18:01:03.659]                   }
[18:01:03.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.659]                     rootPath = tempdir()) 
[18:01:03.659]                   {
[18:01:03.659]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.659]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.659]                       tmpdir = path, fileext = ".rds")
[18:01:03.659]                     save_rds(obj, file)
[18:01:03.659]                   }
[18:01:03.659]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.659]                   {
[18:01:03.659]                     inherits <- base::inherits
[18:01:03.659]                     invokeRestart <- base::invokeRestart
[18:01:03.659]                     is.null <- base::is.null
[18:01:03.659]                     muffled <- FALSE
[18:01:03.659]                     if (inherits(cond, "message")) {
[18:01:03.659]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.659]                       if (muffled) 
[18:01:03.659]                         invokeRestart("muffleMessage")
[18:01:03.659]                     }
[18:01:03.659]                     else if (inherits(cond, "warning")) {
[18:01:03.659]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.659]                       if (muffled) 
[18:01:03.659]                         invokeRestart("muffleWarning")
[18:01:03.659]                     }
[18:01:03.659]                     else if (inherits(cond, "condition")) {
[18:01:03.659]                       if (!is.null(pattern)) {
[18:01:03.659]                         computeRestarts <- base::computeRestarts
[18:01:03.659]                         grepl <- base::grepl
[18:01:03.659]                         restarts <- computeRestarts(cond)
[18:01:03.659]                         for (restart in restarts) {
[18:01:03.659]                           name <- restart$name
[18:01:03.659]                           if (is.null(name)) 
[18:01:03.659]                             next
[18:01:03.659]                           if (!grepl(pattern, name)) 
[18:01:03.659]                             next
[18:01:03.659]                           invokeRestart(restart)
[18:01:03.659]                           muffled <- TRUE
[18:01:03.659]                           break
[18:01:03.659]                         }
[18:01:03.659]                       }
[18:01:03.659]                     }
[18:01:03.659]                     invisible(muffled)
[18:01:03.659]                   }
[18:01:03.659]                   muffleCondition(cond)
[18:01:03.659]                 })
[18:01:03.659]             }))
[18:01:03.659]             future::FutureResult(value = ...future.value$value, 
[18:01:03.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.659]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.659]                     ...future.globalenv.names))
[18:01:03.659]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.659]         }, condition = base::local({
[18:01:03.659]             c <- base::c
[18:01:03.659]             inherits <- base::inherits
[18:01:03.659]             invokeRestart <- base::invokeRestart
[18:01:03.659]             length <- base::length
[18:01:03.659]             list <- base::list
[18:01:03.659]             seq.int <- base::seq.int
[18:01:03.659]             signalCondition <- base::signalCondition
[18:01:03.659]             sys.calls <- base::sys.calls
[18:01:03.659]             `[[` <- base::`[[`
[18:01:03.659]             `+` <- base::`+`
[18:01:03.659]             `<<-` <- base::`<<-`
[18:01:03.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.659]                   3L)]
[18:01:03.659]             }
[18:01:03.659]             function(cond) {
[18:01:03.659]                 is_error <- inherits(cond, "error")
[18:01:03.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.659]                   NULL)
[18:01:03.659]                 if (is_error) {
[18:01:03.659]                   sessionInformation <- function() {
[18:01:03.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.659]                       search = base::search(), system = base::Sys.info())
[18:01:03.659]                   }
[18:01:03.659]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.659]                     cond$call), session = sessionInformation(), 
[18:01:03.659]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.659]                   signalCondition(cond)
[18:01:03.659]                 }
[18:01:03.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.659]                 "immediateCondition"))) {
[18:01:03.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.659]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.659]                   if (TRUE && !signal) {
[18:01:03.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.659]                     {
[18:01:03.659]                       inherits <- base::inherits
[18:01:03.659]                       invokeRestart <- base::invokeRestart
[18:01:03.659]                       is.null <- base::is.null
[18:01:03.659]                       muffled <- FALSE
[18:01:03.659]                       if (inherits(cond, "message")) {
[18:01:03.659]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.659]                         if (muffled) 
[18:01:03.659]                           invokeRestart("muffleMessage")
[18:01:03.659]                       }
[18:01:03.659]                       else if (inherits(cond, "warning")) {
[18:01:03.659]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.659]                         if (muffled) 
[18:01:03.659]                           invokeRestart("muffleWarning")
[18:01:03.659]                       }
[18:01:03.659]                       else if (inherits(cond, "condition")) {
[18:01:03.659]                         if (!is.null(pattern)) {
[18:01:03.659]                           computeRestarts <- base::computeRestarts
[18:01:03.659]                           grepl <- base::grepl
[18:01:03.659]                           restarts <- computeRestarts(cond)
[18:01:03.659]                           for (restart in restarts) {
[18:01:03.659]                             name <- restart$name
[18:01:03.659]                             if (is.null(name)) 
[18:01:03.659]                               next
[18:01:03.659]                             if (!grepl(pattern, name)) 
[18:01:03.659]                               next
[18:01:03.659]                             invokeRestart(restart)
[18:01:03.659]                             muffled <- TRUE
[18:01:03.659]                             break
[18:01:03.659]                           }
[18:01:03.659]                         }
[18:01:03.659]                       }
[18:01:03.659]                       invisible(muffled)
[18:01:03.659]                     }
[18:01:03.659]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.659]                   }
[18:01:03.659]                 }
[18:01:03.659]                 else {
[18:01:03.659]                   if (TRUE) {
[18:01:03.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.659]                     {
[18:01:03.659]                       inherits <- base::inherits
[18:01:03.659]                       invokeRestart <- base::invokeRestart
[18:01:03.659]                       is.null <- base::is.null
[18:01:03.659]                       muffled <- FALSE
[18:01:03.659]                       if (inherits(cond, "message")) {
[18:01:03.659]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.659]                         if (muffled) 
[18:01:03.659]                           invokeRestart("muffleMessage")
[18:01:03.659]                       }
[18:01:03.659]                       else if (inherits(cond, "warning")) {
[18:01:03.659]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.659]                         if (muffled) 
[18:01:03.659]                           invokeRestart("muffleWarning")
[18:01:03.659]                       }
[18:01:03.659]                       else if (inherits(cond, "condition")) {
[18:01:03.659]                         if (!is.null(pattern)) {
[18:01:03.659]                           computeRestarts <- base::computeRestarts
[18:01:03.659]                           grepl <- base::grepl
[18:01:03.659]                           restarts <- computeRestarts(cond)
[18:01:03.659]                           for (restart in restarts) {
[18:01:03.659]                             name <- restart$name
[18:01:03.659]                             if (is.null(name)) 
[18:01:03.659]                               next
[18:01:03.659]                             if (!grepl(pattern, name)) 
[18:01:03.659]                               next
[18:01:03.659]                             invokeRestart(restart)
[18:01:03.659]                             muffled <- TRUE
[18:01:03.659]                             break
[18:01:03.659]                           }
[18:01:03.659]                         }
[18:01:03.659]                       }
[18:01:03.659]                       invisible(muffled)
[18:01:03.659]                     }
[18:01:03.659]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.659]                   }
[18:01:03.659]                 }
[18:01:03.659]             }
[18:01:03.659]         }))
[18:01:03.659]     }, error = function(ex) {
[18:01:03.659]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.659]                 ...future.rng), started = ...future.startTime, 
[18:01:03.659]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.659]             version = "1.8"), class = "FutureResult")
[18:01:03.659]     }, finally = {
[18:01:03.659]         if (!identical(...future.workdir, getwd())) 
[18:01:03.659]             setwd(...future.workdir)
[18:01:03.659]         {
[18:01:03.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.659]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.659]             }
[18:01:03.659]             base::options(...future.oldOptions)
[18:01:03.659]             if (.Platform$OS.type == "windows") {
[18:01:03.659]                 old_names <- names(...future.oldEnvVars)
[18:01:03.659]                 envs <- base::Sys.getenv()
[18:01:03.659]                 names <- names(envs)
[18:01:03.659]                 common <- intersect(names, old_names)
[18:01:03.659]                 added <- setdiff(names, old_names)
[18:01:03.659]                 removed <- setdiff(old_names, names)
[18:01:03.659]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.659]                   envs[common]]
[18:01:03.659]                 NAMES <- toupper(changed)
[18:01:03.659]                 args <- list()
[18:01:03.659]                 for (kk in seq_along(NAMES)) {
[18:01:03.659]                   name <- changed[[kk]]
[18:01:03.659]                   NAME <- NAMES[[kk]]
[18:01:03.659]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.659]                     next
[18:01:03.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.659]                 }
[18:01:03.659]                 NAMES <- toupper(added)
[18:01:03.659]                 for (kk in seq_along(NAMES)) {
[18:01:03.659]                   name <- added[[kk]]
[18:01:03.659]                   NAME <- NAMES[[kk]]
[18:01:03.659]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.659]                     next
[18:01:03.659]                   args[[name]] <- ""
[18:01:03.659]                 }
[18:01:03.659]                 NAMES <- toupper(removed)
[18:01:03.659]                 for (kk in seq_along(NAMES)) {
[18:01:03.659]                   name <- removed[[kk]]
[18:01:03.659]                   NAME <- NAMES[[kk]]
[18:01:03.659]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.659]                     next
[18:01:03.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.659]                 }
[18:01:03.659]                 if (length(args) > 0) 
[18:01:03.659]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.659]             }
[18:01:03.659]             else {
[18:01:03.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.659]             }
[18:01:03.659]             {
[18:01:03.659]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.659]                   0L) {
[18:01:03.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.659]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.659]                   base::options(opts)
[18:01:03.659]                 }
[18:01:03.659]                 {
[18:01:03.659]                   {
[18:01:03.659]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.659]                     NULL
[18:01:03.659]                   }
[18:01:03.659]                   options(future.plan = NULL)
[18:01:03.659]                   if (is.na(NA_character_)) 
[18:01:03.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.659]                     .init = FALSE)
[18:01:03.659]                 }
[18:01:03.659]             }
[18:01:03.659]         }
[18:01:03.659]     })
[18:01:03.659]     if (TRUE) {
[18:01:03.659]         base::sink(type = "output", split = FALSE)
[18:01:03.659]         if (TRUE) {
[18:01:03.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.659]         }
[18:01:03.659]         else {
[18:01:03.659]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.659]         }
[18:01:03.659]         base::close(...future.stdout)
[18:01:03.659]         ...future.stdout <- NULL
[18:01:03.659]     }
[18:01:03.659]     ...future.result$conditions <- ...future.conditions
[18:01:03.659]     ...future.result$finished <- base::Sys.time()
[18:01:03.659]     ...future.result
[18:01:03.659] }
[18:01:03.664] assign_globals() ...
[18:01:03.665] List of 5
[18:01:03.665]  $ ...future.FUN            :function (x, w, ...)  
[18:01:03.665]  $ MoreArgs                 : NULL
[18:01:03.665]  $ ...future.elements_ii    :List of 2
[18:01:03.665]   ..$ :List of 3
[18:01:03.665]   .. ..$ : num [1:10] 0.072 0.2034 0.0275 0.1542 0.7909 ...
[18:01:03.665]   .. ..$ : num [1:10] 0.524 0.703 0.577 0.068 0.559 ...
[18:01:03.665]   .. ..$ : num [1:10] 0.371 0.125 0.98 0.122 0.659 ...
[18:01:03.665]   ..$ :List of 3
[18:01:03.665]   .. ..$ : num [1:10] 7 4 4 5 6 3 9 9 9 6
[18:01:03.665]   .. ..$ : num [1:10] 6 4 3 5 5 7 9 8 7 4
[18:01:03.665]   .. ..$ : num [1:10] 5 5 8 6 7 7 8 4 7 4
[18:01:03.665]  $ ...future.seeds_ii       : NULL
[18:01:03.665]  $ ...future.globals.maxSize: NULL
[18:01:03.665]  - attr(*, "where")=List of 5
[18:01:03.665]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.665]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.665]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.665]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.665]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.665]  - attr(*, "resolved")= logi FALSE
[18:01:03.665]  - attr(*, "total_size")= num 2472
[18:01:03.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.665]  - attr(*, "already-done")= logi TRUE
[18:01:03.681] - copied ‘...future.FUN’ to environment
[18:01:03.681] - copied ‘MoreArgs’ to environment
[18:01:03.682] - copied ‘...future.elements_ii’ to environment
[18:01:03.682] - copied ‘...future.seeds_ii’ to environment
[18:01:03.682] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.682] assign_globals() ... done
[18:01:03.683] requestCore(): workers = 2
[18:01:03.686] MulticoreFuture started
[18:01:03.687] - Launch lazy future ... done
[18:01:03.688] run() for ‘MulticoreFuture’ ... done
[18:01:03.688] Created future:
[18:01:03.689] plan(): Setting new future strategy stack:
[18:01:03.689] List of future strategies:
[18:01:03.689] 1. sequential:
[18:01:03.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.689]    - tweaked: FALSE
[18:01:03.689]    - call: NULL
[18:01:03.691] plan(): nbrOfWorkers() = 1
[18:01:03.696] plan(): Setting new future strategy stack:
[18:01:03.696] List of future strategies:
[18:01:03.696] 1. multicore:
[18:01:03.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.696]    - tweaked: FALSE
[18:01:03.696]    - call: plan(strategy)
[18:01:03.689] MulticoreFuture:
[18:01:03.689] Label: ‘future_Map-2’
[18:01:03.689] Expression:
[18:01:03.689] {
[18:01:03.689]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.689]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.689]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.689]         on.exit(options(oopts), add = TRUE)
[18:01:03.689]     }
[18:01:03.689]     {
[18:01:03.689]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.689]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.689]         do.call(mapply, args = args)
[18:01:03.689]     }
[18:01:03.689] }
[18:01:03.689] Lazy evaluation: FALSE
[18:01:03.689] Asynchronous evaluation: TRUE
[18:01:03.689] Local evaluation: TRUE
[18:01:03.689] Environment: R_GlobalEnv
[18:01:03.689] Capture standard output: TRUE
[18:01:03.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.689] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.689] Packages: 1 packages (‘stats’)
[18:01:03.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:03.689] Resolved: FALSE
[18:01:03.689] Value: <not collected>
[18:01:03.689] Conditions captured: <none>
[18:01:03.689] Early signaling: FALSE
[18:01:03.689] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.689] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.704] Chunk #2 of 2 ... DONE
[18:01:03.704] Launching 2 futures (chunks) ... DONE
[18:01:03.705] Resolving 2 futures (chunks) ...
[18:01:03.705] resolve() on list ...
[18:01:03.705]  recursive: 0
[18:01:03.706]  length: 2
[18:01:03.706] 
[18:01:03.712] Future #1
[18:01:03.712] result() for MulticoreFuture ...
[18:01:03.717] result() for MulticoreFuture ...
[18:01:03.717] result() for MulticoreFuture ... done
[18:01:03.718] plan(): nbrOfWorkers() = 2
[18:01:03.718] result() for MulticoreFuture ... done
[18:01:03.718] result() for MulticoreFuture ...
[18:01:03.719] result() for MulticoreFuture ... done
[18:01:03.719] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:03.720] - nx: 2
[18:01:03.720] - relay: TRUE
[18:01:03.721] - stdout: TRUE
[18:01:03.721] - signal: TRUE
[18:01:03.722] - resignal: FALSE
[18:01:03.722] - force: TRUE
[18:01:03.722] - relayed: [n=2] FALSE, FALSE
[18:01:03.723] - queued futures: [n=2] FALSE, FALSE
[18:01:03.724]  - until=1
[18:01:03.724]  - relaying element #1
[18:01:03.725] result() for MulticoreFuture ...
[18:01:03.725] result() for MulticoreFuture ... done
[18:01:03.726] result() for MulticoreFuture ...
[18:01:03.726] result() for MulticoreFuture ... done
[18:01:03.727] result() for MulticoreFuture ...
[18:01:03.728] result() for MulticoreFuture ... done
[18:01:03.728] result() for MulticoreFuture ...
[18:01:03.728] result() for MulticoreFuture ... done
[18:01:03.729] - relayed: [n=2] TRUE, FALSE
[18:01:03.729] - queued futures: [n=2] TRUE, FALSE
[18:01:03.729] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:03.730]  length: 1 (resolved future 1)
[18:01:03.731] Future #2
[18:01:03.731] result() for MulticoreFuture ...
[18:01:03.733] result() for MulticoreFuture ...
[18:01:03.733] result() for MulticoreFuture ... done
[18:01:03.734] result() for MulticoreFuture ... done
[18:01:03.734] result() for MulticoreFuture ...
[18:01:03.734] result() for MulticoreFuture ... done
[18:01:03.735] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:03.735] - nx: 2
[18:01:03.735] - relay: TRUE
[18:01:03.736] - stdout: TRUE
[18:01:03.736] - signal: TRUE
[18:01:03.736] - resignal: FALSE
[18:01:03.736] - force: TRUE
[18:01:03.737] - relayed: [n=2] TRUE, FALSE
[18:01:03.737] - queued futures: [n=2] TRUE, FALSE
[18:01:03.737]  - until=2
[18:01:03.737]  - relaying element #2
[18:01:03.738] result() for MulticoreFuture ...
[18:01:03.738] result() for MulticoreFuture ... done
[18:01:03.738] result() for MulticoreFuture ...
[18:01:03.738] result() for MulticoreFuture ... done
[18:01:03.739] result() for MulticoreFuture ...
[18:01:03.739] result() for MulticoreFuture ... done
[18:01:03.739] result() for MulticoreFuture ...
[18:01:03.739] result() for MulticoreFuture ... done
[18:01:03.740] - relayed: [n=2] TRUE, TRUE
[18:01:03.740] - queued futures: [n=2] TRUE, TRUE
[18:01:03.740] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:03.740]  length: 0 (resolved future 2)
[18:01:03.740] Relaying remaining futures
[18:01:03.741] signalConditionsASAP(NULL, pos=0) ...
[18:01:03.741] - nx: 2
[18:01:03.741] - relay: TRUE
[18:01:03.741] - stdout: TRUE
[18:01:03.741] - signal: TRUE
[18:01:03.742] - resignal: FALSE
[18:01:03.742] - force: TRUE
[18:01:03.742] - relayed: [n=2] TRUE, TRUE
[18:01:03.742] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:03.743] - relayed: [n=2] TRUE, TRUE
[18:01:03.743] - queued futures: [n=2] TRUE, TRUE
[18:01:03.743] signalConditionsASAP(NULL, pos=0) ... done
[18:01:03.743] resolve() on list ... DONE
[18:01:03.744] result() for MulticoreFuture ...
[18:01:03.744] result() for MulticoreFuture ... done
[18:01:03.744] result() for MulticoreFuture ...
[18:01:03.744] result() for MulticoreFuture ... done
[18:01:03.744] result() for MulticoreFuture ...
[18:01:03.745] result() for MulticoreFuture ... done
[18:01:03.745] result() for MulticoreFuture ...
[18:01:03.745] result() for MulticoreFuture ... done
[18:01:03.745]  - Number of value chunks collected: 2
[18:01:03.746] Resolving 2 futures (chunks) ... DONE
[18:01:03.746] Reducing values from 2 chunks ...
[18:01:03.746]  - Number of values collected after concatenation: 5
[18:01:03.746]  - Number of values expected: 5
[18:01:03.746] Reducing values from 2 chunks ... DONE
[18:01:03.747] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[18:01:03.751] future_mapply() ...
[18:01:03.758] Number of chunks: 2
[18:01:03.758] getGlobalsAndPackagesXApply() ...
[18:01:03.759]  - future.globals: TRUE
[18:01:03.759] getGlobalsAndPackages() ...
[18:01:03.759] Searching for globals...
[18:01:03.760] - globals found: [1] ‘FUN’
[18:01:03.761] Searching for globals ... DONE
[18:01:03.761] Resolving globals: FALSE
[18:01:03.761] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:03.762] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:03.762] - globals: [1] ‘FUN’
[18:01:03.763] 
[18:01:03.763] getGlobalsAndPackages() ... DONE
[18:01:03.763]  - globals found/used: [n=1] ‘FUN’
[18:01:03.763]  - needed namespaces: [n=0] 
[18:01:03.763] Finding globals ... DONE
[18:01:03.764] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:03.764] List of 2
[18:01:03.764]  $ ...future.FUN:function (e1, e2)  
[18:01:03.764]  $ MoreArgs     : NULL
[18:01:03.764]  - attr(*, "where")=List of 2
[18:01:03.764]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:03.764]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:03.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.764]  - attr(*, "resolved")= logi FALSE
[18:01:03.764]  - attr(*, "total_size")= num NA
[18:01:03.769] Packages to be attached in all futures: [n=0] 
[18:01:03.770] getGlobalsAndPackagesXApply() ... DONE
[18:01:03.770] Number of futures (= number of chunks): 2
[18:01:03.773] Launching 2 futures (chunks) ...
[18:01:03.774] Chunk #1 of 2 ...
[18:01:03.774]  - Finding globals in '...' for chunk #1 ...
[18:01:03.774] getGlobalsAndPackages() ...
[18:01:03.774] Searching for globals...
[18:01:03.775] 
[18:01:03.775] Searching for globals ... DONE
[18:01:03.776] - globals: [0] <none>
[18:01:03.776] getGlobalsAndPackages() ... DONE
[18:01:03.776]    + additional globals found: [n=0] 
[18:01:03.776]    + additional namespaces needed: [n=0] 
[18:01:03.776]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:03.777]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.777]  - seeds: <none>
[18:01:03.777]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.777] getGlobalsAndPackages() ...
[18:01:03.778] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.778] Resolving globals: FALSE
[18:01:03.779] The total size of the 5 globals is 168 bytes (168 bytes)
[18:01:03.780] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:03.780] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.780] 
[18:01:03.781] getGlobalsAndPackages() ... DONE
[18:01:03.781] run() for ‘Future’ ...
[18:01:03.781] - state: ‘created’
[18:01:03.782] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.789]   - Field: ‘label’
[18:01:03.789]   - Field: ‘local’
[18:01:03.790]   - Field: ‘owner’
[18:01:03.790]   - Field: ‘envir’
[18:01:03.790]   - Field: ‘workers’
[18:01:03.790]   - Field: ‘packages’
[18:01:03.790]   - Field: ‘gc’
[18:01:03.791]   - Field: ‘job’
[18:01:03.791]   - Field: ‘conditions’
[18:01:03.791]   - Field: ‘expr’
[18:01:03.791]   - Field: ‘uuid’
[18:01:03.791]   - Field: ‘seed’
[18:01:03.792]   - Field: ‘version’
[18:01:03.792]   - Field: ‘result’
[18:01:03.792]   - Field: ‘asynchronous’
[18:01:03.792]   - Field: ‘calls’
[18:01:03.792]   - Field: ‘globals’
[18:01:03.793]   - Field: ‘stdout’
[18:01:03.793]   - Field: ‘earlySignal’
[18:01:03.793]   - Field: ‘lazy’
[18:01:03.793]   - Field: ‘state’
[18:01:03.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.794] - Launch lazy future ...
[18:01:03.794] Packages needed by the future expression (n = 0): <none>
[18:01:03.794] Packages needed by future strategies (n = 0): <none>
[18:01:03.795] {
[18:01:03.795]     {
[18:01:03.795]         {
[18:01:03.795]             ...future.startTime <- base::Sys.time()
[18:01:03.795]             {
[18:01:03.795]                 {
[18:01:03.795]                   {
[18:01:03.795]                     {
[18:01:03.795]                       base::local({
[18:01:03.795]                         has_future <- base::requireNamespace("future", 
[18:01:03.795]                           quietly = TRUE)
[18:01:03.795]                         if (has_future) {
[18:01:03.795]                           ns <- base::getNamespace("future")
[18:01:03.795]                           version <- ns[[".package"]][["version"]]
[18:01:03.795]                           if (is.null(version)) 
[18:01:03.795]                             version <- utils::packageVersion("future")
[18:01:03.795]                         }
[18:01:03.795]                         else {
[18:01:03.795]                           version <- NULL
[18:01:03.795]                         }
[18:01:03.795]                         if (!has_future || version < "1.8.0") {
[18:01:03.795]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.795]                             "", base::R.version$version.string), 
[18:01:03.795]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:03.795]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:03.795]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.795]                               "release", "version")], collapse = " "), 
[18:01:03.795]                             hostname = base::Sys.info()[["nodename"]])
[18:01:03.795]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.795]                             info)
[18:01:03.795]                           info <- base::paste(info, collapse = "; ")
[18:01:03.795]                           if (!has_future) {
[18:01:03.795]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.795]                               info)
[18:01:03.795]                           }
[18:01:03.795]                           else {
[18:01:03.795]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.795]                               info, version)
[18:01:03.795]                           }
[18:01:03.795]                           base::stop(msg)
[18:01:03.795]                         }
[18:01:03.795]                       })
[18:01:03.795]                     }
[18:01:03.795]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.795]                     base::options(mc.cores = 1L)
[18:01:03.795]                   }
[18:01:03.795]                   ...future.strategy.old <- future::plan("list")
[18:01:03.795]                   options(future.plan = NULL)
[18:01:03.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.795]                 }
[18:01:03.795]                 ...future.workdir <- getwd()
[18:01:03.795]             }
[18:01:03.795]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.795]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.795]         }
[18:01:03.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.795]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.795]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.795]             base::names(...future.oldOptions))
[18:01:03.795]     }
[18:01:03.795]     if (FALSE) {
[18:01:03.795]     }
[18:01:03.795]     else {
[18:01:03.795]         if (TRUE) {
[18:01:03.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.795]                 open = "w")
[18:01:03.795]         }
[18:01:03.795]         else {
[18:01:03.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.795]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.795]         }
[18:01:03.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.795]             base::sink(type = "output", split = FALSE)
[18:01:03.795]             base::close(...future.stdout)
[18:01:03.795]         }, add = TRUE)
[18:01:03.795]     }
[18:01:03.795]     ...future.frame <- base::sys.nframe()
[18:01:03.795]     ...future.conditions <- base::list()
[18:01:03.795]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.795]     if (FALSE) {
[18:01:03.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.795]     }
[18:01:03.795]     ...future.result <- base::tryCatch({
[18:01:03.795]         base::withCallingHandlers({
[18:01:03.795]             ...future.value <- base::withVisible(base::local({
[18:01:03.795]                 withCallingHandlers({
[18:01:03.795]                   {
[18:01:03.795]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.795]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.795]                       ...future.globals.maxSize)) {
[18:01:03.795]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.795]                       on.exit(options(oopts), add = TRUE)
[18:01:03.795]                     }
[18:01:03.795]                     {
[18:01:03.795]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.795]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.795]                         USE.NAMES = FALSE)
[18:01:03.795]                       do.call(mapply, args = args)
[18:01:03.795]                     }
[18:01:03.795]                   }
[18:01:03.795]                 }, immediateCondition = function(cond) {
[18:01:03.795]                   save_rds <- function (object, pathname, ...) 
[18:01:03.795]                   {
[18:01:03.795]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.795]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.795]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.795]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.795]                         fi_tmp[["mtime"]])
[18:01:03.795]                     }
[18:01:03.795]                     tryCatch({
[18:01:03.795]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.795]                     }, error = function(ex) {
[18:01:03.795]                       msg <- conditionMessage(ex)
[18:01:03.795]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.795]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.795]                         fi_tmp[["mtime"]], msg)
[18:01:03.795]                       ex$message <- msg
[18:01:03.795]                       stop(ex)
[18:01:03.795]                     })
[18:01:03.795]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.795]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.795]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.795]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.795]                       fi <- file.info(pathname)
[18:01:03.795]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.795]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.795]                         fi[["size"]], fi[["mtime"]])
[18:01:03.795]                       stop(msg)
[18:01:03.795]                     }
[18:01:03.795]                     invisible(pathname)
[18:01:03.795]                   }
[18:01:03.795]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.795]                     rootPath = tempdir()) 
[18:01:03.795]                   {
[18:01:03.795]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.795]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.795]                       tmpdir = path, fileext = ".rds")
[18:01:03.795]                     save_rds(obj, file)
[18:01:03.795]                   }
[18:01:03.795]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.795]                   {
[18:01:03.795]                     inherits <- base::inherits
[18:01:03.795]                     invokeRestart <- base::invokeRestart
[18:01:03.795]                     is.null <- base::is.null
[18:01:03.795]                     muffled <- FALSE
[18:01:03.795]                     if (inherits(cond, "message")) {
[18:01:03.795]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.795]                       if (muffled) 
[18:01:03.795]                         invokeRestart("muffleMessage")
[18:01:03.795]                     }
[18:01:03.795]                     else if (inherits(cond, "warning")) {
[18:01:03.795]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.795]                       if (muffled) 
[18:01:03.795]                         invokeRestart("muffleWarning")
[18:01:03.795]                     }
[18:01:03.795]                     else if (inherits(cond, "condition")) {
[18:01:03.795]                       if (!is.null(pattern)) {
[18:01:03.795]                         computeRestarts <- base::computeRestarts
[18:01:03.795]                         grepl <- base::grepl
[18:01:03.795]                         restarts <- computeRestarts(cond)
[18:01:03.795]                         for (restart in restarts) {
[18:01:03.795]                           name <- restart$name
[18:01:03.795]                           if (is.null(name)) 
[18:01:03.795]                             next
[18:01:03.795]                           if (!grepl(pattern, name)) 
[18:01:03.795]                             next
[18:01:03.795]                           invokeRestart(restart)
[18:01:03.795]                           muffled <- TRUE
[18:01:03.795]                           break
[18:01:03.795]                         }
[18:01:03.795]                       }
[18:01:03.795]                     }
[18:01:03.795]                     invisible(muffled)
[18:01:03.795]                   }
[18:01:03.795]                   muffleCondition(cond)
[18:01:03.795]                 })
[18:01:03.795]             }))
[18:01:03.795]             future::FutureResult(value = ...future.value$value, 
[18:01:03.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.795]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.795]                     ...future.globalenv.names))
[18:01:03.795]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.795]         }, condition = base::local({
[18:01:03.795]             c <- base::c
[18:01:03.795]             inherits <- base::inherits
[18:01:03.795]             invokeRestart <- base::invokeRestart
[18:01:03.795]             length <- base::length
[18:01:03.795]             list <- base::list
[18:01:03.795]             seq.int <- base::seq.int
[18:01:03.795]             signalCondition <- base::signalCondition
[18:01:03.795]             sys.calls <- base::sys.calls
[18:01:03.795]             `[[` <- base::`[[`
[18:01:03.795]             `+` <- base::`+`
[18:01:03.795]             `<<-` <- base::`<<-`
[18:01:03.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.795]                   3L)]
[18:01:03.795]             }
[18:01:03.795]             function(cond) {
[18:01:03.795]                 is_error <- inherits(cond, "error")
[18:01:03.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.795]                   NULL)
[18:01:03.795]                 if (is_error) {
[18:01:03.795]                   sessionInformation <- function() {
[18:01:03.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.795]                       search = base::search(), system = base::Sys.info())
[18:01:03.795]                   }
[18:01:03.795]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.795]                     cond$call), session = sessionInformation(), 
[18:01:03.795]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.795]                   signalCondition(cond)
[18:01:03.795]                 }
[18:01:03.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.795]                 "immediateCondition"))) {
[18:01:03.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.795]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.795]                   if (TRUE && !signal) {
[18:01:03.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.795]                     {
[18:01:03.795]                       inherits <- base::inherits
[18:01:03.795]                       invokeRestart <- base::invokeRestart
[18:01:03.795]                       is.null <- base::is.null
[18:01:03.795]                       muffled <- FALSE
[18:01:03.795]                       if (inherits(cond, "message")) {
[18:01:03.795]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.795]                         if (muffled) 
[18:01:03.795]                           invokeRestart("muffleMessage")
[18:01:03.795]                       }
[18:01:03.795]                       else if (inherits(cond, "warning")) {
[18:01:03.795]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.795]                         if (muffled) 
[18:01:03.795]                           invokeRestart("muffleWarning")
[18:01:03.795]                       }
[18:01:03.795]                       else if (inherits(cond, "condition")) {
[18:01:03.795]                         if (!is.null(pattern)) {
[18:01:03.795]                           computeRestarts <- base::computeRestarts
[18:01:03.795]                           grepl <- base::grepl
[18:01:03.795]                           restarts <- computeRestarts(cond)
[18:01:03.795]                           for (restart in restarts) {
[18:01:03.795]                             name <- restart$name
[18:01:03.795]                             if (is.null(name)) 
[18:01:03.795]                               next
[18:01:03.795]                             if (!grepl(pattern, name)) 
[18:01:03.795]                               next
[18:01:03.795]                             invokeRestart(restart)
[18:01:03.795]                             muffled <- TRUE
[18:01:03.795]                             break
[18:01:03.795]                           }
[18:01:03.795]                         }
[18:01:03.795]                       }
[18:01:03.795]                       invisible(muffled)
[18:01:03.795]                     }
[18:01:03.795]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.795]                   }
[18:01:03.795]                 }
[18:01:03.795]                 else {
[18:01:03.795]                   if (TRUE) {
[18:01:03.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.795]                     {
[18:01:03.795]                       inherits <- base::inherits
[18:01:03.795]                       invokeRestart <- base::invokeRestart
[18:01:03.795]                       is.null <- base::is.null
[18:01:03.795]                       muffled <- FALSE
[18:01:03.795]                       if (inherits(cond, "message")) {
[18:01:03.795]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.795]                         if (muffled) 
[18:01:03.795]                           invokeRestart("muffleMessage")
[18:01:03.795]                       }
[18:01:03.795]                       else if (inherits(cond, "warning")) {
[18:01:03.795]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.795]                         if (muffled) 
[18:01:03.795]                           invokeRestart("muffleWarning")
[18:01:03.795]                       }
[18:01:03.795]                       else if (inherits(cond, "condition")) {
[18:01:03.795]                         if (!is.null(pattern)) {
[18:01:03.795]                           computeRestarts <- base::computeRestarts
[18:01:03.795]                           grepl <- base::grepl
[18:01:03.795]                           restarts <- computeRestarts(cond)
[18:01:03.795]                           for (restart in restarts) {
[18:01:03.795]                             name <- restart$name
[18:01:03.795]                             if (is.null(name)) 
[18:01:03.795]                               next
[18:01:03.795]                             if (!grepl(pattern, name)) 
[18:01:03.795]                               next
[18:01:03.795]                             invokeRestart(restart)
[18:01:03.795]                             muffled <- TRUE
[18:01:03.795]                             break
[18:01:03.795]                           }
[18:01:03.795]                         }
[18:01:03.795]                       }
[18:01:03.795]                       invisible(muffled)
[18:01:03.795]                     }
[18:01:03.795]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.795]                   }
[18:01:03.795]                 }
[18:01:03.795]             }
[18:01:03.795]         }))
[18:01:03.795]     }, error = function(ex) {
[18:01:03.795]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.795]                 ...future.rng), started = ...future.startTime, 
[18:01:03.795]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.795]             version = "1.8"), class = "FutureResult")
[18:01:03.795]     }, finally = {
[18:01:03.795]         if (!identical(...future.workdir, getwd())) 
[18:01:03.795]             setwd(...future.workdir)
[18:01:03.795]         {
[18:01:03.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.795]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.795]             }
[18:01:03.795]             base::options(...future.oldOptions)
[18:01:03.795]             if (.Platform$OS.type == "windows") {
[18:01:03.795]                 old_names <- names(...future.oldEnvVars)
[18:01:03.795]                 envs <- base::Sys.getenv()
[18:01:03.795]                 names <- names(envs)
[18:01:03.795]                 common <- intersect(names, old_names)
[18:01:03.795]                 added <- setdiff(names, old_names)
[18:01:03.795]                 removed <- setdiff(old_names, names)
[18:01:03.795]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.795]                   envs[common]]
[18:01:03.795]                 NAMES <- toupper(changed)
[18:01:03.795]                 args <- list()
[18:01:03.795]                 for (kk in seq_along(NAMES)) {
[18:01:03.795]                   name <- changed[[kk]]
[18:01:03.795]                   NAME <- NAMES[[kk]]
[18:01:03.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.795]                     next
[18:01:03.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.795]                 }
[18:01:03.795]                 NAMES <- toupper(added)
[18:01:03.795]                 for (kk in seq_along(NAMES)) {
[18:01:03.795]                   name <- added[[kk]]
[18:01:03.795]                   NAME <- NAMES[[kk]]
[18:01:03.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.795]                     next
[18:01:03.795]                   args[[name]] <- ""
[18:01:03.795]                 }
[18:01:03.795]                 NAMES <- toupper(removed)
[18:01:03.795]                 for (kk in seq_along(NAMES)) {
[18:01:03.795]                   name <- removed[[kk]]
[18:01:03.795]                   NAME <- NAMES[[kk]]
[18:01:03.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.795]                     next
[18:01:03.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.795]                 }
[18:01:03.795]                 if (length(args) > 0) 
[18:01:03.795]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.795]             }
[18:01:03.795]             else {
[18:01:03.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.795]             }
[18:01:03.795]             {
[18:01:03.795]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.795]                   0L) {
[18:01:03.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.795]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.795]                   base::options(opts)
[18:01:03.795]                 }
[18:01:03.795]                 {
[18:01:03.795]                   {
[18:01:03.795]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.795]                     NULL
[18:01:03.795]                   }
[18:01:03.795]                   options(future.plan = NULL)
[18:01:03.795]                   if (is.na(NA_character_)) 
[18:01:03.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.795]                     .init = FALSE)
[18:01:03.795]                 }
[18:01:03.795]             }
[18:01:03.795]         }
[18:01:03.795]     })
[18:01:03.795]     if (TRUE) {
[18:01:03.795]         base::sink(type = "output", split = FALSE)
[18:01:03.795]         if (TRUE) {
[18:01:03.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.795]         }
[18:01:03.795]         else {
[18:01:03.795]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.795]         }
[18:01:03.795]         base::close(...future.stdout)
[18:01:03.795]         ...future.stdout <- NULL
[18:01:03.795]     }
[18:01:03.795]     ...future.result$conditions <- ...future.conditions
[18:01:03.795]     ...future.result$finished <- base::Sys.time()
[18:01:03.795]     ...future.result
[18:01:03.795] }
[18:01:03.800] assign_globals() ...
[18:01:03.800] List of 5
[18:01:03.800]  $ ...future.FUN            :function (e1, e2)  
[18:01:03.800]  $ MoreArgs                 : NULL
[18:01:03.800]  $ ...future.elements_ii    :List of 2
[18:01:03.800]   ..$ :List of 1
[18:01:03.800]   .. ..$ : num 1
[18:01:03.800]   ..$ :List of 1
[18:01:03.800]   .. ..$ : int 1
[18:01:03.800]  $ ...future.seeds_ii       : NULL
[18:01:03.800]  $ ...future.globals.maxSize: NULL
[18:01:03.800]  - attr(*, "where")=List of 5
[18:01:03.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.800]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.800]  - attr(*, "resolved")= logi FALSE
[18:01:03.800]  - attr(*, "total_size")= num 168
[18:01:03.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.800]  - attr(*, "already-done")= logi TRUE
[18:01:03.810] - copied ‘...future.FUN’ to environment
[18:01:03.811] - copied ‘MoreArgs’ to environment
[18:01:03.811] - copied ‘...future.elements_ii’ to environment
[18:01:03.811] - copied ‘...future.seeds_ii’ to environment
[18:01:03.811] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.811] assign_globals() ... done
[18:01:03.812] requestCore(): workers = 2
[18:01:03.815] MulticoreFuture started
[18:01:03.816] - Launch lazy future ... done
[18:01:03.817] run() for ‘MulticoreFuture’ ... done
[18:01:03.817] Created future:
[18:01:03.817] plan(): Setting new future strategy stack:
[18:01:03.818] List of future strategies:
[18:01:03.818] 1. sequential:
[18:01:03.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.818]    - tweaked: FALSE
[18:01:03.818]    - call: NULL
[18:01:03.820] plan(): nbrOfWorkers() = 1
[18:01:03.824] plan(): Setting new future strategy stack:
[18:01:03.825] List of future strategies:
[18:01:03.825] 1. multicore:
[18:01:03.825]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.825]    - tweaked: FALSE
[18:01:03.825]    - call: plan(strategy)
[18:01:03.818] MulticoreFuture:
[18:01:03.818] Label: ‘future_Map-1’
[18:01:03.818] Expression:
[18:01:03.818] {
[18:01:03.818]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.818]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.818]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.818]         on.exit(options(oopts), add = TRUE)
[18:01:03.818]     }
[18:01:03.818]     {
[18:01:03.818]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.818]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.818]         do.call(mapply, args = args)
[18:01:03.818]     }
[18:01:03.818] }
[18:01:03.818] Lazy evaluation: FALSE
[18:01:03.818] Asynchronous evaluation: TRUE
[18:01:03.818] Local evaluation: TRUE
[18:01:03.818] Environment: R_GlobalEnv
[18:01:03.818] Capture standard output: TRUE
[18:01:03.818] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.818] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.818] Packages: <none>
[18:01:03.818] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:03.818] Resolved: FALSE
[18:01:03.818] Value: <not collected>
[18:01:03.818] Conditions captured: <none>
[18:01:03.818] Early signaling: FALSE
[18:01:03.818] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.818] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.833] Chunk #1 of 2 ... DONE
[18:01:03.833] Chunk #2 of 2 ...
[18:01:03.833]  - Finding globals in '...' for chunk #2 ...
[18:01:03.834] getGlobalsAndPackages() ...
[18:01:03.834] Searching for globals...
[18:01:03.835] 
[18:01:03.836] Searching for globals ... DONE
[18:01:03.836] - globals: [0] <none>
[18:01:03.836] getGlobalsAndPackages() ... DONE
[18:01:03.836]    + additional globals found: [n=0] 
[18:01:03.837]    + additional namespaces needed: [n=0] 
[18:01:03.837]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:03.835] plan(): nbrOfWorkers() = 2
[18:01:03.837]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:03.845]  - seeds: <none>
[18:01:03.846]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.847] getGlobalsAndPackages() ...
[18:01:03.848] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.849] Resolving globals: FALSE
[18:01:03.852] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:03.855] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:03.855] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:03.856] 
[18:01:03.856] getGlobalsAndPackages() ... DONE
[18:01:03.858] run() for ‘Future’ ...
[18:01:03.859] - state: ‘created’
[18:01:03.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:03.870] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:03.871]   - Field: ‘label’
[18:01:03.871]   - Field: ‘local’
[18:01:03.872]   - Field: ‘owner’
[18:01:03.872]   - Field: ‘envir’
[18:01:03.873]   - Field: ‘workers’
[18:01:03.873]   - Field: ‘packages’
[18:01:03.874]   - Field: ‘gc’
[18:01:03.874]   - Field: ‘job’
[18:01:03.874]   - Field: ‘conditions’
[18:01:03.875]   - Field: ‘expr’
[18:01:03.875]   - Field: ‘uuid’
[18:01:03.876]   - Field: ‘seed’
[18:01:03.876]   - Field: ‘version’
[18:01:03.877]   - Field: ‘result’
[18:01:03.877]   - Field: ‘asynchronous’
[18:01:03.877]   - Field: ‘calls’
[18:01:03.878]   - Field: ‘globals’
[18:01:03.878]   - Field: ‘stdout’
[18:01:03.878]   - Field: ‘earlySignal’
[18:01:03.879]   - Field: ‘lazy’
[18:01:03.879]   - Field: ‘state’
[18:01:03.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:03.880] - Launch lazy future ...
[18:01:03.881] Packages needed by the future expression (n = 0): <none>
[18:01:03.881] Packages needed by future strategies (n = 0): <none>
[18:01:03.882] {
[18:01:03.882]     {
[18:01:03.882]         {
[18:01:03.882]             ...future.startTime <- base::Sys.time()
[18:01:03.882]             {
[18:01:03.882]                 {
[18:01:03.882]                   {
[18:01:03.882]                     {
[18:01:03.882]                       base::local({
[18:01:03.882]                         has_future <- base::requireNamespace("future", 
[18:01:03.882]                           quietly = TRUE)
[18:01:03.882]                         if (has_future) {
[18:01:03.882]                           ns <- base::getNamespace("future")
[18:01:03.882]                           version <- ns[[".package"]][["version"]]
[18:01:03.882]                           if (is.null(version)) 
[18:01:03.882]                             version <- utils::packageVersion("future")
[18:01:03.882]                         }
[18:01:03.882]                         else {
[18:01:03.882]                           version <- NULL
[18:01:03.882]                         }
[18:01:03.882]                         if (!has_future || version < "1.8.0") {
[18:01:03.882]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:03.882]                             "", base::R.version$version.string), 
[18:01:03.882]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:03.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:03.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:03.882]                               "release", "version")], collapse = " "), 
[18:01:03.882]                             hostname = base::Sys.info()[["nodename"]])
[18:01:03.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:03.882]                             info)
[18:01:03.882]                           info <- base::paste(info, collapse = "; ")
[18:01:03.882]                           if (!has_future) {
[18:01:03.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:03.882]                               info)
[18:01:03.882]                           }
[18:01:03.882]                           else {
[18:01:03.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:03.882]                               info, version)
[18:01:03.882]                           }
[18:01:03.882]                           base::stop(msg)
[18:01:03.882]                         }
[18:01:03.882]                       })
[18:01:03.882]                     }
[18:01:03.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:03.882]                     base::options(mc.cores = 1L)
[18:01:03.882]                   }
[18:01:03.882]                   ...future.strategy.old <- future::plan("list")
[18:01:03.882]                   options(future.plan = NULL)
[18:01:03.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:03.882]                 }
[18:01:03.882]                 ...future.workdir <- getwd()
[18:01:03.882]             }
[18:01:03.882]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:03.882]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:03.882]         }
[18:01:03.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:03.882]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:03.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:03.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:03.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:03.882]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:03.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:03.882]             base::names(...future.oldOptions))
[18:01:03.882]     }
[18:01:03.882]     if (FALSE) {
[18:01:03.882]     }
[18:01:03.882]     else {
[18:01:03.882]         if (TRUE) {
[18:01:03.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:03.882]                 open = "w")
[18:01:03.882]         }
[18:01:03.882]         else {
[18:01:03.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:03.882]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:03.882]         }
[18:01:03.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:03.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:03.882]             base::sink(type = "output", split = FALSE)
[18:01:03.882]             base::close(...future.stdout)
[18:01:03.882]         }, add = TRUE)
[18:01:03.882]     }
[18:01:03.882]     ...future.frame <- base::sys.nframe()
[18:01:03.882]     ...future.conditions <- base::list()
[18:01:03.882]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:03.882]     if (FALSE) {
[18:01:03.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:03.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:03.882]     }
[18:01:03.882]     ...future.result <- base::tryCatch({
[18:01:03.882]         base::withCallingHandlers({
[18:01:03.882]             ...future.value <- base::withVisible(base::local({
[18:01:03.882]                 withCallingHandlers({
[18:01:03.882]                   {
[18:01:03.882]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.882]                     if (!identical(...future.globals.maxSize.org, 
[18:01:03.882]                       ...future.globals.maxSize)) {
[18:01:03.882]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.882]                       on.exit(options(oopts), add = TRUE)
[18:01:03.882]                     }
[18:01:03.882]                     {
[18:01:03.882]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.882]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:03.882]                         USE.NAMES = FALSE)
[18:01:03.882]                       do.call(mapply, args = args)
[18:01:03.882]                     }
[18:01:03.882]                   }
[18:01:03.882]                 }, immediateCondition = function(cond) {
[18:01:03.882]                   save_rds <- function (object, pathname, ...) 
[18:01:03.882]                   {
[18:01:03.882]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:03.882]                     if (file_test("-f", pathname_tmp)) {
[18:01:03.882]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.882]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:03.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.882]                         fi_tmp[["mtime"]])
[18:01:03.882]                     }
[18:01:03.882]                     tryCatch({
[18:01:03.882]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:03.882]                     }, error = function(ex) {
[18:01:03.882]                       msg <- conditionMessage(ex)
[18:01:03.882]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.882]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:03.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.882]                         fi_tmp[["mtime"]], msg)
[18:01:03.882]                       ex$message <- msg
[18:01:03.882]                       stop(ex)
[18:01:03.882]                     })
[18:01:03.882]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:03.882]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:03.882]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:03.882]                       fi_tmp <- file.info(pathname_tmp)
[18:01:03.882]                       fi <- file.info(pathname)
[18:01:03.882]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:03.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:03.882]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:03.882]                         fi[["size"]], fi[["mtime"]])
[18:01:03.882]                       stop(msg)
[18:01:03.882]                     }
[18:01:03.882]                     invisible(pathname)
[18:01:03.882]                   }
[18:01:03.882]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:03.882]                     rootPath = tempdir()) 
[18:01:03.882]                   {
[18:01:03.882]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:03.882]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:03.882]                       tmpdir = path, fileext = ".rds")
[18:01:03.882]                     save_rds(obj, file)
[18:01:03.882]                   }
[18:01:03.882]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:03.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.882]                   {
[18:01:03.882]                     inherits <- base::inherits
[18:01:03.882]                     invokeRestart <- base::invokeRestart
[18:01:03.882]                     is.null <- base::is.null
[18:01:03.882]                     muffled <- FALSE
[18:01:03.882]                     if (inherits(cond, "message")) {
[18:01:03.882]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:03.882]                       if (muffled) 
[18:01:03.882]                         invokeRestart("muffleMessage")
[18:01:03.882]                     }
[18:01:03.882]                     else if (inherits(cond, "warning")) {
[18:01:03.882]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:03.882]                       if (muffled) 
[18:01:03.882]                         invokeRestart("muffleWarning")
[18:01:03.882]                     }
[18:01:03.882]                     else if (inherits(cond, "condition")) {
[18:01:03.882]                       if (!is.null(pattern)) {
[18:01:03.882]                         computeRestarts <- base::computeRestarts
[18:01:03.882]                         grepl <- base::grepl
[18:01:03.882]                         restarts <- computeRestarts(cond)
[18:01:03.882]                         for (restart in restarts) {
[18:01:03.882]                           name <- restart$name
[18:01:03.882]                           if (is.null(name)) 
[18:01:03.882]                             next
[18:01:03.882]                           if (!grepl(pattern, name)) 
[18:01:03.882]                             next
[18:01:03.882]                           invokeRestart(restart)
[18:01:03.882]                           muffled <- TRUE
[18:01:03.882]                           break
[18:01:03.882]                         }
[18:01:03.882]                       }
[18:01:03.882]                     }
[18:01:03.882]                     invisible(muffled)
[18:01:03.882]                   }
[18:01:03.882]                   muffleCondition(cond)
[18:01:03.882]                 })
[18:01:03.882]             }))
[18:01:03.882]             future::FutureResult(value = ...future.value$value, 
[18:01:03.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.882]                   ...future.rng), globalenv = if (FALSE) 
[18:01:03.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:03.882]                     ...future.globalenv.names))
[18:01:03.882]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:03.882]         }, condition = base::local({
[18:01:03.882]             c <- base::c
[18:01:03.882]             inherits <- base::inherits
[18:01:03.882]             invokeRestart <- base::invokeRestart
[18:01:03.882]             length <- base::length
[18:01:03.882]             list <- base::list
[18:01:03.882]             seq.int <- base::seq.int
[18:01:03.882]             signalCondition <- base::signalCondition
[18:01:03.882]             sys.calls <- base::sys.calls
[18:01:03.882]             `[[` <- base::`[[`
[18:01:03.882]             `+` <- base::`+`
[18:01:03.882]             `<<-` <- base::`<<-`
[18:01:03.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:03.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:03.882]                   3L)]
[18:01:03.882]             }
[18:01:03.882]             function(cond) {
[18:01:03.882]                 is_error <- inherits(cond, "error")
[18:01:03.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:03.882]                   NULL)
[18:01:03.882]                 if (is_error) {
[18:01:03.882]                   sessionInformation <- function() {
[18:01:03.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:03.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:03.882]                       search = base::search(), system = base::Sys.info())
[18:01:03.882]                   }
[18:01:03.882]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:03.882]                     cond$call), session = sessionInformation(), 
[18:01:03.882]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:03.882]                   signalCondition(cond)
[18:01:03.882]                 }
[18:01:03.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:03.882]                 "immediateCondition"))) {
[18:01:03.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:03.882]                   ...future.conditions[[length(...future.conditions) + 
[18:01:03.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:03.882]                   if (TRUE && !signal) {
[18:01:03.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.882]                     {
[18:01:03.882]                       inherits <- base::inherits
[18:01:03.882]                       invokeRestart <- base::invokeRestart
[18:01:03.882]                       is.null <- base::is.null
[18:01:03.882]                       muffled <- FALSE
[18:01:03.882]                       if (inherits(cond, "message")) {
[18:01:03.882]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.882]                         if (muffled) 
[18:01:03.882]                           invokeRestart("muffleMessage")
[18:01:03.882]                       }
[18:01:03.882]                       else if (inherits(cond, "warning")) {
[18:01:03.882]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.882]                         if (muffled) 
[18:01:03.882]                           invokeRestart("muffleWarning")
[18:01:03.882]                       }
[18:01:03.882]                       else if (inherits(cond, "condition")) {
[18:01:03.882]                         if (!is.null(pattern)) {
[18:01:03.882]                           computeRestarts <- base::computeRestarts
[18:01:03.882]                           grepl <- base::grepl
[18:01:03.882]                           restarts <- computeRestarts(cond)
[18:01:03.882]                           for (restart in restarts) {
[18:01:03.882]                             name <- restart$name
[18:01:03.882]                             if (is.null(name)) 
[18:01:03.882]                               next
[18:01:03.882]                             if (!grepl(pattern, name)) 
[18:01:03.882]                               next
[18:01:03.882]                             invokeRestart(restart)
[18:01:03.882]                             muffled <- TRUE
[18:01:03.882]                             break
[18:01:03.882]                           }
[18:01:03.882]                         }
[18:01:03.882]                       }
[18:01:03.882]                       invisible(muffled)
[18:01:03.882]                     }
[18:01:03.882]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.882]                   }
[18:01:03.882]                 }
[18:01:03.882]                 else {
[18:01:03.882]                   if (TRUE) {
[18:01:03.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:03.882]                     {
[18:01:03.882]                       inherits <- base::inherits
[18:01:03.882]                       invokeRestart <- base::invokeRestart
[18:01:03.882]                       is.null <- base::is.null
[18:01:03.882]                       muffled <- FALSE
[18:01:03.882]                       if (inherits(cond, "message")) {
[18:01:03.882]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:03.882]                         if (muffled) 
[18:01:03.882]                           invokeRestart("muffleMessage")
[18:01:03.882]                       }
[18:01:03.882]                       else if (inherits(cond, "warning")) {
[18:01:03.882]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:03.882]                         if (muffled) 
[18:01:03.882]                           invokeRestart("muffleWarning")
[18:01:03.882]                       }
[18:01:03.882]                       else if (inherits(cond, "condition")) {
[18:01:03.882]                         if (!is.null(pattern)) {
[18:01:03.882]                           computeRestarts <- base::computeRestarts
[18:01:03.882]                           grepl <- base::grepl
[18:01:03.882]                           restarts <- computeRestarts(cond)
[18:01:03.882]                           for (restart in restarts) {
[18:01:03.882]                             name <- restart$name
[18:01:03.882]                             if (is.null(name)) 
[18:01:03.882]                               next
[18:01:03.882]                             if (!grepl(pattern, name)) 
[18:01:03.882]                               next
[18:01:03.882]                             invokeRestart(restart)
[18:01:03.882]                             muffled <- TRUE
[18:01:03.882]                             break
[18:01:03.882]                           }
[18:01:03.882]                         }
[18:01:03.882]                       }
[18:01:03.882]                       invisible(muffled)
[18:01:03.882]                     }
[18:01:03.882]                     muffleCondition(cond, pattern = "^muffle")
[18:01:03.882]                   }
[18:01:03.882]                 }
[18:01:03.882]             }
[18:01:03.882]         }))
[18:01:03.882]     }, error = function(ex) {
[18:01:03.882]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:03.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:03.882]                 ...future.rng), started = ...future.startTime, 
[18:01:03.882]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:03.882]             version = "1.8"), class = "FutureResult")
[18:01:03.882]     }, finally = {
[18:01:03.882]         if (!identical(...future.workdir, getwd())) 
[18:01:03.882]             setwd(...future.workdir)
[18:01:03.882]         {
[18:01:03.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:03.882]                 ...future.oldOptions$nwarnings <- NULL
[18:01:03.882]             }
[18:01:03.882]             base::options(...future.oldOptions)
[18:01:03.882]             if (.Platform$OS.type == "windows") {
[18:01:03.882]                 old_names <- names(...future.oldEnvVars)
[18:01:03.882]                 envs <- base::Sys.getenv()
[18:01:03.882]                 names <- names(envs)
[18:01:03.882]                 common <- intersect(names, old_names)
[18:01:03.882]                 added <- setdiff(names, old_names)
[18:01:03.882]                 removed <- setdiff(old_names, names)
[18:01:03.882]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:03.882]                   envs[common]]
[18:01:03.882]                 NAMES <- toupper(changed)
[18:01:03.882]                 args <- list()
[18:01:03.882]                 for (kk in seq_along(NAMES)) {
[18:01:03.882]                   name <- changed[[kk]]
[18:01:03.882]                   NAME <- NAMES[[kk]]
[18:01:03.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.882]                     next
[18:01:03.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.882]                 }
[18:01:03.882]                 NAMES <- toupper(added)
[18:01:03.882]                 for (kk in seq_along(NAMES)) {
[18:01:03.882]                   name <- added[[kk]]
[18:01:03.882]                   NAME <- NAMES[[kk]]
[18:01:03.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.882]                     next
[18:01:03.882]                   args[[name]] <- ""
[18:01:03.882]                 }
[18:01:03.882]                 NAMES <- toupper(removed)
[18:01:03.882]                 for (kk in seq_along(NAMES)) {
[18:01:03.882]                   name <- removed[[kk]]
[18:01:03.882]                   NAME <- NAMES[[kk]]
[18:01:03.882]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:03.882]                     next
[18:01:03.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:03.882]                 }
[18:01:03.882]                 if (length(args) > 0) 
[18:01:03.882]                   base::do.call(base::Sys.setenv, args = args)
[18:01:03.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:03.882]             }
[18:01:03.882]             else {
[18:01:03.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:03.882]             }
[18:01:03.882]             {
[18:01:03.882]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:03.882]                   0L) {
[18:01:03.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:03.882]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:03.882]                   base::options(opts)
[18:01:03.882]                 }
[18:01:03.882]                 {
[18:01:03.882]                   {
[18:01:03.882]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:03.882]                     NULL
[18:01:03.882]                   }
[18:01:03.882]                   options(future.plan = NULL)
[18:01:03.882]                   if (is.na(NA_character_)) 
[18:01:03.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:03.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:03.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:03.882]                     .init = FALSE)
[18:01:03.882]                 }
[18:01:03.882]             }
[18:01:03.882]         }
[18:01:03.882]     })
[18:01:03.882]     if (TRUE) {
[18:01:03.882]         base::sink(type = "output", split = FALSE)
[18:01:03.882]         if (TRUE) {
[18:01:03.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:03.882]         }
[18:01:03.882]         else {
[18:01:03.882]             ...future.result["stdout"] <- base::list(NULL)
[18:01:03.882]         }
[18:01:03.882]         base::close(...future.stdout)
[18:01:03.882]         ...future.stdout <- NULL
[18:01:03.882]     }
[18:01:03.882]     ...future.result$conditions <- ...future.conditions
[18:01:03.882]     ...future.result$finished <- base::Sys.time()
[18:01:03.882]     ...future.result
[18:01:03.882] }
[18:01:03.888] assign_globals() ...
[18:01:03.889] List of 5
[18:01:03.889]  $ ...future.FUN            :function (e1, e2)  
[18:01:03.889]  $ MoreArgs                 : NULL
[18:01:03.889]  $ ...future.elements_ii    :List of 2
[18:01:03.889]   ..$ :List of 2
[18:01:03.889]   .. ..$ : num 1
[18:01:03.889]   .. ..$ : num 1
[18:01:03.889]   ..$ :List of 2
[18:01:03.889]   .. ..$ : int 2
[18:01:03.889]   .. ..$ : int 3
[18:01:03.889]  $ ...future.seeds_ii       : NULL
[18:01:03.889]  $ ...future.globals.maxSize: NULL
[18:01:03.889]  - attr(*, "where")=List of 5
[18:01:03.889]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:03.889]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:03.889]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:03.889]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:03.889]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:03.889]  - attr(*, "resolved")= logi FALSE
[18:01:03.889]  - attr(*, "total_size")= num 280
[18:01:03.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.889]  - attr(*, "already-done")= logi TRUE
[18:01:03.906] - copied ‘...future.FUN’ to environment
[18:01:03.906] - copied ‘MoreArgs’ to environment
[18:01:03.907] - copied ‘...future.elements_ii’ to environment
[18:01:03.907] - copied ‘...future.seeds_ii’ to environment
[18:01:03.907] - copied ‘...future.globals.maxSize’ to environment
[18:01:03.907] assign_globals() ... done
[18:01:03.908] requestCore(): workers = 2
[18:01:03.911] MulticoreFuture started
[18:01:03.912] - Launch lazy future ... done
[18:01:03.913] run() for ‘MulticoreFuture’ ... done
[18:01:03.913] Created future:
[18:01:03.913] plan(): Setting new future strategy stack:
[18:01:03.914] List of future strategies:
[18:01:03.914] 1. sequential:
[18:01:03.914]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:03.914]    - tweaked: FALSE
[18:01:03.914]    - call: NULL
[18:01:03.916] plan(): nbrOfWorkers() = 1
[18:01:03.920] plan(): Setting new future strategy stack:
[18:01:03.921] List of future strategies:
[18:01:03.921] 1. multicore:
[18:01:03.921]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:03.921]    - tweaked: FALSE
[18:01:03.921]    - call: plan(strategy)
[18:01:03.930] plan(): nbrOfWorkers() = 2
[18:01:03.914] MulticoreFuture:
[18:01:03.914] Label: ‘future_Map-2’
[18:01:03.914] Expression:
[18:01:03.914] {
[18:01:03.914]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:03.914]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:03.914]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:03.914]         on.exit(options(oopts), add = TRUE)
[18:01:03.914]     }
[18:01:03.914]     {
[18:01:03.914]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:03.914]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:03.914]         do.call(mapply, args = args)
[18:01:03.914]     }
[18:01:03.914] }
[18:01:03.914] Lazy evaluation: FALSE
[18:01:03.914] Asynchronous evaluation: TRUE
[18:01:03.914] Local evaluation: TRUE
[18:01:03.914] Environment: R_GlobalEnv
[18:01:03.914] Capture standard output: TRUE
[18:01:03.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:03.914] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:03.914] Packages: <none>
[18:01:03.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:03.914] Resolved: FALSE
[18:01:03.914] Value: <not collected>
[18:01:03.914] Conditions captured: <none>
[18:01:03.914] Early signaling: FALSE
[18:01:03.914] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:03.914] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:03.931] Chunk #2 of 2 ... DONE
[18:01:03.931] Launching 2 futures (chunks) ... DONE
[18:01:03.932] Resolving 2 futures (chunks) ...
[18:01:03.932] resolve() on list ...
[18:01:03.932]  recursive: 0
[18:01:03.933]  length: 2
[18:01:03.933] 
[18:01:03.934] Future #1
[18:01:03.934] result() for MulticoreFuture ...
[18:01:03.938] result() for MulticoreFuture ...
[18:01:03.938] result() for MulticoreFuture ... done
[18:01:03.939] result() for MulticoreFuture ... done
[18:01:03.939] result() for MulticoreFuture ...
[18:01:03.939] result() for MulticoreFuture ... done
[18:01:03.942] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:03.942] - nx: 2
[18:01:03.943] - relay: TRUE
[18:01:03.943] - stdout: TRUE
[18:01:03.943] - signal: TRUE
[18:01:03.944] - resignal: FALSE
[18:01:03.944] - force: TRUE
[18:01:03.951] - relayed: [n=2] FALSE, FALSE
[18:01:03.951] - queued futures: [n=2] FALSE, FALSE
[18:01:03.952]  - until=1
[18:01:03.953]  - relaying element #1
[18:01:03.953] result() for MulticoreFuture ...
[18:01:03.954] result() for MulticoreFuture ... done
[18:01:03.955] result() for MulticoreFuture ...
[18:01:03.956] result() for MulticoreFuture ... done
[18:01:03.956] result() for MulticoreFuture ...
[18:01:03.957] result() for MulticoreFuture ... done
[18:01:03.957] result() for MulticoreFuture ...
[18:01:03.958] result() for MulticoreFuture ... done
[18:01:03.958] - relayed: [n=2] TRUE, FALSE
[18:01:03.959] - queued futures: [n=2] TRUE, FALSE
[18:01:03.959] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:03.960]  length: 1 (resolved future 1)
[18:01:03.961] Future #2
[18:01:03.961] result() for MulticoreFuture ...
[18:01:03.963] result() for MulticoreFuture ...
[18:01:03.964] result() for MulticoreFuture ... done
[18:01:03.964] result() for MulticoreFuture ... done
[18:01:03.965] result() for MulticoreFuture ...
[18:01:03.965] result() for MulticoreFuture ... done
[18:01:03.966] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:03.966] - nx: 2
[18:01:03.966] - relay: TRUE
[18:01:03.966] - stdout: TRUE
[18:01:03.967] - signal: TRUE
[18:01:03.967] - resignal: FALSE
[18:01:03.967] - force: TRUE
[18:01:03.967] - relayed: [n=2] TRUE, FALSE
[18:01:03.968] - queued futures: [n=2] TRUE, FALSE
[18:01:03.968]  - until=2
[18:01:03.968]  - relaying element #2
[18:01:03.968] result() for MulticoreFuture ...
[18:01:03.969] result() for MulticoreFuture ... done
[18:01:03.969] result() for MulticoreFuture ...
[18:01:03.969] result() for MulticoreFuture ... done
[18:01:03.970] result() for MulticoreFuture ...
[18:01:03.970] result() for MulticoreFuture ... done
[18:01:03.970] result() for MulticoreFuture ...
[18:01:03.970] result() for MulticoreFuture ... done
[18:01:03.971] - relayed: [n=2] TRUE, TRUE
[18:01:03.971] - queued futures: [n=2] TRUE, TRUE
[18:01:03.971] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:03.971]  length: 0 (resolved future 2)
[18:01:03.972] Relaying remaining futures
[18:01:03.972] signalConditionsASAP(NULL, pos=0) ...
[18:01:03.972] - nx: 2
[18:01:03.972] - relay: TRUE
[18:01:03.973] - stdout: TRUE
[18:01:03.973] - signal: TRUE
[18:01:03.973] - resignal: FALSE
[18:01:03.973] - force: TRUE
[18:01:03.973] - relayed: [n=2] TRUE, TRUE
[18:01:03.974] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:03.974] - relayed: [n=2] TRUE, TRUE
[18:01:03.974] - queued futures: [n=2] TRUE, TRUE
[18:01:03.974] signalConditionsASAP(NULL, pos=0) ... done
[18:01:03.975] resolve() on list ... DONE
[18:01:03.975] result() for MulticoreFuture ...
[18:01:03.975] result() for MulticoreFuture ... done
[18:01:03.975] result() for MulticoreFuture ...
[18:01:03.975] result() for MulticoreFuture ... done
[18:01:03.976] result() for MulticoreFuture ...
[18:01:03.976] result() for MulticoreFuture ... done
[18:01:03.976] result() for MulticoreFuture ...
[18:01:03.976] result() for MulticoreFuture ... done
[18:01:03.977]  - Number of value chunks collected: 2
[18:01:03.977] Resolving 2 futures (chunks) ... DONE
[18:01:03.977] Reducing values from 2 chunks ...
[18:01:03.977]  - Number of values collected after concatenation: 3
[18:01:03.978]  - Number of values expected: 3
[18:01:03.978] Reducing values from 2 chunks ... DONE
[18:01:03.978] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[18:01:03.979] future_mapply() ...
[18:01:03.986] Number of chunks: 2
[18:01:03.986] getGlobalsAndPackagesXApply() ...
[18:01:03.987]  - future.globals: TRUE
[18:01:03.987] getGlobalsAndPackages() ...
[18:01:03.987] Searching for globals...
[18:01:03.989] - globals found: [1] ‘FUN’
[18:01:03.990] Searching for globals ... DONE
[18:01:03.990] Resolving globals: FALSE
[18:01:03.990] The total size of the 1 globals is 848 bytes (848 bytes)
[18:01:03.991] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:01:03.991] - globals: [1] ‘FUN’
[18:01:03.992] 
[18:01:03.992] getGlobalsAndPackages() ... DONE
[18:01:03.992]  - globals found/used: [n=1] ‘FUN’
[18:01:03.992]  - needed namespaces: [n=0] 
[18:01:03.992] Finding globals ... DONE
[18:01:03.993] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:03.993] List of 2
[18:01:03.993]  $ ...future.FUN:function (x)  
[18:01:03.993]  $ MoreArgs     : NULL
[18:01:03.993]  - attr(*, "where")=List of 2
[18:01:03.993]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:03.993]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:03.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:03.993]  - attr(*, "resolved")= logi FALSE
[18:01:03.993]  - attr(*, "total_size")= num NA
[18:01:03.998] Packages to be attached in all futures: [n=0] 
[18:01:03.999] getGlobalsAndPackagesXApply() ... DONE
[18:01:03.999] Number of futures (= number of chunks): 2
[18:01:03.999] Launching 2 futures (chunks) ...
[18:01:03.999] Chunk #1 of 2 ...
[18:01:04.000]  - Finding globals in '...' for chunk #1 ...
[18:01:04.000] getGlobalsAndPackages() ...
[18:01:04.000] Searching for globals...
[18:01:04.001] 
[18:01:04.001] Searching for globals ... DONE
[18:01:04.001] - globals: [0] <none>
[18:01:04.001] getGlobalsAndPackages() ... DONE
[18:01:04.001]    + additional globals found: [n=0] 
[18:01:04.002]    + additional namespaces needed: [n=0] 
[18:01:04.002]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:04.002]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:04.002]  - seeds: <none>
[18:01:04.002]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:04.003] getGlobalsAndPackages() ...
[18:01:04.003] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:04.003] Resolving globals: FALSE
[18:01:04.008] The total size of the 5 globals is 904 bytes (904 bytes)
[18:01:04.009] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:04.009] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:04.009] 
[18:01:04.009] getGlobalsAndPackages() ... DONE
[18:01:04.010] run() for ‘Future’ ...
[18:01:04.010] - state: ‘created’
[18:01:04.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:04.017] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:04.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:04.018]   - Field: ‘label’
[18:01:04.018]   - Field: ‘local’
[18:01:04.018]   - Field: ‘owner’
[18:01:04.019]   - Field: ‘envir’
[18:01:04.019]   - Field: ‘workers’
[18:01:04.019]   - Field: ‘packages’
[18:01:04.019]   - Field: ‘gc’
[18:01:04.019]   - Field: ‘job’
[18:01:04.020]   - Field: ‘conditions’
[18:01:04.020]   - Field: ‘expr’
[18:01:04.020]   - Field: ‘uuid’
[18:01:04.020]   - Field: ‘seed’
[18:01:04.021]   - Field: ‘version’
[18:01:04.021]   - Field: ‘result’
[18:01:04.021]   - Field: ‘asynchronous’
[18:01:04.021]   - Field: ‘calls’
[18:01:04.021]   - Field: ‘globals’
[18:01:04.022]   - Field: ‘stdout’
[18:01:04.022]   - Field: ‘earlySignal’
[18:01:04.022]   - Field: ‘lazy’
[18:01:04.022]   - Field: ‘state’
[18:01:04.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:04.023] - Launch lazy future ...
[18:01:04.023] Packages needed by the future expression (n = 0): <none>
[18:01:04.023] Packages needed by future strategies (n = 0): <none>
[18:01:04.024] {
[18:01:04.024]     {
[18:01:04.024]         {
[18:01:04.024]             ...future.startTime <- base::Sys.time()
[18:01:04.024]             {
[18:01:04.024]                 {
[18:01:04.024]                   {
[18:01:04.024]                     {
[18:01:04.024]                       base::local({
[18:01:04.024]                         has_future <- base::requireNamespace("future", 
[18:01:04.024]                           quietly = TRUE)
[18:01:04.024]                         if (has_future) {
[18:01:04.024]                           ns <- base::getNamespace("future")
[18:01:04.024]                           version <- ns[[".package"]][["version"]]
[18:01:04.024]                           if (is.null(version)) 
[18:01:04.024]                             version <- utils::packageVersion("future")
[18:01:04.024]                         }
[18:01:04.024]                         else {
[18:01:04.024]                           version <- NULL
[18:01:04.024]                         }
[18:01:04.024]                         if (!has_future || version < "1.8.0") {
[18:01:04.024]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:04.024]                             "", base::R.version$version.string), 
[18:01:04.024]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:04.024]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:04.024]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:04.024]                               "release", "version")], collapse = " "), 
[18:01:04.024]                             hostname = base::Sys.info()[["nodename"]])
[18:01:04.024]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:04.024]                             info)
[18:01:04.024]                           info <- base::paste(info, collapse = "; ")
[18:01:04.024]                           if (!has_future) {
[18:01:04.024]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:04.024]                               info)
[18:01:04.024]                           }
[18:01:04.024]                           else {
[18:01:04.024]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:04.024]                               info, version)
[18:01:04.024]                           }
[18:01:04.024]                           base::stop(msg)
[18:01:04.024]                         }
[18:01:04.024]                       })
[18:01:04.024]                     }
[18:01:04.024]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:04.024]                     base::options(mc.cores = 1L)
[18:01:04.024]                   }
[18:01:04.024]                   ...future.strategy.old <- future::plan("list")
[18:01:04.024]                   options(future.plan = NULL)
[18:01:04.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:04.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:04.024]                 }
[18:01:04.024]                 ...future.workdir <- getwd()
[18:01:04.024]             }
[18:01:04.024]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:04.024]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:04.024]         }
[18:01:04.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:04.024]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:04.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:04.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:04.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:04.024]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:04.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:04.024]             base::names(...future.oldOptions))
[18:01:04.024]     }
[18:01:04.024]     if (FALSE) {
[18:01:04.024]     }
[18:01:04.024]     else {
[18:01:04.024]         if (TRUE) {
[18:01:04.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:04.024]                 open = "w")
[18:01:04.024]         }
[18:01:04.024]         else {
[18:01:04.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:04.024]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:04.024]         }
[18:01:04.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:04.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:04.024]             base::sink(type = "output", split = FALSE)
[18:01:04.024]             base::close(...future.stdout)
[18:01:04.024]         }, add = TRUE)
[18:01:04.024]     }
[18:01:04.024]     ...future.frame <- base::sys.nframe()
[18:01:04.024]     ...future.conditions <- base::list()
[18:01:04.024]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:04.024]     if (FALSE) {
[18:01:04.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:04.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:04.024]     }
[18:01:04.024]     ...future.result <- base::tryCatch({
[18:01:04.024]         base::withCallingHandlers({
[18:01:04.024]             ...future.value <- base::withVisible(base::local({
[18:01:04.024]                 withCallingHandlers({
[18:01:04.024]                   {
[18:01:04.024]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:04.024]                     if (!identical(...future.globals.maxSize.org, 
[18:01:04.024]                       ...future.globals.maxSize)) {
[18:01:04.024]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:04.024]                       on.exit(options(oopts), add = TRUE)
[18:01:04.024]                     }
[18:01:04.024]                     {
[18:01:04.024]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:04.024]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:04.024]                         USE.NAMES = FALSE)
[18:01:04.024]                       do.call(mapply, args = args)
[18:01:04.024]                     }
[18:01:04.024]                   }
[18:01:04.024]                 }, immediateCondition = function(cond) {
[18:01:04.024]                   save_rds <- function (object, pathname, ...) 
[18:01:04.024]                   {
[18:01:04.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:04.024]                     if (file_test("-f", pathname_tmp)) {
[18:01:04.024]                       fi_tmp <- file.info(pathname_tmp)
[18:01:04.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:04.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:04.024]                         fi_tmp[["mtime"]])
[18:01:04.024]                     }
[18:01:04.024]                     tryCatch({
[18:01:04.024]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:04.024]                     }, error = function(ex) {
[18:01:04.024]                       msg <- conditionMessage(ex)
[18:01:04.024]                       fi_tmp <- file.info(pathname_tmp)
[18:01:04.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:04.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:04.024]                         fi_tmp[["mtime"]], msg)
[18:01:04.024]                       ex$message <- msg
[18:01:04.024]                       stop(ex)
[18:01:04.024]                     })
[18:01:04.024]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:04.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:04.024]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:04.024]                       fi_tmp <- file.info(pathname_tmp)
[18:01:04.024]                       fi <- file.info(pathname)
[18:01:04.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:04.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:04.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:04.024]                         fi[["size"]], fi[["mtime"]])
[18:01:04.024]                       stop(msg)
[18:01:04.024]                     }
[18:01:04.024]                     invisible(pathname)
[18:01:04.024]                   }
[18:01:04.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:04.024]                     rootPath = tempdir()) 
[18:01:04.024]                   {
[18:01:04.024]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:04.024]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:04.024]                       tmpdir = path, fileext = ".rds")
[18:01:04.024]                     save_rds(obj, file)
[18:01:04.024]                   }
[18:01:04.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:04.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.024]                   {
[18:01:04.024]                     inherits <- base::inherits
[18:01:04.024]                     invokeRestart <- base::invokeRestart
[18:01:04.024]                     is.null <- base::is.null
[18:01:04.024]                     muffled <- FALSE
[18:01:04.024]                     if (inherits(cond, "message")) {
[18:01:04.024]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:04.024]                       if (muffled) 
[18:01:04.024]                         invokeRestart("muffleMessage")
[18:01:04.024]                     }
[18:01:04.024]                     else if (inherits(cond, "warning")) {
[18:01:04.024]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:04.024]                       if (muffled) 
[18:01:04.024]                         invokeRestart("muffleWarning")
[18:01:04.024]                     }
[18:01:04.024]                     else if (inherits(cond, "condition")) {
[18:01:04.024]                       if (!is.null(pattern)) {
[18:01:04.024]                         computeRestarts <- base::computeRestarts
[18:01:04.024]                         grepl <- base::grepl
[18:01:04.024]                         restarts <- computeRestarts(cond)
[18:01:04.024]                         for (restart in restarts) {
[18:01:04.024]                           name <- restart$name
[18:01:04.024]                           if (is.null(name)) 
[18:01:04.024]                             next
[18:01:04.024]                           if (!grepl(pattern, name)) 
[18:01:04.024]                             next
[18:01:04.024]                           invokeRestart(restart)
[18:01:04.024]                           muffled <- TRUE
[18:01:04.024]                           break
[18:01:04.024]                         }
[18:01:04.024]                       }
[18:01:04.024]                     }
[18:01:04.024]                     invisible(muffled)
[18:01:04.024]                   }
[18:01:04.024]                   muffleCondition(cond)
[18:01:04.024]                 })
[18:01:04.024]             }))
[18:01:04.024]             future::FutureResult(value = ...future.value$value, 
[18:01:04.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:04.024]                   ...future.rng), globalenv = if (FALSE) 
[18:01:04.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:04.024]                     ...future.globalenv.names))
[18:01:04.024]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:04.024]         }, condition = base::local({
[18:01:04.024]             c <- base::c
[18:01:04.024]             inherits <- base::inherits
[18:01:04.024]             invokeRestart <- base::invokeRestart
[18:01:04.024]             length <- base::length
[18:01:04.024]             list <- base::list
[18:01:04.024]             seq.int <- base::seq.int
[18:01:04.024]             signalCondition <- base::signalCondition
[18:01:04.024]             sys.calls <- base::sys.calls
[18:01:04.024]             `[[` <- base::`[[`
[18:01:04.024]             `+` <- base::`+`
[18:01:04.024]             `<<-` <- base::`<<-`
[18:01:04.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:04.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:04.024]                   3L)]
[18:01:04.024]             }
[18:01:04.024]             function(cond) {
[18:01:04.024]                 is_error <- inherits(cond, "error")
[18:01:04.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:04.024]                   NULL)
[18:01:04.024]                 if (is_error) {
[18:01:04.024]                   sessionInformation <- function() {
[18:01:04.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:04.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:04.024]                       search = base::search(), system = base::Sys.info())
[18:01:04.024]                   }
[18:01:04.024]                   ...future.conditions[[length(...future.conditions) + 
[18:01:04.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:04.024]                     cond$call), session = sessionInformation(), 
[18:01:04.024]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:04.024]                   signalCondition(cond)
[18:01:04.024]                 }
[18:01:04.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:04.024]                 "immediateCondition"))) {
[18:01:04.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:04.024]                   ...future.conditions[[length(...future.conditions) + 
[18:01:04.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:04.024]                   if (TRUE && !signal) {
[18:01:04.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.024]                     {
[18:01:04.024]                       inherits <- base::inherits
[18:01:04.024]                       invokeRestart <- base::invokeRestart
[18:01:04.024]                       is.null <- base::is.null
[18:01:04.024]                       muffled <- FALSE
[18:01:04.024]                       if (inherits(cond, "message")) {
[18:01:04.024]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:04.024]                         if (muffled) 
[18:01:04.024]                           invokeRestart("muffleMessage")
[18:01:04.024]                       }
[18:01:04.024]                       else if (inherits(cond, "warning")) {
[18:01:04.024]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:04.024]                         if (muffled) 
[18:01:04.024]                           invokeRestart("muffleWarning")
[18:01:04.024]                       }
[18:01:04.024]                       else if (inherits(cond, "condition")) {
[18:01:04.024]                         if (!is.null(pattern)) {
[18:01:04.024]                           computeRestarts <- base::computeRestarts
[18:01:04.024]                           grepl <- base::grepl
[18:01:04.024]                           restarts <- computeRestarts(cond)
[18:01:04.024]                           for (restart in restarts) {
[18:01:04.024]                             name <- restart$name
[18:01:04.024]                             if (is.null(name)) 
[18:01:04.024]                               next
[18:01:04.024]                             if (!grepl(pattern, name)) 
[18:01:04.024]                               next
[18:01:04.024]                             invokeRestart(restart)
[18:01:04.024]                             muffled <- TRUE
[18:01:04.024]                             break
[18:01:04.024]                           }
[18:01:04.024]                         }
[18:01:04.024]                       }
[18:01:04.024]                       invisible(muffled)
[18:01:04.024]                     }
[18:01:04.024]                     muffleCondition(cond, pattern = "^muffle")
[18:01:04.024]                   }
[18:01:04.024]                 }
[18:01:04.024]                 else {
[18:01:04.024]                   if (TRUE) {
[18:01:04.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.024]                     {
[18:01:04.024]                       inherits <- base::inherits
[18:01:04.024]                       invokeRestart <- base::invokeRestart
[18:01:04.024]                       is.null <- base::is.null
[18:01:04.024]                       muffled <- FALSE
[18:01:04.024]                       if (inherits(cond, "message")) {
[18:01:04.024]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:04.024]                         if (muffled) 
[18:01:04.024]                           invokeRestart("muffleMessage")
[18:01:04.024]                       }
[18:01:04.024]                       else if (inherits(cond, "warning")) {
[18:01:04.024]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:04.024]                         if (muffled) 
[18:01:04.024]                           invokeRestart("muffleWarning")
[18:01:04.024]                       }
[18:01:04.024]                       else if (inherits(cond, "condition")) {
[18:01:04.024]                         if (!is.null(pattern)) {
[18:01:04.024]                           computeRestarts <- base::computeRestarts
[18:01:04.024]                           grepl <- base::grepl
[18:01:04.024]                           restarts <- computeRestarts(cond)
[18:01:04.024]                           for (restart in restarts) {
[18:01:04.024]                             name <- restart$name
[18:01:04.024]                             if (is.null(name)) 
[18:01:04.024]                               next
[18:01:04.024]                             if (!grepl(pattern, name)) 
[18:01:04.024]                               next
[18:01:04.024]                             invokeRestart(restart)
[18:01:04.024]                             muffled <- TRUE
[18:01:04.024]                             break
[18:01:04.024]                           }
[18:01:04.024]                         }
[18:01:04.024]                       }
[18:01:04.024]                       invisible(muffled)
[18:01:04.024]                     }
[18:01:04.024]                     muffleCondition(cond, pattern = "^muffle")
[18:01:04.024]                   }
[18:01:04.024]                 }
[18:01:04.024]             }
[18:01:04.024]         }))
[18:01:04.024]     }, error = function(ex) {
[18:01:04.024]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:04.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:04.024]                 ...future.rng), started = ...future.startTime, 
[18:01:04.024]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:04.024]             version = "1.8"), class = "FutureResult")
[18:01:04.024]     }, finally = {
[18:01:04.024]         if (!identical(...future.workdir, getwd())) 
[18:01:04.024]             setwd(...future.workdir)
[18:01:04.024]         {
[18:01:04.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:04.024]                 ...future.oldOptions$nwarnings <- NULL
[18:01:04.024]             }
[18:01:04.024]             base::options(...future.oldOptions)
[18:01:04.024]             if (.Platform$OS.type == "windows") {
[18:01:04.024]                 old_names <- names(...future.oldEnvVars)
[18:01:04.024]                 envs <- base::Sys.getenv()
[18:01:04.024]                 names <- names(envs)
[18:01:04.024]                 common <- intersect(names, old_names)
[18:01:04.024]                 added <- setdiff(names, old_names)
[18:01:04.024]                 removed <- setdiff(old_names, names)
[18:01:04.024]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:04.024]                   envs[common]]
[18:01:04.024]                 NAMES <- toupper(changed)
[18:01:04.024]                 args <- list()
[18:01:04.024]                 for (kk in seq_along(NAMES)) {
[18:01:04.024]                   name <- changed[[kk]]
[18:01:04.024]                   NAME <- NAMES[[kk]]
[18:01:04.024]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.024]                     next
[18:01:04.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:04.024]                 }
[18:01:04.024]                 NAMES <- toupper(added)
[18:01:04.024]                 for (kk in seq_along(NAMES)) {
[18:01:04.024]                   name <- added[[kk]]
[18:01:04.024]                   NAME <- NAMES[[kk]]
[18:01:04.024]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.024]                     next
[18:01:04.024]                   args[[name]] <- ""
[18:01:04.024]                 }
[18:01:04.024]                 NAMES <- toupper(removed)
[18:01:04.024]                 for (kk in seq_along(NAMES)) {
[18:01:04.024]                   name <- removed[[kk]]
[18:01:04.024]                   NAME <- NAMES[[kk]]
[18:01:04.024]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.024]                     next
[18:01:04.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:04.024]                 }
[18:01:04.024]                 if (length(args) > 0) 
[18:01:04.024]                   base::do.call(base::Sys.setenv, args = args)
[18:01:04.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:04.024]             }
[18:01:04.024]             else {
[18:01:04.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:04.024]             }
[18:01:04.024]             {
[18:01:04.024]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:04.024]                   0L) {
[18:01:04.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:04.024]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:04.024]                   base::options(opts)
[18:01:04.024]                 }
[18:01:04.024]                 {
[18:01:04.024]                   {
[18:01:04.024]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:04.024]                     NULL
[18:01:04.024]                   }
[18:01:04.024]                   options(future.plan = NULL)
[18:01:04.024]                   if (is.na(NA_character_)) 
[18:01:04.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:04.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:04.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:04.024]                     .init = FALSE)
[18:01:04.024]                 }
[18:01:04.024]             }
[18:01:04.024]         }
[18:01:04.024]     })
[18:01:04.024]     if (TRUE) {
[18:01:04.024]         base::sink(type = "output", split = FALSE)
[18:01:04.024]         if (TRUE) {
[18:01:04.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:04.024]         }
[18:01:04.024]         else {
[18:01:04.024]             ...future.result["stdout"] <- base::list(NULL)
[18:01:04.024]         }
[18:01:04.024]         base::close(...future.stdout)
[18:01:04.024]         ...future.stdout <- NULL
[18:01:04.024]     }
[18:01:04.024]     ...future.result$conditions <- ...future.conditions
[18:01:04.024]     ...future.result$finished <- base::Sys.time()
[18:01:04.024]     ...future.result
[18:01:04.024] }
[18:01:04.029] assign_globals() ...
[18:01:04.029] List of 5
[18:01:04.029]  $ ...future.FUN            :function (x)  
[18:01:04.029]  $ MoreArgs                 : NULL
[18:01:04.029]  $ ...future.elements_ii    :List of 1
[18:01:04.029]   ..$ :List of 1
[18:01:04.029]   .. ..$ a: num 0
[18:01:04.029]  $ ...future.seeds_ii       : NULL
[18:01:04.029]  $ ...future.globals.maxSize: NULL
[18:01:04.029]  - attr(*, "where")=List of 5
[18:01:04.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:04.029]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:04.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:04.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:04.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:04.029]  - attr(*, "resolved")= logi FALSE
[18:01:04.029]  - attr(*, "total_size")= num 904
[18:01:04.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:04.029]  - attr(*, "already-done")= logi TRUE
[18:01:04.039] - copied ‘...future.FUN’ to environment
[18:01:04.039] - copied ‘MoreArgs’ to environment
[18:01:04.039] - copied ‘...future.elements_ii’ to environment
[18:01:04.039] - copied ‘...future.seeds_ii’ to environment
[18:01:04.040] - copied ‘...future.globals.maxSize’ to environment
[18:01:04.040] assign_globals() ... done
[18:01:04.040] requestCore(): workers = 2
[18:01:04.044] MulticoreFuture started
[18:01:04.044] - Launch lazy future ... done
[18:01:04.045] run() for ‘MulticoreFuture’ ... done
[18:01:04.045] Created future:
[18:01:04.045] plan(): Setting new future strategy stack:
[18:01:04.046] List of future strategies:
[18:01:04.046] 1. sequential:
[18:01:04.046]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:04.046]    - tweaked: FALSE
[18:01:04.046]    - call: NULL
[18:01:04.048] plan(): nbrOfWorkers() = 1
[18:01:04.052] plan(): Setting new future strategy stack:
[18:01:04.053] List of future strategies:
[18:01:04.053] 1. multicore:
[18:01:04.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:04.053]    - tweaked: FALSE
[18:01:04.053]    - call: plan(strategy)
[18:01:04.046] MulticoreFuture:
[18:01:04.046] Label: ‘future_mapply-1’
[18:01:04.046] Expression:
[18:01:04.046] {
[18:01:04.046]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:04.046]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:04.046]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:04.046]         on.exit(options(oopts), add = TRUE)
[18:01:04.046]     }
[18:01:04.046]     {
[18:01:04.046]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:04.046]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:04.046]         do.call(mapply, args = args)
[18:01:04.046]     }
[18:01:04.046] }
[18:01:04.046] Lazy evaluation: FALSE
[18:01:04.046] Asynchronous evaluation: TRUE
[18:01:04.046] Local evaluation: TRUE
[18:01:04.046] Environment: R_GlobalEnv
[18:01:04.046] Capture standard output: TRUE
[18:01:04.046] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:04.046] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:04.046] Packages: <none>
[18:01:04.046] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:04.046] Resolved: FALSE
[18:01:04.046] Value: <not collected>
[18:01:04.046] Conditions captured: <none>
[18:01:04.046] Early signaling: FALSE
[18:01:04.046] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:04.046] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:04.061] Chunk #1 of 2 ... DONE
[18:01:04.061] Chunk #2 of 2 ...
[18:01:04.061]  - Finding globals in '...' for chunk #2 ...
[18:01:04.062] getGlobalsAndPackages() ...
[18:01:04.062] Searching for globals...
[18:01:04.063] plan(): nbrOfWorkers() = 2
[18:01:04.063] 
[18:01:04.064] Searching for globals ... DONE
[18:01:04.064] - globals: [0] <none>
[18:01:04.064] getGlobalsAndPackages() ... DONE
[18:01:04.065]    + additional globals found: [n=0] 
[18:01:04.065]    + additional namespaces needed: [n=0] 
[18:01:04.065]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:04.065]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:04.066]  - seeds: <none>
[18:01:04.066]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:04.066] getGlobalsAndPackages() ...
[18:01:04.067] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:04.067] Resolving globals: FALSE
[18:01:04.069] The total size of the 5 globals is 904 bytes (904 bytes)
[18:01:04.071] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:04.071] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:04.071] 
[18:01:04.072] getGlobalsAndPackages() ... DONE
[18:01:04.073] run() for ‘Future’ ...
[18:01:04.073] - state: ‘created’
[18:01:04.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:04.090] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:04.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:04.091]   - Field: ‘label’
[18:01:04.092]   - Field: ‘local’
[18:01:04.092]   - Field: ‘owner’
[18:01:04.093]   - Field: ‘envir’
[18:01:04.093]   - Field: ‘workers’
[18:01:04.094]   - Field: ‘packages’
[18:01:04.095]   - Field: ‘gc’
[18:01:04.095]   - Field: ‘job’
[18:01:04.096]   - Field: ‘conditions’
[18:01:04.096]   - Field: ‘expr’
[18:01:04.097]   - Field: ‘uuid’
[18:01:04.097]   - Field: ‘seed’
[18:01:04.098]   - Field: ‘version’
[18:01:04.098]   - Field: ‘result’
[18:01:04.099]   - Field: ‘asynchronous’
[18:01:04.099]   - Field: ‘calls’
[18:01:04.099]   - Field: ‘globals’
[18:01:04.100]   - Field: ‘stdout’
[18:01:04.100]   - Field: ‘earlySignal’
[18:01:04.101]   - Field: ‘lazy’
[18:01:04.101]   - Field: ‘state’
[18:01:04.101] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:04.102] - Launch lazy future ...
[18:01:04.103] Packages needed by the future expression (n = 0): <none>
[18:01:04.103] Packages needed by future strategies (n = 0): <none>
[18:01:04.105] {
[18:01:04.105]     {
[18:01:04.105]         {
[18:01:04.105]             ...future.startTime <- base::Sys.time()
[18:01:04.105]             {
[18:01:04.105]                 {
[18:01:04.105]                   {
[18:01:04.105]                     {
[18:01:04.105]                       base::local({
[18:01:04.105]                         has_future <- base::requireNamespace("future", 
[18:01:04.105]                           quietly = TRUE)
[18:01:04.105]                         if (has_future) {
[18:01:04.105]                           ns <- base::getNamespace("future")
[18:01:04.105]                           version <- ns[[".package"]][["version"]]
[18:01:04.105]                           if (is.null(version)) 
[18:01:04.105]                             version <- utils::packageVersion("future")
[18:01:04.105]                         }
[18:01:04.105]                         else {
[18:01:04.105]                           version <- NULL
[18:01:04.105]                         }
[18:01:04.105]                         if (!has_future || version < "1.8.0") {
[18:01:04.105]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:04.105]                             "", base::R.version$version.string), 
[18:01:04.105]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:04.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:04.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:04.105]                               "release", "version")], collapse = " "), 
[18:01:04.105]                             hostname = base::Sys.info()[["nodename"]])
[18:01:04.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:04.105]                             info)
[18:01:04.105]                           info <- base::paste(info, collapse = "; ")
[18:01:04.105]                           if (!has_future) {
[18:01:04.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:04.105]                               info)
[18:01:04.105]                           }
[18:01:04.105]                           else {
[18:01:04.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:04.105]                               info, version)
[18:01:04.105]                           }
[18:01:04.105]                           base::stop(msg)
[18:01:04.105]                         }
[18:01:04.105]                       })
[18:01:04.105]                     }
[18:01:04.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:04.105]                     base::options(mc.cores = 1L)
[18:01:04.105]                   }
[18:01:04.105]                   ...future.strategy.old <- future::plan("list")
[18:01:04.105]                   options(future.plan = NULL)
[18:01:04.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:04.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:04.105]                 }
[18:01:04.105]                 ...future.workdir <- getwd()
[18:01:04.105]             }
[18:01:04.105]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:04.105]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:04.105]         }
[18:01:04.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:04.105]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:04.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:04.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:04.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:04.105]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:04.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:04.105]             base::names(...future.oldOptions))
[18:01:04.105]     }
[18:01:04.105]     if (FALSE) {
[18:01:04.105]     }
[18:01:04.105]     else {
[18:01:04.105]         if (TRUE) {
[18:01:04.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:04.105]                 open = "w")
[18:01:04.105]         }
[18:01:04.105]         else {
[18:01:04.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:04.105]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:04.105]         }
[18:01:04.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:04.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:04.105]             base::sink(type = "output", split = FALSE)
[18:01:04.105]             base::close(...future.stdout)
[18:01:04.105]         }, add = TRUE)
[18:01:04.105]     }
[18:01:04.105]     ...future.frame <- base::sys.nframe()
[18:01:04.105]     ...future.conditions <- base::list()
[18:01:04.105]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:04.105]     if (FALSE) {
[18:01:04.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:04.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:04.105]     }
[18:01:04.105]     ...future.result <- base::tryCatch({
[18:01:04.105]         base::withCallingHandlers({
[18:01:04.105]             ...future.value <- base::withVisible(base::local({
[18:01:04.105]                 withCallingHandlers({
[18:01:04.105]                   {
[18:01:04.105]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:04.105]                     if (!identical(...future.globals.maxSize.org, 
[18:01:04.105]                       ...future.globals.maxSize)) {
[18:01:04.105]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:04.105]                       on.exit(options(oopts), add = TRUE)
[18:01:04.105]                     }
[18:01:04.105]                     {
[18:01:04.105]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:04.105]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:04.105]                         USE.NAMES = FALSE)
[18:01:04.105]                       do.call(mapply, args = args)
[18:01:04.105]                     }
[18:01:04.105]                   }
[18:01:04.105]                 }, immediateCondition = function(cond) {
[18:01:04.105]                   save_rds <- function (object, pathname, ...) 
[18:01:04.105]                   {
[18:01:04.105]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:04.105]                     if (file_test("-f", pathname_tmp)) {
[18:01:04.105]                       fi_tmp <- file.info(pathname_tmp)
[18:01:04.105]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:04.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:04.105]                         fi_tmp[["mtime"]])
[18:01:04.105]                     }
[18:01:04.105]                     tryCatch({
[18:01:04.105]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:04.105]                     }, error = function(ex) {
[18:01:04.105]                       msg <- conditionMessage(ex)
[18:01:04.105]                       fi_tmp <- file.info(pathname_tmp)
[18:01:04.105]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:04.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:04.105]                         fi_tmp[["mtime"]], msg)
[18:01:04.105]                       ex$message <- msg
[18:01:04.105]                       stop(ex)
[18:01:04.105]                     })
[18:01:04.105]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:04.105]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:04.105]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:04.105]                       fi_tmp <- file.info(pathname_tmp)
[18:01:04.105]                       fi <- file.info(pathname)
[18:01:04.105]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:04.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:04.105]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:04.105]                         fi[["size"]], fi[["mtime"]])
[18:01:04.105]                       stop(msg)
[18:01:04.105]                     }
[18:01:04.105]                     invisible(pathname)
[18:01:04.105]                   }
[18:01:04.105]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:04.105]                     rootPath = tempdir()) 
[18:01:04.105]                   {
[18:01:04.105]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:04.105]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:04.105]                       tmpdir = path, fileext = ".rds")
[18:01:04.105]                     save_rds(obj, file)
[18:01:04.105]                   }
[18:01:04.105]                   saveImmediateCondition(cond, path = "/tmp/RtmpsHmqlH/.future/immediateConditions")
[18:01:04.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.105]                   {
[18:01:04.105]                     inherits <- base::inherits
[18:01:04.105]                     invokeRestart <- base::invokeRestart
[18:01:04.105]                     is.null <- base::is.null
[18:01:04.105]                     muffled <- FALSE
[18:01:04.105]                     if (inherits(cond, "message")) {
[18:01:04.105]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:04.105]                       if (muffled) 
[18:01:04.105]                         invokeRestart("muffleMessage")
[18:01:04.105]                     }
[18:01:04.105]                     else if (inherits(cond, "warning")) {
[18:01:04.105]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:04.105]                       if (muffled) 
[18:01:04.105]                         invokeRestart("muffleWarning")
[18:01:04.105]                     }
[18:01:04.105]                     else if (inherits(cond, "condition")) {
[18:01:04.105]                       if (!is.null(pattern)) {
[18:01:04.105]                         computeRestarts <- base::computeRestarts
[18:01:04.105]                         grepl <- base::grepl
[18:01:04.105]                         restarts <- computeRestarts(cond)
[18:01:04.105]                         for (restart in restarts) {
[18:01:04.105]                           name <- restart$name
[18:01:04.105]                           if (is.null(name)) 
[18:01:04.105]                             next
[18:01:04.105]                           if (!grepl(pattern, name)) 
[18:01:04.105]                             next
[18:01:04.105]                           invokeRestart(restart)
[18:01:04.105]                           muffled <- TRUE
[18:01:04.105]                           break
[18:01:04.105]                         }
[18:01:04.105]                       }
[18:01:04.105]                     }
[18:01:04.105]                     invisible(muffled)
[18:01:04.105]                   }
[18:01:04.105]                   muffleCondition(cond)
[18:01:04.105]                 })
[18:01:04.105]             }))
[18:01:04.105]             future::FutureResult(value = ...future.value$value, 
[18:01:04.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:04.105]                   ...future.rng), globalenv = if (FALSE) 
[18:01:04.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:04.105]                     ...future.globalenv.names))
[18:01:04.105]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:04.105]         }, condition = base::local({
[18:01:04.105]             c <- base::c
[18:01:04.105]             inherits <- base::inherits
[18:01:04.105]             invokeRestart <- base::invokeRestart
[18:01:04.105]             length <- base::length
[18:01:04.105]             list <- base::list
[18:01:04.105]             seq.int <- base::seq.int
[18:01:04.105]             signalCondition <- base::signalCondition
[18:01:04.105]             sys.calls <- base::sys.calls
[18:01:04.105]             `[[` <- base::`[[`
[18:01:04.105]             `+` <- base::`+`
[18:01:04.105]             `<<-` <- base::`<<-`
[18:01:04.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:04.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:04.105]                   3L)]
[18:01:04.105]             }
[18:01:04.105]             function(cond) {
[18:01:04.105]                 is_error <- inherits(cond, "error")
[18:01:04.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:04.105]                   NULL)
[18:01:04.105]                 if (is_error) {
[18:01:04.105]                   sessionInformation <- function() {
[18:01:04.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:04.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:04.105]                       search = base::search(), system = base::Sys.info())
[18:01:04.105]                   }
[18:01:04.105]                   ...future.conditions[[length(...future.conditions) + 
[18:01:04.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:04.105]                     cond$call), session = sessionInformation(), 
[18:01:04.105]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:04.105]                   signalCondition(cond)
[18:01:04.105]                 }
[18:01:04.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:04.105]                 "immediateCondition"))) {
[18:01:04.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:04.105]                   ...future.conditions[[length(...future.conditions) + 
[18:01:04.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:04.105]                   if (TRUE && !signal) {
[18:01:04.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.105]                     {
[18:01:04.105]                       inherits <- base::inherits
[18:01:04.105]                       invokeRestart <- base::invokeRestart
[18:01:04.105]                       is.null <- base::is.null
[18:01:04.105]                       muffled <- FALSE
[18:01:04.105]                       if (inherits(cond, "message")) {
[18:01:04.105]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:04.105]                         if (muffled) 
[18:01:04.105]                           invokeRestart("muffleMessage")
[18:01:04.105]                       }
[18:01:04.105]                       else if (inherits(cond, "warning")) {
[18:01:04.105]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:04.105]                         if (muffled) 
[18:01:04.105]                           invokeRestart("muffleWarning")
[18:01:04.105]                       }
[18:01:04.105]                       else if (inherits(cond, "condition")) {
[18:01:04.105]                         if (!is.null(pattern)) {
[18:01:04.105]                           computeRestarts <- base::computeRestarts
[18:01:04.105]                           grepl <- base::grepl
[18:01:04.105]                           restarts <- computeRestarts(cond)
[18:01:04.105]                           for (restart in restarts) {
[18:01:04.105]                             name <- restart$name
[18:01:04.105]                             if (is.null(name)) 
[18:01:04.105]                               next
[18:01:04.105]                             if (!grepl(pattern, name)) 
[18:01:04.105]                               next
[18:01:04.105]                             invokeRestart(restart)
[18:01:04.105]                             muffled <- TRUE
[18:01:04.105]                             break
[18:01:04.105]                           }
[18:01:04.105]                         }
[18:01:04.105]                       }
[18:01:04.105]                       invisible(muffled)
[18:01:04.105]                     }
[18:01:04.105]                     muffleCondition(cond, pattern = "^muffle")
[18:01:04.105]                   }
[18:01:04.105]                 }
[18:01:04.105]                 else {
[18:01:04.105]                   if (TRUE) {
[18:01:04.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.105]                     {
[18:01:04.105]                       inherits <- base::inherits
[18:01:04.105]                       invokeRestart <- base::invokeRestart
[18:01:04.105]                       is.null <- base::is.null
[18:01:04.105]                       muffled <- FALSE
[18:01:04.105]                       if (inherits(cond, "message")) {
[18:01:04.105]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:04.105]                         if (muffled) 
[18:01:04.105]                           invokeRestart("muffleMessage")
[18:01:04.105]                       }
[18:01:04.105]                       else if (inherits(cond, "warning")) {
[18:01:04.105]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:04.105]                         if (muffled) 
[18:01:04.105]                           invokeRestart("muffleWarning")
[18:01:04.105]                       }
[18:01:04.105]                       else if (inherits(cond, "condition")) {
[18:01:04.105]                         if (!is.null(pattern)) {
[18:01:04.105]                           computeRestarts <- base::computeRestarts
[18:01:04.105]                           grepl <- base::grepl
[18:01:04.105]                           restarts <- computeRestarts(cond)
[18:01:04.105]                           for (restart in restarts) {
[18:01:04.105]                             name <- restart$name
[18:01:04.105]                             if (is.null(name)) 
[18:01:04.105]                               next
[18:01:04.105]                             if (!grepl(pattern, name)) 
[18:01:04.105]                               next
[18:01:04.105]                             invokeRestart(restart)
[18:01:04.105]                             muffled <- TRUE
[18:01:04.105]                             break
[18:01:04.105]                           }
[18:01:04.105]                         }
[18:01:04.105]                       }
[18:01:04.105]                       invisible(muffled)
[18:01:04.105]                     }
[18:01:04.105]                     muffleCondition(cond, pattern = "^muffle")
[18:01:04.105]                   }
[18:01:04.105]                 }
[18:01:04.105]             }
[18:01:04.105]         }))
[18:01:04.105]     }, error = function(ex) {
[18:01:04.105]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:04.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:04.105]                 ...future.rng), started = ...future.startTime, 
[18:01:04.105]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:04.105]             version = "1.8"), class = "FutureResult")
[18:01:04.105]     }, finally = {
[18:01:04.105]         if (!identical(...future.workdir, getwd())) 
[18:01:04.105]             setwd(...future.workdir)
[18:01:04.105]         {
[18:01:04.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:04.105]                 ...future.oldOptions$nwarnings <- NULL
[18:01:04.105]             }
[18:01:04.105]             base::options(...future.oldOptions)
[18:01:04.105]             if (.Platform$OS.type == "windows") {
[18:01:04.105]                 old_names <- names(...future.oldEnvVars)
[18:01:04.105]                 envs <- base::Sys.getenv()
[18:01:04.105]                 names <- names(envs)
[18:01:04.105]                 common <- intersect(names, old_names)
[18:01:04.105]                 added <- setdiff(names, old_names)
[18:01:04.105]                 removed <- setdiff(old_names, names)
[18:01:04.105]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:04.105]                   envs[common]]
[18:01:04.105]                 NAMES <- toupper(changed)
[18:01:04.105]                 args <- list()
[18:01:04.105]                 for (kk in seq_along(NAMES)) {
[18:01:04.105]                   name <- changed[[kk]]
[18:01:04.105]                   NAME <- NAMES[[kk]]
[18:01:04.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.105]                     next
[18:01:04.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:04.105]                 }
[18:01:04.105]                 NAMES <- toupper(added)
[18:01:04.105]                 for (kk in seq_along(NAMES)) {
[18:01:04.105]                   name <- added[[kk]]
[18:01:04.105]                   NAME <- NAMES[[kk]]
[18:01:04.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.105]                     next
[18:01:04.105]                   args[[name]] <- ""
[18:01:04.105]                 }
[18:01:04.105]                 NAMES <- toupper(removed)
[18:01:04.105]                 for (kk in seq_along(NAMES)) {
[18:01:04.105]                   name <- removed[[kk]]
[18:01:04.105]                   NAME <- NAMES[[kk]]
[18:01:04.105]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.105]                     next
[18:01:04.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:04.105]                 }
[18:01:04.105]                 if (length(args) > 0) 
[18:01:04.105]                   base::do.call(base::Sys.setenv, args = args)
[18:01:04.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:04.105]             }
[18:01:04.105]             else {
[18:01:04.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:04.105]             }
[18:01:04.105]             {
[18:01:04.105]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:04.105]                   0L) {
[18:01:04.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:04.105]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:04.105]                   base::options(opts)
[18:01:04.105]                 }
[18:01:04.105]                 {
[18:01:04.105]                   {
[18:01:04.105]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:04.105]                     NULL
[18:01:04.105]                   }
[18:01:04.105]                   options(future.plan = NULL)
[18:01:04.105]                   if (is.na(NA_character_)) 
[18:01:04.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:04.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:04.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:04.105]                     .init = FALSE)
[18:01:04.105]                 }
[18:01:04.105]             }
[18:01:04.105]         }
[18:01:04.105]     })
[18:01:04.105]     if (TRUE) {
[18:01:04.105]         base::sink(type = "output", split = FALSE)
[18:01:04.105]         if (TRUE) {
[18:01:04.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:04.105]         }
[18:01:04.105]         else {
[18:01:04.105]             ...future.result["stdout"] <- base::list(NULL)
[18:01:04.105]         }
[18:01:04.105]         base::close(...future.stdout)
[18:01:04.105]         ...future.stdout <- NULL
[18:01:04.105]     }
[18:01:04.105]     ...future.result$conditions <- ...future.conditions
[18:01:04.105]     ...future.result$finished <- base::Sys.time()
[18:01:04.105]     ...future.result
[18:01:04.105] }
[18:01:04.111] assign_globals() ...
[18:01:04.111] List of 5
[18:01:04.111]  $ ...future.FUN            :function (x)  
[18:01:04.111]  $ MoreArgs                 : NULL
[18:01:04.111]  $ ...future.elements_ii    :List of 1
[18:01:04.111]   ..$ :List of 1
[18:01:04.111]   .. ..$ b: num 0
[18:01:04.111]  $ ...future.seeds_ii       : NULL
[18:01:04.111]  $ ...future.globals.maxSize: NULL
[18:01:04.111]  - attr(*, "where")=List of 5
[18:01:04.111]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:04.111]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:01:04.111]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:04.111]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:04.111]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:04.111]  - attr(*, "resolved")= logi FALSE
[18:01:04.111]  - attr(*, "total_size")= num 904
[18:01:04.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:04.111]  - attr(*, "already-done")= logi TRUE
[18:01:04.126] - copied ‘...future.FUN’ to environment
[18:01:04.126] - copied ‘MoreArgs’ to environment
[18:01:04.127] - copied ‘...future.elements_ii’ to environment
[18:01:04.127] - copied ‘...future.seeds_ii’ to environment
[18:01:04.127] - copied ‘...future.globals.maxSize’ to environment
[18:01:04.127] assign_globals() ... done
[18:01:04.128] requestCore(): workers = 2
[18:01:04.131] MulticoreFuture started
[18:01:04.132] - Launch lazy future ... done
[18:01:04.133] run() for ‘MulticoreFuture’ ... done
[18:01:04.133] Created future:
[18:01:04.133] plan(): Setting new future strategy stack:
[18:01:04.134] List of future strategies:
[18:01:04.134] 1. sequential:
[18:01:04.134]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:04.134]    - tweaked: FALSE
[18:01:04.134]    - call: NULL
[18:01:04.136] plan(): nbrOfWorkers() = 1
[18:01:04.141] plan(): Setting new future strategy stack:
[18:01:04.141] List of future strategies:
[18:01:04.141] 1. multicore:
[18:01:04.141]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:04.141]    - tweaked: FALSE
[18:01:04.141]    - call: plan(strategy)
[18:01:04.134] MulticoreFuture:
[18:01:04.134] Label: ‘future_mapply-2’
[18:01:04.134] Expression:
[18:01:04.134] {
[18:01:04.134]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:04.134]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:04.134]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:04.134]         on.exit(options(oopts), add = TRUE)
[18:01:04.134]     }
[18:01:04.134]     {
[18:01:04.134]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:04.134]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:04.134]         do.call(mapply, args = args)
[18:01:04.134]     }
[18:01:04.134] }
[18:01:04.134] Lazy evaluation: FALSE
[18:01:04.134] Asynchronous evaluation: TRUE
[18:01:04.134] Local evaluation: TRUE
[18:01:04.134] Environment: R_GlobalEnv
[18:01:04.134] Capture standard output: TRUE
[18:01:04.134] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:04.134] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:04.134] Packages: <none>
[18:01:04.134] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:04.134] Resolved: FALSE
[18:01:04.134] Value: <not collected>
[18:01:04.134] Conditions captured: <none>
[18:01:04.134] Early signaling: FALSE
[18:01:04.134] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:04.134] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:04.149] Chunk #2 of 2 ... DONE
[18:01:04.149] Launching 2 futures (chunks) ... DONE
[18:01:04.149] Resolving 2 futures (chunks) ...
[18:01:04.150] resolve() on list ...
[18:01:04.150]  recursive: 0
[18:01:04.150]  length: 2
[18:01:04.151] 
[18:01:04.151] plan(): nbrOfWorkers() = 2
[18:01:04.151] Future #1
[18:01:04.152] result() for MulticoreFuture ...
[18:01:04.154] result() for MulticoreFuture ...
[18:01:04.156] result() for MulticoreFuture ... done
[18:01:04.156] result() for MulticoreFuture ... done
[18:01:04.157] result() for MulticoreFuture ...
[18:01:04.157] result() for MulticoreFuture ... done
[18:01:04.157] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:04.158] - nx: 2
[18:01:04.159] - relay: TRUE
[18:01:04.160] - stdout: TRUE
[18:01:04.160] - signal: TRUE
[18:01:04.160] - resignal: FALSE
[18:01:04.161] - force: TRUE
[18:01:04.161] - relayed: [n=2] FALSE, FALSE
[18:01:04.161] - queued futures: [n=2] FALSE, FALSE
[18:01:04.162]  - until=1
[18:01:04.162]  - relaying element #1
[18:01:04.162] result() for MulticoreFuture ...
[18:01:04.163] result() for MulticoreFuture ... done
[18:01:04.163] result() for MulticoreFuture ...
[18:01:04.163] result() for MulticoreFuture ... done
[18:01:04.164] result() for MulticoreFuture ...
[18:01:04.164] result() for MulticoreFuture ... done
[18:01:04.164] result() for MulticoreFuture ...
[18:01:04.165] result() for MulticoreFuture ... done
[18:01:04.165] - relayed: [n=2] TRUE, FALSE
[18:01:04.166] - queued futures: [n=2] TRUE, FALSE
[18:01:04.166] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:04.166]  length: 1 (resolved future 1)
[18:01:04.167] Future #2
[18:01:04.168] result() for MulticoreFuture ...
[18:01:04.169] result() for MulticoreFuture ...
[18:01:04.170] result() for MulticoreFuture ... done
[18:01:04.170] result() for MulticoreFuture ... done
[18:01:04.170] result() for MulticoreFuture ...
[18:01:04.173] result() for MulticoreFuture ... done
[18:01:04.173] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:04.174] - nx: 2
[18:01:04.174] - relay: TRUE
[18:01:04.174] - stdout: TRUE
[18:01:04.174] - signal: TRUE
[18:01:04.175] - resignal: FALSE
[18:01:04.176] - force: TRUE
[18:01:04.177] - relayed: [n=2] TRUE, FALSE
[18:01:04.177] - queued futures: [n=2] TRUE, FALSE
[18:01:04.186]  - until=2
[18:01:04.186]  - relaying element #2
[18:01:04.187] result() for MulticoreFuture ...
[18:01:04.187] result() for MulticoreFuture ... done
[18:01:04.187] result() for MulticoreFuture ...
[18:01:04.188] result() for MulticoreFuture ... done
[18:01:04.188] result() for MulticoreFuture ...
[18:01:04.188] result() for MulticoreFuture ... done
[18:01:04.189] result() for MulticoreFuture ...
[18:01:04.189] result() for MulticoreFuture ... done
[18:01:04.189] - relayed: [n=2] TRUE, TRUE
[18:01:04.189] - queued futures: [n=2] TRUE, TRUE
[18:01:04.189] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:04.190]  length: 0 (resolved future 2)
[18:01:04.190] Relaying remaining futures
[18:01:04.190] signalConditionsASAP(NULL, pos=0) ...
[18:01:04.191] - nx: 2
[18:01:04.191] - relay: TRUE
[18:01:04.191] - stdout: TRUE
[18:01:04.191] - signal: TRUE
[18:01:04.192] - resignal: FALSE
[18:01:04.192] - force: TRUE
[18:01:04.192] - relayed: [n=2] TRUE, TRUE
[18:01:04.192] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:04.193] - relayed: [n=2] TRUE, TRUE
[18:01:04.193] - queued futures: [n=2] TRUE, TRUE
[18:01:04.193] signalConditionsASAP(NULL, pos=0) ... done
[18:01:04.194] resolve() on list ... DONE
[18:01:04.194] result() for MulticoreFuture ...
[18:01:04.194] result() for MulticoreFuture ... done
[18:01:04.194] result() for MulticoreFuture ...
[18:01:04.195] result() for MulticoreFuture ... done
[18:01:04.195] result() for MulticoreFuture ...
[18:01:04.195] result() for MulticoreFuture ... done
[18:01:04.196] result() for MulticoreFuture ...
[18:01:04.196] result() for MulticoreFuture ... done
[18:01:04.196]  - Number of value chunks collected: 2
[18:01:04.197] Resolving 2 futures (chunks) ... DONE
[18:01:04.197] Reducing values from 2 chunks ...
[18:01:04.197]  - Number of values collected after concatenation: 2
[18:01:04.197]  - Number of values expected: 2
[18:01:04.197] Reducing values from 2 chunks ... DONE
[18:01:04.198] future_mapply() ... DONE
[18:01:04.198] plan(): Setting new future strategy stack:
[18:01:04.198] List of future strategies:
[18:01:04.198] 1. sequential:
[18:01:04.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:04.198]    - tweaked: FALSE
[18:01:04.198]    - call: plan(sequential)
[18:01:04.200] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[18:01:04.201] plan(): Setting new future strategy stack:
[18:01:04.201] List of future strategies:
[18:01:04.201] 1. multisession:
[18:01:04.201]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:01:04.201]    - tweaked: FALSE
[18:01:04.201]    - call: plan(strategy)
[18:01:04.202] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:01:04.203] multisession:
[18:01:04.203] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:01:04.203] - tweaked: FALSE
[18:01:04.203] - call: plan(strategy)
[18:01:04.214] getGlobalsAndPackages() ...
[18:01:04.215] Not searching for globals
[18:01:04.215] - globals: [0] <none>
[18:01:04.215] getGlobalsAndPackages() ... DONE
[18:01:04.216] [local output] makeClusterPSOCK() ...
[18:01:04.288] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:01:04.290] [local output] Base port: 11049
[18:01:04.290] [local output] Getting setup options for 2 cluster nodes ...
[18:01:04.290] [local output]  - Node 1 of 2 ...
[18:01:04.291] [local output] localMachine=TRUE => revtunnel=FALSE

[18:01:04.293] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsHmqlH/worker.rank=1.parallelly.parent=314103.4caf737760783.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpsHmqlH/worker.rank=1.parallelly.parent=314103.4caf737760783.pid")'’
[18:01:04.559] - Possible to infer worker's PID: TRUE
[18:01:04.559] [local output] Rscript port: 11049

[18:01:04.560] [local output]  - Node 2 of 2 ...
[18:01:04.560] [local output] localMachine=TRUE => revtunnel=FALSE

[18:01:04.562] [local output] Rscript port: 11049

[18:01:04.562] [local output] Getting setup options for 2 cluster nodes ... done
[18:01:04.562] [local output]  - Parallel setup requested for some PSOCK nodes
[18:01:04.563] [local output] Setting up PSOCK nodes in parallel
[18:01:04.564] List of 36
[18:01:04.564]  $ worker          : chr "localhost"
[18:01:04.564]   ..- attr(*, "localhost")= logi TRUE
[18:01:04.564]  $ master          : chr "localhost"
[18:01:04.564]  $ port            : int 11049
[18:01:04.564]  $ connectTimeout  : num 120
[18:01:04.564]  $ timeout         : num 2592000
[18:01:04.564]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:01:04.564]  $ homogeneous     : logi TRUE
[18:01:04.564]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:01:04.564]  $ rscript_envs    : NULL
[18:01:04.564]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:01:04.564]  $ rscript_startup : NULL
[18:01:04.564]  $ rscript_sh      : chr "sh"
[18:01:04.564]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:01:04.564]  $ methods         : logi TRUE
[18:01:04.564]  $ socketOptions   : chr "no-delay"
[18:01:04.564]  $ useXDR          : logi FALSE
[18:01:04.564]  $ outfile         : chr "/dev/null"
[18:01:04.564]  $ renice          : int NA
[18:01:04.564]  $ rshcmd          : NULL
[18:01:04.564]  $ user            : chr(0) 
[18:01:04.564]  $ revtunnel       : logi FALSE
[18:01:04.564]  $ rshlogfile      : NULL
[18:01:04.564]  $ rshopts         : chr(0) 
[18:01:04.564]  $ rank            : int 1
[18:01:04.564]  $ manual          : logi FALSE
[18:01:04.564]  $ dryrun          : logi FALSE
[18:01:04.564]  $ quiet           : logi FALSE
[18:01:04.564]  $ setup_strategy  : chr "parallel"
[18:01:04.564]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:01:04.564]  $ pidfile         : chr "/tmp/RtmpsHmqlH/worker.rank=1.parallelly.parent=314103.4caf737760783.pid"
[18:01:04.564]  $ rshcmd_label    : NULL
[18:01:04.564]  $ rsh_call        : NULL
[18:01:04.564]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:01:04.564]  $ localMachine    : logi TRUE
[18:01:04.564]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:01:04.564]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:01:04.564]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:01:04.564]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:01:04.564]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:01:04.564]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:01:04.564]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:01:04.564]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:01:04.564]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:01:04.564]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:01:04.564]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:01:04.564]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:01:04.564]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:01:04.564]  $ arguments       :List of 28
[18:01:04.564]   ..$ worker          : chr "localhost"
[18:01:04.564]   ..$ master          : NULL
[18:01:04.564]   ..$ port            : int 11049
[18:01:04.564]   ..$ connectTimeout  : num 120
[18:01:04.564]   ..$ timeout         : num 2592000
[18:01:04.564]   ..$ rscript         : NULL
[18:01:04.564]   ..$ homogeneous     : NULL
[18:01:04.564]   ..$ rscript_args    : NULL
[18:01:04.564]   ..$ rscript_envs    : NULL
[18:01:04.564]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:01:04.564]   ..$ rscript_startup : NULL
[18:01:04.564]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:01:04.564]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:01:04.564]   ..$ methods         : logi TRUE
[18:01:04.564]   ..$ socketOptions   : chr "no-delay"
[18:01:04.564]   ..$ useXDR          : logi FALSE
[18:01:04.564]   ..$ outfile         : chr "/dev/null"
[18:01:04.564]   ..$ renice          : int NA
[18:01:04.564]   ..$ rshcmd          : NULL
[18:01:04.564]   ..$ user            : NULL
[18:01:04.564]   ..$ revtunnel       : logi NA
[18:01:04.564]   ..$ rshlogfile      : NULL
[18:01:04.564]   ..$ rshopts         : NULL
[18:01:04.564]   ..$ rank            : int 1
[18:01:04.564]   ..$ manual          : logi FALSE
[18:01:04.564]   ..$ dryrun          : logi FALSE
[18:01:04.564]   ..$ quiet           : logi FALSE
[18:01:04.564]   ..$ setup_strategy  : chr "parallel"
[18:01:04.564]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:01:04.599] [local output] System call to launch all workers:
[18:01:04.600] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsHmqlH/worker.rank=1.parallelly.parent=314103.4caf737760783.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11049 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:01:04.600] [local output] Starting PSOCK main server
[18:01:04.610] [local output] Workers launched
[18:01:04.610] [local output] Waiting for workers to connect back
[18:01:04.610]  - [local output] 0 workers out of 2 ready
[18:01:04.971]  - [local output] 0 workers out of 2 ready
[18:01:04.972]  - [local output] 0 workers out of 2 ready
[18:01:04.972]  - [local output] 1 workers out of 2 ready
[18:01:04.973]  - [local output] 2 workers out of 2 ready
[18:01:04.973] [local output] Launching of workers completed
[18:01:04.973] [local output] Collecting session information from workers
[18:01:04.975] [local output]  - Worker #1 of 2
[18:01:04.976] [local output]  - Worker #2 of 2
[18:01:04.976] [local output] makeClusterPSOCK() ... done
[18:01:04.996] Packages needed by the future expression (n = 0): <none>
[18:01:04.996] Packages needed by future strategies (n = 0): <none>
[18:01:04.997] {
[18:01:04.997]     {
[18:01:04.997]         {
[18:01:04.997]             ...future.startTime <- base::Sys.time()
[18:01:04.997]             {
[18:01:04.997]                 {
[18:01:04.997]                   {
[18:01:04.997]                     {
[18:01:04.997]                       base::local({
[18:01:04.997]                         has_future <- base::requireNamespace("future", 
[18:01:04.997]                           quietly = TRUE)
[18:01:04.997]                         if (has_future) {
[18:01:04.997]                           ns <- base::getNamespace("future")
[18:01:04.997]                           version <- ns[[".package"]][["version"]]
[18:01:04.997]                           if (is.null(version)) 
[18:01:04.997]                             version <- utils::packageVersion("future")
[18:01:04.997]                         }
[18:01:04.997]                         else {
[18:01:04.997]                           version <- NULL
[18:01:04.997]                         }
[18:01:04.997]                         if (!has_future || version < "1.8.0") {
[18:01:04.997]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:04.997]                             "", base::R.version$version.string), 
[18:01:04.997]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:04.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:04.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:04.997]                               "release", "version")], collapse = " "), 
[18:01:04.997]                             hostname = base::Sys.info()[["nodename"]])
[18:01:04.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:04.997]                             info)
[18:01:04.997]                           info <- base::paste(info, collapse = "; ")
[18:01:04.997]                           if (!has_future) {
[18:01:04.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:04.997]                               info)
[18:01:04.997]                           }
[18:01:04.997]                           else {
[18:01:04.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:04.997]                               info, version)
[18:01:04.997]                           }
[18:01:04.997]                           base::stop(msg)
[18:01:04.997]                         }
[18:01:04.997]                       })
[18:01:04.997]                     }
[18:01:04.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:04.997]                     base::options(mc.cores = 1L)
[18:01:04.997]                   }
[18:01:04.997]                   ...future.strategy.old <- future::plan("list")
[18:01:04.997]                   options(future.plan = NULL)
[18:01:04.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:04.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:04.997]                 }
[18:01:04.997]                 ...future.workdir <- getwd()
[18:01:04.997]             }
[18:01:04.997]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:04.997]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:04.997]         }
[18:01:04.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:04.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:04.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:04.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:04.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:04.997]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:04.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:04.997]             base::names(...future.oldOptions))
[18:01:04.997]     }
[18:01:04.997]     if (FALSE) {
[18:01:04.997]     }
[18:01:04.997]     else {
[18:01:04.997]         if (TRUE) {
[18:01:04.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:04.997]                 open = "w")
[18:01:04.997]         }
[18:01:04.997]         else {
[18:01:04.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:04.997]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:04.997]         }
[18:01:04.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:04.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:04.997]             base::sink(type = "output", split = FALSE)
[18:01:04.997]             base::close(...future.stdout)
[18:01:04.997]         }, add = TRUE)
[18:01:04.997]     }
[18:01:04.997]     ...future.frame <- base::sys.nframe()
[18:01:04.997]     ...future.conditions <- base::list()
[18:01:04.997]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:04.997]     if (FALSE) {
[18:01:04.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:04.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:04.997]     }
[18:01:04.997]     ...future.result <- base::tryCatch({
[18:01:04.997]         base::withCallingHandlers({
[18:01:04.997]             ...future.value <- base::withVisible(base::local({
[18:01:04.997]                 ...future.makeSendCondition <- base::local({
[18:01:04.997]                   sendCondition <- NULL
[18:01:04.997]                   function(frame = 1L) {
[18:01:04.997]                     if (is.function(sendCondition)) 
[18:01:04.997]                       return(sendCondition)
[18:01:04.997]                     ns <- getNamespace("parallel")
[18:01:04.997]                     if (exists("sendData", mode = "function", 
[18:01:04.997]                       envir = ns)) {
[18:01:04.997]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:04.997]                         envir = ns)
[18:01:04.997]                       envir <- sys.frame(frame)
[18:01:04.997]                       master <- NULL
[18:01:04.997]                       while (!identical(envir, .GlobalEnv) && 
[18:01:04.997]                         !identical(envir, emptyenv())) {
[18:01:04.997]                         if (exists("master", mode = "list", envir = envir, 
[18:01:04.997]                           inherits = FALSE)) {
[18:01:04.997]                           master <- get("master", mode = "list", 
[18:01:04.997]                             envir = envir, inherits = FALSE)
[18:01:04.997]                           if (inherits(master, c("SOCKnode", 
[18:01:04.997]                             "SOCK0node"))) {
[18:01:04.997]                             sendCondition <<- function(cond) {
[18:01:04.997]                               data <- list(type = "VALUE", value = cond, 
[18:01:04.997]                                 success = TRUE)
[18:01:04.997]                               parallel_sendData(master, data)
[18:01:04.997]                             }
[18:01:04.997]                             return(sendCondition)
[18:01:04.997]                           }
[18:01:04.997]                         }
[18:01:04.997]                         frame <- frame + 1L
[18:01:04.997]                         envir <- sys.frame(frame)
[18:01:04.997]                       }
[18:01:04.997]                     }
[18:01:04.997]                     sendCondition <<- function(cond) NULL
[18:01:04.997]                   }
[18:01:04.997]                 })
[18:01:04.997]                 withCallingHandlers({
[18:01:04.997]                   NA
[18:01:04.997]                 }, immediateCondition = function(cond) {
[18:01:04.997]                   sendCondition <- ...future.makeSendCondition()
[18:01:04.997]                   sendCondition(cond)
[18:01:04.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.997]                   {
[18:01:04.997]                     inherits <- base::inherits
[18:01:04.997]                     invokeRestart <- base::invokeRestart
[18:01:04.997]                     is.null <- base::is.null
[18:01:04.997]                     muffled <- FALSE
[18:01:04.997]                     if (inherits(cond, "message")) {
[18:01:04.997]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:04.997]                       if (muffled) 
[18:01:04.997]                         invokeRestart("muffleMessage")
[18:01:04.997]                     }
[18:01:04.997]                     else if (inherits(cond, "warning")) {
[18:01:04.997]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:04.997]                       if (muffled) 
[18:01:04.997]                         invokeRestart("muffleWarning")
[18:01:04.997]                     }
[18:01:04.997]                     else if (inherits(cond, "condition")) {
[18:01:04.997]                       if (!is.null(pattern)) {
[18:01:04.997]                         computeRestarts <- base::computeRestarts
[18:01:04.997]                         grepl <- base::grepl
[18:01:04.997]                         restarts <- computeRestarts(cond)
[18:01:04.997]                         for (restart in restarts) {
[18:01:04.997]                           name <- restart$name
[18:01:04.997]                           if (is.null(name)) 
[18:01:04.997]                             next
[18:01:04.997]                           if (!grepl(pattern, name)) 
[18:01:04.997]                             next
[18:01:04.997]                           invokeRestart(restart)
[18:01:04.997]                           muffled <- TRUE
[18:01:04.997]                           break
[18:01:04.997]                         }
[18:01:04.997]                       }
[18:01:04.997]                     }
[18:01:04.997]                     invisible(muffled)
[18:01:04.997]                   }
[18:01:04.997]                   muffleCondition(cond)
[18:01:04.997]                 })
[18:01:04.997]             }))
[18:01:04.997]             future::FutureResult(value = ...future.value$value, 
[18:01:04.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:04.997]                   ...future.rng), globalenv = if (FALSE) 
[18:01:04.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:04.997]                     ...future.globalenv.names))
[18:01:04.997]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:04.997]         }, condition = base::local({
[18:01:04.997]             c <- base::c
[18:01:04.997]             inherits <- base::inherits
[18:01:04.997]             invokeRestart <- base::invokeRestart
[18:01:04.997]             length <- base::length
[18:01:04.997]             list <- base::list
[18:01:04.997]             seq.int <- base::seq.int
[18:01:04.997]             signalCondition <- base::signalCondition
[18:01:04.997]             sys.calls <- base::sys.calls
[18:01:04.997]             `[[` <- base::`[[`
[18:01:04.997]             `+` <- base::`+`
[18:01:04.997]             `<<-` <- base::`<<-`
[18:01:04.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:04.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:04.997]                   3L)]
[18:01:04.997]             }
[18:01:04.997]             function(cond) {
[18:01:04.997]                 is_error <- inherits(cond, "error")
[18:01:04.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:04.997]                   NULL)
[18:01:04.997]                 if (is_error) {
[18:01:04.997]                   sessionInformation <- function() {
[18:01:04.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:04.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:04.997]                       search = base::search(), system = base::Sys.info())
[18:01:04.997]                   }
[18:01:04.997]                   ...future.conditions[[length(...future.conditions) + 
[18:01:04.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:04.997]                     cond$call), session = sessionInformation(), 
[18:01:04.997]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:04.997]                   signalCondition(cond)
[18:01:04.997]                 }
[18:01:04.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:04.997]                 "immediateCondition"))) {
[18:01:04.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:04.997]                   ...future.conditions[[length(...future.conditions) + 
[18:01:04.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:04.997]                   if (TRUE && !signal) {
[18:01:04.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.997]                     {
[18:01:04.997]                       inherits <- base::inherits
[18:01:04.997]                       invokeRestart <- base::invokeRestart
[18:01:04.997]                       is.null <- base::is.null
[18:01:04.997]                       muffled <- FALSE
[18:01:04.997]                       if (inherits(cond, "message")) {
[18:01:04.997]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:04.997]                         if (muffled) 
[18:01:04.997]                           invokeRestart("muffleMessage")
[18:01:04.997]                       }
[18:01:04.997]                       else if (inherits(cond, "warning")) {
[18:01:04.997]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:04.997]                         if (muffled) 
[18:01:04.997]                           invokeRestart("muffleWarning")
[18:01:04.997]                       }
[18:01:04.997]                       else if (inherits(cond, "condition")) {
[18:01:04.997]                         if (!is.null(pattern)) {
[18:01:04.997]                           computeRestarts <- base::computeRestarts
[18:01:04.997]                           grepl <- base::grepl
[18:01:04.997]                           restarts <- computeRestarts(cond)
[18:01:04.997]                           for (restart in restarts) {
[18:01:04.997]                             name <- restart$name
[18:01:04.997]                             if (is.null(name)) 
[18:01:04.997]                               next
[18:01:04.997]                             if (!grepl(pattern, name)) 
[18:01:04.997]                               next
[18:01:04.997]                             invokeRestart(restart)
[18:01:04.997]                             muffled <- TRUE
[18:01:04.997]                             break
[18:01:04.997]                           }
[18:01:04.997]                         }
[18:01:04.997]                       }
[18:01:04.997]                       invisible(muffled)
[18:01:04.997]                     }
[18:01:04.997]                     muffleCondition(cond, pattern = "^muffle")
[18:01:04.997]                   }
[18:01:04.997]                 }
[18:01:04.997]                 else {
[18:01:04.997]                   if (TRUE) {
[18:01:04.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:04.997]                     {
[18:01:04.997]                       inherits <- base::inherits
[18:01:04.997]                       invokeRestart <- base::invokeRestart
[18:01:04.997]                       is.null <- base::is.null
[18:01:04.997]                       muffled <- FALSE
[18:01:04.997]                       if (inherits(cond, "message")) {
[18:01:04.997]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:04.997]                         if (muffled) 
[18:01:04.997]                           invokeRestart("muffleMessage")
[18:01:04.997]                       }
[18:01:04.997]                       else if (inherits(cond, "warning")) {
[18:01:04.997]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:04.997]                         if (muffled) 
[18:01:04.997]                           invokeRestart("muffleWarning")
[18:01:04.997]                       }
[18:01:04.997]                       else if (inherits(cond, "condition")) {
[18:01:04.997]                         if (!is.null(pattern)) {
[18:01:04.997]                           computeRestarts <- base::computeRestarts
[18:01:04.997]                           grepl <- base::grepl
[18:01:04.997]                           restarts <- computeRestarts(cond)
[18:01:04.997]                           for (restart in restarts) {
[18:01:04.997]                             name <- restart$name
[18:01:04.997]                             if (is.null(name)) 
[18:01:04.997]                               next
[18:01:04.997]                             if (!grepl(pattern, name)) 
[18:01:04.997]                               next
[18:01:04.997]                             invokeRestart(restart)
[18:01:04.997]                             muffled <- TRUE
[18:01:04.997]                             break
[18:01:04.997]                           }
[18:01:04.997]                         }
[18:01:04.997]                       }
[18:01:04.997]                       invisible(muffled)
[18:01:04.997]                     }
[18:01:04.997]                     muffleCondition(cond, pattern = "^muffle")
[18:01:04.997]                   }
[18:01:04.997]                 }
[18:01:04.997]             }
[18:01:04.997]         }))
[18:01:04.997]     }, error = function(ex) {
[18:01:04.997]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:04.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:04.997]                 ...future.rng), started = ...future.startTime, 
[18:01:04.997]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:04.997]             version = "1.8"), class = "FutureResult")
[18:01:04.997]     }, finally = {
[18:01:04.997]         if (!identical(...future.workdir, getwd())) 
[18:01:04.997]             setwd(...future.workdir)
[18:01:04.997]         {
[18:01:04.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:04.997]                 ...future.oldOptions$nwarnings <- NULL
[18:01:04.997]             }
[18:01:04.997]             base::options(...future.oldOptions)
[18:01:04.997]             if (.Platform$OS.type == "windows") {
[18:01:04.997]                 old_names <- names(...future.oldEnvVars)
[18:01:04.997]                 envs <- base::Sys.getenv()
[18:01:04.997]                 names <- names(envs)
[18:01:04.997]                 common <- intersect(names, old_names)
[18:01:04.997]                 added <- setdiff(names, old_names)
[18:01:04.997]                 removed <- setdiff(old_names, names)
[18:01:04.997]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:04.997]                   envs[common]]
[18:01:04.997]                 NAMES <- toupper(changed)
[18:01:04.997]                 args <- list()
[18:01:04.997]                 for (kk in seq_along(NAMES)) {
[18:01:04.997]                   name <- changed[[kk]]
[18:01:04.997]                   NAME <- NAMES[[kk]]
[18:01:04.997]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.997]                     next
[18:01:04.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:04.997]                 }
[18:01:04.997]                 NAMES <- toupper(added)
[18:01:04.997]                 for (kk in seq_along(NAMES)) {
[18:01:04.997]                   name <- added[[kk]]
[18:01:04.997]                   NAME <- NAMES[[kk]]
[18:01:04.997]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.997]                     next
[18:01:04.997]                   args[[name]] <- ""
[18:01:04.997]                 }
[18:01:04.997]                 NAMES <- toupper(removed)
[18:01:04.997]                 for (kk in seq_along(NAMES)) {
[18:01:04.997]                   name <- removed[[kk]]
[18:01:04.997]                   NAME <- NAMES[[kk]]
[18:01:04.997]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:04.997]                     next
[18:01:04.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:04.997]                 }
[18:01:04.997]                 if (length(args) > 0) 
[18:01:04.997]                   base::do.call(base::Sys.setenv, args = args)
[18:01:04.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:04.997]             }
[18:01:04.997]             else {
[18:01:04.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:04.997]             }
[18:01:04.997]             {
[18:01:04.997]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:04.997]                   0L) {
[18:01:04.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:04.997]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:04.997]                   base::options(opts)
[18:01:04.997]                 }
[18:01:04.997]                 {
[18:01:04.997]                   {
[18:01:04.997]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:04.997]                     NULL
[18:01:04.997]                   }
[18:01:04.997]                   options(future.plan = NULL)
[18:01:04.997]                   if (is.na(NA_character_)) 
[18:01:04.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:04.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:04.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:04.997]                     .init = FALSE)
[18:01:04.997]                 }
[18:01:04.997]             }
[18:01:04.997]         }
[18:01:04.997]     })
[18:01:04.997]     if (TRUE) {
[18:01:04.997]         base::sink(type = "output", split = FALSE)
[18:01:04.997]         if (TRUE) {
[18:01:04.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:04.997]         }
[18:01:04.997]         else {
[18:01:04.997]             ...future.result["stdout"] <- base::list(NULL)
[18:01:04.997]         }
[18:01:04.997]         base::close(...future.stdout)
[18:01:04.997]         ...future.stdout <- NULL
[18:01:04.997]     }
[18:01:04.997]     ...future.result$conditions <- ...future.conditions
[18:01:04.997]     ...future.result$finished <- base::Sys.time()
[18:01:04.997]     ...future.result
[18:01:04.997] }
[18:01:05.099] MultisessionFuture started
[18:01:05.099] result() for ClusterFuture ...
[18:01:05.100] receiveMessageFromWorker() for ClusterFuture ...
[18:01:05.100] - Validating connection of MultisessionFuture
[18:01:05.163] - received message: FutureResult
[18:01:05.163] - Received FutureResult
[18:01:05.164] - Erased future from FutureRegistry
[18:01:05.164] result() for ClusterFuture ...
[18:01:05.164] - result already collected: FutureResult
[18:01:05.165] result() for ClusterFuture ... done
[18:01:05.165] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:05.165] result() for ClusterFuture ... done
[18:01:05.166] result() for ClusterFuture ...
[18:01:05.166] - result already collected: FutureResult
[18:01:05.166] result() for ClusterFuture ... done
[18:01:05.167] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:01:05.174] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[18:01:05.175] future_mapply() ...
[18:01:05.181] Number of chunks: 2
[18:01:05.182] getGlobalsAndPackagesXApply() ...
[18:01:05.182]  - future.globals: TRUE
[18:01:05.182] getGlobalsAndPackages() ...
[18:01:05.182] Searching for globals...
[18:01:05.183] - globals found: [1] ‘FUN’
[18:01:05.184] Searching for globals ... DONE
[18:01:05.184] Resolving globals: FALSE
[18:01:05.185] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:05.185] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:05.186] - globals: [1] ‘FUN’
[18:01:05.186] 
[18:01:05.186] getGlobalsAndPackages() ... DONE
[18:01:05.186]  - globals found/used: [n=1] ‘FUN’
[18:01:05.186]  - needed namespaces: [n=0] 
[18:01:05.187] Finding globals ... DONE
[18:01:05.187] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:05.187] List of 2
[18:01:05.187]  $ ...future.FUN:function (x, ...)  
[18:01:05.187]  $ MoreArgs     : NULL
[18:01:05.187]  - attr(*, "where")=List of 2
[18:01:05.187]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:05.187]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:05.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:05.187]  - attr(*, "resolved")= logi FALSE
[18:01:05.187]  - attr(*, "total_size")= num NA
[18:01:05.193] Packages to be attached in all futures: [n=0] 
[18:01:05.194] getGlobalsAndPackagesXApply() ... DONE
[18:01:05.194] Number of futures (= number of chunks): 2
[18:01:05.194] Launching 2 futures (chunks) ...
[18:01:05.194] Chunk #1 of 2 ...
[18:01:05.195]  - Finding globals in '...' for chunk #1 ...
[18:01:05.195] getGlobalsAndPackages() ...
[18:01:05.195] Searching for globals...
[18:01:05.196] 
[18:01:05.196] Searching for globals ... DONE
[18:01:05.197] - globals: [0] <none>
[18:01:05.197] getGlobalsAndPackages() ... DONE
[18:01:05.197]    + additional globals found: [n=0] 
[18:01:05.197]    + additional namespaces needed: [n=0] 
[18:01:05.197]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:05.198]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:05.198]  - seeds: <none>
[18:01:05.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.198] getGlobalsAndPackages() ...
[18:01:05.199] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.199] Resolving globals: FALSE
[18:01:05.200] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:05.201] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:05.201] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.202] 
[18:01:05.202] getGlobalsAndPackages() ... DONE
[18:01:05.202] run() for ‘Future’ ...
[18:01:05.203] - state: ‘created’
[18:01:05.203] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:05.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:05.229]   - Field: ‘node’
[18:01:05.229]   - Field: ‘label’
[18:01:05.229]   - Field: ‘local’
[18:01:05.229]   - Field: ‘owner’
[18:01:05.230]   - Field: ‘envir’
[18:01:05.230]   - Field: ‘workers’
[18:01:05.230]   - Field: ‘packages’
[18:01:05.230]   - Field: ‘gc’
[18:01:05.230]   - Field: ‘conditions’
[18:01:05.231]   - Field: ‘persistent’
[18:01:05.231]   - Field: ‘expr’
[18:01:05.231]   - Field: ‘uuid’
[18:01:05.231]   - Field: ‘seed’
[18:01:05.232]   - Field: ‘version’
[18:01:05.232]   - Field: ‘result’
[18:01:05.232]   - Field: ‘asynchronous’
[18:01:05.232]   - Field: ‘calls’
[18:01:05.233]   - Field: ‘globals’
[18:01:05.233]   - Field: ‘stdout’
[18:01:05.233]   - Field: ‘earlySignal’
[18:01:05.233]   - Field: ‘lazy’
[18:01:05.233]   - Field: ‘state’
[18:01:05.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:05.234] - Launch lazy future ...
[18:01:05.235] Packages needed by the future expression (n = 0): <none>
[18:01:05.235] Packages needed by future strategies (n = 0): <none>
[18:01:05.236] {
[18:01:05.236]     {
[18:01:05.236]         {
[18:01:05.236]             ...future.startTime <- base::Sys.time()
[18:01:05.236]             {
[18:01:05.236]                 {
[18:01:05.236]                   {
[18:01:05.236]                     {
[18:01:05.236]                       base::local({
[18:01:05.236]                         has_future <- base::requireNamespace("future", 
[18:01:05.236]                           quietly = TRUE)
[18:01:05.236]                         if (has_future) {
[18:01:05.236]                           ns <- base::getNamespace("future")
[18:01:05.236]                           version <- ns[[".package"]][["version"]]
[18:01:05.236]                           if (is.null(version)) 
[18:01:05.236]                             version <- utils::packageVersion("future")
[18:01:05.236]                         }
[18:01:05.236]                         else {
[18:01:05.236]                           version <- NULL
[18:01:05.236]                         }
[18:01:05.236]                         if (!has_future || version < "1.8.0") {
[18:01:05.236]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:05.236]                             "", base::R.version$version.string), 
[18:01:05.236]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:05.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:05.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:05.236]                               "release", "version")], collapse = " "), 
[18:01:05.236]                             hostname = base::Sys.info()[["nodename"]])
[18:01:05.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:05.236]                             info)
[18:01:05.236]                           info <- base::paste(info, collapse = "; ")
[18:01:05.236]                           if (!has_future) {
[18:01:05.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:05.236]                               info)
[18:01:05.236]                           }
[18:01:05.236]                           else {
[18:01:05.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:05.236]                               info, version)
[18:01:05.236]                           }
[18:01:05.236]                           base::stop(msg)
[18:01:05.236]                         }
[18:01:05.236]                       })
[18:01:05.236]                     }
[18:01:05.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:05.236]                     base::options(mc.cores = 1L)
[18:01:05.236]                   }
[18:01:05.236]                   ...future.strategy.old <- future::plan("list")
[18:01:05.236]                   options(future.plan = NULL)
[18:01:05.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:05.236]                 }
[18:01:05.236]                 ...future.workdir <- getwd()
[18:01:05.236]             }
[18:01:05.236]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:05.236]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:05.236]         }
[18:01:05.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:05.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:05.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:05.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:05.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:05.236]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:05.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:05.236]             base::names(...future.oldOptions))
[18:01:05.236]     }
[18:01:05.236]     if (FALSE) {
[18:01:05.236]     }
[18:01:05.236]     else {
[18:01:05.236]         if (TRUE) {
[18:01:05.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:05.236]                 open = "w")
[18:01:05.236]         }
[18:01:05.236]         else {
[18:01:05.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:05.236]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:05.236]         }
[18:01:05.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:05.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:05.236]             base::sink(type = "output", split = FALSE)
[18:01:05.236]             base::close(...future.stdout)
[18:01:05.236]         }, add = TRUE)
[18:01:05.236]     }
[18:01:05.236]     ...future.frame <- base::sys.nframe()
[18:01:05.236]     ...future.conditions <- base::list()
[18:01:05.236]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:05.236]     if (FALSE) {
[18:01:05.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:05.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:05.236]     }
[18:01:05.236]     ...future.result <- base::tryCatch({
[18:01:05.236]         base::withCallingHandlers({
[18:01:05.236]             ...future.value <- base::withVisible(base::local({
[18:01:05.236]                 ...future.makeSendCondition <- base::local({
[18:01:05.236]                   sendCondition <- NULL
[18:01:05.236]                   function(frame = 1L) {
[18:01:05.236]                     if (is.function(sendCondition)) 
[18:01:05.236]                       return(sendCondition)
[18:01:05.236]                     ns <- getNamespace("parallel")
[18:01:05.236]                     if (exists("sendData", mode = "function", 
[18:01:05.236]                       envir = ns)) {
[18:01:05.236]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:05.236]                         envir = ns)
[18:01:05.236]                       envir <- sys.frame(frame)
[18:01:05.236]                       master <- NULL
[18:01:05.236]                       while (!identical(envir, .GlobalEnv) && 
[18:01:05.236]                         !identical(envir, emptyenv())) {
[18:01:05.236]                         if (exists("master", mode = "list", envir = envir, 
[18:01:05.236]                           inherits = FALSE)) {
[18:01:05.236]                           master <- get("master", mode = "list", 
[18:01:05.236]                             envir = envir, inherits = FALSE)
[18:01:05.236]                           if (inherits(master, c("SOCKnode", 
[18:01:05.236]                             "SOCK0node"))) {
[18:01:05.236]                             sendCondition <<- function(cond) {
[18:01:05.236]                               data <- list(type = "VALUE", value = cond, 
[18:01:05.236]                                 success = TRUE)
[18:01:05.236]                               parallel_sendData(master, data)
[18:01:05.236]                             }
[18:01:05.236]                             return(sendCondition)
[18:01:05.236]                           }
[18:01:05.236]                         }
[18:01:05.236]                         frame <- frame + 1L
[18:01:05.236]                         envir <- sys.frame(frame)
[18:01:05.236]                       }
[18:01:05.236]                     }
[18:01:05.236]                     sendCondition <<- function(cond) NULL
[18:01:05.236]                   }
[18:01:05.236]                 })
[18:01:05.236]                 withCallingHandlers({
[18:01:05.236]                   {
[18:01:05.236]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.236]                     if (!identical(...future.globals.maxSize.org, 
[18:01:05.236]                       ...future.globals.maxSize)) {
[18:01:05.236]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.236]                       on.exit(options(oopts), add = TRUE)
[18:01:05.236]                     }
[18:01:05.236]                     {
[18:01:05.236]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.236]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:05.236]                         USE.NAMES = FALSE)
[18:01:05.236]                       do.call(mapply, args = args)
[18:01:05.236]                     }
[18:01:05.236]                   }
[18:01:05.236]                 }, immediateCondition = function(cond) {
[18:01:05.236]                   sendCondition <- ...future.makeSendCondition()
[18:01:05.236]                   sendCondition(cond)
[18:01:05.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.236]                   {
[18:01:05.236]                     inherits <- base::inherits
[18:01:05.236]                     invokeRestart <- base::invokeRestart
[18:01:05.236]                     is.null <- base::is.null
[18:01:05.236]                     muffled <- FALSE
[18:01:05.236]                     if (inherits(cond, "message")) {
[18:01:05.236]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:05.236]                       if (muffled) 
[18:01:05.236]                         invokeRestart("muffleMessage")
[18:01:05.236]                     }
[18:01:05.236]                     else if (inherits(cond, "warning")) {
[18:01:05.236]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:05.236]                       if (muffled) 
[18:01:05.236]                         invokeRestart("muffleWarning")
[18:01:05.236]                     }
[18:01:05.236]                     else if (inherits(cond, "condition")) {
[18:01:05.236]                       if (!is.null(pattern)) {
[18:01:05.236]                         computeRestarts <- base::computeRestarts
[18:01:05.236]                         grepl <- base::grepl
[18:01:05.236]                         restarts <- computeRestarts(cond)
[18:01:05.236]                         for (restart in restarts) {
[18:01:05.236]                           name <- restart$name
[18:01:05.236]                           if (is.null(name)) 
[18:01:05.236]                             next
[18:01:05.236]                           if (!grepl(pattern, name)) 
[18:01:05.236]                             next
[18:01:05.236]                           invokeRestart(restart)
[18:01:05.236]                           muffled <- TRUE
[18:01:05.236]                           break
[18:01:05.236]                         }
[18:01:05.236]                       }
[18:01:05.236]                     }
[18:01:05.236]                     invisible(muffled)
[18:01:05.236]                   }
[18:01:05.236]                   muffleCondition(cond)
[18:01:05.236]                 })
[18:01:05.236]             }))
[18:01:05.236]             future::FutureResult(value = ...future.value$value, 
[18:01:05.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.236]                   ...future.rng), globalenv = if (FALSE) 
[18:01:05.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:05.236]                     ...future.globalenv.names))
[18:01:05.236]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:05.236]         }, condition = base::local({
[18:01:05.236]             c <- base::c
[18:01:05.236]             inherits <- base::inherits
[18:01:05.236]             invokeRestart <- base::invokeRestart
[18:01:05.236]             length <- base::length
[18:01:05.236]             list <- base::list
[18:01:05.236]             seq.int <- base::seq.int
[18:01:05.236]             signalCondition <- base::signalCondition
[18:01:05.236]             sys.calls <- base::sys.calls
[18:01:05.236]             `[[` <- base::`[[`
[18:01:05.236]             `+` <- base::`+`
[18:01:05.236]             `<<-` <- base::`<<-`
[18:01:05.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:05.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:05.236]                   3L)]
[18:01:05.236]             }
[18:01:05.236]             function(cond) {
[18:01:05.236]                 is_error <- inherits(cond, "error")
[18:01:05.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:05.236]                   NULL)
[18:01:05.236]                 if (is_error) {
[18:01:05.236]                   sessionInformation <- function() {
[18:01:05.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:05.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:05.236]                       search = base::search(), system = base::Sys.info())
[18:01:05.236]                   }
[18:01:05.236]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:05.236]                     cond$call), session = sessionInformation(), 
[18:01:05.236]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:05.236]                   signalCondition(cond)
[18:01:05.236]                 }
[18:01:05.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:05.236]                 "immediateCondition"))) {
[18:01:05.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:05.236]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:05.236]                   if (TRUE && !signal) {
[18:01:05.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.236]                     {
[18:01:05.236]                       inherits <- base::inherits
[18:01:05.236]                       invokeRestart <- base::invokeRestart
[18:01:05.236]                       is.null <- base::is.null
[18:01:05.236]                       muffled <- FALSE
[18:01:05.236]                       if (inherits(cond, "message")) {
[18:01:05.236]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.236]                         if (muffled) 
[18:01:05.236]                           invokeRestart("muffleMessage")
[18:01:05.236]                       }
[18:01:05.236]                       else if (inherits(cond, "warning")) {
[18:01:05.236]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.236]                         if (muffled) 
[18:01:05.236]                           invokeRestart("muffleWarning")
[18:01:05.236]                       }
[18:01:05.236]                       else if (inherits(cond, "condition")) {
[18:01:05.236]                         if (!is.null(pattern)) {
[18:01:05.236]                           computeRestarts <- base::computeRestarts
[18:01:05.236]                           grepl <- base::grepl
[18:01:05.236]                           restarts <- computeRestarts(cond)
[18:01:05.236]                           for (restart in restarts) {
[18:01:05.236]                             name <- restart$name
[18:01:05.236]                             if (is.null(name)) 
[18:01:05.236]                               next
[18:01:05.236]                             if (!grepl(pattern, name)) 
[18:01:05.236]                               next
[18:01:05.236]                             invokeRestart(restart)
[18:01:05.236]                             muffled <- TRUE
[18:01:05.236]                             break
[18:01:05.236]                           }
[18:01:05.236]                         }
[18:01:05.236]                       }
[18:01:05.236]                       invisible(muffled)
[18:01:05.236]                     }
[18:01:05.236]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.236]                   }
[18:01:05.236]                 }
[18:01:05.236]                 else {
[18:01:05.236]                   if (TRUE) {
[18:01:05.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.236]                     {
[18:01:05.236]                       inherits <- base::inherits
[18:01:05.236]                       invokeRestart <- base::invokeRestart
[18:01:05.236]                       is.null <- base::is.null
[18:01:05.236]                       muffled <- FALSE
[18:01:05.236]                       if (inherits(cond, "message")) {
[18:01:05.236]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.236]                         if (muffled) 
[18:01:05.236]                           invokeRestart("muffleMessage")
[18:01:05.236]                       }
[18:01:05.236]                       else if (inherits(cond, "warning")) {
[18:01:05.236]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.236]                         if (muffled) 
[18:01:05.236]                           invokeRestart("muffleWarning")
[18:01:05.236]                       }
[18:01:05.236]                       else if (inherits(cond, "condition")) {
[18:01:05.236]                         if (!is.null(pattern)) {
[18:01:05.236]                           computeRestarts <- base::computeRestarts
[18:01:05.236]                           grepl <- base::grepl
[18:01:05.236]                           restarts <- computeRestarts(cond)
[18:01:05.236]                           for (restart in restarts) {
[18:01:05.236]                             name <- restart$name
[18:01:05.236]                             if (is.null(name)) 
[18:01:05.236]                               next
[18:01:05.236]                             if (!grepl(pattern, name)) 
[18:01:05.236]                               next
[18:01:05.236]                             invokeRestart(restart)
[18:01:05.236]                             muffled <- TRUE
[18:01:05.236]                             break
[18:01:05.236]                           }
[18:01:05.236]                         }
[18:01:05.236]                       }
[18:01:05.236]                       invisible(muffled)
[18:01:05.236]                     }
[18:01:05.236]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.236]                   }
[18:01:05.236]                 }
[18:01:05.236]             }
[18:01:05.236]         }))
[18:01:05.236]     }, error = function(ex) {
[18:01:05.236]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:05.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.236]                 ...future.rng), started = ...future.startTime, 
[18:01:05.236]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:05.236]             version = "1.8"), class = "FutureResult")
[18:01:05.236]     }, finally = {
[18:01:05.236]         if (!identical(...future.workdir, getwd())) 
[18:01:05.236]             setwd(...future.workdir)
[18:01:05.236]         {
[18:01:05.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:05.236]                 ...future.oldOptions$nwarnings <- NULL
[18:01:05.236]             }
[18:01:05.236]             base::options(...future.oldOptions)
[18:01:05.236]             if (.Platform$OS.type == "windows") {
[18:01:05.236]                 old_names <- names(...future.oldEnvVars)
[18:01:05.236]                 envs <- base::Sys.getenv()
[18:01:05.236]                 names <- names(envs)
[18:01:05.236]                 common <- intersect(names, old_names)
[18:01:05.236]                 added <- setdiff(names, old_names)
[18:01:05.236]                 removed <- setdiff(old_names, names)
[18:01:05.236]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:05.236]                   envs[common]]
[18:01:05.236]                 NAMES <- toupper(changed)
[18:01:05.236]                 args <- list()
[18:01:05.236]                 for (kk in seq_along(NAMES)) {
[18:01:05.236]                   name <- changed[[kk]]
[18:01:05.236]                   NAME <- NAMES[[kk]]
[18:01:05.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.236]                     next
[18:01:05.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.236]                 }
[18:01:05.236]                 NAMES <- toupper(added)
[18:01:05.236]                 for (kk in seq_along(NAMES)) {
[18:01:05.236]                   name <- added[[kk]]
[18:01:05.236]                   NAME <- NAMES[[kk]]
[18:01:05.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.236]                     next
[18:01:05.236]                   args[[name]] <- ""
[18:01:05.236]                 }
[18:01:05.236]                 NAMES <- toupper(removed)
[18:01:05.236]                 for (kk in seq_along(NAMES)) {
[18:01:05.236]                   name <- removed[[kk]]
[18:01:05.236]                   NAME <- NAMES[[kk]]
[18:01:05.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.236]                     next
[18:01:05.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.236]                 }
[18:01:05.236]                 if (length(args) > 0) 
[18:01:05.236]                   base::do.call(base::Sys.setenv, args = args)
[18:01:05.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:05.236]             }
[18:01:05.236]             else {
[18:01:05.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:05.236]             }
[18:01:05.236]             {
[18:01:05.236]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:05.236]                   0L) {
[18:01:05.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:05.236]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:05.236]                   base::options(opts)
[18:01:05.236]                 }
[18:01:05.236]                 {
[18:01:05.236]                   {
[18:01:05.236]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:05.236]                     NULL
[18:01:05.236]                   }
[18:01:05.236]                   options(future.plan = NULL)
[18:01:05.236]                   if (is.na(NA_character_)) 
[18:01:05.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:05.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:05.236]                     .init = FALSE)
[18:01:05.236]                 }
[18:01:05.236]             }
[18:01:05.236]         }
[18:01:05.236]     })
[18:01:05.236]     if (TRUE) {
[18:01:05.236]         base::sink(type = "output", split = FALSE)
[18:01:05.236]         if (TRUE) {
[18:01:05.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:05.236]         }
[18:01:05.236]         else {
[18:01:05.236]             ...future.result["stdout"] <- base::list(NULL)
[18:01:05.236]         }
[18:01:05.236]         base::close(...future.stdout)
[18:01:05.236]         ...future.stdout <- NULL
[18:01:05.236]     }
[18:01:05.236]     ...future.result$conditions <- ...future.conditions
[18:01:05.236]     ...future.result$finished <- base::Sys.time()
[18:01:05.236]     ...future.result
[18:01:05.236] }
[18:01:05.241] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[18:01:05.242] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[18:01:05.243] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[18:01:05.243] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:05.244] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.244] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[18:01:05.245] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[18:01:05.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:05.246] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.247] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:05.248] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.248] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[18:01:05.249] MultisessionFuture started
[18:01:05.249] - Launch lazy future ... done
[18:01:05.250] run() for ‘MultisessionFuture’ ... done
[18:01:05.250] Created future:
[18:01:05.250] MultisessionFuture:
[18:01:05.250] Label: ‘future_mapply-1’
[18:01:05.250] Expression:
[18:01:05.250] {
[18:01:05.250]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.250]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:05.250]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.250]         on.exit(options(oopts), add = TRUE)
[18:01:05.250]     }
[18:01:05.250]     {
[18:01:05.250]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.250]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:05.250]         do.call(mapply, args = args)
[18:01:05.250]     }
[18:01:05.250] }
[18:01:05.250] Lazy evaluation: FALSE
[18:01:05.250] Asynchronous evaluation: TRUE
[18:01:05.250] Local evaluation: TRUE
[18:01:05.250] Environment: R_GlobalEnv
[18:01:05.250] Capture standard output: TRUE
[18:01:05.250] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:05.250] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:05.250] Packages: <none>
[18:01:05.250] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:05.250] Resolved: FALSE
[18:01:05.250] Value: <not collected>
[18:01:05.250] Conditions captured: <none>
[18:01:05.250] Early signaling: FALSE
[18:01:05.250] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:05.250] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.264] Chunk #1 of 2 ... DONE
[18:01:05.264] Chunk #2 of 2 ...
[18:01:05.265]  - Finding globals in '...' for chunk #2 ...
[18:01:05.265] getGlobalsAndPackages() ...
[18:01:05.265] Searching for globals...
[18:01:05.266] 
[18:01:05.266] Searching for globals ... DONE
[18:01:05.266] - globals: [0] <none>
[18:01:05.267] getGlobalsAndPackages() ... DONE
[18:01:05.267]    + additional globals found: [n=0] 
[18:01:05.267]    + additional namespaces needed: [n=0] 
[18:01:05.267]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:05.267]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:05.268]  - seeds: <none>
[18:01:05.268]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.268] getGlobalsAndPackages() ...
[18:01:05.268] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.269] Resolving globals: FALSE
[18:01:05.270] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:05.271] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:05.272] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.272] 
[18:01:05.272] getGlobalsAndPackages() ... DONE
[18:01:05.273] run() for ‘Future’ ...
[18:01:05.273] - state: ‘created’
[18:01:05.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:05.303] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:05.303]   - Field: ‘node’
[18:01:05.303]   - Field: ‘label’
[18:01:05.304]   - Field: ‘local’
[18:01:05.304]   - Field: ‘owner’
[18:01:05.304]   - Field: ‘envir’
[18:01:05.304]   - Field: ‘workers’
[18:01:05.304]   - Field: ‘packages’
[18:01:05.305]   - Field: ‘gc’
[18:01:05.305]   - Field: ‘conditions’
[18:01:05.305]   - Field: ‘persistent’
[18:01:05.305]   - Field: ‘expr’
[18:01:05.306]   - Field: ‘uuid’
[18:01:05.306]   - Field: ‘seed’
[18:01:05.306]   - Field: ‘version’
[18:01:05.306]   - Field: ‘result’
[18:01:05.307]   - Field: ‘asynchronous’
[18:01:05.307]   - Field: ‘calls’
[18:01:05.307]   - Field: ‘globals’
[18:01:05.307]   - Field: ‘stdout’
[18:01:05.308]   - Field: ‘earlySignal’
[18:01:05.308]   - Field: ‘lazy’
[18:01:05.308]   - Field: ‘state’
[18:01:05.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:05.309] - Launch lazy future ...
[18:01:05.309] Packages needed by the future expression (n = 0): <none>
[18:01:05.310] Packages needed by future strategies (n = 0): <none>
[18:01:05.311] {
[18:01:05.311]     {
[18:01:05.311]         {
[18:01:05.311]             ...future.startTime <- base::Sys.time()
[18:01:05.311]             {
[18:01:05.311]                 {
[18:01:05.311]                   {
[18:01:05.311]                     {
[18:01:05.311]                       base::local({
[18:01:05.311]                         has_future <- base::requireNamespace("future", 
[18:01:05.311]                           quietly = TRUE)
[18:01:05.311]                         if (has_future) {
[18:01:05.311]                           ns <- base::getNamespace("future")
[18:01:05.311]                           version <- ns[[".package"]][["version"]]
[18:01:05.311]                           if (is.null(version)) 
[18:01:05.311]                             version <- utils::packageVersion("future")
[18:01:05.311]                         }
[18:01:05.311]                         else {
[18:01:05.311]                           version <- NULL
[18:01:05.311]                         }
[18:01:05.311]                         if (!has_future || version < "1.8.0") {
[18:01:05.311]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:05.311]                             "", base::R.version$version.string), 
[18:01:05.311]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:05.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:05.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:05.311]                               "release", "version")], collapse = " "), 
[18:01:05.311]                             hostname = base::Sys.info()[["nodename"]])
[18:01:05.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:05.311]                             info)
[18:01:05.311]                           info <- base::paste(info, collapse = "; ")
[18:01:05.311]                           if (!has_future) {
[18:01:05.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:05.311]                               info)
[18:01:05.311]                           }
[18:01:05.311]                           else {
[18:01:05.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:05.311]                               info, version)
[18:01:05.311]                           }
[18:01:05.311]                           base::stop(msg)
[18:01:05.311]                         }
[18:01:05.311]                       })
[18:01:05.311]                     }
[18:01:05.311]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:05.311]                     base::options(mc.cores = 1L)
[18:01:05.311]                   }
[18:01:05.311]                   ...future.strategy.old <- future::plan("list")
[18:01:05.311]                   options(future.plan = NULL)
[18:01:05.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:05.311]                 }
[18:01:05.311]                 ...future.workdir <- getwd()
[18:01:05.311]             }
[18:01:05.311]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:05.311]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:05.311]         }
[18:01:05.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:05.311]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:05.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:05.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:05.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:05.311]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:05.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:05.311]             base::names(...future.oldOptions))
[18:01:05.311]     }
[18:01:05.311]     if (FALSE) {
[18:01:05.311]     }
[18:01:05.311]     else {
[18:01:05.311]         if (TRUE) {
[18:01:05.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:05.311]                 open = "w")
[18:01:05.311]         }
[18:01:05.311]         else {
[18:01:05.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:05.311]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:05.311]         }
[18:01:05.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:05.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:05.311]             base::sink(type = "output", split = FALSE)
[18:01:05.311]             base::close(...future.stdout)
[18:01:05.311]         }, add = TRUE)
[18:01:05.311]     }
[18:01:05.311]     ...future.frame <- base::sys.nframe()
[18:01:05.311]     ...future.conditions <- base::list()
[18:01:05.311]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:05.311]     if (FALSE) {
[18:01:05.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:05.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:05.311]     }
[18:01:05.311]     ...future.result <- base::tryCatch({
[18:01:05.311]         base::withCallingHandlers({
[18:01:05.311]             ...future.value <- base::withVisible(base::local({
[18:01:05.311]                 ...future.makeSendCondition <- base::local({
[18:01:05.311]                   sendCondition <- NULL
[18:01:05.311]                   function(frame = 1L) {
[18:01:05.311]                     if (is.function(sendCondition)) 
[18:01:05.311]                       return(sendCondition)
[18:01:05.311]                     ns <- getNamespace("parallel")
[18:01:05.311]                     if (exists("sendData", mode = "function", 
[18:01:05.311]                       envir = ns)) {
[18:01:05.311]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:05.311]                         envir = ns)
[18:01:05.311]                       envir <- sys.frame(frame)
[18:01:05.311]                       master <- NULL
[18:01:05.311]                       while (!identical(envir, .GlobalEnv) && 
[18:01:05.311]                         !identical(envir, emptyenv())) {
[18:01:05.311]                         if (exists("master", mode = "list", envir = envir, 
[18:01:05.311]                           inherits = FALSE)) {
[18:01:05.311]                           master <- get("master", mode = "list", 
[18:01:05.311]                             envir = envir, inherits = FALSE)
[18:01:05.311]                           if (inherits(master, c("SOCKnode", 
[18:01:05.311]                             "SOCK0node"))) {
[18:01:05.311]                             sendCondition <<- function(cond) {
[18:01:05.311]                               data <- list(type = "VALUE", value = cond, 
[18:01:05.311]                                 success = TRUE)
[18:01:05.311]                               parallel_sendData(master, data)
[18:01:05.311]                             }
[18:01:05.311]                             return(sendCondition)
[18:01:05.311]                           }
[18:01:05.311]                         }
[18:01:05.311]                         frame <- frame + 1L
[18:01:05.311]                         envir <- sys.frame(frame)
[18:01:05.311]                       }
[18:01:05.311]                     }
[18:01:05.311]                     sendCondition <<- function(cond) NULL
[18:01:05.311]                   }
[18:01:05.311]                 })
[18:01:05.311]                 withCallingHandlers({
[18:01:05.311]                   {
[18:01:05.311]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.311]                     if (!identical(...future.globals.maxSize.org, 
[18:01:05.311]                       ...future.globals.maxSize)) {
[18:01:05.311]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.311]                       on.exit(options(oopts), add = TRUE)
[18:01:05.311]                     }
[18:01:05.311]                     {
[18:01:05.311]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.311]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:05.311]                         USE.NAMES = FALSE)
[18:01:05.311]                       do.call(mapply, args = args)
[18:01:05.311]                     }
[18:01:05.311]                   }
[18:01:05.311]                 }, immediateCondition = function(cond) {
[18:01:05.311]                   sendCondition <- ...future.makeSendCondition()
[18:01:05.311]                   sendCondition(cond)
[18:01:05.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.311]                   {
[18:01:05.311]                     inherits <- base::inherits
[18:01:05.311]                     invokeRestart <- base::invokeRestart
[18:01:05.311]                     is.null <- base::is.null
[18:01:05.311]                     muffled <- FALSE
[18:01:05.311]                     if (inherits(cond, "message")) {
[18:01:05.311]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:05.311]                       if (muffled) 
[18:01:05.311]                         invokeRestart("muffleMessage")
[18:01:05.311]                     }
[18:01:05.311]                     else if (inherits(cond, "warning")) {
[18:01:05.311]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:05.311]                       if (muffled) 
[18:01:05.311]                         invokeRestart("muffleWarning")
[18:01:05.311]                     }
[18:01:05.311]                     else if (inherits(cond, "condition")) {
[18:01:05.311]                       if (!is.null(pattern)) {
[18:01:05.311]                         computeRestarts <- base::computeRestarts
[18:01:05.311]                         grepl <- base::grepl
[18:01:05.311]                         restarts <- computeRestarts(cond)
[18:01:05.311]                         for (restart in restarts) {
[18:01:05.311]                           name <- restart$name
[18:01:05.311]                           if (is.null(name)) 
[18:01:05.311]                             next
[18:01:05.311]                           if (!grepl(pattern, name)) 
[18:01:05.311]                             next
[18:01:05.311]                           invokeRestart(restart)
[18:01:05.311]                           muffled <- TRUE
[18:01:05.311]                           break
[18:01:05.311]                         }
[18:01:05.311]                       }
[18:01:05.311]                     }
[18:01:05.311]                     invisible(muffled)
[18:01:05.311]                   }
[18:01:05.311]                   muffleCondition(cond)
[18:01:05.311]                 })
[18:01:05.311]             }))
[18:01:05.311]             future::FutureResult(value = ...future.value$value, 
[18:01:05.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.311]                   ...future.rng), globalenv = if (FALSE) 
[18:01:05.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:05.311]                     ...future.globalenv.names))
[18:01:05.311]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:05.311]         }, condition = base::local({
[18:01:05.311]             c <- base::c
[18:01:05.311]             inherits <- base::inherits
[18:01:05.311]             invokeRestart <- base::invokeRestart
[18:01:05.311]             length <- base::length
[18:01:05.311]             list <- base::list
[18:01:05.311]             seq.int <- base::seq.int
[18:01:05.311]             signalCondition <- base::signalCondition
[18:01:05.311]             sys.calls <- base::sys.calls
[18:01:05.311]             `[[` <- base::`[[`
[18:01:05.311]             `+` <- base::`+`
[18:01:05.311]             `<<-` <- base::`<<-`
[18:01:05.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:05.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:05.311]                   3L)]
[18:01:05.311]             }
[18:01:05.311]             function(cond) {
[18:01:05.311]                 is_error <- inherits(cond, "error")
[18:01:05.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:05.311]                   NULL)
[18:01:05.311]                 if (is_error) {
[18:01:05.311]                   sessionInformation <- function() {
[18:01:05.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:05.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:05.311]                       search = base::search(), system = base::Sys.info())
[18:01:05.311]                   }
[18:01:05.311]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:05.311]                     cond$call), session = sessionInformation(), 
[18:01:05.311]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:05.311]                   signalCondition(cond)
[18:01:05.311]                 }
[18:01:05.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:05.311]                 "immediateCondition"))) {
[18:01:05.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:05.311]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:05.311]                   if (TRUE && !signal) {
[18:01:05.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.311]                     {
[18:01:05.311]                       inherits <- base::inherits
[18:01:05.311]                       invokeRestart <- base::invokeRestart
[18:01:05.311]                       is.null <- base::is.null
[18:01:05.311]                       muffled <- FALSE
[18:01:05.311]                       if (inherits(cond, "message")) {
[18:01:05.311]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.311]                         if (muffled) 
[18:01:05.311]                           invokeRestart("muffleMessage")
[18:01:05.311]                       }
[18:01:05.311]                       else if (inherits(cond, "warning")) {
[18:01:05.311]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.311]                         if (muffled) 
[18:01:05.311]                           invokeRestart("muffleWarning")
[18:01:05.311]                       }
[18:01:05.311]                       else if (inherits(cond, "condition")) {
[18:01:05.311]                         if (!is.null(pattern)) {
[18:01:05.311]                           computeRestarts <- base::computeRestarts
[18:01:05.311]                           grepl <- base::grepl
[18:01:05.311]                           restarts <- computeRestarts(cond)
[18:01:05.311]                           for (restart in restarts) {
[18:01:05.311]                             name <- restart$name
[18:01:05.311]                             if (is.null(name)) 
[18:01:05.311]                               next
[18:01:05.311]                             if (!grepl(pattern, name)) 
[18:01:05.311]                               next
[18:01:05.311]                             invokeRestart(restart)
[18:01:05.311]                             muffled <- TRUE
[18:01:05.311]                             break
[18:01:05.311]                           }
[18:01:05.311]                         }
[18:01:05.311]                       }
[18:01:05.311]                       invisible(muffled)
[18:01:05.311]                     }
[18:01:05.311]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.311]                   }
[18:01:05.311]                 }
[18:01:05.311]                 else {
[18:01:05.311]                   if (TRUE) {
[18:01:05.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.311]                     {
[18:01:05.311]                       inherits <- base::inherits
[18:01:05.311]                       invokeRestart <- base::invokeRestart
[18:01:05.311]                       is.null <- base::is.null
[18:01:05.311]                       muffled <- FALSE
[18:01:05.311]                       if (inherits(cond, "message")) {
[18:01:05.311]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.311]                         if (muffled) 
[18:01:05.311]                           invokeRestart("muffleMessage")
[18:01:05.311]                       }
[18:01:05.311]                       else if (inherits(cond, "warning")) {
[18:01:05.311]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.311]                         if (muffled) 
[18:01:05.311]                           invokeRestart("muffleWarning")
[18:01:05.311]                       }
[18:01:05.311]                       else if (inherits(cond, "condition")) {
[18:01:05.311]                         if (!is.null(pattern)) {
[18:01:05.311]                           computeRestarts <- base::computeRestarts
[18:01:05.311]                           grepl <- base::grepl
[18:01:05.311]                           restarts <- computeRestarts(cond)
[18:01:05.311]                           for (restart in restarts) {
[18:01:05.311]                             name <- restart$name
[18:01:05.311]                             if (is.null(name)) 
[18:01:05.311]                               next
[18:01:05.311]                             if (!grepl(pattern, name)) 
[18:01:05.311]                               next
[18:01:05.311]                             invokeRestart(restart)
[18:01:05.311]                             muffled <- TRUE
[18:01:05.311]                             break
[18:01:05.311]                           }
[18:01:05.311]                         }
[18:01:05.311]                       }
[18:01:05.311]                       invisible(muffled)
[18:01:05.311]                     }
[18:01:05.311]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.311]                   }
[18:01:05.311]                 }
[18:01:05.311]             }
[18:01:05.311]         }))
[18:01:05.311]     }, error = function(ex) {
[18:01:05.311]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:05.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.311]                 ...future.rng), started = ...future.startTime, 
[18:01:05.311]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:05.311]             version = "1.8"), class = "FutureResult")
[18:01:05.311]     }, finally = {
[18:01:05.311]         if (!identical(...future.workdir, getwd())) 
[18:01:05.311]             setwd(...future.workdir)
[18:01:05.311]         {
[18:01:05.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:05.311]                 ...future.oldOptions$nwarnings <- NULL
[18:01:05.311]             }
[18:01:05.311]             base::options(...future.oldOptions)
[18:01:05.311]             if (.Platform$OS.type == "windows") {
[18:01:05.311]                 old_names <- names(...future.oldEnvVars)
[18:01:05.311]                 envs <- base::Sys.getenv()
[18:01:05.311]                 names <- names(envs)
[18:01:05.311]                 common <- intersect(names, old_names)
[18:01:05.311]                 added <- setdiff(names, old_names)
[18:01:05.311]                 removed <- setdiff(old_names, names)
[18:01:05.311]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:05.311]                   envs[common]]
[18:01:05.311]                 NAMES <- toupper(changed)
[18:01:05.311]                 args <- list()
[18:01:05.311]                 for (kk in seq_along(NAMES)) {
[18:01:05.311]                   name <- changed[[kk]]
[18:01:05.311]                   NAME <- NAMES[[kk]]
[18:01:05.311]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.311]                     next
[18:01:05.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.311]                 }
[18:01:05.311]                 NAMES <- toupper(added)
[18:01:05.311]                 for (kk in seq_along(NAMES)) {
[18:01:05.311]                   name <- added[[kk]]
[18:01:05.311]                   NAME <- NAMES[[kk]]
[18:01:05.311]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.311]                     next
[18:01:05.311]                   args[[name]] <- ""
[18:01:05.311]                 }
[18:01:05.311]                 NAMES <- toupper(removed)
[18:01:05.311]                 for (kk in seq_along(NAMES)) {
[18:01:05.311]                   name <- removed[[kk]]
[18:01:05.311]                   NAME <- NAMES[[kk]]
[18:01:05.311]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.311]                     next
[18:01:05.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.311]                 }
[18:01:05.311]                 if (length(args) > 0) 
[18:01:05.311]                   base::do.call(base::Sys.setenv, args = args)
[18:01:05.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:05.311]             }
[18:01:05.311]             else {
[18:01:05.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:05.311]             }
[18:01:05.311]             {
[18:01:05.311]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:05.311]                   0L) {
[18:01:05.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:05.311]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:05.311]                   base::options(opts)
[18:01:05.311]                 }
[18:01:05.311]                 {
[18:01:05.311]                   {
[18:01:05.311]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:05.311]                     NULL
[18:01:05.311]                   }
[18:01:05.311]                   options(future.plan = NULL)
[18:01:05.311]                   if (is.na(NA_character_)) 
[18:01:05.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:05.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:05.311]                     .init = FALSE)
[18:01:05.311]                 }
[18:01:05.311]             }
[18:01:05.311]         }
[18:01:05.311]     })
[18:01:05.311]     if (TRUE) {
[18:01:05.311]         base::sink(type = "output", split = FALSE)
[18:01:05.311]         if (TRUE) {
[18:01:05.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:05.311]         }
[18:01:05.311]         else {
[18:01:05.311]             ...future.result["stdout"] <- base::list(NULL)
[18:01:05.311]         }
[18:01:05.311]         base::close(...future.stdout)
[18:01:05.311]         ...future.stdout <- NULL
[18:01:05.311]     }
[18:01:05.311]     ...future.result$conditions <- ...future.conditions
[18:01:05.311]     ...future.result$finished <- base::Sys.time()
[18:01:05.311]     ...future.result
[18:01:05.311] }
[18:01:05.414] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[18:01:05.414] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[18:01:05.415] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[18:01:05.415] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:05.416] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.417] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:05.417] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:05.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:05.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.419] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:05.420] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.420] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[18:01:05.421] MultisessionFuture started
[18:01:05.421] - Launch lazy future ... done
[18:01:05.421] run() for ‘MultisessionFuture’ ... done
[18:01:05.422] Created future:
[18:01:05.422] MultisessionFuture:
[18:01:05.422] Label: ‘future_mapply-2’
[18:01:05.422] Expression:
[18:01:05.422] {
[18:01:05.422]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.422]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:05.422]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.422]         on.exit(options(oopts), add = TRUE)
[18:01:05.422]     }
[18:01:05.422]     {
[18:01:05.422]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.422]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:05.422]         do.call(mapply, args = args)
[18:01:05.422]     }
[18:01:05.422] }
[18:01:05.422] Lazy evaluation: FALSE
[18:01:05.422] Asynchronous evaluation: TRUE
[18:01:05.422] Local evaluation: TRUE
[18:01:05.422] Environment: R_GlobalEnv
[18:01:05.422] Capture standard output: TRUE
[18:01:05.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:05.422] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:05.422] Packages: <none>
[18:01:05.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:05.422] Resolved: FALSE
[18:01:05.422] Value: <not collected>
[18:01:05.422] Conditions captured: <none>
[18:01:05.422] Early signaling: FALSE
[18:01:05.422] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:05.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.435] Chunk #2 of 2 ... DONE
[18:01:05.435] Launching 2 futures (chunks) ... DONE
[18:01:05.436] Resolving 2 futures (chunks) ...
[18:01:05.436] resolve() on list ...
[18:01:05.436]  recursive: 0
[18:01:05.437]  length: 2
[18:01:05.437] 
[18:01:05.438] receiveMessageFromWorker() for ClusterFuture ...
[18:01:05.438] - Validating connection of MultisessionFuture
[18:01:05.439] - received message: FutureResult
[18:01:05.439] - Received FutureResult
[18:01:05.440] - Erased future from FutureRegistry
[18:01:05.440] result() for ClusterFuture ...
[18:01:05.440] - result already collected: FutureResult
[18:01:05.440] result() for ClusterFuture ... done
[18:01:05.441] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:05.441] Future #1
[18:01:05.441] result() for ClusterFuture ...
[18:01:05.442] - result already collected: FutureResult
[18:01:05.442] result() for ClusterFuture ... done
[18:01:05.442] result() for ClusterFuture ...
[18:01:05.442] - result already collected: FutureResult
[18:01:05.443] result() for ClusterFuture ... done
[18:01:05.443] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:05.443] - nx: 2
[18:01:05.443] - relay: TRUE
[18:01:05.444] - stdout: TRUE
[18:01:05.444] - signal: TRUE
[18:01:05.444] - resignal: FALSE
[18:01:05.444] - force: TRUE
[18:01:05.445] - relayed: [n=2] FALSE, FALSE
[18:01:05.445] - queued futures: [n=2] FALSE, FALSE
[18:01:05.445]  - until=1
[18:01:05.445]  - relaying element #1
[18:01:05.446] result() for ClusterFuture ...
[18:01:05.446] - result already collected: FutureResult
[18:01:05.446] result() for ClusterFuture ... done
[18:01:05.447] result() for ClusterFuture ...
[18:01:05.447] - result already collected: FutureResult
[18:01:05.447] result() for ClusterFuture ... done
[18:01:05.448] result() for ClusterFuture ...
[18:01:05.448] - result already collected: FutureResult
[18:01:05.448] result() for ClusterFuture ... done
[18:01:05.448] result() for ClusterFuture ...
[18:01:05.449] - result already collected: FutureResult
[18:01:05.449] result() for ClusterFuture ... done
[18:01:05.449] - relayed: [n=2] TRUE, FALSE
[18:01:05.449] - queued futures: [n=2] TRUE, FALSE
[18:01:05.450] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:05.450]  length: 1 (resolved future 1)
[18:01:05.536] receiveMessageFromWorker() for ClusterFuture ...
[18:01:05.537] - Validating connection of MultisessionFuture
[18:01:05.537] - received message: FutureResult
[18:01:05.538] - Received FutureResult
[18:01:05.538] - Erased future from FutureRegistry
[18:01:05.538] result() for ClusterFuture ...
[18:01:05.538] - result already collected: FutureResult
[18:01:05.539] result() for ClusterFuture ... done
[18:01:05.539] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:05.539] Future #2
[18:01:05.540] result() for ClusterFuture ...
[18:01:05.540] - result already collected: FutureResult
[18:01:05.540] result() for ClusterFuture ... done
[18:01:05.541] result() for ClusterFuture ...
[18:01:05.542] - result already collected: FutureResult
[18:01:05.542] result() for ClusterFuture ... done
[18:01:05.542] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:05.544] - nx: 2
[18:01:05.545] - relay: TRUE
[18:01:05.546] - stdout: TRUE
[18:01:05.547] - signal: TRUE
[18:01:05.555] - resignal: FALSE
[18:01:05.555] - force: TRUE
[18:01:05.555] - relayed: [n=2] TRUE, FALSE
[18:01:05.555] - queued futures: [n=2] TRUE, FALSE
[18:01:05.556]  - until=2
[18:01:05.556]  - relaying element #2
[18:01:05.556] result() for ClusterFuture ...
[18:01:05.556] - result already collected: FutureResult
[18:01:05.556] result() for ClusterFuture ... done
[18:01:05.557] result() for ClusterFuture ...
[18:01:05.557] - result already collected: FutureResult
[18:01:05.557] result() for ClusterFuture ... done
[18:01:05.557] result() for ClusterFuture ...
[18:01:05.558] - result already collected: FutureResult
[18:01:05.558] result() for ClusterFuture ... done
[18:01:05.558] result() for ClusterFuture ...
[18:01:05.558] - result already collected: FutureResult
[18:01:05.558] result() for ClusterFuture ... done
[18:01:05.558] - relayed: [n=2] TRUE, TRUE
[18:01:05.559] - queued futures: [n=2] TRUE, TRUE
[18:01:05.559] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:05.559]  length: 0 (resolved future 2)
[18:01:05.559] Relaying remaining futures
[18:01:05.559] signalConditionsASAP(NULL, pos=0) ...
[18:01:05.560] - nx: 2
[18:01:05.560] - relay: TRUE
[18:01:05.560] - stdout: TRUE
[18:01:05.560] - signal: TRUE
[18:01:05.560] - resignal: FALSE
[18:01:05.560] - force: TRUE
[18:01:05.561] - relayed: [n=2] TRUE, TRUE
[18:01:05.561] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:05.561] - relayed: [n=2] TRUE, TRUE
[18:01:05.561] - queued futures: [n=2] TRUE, TRUE
[18:01:05.562] signalConditionsASAP(NULL, pos=0) ... done
[18:01:05.562] resolve() on list ... DONE
[18:01:05.562] result() for ClusterFuture ...
[18:01:05.562] - result already collected: FutureResult
[18:01:05.562] result() for ClusterFuture ... done
[18:01:05.563] result() for ClusterFuture ...
[18:01:05.563] - result already collected: FutureResult
[18:01:05.563] result() for ClusterFuture ... done
[18:01:05.563] result() for ClusterFuture ...
[18:01:05.563] - result already collected: FutureResult
[18:01:05.564] result() for ClusterFuture ... done
[18:01:05.564] result() for ClusterFuture ...
[18:01:05.564] - result already collected: FutureResult
[18:01:05.564] result() for ClusterFuture ... done
[18:01:05.564]  - Number of value chunks collected: 2
[18:01:05.565] Resolving 2 futures (chunks) ... DONE
[18:01:05.565] Reducing values from 2 chunks ...
[18:01:05.565]  - Number of values collected after concatenation: 4
[18:01:05.565]  - Number of values expected: 4
[18:01:05.565] Reducing values from 2 chunks ... DONE
[18:01:05.565] future_mapply() ... DONE
[18:01:05.566] future_mapply() ...
[18:01:05.572] Number of chunks: 2
[18:01:05.572] getGlobalsAndPackagesXApply() ...
[18:01:05.573]  - future.globals: TRUE
[18:01:05.573] getGlobalsAndPackages() ...
[18:01:05.573] Searching for globals...
[18:01:05.574] - globals found: [1] ‘FUN’
[18:01:05.575] Searching for globals ... DONE
[18:01:05.575] Resolving globals: FALSE
[18:01:05.576] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:05.576] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:05.577] - globals: [1] ‘FUN’
[18:01:05.577] 
[18:01:05.577] getGlobalsAndPackages() ... DONE
[18:01:05.577]  - globals found/used: [n=1] ‘FUN’
[18:01:05.577]  - needed namespaces: [n=0] 
[18:01:05.578] Finding globals ... DONE
[18:01:05.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:05.578] List of 2
[18:01:05.578]  $ ...future.FUN:function (x, ...)  
[18:01:05.578]  $ MoreArgs     : NULL
[18:01:05.578]  - attr(*, "where")=List of 2
[18:01:05.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:05.578]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:05.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:05.578]  - attr(*, "resolved")= logi FALSE
[18:01:05.578]  - attr(*, "total_size")= num NA
[18:01:05.584] Packages to be attached in all futures: [n=0] 
[18:01:05.584] getGlobalsAndPackagesXApply() ... DONE
[18:01:05.584] Number of futures (= number of chunks): 2
[18:01:05.585] Launching 2 futures (chunks) ...
[18:01:05.585] Chunk #1 of 2 ...
[18:01:05.585]  - Finding globals in '...' for chunk #1 ...
[18:01:05.585] getGlobalsAndPackages() ...
[18:01:05.586] Searching for globals...
[18:01:05.586] 
[18:01:05.587] Searching for globals ... DONE
[18:01:05.587] - globals: [0] <none>
[18:01:05.587] getGlobalsAndPackages() ... DONE
[18:01:05.587]    + additional globals found: [n=0] 
[18:01:05.587]    + additional namespaces needed: [n=0] 
[18:01:05.588]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:05.588]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:05.588]  - seeds: <none>
[18:01:05.588]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.588] getGlobalsAndPackages() ...
[18:01:05.589] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.589] Resolving globals: FALSE
[18:01:05.590] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:05.593] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:05.593] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.594] 
[18:01:05.594] getGlobalsAndPackages() ... DONE
[18:01:05.594] run() for ‘Future’ ...
[18:01:05.595] - state: ‘created’
[18:01:05.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:05.622] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:05.623]   - Field: ‘node’
[18:01:05.623]   - Field: ‘label’
[18:01:05.623]   - Field: ‘local’
[18:01:05.623]   - Field: ‘owner’
[18:01:05.624]   - Field: ‘envir’
[18:01:05.624]   - Field: ‘workers’
[18:01:05.624]   - Field: ‘packages’
[18:01:05.624]   - Field: ‘gc’
[18:01:05.625]   - Field: ‘conditions’
[18:01:05.625]   - Field: ‘persistent’
[18:01:05.625]   - Field: ‘expr’
[18:01:05.625]   - Field: ‘uuid’
[18:01:05.625]   - Field: ‘seed’
[18:01:05.626]   - Field: ‘version’
[18:01:05.626]   - Field: ‘result’
[18:01:05.626]   - Field: ‘asynchronous’
[18:01:05.626]   - Field: ‘calls’
[18:01:05.626]   - Field: ‘globals’
[18:01:05.627]   - Field: ‘stdout’
[18:01:05.627]   - Field: ‘earlySignal’
[18:01:05.627]   - Field: ‘lazy’
[18:01:05.627]   - Field: ‘state’
[18:01:05.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:05.628] - Launch lazy future ...
[18:01:05.628] Packages needed by the future expression (n = 0): <none>
[18:01:05.628] Packages needed by future strategies (n = 0): <none>
[18:01:05.629] {
[18:01:05.629]     {
[18:01:05.629]         {
[18:01:05.629]             ...future.startTime <- base::Sys.time()
[18:01:05.629]             {
[18:01:05.629]                 {
[18:01:05.629]                   {
[18:01:05.629]                     {
[18:01:05.629]                       base::local({
[18:01:05.629]                         has_future <- base::requireNamespace("future", 
[18:01:05.629]                           quietly = TRUE)
[18:01:05.629]                         if (has_future) {
[18:01:05.629]                           ns <- base::getNamespace("future")
[18:01:05.629]                           version <- ns[[".package"]][["version"]]
[18:01:05.629]                           if (is.null(version)) 
[18:01:05.629]                             version <- utils::packageVersion("future")
[18:01:05.629]                         }
[18:01:05.629]                         else {
[18:01:05.629]                           version <- NULL
[18:01:05.629]                         }
[18:01:05.629]                         if (!has_future || version < "1.8.0") {
[18:01:05.629]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:05.629]                             "", base::R.version$version.string), 
[18:01:05.629]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:05.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:05.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:05.629]                               "release", "version")], collapse = " "), 
[18:01:05.629]                             hostname = base::Sys.info()[["nodename"]])
[18:01:05.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:05.629]                             info)
[18:01:05.629]                           info <- base::paste(info, collapse = "; ")
[18:01:05.629]                           if (!has_future) {
[18:01:05.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:05.629]                               info)
[18:01:05.629]                           }
[18:01:05.629]                           else {
[18:01:05.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:05.629]                               info, version)
[18:01:05.629]                           }
[18:01:05.629]                           base::stop(msg)
[18:01:05.629]                         }
[18:01:05.629]                       })
[18:01:05.629]                     }
[18:01:05.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:05.629]                     base::options(mc.cores = 1L)
[18:01:05.629]                   }
[18:01:05.629]                   ...future.strategy.old <- future::plan("list")
[18:01:05.629]                   options(future.plan = NULL)
[18:01:05.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:05.629]                 }
[18:01:05.629]                 ...future.workdir <- getwd()
[18:01:05.629]             }
[18:01:05.629]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:05.629]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:05.629]         }
[18:01:05.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:05.629]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:05.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:05.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:05.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:05.629]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:05.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:05.629]             base::names(...future.oldOptions))
[18:01:05.629]     }
[18:01:05.629]     if (FALSE) {
[18:01:05.629]     }
[18:01:05.629]     else {
[18:01:05.629]         if (TRUE) {
[18:01:05.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:05.629]                 open = "w")
[18:01:05.629]         }
[18:01:05.629]         else {
[18:01:05.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:05.629]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:05.629]         }
[18:01:05.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:05.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:05.629]             base::sink(type = "output", split = FALSE)
[18:01:05.629]             base::close(...future.stdout)
[18:01:05.629]         }, add = TRUE)
[18:01:05.629]     }
[18:01:05.629]     ...future.frame <- base::sys.nframe()
[18:01:05.629]     ...future.conditions <- base::list()
[18:01:05.629]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:05.629]     if (FALSE) {
[18:01:05.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:05.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:05.629]     }
[18:01:05.629]     ...future.result <- base::tryCatch({
[18:01:05.629]         base::withCallingHandlers({
[18:01:05.629]             ...future.value <- base::withVisible(base::local({
[18:01:05.629]                 ...future.makeSendCondition <- base::local({
[18:01:05.629]                   sendCondition <- NULL
[18:01:05.629]                   function(frame = 1L) {
[18:01:05.629]                     if (is.function(sendCondition)) 
[18:01:05.629]                       return(sendCondition)
[18:01:05.629]                     ns <- getNamespace("parallel")
[18:01:05.629]                     if (exists("sendData", mode = "function", 
[18:01:05.629]                       envir = ns)) {
[18:01:05.629]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:05.629]                         envir = ns)
[18:01:05.629]                       envir <- sys.frame(frame)
[18:01:05.629]                       master <- NULL
[18:01:05.629]                       while (!identical(envir, .GlobalEnv) && 
[18:01:05.629]                         !identical(envir, emptyenv())) {
[18:01:05.629]                         if (exists("master", mode = "list", envir = envir, 
[18:01:05.629]                           inherits = FALSE)) {
[18:01:05.629]                           master <- get("master", mode = "list", 
[18:01:05.629]                             envir = envir, inherits = FALSE)
[18:01:05.629]                           if (inherits(master, c("SOCKnode", 
[18:01:05.629]                             "SOCK0node"))) {
[18:01:05.629]                             sendCondition <<- function(cond) {
[18:01:05.629]                               data <- list(type = "VALUE", value = cond, 
[18:01:05.629]                                 success = TRUE)
[18:01:05.629]                               parallel_sendData(master, data)
[18:01:05.629]                             }
[18:01:05.629]                             return(sendCondition)
[18:01:05.629]                           }
[18:01:05.629]                         }
[18:01:05.629]                         frame <- frame + 1L
[18:01:05.629]                         envir <- sys.frame(frame)
[18:01:05.629]                       }
[18:01:05.629]                     }
[18:01:05.629]                     sendCondition <<- function(cond) NULL
[18:01:05.629]                   }
[18:01:05.629]                 })
[18:01:05.629]                 withCallingHandlers({
[18:01:05.629]                   {
[18:01:05.629]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.629]                     if (!identical(...future.globals.maxSize.org, 
[18:01:05.629]                       ...future.globals.maxSize)) {
[18:01:05.629]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.629]                       on.exit(options(oopts), add = TRUE)
[18:01:05.629]                     }
[18:01:05.629]                     {
[18:01:05.629]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.629]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:05.629]                         USE.NAMES = FALSE)
[18:01:05.629]                       do.call(mapply, args = args)
[18:01:05.629]                     }
[18:01:05.629]                   }
[18:01:05.629]                 }, immediateCondition = function(cond) {
[18:01:05.629]                   sendCondition <- ...future.makeSendCondition()
[18:01:05.629]                   sendCondition(cond)
[18:01:05.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.629]                   {
[18:01:05.629]                     inherits <- base::inherits
[18:01:05.629]                     invokeRestart <- base::invokeRestart
[18:01:05.629]                     is.null <- base::is.null
[18:01:05.629]                     muffled <- FALSE
[18:01:05.629]                     if (inherits(cond, "message")) {
[18:01:05.629]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:05.629]                       if (muffled) 
[18:01:05.629]                         invokeRestart("muffleMessage")
[18:01:05.629]                     }
[18:01:05.629]                     else if (inherits(cond, "warning")) {
[18:01:05.629]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:05.629]                       if (muffled) 
[18:01:05.629]                         invokeRestart("muffleWarning")
[18:01:05.629]                     }
[18:01:05.629]                     else if (inherits(cond, "condition")) {
[18:01:05.629]                       if (!is.null(pattern)) {
[18:01:05.629]                         computeRestarts <- base::computeRestarts
[18:01:05.629]                         grepl <- base::grepl
[18:01:05.629]                         restarts <- computeRestarts(cond)
[18:01:05.629]                         for (restart in restarts) {
[18:01:05.629]                           name <- restart$name
[18:01:05.629]                           if (is.null(name)) 
[18:01:05.629]                             next
[18:01:05.629]                           if (!grepl(pattern, name)) 
[18:01:05.629]                             next
[18:01:05.629]                           invokeRestart(restart)
[18:01:05.629]                           muffled <- TRUE
[18:01:05.629]                           break
[18:01:05.629]                         }
[18:01:05.629]                       }
[18:01:05.629]                     }
[18:01:05.629]                     invisible(muffled)
[18:01:05.629]                   }
[18:01:05.629]                   muffleCondition(cond)
[18:01:05.629]                 })
[18:01:05.629]             }))
[18:01:05.629]             future::FutureResult(value = ...future.value$value, 
[18:01:05.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.629]                   ...future.rng), globalenv = if (FALSE) 
[18:01:05.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:05.629]                     ...future.globalenv.names))
[18:01:05.629]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:05.629]         }, condition = base::local({
[18:01:05.629]             c <- base::c
[18:01:05.629]             inherits <- base::inherits
[18:01:05.629]             invokeRestart <- base::invokeRestart
[18:01:05.629]             length <- base::length
[18:01:05.629]             list <- base::list
[18:01:05.629]             seq.int <- base::seq.int
[18:01:05.629]             signalCondition <- base::signalCondition
[18:01:05.629]             sys.calls <- base::sys.calls
[18:01:05.629]             `[[` <- base::`[[`
[18:01:05.629]             `+` <- base::`+`
[18:01:05.629]             `<<-` <- base::`<<-`
[18:01:05.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:05.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:05.629]                   3L)]
[18:01:05.629]             }
[18:01:05.629]             function(cond) {
[18:01:05.629]                 is_error <- inherits(cond, "error")
[18:01:05.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:05.629]                   NULL)
[18:01:05.629]                 if (is_error) {
[18:01:05.629]                   sessionInformation <- function() {
[18:01:05.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:05.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:05.629]                       search = base::search(), system = base::Sys.info())
[18:01:05.629]                   }
[18:01:05.629]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:05.629]                     cond$call), session = sessionInformation(), 
[18:01:05.629]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:05.629]                   signalCondition(cond)
[18:01:05.629]                 }
[18:01:05.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:05.629]                 "immediateCondition"))) {
[18:01:05.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:05.629]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:05.629]                   if (TRUE && !signal) {
[18:01:05.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.629]                     {
[18:01:05.629]                       inherits <- base::inherits
[18:01:05.629]                       invokeRestart <- base::invokeRestart
[18:01:05.629]                       is.null <- base::is.null
[18:01:05.629]                       muffled <- FALSE
[18:01:05.629]                       if (inherits(cond, "message")) {
[18:01:05.629]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.629]                         if (muffled) 
[18:01:05.629]                           invokeRestart("muffleMessage")
[18:01:05.629]                       }
[18:01:05.629]                       else if (inherits(cond, "warning")) {
[18:01:05.629]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.629]                         if (muffled) 
[18:01:05.629]                           invokeRestart("muffleWarning")
[18:01:05.629]                       }
[18:01:05.629]                       else if (inherits(cond, "condition")) {
[18:01:05.629]                         if (!is.null(pattern)) {
[18:01:05.629]                           computeRestarts <- base::computeRestarts
[18:01:05.629]                           grepl <- base::grepl
[18:01:05.629]                           restarts <- computeRestarts(cond)
[18:01:05.629]                           for (restart in restarts) {
[18:01:05.629]                             name <- restart$name
[18:01:05.629]                             if (is.null(name)) 
[18:01:05.629]                               next
[18:01:05.629]                             if (!grepl(pattern, name)) 
[18:01:05.629]                               next
[18:01:05.629]                             invokeRestart(restart)
[18:01:05.629]                             muffled <- TRUE
[18:01:05.629]                             break
[18:01:05.629]                           }
[18:01:05.629]                         }
[18:01:05.629]                       }
[18:01:05.629]                       invisible(muffled)
[18:01:05.629]                     }
[18:01:05.629]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.629]                   }
[18:01:05.629]                 }
[18:01:05.629]                 else {
[18:01:05.629]                   if (TRUE) {
[18:01:05.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.629]                     {
[18:01:05.629]                       inherits <- base::inherits
[18:01:05.629]                       invokeRestart <- base::invokeRestart
[18:01:05.629]                       is.null <- base::is.null
[18:01:05.629]                       muffled <- FALSE
[18:01:05.629]                       if (inherits(cond, "message")) {
[18:01:05.629]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.629]                         if (muffled) 
[18:01:05.629]                           invokeRestart("muffleMessage")
[18:01:05.629]                       }
[18:01:05.629]                       else if (inherits(cond, "warning")) {
[18:01:05.629]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.629]                         if (muffled) 
[18:01:05.629]                           invokeRestart("muffleWarning")
[18:01:05.629]                       }
[18:01:05.629]                       else if (inherits(cond, "condition")) {
[18:01:05.629]                         if (!is.null(pattern)) {
[18:01:05.629]                           computeRestarts <- base::computeRestarts
[18:01:05.629]                           grepl <- base::grepl
[18:01:05.629]                           restarts <- computeRestarts(cond)
[18:01:05.629]                           for (restart in restarts) {
[18:01:05.629]                             name <- restart$name
[18:01:05.629]                             if (is.null(name)) 
[18:01:05.629]                               next
[18:01:05.629]                             if (!grepl(pattern, name)) 
[18:01:05.629]                               next
[18:01:05.629]                             invokeRestart(restart)
[18:01:05.629]                             muffled <- TRUE
[18:01:05.629]                             break
[18:01:05.629]                           }
[18:01:05.629]                         }
[18:01:05.629]                       }
[18:01:05.629]                       invisible(muffled)
[18:01:05.629]                     }
[18:01:05.629]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.629]                   }
[18:01:05.629]                 }
[18:01:05.629]             }
[18:01:05.629]         }))
[18:01:05.629]     }, error = function(ex) {
[18:01:05.629]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:05.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.629]                 ...future.rng), started = ...future.startTime, 
[18:01:05.629]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:05.629]             version = "1.8"), class = "FutureResult")
[18:01:05.629]     }, finally = {
[18:01:05.629]         if (!identical(...future.workdir, getwd())) 
[18:01:05.629]             setwd(...future.workdir)
[18:01:05.629]         {
[18:01:05.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:05.629]                 ...future.oldOptions$nwarnings <- NULL
[18:01:05.629]             }
[18:01:05.629]             base::options(...future.oldOptions)
[18:01:05.629]             if (.Platform$OS.type == "windows") {
[18:01:05.629]                 old_names <- names(...future.oldEnvVars)
[18:01:05.629]                 envs <- base::Sys.getenv()
[18:01:05.629]                 names <- names(envs)
[18:01:05.629]                 common <- intersect(names, old_names)
[18:01:05.629]                 added <- setdiff(names, old_names)
[18:01:05.629]                 removed <- setdiff(old_names, names)
[18:01:05.629]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:05.629]                   envs[common]]
[18:01:05.629]                 NAMES <- toupper(changed)
[18:01:05.629]                 args <- list()
[18:01:05.629]                 for (kk in seq_along(NAMES)) {
[18:01:05.629]                   name <- changed[[kk]]
[18:01:05.629]                   NAME <- NAMES[[kk]]
[18:01:05.629]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.629]                     next
[18:01:05.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.629]                 }
[18:01:05.629]                 NAMES <- toupper(added)
[18:01:05.629]                 for (kk in seq_along(NAMES)) {
[18:01:05.629]                   name <- added[[kk]]
[18:01:05.629]                   NAME <- NAMES[[kk]]
[18:01:05.629]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.629]                     next
[18:01:05.629]                   args[[name]] <- ""
[18:01:05.629]                 }
[18:01:05.629]                 NAMES <- toupper(removed)
[18:01:05.629]                 for (kk in seq_along(NAMES)) {
[18:01:05.629]                   name <- removed[[kk]]
[18:01:05.629]                   NAME <- NAMES[[kk]]
[18:01:05.629]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.629]                     next
[18:01:05.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.629]                 }
[18:01:05.629]                 if (length(args) > 0) 
[18:01:05.629]                   base::do.call(base::Sys.setenv, args = args)
[18:01:05.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:05.629]             }
[18:01:05.629]             else {
[18:01:05.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:05.629]             }
[18:01:05.629]             {
[18:01:05.629]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:05.629]                   0L) {
[18:01:05.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:05.629]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:05.629]                   base::options(opts)
[18:01:05.629]                 }
[18:01:05.629]                 {
[18:01:05.629]                   {
[18:01:05.629]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:05.629]                     NULL
[18:01:05.629]                   }
[18:01:05.629]                   options(future.plan = NULL)
[18:01:05.629]                   if (is.na(NA_character_)) 
[18:01:05.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:05.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:05.629]                     .init = FALSE)
[18:01:05.629]                 }
[18:01:05.629]             }
[18:01:05.629]         }
[18:01:05.629]     })
[18:01:05.629]     if (TRUE) {
[18:01:05.629]         base::sink(type = "output", split = FALSE)
[18:01:05.629]         if (TRUE) {
[18:01:05.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:05.629]         }
[18:01:05.629]         else {
[18:01:05.629]             ...future.result["stdout"] <- base::list(NULL)
[18:01:05.629]         }
[18:01:05.629]         base::close(...future.stdout)
[18:01:05.629]         ...future.stdout <- NULL
[18:01:05.629]     }
[18:01:05.629]     ...future.result$conditions <- ...future.conditions
[18:01:05.629]     ...future.result$finished <- base::Sys.time()
[18:01:05.629]     ...future.result
[18:01:05.629] }
[18:01:05.635] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[18:01:05.635] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[18:01:05.636] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[18:01:05.637] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:05.637] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.638] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[18:01:05.639] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[18:01:05.639] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:05.640] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.640] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:05.641] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.642] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[18:01:05.643] MultisessionFuture started
[18:01:05.644] - Launch lazy future ... done
[18:01:05.646] run() for ‘MultisessionFuture’ ... done
[18:01:05.646] Created future:
[18:01:05.646] MultisessionFuture:
[18:01:05.646] Label: ‘future_mapply-1’
[18:01:05.646] Expression:
[18:01:05.646] {
[18:01:05.646]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.646]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:05.646]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.646]         on.exit(options(oopts), add = TRUE)
[18:01:05.646]     }
[18:01:05.646]     {
[18:01:05.646]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.646]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:05.646]         do.call(mapply, args = args)
[18:01:05.646]     }
[18:01:05.646] }
[18:01:05.646] Lazy evaluation: FALSE
[18:01:05.646] Asynchronous evaluation: TRUE
[18:01:05.646] Local evaluation: TRUE
[18:01:05.646] Environment: R_GlobalEnv
[18:01:05.646] Capture standard output: TRUE
[18:01:05.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:05.646] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:05.646] Packages: <none>
[18:01:05.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:05.646] Resolved: FALSE
[18:01:05.646] Value: <not collected>
[18:01:05.646] Conditions captured: <none>
[18:01:05.646] Early signaling: FALSE
[18:01:05.646] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:05.646] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.662] Chunk #1 of 2 ... DONE
[18:01:05.662] Chunk #2 of 2 ...
[18:01:05.662]  - Finding globals in '...' for chunk #2 ...
[18:01:05.663] getGlobalsAndPackages() ...
[18:01:05.663] Searching for globals...
[18:01:05.663] 
[18:01:05.664] Searching for globals ... DONE
[18:01:05.664] - globals: [0] <none>
[18:01:05.664] getGlobalsAndPackages() ... DONE
[18:01:05.664]    + additional globals found: [n=0] 
[18:01:05.664]    + additional namespaces needed: [n=0] 
[18:01:05.665]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:05.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:05.665]  - seeds: <none>
[18:01:05.665]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.665] getGlobalsAndPackages() ...
[18:01:05.666] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.666] Resolving globals: FALSE
[18:01:05.667] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:05.668] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:05.668] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.668] 
[18:01:05.668] getGlobalsAndPackages() ... DONE
[18:01:05.669] run() for ‘Future’ ...
[18:01:05.669] - state: ‘created’
[18:01:05.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:05.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:05.694]   - Field: ‘node’
[18:01:05.694]   - Field: ‘label’
[18:01:05.694]   - Field: ‘local’
[18:01:05.695]   - Field: ‘owner’
[18:01:05.695]   - Field: ‘envir’
[18:01:05.695]   - Field: ‘workers’
[18:01:05.695]   - Field: ‘packages’
[18:01:05.695]   - Field: ‘gc’
[18:01:05.696]   - Field: ‘conditions’
[18:01:05.696]   - Field: ‘persistent’
[18:01:05.696]   - Field: ‘expr’
[18:01:05.697]   - Field: ‘uuid’
[18:01:05.697]   - Field: ‘seed’
[18:01:05.697]   - Field: ‘version’
[18:01:05.697]   - Field: ‘result’
[18:01:05.697]   - Field: ‘asynchronous’
[18:01:05.698]   - Field: ‘calls’
[18:01:05.698]   - Field: ‘globals’
[18:01:05.698]   - Field: ‘stdout’
[18:01:05.698]   - Field: ‘earlySignal’
[18:01:05.698]   - Field: ‘lazy’
[18:01:05.699]   - Field: ‘state’
[18:01:05.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:05.699] - Launch lazy future ...
[18:01:05.700] Packages needed by the future expression (n = 0): <none>
[18:01:05.700] Packages needed by future strategies (n = 0): <none>
[18:01:05.701] {
[18:01:05.701]     {
[18:01:05.701]         {
[18:01:05.701]             ...future.startTime <- base::Sys.time()
[18:01:05.701]             {
[18:01:05.701]                 {
[18:01:05.701]                   {
[18:01:05.701]                     {
[18:01:05.701]                       base::local({
[18:01:05.701]                         has_future <- base::requireNamespace("future", 
[18:01:05.701]                           quietly = TRUE)
[18:01:05.701]                         if (has_future) {
[18:01:05.701]                           ns <- base::getNamespace("future")
[18:01:05.701]                           version <- ns[[".package"]][["version"]]
[18:01:05.701]                           if (is.null(version)) 
[18:01:05.701]                             version <- utils::packageVersion("future")
[18:01:05.701]                         }
[18:01:05.701]                         else {
[18:01:05.701]                           version <- NULL
[18:01:05.701]                         }
[18:01:05.701]                         if (!has_future || version < "1.8.0") {
[18:01:05.701]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:05.701]                             "", base::R.version$version.string), 
[18:01:05.701]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:05.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:05.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:05.701]                               "release", "version")], collapse = " "), 
[18:01:05.701]                             hostname = base::Sys.info()[["nodename"]])
[18:01:05.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:05.701]                             info)
[18:01:05.701]                           info <- base::paste(info, collapse = "; ")
[18:01:05.701]                           if (!has_future) {
[18:01:05.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:05.701]                               info)
[18:01:05.701]                           }
[18:01:05.701]                           else {
[18:01:05.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:05.701]                               info, version)
[18:01:05.701]                           }
[18:01:05.701]                           base::stop(msg)
[18:01:05.701]                         }
[18:01:05.701]                       })
[18:01:05.701]                     }
[18:01:05.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:05.701]                     base::options(mc.cores = 1L)
[18:01:05.701]                   }
[18:01:05.701]                   ...future.strategy.old <- future::plan("list")
[18:01:05.701]                   options(future.plan = NULL)
[18:01:05.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:05.701]                 }
[18:01:05.701]                 ...future.workdir <- getwd()
[18:01:05.701]             }
[18:01:05.701]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:05.701]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:05.701]         }
[18:01:05.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:05.701]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:05.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:05.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:05.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:05.701]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:05.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:05.701]             base::names(...future.oldOptions))
[18:01:05.701]     }
[18:01:05.701]     if (FALSE) {
[18:01:05.701]     }
[18:01:05.701]     else {
[18:01:05.701]         if (TRUE) {
[18:01:05.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:05.701]                 open = "w")
[18:01:05.701]         }
[18:01:05.701]         else {
[18:01:05.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:05.701]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:05.701]         }
[18:01:05.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:05.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:05.701]             base::sink(type = "output", split = FALSE)
[18:01:05.701]             base::close(...future.stdout)
[18:01:05.701]         }, add = TRUE)
[18:01:05.701]     }
[18:01:05.701]     ...future.frame <- base::sys.nframe()
[18:01:05.701]     ...future.conditions <- base::list()
[18:01:05.701]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:05.701]     if (FALSE) {
[18:01:05.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:05.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:05.701]     }
[18:01:05.701]     ...future.result <- base::tryCatch({
[18:01:05.701]         base::withCallingHandlers({
[18:01:05.701]             ...future.value <- base::withVisible(base::local({
[18:01:05.701]                 ...future.makeSendCondition <- base::local({
[18:01:05.701]                   sendCondition <- NULL
[18:01:05.701]                   function(frame = 1L) {
[18:01:05.701]                     if (is.function(sendCondition)) 
[18:01:05.701]                       return(sendCondition)
[18:01:05.701]                     ns <- getNamespace("parallel")
[18:01:05.701]                     if (exists("sendData", mode = "function", 
[18:01:05.701]                       envir = ns)) {
[18:01:05.701]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:05.701]                         envir = ns)
[18:01:05.701]                       envir <- sys.frame(frame)
[18:01:05.701]                       master <- NULL
[18:01:05.701]                       while (!identical(envir, .GlobalEnv) && 
[18:01:05.701]                         !identical(envir, emptyenv())) {
[18:01:05.701]                         if (exists("master", mode = "list", envir = envir, 
[18:01:05.701]                           inherits = FALSE)) {
[18:01:05.701]                           master <- get("master", mode = "list", 
[18:01:05.701]                             envir = envir, inherits = FALSE)
[18:01:05.701]                           if (inherits(master, c("SOCKnode", 
[18:01:05.701]                             "SOCK0node"))) {
[18:01:05.701]                             sendCondition <<- function(cond) {
[18:01:05.701]                               data <- list(type = "VALUE", value = cond, 
[18:01:05.701]                                 success = TRUE)
[18:01:05.701]                               parallel_sendData(master, data)
[18:01:05.701]                             }
[18:01:05.701]                             return(sendCondition)
[18:01:05.701]                           }
[18:01:05.701]                         }
[18:01:05.701]                         frame <- frame + 1L
[18:01:05.701]                         envir <- sys.frame(frame)
[18:01:05.701]                       }
[18:01:05.701]                     }
[18:01:05.701]                     sendCondition <<- function(cond) NULL
[18:01:05.701]                   }
[18:01:05.701]                 })
[18:01:05.701]                 withCallingHandlers({
[18:01:05.701]                   {
[18:01:05.701]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.701]                     if (!identical(...future.globals.maxSize.org, 
[18:01:05.701]                       ...future.globals.maxSize)) {
[18:01:05.701]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.701]                       on.exit(options(oopts), add = TRUE)
[18:01:05.701]                     }
[18:01:05.701]                     {
[18:01:05.701]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.701]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:05.701]                         USE.NAMES = FALSE)
[18:01:05.701]                       do.call(mapply, args = args)
[18:01:05.701]                     }
[18:01:05.701]                   }
[18:01:05.701]                 }, immediateCondition = function(cond) {
[18:01:05.701]                   sendCondition <- ...future.makeSendCondition()
[18:01:05.701]                   sendCondition(cond)
[18:01:05.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.701]                   {
[18:01:05.701]                     inherits <- base::inherits
[18:01:05.701]                     invokeRestart <- base::invokeRestart
[18:01:05.701]                     is.null <- base::is.null
[18:01:05.701]                     muffled <- FALSE
[18:01:05.701]                     if (inherits(cond, "message")) {
[18:01:05.701]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:05.701]                       if (muffled) 
[18:01:05.701]                         invokeRestart("muffleMessage")
[18:01:05.701]                     }
[18:01:05.701]                     else if (inherits(cond, "warning")) {
[18:01:05.701]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:05.701]                       if (muffled) 
[18:01:05.701]                         invokeRestart("muffleWarning")
[18:01:05.701]                     }
[18:01:05.701]                     else if (inherits(cond, "condition")) {
[18:01:05.701]                       if (!is.null(pattern)) {
[18:01:05.701]                         computeRestarts <- base::computeRestarts
[18:01:05.701]                         grepl <- base::grepl
[18:01:05.701]                         restarts <- computeRestarts(cond)
[18:01:05.701]                         for (restart in restarts) {
[18:01:05.701]                           name <- restart$name
[18:01:05.701]                           if (is.null(name)) 
[18:01:05.701]                             next
[18:01:05.701]                           if (!grepl(pattern, name)) 
[18:01:05.701]                             next
[18:01:05.701]                           invokeRestart(restart)
[18:01:05.701]                           muffled <- TRUE
[18:01:05.701]                           break
[18:01:05.701]                         }
[18:01:05.701]                       }
[18:01:05.701]                     }
[18:01:05.701]                     invisible(muffled)
[18:01:05.701]                   }
[18:01:05.701]                   muffleCondition(cond)
[18:01:05.701]                 })
[18:01:05.701]             }))
[18:01:05.701]             future::FutureResult(value = ...future.value$value, 
[18:01:05.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.701]                   ...future.rng), globalenv = if (FALSE) 
[18:01:05.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:05.701]                     ...future.globalenv.names))
[18:01:05.701]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:05.701]         }, condition = base::local({
[18:01:05.701]             c <- base::c
[18:01:05.701]             inherits <- base::inherits
[18:01:05.701]             invokeRestart <- base::invokeRestart
[18:01:05.701]             length <- base::length
[18:01:05.701]             list <- base::list
[18:01:05.701]             seq.int <- base::seq.int
[18:01:05.701]             signalCondition <- base::signalCondition
[18:01:05.701]             sys.calls <- base::sys.calls
[18:01:05.701]             `[[` <- base::`[[`
[18:01:05.701]             `+` <- base::`+`
[18:01:05.701]             `<<-` <- base::`<<-`
[18:01:05.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:05.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:05.701]                   3L)]
[18:01:05.701]             }
[18:01:05.701]             function(cond) {
[18:01:05.701]                 is_error <- inherits(cond, "error")
[18:01:05.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:05.701]                   NULL)
[18:01:05.701]                 if (is_error) {
[18:01:05.701]                   sessionInformation <- function() {
[18:01:05.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:05.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:05.701]                       search = base::search(), system = base::Sys.info())
[18:01:05.701]                   }
[18:01:05.701]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:05.701]                     cond$call), session = sessionInformation(), 
[18:01:05.701]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:05.701]                   signalCondition(cond)
[18:01:05.701]                 }
[18:01:05.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:05.701]                 "immediateCondition"))) {
[18:01:05.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:05.701]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:05.701]                   if (TRUE && !signal) {
[18:01:05.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.701]                     {
[18:01:05.701]                       inherits <- base::inherits
[18:01:05.701]                       invokeRestart <- base::invokeRestart
[18:01:05.701]                       is.null <- base::is.null
[18:01:05.701]                       muffled <- FALSE
[18:01:05.701]                       if (inherits(cond, "message")) {
[18:01:05.701]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.701]                         if (muffled) 
[18:01:05.701]                           invokeRestart("muffleMessage")
[18:01:05.701]                       }
[18:01:05.701]                       else if (inherits(cond, "warning")) {
[18:01:05.701]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.701]                         if (muffled) 
[18:01:05.701]                           invokeRestart("muffleWarning")
[18:01:05.701]                       }
[18:01:05.701]                       else if (inherits(cond, "condition")) {
[18:01:05.701]                         if (!is.null(pattern)) {
[18:01:05.701]                           computeRestarts <- base::computeRestarts
[18:01:05.701]                           grepl <- base::grepl
[18:01:05.701]                           restarts <- computeRestarts(cond)
[18:01:05.701]                           for (restart in restarts) {
[18:01:05.701]                             name <- restart$name
[18:01:05.701]                             if (is.null(name)) 
[18:01:05.701]                               next
[18:01:05.701]                             if (!grepl(pattern, name)) 
[18:01:05.701]                               next
[18:01:05.701]                             invokeRestart(restart)
[18:01:05.701]                             muffled <- TRUE
[18:01:05.701]                             break
[18:01:05.701]                           }
[18:01:05.701]                         }
[18:01:05.701]                       }
[18:01:05.701]                       invisible(muffled)
[18:01:05.701]                     }
[18:01:05.701]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.701]                   }
[18:01:05.701]                 }
[18:01:05.701]                 else {
[18:01:05.701]                   if (TRUE) {
[18:01:05.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.701]                     {
[18:01:05.701]                       inherits <- base::inherits
[18:01:05.701]                       invokeRestart <- base::invokeRestart
[18:01:05.701]                       is.null <- base::is.null
[18:01:05.701]                       muffled <- FALSE
[18:01:05.701]                       if (inherits(cond, "message")) {
[18:01:05.701]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.701]                         if (muffled) 
[18:01:05.701]                           invokeRestart("muffleMessage")
[18:01:05.701]                       }
[18:01:05.701]                       else if (inherits(cond, "warning")) {
[18:01:05.701]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.701]                         if (muffled) 
[18:01:05.701]                           invokeRestart("muffleWarning")
[18:01:05.701]                       }
[18:01:05.701]                       else if (inherits(cond, "condition")) {
[18:01:05.701]                         if (!is.null(pattern)) {
[18:01:05.701]                           computeRestarts <- base::computeRestarts
[18:01:05.701]                           grepl <- base::grepl
[18:01:05.701]                           restarts <- computeRestarts(cond)
[18:01:05.701]                           for (restart in restarts) {
[18:01:05.701]                             name <- restart$name
[18:01:05.701]                             if (is.null(name)) 
[18:01:05.701]                               next
[18:01:05.701]                             if (!grepl(pattern, name)) 
[18:01:05.701]                               next
[18:01:05.701]                             invokeRestart(restart)
[18:01:05.701]                             muffled <- TRUE
[18:01:05.701]                             break
[18:01:05.701]                           }
[18:01:05.701]                         }
[18:01:05.701]                       }
[18:01:05.701]                       invisible(muffled)
[18:01:05.701]                     }
[18:01:05.701]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.701]                   }
[18:01:05.701]                 }
[18:01:05.701]             }
[18:01:05.701]         }))
[18:01:05.701]     }, error = function(ex) {
[18:01:05.701]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:05.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.701]                 ...future.rng), started = ...future.startTime, 
[18:01:05.701]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:05.701]             version = "1.8"), class = "FutureResult")
[18:01:05.701]     }, finally = {
[18:01:05.701]         if (!identical(...future.workdir, getwd())) 
[18:01:05.701]             setwd(...future.workdir)
[18:01:05.701]         {
[18:01:05.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:05.701]                 ...future.oldOptions$nwarnings <- NULL
[18:01:05.701]             }
[18:01:05.701]             base::options(...future.oldOptions)
[18:01:05.701]             if (.Platform$OS.type == "windows") {
[18:01:05.701]                 old_names <- names(...future.oldEnvVars)
[18:01:05.701]                 envs <- base::Sys.getenv()
[18:01:05.701]                 names <- names(envs)
[18:01:05.701]                 common <- intersect(names, old_names)
[18:01:05.701]                 added <- setdiff(names, old_names)
[18:01:05.701]                 removed <- setdiff(old_names, names)
[18:01:05.701]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:05.701]                   envs[common]]
[18:01:05.701]                 NAMES <- toupper(changed)
[18:01:05.701]                 args <- list()
[18:01:05.701]                 for (kk in seq_along(NAMES)) {
[18:01:05.701]                   name <- changed[[kk]]
[18:01:05.701]                   NAME <- NAMES[[kk]]
[18:01:05.701]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.701]                     next
[18:01:05.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.701]                 }
[18:01:05.701]                 NAMES <- toupper(added)
[18:01:05.701]                 for (kk in seq_along(NAMES)) {
[18:01:05.701]                   name <- added[[kk]]
[18:01:05.701]                   NAME <- NAMES[[kk]]
[18:01:05.701]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.701]                     next
[18:01:05.701]                   args[[name]] <- ""
[18:01:05.701]                 }
[18:01:05.701]                 NAMES <- toupper(removed)
[18:01:05.701]                 for (kk in seq_along(NAMES)) {
[18:01:05.701]                   name <- removed[[kk]]
[18:01:05.701]                   NAME <- NAMES[[kk]]
[18:01:05.701]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.701]                     next
[18:01:05.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.701]                 }
[18:01:05.701]                 if (length(args) > 0) 
[18:01:05.701]                   base::do.call(base::Sys.setenv, args = args)
[18:01:05.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:05.701]             }
[18:01:05.701]             else {
[18:01:05.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:05.701]             }
[18:01:05.701]             {
[18:01:05.701]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:05.701]                   0L) {
[18:01:05.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:05.701]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:05.701]                   base::options(opts)
[18:01:05.701]                 }
[18:01:05.701]                 {
[18:01:05.701]                   {
[18:01:05.701]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:05.701]                     NULL
[18:01:05.701]                   }
[18:01:05.701]                   options(future.plan = NULL)
[18:01:05.701]                   if (is.na(NA_character_)) 
[18:01:05.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:05.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:05.701]                     .init = FALSE)
[18:01:05.701]                 }
[18:01:05.701]             }
[18:01:05.701]         }
[18:01:05.701]     })
[18:01:05.701]     if (TRUE) {
[18:01:05.701]         base::sink(type = "output", split = FALSE)
[18:01:05.701]         if (TRUE) {
[18:01:05.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:05.701]         }
[18:01:05.701]         else {
[18:01:05.701]             ...future.result["stdout"] <- base::list(NULL)
[18:01:05.701]         }
[18:01:05.701]         base::close(...future.stdout)
[18:01:05.701]         ...future.stdout <- NULL
[18:01:05.701]     }
[18:01:05.701]     ...future.result$conditions <- ...future.conditions
[18:01:05.701]     ...future.result$finished <- base::Sys.time()
[18:01:05.701]     ...future.result
[18:01:05.701] }
[18:01:05.706] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[18:01:05.706] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[18:01:05.707] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[18:01:05.707] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:05.708] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.708] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:05.709] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:05.709] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:05.710] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.710] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:05.711] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.711] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[18:01:05.712] MultisessionFuture started
[18:01:05.712] - Launch lazy future ... done
[18:01:05.713] run() for ‘MultisessionFuture’ ... done
[18:01:05.713] Created future:
[18:01:05.713] MultisessionFuture:
[18:01:05.713] Label: ‘future_mapply-2’
[18:01:05.713] Expression:
[18:01:05.713] {
[18:01:05.713]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.713]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:05.713]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.713]         on.exit(options(oopts), add = TRUE)
[18:01:05.713]     }
[18:01:05.713]     {
[18:01:05.713]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.713]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:05.713]         do.call(mapply, args = args)
[18:01:05.713]     }
[18:01:05.713] }
[18:01:05.713] Lazy evaluation: FALSE
[18:01:05.713] Asynchronous evaluation: TRUE
[18:01:05.713] Local evaluation: TRUE
[18:01:05.713] Environment: R_GlobalEnv
[18:01:05.713] Capture standard output: TRUE
[18:01:05.713] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:05.713] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:05.713] Packages: <none>
[18:01:05.713] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:05.713] Resolved: FALSE
[18:01:05.713] Value: <not collected>
[18:01:05.713] Conditions captured: <none>
[18:01:05.713] Early signaling: FALSE
[18:01:05.713] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:05.713] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.726] Chunk #2 of 2 ... DONE
[18:01:05.726] Launching 2 futures (chunks) ... DONE
[18:01:05.726] Resolving 2 futures (chunks) ...
[18:01:05.727] resolve() on list ...
[18:01:05.727]  recursive: 0
[18:01:05.727]  length: 2
[18:01:05.727] 
[18:01:05.728] receiveMessageFromWorker() for ClusterFuture ...
[18:01:05.728] - Validating connection of MultisessionFuture
[18:01:05.729] - received message: FutureResult
[18:01:05.729] - Received FutureResult
[18:01:05.729] - Erased future from FutureRegistry
[18:01:05.729] result() for ClusterFuture ...
[18:01:05.730] - result already collected: FutureResult
[18:01:05.730] result() for ClusterFuture ... done
[18:01:05.730] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:05.730] Future #1
[18:01:05.730] result() for ClusterFuture ...
[18:01:05.730] - result already collected: FutureResult
[18:01:05.731] result() for ClusterFuture ... done
[18:01:05.731] result() for ClusterFuture ...
[18:01:05.731] - result already collected: FutureResult
[18:01:05.731] result() for ClusterFuture ... done
[18:01:05.731] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:05.732] - nx: 2
[18:01:05.732] - relay: TRUE
[18:01:05.732] - stdout: TRUE
[18:01:05.732] - signal: TRUE
[18:01:05.732] - resignal: FALSE
[18:01:05.732] - force: TRUE
[18:01:05.733] - relayed: [n=2] FALSE, FALSE
[18:01:05.733] - queued futures: [n=2] FALSE, FALSE
[18:01:05.733]  - until=1
[18:01:05.733]  - relaying element #1
[18:01:05.734] result() for ClusterFuture ...
[18:01:05.734] - result already collected: FutureResult
[18:01:05.734] result() for ClusterFuture ... done
[18:01:05.734] result() for ClusterFuture ...
[18:01:05.734] - result already collected: FutureResult
[18:01:05.734] result() for ClusterFuture ... done
[18:01:05.735] result() for ClusterFuture ...
[18:01:05.735] - result already collected: FutureResult
[18:01:05.735] result() for ClusterFuture ... done
[18:01:05.735] result() for ClusterFuture ...
[18:01:05.736] - result already collected: FutureResult
[18:01:05.736] result() for ClusterFuture ... done
[18:01:05.736] - relayed: [n=2] TRUE, FALSE
[18:01:05.736] - queued futures: [n=2] TRUE, FALSE
[18:01:05.736] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:05.736]  length: 1 (resolved future 1)
[18:01:05.759] receiveMessageFromWorker() for ClusterFuture ...
[18:01:05.759] - Validating connection of MultisessionFuture
[18:01:05.759] - received message: FutureResult
[18:01:05.760] - Received FutureResult
[18:01:05.760] - Erased future from FutureRegistry
[18:01:05.760] result() for ClusterFuture ...
[18:01:05.760] - result already collected: FutureResult
[18:01:05.760] result() for ClusterFuture ... done
[18:01:05.761] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:05.761] Future #2
[18:01:05.761] result() for ClusterFuture ...
[18:01:05.761] - result already collected: FutureResult
[18:01:05.761] result() for ClusterFuture ... done
[18:01:05.762] result() for ClusterFuture ...
[18:01:05.762] - result already collected: FutureResult
[18:01:05.762] result() for ClusterFuture ... done
[18:01:05.762] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:05.762] - nx: 2
[18:01:05.763] - relay: TRUE
[18:01:05.763] - stdout: TRUE
[18:01:05.763] - signal: TRUE
[18:01:05.763] - resignal: FALSE
[18:01:05.763] - force: TRUE
[18:01:05.763] - relayed: [n=2] TRUE, FALSE
[18:01:05.764] - queued futures: [n=2] TRUE, FALSE
[18:01:05.764]  - until=2
[18:01:05.764]  - relaying element #2
[18:01:05.764] result() for ClusterFuture ...
[18:01:05.764] - result already collected: FutureResult
[18:01:05.765] result() for ClusterFuture ... done
[18:01:05.765] result() for ClusterFuture ...
[18:01:05.765] - result already collected: FutureResult
[18:01:05.765] result() for ClusterFuture ... done
[18:01:05.765] result() for ClusterFuture ...
[18:01:05.766] - result already collected: FutureResult
[18:01:05.766] result() for ClusterFuture ... done
[18:01:05.766] result() for ClusterFuture ...
[18:01:05.766] - result already collected: FutureResult
[18:01:05.766] result() for ClusterFuture ... done
[18:01:05.766] - relayed: [n=2] TRUE, TRUE
[18:01:05.767] - queued futures: [n=2] TRUE, TRUE
[18:01:05.767] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:05.767]  length: 0 (resolved future 2)
[18:01:05.767] Relaying remaining futures
[18:01:05.767] signalConditionsASAP(NULL, pos=0) ...
[18:01:05.768] - nx: 2
[18:01:05.768] - relay: TRUE
[18:01:05.768] - stdout: TRUE
[18:01:05.768] - signal: TRUE
[18:01:05.768] - resignal: FALSE
[18:01:05.768] - force: TRUE
[18:01:05.769] - relayed: [n=2] TRUE, TRUE
[18:01:05.769] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:05.769] - relayed: [n=2] TRUE, TRUE
[18:01:05.769] - queued futures: [n=2] TRUE, TRUE
[18:01:05.770] signalConditionsASAP(NULL, pos=0) ... done
[18:01:05.770] resolve() on list ... DONE
[18:01:05.770] result() for ClusterFuture ...
[18:01:05.770] - result already collected: FutureResult
[18:01:05.770] result() for ClusterFuture ... done
[18:01:05.771] result() for ClusterFuture ...
[18:01:05.771] - result already collected: FutureResult
[18:01:05.771] result() for ClusterFuture ... done
[18:01:05.771] result() for ClusterFuture ...
[18:01:05.771] - result already collected: FutureResult
[18:01:05.771] result() for ClusterFuture ... done
[18:01:05.772] result() for ClusterFuture ...
[18:01:05.772] - result already collected: FutureResult
[18:01:05.772] result() for ClusterFuture ... done
[18:01:05.772]  - Number of value chunks collected: 2
[18:01:05.772] Resolving 2 futures (chunks) ... DONE
[18:01:05.773] Reducing values from 2 chunks ...
[18:01:05.773]  - Number of values collected after concatenation: 4
[18:01:05.773]  - Number of values expected: 4
[18:01:05.773] Reducing values from 2 chunks ... DONE
[18:01:05.773] future_mapply() ... DONE
[18:01:05.774] future_mapply() ...
[18:01:05.780] Number of chunks: 2
[18:01:05.780] getGlobalsAndPackagesXApply() ...
[18:01:05.780]  - future.globals: TRUE
[18:01:05.781] getGlobalsAndPackages() ...
[18:01:05.781] Searching for globals...
[18:01:05.782] - globals found: [1] ‘FUN’
[18:01:05.782] Searching for globals ... DONE
[18:01:05.783] Resolving globals: FALSE
[18:01:05.783] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:05.784] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:05.784] - globals: [1] ‘FUN’
[18:01:05.784] 
[18:01:05.784] getGlobalsAndPackages() ... DONE
[18:01:05.785]  - globals found/used: [n=1] ‘FUN’
[18:01:05.785]  - needed namespaces: [n=0] 
[18:01:05.785] Finding globals ... DONE
[18:01:05.785] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:05.785] List of 2
[18:01:05.785]  $ ...future.FUN:function (x, ...)  
[18:01:05.785]  $ MoreArgs     : NULL
[18:01:05.785]  - attr(*, "where")=List of 2
[18:01:05.785]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:05.785]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:05.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:05.785]  - attr(*, "resolved")= logi FALSE
[18:01:05.785]  - attr(*, "total_size")= num NA
[18:01:05.790] Packages to be attached in all futures: [n=0] 
[18:01:05.791] getGlobalsAndPackagesXApply() ... DONE
[18:01:05.791] Number of futures (= number of chunks): 2
[18:01:05.791] Launching 2 futures (chunks) ...
[18:01:05.791] Chunk #1 of 2 ...
[18:01:05.792]  - Finding globals in '...' for chunk #1 ...
[18:01:05.792] getGlobalsAndPackages() ...
[18:01:05.792] Searching for globals...
[18:01:05.793] 
[18:01:05.793] Searching for globals ... DONE
[18:01:05.793] - globals: [0] <none>
[18:01:05.793] getGlobalsAndPackages() ... DONE
[18:01:05.793]    + additional globals found: [n=0] 
[18:01:05.794]    + additional namespaces needed: [n=0] 
[18:01:05.794]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:05.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:05.794]  - seeds: <none>
[18:01:05.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.795] getGlobalsAndPackages() ...
[18:01:05.795] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.795] Resolving globals: FALSE
[18:01:05.796] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:05.797] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:05.797] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.797] 
[18:01:05.798] getGlobalsAndPackages() ... DONE
[18:01:05.798] run() for ‘Future’ ...
[18:01:05.798] - state: ‘created’
[18:01:05.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:05.822] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:05.823]   - Field: ‘node’
[18:01:05.823]   - Field: ‘label’
[18:01:05.823]   - Field: ‘local’
[18:01:05.824]   - Field: ‘owner’
[18:01:05.824]   - Field: ‘envir’
[18:01:05.824]   - Field: ‘workers’
[18:01:05.824]   - Field: ‘packages’
[18:01:05.824]   - Field: ‘gc’
[18:01:05.825]   - Field: ‘conditions’
[18:01:05.825]   - Field: ‘persistent’
[18:01:05.825]   - Field: ‘expr’
[18:01:05.825]   - Field: ‘uuid’
[18:01:05.825]   - Field: ‘seed’
[18:01:05.826]   - Field: ‘version’
[18:01:05.826]   - Field: ‘result’
[18:01:05.826]   - Field: ‘asynchronous’
[18:01:05.826]   - Field: ‘calls’
[18:01:05.826]   - Field: ‘globals’
[18:01:05.827]   - Field: ‘stdout’
[18:01:05.827]   - Field: ‘earlySignal’
[18:01:05.827]   - Field: ‘lazy’
[18:01:05.827]   - Field: ‘state’
[18:01:05.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:05.828] - Launch lazy future ...
[18:01:05.828] Packages needed by the future expression (n = 0): <none>
[18:01:05.828] Packages needed by future strategies (n = 0): <none>
[18:01:05.829] {
[18:01:05.829]     {
[18:01:05.829]         {
[18:01:05.829]             ...future.startTime <- base::Sys.time()
[18:01:05.829]             {
[18:01:05.829]                 {
[18:01:05.829]                   {
[18:01:05.829]                     {
[18:01:05.829]                       base::local({
[18:01:05.829]                         has_future <- base::requireNamespace("future", 
[18:01:05.829]                           quietly = TRUE)
[18:01:05.829]                         if (has_future) {
[18:01:05.829]                           ns <- base::getNamespace("future")
[18:01:05.829]                           version <- ns[[".package"]][["version"]]
[18:01:05.829]                           if (is.null(version)) 
[18:01:05.829]                             version <- utils::packageVersion("future")
[18:01:05.829]                         }
[18:01:05.829]                         else {
[18:01:05.829]                           version <- NULL
[18:01:05.829]                         }
[18:01:05.829]                         if (!has_future || version < "1.8.0") {
[18:01:05.829]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:05.829]                             "", base::R.version$version.string), 
[18:01:05.829]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:05.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:05.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:05.829]                               "release", "version")], collapse = " "), 
[18:01:05.829]                             hostname = base::Sys.info()[["nodename"]])
[18:01:05.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:05.829]                             info)
[18:01:05.829]                           info <- base::paste(info, collapse = "; ")
[18:01:05.829]                           if (!has_future) {
[18:01:05.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:05.829]                               info)
[18:01:05.829]                           }
[18:01:05.829]                           else {
[18:01:05.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:05.829]                               info, version)
[18:01:05.829]                           }
[18:01:05.829]                           base::stop(msg)
[18:01:05.829]                         }
[18:01:05.829]                       })
[18:01:05.829]                     }
[18:01:05.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:05.829]                     base::options(mc.cores = 1L)
[18:01:05.829]                   }
[18:01:05.829]                   ...future.strategy.old <- future::plan("list")
[18:01:05.829]                   options(future.plan = NULL)
[18:01:05.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:05.829]                 }
[18:01:05.829]                 ...future.workdir <- getwd()
[18:01:05.829]             }
[18:01:05.829]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:05.829]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:05.829]         }
[18:01:05.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:05.829]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:05.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:05.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:05.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:05.829]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:05.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:05.829]             base::names(...future.oldOptions))
[18:01:05.829]     }
[18:01:05.829]     if (FALSE) {
[18:01:05.829]     }
[18:01:05.829]     else {
[18:01:05.829]         if (TRUE) {
[18:01:05.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:05.829]                 open = "w")
[18:01:05.829]         }
[18:01:05.829]         else {
[18:01:05.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:05.829]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:05.829]         }
[18:01:05.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:05.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:05.829]             base::sink(type = "output", split = FALSE)
[18:01:05.829]             base::close(...future.stdout)
[18:01:05.829]         }, add = TRUE)
[18:01:05.829]     }
[18:01:05.829]     ...future.frame <- base::sys.nframe()
[18:01:05.829]     ...future.conditions <- base::list()
[18:01:05.829]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:05.829]     if (FALSE) {
[18:01:05.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:05.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:05.829]     }
[18:01:05.829]     ...future.result <- base::tryCatch({
[18:01:05.829]         base::withCallingHandlers({
[18:01:05.829]             ...future.value <- base::withVisible(base::local({
[18:01:05.829]                 ...future.makeSendCondition <- base::local({
[18:01:05.829]                   sendCondition <- NULL
[18:01:05.829]                   function(frame = 1L) {
[18:01:05.829]                     if (is.function(sendCondition)) 
[18:01:05.829]                       return(sendCondition)
[18:01:05.829]                     ns <- getNamespace("parallel")
[18:01:05.829]                     if (exists("sendData", mode = "function", 
[18:01:05.829]                       envir = ns)) {
[18:01:05.829]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:05.829]                         envir = ns)
[18:01:05.829]                       envir <- sys.frame(frame)
[18:01:05.829]                       master <- NULL
[18:01:05.829]                       while (!identical(envir, .GlobalEnv) && 
[18:01:05.829]                         !identical(envir, emptyenv())) {
[18:01:05.829]                         if (exists("master", mode = "list", envir = envir, 
[18:01:05.829]                           inherits = FALSE)) {
[18:01:05.829]                           master <- get("master", mode = "list", 
[18:01:05.829]                             envir = envir, inherits = FALSE)
[18:01:05.829]                           if (inherits(master, c("SOCKnode", 
[18:01:05.829]                             "SOCK0node"))) {
[18:01:05.829]                             sendCondition <<- function(cond) {
[18:01:05.829]                               data <- list(type = "VALUE", value = cond, 
[18:01:05.829]                                 success = TRUE)
[18:01:05.829]                               parallel_sendData(master, data)
[18:01:05.829]                             }
[18:01:05.829]                             return(sendCondition)
[18:01:05.829]                           }
[18:01:05.829]                         }
[18:01:05.829]                         frame <- frame + 1L
[18:01:05.829]                         envir <- sys.frame(frame)
[18:01:05.829]                       }
[18:01:05.829]                     }
[18:01:05.829]                     sendCondition <<- function(cond) NULL
[18:01:05.829]                   }
[18:01:05.829]                 })
[18:01:05.829]                 withCallingHandlers({
[18:01:05.829]                   {
[18:01:05.829]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.829]                     if (!identical(...future.globals.maxSize.org, 
[18:01:05.829]                       ...future.globals.maxSize)) {
[18:01:05.829]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.829]                       on.exit(options(oopts), add = TRUE)
[18:01:05.829]                     }
[18:01:05.829]                     {
[18:01:05.829]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.829]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:05.829]                         USE.NAMES = FALSE)
[18:01:05.829]                       do.call(mapply, args = args)
[18:01:05.829]                     }
[18:01:05.829]                   }
[18:01:05.829]                 }, immediateCondition = function(cond) {
[18:01:05.829]                   sendCondition <- ...future.makeSendCondition()
[18:01:05.829]                   sendCondition(cond)
[18:01:05.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.829]                   {
[18:01:05.829]                     inherits <- base::inherits
[18:01:05.829]                     invokeRestart <- base::invokeRestart
[18:01:05.829]                     is.null <- base::is.null
[18:01:05.829]                     muffled <- FALSE
[18:01:05.829]                     if (inherits(cond, "message")) {
[18:01:05.829]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:05.829]                       if (muffled) 
[18:01:05.829]                         invokeRestart("muffleMessage")
[18:01:05.829]                     }
[18:01:05.829]                     else if (inherits(cond, "warning")) {
[18:01:05.829]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:05.829]                       if (muffled) 
[18:01:05.829]                         invokeRestart("muffleWarning")
[18:01:05.829]                     }
[18:01:05.829]                     else if (inherits(cond, "condition")) {
[18:01:05.829]                       if (!is.null(pattern)) {
[18:01:05.829]                         computeRestarts <- base::computeRestarts
[18:01:05.829]                         grepl <- base::grepl
[18:01:05.829]                         restarts <- computeRestarts(cond)
[18:01:05.829]                         for (restart in restarts) {
[18:01:05.829]                           name <- restart$name
[18:01:05.829]                           if (is.null(name)) 
[18:01:05.829]                             next
[18:01:05.829]                           if (!grepl(pattern, name)) 
[18:01:05.829]                             next
[18:01:05.829]                           invokeRestart(restart)
[18:01:05.829]                           muffled <- TRUE
[18:01:05.829]                           break
[18:01:05.829]                         }
[18:01:05.829]                       }
[18:01:05.829]                     }
[18:01:05.829]                     invisible(muffled)
[18:01:05.829]                   }
[18:01:05.829]                   muffleCondition(cond)
[18:01:05.829]                 })
[18:01:05.829]             }))
[18:01:05.829]             future::FutureResult(value = ...future.value$value, 
[18:01:05.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.829]                   ...future.rng), globalenv = if (FALSE) 
[18:01:05.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:05.829]                     ...future.globalenv.names))
[18:01:05.829]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:05.829]         }, condition = base::local({
[18:01:05.829]             c <- base::c
[18:01:05.829]             inherits <- base::inherits
[18:01:05.829]             invokeRestart <- base::invokeRestart
[18:01:05.829]             length <- base::length
[18:01:05.829]             list <- base::list
[18:01:05.829]             seq.int <- base::seq.int
[18:01:05.829]             signalCondition <- base::signalCondition
[18:01:05.829]             sys.calls <- base::sys.calls
[18:01:05.829]             `[[` <- base::`[[`
[18:01:05.829]             `+` <- base::`+`
[18:01:05.829]             `<<-` <- base::`<<-`
[18:01:05.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:05.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:05.829]                   3L)]
[18:01:05.829]             }
[18:01:05.829]             function(cond) {
[18:01:05.829]                 is_error <- inherits(cond, "error")
[18:01:05.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:05.829]                   NULL)
[18:01:05.829]                 if (is_error) {
[18:01:05.829]                   sessionInformation <- function() {
[18:01:05.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:05.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:05.829]                       search = base::search(), system = base::Sys.info())
[18:01:05.829]                   }
[18:01:05.829]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:05.829]                     cond$call), session = sessionInformation(), 
[18:01:05.829]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:05.829]                   signalCondition(cond)
[18:01:05.829]                 }
[18:01:05.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:05.829]                 "immediateCondition"))) {
[18:01:05.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:05.829]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:05.829]                   if (TRUE && !signal) {
[18:01:05.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.829]                     {
[18:01:05.829]                       inherits <- base::inherits
[18:01:05.829]                       invokeRestart <- base::invokeRestart
[18:01:05.829]                       is.null <- base::is.null
[18:01:05.829]                       muffled <- FALSE
[18:01:05.829]                       if (inherits(cond, "message")) {
[18:01:05.829]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.829]                         if (muffled) 
[18:01:05.829]                           invokeRestart("muffleMessage")
[18:01:05.829]                       }
[18:01:05.829]                       else if (inherits(cond, "warning")) {
[18:01:05.829]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.829]                         if (muffled) 
[18:01:05.829]                           invokeRestart("muffleWarning")
[18:01:05.829]                       }
[18:01:05.829]                       else if (inherits(cond, "condition")) {
[18:01:05.829]                         if (!is.null(pattern)) {
[18:01:05.829]                           computeRestarts <- base::computeRestarts
[18:01:05.829]                           grepl <- base::grepl
[18:01:05.829]                           restarts <- computeRestarts(cond)
[18:01:05.829]                           for (restart in restarts) {
[18:01:05.829]                             name <- restart$name
[18:01:05.829]                             if (is.null(name)) 
[18:01:05.829]                               next
[18:01:05.829]                             if (!grepl(pattern, name)) 
[18:01:05.829]                               next
[18:01:05.829]                             invokeRestart(restart)
[18:01:05.829]                             muffled <- TRUE
[18:01:05.829]                             break
[18:01:05.829]                           }
[18:01:05.829]                         }
[18:01:05.829]                       }
[18:01:05.829]                       invisible(muffled)
[18:01:05.829]                     }
[18:01:05.829]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.829]                   }
[18:01:05.829]                 }
[18:01:05.829]                 else {
[18:01:05.829]                   if (TRUE) {
[18:01:05.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.829]                     {
[18:01:05.829]                       inherits <- base::inherits
[18:01:05.829]                       invokeRestart <- base::invokeRestart
[18:01:05.829]                       is.null <- base::is.null
[18:01:05.829]                       muffled <- FALSE
[18:01:05.829]                       if (inherits(cond, "message")) {
[18:01:05.829]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.829]                         if (muffled) 
[18:01:05.829]                           invokeRestart("muffleMessage")
[18:01:05.829]                       }
[18:01:05.829]                       else if (inherits(cond, "warning")) {
[18:01:05.829]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.829]                         if (muffled) 
[18:01:05.829]                           invokeRestart("muffleWarning")
[18:01:05.829]                       }
[18:01:05.829]                       else if (inherits(cond, "condition")) {
[18:01:05.829]                         if (!is.null(pattern)) {
[18:01:05.829]                           computeRestarts <- base::computeRestarts
[18:01:05.829]                           grepl <- base::grepl
[18:01:05.829]                           restarts <- computeRestarts(cond)
[18:01:05.829]                           for (restart in restarts) {
[18:01:05.829]                             name <- restart$name
[18:01:05.829]                             if (is.null(name)) 
[18:01:05.829]                               next
[18:01:05.829]                             if (!grepl(pattern, name)) 
[18:01:05.829]                               next
[18:01:05.829]                             invokeRestart(restart)
[18:01:05.829]                             muffled <- TRUE
[18:01:05.829]                             break
[18:01:05.829]                           }
[18:01:05.829]                         }
[18:01:05.829]                       }
[18:01:05.829]                       invisible(muffled)
[18:01:05.829]                     }
[18:01:05.829]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.829]                   }
[18:01:05.829]                 }
[18:01:05.829]             }
[18:01:05.829]         }))
[18:01:05.829]     }, error = function(ex) {
[18:01:05.829]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:05.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.829]                 ...future.rng), started = ...future.startTime, 
[18:01:05.829]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:05.829]             version = "1.8"), class = "FutureResult")
[18:01:05.829]     }, finally = {
[18:01:05.829]         if (!identical(...future.workdir, getwd())) 
[18:01:05.829]             setwd(...future.workdir)
[18:01:05.829]         {
[18:01:05.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:05.829]                 ...future.oldOptions$nwarnings <- NULL
[18:01:05.829]             }
[18:01:05.829]             base::options(...future.oldOptions)
[18:01:05.829]             if (.Platform$OS.type == "windows") {
[18:01:05.829]                 old_names <- names(...future.oldEnvVars)
[18:01:05.829]                 envs <- base::Sys.getenv()
[18:01:05.829]                 names <- names(envs)
[18:01:05.829]                 common <- intersect(names, old_names)
[18:01:05.829]                 added <- setdiff(names, old_names)
[18:01:05.829]                 removed <- setdiff(old_names, names)
[18:01:05.829]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:05.829]                   envs[common]]
[18:01:05.829]                 NAMES <- toupper(changed)
[18:01:05.829]                 args <- list()
[18:01:05.829]                 for (kk in seq_along(NAMES)) {
[18:01:05.829]                   name <- changed[[kk]]
[18:01:05.829]                   NAME <- NAMES[[kk]]
[18:01:05.829]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.829]                     next
[18:01:05.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.829]                 }
[18:01:05.829]                 NAMES <- toupper(added)
[18:01:05.829]                 for (kk in seq_along(NAMES)) {
[18:01:05.829]                   name <- added[[kk]]
[18:01:05.829]                   NAME <- NAMES[[kk]]
[18:01:05.829]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.829]                     next
[18:01:05.829]                   args[[name]] <- ""
[18:01:05.829]                 }
[18:01:05.829]                 NAMES <- toupper(removed)
[18:01:05.829]                 for (kk in seq_along(NAMES)) {
[18:01:05.829]                   name <- removed[[kk]]
[18:01:05.829]                   NAME <- NAMES[[kk]]
[18:01:05.829]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.829]                     next
[18:01:05.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.829]                 }
[18:01:05.829]                 if (length(args) > 0) 
[18:01:05.829]                   base::do.call(base::Sys.setenv, args = args)
[18:01:05.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:05.829]             }
[18:01:05.829]             else {
[18:01:05.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:05.829]             }
[18:01:05.829]             {
[18:01:05.829]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:05.829]                   0L) {
[18:01:05.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:05.829]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:05.829]                   base::options(opts)
[18:01:05.829]                 }
[18:01:05.829]                 {
[18:01:05.829]                   {
[18:01:05.829]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:05.829]                     NULL
[18:01:05.829]                   }
[18:01:05.829]                   options(future.plan = NULL)
[18:01:05.829]                   if (is.na(NA_character_)) 
[18:01:05.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:05.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:05.829]                     .init = FALSE)
[18:01:05.829]                 }
[18:01:05.829]             }
[18:01:05.829]         }
[18:01:05.829]     })
[18:01:05.829]     if (TRUE) {
[18:01:05.829]         base::sink(type = "output", split = FALSE)
[18:01:05.829]         if (TRUE) {
[18:01:05.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:05.829]         }
[18:01:05.829]         else {
[18:01:05.829]             ...future.result["stdout"] <- base::list(NULL)
[18:01:05.829]         }
[18:01:05.829]         base::close(...future.stdout)
[18:01:05.829]         ...future.stdout <- NULL
[18:01:05.829]     }
[18:01:05.829]     ...future.result$conditions <- ...future.conditions
[18:01:05.829]     ...future.result$finished <- base::Sys.time()
[18:01:05.829]     ...future.result
[18:01:05.829] }
[18:01:05.835] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[18:01:05.835] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[18:01:05.836] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[18:01:05.836] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:05.837] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.837] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[18:01:05.838] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[18:01:05.838] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:05.839] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.840] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:05.840] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:05.841] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[18:01:05.842] MultisessionFuture started
[18:01:05.842] - Launch lazy future ... done
[18:01:05.842] run() for ‘MultisessionFuture’ ... done
[18:01:05.842] Created future:
[18:01:05.842] MultisessionFuture:
[18:01:05.842] Label: ‘future_mapply-1’
[18:01:05.842] Expression:
[18:01:05.842] {
[18:01:05.842]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.842]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:05.842]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.842]         on.exit(options(oopts), add = TRUE)
[18:01:05.842]     }
[18:01:05.842]     {
[18:01:05.842]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.842]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:05.842]         do.call(mapply, args = args)
[18:01:05.842]     }
[18:01:05.842] }
[18:01:05.842] Lazy evaluation: FALSE
[18:01:05.842] Asynchronous evaluation: TRUE
[18:01:05.842] Local evaluation: TRUE
[18:01:05.842] Environment: R_GlobalEnv
[18:01:05.842] Capture standard output: TRUE
[18:01:05.842] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:05.842] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:05.842] Packages: <none>
[18:01:05.842] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:05.842] Resolved: FALSE
[18:01:05.842] Value: <not collected>
[18:01:05.842] Conditions captured: <none>
[18:01:05.842] Early signaling: FALSE
[18:01:05.842] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:05.842] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.855] Chunk #1 of 2 ... DONE
[18:01:05.855] Chunk #2 of 2 ...
[18:01:05.856]  - Finding globals in '...' for chunk #2 ...
[18:01:05.856] getGlobalsAndPackages() ...
[18:01:05.856] Searching for globals...
[18:01:05.857] 
[18:01:05.857] Searching for globals ... DONE
[18:01:05.857] - globals: [0] <none>
[18:01:05.858] getGlobalsAndPackages() ... DONE
[18:01:05.858]    + additional globals found: [n=0] 
[18:01:05.858]    + additional namespaces needed: [n=0] 
[18:01:05.858]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:05.858]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:05.859]  - seeds: <none>
[18:01:05.859]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.859] getGlobalsAndPackages() ...
[18:01:05.859] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.860] Resolving globals: FALSE
[18:01:05.905] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:05.906] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:05.906] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:05.906] 
[18:01:05.907] getGlobalsAndPackages() ... DONE
[18:01:05.907] run() for ‘Future’ ...
[18:01:05.907] - state: ‘created’
[18:01:05.908] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:05.930] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:05.931]   - Field: ‘node’
[18:01:05.931]   - Field: ‘label’
[18:01:05.931]   - Field: ‘local’
[18:01:05.931]   - Field: ‘owner’
[18:01:05.931]   - Field: ‘envir’
[18:01:05.932]   - Field: ‘workers’
[18:01:05.932]   - Field: ‘packages’
[18:01:05.932]   - Field: ‘gc’
[18:01:05.932]   - Field: ‘conditions’
[18:01:05.932]   - Field: ‘persistent’
[18:01:05.933]   - Field: ‘expr’
[18:01:05.933]   - Field: ‘uuid’
[18:01:05.933]   - Field: ‘seed’
[18:01:05.933]   - Field: ‘version’
[18:01:05.933]   - Field: ‘result’
[18:01:05.934]   - Field: ‘asynchronous’
[18:01:05.934]   - Field: ‘calls’
[18:01:05.934]   - Field: ‘globals’
[18:01:05.934]   - Field: ‘stdout’
[18:01:05.934]   - Field: ‘earlySignal’
[18:01:05.935]   - Field: ‘lazy’
[18:01:05.935]   - Field: ‘state’
[18:01:05.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:05.935] - Launch lazy future ...
[18:01:05.936] Packages needed by the future expression (n = 0): <none>
[18:01:05.936] Packages needed by future strategies (n = 0): <none>
[18:01:05.937] {
[18:01:05.937]     {
[18:01:05.937]         {
[18:01:05.937]             ...future.startTime <- base::Sys.time()
[18:01:05.937]             {
[18:01:05.937]                 {
[18:01:05.937]                   {
[18:01:05.937]                     {
[18:01:05.937]                       base::local({
[18:01:05.937]                         has_future <- base::requireNamespace("future", 
[18:01:05.937]                           quietly = TRUE)
[18:01:05.937]                         if (has_future) {
[18:01:05.937]                           ns <- base::getNamespace("future")
[18:01:05.937]                           version <- ns[[".package"]][["version"]]
[18:01:05.937]                           if (is.null(version)) 
[18:01:05.937]                             version <- utils::packageVersion("future")
[18:01:05.937]                         }
[18:01:05.937]                         else {
[18:01:05.937]                           version <- NULL
[18:01:05.937]                         }
[18:01:05.937]                         if (!has_future || version < "1.8.0") {
[18:01:05.937]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:05.937]                             "", base::R.version$version.string), 
[18:01:05.937]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:05.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:05.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:05.937]                               "release", "version")], collapse = " "), 
[18:01:05.937]                             hostname = base::Sys.info()[["nodename"]])
[18:01:05.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:05.937]                             info)
[18:01:05.937]                           info <- base::paste(info, collapse = "; ")
[18:01:05.937]                           if (!has_future) {
[18:01:05.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:05.937]                               info)
[18:01:05.937]                           }
[18:01:05.937]                           else {
[18:01:05.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:05.937]                               info, version)
[18:01:05.937]                           }
[18:01:05.937]                           base::stop(msg)
[18:01:05.937]                         }
[18:01:05.937]                       })
[18:01:05.937]                     }
[18:01:05.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:05.937]                     base::options(mc.cores = 1L)
[18:01:05.937]                   }
[18:01:05.937]                   ...future.strategy.old <- future::plan("list")
[18:01:05.937]                   options(future.plan = NULL)
[18:01:05.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:05.937]                 }
[18:01:05.937]                 ...future.workdir <- getwd()
[18:01:05.937]             }
[18:01:05.937]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:05.937]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:05.937]         }
[18:01:05.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:05.937]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:05.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:05.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:05.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:05.937]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:05.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:05.937]             base::names(...future.oldOptions))
[18:01:05.937]     }
[18:01:05.937]     if (FALSE) {
[18:01:05.937]     }
[18:01:05.937]     else {
[18:01:05.937]         if (TRUE) {
[18:01:05.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:05.937]                 open = "w")
[18:01:05.937]         }
[18:01:05.937]         else {
[18:01:05.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:05.937]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:05.937]         }
[18:01:05.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:05.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:05.937]             base::sink(type = "output", split = FALSE)
[18:01:05.937]             base::close(...future.stdout)
[18:01:05.937]         }, add = TRUE)
[18:01:05.937]     }
[18:01:05.937]     ...future.frame <- base::sys.nframe()
[18:01:05.937]     ...future.conditions <- base::list()
[18:01:05.937]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:05.937]     if (FALSE) {
[18:01:05.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:05.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:05.937]     }
[18:01:05.937]     ...future.result <- base::tryCatch({
[18:01:05.937]         base::withCallingHandlers({
[18:01:05.937]             ...future.value <- base::withVisible(base::local({
[18:01:05.937]                 ...future.makeSendCondition <- base::local({
[18:01:05.937]                   sendCondition <- NULL
[18:01:05.937]                   function(frame = 1L) {
[18:01:05.937]                     if (is.function(sendCondition)) 
[18:01:05.937]                       return(sendCondition)
[18:01:05.937]                     ns <- getNamespace("parallel")
[18:01:05.937]                     if (exists("sendData", mode = "function", 
[18:01:05.937]                       envir = ns)) {
[18:01:05.937]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:05.937]                         envir = ns)
[18:01:05.937]                       envir <- sys.frame(frame)
[18:01:05.937]                       master <- NULL
[18:01:05.937]                       while (!identical(envir, .GlobalEnv) && 
[18:01:05.937]                         !identical(envir, emptyenv())) {
[18:01:05.937]                         if (exists("master", mode = "list", envir = envir, 
[18:01:05.937]                           inherits = FALSE)) {
[18:01:05.937]                           master <- get("master", mode = "list", 
[18:01:05.937]                             envir = envir, inherits = FALSE)
[18:01:05.937]                           if (inherits(master, c("SOCKnode", 
[18:01:05.937]                             "SOCK0node"))) {
[18:01:05.937]                             sendCondition <<- function(cond) {
[18:01:05.937]                               data <- list(type = "VALUE", value = cond, 
[18:01:05.937]                                 success = TRUE)
[18:01:05.937]                               parallel_sendData(master, data)
[18:01:05.937]                             }
[18:01:05.937]                             return(sendCondition)
[18:01:05.937]                           }
[18:01:05.937]                         }
[18:01:05.937]                         frame <- frame + 1L
[18:01:05.937]                         envir <- sys.frame(frame)
[18:01:05.937]                       }
[18:01:05.937]                     }
[18:01:05.937]                     sendCondition <<- function(cond) NULL
[18:01:05.937]                   }
[18:01:05.937]                 })
[18:01:05.937]                 withCallingHandlers({
[18:01:05.937]                   {
[18:01:05.937]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.937]                     if (!identical(...future.globals.maxSize.org, 
[18:01:05.937]                       ...future.globals.maxSize)) {
[18:01:05.937]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.937]                       on.exit(options(oopts), add = TRUE)
[18:01:05.937]                     }
[18:01:05.937]                     {
[18:01:05.937]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.937]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:05.937]                         USE.NAMES = FALSE)
[18:01:05.937]                       do.call(mapply, args = args)
[18:01:05.937]                     }
[18:01:05.937]                   }
[18:01:05.937]                 }, immediateCondition = function(cond) {
[18:01:05.937]                   sendCondition <- ...future.makeSendCondition()
[18:01:05.937]                   sendCondition(cond)
[18:01:05.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.937]                   {
[18:01:05.937]                     inherits <- base::inherits
[18:01:05.937]                     invokeRestart <- base::invokeRestart
[18:01:05.937]                     is.null <- base::is.null
[18:01:05.937]                     muffled <- FALSE
[18:01:05.937]                     if (inherits(cond, "message")) {
[18:01:05.937]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:05.937]                       if (muffled) 
[18:01:05.937]                         invokeRestart("muffleMessage")
[18:01:05.937]                     }
[18:01:05.937]                     else if (inherits(cond, "warning")) {
[18:01:05.937]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:05.937]                       if (muffled) 
[18:01:05.937]                         invokeRestart("muffleWarning")
[18:01:05.937]                     }
[18:01:05.937]                     else if (inherits(cond, "condition")) {
[18:01:05.937]                       if (!is.null(pattern)) {
[18:01:05.937]                         computeRestarts <- base::computeRestarts
[18:01:05.937]                         grepl <- base::grepl
[18:01:05.937]                         restarts <- computeRestarts(cond)
[18:01:05.937]                         for (restart in restarts) {
[18:01:05.937]                           name <- restart$name
[18:01:05.937]                           if (is.null(name)) 
[18:01:05.937]                             next
[18:01:05.937]                           if (!grepl(pattern, name)) 
[18:01:05.937]                             next
[18:01:05.937]                           invokeRestart(restart)
[18:01:05.937]                           muffled <- TRUE
[18:01:05.937]                           break
[18:01:05.937]                         }
[18:01:05.937]                       }
[18:01:05.937]                     }
[18:01:05.937]                     invisible(muffled)
[18:01:05.937]                   }
[18:01:05.937]                   muffleCondition(cond)
[18:01:05.937]                 })
[18:01:05.937]             }))
[18:01:05.937]             future::FutureResult(value = ...future.value$value, 
[18:01:05.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.937]                   ...future.rng), globalenv = if (FALSE) 
[18:01:05.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:05.937]                     ...future.globalenv.names))
[18:01:05.937]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:05.937]         }, condition = base::local({
[18:01:05.937]             c <- base::c
[18:01:05.937]             inherits <- base::inherits
[18:01:05.937]             invokeRestart <- base::invokeRestart
[18:01:05.937]             length <- base::length
[18:01:05.937]             list <- base::list
[18:01:05.937]             seq.int <- base::seq.int
[18:01:05.937]             signalCondition <- base::signalCondition
[18:01:05.937]             sys.calls <- base::sys.calls
[18:01:05.937]             `[[` <- base::`[[`
[18:01:05.937]             `+` <- base::`+`
[18:01:05.937]             `<<-` <- base::`<<-`
[18:01:05.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:05.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:05.937]                   3L)]
[18:01:05.937]             }
[18:01:05.937]             function(cond) {
[18:01:05.937]                 is_error <- inherits(cond, "error")
[18:01:05.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:05.937]                   NULL)
[18:01:05.937]                 if (is_error) {
[18:01:05.937]                   sessionInformation <- function() {
[18:01:05.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:05.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:05.937]                       search = base::search(), system = base::Sys.info())
[18:01:05.937]                   }
[18:01:05.937]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:05.937]                     cond$call), session = sessionInformation(), 
[18:01:05.937]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:05.937]                   signalCondition(cond)
[18:01:05.937]                 }
[18:01:05.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:05.937]                 "immediateCondition"))) {
[18:01:05.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:05.937]                   ...future.conditions[[length(...future.conditions) + 
[18:01:05.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:05.937]                   if (TRUE && !signal) {
[18:01:05.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.937]                     {
[18:01:05.937]                       inherits <- base::inherits
[18:01:05.937]                       invokeRestart <- base::invokeRestart
[18:01:05.937]                       is.null <- base::is.null
[18:01:05.937]                       muffled <- FALSE
[18:01:05.937]                       if (inherits(cond, "message")) {
[18:01:05.937]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.937]                         if (muffled) 
[18:01:05.937]                           invokeRestart("muffleMessage")
[18:01:05.937]                       }
[18:01:05.937]                       else if (inherits(cond, "warning")) {
[18:01:05.937]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.937]                         if (muffled) 
[18:01:05.937]                           invokeRestart("muffleWarning")
[18:01:05.937]                       }
[18:01:05.937]                       else if (inherits(cond, "condition")) {
[18:01:05.937]                         if (!is.null(pattern)) {
[18:01:05.937]                           computeRestarts <- base::computeRestarts
[18:01:05.937]                           grepl <- base::grepl
[18:01:05.937]                           restarts <- computeRestarts(cond)
[18:01:05.937]                           for (restart in restarts) {
[18:01:05.937]                             name <- restart$name
[18:01:05.937]                             if (is.null(name)) 
[18:01:05.937]                               next
[18:01:05.937]                             if (!grepl(pattern, name)) 
[18:01:05.937]                               next
[18:01:05.937]                             invokeRestart(restart)
[18:01:05.937]                             muffled <- TRUE
[18:01:05.937]                             break
[18:01:05.937]                           }
[18:01:05.937]                         }
[18:01:05.937]                       }
[18:01:05.937]                       invisible(muffled)
[18:01:05.937]                     }
[18:01:05.937]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.937]                   }
[18:01:05.937]                 }
[18:01:05.937]                 else {
[18:01:05.937]                   if (TRUE) {
[18:01:05.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:05.937]                     {
[18:01:05.937]                       inherits <- base::inherits
[18:01:05.937]                       invokeRestart <- base::invokeRestart
[18:01:05.937]                       is.null <- base::is.null
[18:01:05.937]                       muffled <- FALSE
[18:01:05.937]                       if (inherits(cond, "message")) {
[18:01:05.937]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:05.937]                         if (muffled) 
[18:01:05.937]                           invokeRestart("muffleMessage")
[18:01:05.937]                       }
[18:01:05.937]                       else if (inherits(cond, "warning")) {
[18:01:05.937]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:05.937]                         if (muffled) 
[18:01:05.937]                           invokeRestart("muffleWarning")
[18:01:05.937]                       }
[18:01:05.937]                       else if (inherits(cond, "condition")) {
[18:01:05.937]                         if (!is.null(pattern)) {
[18:01:05.937]                           computeRestarts <- base::computeRestarts
[18:01:05.937]                           grepl <- base::grepl
[18:01:05.937]                           restarts <- computeRestarts(cond)
[18:01:05.937]                           for (restart in restarts) {
[18:01:05.937]                             name <- restart$name
[18:01:05.937]                             if (is.null(name)) 
[18:01:05.937]                               next
[18:01:05.937]                             if (!grepl(pattern, name)) 
[18:01:05.937]                               next
[18:01:05.937]                             invokeRestart(restart)
[18:01:05.937]                             muffled <- TRUE
[18:01:05.937]                             break
[18:01:05.937]                           }
[18:01:05.937]                         }
[18:01:05.937]                       }
[18:01:05.937]                       invisible(muffled)
[18:01:05.937]                     }
[18:01:05.937]                     muffleCondition(cond, pattern = "^muffle")
[18:01:05.937]                   }
[18:01:05.937]                 }
[18:01:05.937]             }
[18:01:05.937]         }))
[18:01:05.937]     }, error = function(ex) {
[18:01:05.937]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:05.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:05.937]                 ...future.rng), started = ...future.startTime, 
[18:01:05.937]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:05.937]             version = "1.8"), class = "FutureResult")
[18:01:05.937]     }, finally = {
[18:01:05.937]         if (!identical(...future.workdir, getwd())) 
[18:01:05.937]             setwd(...future.workdir)
[18:01:05.937]         {
[18:01:05.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:05.937]                 ...future.oldOptions$nwarnings <- NULL
[18:01:05.937]             }
[18:01:05.937]             base::options(...future.oldOptions)
[18:01:05.937]             if (.Platform$OS.type == "windows") {
[18:01:05.937]                 old_names <- names(...future.oldEnvVars)
[18:01:05.937]                 envs <- base::Sys.getenv()
[18:01:05.937]                 names <- names(envs)
[18:01:05.937]                 common <- intersect(names, old_names)
[18:01:05.937]                 added <- setdiff(names, old_names)
[18:01:05.937]                 removed <- setdiff(old_names, names)
[18:01:05.937]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:05.937]                   envs[common]]
[18:01:05.937]                 NAMES <- toupper(changed)
[18:01:05.937]                 args <- list()
[18:01:05.937]                 for (kk in seq_along(NAMES)) {
[18:01:05.937]                   name <- changed[[kk]]
[18:01:05.937]                   NAME <- NAMES[[kk]]
[18:01:05.937]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.937]                     next
[18:01:05.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.937]                 }
[18:01:05.937]                 NAMES <- toupper(added)
[18:01:05.937]                 for (kk in seq_along(NAMES)) {
[18:01:05.937]                   name <- added[[kk]]
[18:01:05.937]                   NAME <- NAMES[[kk]]
[18:01:05.937]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.937]                     next
[18:01:05.937]                   args[[name]] <- ""
[18:01:05.937]                 }
[18:01:05.937]                 NAMES <- toupper(removed)
[18:01:05.937]                 for (kk in seq_along(NAMES)) {
[18:01:05.937]                   name <- removed[[kk]]
[18:01:05.937]                   NAME <- NAMES[[kk]]
[18:01:05.937]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:05.937]                     next
[18:01:05.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:05.937]                 }
[18:01:05.937]                 if (length(args) > 0) 
[18:01:05.937]                   base::do.call(base::Sys.setenv, args = args)
[18:01:05.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:05.937]             }
[18:01:05.937]             else {
[18:01:05.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:05.937]             }
[18:01:05.937]             {
[18:01:05.937]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:05.937]                   0L) {
[18:01:05.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:05.937]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:05.937]                   base::options(opts)
[18:01:05.937]                 }
[18:01:05.937]                 {
[18:01:05.937]                   {
[18:01:05.937]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:05.937]                     NULL
[18:01:05.937]                   }
[18:01:05.937]                   options(future.plan = NULL)
[18:01:05.937]                   if (is.na(NA_character_)) 
[18:01:05.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:05.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:05.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:05.937]                     .init = FALSE)
[18:01:05.937]                 }
[18:01:05.937]             }
[18:01:05.937]         }
[18:01:05.937]     })
[18:01:05.937]     if (TRUE) {
[18:01:05.937]         base::sink(type = "output", split = FALSE)
[18:01:05.937]         if (TRUE) {
[18:01:05.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:05.937]         }
[18:01:05.937]         else {
[18:01:05.937]             ...future.result["stdout"] <- base::list(NULL)
[18:01:05.937]         }
[18:01:05.937]         base::close(...future.stdout)
[18:01:05.937]         ...future.stdout <- NULL
[18:01:05.937]     }
[18:01:05.937]     ...future.result$conditions <- ...future.conditions
[18:01:05.937]     ...future.result$finished <- base::Sys.time()
[18:01:05.937]     ...future.result
[18:01:05.937] }
[18:01:05.943] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[18:01:05.943] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[18:01:05.949] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[18:01:05.949] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:05.950] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.950] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:05.951] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:05.952] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:05.952] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.953] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:05.953] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:05.954] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[18:01:05.954] MultisessionFuture started
[18:01:05.955] - Launch lazy future ... done
[18:01:05.955] run() for ‘MultisessionFuture’ ... done
[18:01:05.955] Created future:
[18:01:05.955] MultisessionFuture:
[18:01:05.955] Label: ‘future_mapply-2’
[18:01:05.955] Expression:
[18:01:05.955] {
[18:01:05.955]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:05.955]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:05.955]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:05.955]         on.exit(options(oopts), add = TRUE)
[18:01:05.955]     }
[18:01:05.955]     {
[18:01:05.955]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:05.955]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:05.955]         do.call(mapply, args = args)
[18:01:05.955]     }
[18:01:05.955] }
[18:01:05.955] Lazy evaluation: FALSE
[18:01:05.955] Asynchronous evaluation: TRUE
[18:01:05.955] Local evaluation: TRUE
[18:01:05.955] Environment: R_GlobalEnv
[18:01:05.955] Capture standard output: TRUE
[18:01:05.955] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:05.955] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:05.955] Packages: <none>
[18:01:05.955] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:05.955] Resolved: FALSE
[18:01:05.955] Value: <not collected>
[18:01:05.955] Conditions captured: <none>
[18:01:05.955] Early signaling: FALSE
[18:01:05.955] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:05.955] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:05.968] Chunk #2 of 2 ... DONE
[18:01:05.968] Launching 2 futures (chunks) ... DONE
[18:01:05.968] Resolving 2 futures (chunks) ...
[18:01:05.969] resolve() on list ...
[18:01:05.969]  recursive: 0
[18:01:05.969]  length: 2
[18:01:05.969] 
[18:01:05.970] receiveMessageFromWorker() for ClusterFuture ...
[18:01:05.970] - Validating connection of MultisessionFuture
[18:01:05.971] - received message: FutureResult
[18:01:05.971] - Received FutureResult
[18:01:05.971] - Erased future from FutureRegistry
[18:01:05.971] result() for ClusterFuture ...
[18:01:05.972] - result already collected: FutureResult
[18:01:05.972] result() for ClusterFuture ... done
[18:01:05.972] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:05.972] Future #1
[18:01:05.972] result() for ClusterFuture ...
[18:01:05.973] - result already collected: FutureResult
[18:01:05.973] result() for ClusterFuture ... done
[18:01:05.973] result() for ClusterFuture ...
[18:01:05.974] - result already collected: FutureResult
[18:01:05.974] result() for ClusterFuture ... done
[18:01:05.974] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:05.974] - nx: 2
[18:01:05.975] - relay: TRUE
[18:01:05.975] - stdout: TRUE
[18:01:05.975] - signal: TRUE
[18:01:05.975] - resignal: FALSE
[18:01:05.975] - force: TRUE
[18:01:05.975] - relayed: [n=2] FALSE, FALSE
[18:01:05.976] - queued futures: [n=2] FALSE, FALSE
[18:01:05.976]  - until=1
[18:01:05.976]  - relaying element #1
[18:01:05.976] result() for ClusterFuture ...
[18:01:05.976] - result already collected: FutureResult
[18:01:05.977] result() for ClusterFuture ... done
[18:01:05.977] result() for ClusterFuture ...
[18:01:05.977] - result already collected: FutureResult
[18:01:05.977] result() for ClusterFuture ... done
[18:01:05.977] result() for ClusterFuture ...
[18:01:05.978] - result already collected: FutureResult
[18:01:05.978] result() for ClusterFuture ... done
[18:01:05.978] result() for ClusterFuture ...
[18:01:05.978] - result already collected: FutureResult
[18:01:05.978] result() for ClusterFuture ... done
[18:01:05.978] - relayed: [n=2] TRUE, FALSE
[18:01:05.979] - queued futures: [n=2] TRUE, FALSE
[18:01:05.979] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:05.979]  length: 1 (resolved future 1)
[18:01:06.001] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.001] - Validating connection of MultisessionFuture
[18:01:06.002] - received message: FutureResult
[18:01:06.003] - Received FutureResult
[18:01:06.004] - Erased future from FutureRegistry
[18:01:06.004] result() for ClusterFuture ...
[18:01:06.004] - result already collected: FutureResult
[18:01:06.004] result() for ClusterFuture ... done
[18:01:06.004] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.004] Future #2
[18:01:06.005] result() for ClusterFuture ...
[18:01:06.005] - result already collected: FutureResult
[18:01:06.005] result() for ClusterFuture ... done
[18:01:06.005] result() for ClusterFuture ...
[18:01:06.005] - result already collected: FutureResult
[18:01:06.006] result() for ClusterFuture ... done
[18:01:06.006] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:06.006] - nx: 2
[18:01:06.006] - relay: TRUE
[18:01:06.006] - stdout: TRUE
[18:01:06.006] - signal: TRUE
[18:01:06.007] - resignal: FALSE
[18:01:06.007] - force: TRUE
[18:01:06.007] - relayed: [n=2] TRUE, FALSE
[18:01:06.007] - queued futures: [n=2] TRUE, FALSE
[18:01:06.007]  - until=2
[18:01:06.008]  - relaying element #2
[18:01:06.008] result() for ClusterFuture ...
[18:01:06.008] - result already collected: FutureResult
[18:01:06.008] result() for ClusterFuture ... done
[18:01:06.008] result() for ClusterFuture ...
[18:01:06.008] - result already collected: FutureResult
[18:01:06.009] result() for ClusterFuture ... done
[18:01:06.009] result() for ClusterFuture ...
[18:01:06.009] - result already collected: FutureResult
[18:01:06.009] result() for ClusterFuture ... done
[18:01:06.009] result() for ClusterFuture ...
[18:01:06.010] - result already collected: FutureResult
[18:01:06.010] result() for ClusterFuture ... done
[18:01:06.010] - relayed: [n=2] TRUE, TRUE
[18:01:06.010] - queued futures: [n=2] TRUE, TRUE
[18:01:06.010] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:06.010]  length: 0 (resolved future 2)
[18:01:06.011] Relaying remaining futures
[18:01:06.011] signalConditionsASAP(NULL, pos=0) ...
[18:01:06.011] - nx: 2
[18:01:06.011] - relay: TRUE
[18:01:06.011] - stdout: TRUE
[18:01:06.011] - signal: TRUE
[18:01:06.012] - resignal: FALSE
[18:01:06.012] - force: TRUE
[18:01:06.012] - relayed: [n=2] TRUE, TRUE
[18:01:06.012] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:06.012] - relayed: [n=2] TRUE, TRUE
[18:01:06.013] - queued futures: [n=2] TRUE, TRUE
[18:01:06.013] signalConditionsASAP(NULL, pos=0) ... done
[18:01:06.013] resolve() on list ... DONE
[18:01:06.013] result() for ClusterFuture ...
[18:01:06.013] - result already collected: FutureResult
[18:01:06.014] result() for ClusterFuture ... done
[18:01:06.014] result() for ClusterFuture ...
[18:01:06.014] - result already collected: FutureResult
[18:01:06.014] result() for ClusterFuture ... done
[18:01:06.014] result() for ClusterFuture ...
[18:01:06.014] - result already collected: FutureResult
[18:01:06.015] result() for ClusterFuture ... done
[18:01:06.015] result() for ClusterFuture ...
[18:01:06.015] - result already collected: FutureResult
[18:01:06.015] result() for ClusterFuture ... done
[18:01:06.015]  - Number of value chunks collected: 2
[18:01:06.016] Resolving 2 futures (chunks) ... DONE
[18:01:06.016] Reducing values from 2 chunks ...
[18:01:06.016]  - Number of values collected after concatenation: 4
[18:01:06.016]  - Number of values expected: 4
[18:01:06.016] Reducing values from 2 chunks ... DONE
[18:01:06.016] future_mapply() ... DONE
[18:01:06.017] future_mapply() ...
[18:01:06.023] Number of chunks: 2
[18:01:06.023] getGlobalsAndPackagesXApply() ...
[18:01:06.023]  - future.globals: TRUE
[18:01:06.024] getGlobalsAndPackages() ...
[18:01:06.024] Searching for globals...
[18:01:06.025] - globals found: [1] ‘FUN’
[18:01:06.025] Searching for globals ... DONE
[18:01:06.025] Resolving globals: FALSE
[18:01:06.026] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:06.026] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:06.027] - globals: [1] ‘FUN’
[18:01:06.027] 
[18:01:06.027] getGlobalsAndPackages() ... DONE
[18:01:06.027]  - globals found/used: [n=1] ‘FUN’
[18:01:06.028]  - needed namespaces: [n=0] 
[18:01:06.028] Finding globals ... DONE
[18:01:06.028] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:06.028] List of 2
[18:01:06.028]  $ ...future.FUN:function (x, ...)  
[18:01:06.028]  $ MoreArgs     :List of 1
[18:01:06.028]   ..$ x: num 42
[18:01:06.028]  - attr(*, "where")=List of 2
[18:01:06.028]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:06.028]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:06.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:06.028]  - attr(*, "resolved")= logi FALSE
[18:01:06.028]  - attr(*, "total_size")= num NA
[18:01:06.034] Packages to be attached in all futures: [n=0] 
[18:01:06.034] getGlobalsAndPackagesXApply() ... DONE
[18:01:06.034] Number of futures (= number of chunks): 2
[18:01:06.035] Launching 2 futures (chunks) ...
[18:01:06.035] Chunk #1 of 2 ...
[18:01:06.035]  - Finding globals in '...' for chunk #1 ...
[18:01:06.035] getGlobalsAndPackages() ...
[18:01:06.035] Searching for globals...
[18:01:06.036] 
[18:01:06.036] Searching for globals ... DONE
[18:01:06.036] - globals: [0] <none>
[18:01:06.036] getGlobalsAndPackages() ... DONE
[18:01:06.037]    + additional globals found: [n=0] 
[18:01:06.037]    + additional namespaces needed: [n=0] 
[18:01:06.037]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:06.037]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:06.037]  - seeds: <none>
[18:01:06.038]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.038] getGlobalsAndPackages() ...
[18:01:06.038] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.038] Resolving globals: FALSE
[18:01:06.039] The total size of the 5 globals is 224 bytes (224 bytes)
[18:01:06.040] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:01:06.040] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.040] 
[18:01:06.041] getGlobalsAndPackages() ... DONE
[18:01:06.041] run() for ‘Future’ ...
[18:01:06.041] - state: ‘created’
[18:01:06.042] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.064] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.064]   - Field: ‘node’
[18:01:06.064]   - Field: ‘label’
[18:01:06.064]   - Field: ‘local’
[18:01:06.065]   - Field: ‘owner’
[18:01:06.065]   - Field: ‘envir’
[18:01:06.065]   - Field: ‘workers’
[18:01:06.065]   - Field: ‘packages’
[18:01:06.065]   - Field: ‘gc’
[18:01:06.066]   - Field: ‘conditions’
[18:01:06.066]   - Field: ‘persistent’
[18:01:06.066]   - Field: ‘expr’
[18:01:06.066]   - Field: ‘uuid’
[18:01:06.066]   - Field: ‘seed’
[18:01:06.067]   - Field: ‘version’
[18:01:06.067]   - Field: ‘result’
[18:01:06.067]   - Field: ‘asynchronous’
[18:01:06.067]   - Field: ‘calls’
[18:01:06.067]   - Field: ‘globals’
[18:01:06.068]   - Field: ‘stdout’
[18:01:06.068]   - Field: ‘earlySignal’
[18:01:06.068]   - Field: ‘lazy’
[18:01:06.068]   - Field: ‘state’
[18:01:06.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.069] - Launch lazy future ...
[18:01:06.069] Packages needed by the future expression (n = 0): <none>
[18:01:06.069] Packages needed by future strategies (n = 0): <none>
[18:01:06.070] {
[18:01:06.070]     {
[18:01:06.070]         {
[18:01:06.070]             ...future.startTime <- base::Sys.time()
[18:01:06.070]             {
[18:01:06.070]                 {
[18:01:06.070]                   {
[18:01:06.070]                     {
[18:01:06.070]                       base::local({
[18:01:06.070]                         has_future <- base::requireNamespace("future", 
[18:01:06.070]                           quietly = TRUE)
[18:01:06.070]                         if (has_future) {
[18:01:06.070]                           ns <- base::getNamespace("future")
[18:01:06.070]                           version <- ns[[".package"]][["version"]]
[18:01:06.070]                           if (is.null(version)) 
[18:01:06.070]                             version <- utils::packageVersion("future")
[18:01:06.070]                         }
[18:01:06.070]                         else {
[18:01:06.070]                           version <- NULL
[18:01:06.070]                         }
[18:01:06.070]                         if (!has_future || version < "1.8.0") {
[18:01:06.070]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.070]                             "", base::R.version$version.string), 
[18:01:06.070]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.070]                               "release", "version")], collapse = " "), 
[18:01:06.070]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.070]                             info)
[18:01:06.070]                           info <- base::paste(info, collapse = "; ")
[18:01:06.070]                           if (!has_future) {
[18:01:06.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.070]                               info)
[18:01:06.070]                           }
[18:01:06.070]                           else {
[18:01:06.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.070]                               info, version)
[18:01:06.070]                           }
[18:01:06.070]                           base::stop(msg)
[18:01:06.070]                         }
[18:01:06.070]                       })
[18:01:06.070]                     }
[18:01:06.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.070]                     base::options(mc.cores = 1L)
[18:01:06.070]                   }
[18:01:06.070]                   ...future.strategy.old <- future::plan("list")
[18:01:06.070]                   options(future.plan = NULL)
[18:01:06.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.070]                 }
[18:01:06.070]                 ...future.workdir <- getwd()
[18:01:06.070]             }
[18:01:06.070]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.070]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.070]         }
[18:01:06.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.070]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:06.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.070]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.070]             base::names(...future.oldOptions))
[18:01:06.070]     }
[18:01:06.070]     if (FALSE) {
[18:01:06.070]     }
[18:01:06.070]     else {
[18:01:06.070]         if (TRUE) {
[18:01:06.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.070]                 open = "w")
[18:01:06.070]         }
[18:01:06.070]         else {
[18:01:06.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.070]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.070]         }
[18:01:06.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.070]             base::sink(type = "output", split = FALSE)
[18:01:06.070]             base::close(...future.stdout)
[18:01:06.070]         }, add = TRUE)
[18:01:06.070]     }
[18:01:06.070]     ...future.frame <- base::sys.nframe()
[18:01:06.070]     ...future.conditions <- base::list()
[18:01:06.070]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.070]     if (FALSE) {
[18:01:06.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.070]     }
[18:01:06.070]     ...future.result <- base::tryCatch({
[18:01:06.070]         base::withCallingHandlers({
[18:01:06.070]             ...future.value <- base::withVisible(base::local({
[18:01:06.070]                 ...future.makeSendCondition <- base::local({
[18:01:06.070]                   sendCondition <- NULL
[18:01:06.070]                   function(frame = 1L) {
[18:01:06.070]                     if (is.function(sendCondition)) 
[18:01:06.070]                       return(sendCondition)
[18:01:06.070]                     ns <- getNamespace("parallel")
[18:01:06.070]                     if (exists("sendData", mode = "function", 
[18:01:06.070]                       envir = ns)) {
[18:01:06.070]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.070]                         envir = ns)
[18:01:06.070]                       envir <- sys.frame(frame)
[18:01:06.070]                       master <- NULL
[18:01:06.070]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.070]                         !identical(envir, emptyenv())) {
[18:01:06.070]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.070]                           inherits = FALSE)) {
[18:01:06.070]                           master <- get("master", mode = "list", 
[18:01:06.070]                             envir = envir, inherits = FALSE)
[18:01:06.070]                           if (inherits(master, c("SOCKnode", 
[18:01:06.070]                             "SOCK0node"))) {
[18:01:06.070]                             sendCondition <<- function(cond) {
[18:01:06.070]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.070]                                 success = TRUE)
[18:01:06.070]                               parallel_sendData(master, data)
[18:01:06.070]                             }
[18:01:06.070]                             return(sendCondition)
[18:01:06.070]                           }
[18:01:06.070]                         }
[18:01:06.070]                         frame <- frame + 1L
[18:01:06.070]                         envir <- sys.frame(frame)
[18:01:06.070]                       }
[18:01:06.070]                     }
[18:01:06.070]                     sendCondition <<- function(cond) NULL
[18:01:06.070]                   }
[18:01:06.070]                 })
[18:01:06.070]                 withCallingHandlers({
[18:01:06.070]                   {
[18:01:06.070]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.070]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.070]                       ...future.globals.maxSize)) {
[18:01:06.070]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.070]                       on.exit(options(oopts), add = TRUE)
[18:01:06.070]                     }
[18:01:06.070]                     {
[18:01:06.070]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.070]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.070]                         USE.NAMES = FALSE)
[18:01:06.070]                       do.call(mapply, args = args)
[18:01:06.070]                     }
[18:01:06.070]                   }
[18:01:06.070]                 }, immediateCondition = function(cond) {
[18:01:06.070]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.070]                   sendCondition(cond)
[18:01:06.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.070]                   {
[18:01:06.070]                     inherits <- base::inherits
[18:01:06.070]                     invokeRestart <- base::invokeRestart
[18:01:06.070]                     is.null <- base::is.null
[18:01:06.070]                     muffled <- FALSE
[18:01:06.070]                     if (inherits(cond, "message")) {
[18:01:06.070]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.070]                       if (muffled) 
[18:01:06.070]                         invokeRestart("muffleMessage")
[18:01:06.070]                     }
[18:01:06.070]                     else if (inherits(cond, "warning")) {
[18:01:06.070]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.070]                       if (muffled) 
[18:01:06.070]                         invokeRestart("muffleWarning")
[18:01:06.070]                     }
[18:01:06.070]                     else if (inherits(cond, "condition")) {
[18:01:06.070]                       if (!is.null(pattern)) {
[18:01:06.070]                         computeRestarts <- base::computeRestarts
[18:01:06.070]                         grepl <- base::grepl
[18:01:06.070]                         restarts <- computeRestarts(cond)
[18:01:06.070]                         for (restart in restarts) {
[18:01:06.070]                           name <- restart$name
[18:01:06.070]                           if (is.null(name)) 
[18:01:06.070]                             next
[18:01:06.070]                           if (!grepl(pattern, name)) 
[18:01:06.070]                             next
[18:01:06.070]                           invokeRestart(restart)
[18:01:06.070]                           muffled <- TRUE
[18:01:06.070]                           break
[18:01:06.070]                         }
[18:01:06.070]                       }
[18:01:06.070]                     }
[18:01:06.070]                     invisible(muffled)
[18:01:06.070]                   }
[18:01:06.070]                   muffleCondition(cond)
[18:01:06.070]                 })
[18:01:06.070]             }))
[18:01:06.070]             future::FutureResult(value = ...future.value$value, 
[18:01:06.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.070]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.070]                     ...future.globalenv.names))
[18:01:06.070]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.070]         }, condition = base::local({
[18:01:06.070]             c <- base::c
[18:01:06.070]             inherits <- base::inherits
[18:01:06.070]             invokeRestart <- base::invokeRestart
[18:01:06.070]             length <- base::length
[18:01:06.070]             list <- base::list
[18:01:06.070]             seq.int <- base::seq.int
[18:01:06.070]             signalCondition <- base::signalCondition
[18:01:06.070]             sys.calls <- base::sys.calls
[18:01:06.070]             `[[` <- base::`[[`
[18:01:06.070]             `+` <- base::`+`
[18:01:06.070]             `<<-` <- base::`<<-`
[18:01:06.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.070]                   3L)]
[18:01:06.070]             }
[18:01:06.070]             function(cond) {
[18:01:06.070]                 is_error <- inherits(cond, "error")
[18:01:06.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.070]                   NULL)
[18:01:06.070]                 if (is_error) {
[18:01:06.070]                   sessionInformation <- function() {
[18:01:06.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.070]                       search = base::search(), system = base::Sys.info())
[18:01:06.070]                   }
[18:01:06.070]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.070]                     cond$call), session = sessionInformation(), 
[18:01:06.070]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.070]                   signalCondition(cond)
[18:01:06.070]                 }
[18:01:06.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.070]                 "immediateCondition"))) {
[18:01:06.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.070]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.070]                   if (TRUE && !signal) {
[18:01:06.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.070]                     {
[18:01:06.070]                       inherits <- base::inherits
[18:01:06.070]                       invokeRestart <- base::invokeRestart
[18:01:06.070]                       is.null <- base::is.null
[18:01:06.070]                       muffled <- FALSE
[18:01:06.070]                       if (inherits(cond, "message")) {
[18:01:06.070]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.070]                         if (muffled) 
[18:01:06.070]                           invokeRestart("muffleMessage")
[18:01:06.070]                       }
[18:01:06.070]                       else if (inherits(cond, "warning")) {
[18:01:06.070]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.070]                         if (muffled) 
[18:01:06.070]                           invokeRestart("muffleWarning")
[18:01:06.070]                       }
[18:01:06.070]                       else if (inherits(cond, "condition")) {
[18:01:06.070]                         if (!is.null(pattern)) {
[18:01:06.070]                           computeRestarts <- base::computeRestarts
[18:01:06.070]                           grepl <- base::grepl
[18:01:06.070]                           restarts <- computeRestarts(cond)
[18:01:06.070]                           for (restart in restarts) {
[18:01:06.070]                             name <- restart$name
[18:01:06.070]                             if (is.null(name)) 
[18:01:06.070]                               next
[18:01:06.070]                             if (!grepl(pattern, name)) 
[18:01:06.070]                               next
[18:01:06.070]                             invokeRestart(restart)
[18:01:06.070]                             muffled <- TRUE
[18:01:06.070]                             break
[18:01:06.070]                           }
[18:01:06.070]                         }
[18:01:06.070]                       }
[18:01:06.070]                       invisible(muffled)
[18:01:06.070]                     }
[18:01:06.070]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.070]                   }
[18:01:06.070]                 }
[18:01:06.070]                 else {
[18:01:06.070]                   if (TRUE) {
[18:01:06.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.070]                     {
[18:01:06.070]                       inherits <- base::inherits
[18:01:06.070]                       invokeRestart <- base::invokeRestart
[18:01:06.070]                       is.null <- base::is.null
[18:01:06.070]                       muffled <- FALSE
[18:01:06.070]                       if (inherits(cond, "message")) {
[18:01:06.070]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.070]                         if (muffled) 
[18:01:06.070]                           invokeRestart("muffleMessage")
[18:01:06.070]                       }
[18:01:06.070]                       else if (inherits(cond, "warning")) {
[18:01:06.070]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.070]                         if (muffled) 
[18:01:06.070]                           invokeRestart("muffleWarning")
[18:01:06.070]                       }
[18:01:06.070]                       else if (inherits(cond, "condition")) {
[18:01:06.070]                         if (!is.null(pattern)) {
[18:01:06.070]                           computeRestarts <- base::computeRestarts
[18:01:06.070]                           grepl <- base::grepl
[18:01:06.070]                           restarts <- computeRestarts(cond)
[18:01:06.070]                           for (restart in restarts) {
[18:01:06.070]                             name <- restart$name
[18:01:06.070]                             if (is.null(name)) 
[18:01:06.070]                               next
[18:01:06.070]                             if (!grepl(pattern, name)) 
[18:01:06.070]                               next
[18:01:06.070]                             invokeRestart(restart)
[18:01:06.070]                             muffled <- TRUE
[18:01:06.070]                             break
[18:01:06.070]                           }
[18:01:06.070]                         }
[18:01:06.070]                       }
[18:01:06.070]                       invisible(muffled)
[18:01:06.070]                     }
[18:01:06.070]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.070]                   }
[18:01:06.070]                 }
[18:01:06.070]             }
[18:01:06.070]         }))
[18:01:06.070]     }, error = function(ex) {
[18:01:06.070]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.070]                 ...future.rng), started = ...future.startTime, 
[18:01:06.070]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.070]             version = "1.8"), class = "FutureResult")
[18:01:06.070]     }, finally = {
[18:01:06.070]         if (!identical(...future.workdir, getwd())) 
[18:01:06.070]             setwd(...future.workdir)
[18:01:06.070]         {
[18:01:06.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.070]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.070]             }
[18:01:06.070]             base::options(...future.oldOptions)
[18:01:06.070]             if (.Platform$OS.type == "windows") {
[18:01:06.070]                 old_names <- names(...future.oldEnvVars)
[18:01:06.070]                 envs <- base::Sys.getenv()
[18:01:06.070]                 names <- names(envs)
[18:01:06.070]                 common <- intersect(names, old_names)
[18:01:06.070]                 added <- setdiff(names, old_names)
[18:01:06.070]                 removed <- setdiff(old_names, names)
[18:01:06.070]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.070]                   envs[common]]
[18:01:06.070]                 NAMES <- toupper(changed)
[18:01:06.070]                 args <- list()
[18:01:06.070]                 for (kk in seq_along(NAMES)) {
[18:01:06.070]                   name <- changed[[kk]]
[18:01:06.070]                   NAME <- NAMES[[kk]]
[18:01:06.070]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.070]                     next
[18:01:06.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.070]                 }
[18:01:06.070]                 NAMES <- toupper(added)
[18:01:06.070]                 for (kk in seq_along(NAMES)) {
[18:01:06.070]                   name <- added[[kk]]
[18:01:06.070]                   NAME <- NAMES[[kk]]
[18:01:06.070]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.070]                     next
[18:01:06.070]                   args[[name]] <- ""
[18:01:06.070]                 }
[18:01:06.070]                 NAMES <- toupper(removed)
[18:01:06.070]                 for (kk in seq_along(NAMES)) {
[18:01:06.070]                   name <- removed[[kk]]
[18:01:06.070]                   NAME <- NAMES[[kk]]
[18:01:06.070]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.070]                     next
[18:01:06.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.070]                 }
[18:01:06.070]                 if (length(args) > 0) 
[18:01:06.070]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.070]             }
[18:01:06.070]             else {
[18:01:06.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.070]             }
[18:01:06.070]             {
[18:01:06.070]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.070]                   0L) {
[18:01:06.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.070]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.070]                   base::options(opts)
[18:01:06.070]                 }
[18:01:06.070]                 {
[18:01:06.070]                   {
[18:01:06.070]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.070]                     NULL
[18:01:06.070]                   }
[18:01:06.070]                   options(future.plan = NULL)
[18:01:06.070]                   if (is.na(NA_character_)) 
[18:01:06.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.070]                     .init = FALSE)
[18:01:06.070]                 }
[18:01:06.070]             }
[18:01:06.070]         }
[18:01:06.070]     })
[18:01:06.070]     if (TRUE) {
[18:01:06.070]         base::sink(type = "output", split = FALSE)
[18:01:06.070]         if (TRUE) {
[18:01:06.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.070]         }
[18:01:06.070]         else {
[18:01:06.070]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.070]         }
[18:01:06.070]         base::close(...future.stdout)
[18:01:06.070]         ...future.stdout <- NULL
[18:01:06.070]     }
[18:01:06.070]     ...future.result$conditions <- ...future.conditions
[18:01:06.070]     ...future.result$finished <- base::Sys.time()
[18:01:06.070]     ...future.result
[18:01:06.070] }
[18:01:06.075] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[18:01:06.076] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[18:01:06.076] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[18:01:06.077] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[18:01:06.078] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[18:01:06.078] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:01:06.079] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:01:06.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:06.080] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.080] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:06.081] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.081] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[18:01:06.082] MultisessionFuture started
[18:01:06.082] - Launch lazy future ... done
[18:01:06.082] run() for ‘MultisessionFuture’ ... done
[18:01:06.083] Created future:
[18:01:06.083] MultisessionFuture:
[18:01:06.083] Label: ‘future_mapply-1’
[18:01:06.083] Expression:
[18:01:06.083] {
[18:01:06.083]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.083]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.083]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.083]         on.exit(options(oopts), add = TRUE)
[18:01:06.083]     }
[18:01:06.083]     {
[18:01:06.083]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.083]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.083]         do.call(mapply, args = args)
[18:01:06.083]     }
[18:01:06.083] }
[18:01:06.083] Lazy evaluation: FALSE
[18:01:06.083] Asynchronous evaluation: TRUE
[18:01:06.083] Local evaluation: TRUE
[18:01:06.083] Environment: R_GlobalEnv
[18:01:06.083] Capture standard output: TRUE
[18:01:06.083] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.083] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.083] Packages: <none>
[18:01:06.083] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.083] Resolved: FALSE
[18:01:06.083] Value: <not collected>
[18:01:06.083] Conditions captured: <none>
[18:01:06.083] Early signaling: FALSE
[18:01:06.083] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.083] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.096] Chunk #1 of 2 ... DONE
[18:01:06.096] Chunk #2 of 2 ...
[18:01:06.096]  - Finding globals in '...' for chunk #2 ...
[18:01:06.096] getGlobalsAndPackages() ...
[18:01:06.096] Searching for globals...
[18:01:06.097] 
[18:01:06.097] Searching for globals ... DONE
[18:01:06.097] - globals: [0] <none>
[18:01:06.098] getGlobalsAndPackages() ... DONE
[18:01:06.098]    + additional globals found: [n=0] 
[18:01:06.098]    + additional namespaces needed: [n=0] 
[18:01:06.098]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:06.098]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:06.099]  - seeds: <none>
[18:01:06.099]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.099] getGlobalsAndPackages() ...
[18:01:06.099] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.099] Resolving globals: FALSE
[18:01:06.100] The total size of the 5 globals is 224 bytes (224 bytes)
[18:01:06.101] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:01:06.101] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.102] 
[18:01:06.102] getGlobalsAndPackages() ... DONE
[18:01:06.102] run() for ‘Future’ ...
[18:01:06.103] - state: ‘created’
[18:01:06.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.127] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.128]   - Field: ‘node’
[18:01:06.128]   - Field: ‘label’
[18:01:06.128]   - Field: ‘local’
[18:01:06.129]   - Field: ‘owner’
[18:01:06.129]   - Field: ‘envir’
[18:01:06.130]   - Field: ‘workers’
[18:01:06.130]   - Field: ‘packages’
[18:01:06.130]   - Field: ‘gc’
[18:01:06.130]   - Field: ‘conditions’
[18:01:06.131]   - Field: ‘persistent’
[18:01:06.131]   - Field: ‘expr’
[18:01:06.131]   - Field: ‘uuid’
[18:01:06.131]   - Field: ‘seed’
[18:01:06.131]   - Field: ‘version’
[18:01:06.132]   - Field: ‘result’
[18:01:06.132]   - Field: ‘asynchronous’
[18:01:06.132]   - Field: ‘calls’
[18:01:06.132]   - Field: ‘globals’
[18:01:06.132]   - Field: ‘stdout’
[18:01:06.133]   - Field: ‘earlySignal’
[18:01:06.133]   - Field: ‘lazy’
[18:01:06.133]   - Field: ‘state’
[18:01:06.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.133] - Launch lazy future ...
[18:01:06.134] Packages needed by the future expression (n = 0): <none>
[18:01:06.134] Packages needed by future strategies (n = 0): <none>
[18:01:06.135] {
[18:01:06.135]     {
[18:01:06.135]         {
[18:01:06.135]             ...future.startTime <- base::Sys.time()
[18:01:06.135]             {
[18:01:06.135]                 {
[18:01:06.135]                   {
[18:01:06.135]                     {
[18:01:06.135]                       base::local({
[18:01:06.135]                         has_future <- base::requireNamespace("future", 
[18:01:06.135]                           quietly = TRUE)
[18:01:06.135]                         if (has_future) {
[18:01:06.135]                           ns <- base::getNamespace("future")
[18:01:06.135]                           version <- ns[[".package"]][["version"]]
[18:01:06.135]                           if (is.null(version)) 
[18:01:06.135]                             version <- utils::packageVersion("future")
[18:01:06.135]                         }
[18:01:06.135]                         else {
[18:01:06.135]                           version <- NULL
[18:01:06.135]                         }
[18:01:06.135]                         if (!has_future || version < "1.8.0") {
[18:01:06.135]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.135]                             "", base::R.version$version.string), 
[18:01:06.135]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.135]                               "release", "version")], collapse = " "), 
[18:01:06.135]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.135]                             info)
[18:01:06.135]                           info <- base::paste(info, collapse = "; ")
[18:01:06.135]                           if (!has_future) {
[18:01:06.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.135]                               info)
[18:01:06.135]                           }
[18:01:06.135]                           else {
[18:01:06.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.135]                               info, version)
[18:01:06.135]                           }
[18:01:06.135]                           base::stop(msg)
[18:01:06.135]                         }
[18:01:06.135]                       })
[18:01:06.135]                     }
[18:01:06.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.135]                     base::options(mc.cores = 1L)
[18:01:06.135]                   }
[18:01:06.135]                   ...future.strategy.old <- future::plan("list")
[18:01:06.135]                   options(future.plan = NULL)
[18:01:06.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.135]                 }
[18:01:06.135]                 ...future.workdir <- getwd()
[18:01:06.135]             }
[18:01:06.135]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.135]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.135]         }
[18:01:06.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.135]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:06.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.135]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.135]             base::names(...future.oldOptions))
[18:01:06.135]     }
[18:01:06.135]     if (FALSE) {
[18:01:06.135]     }
[18:01:06.135]     else {
[18:01:06.135]         if (TRUE) {
[18:01:06.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.135]                 open = "w")
[18:01:06.135]         }
[18:01:06.135]         else {
[18:01:06.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.135]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.135]         }
[18:01:06.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.135]             base::sink(type = "output", split = FALSE)
[18:01:06.135]             base::close(...future.stdout)
[18:01:06.135]         }, add = TRUE)
[18:01:06.135]     }
[18:01:06.135]     ...future.frame <- base::sys.nframe()
[18:01:06.135]     ...future.conditions <- base::list()
[18:01:06.135]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.135]     if (FALSE) {
[18:01:06.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.135]     }
[18:01:06.135]     ...future.result <- base::tryCatch({
[18:01:06.135]         base::withCallingHandlers({
[18:01:06.135]             ...future.value <- base::withVisible(base::local({
[18:01:06.135]                 ...future.makeSendCondition <- base::local({
[18:01:06.135]                   sendCondition <- NULL
[18:01:06.135]                   function(frame = 1L) {
[18:01:06.135]                     if (is.function(sendCondition)) 
[18:01:06.135]                       return(sendCondition)
[18:01:06.135]                     ns <- getNamespace("parallel")
[18:01:06.135]                     if (exists("sendData", mode = "function", 
[18:01:06.135]                       envir = ns)) {
[18:01:06.135]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.135]                         envir = ns)
[18:01:06.135]                       envir <- sys.frame(frame)
[18:01:06.135]                       master <- NULL
[18:01:06.135]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.135]                         !identical(envir, emptyenv())) {
[18:01:06.135]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.135]                           inherits = FALSE)) {
[18:01:06.135]                           master <- get("master", mode = "list", 
[18:01:06.135]                             envir = envir, inherits = FALSE)
[18:01:06.135]                           if (inherits(master, c("SOCKnode", 
[18:01:06.135]                             "SOCK0node"))) {
[18:01:06.135]                             sendCondition <<- function(cond) {
[18:01:06.135]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.135]                                 success = TRUE)
[18:01:06.135]                               parallel_sendData(master, data)
[18:01:06.135]                             }
[18:01:06.135]                             return(sendCondition)
[18:01:06.135]                           }
[18:01:06.135]                         }
[18:01:06.135]                         frame <- frame + 1L
[18:01:06.135]                         envir <- sys.frame(frame)
[18:01:06.135]                       }
[18:01:06.135]                     }
[18:01:06.135]                     sendCondition <<- function(cond) NULL
[18:01:06.135]                   }
[18:01:06.135]                 })
[18:01:06.135]                 withCallingHandlers({
[18:01:06.135]                   {
[18:01:06.135]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.135]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.135]                       ...future.globals.maxSize)) {
[18:01:06.135]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.135]                       on.exit(options(oopts), add = TRUE)
[18:01:06.135]                     }
[18:01:06.135]                     {
[18:01:06.135]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.135]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.135]                         USE.NAMES = FALSE)
[18:01:06.135]                       do.call(mapply, args = args)
[18:01:06.135]                     }
[18:01:06.135]                   }
[18:01:06.135]                 }, immediateCondition = function(cond) {
[18:01:06.135]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.135]                   sendCondition(cond)
[18:01:06.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.135]                   {
[18:01:06.135]                     inherits <- base::inherits
[18:01:06.135]                     invokeRestart <- base::invokeRestart
[18:01:06.135]                     is.null <- base::is.null
[18:01:06.135]                     muffled <- FALSE
[18:01:06.135]                     if (inherits(cond, "message")) {
[18:01:06.135]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.135]                       if (muffled) 
[18:01:06.135]                         invokeRestart("muffleMessage")
[18:01:06.135]                     }
[18:01:06.135]                     else if (inherits(cond, "warning")) {
[18:01:06.135]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.135]                       if (muffled) 
[18:01:06.135]                         invokeRestart("muffleWarning")
[18:01:06.135]                     }
[18:01:06.135]                     else if (inherits(cond, "condition")) {
[18:01:06.135]                       if (!is.null(pattern)) {
[18:01:06.135]                         computeRestarts <- base::computeRestarts
[18:01:06.135]                         grepl <- base::grepl
[18:01:06.135]                         restarts <- computeRestarts(cond)
[18:01:06.135]                         for (restart in restarts) {
[18:01:06.135]                           name <- restart$name
[18:01:06.135]                           if (is.null(name)) 
[18:01:06.135]                             next
[18:01:06.135]                           if (!grepl(pattern, name)) 
[18:01:06.135]                             next
[18:01:06.135]                           invokeRestart(restart)
[18:01:06.135]                           muffled <- TRUE
[18:01:06.135]                           break
[18:01:06.135]                         }
[18:01:06.135]                       }
[18:01:06.135]                     }
[18:01:06.135]                     invisible(muffled)
[18:01:06.135]                   }
[18:01:06.135]                   muffleCondition(cond)
[18:01:06.135]                 })
[18:01:06.135]             }))
[18:01:06.135]             future::FutureResult(value = ...future.value$value, 
[18:01:06.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.135]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.135]                     ...future.globalenv.names))
[18:01:06.135]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.135]         }, condition = base::local({
[18:01:06.135]             c <- base::c
[18:01:06.135]             inherits <- base::inherits
[18:01:06.135]             invokeRestart <- base::invokeRestart
[18:01:06.135]             length <- base::length
[18:01:06.135]             list <- base::list
[18:01:06.135]             seq.int <- base::seq.int
[18:01:06.135]             signalCondition <- base::signalCondition
[18:01:06.135]             sys.calls <- base::sys.calls
[18:01:06.135]             `[[` <- base::`[[`
[18:01:06.135]             `+` <- base::`+`
[18:01:06.135]             `<<-` <- base::`<<-`
[18:01:06.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.135]                   3L)]
[18:01:06.135]             }
[18:01:06.135]             function(cond) {
[18:01:06.135]                 is_error <- inherits(cond, "error")
[18:01:06.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.135]                   NULL)
[18:01:06.135]                 if (is_error) {
[18:01:06.135]                   sessionInformation <- function() {
[18:01:06.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.135]                       search = base::search(), system = base::Sys.info())
[18:01:06.135]                   }
[18:01:06.135]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.135]                     cond$call), session = sessionInformation(), 
[18:01:06.135]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.135]                   signalCondition(cond)
[18:01:06.135]                 }
[18:01:06.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.135]                 "immediateCondition"))) {
[18:01:06.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.135]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.135]                   if (TRUE && !signal) {
[18:01:06.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.135]                     {
[18:01:06.135]                       inherits <- base::inherits
[18:01:06.135]                       invokeRestart <- base::invokeRestart
[18:01:06.135]                       is.null <- base::is.null
[18:01:06.135]                       muffled <- FALSE
[18:01:06.135]                       if (inherits(cond, "message")) {
[18:01:06.135]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.135]                         if (muffled) 
[18:01:06.135]                           invokeRestart("muffleMessage")
[18:01:06.135]                       }
[18:01:06.135]                       else if (inherits(cond, "warning")) {
[18:01:06.135]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.135]                         if (muffled) 
[18:01:06.135]                           invokeRestart("muffleWarning")
[18:01:06.135]                       }
[18:01:06.135]                       else if (inherits(cond, "condition")) {
[18:01:06.135]                         if (!is.null(pattern)) {
[18:01:06.135]                           computeRestarts <- base::computeRestarts
[18:01:06.135]                           grepl <- base::grepl
[18:01:06.135]                           restarts <- computeRestarts(cond)
[18:01:06.135]                           for (restart in restarts) {
[18:01:06.135]                             name <- restart$name
[18:01:06.135]                             if (is.null(name)) 
[18:01:06.135]                               next
[18:01:06.135]                             if (!grepl(pattern, name)) 
[18:01:06.135]                               next
[18:01:06.135]                             invokeRestart(restart)
[18:01:06.135]                             muffled <- TRUE
[18:01:06.135]                             break
[18:01:06.135]                           }
[18:01:06.135]                         }
[18:01:06.135]                       }
[18:01:06.135]                       invisible(muffled)
[18:01:06.135]                     }
[18:01:06.135]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.135]                   }
[18:01:06.135]                 }
[18:01:06.135]                 else {
[18:01:06.135]                   if (TRUE) {
[18:01:06.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.135]                     {
[18:01:06.135]                       inherits <- base::inherits
[18:01:06.135]                       invokeRestart <- base::invokeRestart
[18:01:06.135]                       is.null <- base::is.null
[18:01:06.135]                       muffled <- FALSE
[18:01:06.135]                       if (inherits(cond, "message")) {
[18:01:06.135]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.135]                         if (muffled) 
[18:01:06.135]                           invokeRestart("muffleMessage")
[18:01:06.135]                       }
[18:01:06.135]                       else if (inherits(cond, "warning")) {
[18:01:06.135]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.135]                         if (muffled) 
[18:01:06.135]                           invokeRestart("muffleWarning")
[18:01:06.135]                       }
[18:01:06.135]                       else if (inherits(cond, "condition")) {
[18:01:06.135]                         if (!is.null(pattern)) {
[18:01:06.135]                           computeRestarts <- base::computeRestarts
[18:01:06.135]                           grepl <- base::grepl
[18:01:06.135]                           restarts <- computeRestarts(cond)
[18:01:06.135]                           for (restart in restarts) {
[18:01:06.135]                             name <- restart$name
[18:01:06.135]                             if (is.null(name)) 
[18:01:06.135]                               next
[18:01:06.135]                             if (!grepl(pattern, name)) 
[18:01:06.135]                               next
[18:01:06.135]                             invokeRestart(restart)
[18:01:06.135]                             muffled <- TRUE
[18:01:06.135]                             break
[18:01:06.135]                           }
[18:01:06.135]                         }
[18:01:06.135]                       }
[18:01:06.135]                       invisible(muffled)
[18:01:06.135]                     }
[18:01:06.135]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.135]                   }
[18:01:06.135]                 }
[18:01:06.135]             }
[18:01:06.135]         }))
[18:01:06.135]     }, error = function(ex) {
[18:01:06.135]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.135]                 ...future.rng), started = ...future.startTime, 
[18:01:06.135]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.135]             version = "1.8"), class = "FutureResult")
[18:01:06.135]     }, finally = {
[18:01:06.135]         if (!identical(...future.workdir, getwd())) 
[18:01:06.135]             setwd(...future.workdir)
[18:01:06.135]         {
[18:01:06.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.135]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.135]             }
[18:01:06.135]             base::options(...future.oldOptions)
[18:01:06.135]             if (.Platform$OS.type == "windows") {
[18:01:06.135]                 old_names <- names(...future.oldEnvVars)
[18:01:06.135]                 envs <- base::Sys.getenv()
[18:01:06.135]                 names <- names(envs)
[18:01:06.135]                 common <- intersect(names, old_names)
[18:01:06.135]                 added <- setdiff(names, old_names)
[18:01:06.135]                 removed <- setdiff(old_names, names)
[18:01:06.135]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.135]                   envs[common]]
[18:01:06.135]                 NAMES <- toupper(changed)
[18:01:06.135]                 args <- list()
[18:01:06.135]                 for (kk in seq_along(NAMES)) {
[18:01:06.135]                   name <- changed[[kk]]
[18:01:06.135]                   NAME <- NAMES[[kk]]
[18:01:06.135]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.135]                     next
[18:01:06.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.135]                 }
[18:01:06.135]                 NAMES <- toupper(added)
[18:01:06.135]                 for (kk in seq_along(NAMES)) {
[18:01:06.135]                   name <- added[[kk]]
[18:01:06.135]                   NAME <- NAMES[[kk]]
[18:01:06.135]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.135]                     next
[18:01:06.135]                   args[[name]] <- ""
[18:01:06.135]                 }
[18:01:06.135]                 NAMES <- toupper(removed)
[18:01:06.135]                 for (kk in seq_along(NAMES)) {
[18:01:06.135]                   name <- removed[[kk]]
[18:01:06.135]                   NAME <- NAMES[[kk]]
[18:01:06.135]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.135]                     next
[18:01:06.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.135]                 }
[18:01:06.135]                 if (length(args) > 0) 
[18:01:06.135]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.135]             }
[18:01:06.135]             else {
[18:01:06.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.135]             }
[18:01:06.135]             {
[18:01:06.135]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.135]                   0L) {
[18:01:06.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.135]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.135]                   base::options(opts)
[18:01:06.135]                 }
[18:01:06.135]                 {
[18:01:06.135]                   {
[18:01:06.135]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.135]                     NULL
[18:01:06.135]                   }
[18:01:06.135]                   options(future.plan = NULL)
[18:01:06.135]                   if (is.na(NA_character_)) 
[18:01:06.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.135]                     .init = FALSE)
[18:01:06.135]                 }
[18:01:06.135]             }
[18:01:06.135]         }
[18:01:06.135]     })
[18:01:06.135]     if (TRUE) {
[18:01:06.135]         base::sink(type = "output", split = FALSE)
[18:01:06.135]         if (TRUE) {
[18:01:06.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.135]         }
[18:01:06.135]         else {
[18:01:06.135]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.135]         }
[18:01:06.135]         base::close(...future.stdout)
[18:01:06.135]         ...future.stdout <- NULL
[18:01:06.135]     }
[18:01:06.135]     ...future.result$conditions <- ...future.conditions
[18:01:06.135]     ...future.result$finished <- base::Sys.time()
[18:01:06.135]     ...future.result
[18:01:06.135] }
[18:01:06.140] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[18:01:06.141] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[18:01:06.142] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[18:01:06.142] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[18:01:06.143] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[18:01:06.143] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:01:06.144] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:01:06.144] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:06.145] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.146] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:06.146] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.147] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[18:01:06.148] MultisessionFuture started
[18:01:06.148] - Launch lazy future ... done
[18:01:06.148] run() for ‘MultisessionFuture’ ... done
[18:01:06.149] Created future:
[18:01:06.149] MultisessionFuture:
[18:01:06.149] Label: ‘future_mapply-2’
[18:01:06.149] Expression:
[18:01:06.149] {
[18:01:06.149]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.149]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.149]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.149]         on.exit(options(oopts), add = TRUE)
[18:01:06.149]     }
[18:01:06.149]     {
[18:01:06.149]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.149]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.149]         do.call(mapply, args = args)
[18:01:06.149]     }
[18:01:06.149] }
[18:01:06.149] Lazy evaluation: FALSE
[18:01:06.149] Asynchronous evaluation: TRUE
[18:01:06.149] Local evaluation: TRUE
[18:01:06.149] Environment: R_GlobalEnv
[18:01:06.149] Capture standard output: TRUE
[18:01:06.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.149] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.149] Packages: <none>
[18:01:06.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.149] Resolved: FALSE
[18:01:06.149] Value: <not collected>
[18:01:06.149] Conditions captured: <none>
[18:01:06.149] Early signaling: FALSE
[18:01:06.149] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.149] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.162] Chunk #2 of 2 ... DONE
[18:01:06.163] Launching 2 futures (chunks) ... DONE
[18:01:06.163] Resolving 2 futures (chunks) ...
[18:01:06.163] resolve() on list ...
[18:01:06.163]  recursive: 0
[18:01:06.164]  length: 2
[18:01:06.164] 
[18:01:06.165] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.165] - Validating connection of MultisessionFuture
[18:01:06.165] - received message: FutureResult
[18:01:06.165] - Received FutureResult
[18:01:06.166] - Erased future from FutureRegistry
[18:01:06.166] result() for ClusterFuture ...
[18:01:06.166] - result already collected: FutureResult
[18:01:06.166] result() for ClusterFuture ... done
[18:01:06.166] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.167] Future #1
[18:01:06.167] result() for ClusterFuture ...
[18:01:06.167] - result already collected: FutureResult
[18:01:06.167] result() for ClusterFuture ... done
[18:01:06.167] result() for ClusterFuture ...
[18:01:06.167] - result already collected: FutureResult
[18:01:06.168] result() for ClusterFuture ... done
[18:01:06.168] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:06.168] - nx: 2
[18:01:06.168] - relay: TRUE
[18:01:06.168] - stdout: TRUE
[18:01:06.169] - signal: TRUE
[18:01:06.169] - resignal: FALSE
[18:01:06.169] - force: TRUE
[18:01:06.169] - relayed: [n=2] FALSE, FALSE
[18:01:06.169] - queued futures: [n=2] FALSE, FALSE
[18:01:06.169]  - until=1
[18:01:06.170]  - relaying element #1
[18:01:06.170] result() for ClusterFuture ...
[18:01:06.170] - result already collected: FutureResult
[18:01:06.170] result() for ClusterFuture ... done
[18:01:06.170] result() for ClusterFuture ...
[18:01:06.171] - result already collected: FutureResult
[18:01:06.171] result() for ClusterFuture ... done
[18:01:06.171] result() for ClusterFuture ...
[18:01:06.171] - result already collected: FutureResult
[18:01:06.171] result() for ClusterFuture ... done
[18:01:06.172] result() for ClusterFuture ...
[18:01:06.172] - result already collected: FutureResult
[18:01:06.172] result() for ClusterFuture ... done
[18:01:06.172] - relayed: [n=2] TRUE, FALSE
[18:01:06.172] - queued futures: [n=2] TRUE, FALSE
[18:01:06.172] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:06.173]  length: 1 (resolved future 1)
[18:01:06.195] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.195] - Validating connection of MultisessionFuture
[18:01:06.195] - received message: FutureResult
[18:01:06.196] - Received FutureResult
[18:01:06.196] - Erased future from FutureRegistry
[18:01:06.196] result() for ClusterFuture ...
[18:01:06.196] - result already collected: FutureResult
[18:01:06.196] result() for ClusterFuture ... done
[18:01:06.196] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.197] Future #2
[18:01:06.197] result() for ClusterFuture ...
[18:01:06.197] - result already collected: FutureResult
[18:01:06.197] result() for ClusterFuture ... done
[18:01:06.197] result() for ClusterFuture ...
[18:01:06.198] - result already collected: FutureResult
[18:01:06.198] result() for ClusterFuture ... done
[18:01:06.198] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:06.198] - nx: 2
[18:01:06.198] - relay: TRUE
[18:01:06.199] - stdout: TRUE
[18:01:06.199] - signal: TRUE
[18:01:06.199] - resignal: FALSE
[18:01:06.199] - force: TRUE
[18:01:06.199] - relayed: [n=2] TRUE, FALSE
[18:01:06.199] - queued futures: [n=2] TRUE, FALSE
[18:01:06.200]  - until=2
[18:01:06.200]  - relaying element #2
[18:01:06.200] result() for ClusterFuture ...
[18:01:06.200] - result already collected: FutureResult
[18:01:06.200] result() for ClusterFuture ... done
[18:01:06.201] result() for ClusterFuture ...
[18:01:06.201] - result already collected: FutureResult
[18:01:06.201] result() for ClusterFuture ... done
[18:01:06.201] result() for ClusterFuture ...
[18:01:06.201] - result already collected: FutureResult
[18:01:06.202] result() for ClusterFuture ... done
[18:01:06.202] result() for ClusterFuture ...
[18:01:06.202] - result already collected: FutureResult
[18:01:06.202] result() for ClusterFuture ... done
[18:01:06.202] - relayed: [n=2] TRUE, TRUE
[18:01:06.202] - queued futures: [n=2] TRUE, TRUE
[18:01:06.203] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:06.203]  length: 0 (resolved future 2)
[18:01:06.203] Relaying remaining futures
[18:01:06.203] signalConditionsASAP(NULL, pos=0) ...
[18:01:06.203] - nx: 2
[18:01:06.204] - relay: TRUE
[18:01:06.204] - stdout: TRUE
[18:01:06.204] - signal: TRUE
[18:01:06.204] - resignal: FALSE
[18:01:06.204] - force: TRUE
[18:01:06.204] - relayed: [n=2] TRUE, TRUE
[18:01:06.205] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:06.205] - relayed: [n=2] TRUE, TRUE
[18:01:06.205] - queued futures: [n=2] TRUE, TRUE
[18:01:06.205] signalConditionsASAP(NULL, pos=0) ... done
[18:01:06.206] resolve() on list ... DONE
[18:01:06.206] result() for ClusterFuture ...
[18:01:06.206] - result already collected: FutureResult
[18:01:06.206] result() for ClusterFuture ... done
[18:01:06.206] result() for ClusterFuture ...
[18:01:06.206] - result already collected: FutureResult
[18:01:06.207] result() for ClusterFuture ... done
[18:01:06.207] result() for ClusterFuture ...
[18:01:06.207] - result already collected: FutureResult
[18:01:06.207] result() for ClusterFuture ... done
[18:01:06.207] result() for ClusterFuture ...
[18:01:06.208] - result already collected: FutureResult
[18:01:06.208] result() for ClusterFuture ... done
[18:01:06.208]  - Number of value chunks collected: 2
[18:01:06.208] Resolving 2 futures (chunks) ... DONE
[18:01:06.208] Reducing values from 2 chunks ...
[18:01:06.209]  - Number of values collected after concatenation: 4
[18:01:06.209]  - Number of values expected: 4
[18:01:06.209] Reducing values from 2 chunks ... DONE
[18:01:06.209] future_mapply() ... DONE
[18:01:06.209] future_mapply() ...
[18:01:06.216] Number of chunks: 2
[18:01:06.216] getGlobalsAndPackagesXApply() ...
[18:01:06.216]  - future.globals: TRUE
[18:01:06.216] getGlobalsAndPackages() ...
[18:01:06.216] Searching for globals...
[18:01:06.219] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[18:01:06.220] Searching for globals ... DONE
[18:01:06.220] Resolving globals: FALSE
[18:01:06.221] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[18:01:06.221] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[18:01:06.222] - globals: [1] ‘FUN’
[18:01:06.225] 
[18:01:06.225] getGlobalsAndPackages() ... DONE
[18:01:06.225]  - globals found/used: [n=1] ‘FUN’
[18:01:06.225]  - needed namespaces: [n=0] 
[18:01:06.226] Finding globals ... DONE
[18:01:06.226] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:06.226] List of 2
[18:01:06.226]  $ ...future.FUN:function (x, y)  
[18:01:06.226]  $ MoreArgs     : NULL
[18:01:06.226]  - attr(*, "where")=List of 2
[18:01:06.226]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:06.226]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:06.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:06.226]  - attr(*, "resolved")= logi FALSE
[18:01:06.226]  - attr(*, "total_size")= num NA
[18:01:06.232] Packages to be attached in all futures: [n=0] 
[18:01:06.232] getGlobalsAndPackagesXApply() ... DONE
[18:01:06.232] Number of futures (= number of chunks): 2
[18:01:06.232] Launching 2 futures (chunks) ...
[18:01:06.233] Chunk #1 of 2 ...
[18:01:06.233]  - Finding globals in '...' for chunk #1 ...
[18:01:06.233] getGlobalsAndPackages() ...
[18:01:06.233] Searching for globals...
[18:01:06.234] 
[18:01:06.234] Searching for globals ... DONE
[18:01:06.234] - globals: [0] <none>
[18:01:06.234] getGlobalsAndPackages() ... DONE
[18:01:06.235]    + additional globals found: [n=0] 
[18:01:06.235]    + additional namespaces needed: [n=0] 
[18:01:06.235]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:06.235]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:06.235]  - seeds: <none>
[18:01:06.236]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.236] getGlobalsAndPackages() ...
[18:01:06.236] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.236] Resolving globals: FALSE
[18:01:06.237] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[18:01:06.238] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.238] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.238] 
[18:01:06.239] getGlobalsAndPackages() ... DONE
[18:01:06.239] run() for ‘Future’ ...
[18:01:06.239] - state: ‘created’
[18:01:06.240] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.262]   - Field: ‘node’
[18:01:06.262]   - Field: ‘label’
[18:01:06.262]   - Field: ‘local’
[18:01:06.262]   - Field: ‘owner’
[18:01:06.263]   - Field: ‘envir’
[18:01:06.263]   - Field: ‘workers’
[18:01:06.263]   - Field: ‘packages’
[18:01:06.263]   - Field: ‘gc’
[18:01:06.263]   - Field: ‘conditions’
[18:01:06.264]   - Field: ‘persistent’
[18:01:06.264]   - Field: ‘expr’
[18:01:06.264]   - Field: ‘uuid’
[18:01:06.264]   - Field: ‘seed’
[18:01:06.264]   - Field: ‘version’
[18:01:06.265]   - Field: ‘result’
[18:01:06.265]   - Field: ‘asynchronous’
[18:01:06.265]   - Field: ‘calls’
[18:01:06.265]   - Field: ‘globals’
[18:01:06.265]   - Field: ‘stdout’
[18:01:06.265]   - Field: ‘earlySignal’
[18:01:06.266]   - Field: ‘lazy’
[18:01:06.266]   - Field: ‘state’
[18:01:06.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.266] - Launch lazy future ...
[18:01:06.267] Packages needed by the future expression (n = 0): <none>
[18:01:06.267] Packages needed by future strategies (n = 0): <none>
[18:01:06.268] {
[18:01:06.268]     {
[18:01:06.268]         {
[18:01:06.268]             ...future.startTime <- base::Sys.time()
[18:01:06.268]             {
[18:01:06.268]                 {
[18:01:06.268]                   {
[18:01:06.268]                     {
[18:01:06.268]                       base::local({
[18:01:06.268]                         has_future <- base::requireNamespace("future", 
[18:01:06.268]                           quietly = TRUE)
[18:01:06.268]                         if (has_future) {
[18:01:06.268]                           ns <- base::getNamespace("future")
[18:01:06.268]                           version <- ns[[".package"]][["version"]]
[18:01:06.268]                           if (is.null(version)) 
[18:01:06.268]                             version <- utils::packageVersion("future")
[18:01:06.268]                         }
[18:01:06.268]                         else {
[18:01:06.268]                           version <- NULL
[18:01:06.268]                         }
[18:01:06.268]                         if (!has_future || version < "1.8.0") {
[18:01:06.268]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.268]                             "", base::R.version$version.string), 
[18:01:06.268]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.268]                               "release", "version")], collapse = " "), 
[18:01:06.268]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.268]                             info)
[18:01:06.268]                           info <- base::paste(info, collapse = "; ")
[18:01:06.268]                           if (!has_future) {
[18:01:06.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.268]                               info)
[18:01:06.268]                           }
[18:01:06.268]                           else {
[18:01:06.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.268]                               info, version)
[18:01:06.268]                           }
[18:01:06.268]                           base::stop(msg)
[18:01:06.268]                         }
[18:01:06.268]                       })
[18:01:06.268]                     }
[18:01:06.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.268]                     base::options(mc.cores = 1L)
[18:01:06.268]                   }
[18:01:06.268]                   ...future.strategy.old <- future::plan("list")
[18:01:06.268]                   options(future.plan = NULL)
[18:01:06.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.268]                 }
[18:01:06.268]                 ...future.workdir <- getwd()
[18:01:06.268]             }
[18:01:06.268]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.268]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.268]         }
[18:01:06.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.268]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:06.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.268]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.268]             base::names(...future.oldOptions))
[18:01:06.268]     }
[18:01:06.268]     if (FALSE) {
[18:01:06.268]     }
[18:01:06.268]     else {
[18:01:06.268]         if (TRUE) {
[18:01:06.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.268]                 open = "w")
[18:01:06.268]         }
[18:01:06.268]         else {
[18:01:06.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.268]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.268]         }
[18:01:06.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.268]             base::sink(type = "output", split = FALSE)
[18:01:06.268]             base::close(...future.stdout)
[18:01:06.268]         }, add = TRUE)
[18:01:06.268]     }
[18:01:06.268]     ...future.frame <- base::sys.nframe()
[18:01:06.268]     ...future.conditions <- base::list()
[18:01:06.268]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.268]     if (FALSE) {
[18:01:06.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.268]     }
[18:01:06.268]     ...future.result <- base::tryCatch({
[18:01:06.268]         base::withCallingHandlers({
[18:01:06.268]             ...future.value <- base::withVisible(base::local({
[18:01:06.268]                 ...future.makeSendCondition <- base::local({
[18:01:06.268]                   sendCondition <- NULL
[18:01:06.268]                   function(frame = 1L) {
[18:01:06.268]                     if (is.function(sendCondition)) 
[18:01:06.268]                       return(sendCondition)
[18:01:06.268]                     ns <- getNamespace("parallel")
[18:01:06.268]                     if (exists("sendData", mode = "function", 
[18:01:06.268]                       envir = ns)) {
[18:01:06.268]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.268]                         envir = ns)
[18:01:06.268]                       envir <- sys.frame(frame)
[18:01:06.268]                       master <- NULL
[18:01:06.268]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.268]                         !identical(envir, emptyenv())) {
[18:01:06.268]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.268]                           inherits = FALSE)) {
[18:01:06.268]                           master <- get("master", mode = "list", 
[18:01:06.268]                             envir = envir, inherits = FALSE)
[18:01:06.268]                           if (inherits(master, c("SOCKnode", 
[18:01:06.268]                             "SOCK0node"))) {
[18:01:06.268]                             sendCondition <<- function(cond) {
[18:01:06.268]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.268]                                 success = TRUE)
[18:01:06.268]                               parallel_sendData(master, data)
[18:01:06.268]                             }
[18:01:06.268]                             return(sendCondition)
[18:01:06.268]                           }
[18:01:06.268]                         }
[18:01:06.268]                         frame <- frame + 1L
[18:01:06.268]                         envir <- sys.frame(frame)
[18:01:06.268]                       }
[18:01:06.268]                     }
[18:01:06.268]                     sendCondition <<- function(cond) NULL
[18:01:06.268]                   }
[18:01:06.268]                 })
[18:01:06.268]                 withCallingHandlers({
[18:01:06.268]                   {
[18:01:06.268]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.268]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.268]                       ...future.globals.maxSize)) {
[18:01:06.268]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.268]                       on.exit(options(oopts), add = TRUE)
[18:01:06.268]                     }
[18:01:06.268]                     {
[18:01:06.268]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.268]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.268]                         USE.NAMES = FALSE)
[18:01:06.268]                       do.call(mapply, args = args)
[18:01:06.268]                     }
[18:01:06.268]                   }
[18:01:06.268]                 }, immediateCondition = function(cond) {
[18:01:06.268]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.268]                   sendCondition(cond)
[18:01:06.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.268]                   {
[18:01:06.268]                     inherits <- base::inherits
[18:01:06.268]                     invokeRestart <- base::invokeRestart
[18:01:06.268]                     is.null <- base::is.null
[18:01:06.268]                     muffled <- FALSE
[18:01:06.268]                     if (inherits(cond, "message")) {
[18:01:06.268]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.268]                       if (muffled) 
[18:01:06.268]                         invokeRestart("muffleMessage")
[18:01:06.268]                     }
[18:01:06.268]                     else if (inherits(cond, "warning")) {
[18:01:06.268]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.268]                       if (muffled) 
[18:01:06.268]                         invokeRestart("muffleWarning")
[18:01:06.268]                     }
[18:01:06.268]                     else if (inherits(cond, "condition")) {
[18:01:06.268]                       if (!is.null(pattern)) {
[18:01:06.268]                         computeRestarts <- base::computeRestarts
[18:01:06.268]                         grepl <- base::grepl
[18:01:06.268]                         restarts <- computeRestarts(cond)
[18:01:06.268]                         for (restart in restarts) {
[18:01:06.268]                           name <- restart$name
[18:01:06.268]                           if (is.null(name)) 
[18:01:06.268]                             next
[18:01:06.268]                           if (!grepl(pattern, name)) 
[18:01:06.268]                             next
[18:01:06.268]                           invokeRestart(restart)
[18:01:06.268]                           muffled <- TRUE
[18:01:06.268]                           break
[18:01:06.268]                         }
[18:01:06.268]                       }
[18:01:06.268]                     }
[18:01:06.268]                     invisible(muffled)
[18:01:06.268]                   }
[18:01:06.268]                   muffleCondition(cond)
[18:01:06.268]                 })
[18:01:06.268]             }))
[18:01:06.268]             future::FutureResult(value = ...future.value$value, 
[18:01:06.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.268]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.268]                     ...future.globalenv.names))
[18:01:06.268]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.268]         }, condition = base::local({
[18:01:06.268]             c <- base::c
[18:01:06.268]             inherits <- base::inherits
[18:01:06.268]             invokeRestart <- base::invokeRestart
[18:01:06.268]             length <- base::length
[18:01:06.268]             list <- base::list
[18:01:06.268]             seq.int <- base::seq.int
[18:01:06.268]             signalCondition <- base::signalCondition
[18:01:06.268]             sys.calls <- base::sys.calls
[18:01:06.268]             `[[` <- base::`[[`
[18:01:06.268]             `+` <- base::`+`
[18:01:06.268]             `<<-` <- base::`<<-`
[18:01:06.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.268]                   3L)]
[18:01:06.268]             }
[18:01:06.268]             function(cond) {
[18:01:06.268]                 is_error <- inherits(cond, "error")
[18:01:06.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.268]                   NULL)
[18:01:06.268]                 if (is_error) {
[18:01:06.268]                   sessionInformation <- function() {
[18:01:06.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.268]                       search = base::search(), system = base::Sys.info())
[18:01:06.268]                   }
[18:01:06.268]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.268]                     cond$call), session = sessionInformation(), 
[18:01:06.268]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.268]                   signalCondition(cond)
[18:01:06.268]                 }
[18:01:06.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.268]                 "immediateCondition"))) {
[18:01:06.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.268]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.268]                   if (TRUE && !signal) {
[18:01:06.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.268]                     {
[18:01:06.268]                       inherits <- base::inherits
[18:01:06.268]                       invokeRestart <- base::invokeRestart
[18:01:06.268]                       is.null <- base::is.null
[18:01:06.268]                       muffled <- FALSE
[18:01:06.268]                       if (inherits(cond, "message")) {
[18:01:06.268]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.268]                         if (muffled) 
[18:01:06.268]                           invokeRestart("muffleMessage")
[18:01:06.268]                       }
[18:01:06.268]                       else if (inherits(cond, "warning")) {
[18:01:06.268]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.268]                         if (muffled) 
[18:01:06.268]                           invokeRestart("muffleWarning")
[18:01:06.268]                       }
[18:01:06.268]                       else if (inherits(cond, "condition")) {
[18:01:06.268]                         if (!is.null(pattern)) {
[18:01:06.268]                           computeRestarts <- base::computeRestarts
[18:01:06.268]                           grepl <- base::grepl
[18:01:06.268]                           restarts <- computeRestarts(cond)
[18:01:06.268]                           for (restart in restarts) {
[18:01:06.268]                             name <- restart$name
[18:01:06.268]                             if (is.null(name)) 
[18:01:06.268]                               next
[18:01:06.268]                             if (!grepl(pattern, name)) 
[18:01:06.268]                               next
[18:01:06.268]                             invokeRestart(restart)
[18:01:06.268]                             muffled <- TRUE
[18:01:06.268]                             break
[18:01:06.268]                           }
[18:01:06.268]                         }
[18:01:06.268]                       }
[18:01:06.268]                       invisible(muffled)
[18:01:06.268]                     }
[18:01:06.268]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.268]                   }
[18:01:06.268]                 }
[18:01:06.268]                 else {
[18:01:06.268]                   if (TRUE) {
[18:01:06.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.268]                     {
[18:01:06.268]                       inherits <- base::inherits
[18:01:06.268]                       invokeRestart <- base::invokeRestart
[18:01:06.268]                       is.null <- base::is.null
[18:01:06.268]                       muffled <- FALSE
[18:01:06.268]                       if (inherits(cond, "message")) {
[18:01:06.268]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.268]                         if (muffled) 
[18:01:06.268]                           invokeRestart("muffleMessage")
[18:01:06.268]                       }
[18:01:06.268]                       else if (inherits(cond, "warning")) {
[18:01:06.268]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.268]                         if (muffled) 
[18:01:06.268]                           invokeRestart("muffleWarning")
[18:01:06.268]                       }
[18:01:06.268]                       else if (inherits(cond, "condition")) {
[18:01:06.268]                         if (!is.null(pattern)) {
[18:01:06.268]                           computeRestarts <- base::computeRestarts
[18:01:06.268]                           grepl <- base::grepl
[18:01:06.268]                           restarts <- computeRestarts(cond)
[18:01:06.268]                           for (restart in restarts) {
[18:01:06.268]                             name <- restart$name
[18:01:06.268]                             if (is.null(name)) 
[18:01:06.268]                               next
[18:01:06.268]                             if (!grepl(pattern, name)) 
[18:01:06.268]                               next
[18:01:06.268]                             invokeRestart(restart)
[18:01:06.268]                             muffled <- TRUE
[18:01:06.268]                             break
[18:01:06.268]                           }
[18:01:06.268]                         }
[18:01:06.268]                       }
[18:01:06.268]                       invisible(muffled)
[18:01:06.268]                     }
[18:01:06.268]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.268]                   }
[18:01:06.268]                 }
[18:01:06.268]             }
[18:01:06.268]         }))
[18:01:06.268]     }, error = function(ex) {
[18:01:06.268]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.268]                 ...future.rng), started = ...future.startTime, 
[18:01:06.268]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.268]             version = "1.8"), class = "FutureResult")
[18:01:06.268]     }, finally = {
[18:01:06.268]         if (!identical(...future.workdir, getwd())) 
[18:01:06.268]             setwd(...future.workdir)
[18:01:06.268]         {
[18:01:06.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.268]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.268]             }
[18:01:06.268]             base::options(...future.oldOptions)
[18:01:06.268]             if (.Platform$OS.type == "windows") {
[18:01:06.268]                 old_names <- names(...future.oldEnvVars)
[18:01:06.268]                 envs <- base::Sys.getenv()
[18:01:06.268]                 names <- names(envs)
[18:01:06.268]                 common <- intersect(names, old_names)
[18:01:06.268]                 added <- setdiff(names, old_names)
[18:01:06.268]                 removed <- setdiff(old_names, names)
[18:01:06.268]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.268]                   envs[common]]
[18:01:06.268]                 NAMES <- toupper(changed)
[18:01:06.268]                 args <- list()
[18:01:06.268]                 for (kk in seq_along(NAMES)) {
[18:01:06.268]                   name <- changed[[kk]]
[18:01:06.268]                   NAME <- NAMES[[kk]]
[18:01:06.268]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.268]                     next
[18:01:06.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.268]                 }
[18:01:06.268]                 NAMES <- toupper(added)
[18:01:06.268]                 for (kk in seq_along(NAMES)) {
[18:01:06.268]                   name <- added[[kk]]
[18:01:06.268]                   NAME <- NAMES[[kk]]
[18:01:06.268]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.268]                     next
[18:01:06.268]                   args[[name]] <- ""
[18:01:06.268]                 }
[18:01:06.268]                 NAMES <- toupper(removed)
[18:01:06.268]                 for (kk in seq_along(NAMES)) {
[18:01:06.268]                   name <- removed[[kk]]
[18:01:06.268]                   NAME <- NAMES[[kk]]
[18:01:06.268]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.268]                     next
[18:01:06.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.268]                 }
[18:01:06.268]                 if (length(args) > 0) 
[18:01:06.268]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.268]             }
[18:01:06.268]             else {
[18:01:06.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.268]             }
[18:01:06.268]             {
[18:01:06.268]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.268]                   0L) {
[18:01:06.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.268]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.268]                   base::options(opts)
[18:01:06.268]                 }
[18:01:06.268]                 {
[18:01:06.268]                   {
[18:01:06.268]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.268]                     NULL
[18:01:06.268]                   }
[18:01:06.268]                   options(future.plan = NULL)
[18:01:06.268]                   if (is.na(NA_character_)) 
[18:01:06.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.268]                     .init = FALSE)
[18:01:06.268]                 }
[18:01:06.268]             }
[18:01:06.268]         }
[18:01:06.268]     })
[18:01:06.268]     if (TRUE) {
[18:01:06.268]         base::sink(type = "output", split = FALSE)
[18:01:06.268]         if (TRUE) {
[18:01:06.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.268]         }
[18:01:06.268]         else {
[18:01:06.268]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.268]         }
[18:01:06.268]         base::close(...future.stdout)
[18:01:06.268]         ...future.stdout <- NULL
[18:01:06.268]     }
[18:01:06.268]     ...future.result$conditions <- ...future.conditions
[18:01:06.268]     ...future.result$finished <- base::Sys.time()
[18:01:06.268]     ...future.result
[18:01:06.268] }
[18:01:06.273] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[18:01:06.273] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[18:01:06.274] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[18:01:06.274] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:06.275] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.276] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:01:06.276] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:01:06.277] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:06.278] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:06.279] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.279] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[18:01:06.280] MultisessionFuture started
[18:01:06.280] - Launch lazy future ... done
[18:01:06.280] run() for ‘MultisessionFuture’ ... done
[18:01:06.281] Created future:
[18:01:06.281] MultisessionFuture:
[18:01:06.281] Label: ‘future_mapply-1’
[18:01:06.281] Expression:
[18:01:06.281] {
[18:01:06.281]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.281]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.281]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.281]         on.exit(options(oopts), add = TRUE)
[18:01:06.281]     }
[18:01:06.281]     {
[18:01:06.281]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.281]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.281]         do.call(mapply, args = args)
[18:01:06.281]     }
[18:01:06.281] }
[18:01:06.281] Lazy evaluation: FALSE
[18:01:06.281] Asynchronous evaluation: TRUE
[18:01:06.281] Local evaluation: TRUE
[18:01:06.281] Environment: R_GlobalEnv
[18:01:06.281] Capture standard output: TRUE
[18:01:06.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.281] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.281] Packages: <none>
[18:01:06.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.281] Resolved: FALSE
[18:01:06.281] Value: <not collected>
[18:01:06.281] Conditions captured: <none>
[18:01:06.281] Early signaling: FALSE
[18:01:06.281] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.281] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.293] Chunk #1 of 2 ... DONE
[18:01:06.294] Chunk #2 of 2 ...
[18:01:06.294]  - Finding globals in '...' for chunk #2 ...
[18:01:06.294] getGlobalsAndPackages() ...
[18:01:06.294] Searching for globals...
[18:01:06.295] 
[18:01:06.295] Searching for globals ... DONE
[18:01:06.295] - globals: [0] <none>
[18:01:06.296] getGlobalsAndPackages() ... DONE
[18:01:06.296]    + additional globals found: [n=0] 
[18:01:06.296]    + additional namespaces needed: [n=0] 
[18:01:06.296]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:06.296]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:06.297]  - seeds: <none>
[18:01:06.297]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.297] getGlobalsAndPackages() ...
[18:01:06.297] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.297] Resolving globals: FALSE
[18:01:06.298] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[18:01:06.299] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.300] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.300] 
[18:01:06.300] getGlobalsAndPackages() ... DONE
[18:01:06.301] run() for ‘Future’ ...
[18:01:06.301] - state: ‘created’
[18:01:06.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.323] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.324]   - Field: ‘node’
[18:01:06.324]   - Field: ‘label’
[18:01:06.324]   - Field: ‘local’
[18:01:06.325]   - Field: ‘owner’
[18:01:06.325]   - Field: ‘envir’
[18:01:06.325]   - Field: ‘workers’
[18:01:06.325]   - Field: ‘packages’
[18:01:06.325]   - Field: ‘gc’
[18:01:06.326]   - Field: ‘conditions’
[18:01:06.326]   - Field: ‘persistent’
[18:01:06.326]   - Field: ‘expr’
[18:01:06.326]   - Field: ‘uuid’
[18:01:06.326]   - Field: ‘seed’
[18:01:06.327]   - Field: ‘version’
[18:01:06.327]   - Field: ‘result’
[18:01:06.327]   - Field: ‘asynchronous’
[18:01:06.327]   - Field: ‘calls’
[18:01:06.327]   - Field: ‘globals’
[18:01:06.328]   - Field: ‘stdout’
[18:01:06.328]   - Field: ‘earlySignal’
[18:01:06.328]   - Field: ‘lazy’
[18:01:06.328]   - Field: ‘state’
[18:01:06.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.329] - Launch lazy future ...
[18:01:06.329] Packages needed by the future expression (n = 0): <none>
[18:01:06.329] Packages needed by future strategies (n = 0): <none>
[18:01:06.330] {
[18:01:06.330]     {
[18:01:06.330]         {
[18:01:06.330]             ...future.startTime <- base::Sys.time()
[18:01:06.330]             {
[18:01:06.330]                 {
[18:01:06.330]                   {
[18:01:06.330]                     {
[18:01:06.330]                       base::local({
[18:01:06.330]                         has_future <- base::requireNamespace("future", 
[18:01:06.330]                           quietly = TRUE)
[18:01:06.330]                         if (has_future) {
[18:01:06.330]                           ns <- base::getNamespace("future")
[18:01:06.330]                           version <- ns[[".package"]][["version"]]
[18:01:06.330]                           if (is.null(version)) 
[18:01:06.330]                             version <- utils::packageVersion("future")
[18:01:06.330]                         }
[18:01:06.330]                         else {
[18:01:06.330]                           version <- NULL
[18:01:06.330]                         }
[18:01:06.330]                         if (!has_future || version < "1.8.0") {
[18:01:06.330]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.330]                             "", base::R.version$version.string), 
[18:01:06.330]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.330]                               "release", "version")], collapse = " "), 
[18:01:06.330]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.330]                             info)
[18:01:06.330]                           info <- base::paste(info, collapse = "; ")
[18:01:06.330]                           if (!has_future) {
[18:01:06.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.330]                               info)
[18:01:06.330]                           }
[18:01:06.330]                           else {
[18:01:06.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.330]                               info, version)
[18:01:06.330]                           }
[18:01:06.330]                           base::stop(msg)
[18:01:06.330]                         }
[18:01:06.330]                       })
[18:01:06.330]                     }
[18:01:06.330]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.330]                     base::options(mc.cores = 1L)
[18:01:06.330]                   }
[18:01:06.330]                   ...future.strategy.old <- future::plan("list")
[18:01:06.330]                   options(future.plan = NULL)
[18:01:06.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.330]                 }
[18:01:06.330]                 ...future.workdir <- getwd()
[18:01:06.330]             }
[18:01:06.330]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.330]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.330]         }
[18:01:06.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.330]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:06.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.330]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.330]             base::names(...future.oldOptions))
[18:01:06.330]     }
[18:01:06.330]     if (FALSE) {
[18:01:06.330]     }
[18:01:06.330]     else {
[18:01:06.330]         if (TRUE) {
[18:01:06.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.330]                 open = "w")
[18:01:06.330]         }
[18:01:06.330]         else {
[18:01:06.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.330]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.330]         }
[18:01:06.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.330]             base::sink(type = "output", split = FALSE)
[18:01:06.330]             base::close(...future.stdout)
[18:01:06.330]         }, add = TRUE)
[18:01:06.330]     }
[18:01:06.330]     ...future.frame <- base::sys.nframe()
[18:01:06.330]     ...future.conditions <- base::list()
[18:01:06.330]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.330]     if (FALSE) {
[18:01:06.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.330]     }
[18:01:06.330]     ...future.result <- base::tryCatch({
[18:01:06.330]         base::withCallingHandlers({
[18:01:06.330]             ...future.value <- base::withVisible(base::local({
[18:01:06.330]                 ...future.makeSendCondition <- base::local({
[18:01:06.330]                   sendCondition <- NULL
[18:01:06.330]                   function(frame = 1L) {
[18:01:06.330]                     if (is.function(sendCondition)) 
[18:01:06.330]                       return(sendCondition)
[18:01:06.330]                     ns <- getNamespace("parallel")
[18:01:06.330]                     if (exists("sendData", mode = "function", 
[18:01:06.330]                       envir = ns)) {
[18:01:06.330]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.330]                         envir = ns)
[18:01:06.330]                       envir <- sys.frame(frame)
[18:01:06.330]                       master <- NULL
[18:01:06.330]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.330]                         !identical(envir, emptyenv())) {
[18:01:06.330]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.330]                           inherits = FALSE)) {
[18:01:06.330]                           master <- get("master", mode = "list", 
[18:01:06.330]                             envir = envir, inherits = FALSE)
[18:01:06.330]                           if (inherits(master, c("SOCKnode", 
[18:01:06.330]                             "SOCK0node"))) {
[18:01:06.330]                             sendCondition <<- function(cond) {
[18:01:06.330]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.330]                                 success = TRUE)
[18:01:06.330]                               parallel_sendData(master, data)
[18:01:06.330]                             }
[18:01:06.330]                             return(sendCondition)
[18:01:06.330]                           }
[18:01:06.330]                         }
[18:01:06.330]                         frame <- frame + 1L
[18:01:06.330]                         envir <- sys.frame(frame)
[18:01:06.330]                       }
[18:01:06.330]                     }
[18:01:06.330]                     sendCondition <<- function(cond) NULL
[18:01:06.330]                   }
[18:01:06.330]                 })
[18:01:06.330]                 withCallingHandlers({
[18:01:06.330]                   {
[18:01:06.330]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.330]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.330]                       ...future.globals.maxSize)) {
[18:01:06.330]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.330]                       on.exit(options(oopts), add = TRUE)
[18:01:06.330]                     }
[18:01:06.330]                     {
[18:01:06.330]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.330]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.330]                         USE.NAMES = FALSE)
[18:01:06.330]                       do.call(mapply, args = args)
[18:01:06.330]                     }
[18:01:06.330]                   }
[18:01:06.330]                 }, immediateCondition = function(cond) {
[18:01:06.330]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.330]                   sendCondition(cond)
[18:01:06.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.330]                   {
[18:01:06.330]                     inherits <- base::inherits
[18:01:06.330]                     invokeRestart <- base::invokeRestart
[18:01:06.330]                     is.null <- base::is.null
[18:01:06.330]                     muffled <- FALSE
[18:01:06.330]                     if (inherits(cond, "message")) {
[18:01:06.330]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.330]                       if (muffled) 
[18:01:06.330]                         invokeRestart("muffleMessage")
[18:01:06.330]                     }
[18:01:06.330]                     else if (inherits(cond, "warning")) {
[18:01:06.330]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.330]                       if (muffled) 
[18:01:06.330]                         invokeRestart("muffleWarning")
[18:01:06.330]                     }
[18:01:06.330]                     else if (inherits(cond, "condition")) {
[18:01:06.330]                       if (!is.null(pattern)) {
[18:01:06.330]                         computeRestarts <- base::computeRestarts
[18:01:06.330]                         grepl <- base::grepl
[18:01:06.330]                         restarts <- computeRestarts(cond)
[18:01:06.330]                         for (restart in restarts) {
[18:01:06.330]                           name <- restart$name
[18:01:06.330]                           if (is.null(name)) 
[18:01:06.330]                             next
[18:01:06.330]                           if (!grepl(pattern, name)) 
[18:01:06.330]                             next
[18:01:06.330]                           invokeRestart(restart)
[18:01:06.330]                           muffled <- TRUE
[18:01:06.330]                           break
[18:01:06.330]                         }
[18:01:06.330]                       }
[18:01:06.330]                     }
[18:01:06.330]                     invisible(muffled)
[18:01:06.330]                   }
[18:01:06.330]                   muffleCondition(cond)
[18:01:06.330]                 })
[18:01:06.330]             }))
[18:01:06.330]             future::FutureResult(value = ...future.value$value, 
[18:01:06.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.330]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.330]                     ...future.globalenv.names))
[18:01:06.330]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.330]         }, condition = base::local({
[18:01:06.330]             c <- base::c
[18:01:06.330]             inherits <- base::inherits
[18:01:06.330]             invokeRestart <- base::invokeRestart
[18:01:06.330]             length <- base::length
[18:01:06.330]             list <- base::list
[18:01:06.330]             seq.int <- base::seq.int
[18:01:06.330]             signalCondition <- base::signalCondition
[18:01:06.330]             sys.calls <- base::sys.calls
[18:01:06.330]             `[[` <- base::`[[`
[18:01:06.330]             `+` <- base::`+`
[18:01:06.330]             `<<-` <- base::`<<-`
[18:01:06.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.330]                   3L)]
[18:01:06.330]             }
[18:01:06.330]             function(cond) {
[18:01:06.330]                 is_error <- inherits(cond, "error")
[18:01:06.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.330]                   NULL)
[18:01:06.330]                 if (is_error) {
[18:01:06.330]                   sessionInformation <- function() {
[18:01:06.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.330]                       search = base::search(), system = base::Sys.info())
[18:01:06.330]                   }
[18:01:06.330]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.330]                     cond$call), session = sessionInformation(), 
[18:01:06.330]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.330]                   signalCondition(cond)
[18:01:06.330]                 }
[18:01:06.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.330]                 "immediateCondition"))) {
[18:01:06.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.330]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.330]                   if (TRUE && !signal) {
[18:01:06.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.330]                     {
[18:01:06.330]                       inherits <- base::inherits
[18:01:06.330]                       invokeRestart <- base::invokeRestart
[18:01:06.330]                       is.null <- base::is.null
[18:01:06.330]                       muffled <- FALSE
[18:01:06.330]                       if (inherits(cond, "message")) {
[18:01:06.330]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.330]                         if (muffled) 
[18:01:06.330]                           invokeRestart("muffleMessage")
[18:01:06.330]                       }
[18:01:06.330]                       else if (inherits(cond, "warning")) {
[18:01:06.330]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.330]                         if (muffled) 
[18:01:06.330]                           invokeRestart("muffleWarning")
[18:01:06.330]                       }
[18:01:06.330]                       else if (inherits(cond, "condition")) {
[18:01:06.330]                         if (!is.null(pattern)) {
[18:01:06.330]                           computeRestarts <- base::computeRestarts
[18:01:06.330]                           grepl <- base::grepl
[18:01:06.330]                           restarts <- computeRestarts(cond)
[18:01:06.330]                           for (restart in restarts) {
[18:01:06.330]                             name <- restart$name
[18:01:06.330]                             if (is.null(name)) 
[18:01:06.330]                               next
[18:01:06.330]                             if (!grepl(pattern, name)) 
[18:01:06.330]                               next
[18:01:06.330]                             invokeRestart(restart)
[18:01:06.330]                             muffled <- TRUE
[18:01:06.330]                             break
[18:01:06.330]                           }
[18:01:06.330]                         }
[18:01:06.330]                       }
[18:01:06.330]                       invisible(muffled)
[18:01:06.330]                     }
[18:01:06.330]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.330]                   }
[18:01:06.330]                 }
[18:01:06.330]                 else {
[18:01:06.330]                   if (TRUE) {
[18:01:06.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.330]                     {
[18:01:06.330]                       inherits <- base::inherits
[18:01:06.330]                       invokeRestart <- base::invokeRestart
[18:01:06.330]                       is.null <- base::is.null
[18:01:06.330]                       muffled <- FALSE
[18:01:06.330]                       if (inherits(cond, "message")) {
[18:01:06.330]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.330]                         if (muffled) 
[18:01:06.330]                           invokeRestart("muffleMessage")
[18:01:06.330]                       }
[18:01:06.330]                       else if (inherits(cond, "warning")) {
[18:01:06.330]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.330]                         if (muffled) 
[18:01:06.330]                           invokeRestart("muffleWarning")
[18:01:06.330]                       }
[18:01:06.330]                       else if (inherits(cond, "condition")) {
[18:01:06.330]                         if (!is.null(pattern)) {
[18:01:06.330]                           computeRestarts <- base::computeRestarts
[18:01:06.330]                           grepl <- base::grepl
[18:01:06.330]                           restarts <- computeRestarts(cond)
[18:01:06.330]                           for (restart in restarts) {
[18:01:06.330]                             name <- restart$name
[18:01:06.330]                             if (is.null(name)) 
[18:01:06.330]                               next
[18:01:06.330]                             if (!grepl(pattern, name)) 
[18:01:06.330]                               next
[18:01:06.330]                             invokeRestart(restart)
[18:01:06.330]                             muffled <- TRUE
[18:01:06.330]                             break
[18:01:06.330]                           }
[18:01:06.330]                         }
[18:01:06.330]                       }
[18:01:06.330]                       invisible(muffled)
[18:01:06.330]                     }
[18:01:06.330]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.330]                   }
[18:01:06.330]                 }
[18:01:06.330]             }
[18:01:06.330]         }))
[18:01:06.330]     }, error = function(ex) {
[18:01:06.330]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.330]                 ...future.rng), started = ...future.startTime, 
[18:01:06.330]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.330]             version = "1.8"), class = "FutureResult")
[18:01:06.330]     }, finally = {
[18:01:06.330]         if (!identical(...future.workdir, getwd())) 
[18:01:06.330]             setwd(...future.workdir)
[18:01:06.330]         {
[18:01:06.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.330]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.330]             }
[18:01:06.330]             base::options(...future.oldOptions)
[18:01:06.330]             if (.Platform$OS.type == "windows") {
[18:01:06.330]                 old_names <- names(...future.oldEnvVars)
[18:01:06.330]                 envs <- base::Sys.getenv()
[18:01:06.330]                 names <- names(envs)
[18:01:06.330]                 common <- intersect(names, old_names)
[18:01:06.330]                 added <- setdiff(names, old_names)
[18:01:06.330]                 removed <- setdiff(old_names, names)
[18:01:06.330]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.330]                   envs[common]]
[18:01:06.330]                 NAMES <- toupper(changed)
[18:01:06.330]                 args <- list()
[18:01:06.330]                 for (kk in seq_along(NAMES)) {
[18:01:06.330]                   name <- changed[[kk]]
[18:01:06.330]                   NAME <- NAMES[[kk]]
[18:01:06.330]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.330]                     next
[18:01:06.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.330]                 }
[18:01:06.330]                 NAMES <- toupper(added)
[18:01:06.330]                 for (kk in seq_along(NAMES)) {
[18:01:06.330]                   name <- added[[kk]]
[18:01:06.330]                   NAME <- NAMES[[kk]]
[18:01:06.330]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.330]                     next
[18:01:06.330]                   args[[name]] <- ""
[18:01:06.330]                 }
[18:01:06.330]                 NAMES <- toupper(removed)
[18:01:06.330]                 for (kk in seq_along(NAMES)) {
[18:01:06.330]                   name <- removed[[kk]]
[18:01:06.330]                   NAME <- NAMES[[kk]]
[18:01:06.330]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.330]                     next
[18:01:06.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.330]                 }
[18:01:06.330]                 if (length(args) > 0) 
[18:01:06.330]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.330]             }
[18:01:06.330]             else {
[18:01:06.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.330]             }
[18:01:06.330]             {
[18:01:06.330]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.330]                   0L) {
[18:01:06.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.330]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.330]                   base::options(opts)
[18:01:06.330]                 }
[18:01:06.330]                 {
[18:01:06.330]                   {
[18:01:06.330]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.330]                     NULL
[18:01:06.330]                   }
[18:01:06.330]                   options(future.plan = NULL)
[18:01:06.330]                   if (is.na(NA_character_)) 
[18:01:06.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.330]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.330]                     .init = FALSE)
[18:01:06.330]                 }
[18:01:06.330]             }
[18:01:06.330]         }
[18:01:06.330]     })
[18:01:06.330]     if (TRUE) {
[18:01:06.330]         base::sink(type = "output", split = FALSE)
[18:01:06.330]         if (TRUE) {
[18:01:06.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.330]         }
[18:01:06.330]         else {
[18:01:06.330]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.330]         }
[18:01:06.330]         base::close(...future.stdout)
[18:01:06.330]         ...future.stdout <- NULL
[18:01:06.330]     }
[18:01:06.330]     ...future.result$conditions <- ...future.conditions
[18:01:06.330]     ...future.result$finished <- base::Sys.time()
[18:01:06.330]     ...future.result
[18:01:06.330] }
[18:01:06.335] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[18:01:06.335] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[18:01:06.336] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[18:01:06.337] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:06.337] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.338] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:06.339] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:06.339] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:06.340] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.341] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:06.342] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.342] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[18:01:06.343] MultisessionFuture started
[18:01:06.344] - Launch lazy future ... done
[18:01:06.345] run() for ‘MultisessionFuture’ ... done
[18:01:06.345] Created future:
[18:01:06.345] MultisessionFuture:
[18:01:06.345] Label: ‘future_mapply-2’
[18:01:06.345] Expression:
[18:01:06.345] {
[18:01:06.345]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.345]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.345]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.345]         on.exit(options(oopts), add = TRUE)
[18:01:06.345]     }
[18:01:06.345]     {
[18:01:06.345]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.345]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.345]         do.call(mapply, args = args)
[18:01:06.345]     }
[18:01:06.345] }
[18:01:06.345] Lazy evaluation: FALSE
[18:01:06.345] Asynchronous evaluation: TRUE
[18:01:06.345] Local evaluation: TRUE
[18:01:06.345] Environment: R_GlobalEnv
[18:01:06.345] Capture standard output: TRUE
[18:01:06.345] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.345] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.345] Packages: <none>
[18:01:06.345] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.345] Resolved: FALSE
[18:01:06.345] Value: <not collected>
[18:01:06.345] Conditions captured: <none>
[18:01:06.345] Early signaling: FALSE
[18:01:06.345] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.345] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.358] Chunk #2 of 2 ... DONE
[18:01:06.358] Launching 2 futures (chunks) ... DONE
[18:01:06.358] Resolving 2 futures (chunks) ...
[18:01:06.358] resolve() on list ...
[18:01:06.358]  recursive: 0
[18:01:06.359]  length: 2
[18:01:06.359] 
[18:01:06.360] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.360] - Validating connection of MultisessionFuture
[18:01:06.360] - received message: FutureResult
[18:01:06.361] - Received FutureResult
[18:01:06.361] - Erased future from FutureRegistry
[18:01:06.361] result() for ClusterFuture ...
[18:01:06.361] - result already collected: FutureResult
[18:01:06.361] result() for ClusterFuture ... done
[18:01:06.361] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.362] Future #1
[18:01:06.362] result() for ClusterFuture ...
[18:01:06.362] - result already collected: FutureResult
[18:01:06.362] result() for ClusterFuture ... done
[18:01:06.362] result() for ClusterFuture ...
[18:01:06.363] - result already collected: FutureResult
[18:01:06.363] result() for ClusterFuture ... done
[18:01:06.363] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:06.363] - nx: 2
[18:01:06.363] - relay: TRUE
[18:01:06.363] - stdout: TRUE
[18:01:06.364] - signal: TRUE
[18:01:06.364] - resignal: FALSE
[18:01:06.364] - force: TRUE
[18:01:06.364] - relayed: [n=2] FALSE, FALSE
[18:01:06.364] - queued futures: [n=2] FALSE, FALSE
[18:01:06.364]  - until=1
[18:01:06.365]  - relaying element #1
[18:01:06.365] result() for ClusterFuture ...
[18:01:06.365] - result already collected: FutureResult
[18:01:06.365] result() for ClusterFuture ... done
[18:01:06.365] result() for ClusterFuture ...
[18:01:06.366] - result already collected: FutureResult
[18:01:06.366] result() for ClusterFuture ... done
[18:01:06.366] result() for ClusterFuture ...
[18:01:06.366] - result already collected: FutureResult
[18:01:06.366] result() for ClusterFuture ... done
[18:01:06.367] result() for ClusterFuture ...
[18:01:06.367] - result already collected: FutureResult
[18:01:06.367] result() for ClusterFuture ... done
[18:01:06.367] - relayed: [n=2] TRUE, FALSE
[18:01:06.368] - queued futures: [n=2] TRUE, FALSE
[18:01:06.368] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:06.368]  length: 1 (resolved future 1)
[18:01:06.390] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.390] - Validating connection of MultisessionFuture
[18:01:06.391] - received message: FutureResult
[18:01:06.391] - Received FutureResult
[18:01:06.391] - Erased future from FutureRegistry
[18:01:06.391] result() for ClusterFuture ...
[18:01:06.392] - result already collected: FutureResult
[18:01:06.392] result() for ClusterFuture ... done
[18:01:06.392] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.392] Future #2
[18:01:06.392] result() for ClusterFuture ...
[18:01:06.392] - result already collected: FutureResult
[18:01:06.393] result() for ClusterFuture ... done
[18:01:06.393] result() for ClusterFuture ...
[18:01:06.393] - result already collected: FutureResult
[18:01:06.393] result() for ClusterFuture ... done
[18:01:06.393] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:06.394] - nx: 2
[18:01:06.394] - relay: TRUE
[18:01:06.394] - stdout: TRUE
[18:01:06.394] - signal: TRUE
[18:01:06.394] - resignal: FALSE
[18:01:06.394] - force: TRUE
[18:01:06.395] - relayed: [n=2] TRUE, FALSE
[18:01:06.395] - queued futures: [n=2] TRUE, FALSE
[18:01:06.395]  - until=2
[18:01:06.395]  - relaying element #2
[18:01:06.395] result() for ClusterFuture ...
[18:01:06.396] - result already collected: FutureResult
[18:01:06.396] result() for ClusterFuture ... done
[18:01:06.396] result() for ClusterFuture ...
[18:01:06.396] - result already collected: FutureResult
[18:01:06.396] result() for ClusterFuture ... done
[18:01:06.397] result() for ClusterFuture ...
[18:01:06.397] - result already collected: FutureResult
[18:01:06.397] result() for ClusterFuture ... done
[18:01:06.397] result() for ClusterFuture ...
[18:01:06.397] - result already collected: FutureResult
[18:01:06.397] result() for ClusterFuture ... done
[18:01:06.398] - relayed: [n=2] TRUE, TRUE
[18:01:06.398] - queued futures: [n=2] TRUE, TRUE
[18:01:06.398] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:06.398]  length: 0 (resolved future 2)
[18:01:06.398] Relaying remaining futures
[18:01:06.398] signalConditionsASAP(NULL, pos=0) ...
[18:01:06.399] - nx: 2
[18:01:06.399] - relay: TRUE
[18:01:06.399] - stdout: TRUE
[18:01:06.399] - signal: TRUE
[18:01:06.399] - resignal: FALSE
[18:01:06.399] - force: TRUE
[18:01:06.400] - relayed: [n=2] TRUE, TRUE
[18:01:06.400] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:06.400] - relayed: [n=2] TRUE, TRUE
[18:01:06.400] - queued futures: [n=2] TRUE, TRUE
[18:01:06.400] signalConditionsASAP(NULL, pos=0) ... done
[18:01:06.401] resolve() on list ... DONE
[18:01:06.401] result() for ClusterFuture ...
[18:01:06.401] - result already collected: FutureResult
[18:01:06.401] result() for ClusterFuture ... done
[18:01:06.401] result() for ClusterFuture ...
[18:01:06.402] - result already collected: FutureResult
[18:01:06.402] result() for ClusterFuture ... done
[18:01:06.402] result() for ClusterFuture ...
[18:01:06.402] - result already collected: FutureResult
[18:01:06.402] result() for ClusterFuture ... done
[18:01:06.402] result() for ClusterFuture ...
[18:01:06.403] - result already collected: FutureResult
[18:01:06.403] result() for ClusterFuture ... done
[18:01:06.403]  - Number of value chunks collected: 2
[18:01:06.403] Resolving 2 futures (chunks) ... DONE
[18:01:06.403] Reducing values from 2 chunks ...
[18:01:06.404]  - Number of values collected after concatenation: 3
[18:01:06.404]  - Number of values expected: 3
[18:01:06.404] Reducing values from 2 chunks ... DONE
[18:01:06.404] future_mapply() ... DONE
- future_.mapply()
[18:01:06.405] future_mapply() ...
[18:01:06.411] Number of chunks: 2
[18:01:06.412] getGlobalsAndPackagesXApply() ...
[18:01:06.412]  - future.globals: TRUE
[18:01:06.412] getGlobalsAndPackages() ...
[18:01:06.412] Searching for globals...
[18:01:06.415] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[18:01:06.415] Searching for globals ... DONE
[18:01:06.415] Resolving globals: FALSE
[18:01:06.416] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[18:01:06.417] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[18:01:06.418] - globals: [1] ‘FUN’
[18:01:06.418] 
[18:01:06.418] getGlobalsAndPackages() ... DONE
[18:01:06.418]  - globals found/used: [n=1] ‘FUN’
[18:01:06.419]  - needed namespaces: [n=0] 
[18:01:06.419] Finding globals ... DONE
[18:01:06.419] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:06.419] List of 2
[18:01:06.419]  $ ...future.FUN:function (x, y)  
[18:01:06.419]  $ MoreArgs     : list()
[18:01:06.419]  - attr(*, "where")=List of 2
[18:01:06.419]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:06.419]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:06.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:06.419]  - attr(*, "resolved")= logi FALSE
[18:01:06.419]  - attr(*, "total_size")= num NA
[18:01:06.425] Packages to be attached in all futures: [n=0] 
[18:01:06.425] getGlobalsAndPackagesXApply() ... DONE
[18:01:06.425] Number of futures (= number of chunks): 2
[18:01:06.426] Launching 2 futures (chunks) ...
[18:01:06.426] Chunk #1 of 2 ...
[18:01:06.426]  - Finding globals in '...' for chunk #1 ...
[18:01:06.426] getGlobalsAndPackages() ...
[18:01:06.426] Searching for globals...
[18:01:06.427] 
[18:01:06.428] Searching for globals ... DONE
[18:01:06.428] - globals: [0] <none>
[18:01:06.428] getGlobalsAndPackages() ... DONE
[18:01:06.428]    + additional globals found: [n=0] 
[18:01:06.428]    + additional namespaces needed: [n=0] 
[18:01:06.429]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:06.429]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:06.429]  - seeds: <none>
[18:01:06.429]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.429] getGlobalsAndPackages() ...
[18:01:06.430] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.430] Resolving globals: FALSE
[18:01:06.431] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[18:01:06.432] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:06.432] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.432] 
[18:01:06.433] getGlobalsAndPackages() ... DONE
[18:01:06.433] run() for ‘Future’ ...
[18:01:06.434] - state: ‘created’
[18:01:06.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.457]   - Field: ‘node’
[18:01:06.457]   - Field: ‘label’
[18:01:06.458]   - Field: ‘local’
[18:01:06.458]   - Field: ‘owner’
[18:01:06.458]   - Field: ‘envir’
[18:01:06.458]   - Field: ‘workers’
[18:01:06.458]   - Field: ‘packages’
[18:01:06.459]   - Field: ‘gc’
[18:01:06.459]   - Field: ‘conditions’
[18:01:06.459]   - Field: ‘persistent’
[18:01:06.459]   - Field: ‘expr’
[18:01:06.459]   - Field: ‘uuid’
[18:01:06.460]   - Field: ‘seed’
[18:01:06.460]   - Field: ‘version’
[18:01:06.460]   - Field: ‘result’
[18:01:06.460]   - Field: ‘asynchronous’
[18:01:06.460]   - Field: ‘calls’
[18:01:06.461]   - Field: ‘globals’
[18:01:06.461]   - Field: ‘stdout’
[18:01:06.461]   - Field: ‘earlySignal’
[18:01:06.461]   - Field: ‘lazy’
[18:01:06.461]   - Field: ‘state’
[18:01:06.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.462] - Launch lazy future ...
[18:01:06.462] Packages needed by the future expression (n = 0): <none>
[18:01:06.462] Packages needed by future strategies (n = 0): <none>
[18:01:06.463] {
[18:01:06.463]     {
[18:01:06.463]         {
[18:01:06.463]             ...future.startTime <- base::Sys.time()
[18:01:06.463]             {
[18:01:06.463]                 {
[18:01:06.463]                   {
[18:01:06.463]                     {
[18:01:06.463]                       base::local({
[18:01:06.463]                         has_future <- base::requireNamespace("future", 
[18:01:06.463]                           quietly = TRUE)
[18:01:06.463]                         if (has_future) {
[18:01:06.463]                           ns <- base::getNamespace("future")
[18:01:06.463]                           version <- ns[[".package"]][["version"]]
[18:01:06.463]                           if (is.null(version)) 
[18:01:06.463]                             version <- utils::packageVersion("future")
[18:01:06.463]                         }
[18:01:06.463]                         else {
[18:01:06.463]                           version <- NULL
[18:01:06.463]                         }
[18:01:06.463]                         if (!has_future || version < "1.8.0") {
[18:01:06.463]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.463]                             "", base::R.version$version.string), 
[18:01:06.463]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.463]                               "release", "version")], collapse = " "), 
[18:01:06.463]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.463]                             info)
[18:01:06.463]                           info <- base::paste(info, collapse = "; ")
[18:01:06.463]                           if (!has_future) {
[18:01:06.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.463]                               info)
[18:01:06.463]                           }
[18:01:06.463]                           else {
[18:01:06.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.463]                               info, version)
[18:01:06.463]                           }
[18:01:06.463]                           base::stop(msg)
[18:01:06.463]                         }
[18:01:06.463]                       })
[18:01:06.463]                     }
[18:01:06.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.463]                     base::options(mc.cores = 1L)
[18:01:06.463]                   }
[18:01:06.463]                   ...future.strategy.old <- future::plan("list")
[18:01:06.463]                   options(future.plan = NULL)
[18:01:06.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.463]                 }
[18:01:06.463]                 ...future.workdir <- getwd()
[18:01:06.463]             }
[18:01:06.463]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.463]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.463]         }
[18:01:06.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.463]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:06.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.463]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.463]             base::names(...future.oldOptions))
[18:01:06.463]     }
[18:01:06.463]     if (FALSE) {
[18:01:06.463]     }
[18:01:06.463]     else {
[18:01:06.463]         if (TRUE) {
[18:01:06.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.463]                 open = "w")
[18:01:06.463]         }
[18:01:06.463]         else {
[18:01:06.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.463]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.463]         }
[18:01:06.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.463]             base::sink(type = "output", split = FALSE)
[18:01:06.463]             base::close(...future.stdout)
[18:01:06.463]         }, add = TRUE)
[18:01:06.463]     }
[18:01:06.463]     ...future.frame <- base::sys.nframe()
[18:01:06.463]     ...future.conditions <- base::list()
[18:01:06.463]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.463]     if (FALSE) {
[18:01:06.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.463]     }
[18:01:06.463]     ...future.result <- base::tryCatch({
[18:01:06.463]         base::withCallingHandlers({
[18:01:06.463]             ...future.value <- base::withVisible(base::local({
[18:01:06.463]                 ...future.makeSendCondition <- base::local({
[18:01:06.463]                   sendCondition <- NULL
[18:01:06.463]                   function(frame = 1L) {
[18:01:06.463]                     if (is.function(sendCondition)) 
[18:01:06.463]                       return(sendCondition)
[18:01:06.463]                     ns <- getNamespace("parallel")
[18:01:06.463]                     if (exists("sendData", mode = "function", 
[18:01:06.463]                       envir = ns)) {
[18:01:06.463]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.463]                         envir = ns)
[18:01:06.463]                       envir <- sys.frame(frame)
[18:01:06.463]                       master <- NULL
[18:01:06.463]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.463]                         !identical(envir, emptyenv())) {
[18:01:06.463]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.463]                           inherits = FALSE)) {
[18:01:06.463]                           master <- get("master", mode = "list", 
[18:01:06.463]                             envir = envir, inherits = FALSE)
[18:01:06.463]                           if (inherits(master, c("SOCKnode", 
[18:01:06.463]                             "SOCK0node"))) {
[18:01:06.463]                             sendCondition <<- function(cond) {
[18:01:06.463]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.463]                                 success = TRUE)
[18:01:06.463]                               parallel_sendData(master, data)
[18:01:06.463]                             }
[18:01:06.463]                             return(sendCondition)
[18:01:06.463]                           }
[18:01:06.463]                         }
[18:01:06.463]                         frame <- frame + 1L
[18:01:06.463]                         envir <- sys.frame(frame)
[18:01:06.463]                       }
[18:01:06.463]                     }
[18:01:06.463]                     sendCondition <<- function(cond) NULL
[18:01:06.463]                   }
[18:01:06.463]                 })
[18:01:06.463]                 withCallingHandlers({
[18:01:06.463]                   {
[18:01:06.463]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.463]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.463]                       ...future.globals.maxSize)) {
[18:01:06.463]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.463]                       on.exit(options(oopts), add = TRUE)
[18:01:06.463]                     }
[18:01:06.463]                     {
[18:01:06.463]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.463]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.463]                         USE.NAMES = FALSE)
[18:01:06.463]                       do.call(mapply, args = args)
[18:01:06.463]                     }
[18:01:06.463]                   }
[18:01:06.463]                 }, immediateCondition = function(cond) {
[18:01:06.463]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.463]                   sendCondition(cond)
[18:01:06.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.463]                   {
[18:01:06.463]                     inherits <- base::inherits
[18:01:06.463]                     invokeRestart <- base::invokeRestart
[18:01:06.463]                     is.null <- base::is.null
[18:01:06.463]                     muffled <- FALSE
[18:01:06.463]                     if (inherits(cond, "message")) {
[18:01:06.463]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.463]                       if (muffled) 
[18:01:06.463]                         invokeRestart("muffleMessage")
[18:01:06.463]                     }
[18:01:06.463]                     else if (inherits(cond, "warning")) {
[18:01:06.463]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.463]                       if (muffled) 
[18:01:06.463]                         invokeRestart("muffleWarning")
[18:01:06.463]                     }
[18:01:06.463]                     else if (inherits(cond, "condition")) {
[18:01:06.463]                       if (!is.null(pattern)) {
[18:01:06.463]                         computeRestarts <- base::computeRestarts
[18:01:06.463]                         grepl <- base::grepl
[18:01:06.463]                         restarts <- computeRestarts(cond)
[18:01:06.463]                         for (restart in restarts) {
[18:01:06.463]                           name <- restart$name
[18:01:06.463]                           if (is.null(name)) 
[18:01:06.463]                             next
[18:01:06.463]                           if (!grepl(pattern, name)) 
[18:01:06.463]                             next
[18:01:06.463]                           invokeRestart(restart)
[18:01:06.463]                           muffled <- TRUE
[18:01:06.463]                           break
[18:01:06.463]                         }
[18:01:06.463]                       }
[18:01:06.463]                     }
[18:01:06.463]                     invisible(muffled)
[18:01:06.463]                   }
[18:01:06.463]                   muffleCondition(cond)
[18:01:06.463]                 })
[18:01:06.463]             }))
[18:01:06.463]             future::FutureResult(value = ...future.value$value, 
[18:01:06.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.463]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.463]                     ...future.globalenv.names))
[18:01:06.463]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.463]         }, condition = base::local({
[18:01:06.463]             c <- base::c
[18:01:06.463]             inherits <- base::inherits
[18:01:06.463]             invokeRestart <- base::invokeRestart
[18:01:06.463]             length <- base::length
[18:01:06.463]             list <- base::list
[18:01:06.463]             seq.int <- base::seq.int
[18:01:06.463]             signalCondition <- base::signalCondition
[18:01:06.463]             sys.calls <- base::sys.calls
[18:01:06.463]             `[[` <- base::`[[`
[18:01:06.463]             `+` <- base::`+`
[18:01:06.463]             `<<-` <- base::`<<-`
[18:01:06.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.463]                   3L)]
[18:01:06.463]             }
[18:01:06.463]             function(cond) {
[18:01:06.463]                 is_error <- inherits(cond, "error")
[18:01:06.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.463]                   NULL)
[18:01:06.463]                 if (is_error) {
[18:01:06.463]                   sessionInformation <- function() {
[18:01:06.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.463]                       search = base::search(), system = base::Sys.info())
[18:01:06.463]                   }
[18:01:06.463]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.463]                     cond$call), session = sessionInformation(), 
[18:01:06.463]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.463]                   signalCondition(cond)
[18:01:06.463]                 }
[18:01:06.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.463]                 "immediateCondition"))) {
[18:01:06.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.463]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.463]                   if (TRUE && !signal) {
[18:01:06.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.463]                     {
[18:01:06.463]                       inherits <- base::inherits
[18:01:06.463]                       invokeRestart <- base::invokeRestart
[18:01:06.463]                       is.null <- base::is.null
[18:01:06.463]                       muffled <- FALSE
[18:01:06.463]                       if (inherits(cond, "message")) {
[18:01:06.463]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.463]                         if (muffled) 
[18:01:06.463]                           invokeRestart("muffleMessage")
[18:01:06.463]                       }
[18:01:06.463]                       else if (inherits(cond, "warning")) {
[18:01:06.463]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.463]                         if (muffled) 
[18:01:06.463]                           invokeRestart("muffleWarning")
[18:01:06.463]                       }
[18:01:06.463]                       else if (inherits(cond, "condition")) {
[18:01:06.463]                         if (!is.null(pattern)) {
[18:01:06.463]                           computeRestarts <- base::computeRestarts
[18:01:06.463]                           grepl <- base::grepl
[18:01:06.463]                           restarts <- computeRestarts(cond)
[18:01:06.463]                           for (restart in restarts) {
[18:01:06.463]                             name <- restart$name
[18:01:06.463]                             if (is.null(name)) 
[18:01:06.463]                               next
[18:01:06.463]                             if (!grepl(pattern, name)) 
[18:01:06.463]                               next
[18:01:06.463]                             invokeRestart(restart)
[18:01:06.463]                             muffled <- TRUE
[18:01:06.463]                             break
[18:01:06.463]                           }
[18:01:06.463]                         }
[18:01:06.463]                       }
[18:01:06.463]                       invisible(muffled)
[18:01:06.463]                     }
[18:01:06.463]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.463]                   }
[18:01:06.463]                 }
[18:01:06.463]                 else {
[18:01:06.463]                   if (TRUE) {
[18:01:06.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.463]                     {
[18:01:06.463]                       inherits <- base::inherits
[18:01:06.463]                       invokeRestart <- base::invokeRestart
[18:01:06.463]                       is.null <- base::is.null
[18:01:06.463]                       muffled <- FALSE
[18:01:06.463]                       if (inherits(cond, "message")) {
[18:01:06.463]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.463]                         if (muffled) 
[18:01:06.463]                           invokeRestart("muffleMessage")
[18:01:06.463]                       }
[18:01:06.463]                       else if (inherits(cond, "warning")) {
[18:01:06.463]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.463]                         if (muffled) 
[18:01:06.463]                           invokeRestart("muffleWarning")
[18:01:06.463]                       }
[18:01:06.463]                       else if (inherits(cond, "condition")) {
[18:01:06.463]                         if (!is.null(pattern)) {
[18:01:06.463]                           computeRestarts <- base::computeRestarts
[18:01:06.463]                           grepl <- base::grepl
[18:01:06.463]                           restarts <- computeRestarts(cond)
[18:01:06.463]                           for (restart in restarts) {
[18:01:06.463]                             name <- restart$name
[18:01:06.463]                             if (is.null(name)) 
[18:01:06.463]                               next
[18:01:06.463]                             if (!grepl(pattern, name)) 
[18:01:06.463]                               next
[18:01:06.463]                             invokeRestart(restart)
[18:01:06.463]                             muffled <- TRUE
[18:01:06.463]                             break
[18:01:06.463]                           }
[18:01:06.463]                         }
[18:01:06.463]                       }
[18:01:06.463]                       invisible(muffled)
[18:01:06.463]                     }
[18:01:06.463]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.463]                   }
[18:01:06.463]                 }
[18:01:06.463]             }
[18:01:06.463]         }))
[18:01:06.463]     }, error = function(ex) {
[18:01:06.463]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.463]                 ...future.rng), started = ...future.startTime, 
[18:01:06.463]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.463]             version = "1.8"), class = "FutureResult")
[18:01:06.463]     }, finally = {
[18:01:06.463]         if (!identical(...future.workdir, getwd())) 
[18:01:06.463]             setwd(...future.workdir)
[18:01:06.463]         {
[18:01:06.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.463]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.463]             }
[18:01:06.463]             base::options(...future.oldOptions)
[18:01:06.463]             if (.Platform$OS.type == "windows") {
[18:01:06.463]                 old_names <- names(...future.oldEnvVars)
[18:01:06.463]                 envs <- base::Sys.getenv()
[18:01:06.463]                 names <- names(envs)
[18:01:06.463]                 common <- intersect(names, old_names)
[18:01:06.463]                 added <- setdiff(names, old_names)
[18:01:06.463]                 removed <- setdiff(old_names, names)
[18:01:06.463]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.463]                   envs[common]]
[18:01:06.463]                 NAMES <- toupper(changed)
[18:01:06.463]                 args <- list()
[18:01:06.463]                 for (kk in seq_along(NAMES)) {
[18:01:06.463]                   name <- changed[[kk]]
[18:01:06.463]                   NAME <- NAMES[[kk]]
[18:01:06.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.463]                     next
[18:01:06.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.463]                 }
[18:01:06.463]                 NAMES <- toupper(added)
[18:01:06.463]                 for (kk in seq_along(NAMES)) {
[18:01:06.463]                   name <- added[[kk]]
[18:01:06.463]                   NAME <- NAMES[[kk]]
[18:01:06.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.463]                     next
[18:01:06.463]                   args[[name]] <- ""
[18:01:06.463]                 }
[18:01:06.463]                 NAMES <- toupper(removed)
[18:01:06.463]                 for (kk in seq_along(NAMES)) {
[18:01:06.463]                   name <- removed[[kk]]
[18:01:06.463]                   NAME <- NAMES[[kk]]
[18:01:06.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.463]                     next
[18:01:06.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.463]                 }
[18:01:06.463]                 if (length(args) > 0) 
[18:01:06.463]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.463]             }
[18:01:06.463]             else {
[18:01:06.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.463]             }
[18:01:06.463]             {
[18:01:06.463]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.463]                   0L) {
[18:01:06.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.463]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.463]                   base::options(opts)
[18:01:06.463]                 }
[18:01:06.463]                 {
[18:01:06.463]                   {
[18:01:06.463]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.463]                     NULL
[18:01:06.463]                   }
[18:01:06.463]                   options(future.plan = NULL)
[18:01:06.463]                   if (is.na(NA_character_)) 
[18:01:06.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.463]                     .init = FALSE)
[18:01:06.463]                 }
[18:01:06.463]             }
[18:01:06.463]         }
[18:01:06.463]     })
[18:01:06.463]     if (TRUE) {
[18:01:06.463]         base::sink(type = "output", split = FALSE)
[18:01:06.463]         if (TRUE) {
[18:01:06.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.463]         }
[18:01:06.463]         else {
[18:01:06.463]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.463]         }
[18:01:06.463]         base::close(...future.stdout)
[18:01:06.463]         ...future.stdout <- NULL
[18:01:06.463]     }
[18:01:06.463]     ...future.result$conditions <- ...future.conditions
[18:01:06.463]     ...future.result$finished <- base::Sys.time()
[18:01:06.463]     ...future.result
[18:01:06.463] }
[18:01:06.468] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[18:01:06.469] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[18:01:06.470] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[18:01:06.470] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:06.471] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.471] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:01:06.472] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:01:06.472] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:06.473] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.474] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:06.474] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.475] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[18:01:06.476] MultisessionFuture started
[18:01:06.476] - Launch lazy future ... done
[18:01:06.476] run() for ‘MultisessionFuture’ ... done
[18:01:06.476] Created future:
[18:01:06.476] MultisessionFuture:
[18:01:06.476] Label: ‘future_.mapply-1’
[18:01:06.476] Expression:
[18:01:06.476] {
[18:01:06.476]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.476]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.476]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.476]         on.exit(options(oopts), add = TRUE)
[18:01:06.476]     }
[18:01:06.476]     {
[18:01:06.476]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.476]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.476]         do.call(mapply, args = args)
[18:01:06.476]     }
[18:01:06.476] }
[18:01:06.476] Lazy evaluation: FALSE
[18:01:06.476] Asynchronous evaluation: TRUE
[18:01:06.476] Local evaluation: TRUE
[18:01:06.476] Environment: R_GlobalEnv
[18:01:06.476] Capture standard output: TRUE
[18:01:06.476] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.476] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.476] Packages: <none>
[18:01:06.476] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.476] Resolved: FALSE
[18:01:06.476] Value: <not collected>
[18:01:06.476] Conditions captured: <none>
[18:01:06.476] Early signaling: FALSE
[18:01:06.476] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.476] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.489] Chunk #1 of 2 ... DONE
[18:01:06.489] Chunk #2 of 2 ...
[18:01:06.490]  - Finding globals in '...' for chunk #2 ...
[18:01:06.490] getGlobalsAndPackages() ...
[18:01:06.490] Searching for globals...
[18:01:06.491] 
[18:01:06.491] Searching for globals ... DONE
[18:01:06.491] - globals: [0] <none>
[18:01:06.492] getGlobalsAndPackages() ... DONE
[18:01:06.492]    + additional globals found: [n=0] 
[18:01:06.492]    + additional namespaces needed: [n=0] 
[18:01:06.492]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:06.492]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:06.492]  - seeds: <none>
[18:01:06.493]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.493] getGlobalsAndPackages() ...
[18:01:06.493] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.493] Resolving globals: FALSE
[18:01:06.494] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[18:01:06.495] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:06.496] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.496] 
[18:01:06.496] getGlobalsAndPackages() ... DONE
[18:01:06.497] run() for ‘Future’ ...
[18:01:06.497] - state: ‘created’
[18:01:06.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.527]   - Field: ‘node’
[18:01:06.527]   - Field: ‘label’
[18:01:06.527]   - Field: ‘local’
[18:01:06.527]   - Field: ‘owner’
[18:01:06.527]   - Field: ‘envir’
[18:01:06.528]   - Field: ‘workers’
[18:01:06.528]   - Field: ‘packages’
[18:01:06.528]   - Field: ‘gc’
[18:01:06.528]   - Field: ‘conditions’
[18:01:06.528]   - Field: ‘persistent’
[18:01:06.529]   - Field: ‘expr’
[18:01:06.529]   - Field: ‘uuid’
[18:01:06.529]   - Field: ‘seed’
[18:01:06.529]   - Field: ‘version’
[18:01:06.529]   - Field: ‘result’
[18:01:06.530]   - Field: ‘asynchronous’
[18:01:06.530]   - Field: ‘calls’
[18:01:06.530]   - Field: ‘globals’
[18:01:06.530]   - Field: ‘stdout’
[18:01:06.530]   - Field: ‘earlySignal’
[18:01:06.531]   - Field: ‘lazy’
[18:01:06.531]   - Field: ‘state’
[18:01:06.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.531] - Launch lazy future ...
[18:01:06.532] Packages needed by the future expression (n = 0): <none>
[18:01:06.532] Packages needed by future strategies (n = 0): <none>
[18:01:06.533] {
[18:01:06.533]     {
[18:01:06.533]         {
[18:01:06.533]             ...future.startTime <- base::Sys.time()
[18:01:06.533]             {
[18:01:06.533]                 {
[18:01:06.533]                   {
[18:01:06.533]                     {
[18:01:06.533]                       base::local({
[18:01:06.533]                         has_future <- base::requireNamespace("future", 
[18:01:06.533]                           quietly = TRUE)
[18:01:06.533]                         if (has_future) {
[18:01:06.533]                           ns <- base::getNamespace("future")
[18:01:06.533]                           version <- ns[[".package"]][["version"]]
[18:01:06.533]                           if (is.null(version)) 
[18:01:06.533]                             version <- utils::packageVersion("future")
[18:01:06.533]                         }
[18:01:06.533]                         else {
[18:01:06.533]                           version <- NULL
[18:01:06.533]                         }
[18:01:06.533]                         if (!has_future || version < "1.8.0") {
[18:01:06.533]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.533]                             "", base::R.version$version.string), 
[18:01:06.533]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.533]                               "release", "version")], collapse = " "), 
[18:01:06.533]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.533]                             info)
[18:01:06.533]                           info <- base::paste(info, collapse = "; ")
[18:01:06.533]                           if (!has_future) {
[18:01:06.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.533]                               info)
[18:01:06.533]                           }
[18:01:06.533]                           else {
[18:01:06.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.533]                               info, version)
[18:01:06.533]                           }
[18:01:06.533]                           base::stop(msg)
[18:01:06.533]                         }
[18:01:06.533]                       })
[18:01:06.533]                     }
[18:01:06.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.533]                     base::options(mc.cores = 1L)
[18:01:06.533]                   }
[18:01:06.533]                   ...future.strategy.old <- future::plan("list")
[18:01:06.533]                   options(future.plan = NULL)
[18:01:06.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.533]                 }
[18:01:06.533]                 ...future.workdir <- getwd()
[18:01:06.533]             }
[18:01:06.533]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.533]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.533]         }
[18:01:06.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.533]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:06.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.533]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.533]             base::names(...future.oldOptions))
[18:01:06.533]     }
[18:01:06.533]     if (FALSE) {
[18:01:06.533]     }
[18:01:06.533]     else {
[18:01:06.533]         if (TRUE) {
[18:01:06.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.533]                 open = "w")
[18:01:06.533]         }
[18:01:06.533]         else {
[18:01:06.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.533]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.533]         }
[18:01:06.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.533]             base::sink(type = "output", split = FALSE)
[18:01:06.533]             base::close(...future.stdout)
[18:01:06.533]         }, add = TRUE)
[18:01:06.533]     }
[18:01:06.533]     ...future.frame <- base::sys.nframe()
[18:01:06.533]     ...future.conditions <- base::list()
[18:01:06.533]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.533]     if (FALSE) {
[18:01:06.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.533]     }
[18:01:06.533]     ...future.result <- base::tryCatch({
[18:01:06.533]         base::withCallingHandlers({
[18:01:06.533]             ...future.value <- base::withVisible(base::local({
[18:01:06.533]                 ...future.makeSendCondition <- base::local({
[18:01:06.533]                   sendCondition <- NULL
[18:01:06.533]                   function(frame = 1L) {
[18:01:06.533]                     if (is.function(sendCondition)) 
[18:01:06.533]                       return(sendCondition)
[18:01:06.533]                     ns <- getNamespace("parallel")
[18:01:06.533]                     if (exists("sendData", mode = "function", 
[18:01:06.533]                       envir = ns)) {
[18:01:06.533]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.533]                         envir = ns)
[18:01:06.533]                       envir <- sys.frame(frame)
[18:01:06.533]                       master <- NULL
[18:01:06.533]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.533]                         !identical(envir, emptyenv())) {
[18:01:06.533]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.533]                           inherits = FALSE)) {
[18:01:06.533]                           master <- get("master", mode = "list", 
[18:01:06.533]                             envir = envir, inherits = FALSE)
[18:01:06.533]                           if (inherits(master, c("SOCKnode", 
[18:01:06.533]                             "SOCK0node"))) {
[18:01:06.533]                             sendCondition <<- function(cond) {
[18:01:06.533]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.533]                                 success = TRUE)
[18:01:06.533]                               parallel_sendData(master, data)
[18:01:06.533]                             }
[18:01:06.533]                             return(sendCondition)
[18:01:06.533]                           }
[18:01:06.533]                         }
[18:01:06.533]                         frame <- frame + 1L
[18:01:06.533]                         envir <- sys.frame(frame)
[18:01:06.533]                       }
[18:01:06.533]                     }
[18:01:06.533]                     sendCondition <<- function(cond) NULL
[18:01:06.533]                   }
[18:01:06.533]                 })
[18:01:06.533]                 withCallingHandlers({
[18:01:06.533]                   {
[18:01:06.533]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.533]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.533]                       ...future.globals.maxSize)) {
[18:01:06.533]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.533]                       on.exit(options(oopts), add = TRUE)
[18:01:06.533]                     }
[18:01:06.533]                     {
[18:01:06.533]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.533]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.533]                         USE.NAMES = FALSE)
[18:01:06.533]                       do.call(mapply, args = args)
[18:01:06.533]                     }
[18:01:06.533]                   }
[18:01:06.533]                 }, immediateCondition = function(cond) {
[18:01:06.533]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.533]                   sendCondition(cond)
[18:01:06.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.533]                   {
[18:01:06.533]                     inherits <- base::inherits
[18:01:06.533]                     invokeRestart <- base::invokeRestart
[18:01:06.533]                     is.null <- base::is.null
[18:01:06.533]                     muffled <- FALSE
[18:01:06.533]                     if (inherits(cond, "message")) {
[18:01:06.533]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.533]                       if (muffled) 
[18:01:06.533]                         invokeRestart("muffleMessage")
[18:01:06.533]                     }
[18:01:06.533]                     else if (inherits(cond, "warning")) {
[18:01:06.533]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.533]                       if (muffled) 
[18:01:06.533]                         invokeRestart("muffleWarning")
[18:01:06.533]                     }
[18:01:06.533]                     else if (inherits(cond, "condition")) {
[18:01:06.533]                       if (!is.null(pattern)) {
[18:01:06.533]                         computeRestarts <- base::computeRestarts
[18:01:06.533]                         grepl <- base::grepl
[18:01:06.533]                         restarts <- computeRestarts(cond)
[18:01:06.533]                         for (restart in restarts) {
[18:01:06.533]                           name <- restart$name
[18:01:06.533]                           if (is.null(name)) 
[18:01:06.533]                             next
[18:01:06.533]                           if (!grepl(pattern, name)) 
[18:01:06.533]                             next
[18:01:06.533]                           invokeRestart(restart)
[18:01:06.533]                           muffled <- TRUE
[18:01:06.533]                           break
[18:01:06.533]                         }
[18:01:06.533]                       }
[18:01:06.533]                     }
[18:01:06.533]                     invisible(muffled)
[18:01:06.533]                   }
[18:01:06.533]                   muffleCondition(cond)
[18:01:06.533]                 })
[18:01:06.533]             }))
[18:01:06.533]             future::FutureResult(value = ...future.value$value, 
[18:01:06.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.533]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.533]                     ...future.globalenv.names))
[18:01:06.533]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.533]         }, condition = base::local({
[18:01:06.533]             c <- base::c
[18:01:06.533]             inherits <- base::inherits
[18:01:06.533]             invokeRestart <- base::invokeRestart
[18:01:06.533]             length <- base::length
[18:01:06.533]             list <- base::list
[18:01:06.533]             seq.int <- base::seq.int
[18:01:06.533]             signalCondition <- base::signalCondition
[18:01:06.533]             sys.calls <- base::sys.calls
[18:01:06.533]             `[[` <- base::`[[`
[18:01:06.533]             `+` <- base::`+`
[18:01:06.533]             `<<-` <- base::`<<-`
[18:01:06.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.533]                   3L)]
[18:01:06.533]             }
[18:01:06.533]             function(cond) {
[18:01:06.533]                 is_error <- inherits(cond, "error")
[18:01:06.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.533]                   NULL)
[18:01:06.533]                 if (is_error) {
[18:01:06.533]                   sessionInformation <- function() {
[18:01:06.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.533]                       search = base::search(), system = base::Sys.info())
[18:01:06.533]                   }
[18:01:06.533]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.533]                     cond$call), session = sessionInformation(), 
[18:01:06.533]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.533]                   signalCondition(cond)
[18:01:06.533]                 }
[18:01:06.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.533]                 "immediateCondition"))) {
[18:01:06.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.533]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.533]                   if (TRUE && !signal) {
[18:01:06.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.533]                     {
[18:01:06.533]                       inherits <- base::inherits
[18:01:06.533]                       invokeRestart <- base::invokeRestart
[18:01:06.533]                       is.null <- base::is.null
[18:01:06.533]                       muffled <- FALSE
[18:01:06.533]                       if (inherits(cond, "message")) {
[18:01:06.533]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.533]                         if (muffled) 
[18:01:06.533]                           invokeRestart("muffleMessage")
[18:01:06.533]                       }
[18:01:06.533]                       else if (inherits(cond, "warning")) {
[18:01:06.533]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.533]                         if (muffled) 
[18:01:06.533]                           invokeRestart("muffleWarning")
[18:01:06.533]                       }
[18:01:06.533]                       else if (inherits(cond, "condition")) {
[18:01:06.533]                         if (!is.null(pattern)) {
[18:01:06.533]                           computeRestarts <- base::computeRestarts
[18:01:06.533]                           grepl <- base::grepl
[18:01:06.533]                           restarts <- computeRestarts(cond)
[18:01:06.533]                           for (restart in restarts) {
[18:01:06.533]                             name <- restart$name
[18:01:06.533]                             if (is.null(name)) 
[18:01:06.533]                               next
[18:01:06.533]                             if (!grepl(pattern, name)) 
[18:01:06.533]                               next
[18:01:06.533]                             invokeRestart(restart)
[18:01:06.533]                             muffled <- TRUE
[18:01:06.533]                             break
[18:01:06.533]                           }
[18:01:06.533]                         }
[18:01:06.533]                       }
[18:01:06.533]                       invisible(muffled)
[18:01:06.533]                     }
[18:01:06.533]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.533]                   }
[18:01:06.533]                 }
[18:01:06.533]                 else {
[18:01:06.533]                   if (TRUE) {
[18:01:06.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.533]                     {
[18:01:06.533]                       inherits <- base::inherits
[18:01:06.533]                       invokeRestart <- base::invokeRestart
[18:01:06.533]                       is.null <- base::is.null
[18:01:06.533]                       muffled <- FALSE
[18:01:06.533]                       if (inherits(cond, "message")) {
[18:01:06.533]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.533]                         if (muffled) 
[18:01:06.533]                           invokeRestart("muffleMessage")
[18:01:06.533]                       }
[18:01:06.533]                       else if (inherits(cond, "warning")) {
[18:01:06.533]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.533]                         if (muffled) 
[18:01:06.533]                           invokeRestart("muffleWarning")
[18:01:06.533]                       }
[18:01:06.533]                       else if (inherits(cond, "condition")) {
[18:01:06.533]                         if (!is.null(pattern)) {
[18:01:06.533]                           computeRestarts <- base::computeRestarts
[18:01:06.533]                           grepl <- base::grepl
[18:01:06.533]                           restarts <- computeRestarts(cond)
[18:01:06.533]                           for (restart in restarts) {
[18:01:06.533]                             name <- restart$name
[18:01:06.533]                             if (is.null(name)) 
[18:01:06.533]                               next
[18:01:06.533]                             if (!grepl(pattern, name)) 
[18:01:06.533]                               next
[18:01:06.533]                             invokeRestart(restart)
[18:01:06.533]                             muffled <- TRUE
[18:01:06.533]                             break
[18:01:06.533]                           }
[18:01:06.533]                         }
[18:01:06.533]                       }
[18:01:06.533]                       invisible(muffled)
[18:01:06.533]                     }
[18:01:06.533]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.533]                   }
[18:01:06.533]                 }
[18:01:06.533]             }
[18:01:06.533]         }))
[18:01:06.533]     }, error = function(ex) {
[18:01:06.533]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.533]                 ...future.rng), started = ...future.startTime, 
[18:01:06.533]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.533]             version = "1.8"), class = "FutureResult")
[18:01:06.533]     }, finally = {
[18:01:06.533]         if (!identical(...future.workdir, getwd())) 
[18:01:06.533]             setwd(...future.workdir)
[18:01:06.533]         {
[18:01:06.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.533]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.533]             }
[18:01:06.533]             base::options(...future.oldOptions)
[18:01:06.533]             if (.Platform$OS.type == "windows") {
[18:01:06.533]                 old_names <- names(...future.oldEnvVars)
[18:01:06.533]                 envs <- base::Sys.getenv()
[18:01:06.533]                 names <- names(envs)
[18:01:06.533]                 common <- intersect(names, old_names)
[18:01:06.533]                 added <- setdiff(names, old_names)
[18:01:06.533]                 removed <- setdiff(old_names, names)
[18:01:06.533]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.533]                   envs[common]]
[18:01:06.533]                 NAMES <- toupper(changed)
[18:01:06.533]                 args <- list()
[18:01:06.533]                 for (kk in seq_along(NAMES)) {
[18:01:06.533]                   name <- changed[[kk]]
[18:01:06.533]                   NAME <- NAMES[[kk]]
[18:01:06.533]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.533]                     next
[18:01:06.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.533]                 }
[18:01:06.533]                 NAMES <- toupper(added)
[18:01:06.533]                 for (kk in seq_along(NAMES)) {
[18:01:06.533]                   name <- added[[kk]]
[18:01:06.533]                   NAME <- NAMES[[kk]]
[18:01:06.533]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.533]                     next
[18:01:06.533]                   args[[name]] <- ""
[18:01:06.533]                 }
[18:01:06.533]                 NAMES <- toupper(removed)
[18:01:06.533]                 for (kk in seq_along(NAMES)) {
[18:01:06.533]                   name <- removed[[kk]]
[18:01:06.533]                   NAME <- NAMES[[kk]]
[18:01:06.533]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.533]                     next
[18:01:06.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.533]                 }
[18:01:06.533]                 if (length(args) > 0) 
[18:01:06.533]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.533]             }
[18:01:06.533]             else {
[18:01:06.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.533]             }
[18:01:06.533]             {
[18:01:06.533]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.533]                   0L) {
[18:01:06.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.533]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.533]                   base::options(opts)
[18:01:06.533]                 }
[18:01:06.533]                 {
[18:01:06.533]                   {
[18:01:06.533]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.533]                     NULL
[18:01:06.533]                   }
[18:01:06.533]                   options(future.plan = NULL)
[18:01:06.533]                   if (is.na(NA_character_)) 
[18:01:06.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.533]                     .init = FALSE)
[18:01:06.533]                 }
[18:01:06.533]             }
[18:01:06.533]         }
[18:01:06.533]     })
[18:01:06.533]     if (TRUE) {
[18:01:06.533]         base::sink(type = "output", split = FALSE)
[18:01:06.533]         if (TRUE) {
[18:01:06.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.533]         }
[18:01:06.533]         else {
[18:01:06.533]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.533]         }
[18:01:06.533]         base::close(...future.stdout)
[18:01:06.533]         ...future.stdout <- NULL
[18:01:06.533]     }
[18:01:06.533]     ...future.result$conditions <- ...future.conditions
[18:01:06.533]     ...future.result$finished <- base::Sys.time()
[18:01:06.533]     ...future.result
[18:01:06.533] }
[18:01:06.538] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[18:01:06.541] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[18:01:06.542] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[18:01:06.543] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:06.543] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.544] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:06.545] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:06.545] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:06.546] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.546] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:06.547] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.547] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[18:01:06.548] MultisessionFuture started
[18:01:06.548] - Launch lazy future ... done
[18:01:06.548] run() for ‘MultisessionFuture’ ... done
[18:01:06.549] Created future:
[18:01:06.549] MultisessionFuture:
[18:01:06.549] Label: ‘future_.mapply-2’
[18:01:06.549] Expression:
[18:01:06.549] {
[18:01:06.549]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.549]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.549]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.549]         on.exit(options(oopts), add = TRUE)
[18:01:06.549]     }
[18:01:06.549]     {
[18:01:06.549]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.549]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.549]         do.call(mapply, args = args)
[18:01:06.549]     }
[18:01:06.549] }
[18:01:06.549] Lazy evaluation: FALSE
[18:01:06.549] Asynchronous evaluation: TRUE
[18:01:06.549] Local evaluation: TRUE
[18:01:06.549] Environment: R_GlobalEnv
[18:01:06.549] Capture standard output: TRUE
[18:01:06.549] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.549] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.549] Packages: <none>
[18:01:06.549] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.549] Resolved: FALSE
[18:01:06.549] Value: <not collected>
[18:01:06.549] Conditions captured: <none>
[18:01:06.549] Early signaling: FALSE
[18:01:06.549] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.549] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.561] Chunk #2 of 2 ... DONE
[18:01:06.562] Launching 2 futures (chunks) ... DONE
[18:01:06.562] Resolving 2 futures (chunks) ...
[18:01:06.562] resolve() on list ...
[18:01:06.562]  recursive: 0
[18:01:06.562]  length: 2
[18:01:06.563] 
[18:01:06.564] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.564] - Validating connection of MultisessionFuture
[18:01:06.564] - received message: FutureResult
[18:01:06.564] - Received FutureResult
[18:01:06.565] - Erased future from FutureRegistry
[18:01:06.565] result() for ClusterFuture ...
[18:01:06.565] - result already collected: FutureResult
[18:01:06.565] result() for ClusterFuture ... done
[18:01:06.565] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.565] Future #1
[18:01:06.566] result() for ClusterFuture ...
[18:01:06.566] - result already collected: FutureResult
[18:01:06.566] result() for ClusterFuture ... done
[18:01:06.566] result() for ClusterFuture ...
[18:01:06.566] - result already collected: FutureResult
[18:01:06.567] result() for ClusterFuture ... done
[18:01:06.567] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:06.567] - nx: 2
[18:01:06.567] - relay: TRUE
[18:01:06.567] - stdout: TRUE
[18:01:06.567] - signal: TRUE
[18:01:06.568] - resignal: FALSE
[18:01:06.568] - force: TRUE
[18:01:06.568] - relayed: [n=2] FALSE, FALSE
[18:01:06.568] - queued futures: [n=2] FALSE, FALSE
[18:01:06.568]  - until=1
[18:01:06.568]  - relaying element #1
[18:01:06.569] result() for ClusterFuture ...
[18:01:06.569] - result already collected: FutureResult
[18:01:06.569] result() for ClusterFuture ... done
[18:01:06.570] result() for ClusterFuture ...
[18:01:06.570] - result already collected: FutureResult
[18:01:06.570] result() for ClusterFuture ... done
[18:01:06.570] result() for ClusterFuture ...
[18:01:06.570] - result already collected: FutureResult
[18:01:06.571] result() for ClusterFuture ... done
[18:01:06.571] result() for ClusterFuture ...
[18:01:06.571] - result already collected: FutureResult
[18:01:06.571] result() for ClusterFuture ... done
[18:01:06.571] - relayed: [n=2] TRUE, FALSE
[18:01:06.571] - queued futures: [n=2] TRUE, FALSE
[18:01:06.572] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:06.572]  length: 1 (resolved future 1)
[18:01:06.594] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.594] - Validating connection of MultisessionFuture
[18:01:06.595] - received message: FutureResult
[18:01:06.595] - Received FutureResult
[18:01:06.595] - Erased future from FutureRegistry
[18:01:06.595] result() for ClusterFuture ...
[18:01:06.595] - result already collected: FutureResult
[18:01:06.596] result() for ClusterFuture ... done
[18:01:06.596] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.596] Future #2
[18:01:06.596] result() for ClusterFuture ...
[18:01:06.596] - result already collected: FutureResult
[18:01:06.597] result() for ClusterFuture ... done
[18:01:06.597] result() for ClusterFuture ...
[18:01:06.597] - result already collected: FutureResult
[18:01:06.597] result() for ClusterFuture ... done
[18:01:06.597] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:06.597] - nx: 2
[18:01:06.598] - relay: TRUE
[18:01:06.598] - stdout: TRUE
[18:01:06.598] - signal: TRUE
[18:01:06.598] - resignal: FALSE
[18:01:06.598] - force: TRUE
[18:01:06.599] - relayed: [n=2] TRUE, FALSE
[18:01:06.599] - queued futures: [n=2] TRUE, FALSE
[18:01:06.599]  - until=2
[18:01:06.599]  - relaying element #2
[18:01:06.599] result() for ClusterFuture ...
[18:01:06.599] - result already collected: FutureResult
[18:01:06.600] result() for ClusterFuture ... done
[18:01:06.600] result() for ClusterFuture ...
[18:01:06.600] - result already collected: FutureResult
[18:01:06.600] result() for ClusterFuture ... done
[18:01:06.600] result() for ClusterFuture ...
[18:01:06.601] - result already collected: FutureResult
[18:01:06.601] result() for ClusterFuture ... done
[18:01:06.601] result() for ClusterFuture ...
[18:01:06.601] - result already collected: FutureResult
[18:01:06.601] result() for ClusterFuture ... done
[18:01:06.601] - relayed: [n=2] TRUE, TRUE
[18:01:06.602] - queued futures: [n=2] TRUE, TRUE
[18:01:06.602] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:06.602]  length: 0 (resolved future 2)
[18:01:06.602] Relaying remaining futures
[18:01:06.602] signalConditionsASAP(NULL, pos=0) ...
[18:01:06.603] - nx: 2
[18:01:06.603] - relay: TRUE
[18:01:06.603] - stdout: TRUE
[18:01:06.603] - signal: TRUE
[18:01:06.603] - resignal: FALSE
[18:01:06.603] - force: TRUE
[18:01:06.604] - relayed: [n=2] TRUE, TRUE
[18:01:06.604] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:06.604] - relayed: [n=2] TRUE, TRUE
[18:01:06.604] - queued futures: [n=2] TRUE, TRUE
[18:01:06.604] signalConditionsASAP(NULL, pos=0) ... done
[18:01:06.605] resolve() on list ... DONE
[18:01:06.605] result() for ClusterFuture ...
[18:01:06.605] - result already collected: FutureResult
[18:01:06.605] result() for ClusterFuture ... done
[18:01:06.605] result() for ClusterFuture ...
[18:01:06.605] - result already collected: FutureResult
[18:01:06.606] result() for ClusterFuture ... done
[18:01:06.606] result() for ClusterFuture ...
[18:01:06.606] - result already collected: FutureResult
[18:01:06.606] result() for ClusterFuture ... done
[18:01:06.606] result() for ClusterFuture ...
[18:01:06.607] - result already collected: FutureResult
[18:01:06.607] result() for ClusterFuture ... done
[18:01:06.607]  - Number of value chunks collected: 2
[18:01:06.607] Resolving 2 futures (chunks) ... DONE
[18:01:06.607] Reducing values from 2 chunks ...
[18:01:06.607]  - Number of values collected after concatenation: 3
[18:01:06.608]  - Number of values expected: 3
[18:01:06.608] Reducing values from 2 chunks ... DONE
[18:01:06.608] future_mapply() ... DONE
[18:01:06.609] future_mapply() ...
[18:01:06.615] Number of chunks: 5
[18:01:06.615] getGlobalsAndPackagesXApply() ...
[18:01:06.615]  - future.globals: TRUE
[18:01:06.615] getGlobalsAndPackages() ...
[18:01:06.616] Searching for globals...
[18:01:06.618] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:06.618] Searching for globals ... DONE
[18:01:06.619] Resolving globals: FALSE
[18:01:06.619] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:06.620] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:06.620] - globals: [1] ‘FUN’
[18:01:06.620] 
[18:01:06.621] getGlobalsAndPackages() ... DONE
[18:01:06.621]  - globals found/used: [n=1] ‘FUN’
[18:01:06.621]  - needed namespaces: [n=0] 
[18:01:06.621] Finding globals ... DONE
[18:01:06.621] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:06.622] List of 2
[18:01:06.622]  $ ...future.FUN:function (C, k)  
[18:01:06.622]  $ MoreArgs     : NULL
[18:01:06.622]  - attr(*, "where")=List of 2
[18:01:06.622]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:06.622]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:06.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:06.622]  - attr(*, "resolved")= logi FALSE
[18:01:06.622]  - attr(*, "total_size")= num NA
[18:01:06.626] Packages to be attached in all futures: [n=0] 
[18:01:06.627] getGlobalsAndPackagesXApply() ... DONE
[18:01:06.627] Number of futures (= number of chunks): 5
[18:01:06.627] Launching 5 futures (chunks) ...
[18:01:06.627] Chunk #1 of 5 ...
[18:01:06.628]  - Finding globals in '...' for chunk #1 ...
[18:01:06.628] getGlobalsAndPackages() ...
[18:01:06.628] Searching for globals...
[18:01:06.629] 
[18:01:06.629] Searching for globals ... DONE
[18:01:06.629] - globals: [0] <none>
[18:01:06.629] getGlobalsAndPackages() ... DONE
[18:01:06.629]    + additional globals found: [n=0] 
[18:01:06.630]    + additional namespaces needed: [n=0] 
[18:01:06.630]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:06.630]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:06.630]  - seeds: <none>
[18:01:06.630]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.631] getGlobalsAndPackages() ...
[18:01:06.631] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.631] Resolving globals: FALSE
[18:01:06.632] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:06.633] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.633] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.633] 
[18:01:06.633] getGlobalsAndPackages() ... DONE
[18:01:06.634] run() for ‘Future’ ...
[18:01:06.634] - state: ‘created’
[18:01:06.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.656] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.657]   - Field: ‘node’
[18:01:06.657]   - Field: ‘label’
[18:01:06.657]   - Field: ‘local’
[18:01:06.658]   - Field: ‘owner’
[18:01:06.658]   - Field: ‘envir’
[18:01:06.658]   - Field: ‘workers’
[18:01:06.658]   - Field: ‘packages’
[18:01:06.658]   - Field: ‘gc’
[18:01:06.659]   - Field: ‘conditions’
[18:01:06.659]   - Field: ‘persistent’
[18:01:06.659]   - Field: ‘expr’
[18:01:06.659]   - Field: ‘uuid’
[18:01:06.659]   - Field: ‘seed’
[18:01:06.660]   - Field: ‘version’
[18:01:06.660]   - Field: ‘result’
[18:01:06.660]   - Field: ‘asynchronous’
[18:01:06.660]   - Field: ‘calls’
[18:01:06.660]   - Field: ‘globals’
[18:01:06.660]   - Field: ‘stdout’
[18:01:06.661]   - Field: ‘earlySignal’
[18:01:06.661]   - Field: ‘lazy’
[18:01:06.661]   - Field: ‘state’
[18:01:06.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.661] - Launch lazy future ...
[18:01:06.662] Packages needed by the future expression (n = 0): <none>
[18:01:06.662] Packages needed by future strategies (n = 0): <none>
[18:01:06.663] {
[18:01:06.663]     {
[18:01:06.663]         {
[18:01:06.663]             ...future.startTime <- base::Sys.time()
[18:01:06.663]             {
[18:01:06.663]                 {
[18:01:06.663]                   {
[18:01:06.663]                     {
[18:01:06.663]                       base::local({
[18:01:06.663]                         has_future <- base::requireNamespace("future", 
[18:01:06.663]                           quietly = TRUE)
[18:01:06.663]                         if (has_future) {
[18:01:06.663]                           ns <- base::getNamespace("future")
[18:01:06.663]                           version <- ns[[".package"]][["version"]]
[18:01:06.663]                           if (is.null(version)) 
[18:01:06.663]                             version <- utils::packageVersion("future")
[18:01:06.663]                         }
[18:01:06.663]                         else {
[18:01:06.663]                           version <- NULL
[18:01:06.663]                         }
[18:01:06.663]                         if (!has_future || version < "1.8.0") {
[18:01:06.663]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.663]                             "", base::R.version$version.string), 
[18:01:06.663]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.663]                               "release", "version")], collapse = " "), 
[18:01:06.663]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.663]                             info)
[18:01:06.663]                           info <- base::paste(info, collapse = "; ")
[18:01:06.663]                           if (!has_future) {
[18:01:06.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.663]                               info)
[18:01:06.663]                           }
[18:01:06.663]                           else {
[18:01:06.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.663]                               info, version)
[18:01:06.663]                           }
[18:01:06.663]                           base::stop(msg)
[18:01:06.663]                         }
[18:01:06.663]                       })
[18:01:06.663]                     }
[18:01:06.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.663]                     base::options(mc.cores = 1L)
[18:01:06.663]                   }
[18:01:06.663]                   ...future.strategy.old <- future::plan("list")
[18:01:06.663]                   options(future.plan = NULL)
[18:01:06.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.663]                 }
[18:01:06.663]                 ...future.workdir <- getwd()
[18:01:06.663]             }
[18:01:06.663]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.663]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.663]         }
[18:01:06.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.663]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:06.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.663]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.663]             base::names(...future.oldOptions))
[18:01:06.663]     }
[18:01:06.663]     if (FALSE) {
[18:01:06.663]     }
[18:01:06.663]     else {
[18:01:06.663]         if (TRUE) {
[18:01:06.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.663]                 open = "w")
[18:01:06.663]         }
[18:01:06.663]         else {
[18:01:06.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.663]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.663]         }
[18:01:06.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.663]             base::sink(type = "output", split = FALSE)
[18:01:06.663]             base::close(...future.stdout)
[18:01:06.663]         }, add = TRUE)
[18:01:06.663]     }
[18:01:06.663]     ...future.frame <- base::sys.nframe()
[18:01:06.663]     ...future.conditions <- base::list()
[18:01:06.663]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.663]     if (FALSE) {
[18:01:06.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.663]     }
[18:01:06.663]     ...future.result <- base::tryCatch({
[18:01:06.663]         base::withCallingHandlers({
[18:01:06.663]             ...future.value <- base::withVisible(base::local({
[18:01:06.663]                 ...future.makeSendCondition <- base::local({
[18:01:06.663]                   sendCondition <- NULL
[18:01:06.663]                   function(frame = 1L) {
[18:01:06.663]                     if (is.function(sendCondition)) 
[18:01:06.663]                       return(sendCondition)
[18:01:06.663]                     ns <- getNamespace("parallel")
[18:01:06.663]                     if (exists("sendData", mode = "function", 
[18:01:06.663]                       envir = ns)) {
[18:01:06.663]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.663]                         envir = ns)
[18:01:06.663]                       envir <- sys.frame(frame)
[18:01:06.663]                       master <- NULL
[18:01:06.663]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.663]                         !identical(envir, emptyenv())) {
[18:01:06.663]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.663]                           inherits = FALSE)) {
[18:01:06.663]                           master <- get("master", mode = "list", 
[18:01:06.663]                             envir = envir, inherits = FALSE)
[18:01:06.663]                           if (inherits(master, c("SOCKnode", 
[18:01:06.663]                             "SOCK0node"))) {
[18:01:06.663]                             sendCondition <<- function(cond) {
[18:01:06.663]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.663]                                 success = TRUE)
[18:01:06.663]                               parallel_sendData(master, data)
[18:01:06.663]                             }
[18:01:06.663]                             return(sendCondition)
[18:01:06.663]                           }
[18:01:06.663]                         }
[18:01:06.663]                         frame <- frame + 1L
[18:01:06.663]                         envir <- sys.frame(frame)
[18:01:06.663]                       }
[18:01:06.663]                     }
[18:01:06.663]                     sendCondition <<- function(cond) NULL
[18:01:06.663]                   }
[18:01:06.663]                 })
[18:01:06.663]                 withCallingHandlers({
[18:01:06.663]                   {
[18:01:06.663]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.663]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.663]                       ...future.globals.maxSize)) {
[18:01:06.663]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.663]                       on.exit(options(oopts), add = TRUE)
[18:01:06.663]                     }
[18:01:06.663]                     {
[18:01:06.663]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.663]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.663]                         USE.NAMES = FALSE)
[18:01:06.663]                       do.call(mapply, args = args)
[18:01:06.663]                     }
[18:01:06.663]                   }
[18:01:06.663]                 }, immediateCondition = function(cond) {
[18:01:06.663]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.663]                   sendCondition(cond)
[18:01:06.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.663]                   {
[18:01:06.663]                     inherits <- base::inherits
[18:01:06.663]                     invokeRestart <- base::invokeRestart
[18:01:06.663]                     is.null <- base::is.null
[18:01:06.663]                     muffled <- FALSE
[18:01:06.663]                     if (inherits(cond, "message")) {
[18:01:06.663]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.663]                       if (muffled) 
[18:01:06.663]                         invokeRestart("muffleMessage")
[18:01:06.663]                     }
[18:01:06.663]                     else if (inherits(cond, "warning")) {
[18:01:06.663]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.663]                       if (muffled) 
[18:01:06.663]                         invokeRestart("muffleWarning")
[18:01:06.663]                     }
[18:01:06.663]                     else if (inherits(cond, "condition")) {
[18:01:06.663]                       if (!is.null(pattern)) {
[18:01:06.663]                         computeRestarts <- base::computeRestarts
[18:01:06.663]                         grepl <- base::grepl
[18:01:06.663]                         restarts <- computeRestarts(cond)
[18:01:06.663]                         for (restart in restarts) {
[18:01:06.663]                           name <- restart$name
[18:01:06.663]                           if (is.null(name)) 
[18:01:06.663]                             next
[18:01:06.663]                           if (!grepl(pattern, name)) 
[18:01:06.663]                             next
[18:01:06.663]                           invokeRestart(restart)
[18:01:06.663]                           muffled <- TRUE
[18:01:06.663]                           break
[18:01:06.663]                         }
[18:01:06.663]                       }
[18:01:06.663]                     }
[18:01:06.663]                     invisible(muffled)
[18:01:06.663]                   }
[18:01:06.663]                   muffleCondition(cond)
[18:01:06.663]                 })
[18:01:06.663]             }))
[18:01:06.663]             future::FutureResult(value = ...future.value$value, 
[18:01:06.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.663]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.663]                     ...future.globalenv.names))
[18:01:06.663]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.663]         }, condition = base::local({
[18:01:06.663]             c <- base::c
[18:01:06.663]             inherits <- base::inherits
[18:01:06.663]             invokeRestart <- base::invokeRestart
[18:01:06.663]             length <- base::length
[18:01:06.663]             list <- base::list
[18:01:06.663]             seq.int <- base::seq.int
[18:01:06.663]             signalCondition <- base::signalCondition
[18:01:06.663]             sys.calls <- base::sys.calls
[18:01:06.663]             `[[` <- base::`[[`
[18:01:06.663]             `+` <- base::`+`
[18:01:06.663]             `<<-` <- base::`<<-`
[18:01:06.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.663]                   3L)]
[18:01:06.663]             }
[18:01:06.663]             function(cond) {
[18:01:06.663]                 is_error <- inherits(cond, "error")
[18:01:06.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.663]                   NULL)
[18:01:06.663]                 if (is_error) {
[18:01:06.663]                   sessionInformation <- function() {
[18:01:06.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.663]                       search = base::search(), system = base::Sys.info())
[18:01:06.663]                   }
[18:01:06.663]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.663]                     cond$call), session = sessionInformation(), 
[18:01:06.663]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.663]                   signalCondition(cond)
[18:01:06.663]                 }
[18:01:06.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.663]                 "immediateCondition"))) {
[18:01:06.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.663]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.663]                   if (TRUE && !signal) {
[18:01:06.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.663]                     {
[18:01:06.663]                       inherits <- base::inherits
[18:01:06.663]                       invokeRestart <- base::invokeRestart
[18:01:06.663]                       is.null <- base::is.null
[18:01:06.663]                       muffled <- FALSE
[18:01:06.663]                       if (inherits(cond, "message")) {
[18:01:06.663]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.663]                         if (muffled) 
[18:01:06.663]                           invokeRestart("muffleMessage")
[18:01:06.663]                       }
[18:01:06.663]                       else if (inherits(cond, "warning")) {
[18:01:06.663]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.663]                         if (muffled) 
[18:01:06.663]                           invokeRestart("muffleWarning")
[18:01:06.663]                       }
[18:01:06.663]                       else if (inherits(cond, "condition")) {
[18:01:06.663]                         if (!is.null(pattern)) {
[18:01:06.663]                           computeRestarts <- base::computeRestarts
[18:01:06.663]                           grepl <- base::grepl
[18:01:06.663]                           restarts <- computeRestarts(cond)
[18:01:06.663]                           for (restart in restarts) {
[18:01:06.663]                             name <- restart$name
[18:01:06.663]                             if (is.null(name)) 
[18:01:06.663]                               next
[18:01:06.663]                             if (!grepl(pattern, name)) 
[18:01:06.663]                               next
[18:01:06.663]                             invokeRestart(restart)
[18:01:06.663]                             muffled <- TRUE
[18:01:06.663]                             break
[18:01:06.663]                           }
[18:01:06.663]                         }
[18:01:06.663]                       }
[18:01:06.663]                       invisible(muffled)
[18:01:06.663]                     }
[18:01:06.663]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.663]                   }
[18:01:06.663]                 }
[18:01:06.663]                 else {
[18:01:06.663]                   if (TRUE) {
[18:01:06.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.663]                     {
[18:01:06.663]                       inherits <- base::inherits
[18:01:06.663]                       invokeRestart <- base::invokeRestart
[18:01:06.663]                       is.null <- base::is.null
[18:01:06.663]                       muffled <- FALSE
[18:01:06.663]                       if (inherits(cond, "message")) {
[18:01:06.663]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.663]                         if (muffled) 
[18:01:06.663]                           invokeRestart("muffleMessage")
[18:01:06.663]                       }
[18:01:06.663]                       else if (inherits(cond, "warning")) {
[18:01:06.663]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.663]                         if (muffled) 
[18:01:06.663]                           invokeRestart("muffleWarning")
[18:01:06.663]                       }
[18:01:06.663]                       else if (inherits(cond, "condition")) {
[18:01:06.663]                         if (!is.null(pattern)) {
[18:01:06.663]                           computeRestarts <- base::computeRestarts
[18:01:06.663]                           grepl <- base::grepl
[18:01:06.663]                           restarts <- computeRestarts(cond)
[18:01:06.663]                           for (restart in restarts) {
[18:01:06.663]                             name <- restart$name
[18:01:06.663]                             if (is.null(name)) 
[18:01:06.663]                               next
[18:01:06.663]                             if (!grepl(pattern, name)) 
[18:01:06.663]                               next
[18:01:06.663]                             invokeRestart(restart)
[18:01:06.663]                             muffled <- TRUE
[18:01:06.663]                             break
[18:01:06.663]                           }
[18:01:06.663]                         }
[18:01:06.663]                       }
[18:01:06.663]                       invisible(muffled)
[18:01:06.663]                     }
[18:01:06.663]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.663]                   }
[18:01:06.663]                 }
[18:01:06.663]             }
[18:01:06.663]         }))
[18:01:06.663]     }, error = function(ex) {
[18:01:06.663]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.663]                 ...future.rng), started = ...future.startTime, 
[18:01:06.663]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.663]             version = "1.8"), class = "FutureResult")
[18:01:06.663]     }, finally = {
[18:01:06.663]         if (!identical(...future.workdir, getwd())) 
[18:01:06.663]             setwd(...future.workdir)
[18:01:06.663]         {
[18:01:06.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.663]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.663]             }
[18:01:06.663]             base::options(...future.oldOptions)
[18:01:06.663]             if (.Platform$OS.type == "windows") {
[18:01:06.663]                 old_names <- names(...future.oldEnvVars)
[18:01:06.663]                 envs <- base::Sys.getenv()
[18:01:06.663]                 names <- names(envs)
[18:01:06.663]                 common <- intersect(names, old_names)
[18:01:06.663]                 added <- setdiff(names, old_names)
[18:01:06.663]                 removed <- setdiff(old_names, names)
[18:01:06.663]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.663]                   envs[common]]
[18:01:06.663]                 NAMES <- toupper(changed)
[18:01:06.663]                 args <- list()
[18:01:06.663]                 for (kk in seq_along(NAMES)) {
[18:01:06.663]                   name <- changed[[kk]]
[18:01:06.663]                   NAME <- NAMES[[kk]]
[18:01:06.663]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.663]                     next
[18:01:06.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.663]                 }
[18:01:06.663]                 NAMES <- toupper(added)
[18:01:06.663]                 for (kk in seq_along(NAMES)) {
[18:01:06.663]                   name <- added[[kk]]
[18:01:06.663]                   NAME <- NAMES[[kk]]
[18:01:06.663]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.663]                     next
[18:01:06.663]                   args[[name]] <- ""
[18:01:06.663]                 }
[18:01:06.663]                 NAMES <- toupper(removed)
[18:01:06.663]                 for (kk in seq_along(NAMES)) {
[18:01:06.663]                   name <- removed[[kk]]
[18:01:06.663]                   NAME <- NAMES[[kk]]
[18:01:06.663]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.663]                     next
[18:01:06.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.663]                 }
[18:01:06.663]                 if (length(args) > 0) 
[18:01:06.663]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.663]             }
[18:01:06.663]             else {
[18:01:06.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.663]             }
[18:01:06.663]             {
[18:01:06.663]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.663]                   0L) {
[18:01:06.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.663]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.663]                   base::options(opts)
[18:01:06.663]                 }
[18:01:06.663]                 {
[18:01:06.663]                   {
[18:01:06.663]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.663]                     NULL
[18:01:06.663]                   }
[18:01:06.663]                   options(future.plan = NULL)
[18:01:06.663]                   if (is.na(NA_character_)) 
[18:01:06.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.663]                     .init = FALSE)
[18:01:06.663]                 }
[18:01:06.663]             }
[18:01:06.663]         }
[18:01:06.663]     })
[18:01:06.663]     if (TRUE) {
[18:01:06.663]         base::sink(type = "output", split = FALSE)
[18:01:06.663]         if (TRUE) {
[18:01:06.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.663]         }
[18:01:06.663]         else {
[18:01:06.663]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.663]         }
[18:01:06.663]         base::close(...future.stdout)
[18:01:06.663]         ...future.stdout <- NULL
[18:01:06.663]     }
[18:01:06.663]     ...future.result$conditions <- ...future.conditions
[18:01:06.663]     ...future.result$finished <- base::Sys.time()
[18:01:06.663]     ...future.result
[18:01:06.663] }
[18:01:06.668] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[18:01:06.668] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:06.669] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:06.670] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:06.670] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.671] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[18:01:06.672] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[18:01:06.672] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:06.673] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.673] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:06.674] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.674] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[18:01:06.675] MultisessionFuture started
[18:01:06.675] - Launch lazy future ... done
[18:01:06.676] run() for ‘MultisessionFuture’ ... done
[18:01:06.676] Created future:
[18:01:06.676] MultisessionFuture:
[18:01:06.676] Label: ‘future_mapply-1’
[18:01:06.676] Expression:
[18:01:06.676] {
[18:01:06.676]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.676]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.676]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.676]         on.exit(options(oopts), add = TRUE)
[18:01:06.676]     }
[18:01:06.676]     {
[18:01:06.676]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.676]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.676]         do.call(mapply, args = args)
[18:01:06.676]     }
[18:01:06.676] }
[18:01:06.676] Lazy evaluation: FALSE
[18:01:06.676] Asynchronous evaluation: TRUE
[18:01:06.676] Local evaluation: TRUE
[18:01:06.676] Environment: R_GlobalEnv
[18:01:06.676] Capture standard output: TRUE
[18:01:06.676] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.676] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.676] Packages: <none>
[18:01:06.676] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.676] Resolved: FALSE
[18:01:06.676] Value: <not collected>
[18:01:06.676] Conditions captured: <none>
[18:01:06.676] Early signaling: FALSE
[18:01:06.676] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.676] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.689] Chunk #1 of 5 ... DONE
[18:01:06.689] Chunk #2 of 5 ...
[18:01:06.689]  - Finding globals in '...' for chunk #2 ...
[18:01:06.689] getGlobalsAndPackages() ...
[18:01:06.689] Searching for globals...
[18:01:06.690] 
[18:01:06.690] Searching for globals ... DONE
[18:01:06.691] - globals: [0] <none>
[18:01:06.691] getGlobalsAndPackages() ... DONE
[18:01:06.691]    + additional globals found: [n=0] 
[18:01:06.691]    + additional namespaces needed: [n=0] 
[18:01:06.691]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:06.691]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:06.692]  - seeds: <none>
[18:01:06.692]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.692] getGlobalsAndPackages() ...
[18:01:06.692] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.692] Resolving globals: FALSE
[18:01:06.693] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:06.694] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.695] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.695] 
[18:01:06.695] getGlobalsAndPackages() ... DONE
[18:01:06.695] run() for ‘Future’ ...
[18:01:06.696] - state: ‘created’
[18:01:06.696] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.719]   - Field: ‘node’
[18:01:06.719]   - Field: ‘label’
[18:01:06.719]   - Field: ‘local’
[18:01:06.719]   - Field: ‘owner’
[18:01:06.720]   - Field: ‘envir’
[18:01:06.720]   - Field: ‘workers’
[18:01:06.720]   - Field: ‘packages’
[18:01:06.720]   - Field: ‘gc’
[18:01:06.720]   - Field: ‘conditions’
[18:01:06.721]   - Field: ‘persistent’
[18:01:06.721]   - Field: ‘expr’
[18:01:06.721]   - Field: ‘uuid’
[18:01:06.721]   - Field: ‘seed’
[18:01:06.721]   - Field: ‘version’
[18:01:06.722]   - Field: ‘result’
[18:01:06.722]   - Field: ‘asynchronous’
[18:01:06.722]   - Field: ‘calls’
[18:01:06.722]   - Field: ‘globals’
[18:01:06.722]   - Field: ‘stdout’
[18:01:06.722]   - Field: ‘earlySignal’
[18:01:06.723]   - Field: ‘lazy’
[18:01:06.723]   - Field: ‘state’
[18:01:06.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.723] - Launch lazy future ...
[18:01:06.724] Packages needed by the future expression (n = 0): <none>
[18:01:06.724] Packages needed by future strategies (n = 0): <none>
[18:01:06.725] {
[18:01:06.725]     {
[18:01:06.725]         {
[18:01:06.725]             ...future.startTime <- base::Sys.time()
[18:01:06.725]             {
[18:01:06.725]                 {
[18:01:06.725]                   {
[18:01:06.725]                     {
[18:01:06.725]                       base::local({
[18:01:06.725]                         has_future <- base::requireNamespace("future", 
[18:01:06.725]                           quietly = TRUE)
[18:01:06.725]                         if (has_future) {
[18:01:06.725]                           ns <- base::getNamespace("future")
[18:01:06.725]                           version <- ns[[".package"]][["version"]]
[18:01:06.725]                           if (is.null(version)) 
[18:01:06.725]                             version <- utils::packageVersion("future")
[18:01:06.725]                         }
[18:01:06.725]                         else {
[18:01:06.725]                           version <- NULL
[18:01:06.725]                         }
[18:01:06.725]                         if (!has_future || version < "1.8.0") {
[18:01:06.725]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.725]                             "", base::R.version$version.string), 
[18:01:06.725]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.725]                               "release", "version")], collapse = " "), 
[18:01:06.725]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.725]                             info)
[18:01:06.725]                           info <- base::paste(info, collapse = "; ")
[18:01:06.725]                           if (!has_future) {
[18:01:06.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.725]                               info)
[18:01:06.725]                           }
[18:01:06.725]                           else {
[18:01:06.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.725]                               info, version)
[18:01:06.725]                           }
[18:01:06.725]                           base::stop(msg)
[18:01:06.725]                         }
[18:01:06.725]                       })
[18:01:06.725]                     }
[18:01:06.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.725]                     base::options(mc.cores = 1L)
[18:01:06.725]                   }
[18:01:06.725]                   ...future.strategy.old <- future::plan("list")
[18:01:06.725]                   options(future.plan = NULL)
[18:01:06.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.725]                 }
[18:01:06.725]                 ...future.workdir <- getwd()
[18:01:06.725]             }
[18:01:06.725]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.725]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.725]         }
[18:01:06.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.725]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:06.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.725]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.725]             base::names(...future.oldOptions))
[18:01:06.725]     }
[18:01:06.725]     if (FALSE) {
[18:01:06.725]     }
[18:01:06.725]     else {
[18:01:06.725]         if (TRUE) {
[18:01:06.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.725]                 open = "w")
[18:01:06.725]         }
[18:01:06.725]         else {
[18:01:06.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.725]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.725]         }
[18:01:06.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.725]             base::sink(type = "output", split = FALSE)
[18:01:06.725]             base::close(...future.stdout)
[18:01:06.725]         }, add = TRUE)
[18:01:06.725]     }
[18:01:06.725]     ...future.frame <- base::sys.nframe()
[18:01:06.725]     ...future.conditions <- base::list()
[18:01:06.725]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.725]     if (FALSE) {
[18:01:06.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.725]     }
[18:01:06.725]     ...future.result <- base::tryCatch({
[18:01:06.725]         base::withCallingHandlers({
[18:01:06.725]             ...future.value <- base::withVisible(base::local({
[18:01:06.725]                 ...future.makeSendCondition <- base::local({
[18:01:06.725]                   sendCondition <- NULL
[18:01:06.725]                   function(frame = 1L) {
[18:01:06.725]                     if (is.function(sendCondition)) 
[18:01:06.725]                       return(sendCondition)
[18:01:06.725]                     ns <- getNamespace("parallel")
[18:01:06.725]                     if (exists("sendData", mode = "function", 
[18:01:06.725]                       envir = ns)) {
[18:01:06.725]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.725]                         envir = ns)
[18:01:06.725]                       envir <- sys.frame(frame)
[18:01:06.725]                       master <- NULL
[18:01:06.725]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.725]                         !identical(envir, emptyenv())) {
[18:01:06.725]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.725]                           inherits = FALSE)) {
[18:01:06.725]                           master <- get("master", mode = "list", 
[18:01:06.725]                             envir = envir, inherits = FALSE)
[18:01:06.725]                           if (inherits(master, c("SOCKnode", 
[18:01:06.725]                             "SOCK0node"))) {
[18:01:06.725]                             sendCondition <<- function(cond) {
[18:01:06.725]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.725]                                 success = TRUE)
[18:01:06.725]                               parallel_sendData(master, data)
[18:01:06.725]                             }
[18:01:06.725]                             return(sendCondition)
[18:01:06.725]                           }
[18:01:06.725]                         }
[18:01:06.725]                         frame <- frame + 1L
[18:01:06.725]                         envir <- sys.frame(frame)
[18:01:06.725]                       }
[18:01:06.725]                     }
[18:01:06.725]                     sendCondition <<- function(cond) NULL
[18:01:06.725]                   }
[18:01:06.725]                 })
[18:01:06.725]                 withCallingHandlers({
[18:01:06.725]                   {
[18:01:06.725]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.725]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.725]                       ...future.globals.maxSize)) {
[18:01:06.725]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.725]                       on.exit(options(oopts), add = TRUE)
[18:01:06.725]                     }
[18:01:06.725]                     {
[18:01:06.725]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.725]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.725]                         USE.NAMES = FALSE)
[18:01:06.725]                       do.call(mapply, args = args)
[18:01:06.725]                     }
[18:01:06.725]                   }
[18:01:06.725]                 }, immediateCondition = function(cond) {
[18:01:06.725]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.725]                   sendCondition(cond)
[18:01:06.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.725]                   {
[18:01:06.725]                     inherits <- base::inherits
[18:01:06.725]                     invokeRestart <- base::invokeRestart
[18:01:06.725]                     is.null <- base::is.null
[18:01:06.725]                     muffled <- FALSE
[18:01:06.725]                     if (inherits(cond, "message")) {
[18:01:06.725]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.725]                       if (muffled) 
[18:01:06.725]                         invokeRestart("muffleMessage")
[18:01:06.725]                     }
[18:01:06.725]                     else if (inherits(cond, "warning")) {
[18:01:06.725]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.725]                       if (muffled) 
[18:01:06.725]                         invokeRestart("muffleWarning")
[18:01:06.725]                     }
[18:01:06.725]                     else if (inherits(cond, "condition")) {
[18:01:06.725]                       if (!is.null(pattern)) {
[18:01:06.725]                         computeRestarts <- base::computeRestarts
[18:01:06.725]                         grepl <- base::grepl
[18:01:06.725]                         restarts <- computeRestarts(cond)
[18:01:06.725]                         for (restart in restarts) {
[18:01:06.725]                           name <- restart$name
[18:01:06.725]                           if (is.null(name)) 
[18:01:06.725]                             next
[18:01:06.725]                           if (!grepl(pattern, name)) 
[18:01:06.725]                             next
[18:01:06.725]                           invokeRestart(restart)
[18:01:06.725]                           muffled <- TRUE
[18:01:06.725]                           break
[18:01:06.725]                         }
[18:01:06.725]                       }
[18:01:06.725]                     }
[18:01:06.725]                     invisible(muffled)
[18:01:06.725]                   }
[18:01:06.725]                   muffleCondition(cond)
[18:01:06.725]                 })
[18:01:06.725]             }))
[18:01:06.725]             future::FutureResult(value = ...future.value$value, 
[18:01:06.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.725]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.725]                     ...future.globalenv.names))
[18:01:06.725]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.725]         }, condition = base::local({
[18:01:06.725]             c <- base::c
[18:01:06.725]             inherits <- base::inherits
[18:01:06.725]             invokeRestart <- base::invokeRestart
[18:01:06.725]             length <- base::length
[18:01:06.725]             list <- base::list
[18:01:06.725]             seq.int <- base::seq.int
[18:01:06.725]             signalCondition <- base::signalCondition
[18:01:06.725]             sys.calls <- base::sys.calls
[18:01:06.725]             `[[` <- base::`[[`
[18:01:06.725]             `+` <- base::`+`
[18:01:06.725]             `<<-` <- base::`<<-`
[18:01:06.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.725]                   3L)]
[18:01:06.725]             }
[18:01:06.725]             function(cond) {
[18:01:06.725]                 is_error <- inherits(cond, "error")
[18:01:06.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.725]                   NULL)
[18:01:06.725]                 if (is_error) {
[18:01:06.725]                   sessionInformation <- function() {
[18:01:06.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.725]                       search = base::search(), system = base::Sys.info())
[18:01:06.725]                   }
[18:01:06.725]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.725]                     cond$call), session = sessionInformation(), 
[18:01:06.725]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.725]                   signalCondition(cond)
[18:01:06.725]                 }
[18:01:06.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.725]                 "immediateCondition"))) {
[18:01:06.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.725]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.725]                   if (TRUE && !signal) {
[18:01:06.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.725]                     {
[18:01:06.725]                       inherits <- base::inherits
[18:01:06.725]                       invokeRestart <- base::invokeRestart
[18:01:06.725]                       is.null <- base::is.null
[18:01:06.725]                       muffled <- FALSE
[18:01:06.725]                       if (inherits(cond, "message")) {
[18:01:06.725]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.725]                         if (muffled) 
[18:01:06.725]                           invokeRestart("muffleMessage")
[18:01:06.725]                       }
[18:01:06.725]                       else if (inherits(cond, "warning")) {
[18:01:06.725]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.725]                         if (muffled) 
[18:01:06.725]                           invokeRestart("muffleWarning")
[18:01:06.725]                       }
[18:01:06.725]                       else if (inherits(cond, "condition")) {
[18:01:06.725]                         if (!is.null(pattern)) {
[18:01:06.725]                           computeRestarts <- base::computeRestarts
[18:01:06.725]                           grepl <- base::grepl
[18:01:06.725]                           restarts <- computeRestarts(cond)
[18:01:06.725]                           for (restart in restarts) {
[18:01:06.725]                             name <- restart$name
[18:01:06.725]                             if (is.null(name)) 
[18:01:06.725]                               next
[18:01:06.725]                             if (!grepl(pattern, name)) 
[18:01:06.725]                               next
[18:01:06.725]                             invokeRestart(restart)
[18:01:06.725]                             muffled <- TRUE
[18:01:06.725]                             break
[18:01:06.725]                           }
[18:01:06.725]                         }
[18:01:06.725]                       }
[18:01:06.725]                       invisible(muffled)
[18:01:06.725]                     }
[18:01:06.725]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.725]                   }
[18:01:06.725]                 }
[18:01:06.725]                 else {
[18:01:06.725]                   if (TRUE) {
[18:01:06.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.725]                     {
[18:01:06.725]                       inherits <- base::inherits
[18:01:06.725]                       invokeRestart <- base::invokeRestart
[18:01:06.725]                       is.null <- base::is.null
[18:01:06.725]                       muffled <- FALSE
[18:01:06.725]                       if (inherits(cond, "message")) {
[18:01:06.725]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.725]                         if (muffled) 
[18:01:06.725]                           invokeRestart("muffleMessage")
[18:01:06.725]                       }
[18:01:06.725]                       else if (inherits(cond, "warning")) {
[18:01:06.725]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.725]                         if (muffled) 
[18:01:06.725]                           invokeRestart("muffleWarning")
[18:01:06.725]                       }
[18:01:06.725]                       else if (inherits(cond, "condition")) {
[18:01:06.725]                         if (!is.null(pattern)) {
[18:01:06.725]                           computeRestarts <- base::computeRestarts
[18:01:06.725]                           grepl <- base::grepl
[18:01:06.725]                           restarts <- computeRestarts(cond)
[18:01:06.725]                           for (restart in restarts) {
[18:01:06.725]                             name <- restart$name
[18:01:06.725]                             if (is.null(name)) 
[18:01:06.725]                               next
[18:01:06.725]                             if (!grepl(pattern, name)) 
[18:01:06.725]                               next
[18:01:06.725]                             invokeRestart(restart)
[18:01:06.725]                             muffled <- TRUE
[18:01:06.725]                             break
[18:01:06.725]                           }
[18:01:06.725]                         }
[18:01:06.725]                       }
[18:01:06.725]                       invisible(muffled)
[18:01:06.725]                     }
[18:01:06.725]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.725]                   }
[18:01:06.725]                 }
[18:01:06.725]             }
[18:01:06.725]         }))
[18:01:06.725]     }, error = function(ex) {
[18:01:06.725]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.725]                 ...future.rng), started = ...future.startTime, 
[18:01:06.725]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.725]             version = "1.8"), class = "FutureResult")
[18:01:06.725]     }, finally = {
[18:01:06.725]         if (!identical(...future.workdir, getwd())) 
[18:01:06.725]             setwd(...future.workdir)
[18:01:06.725]         {
[18:01:06.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.725]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.725]             }
[18:01:06.725]             base::options(...future.oldOptions)
[18:01:06.725]             if (.Platform$OS.type == "windows") {
[18:01:06.725]                 old_names <- names(...future.oldEnvVars)
[18:01:06.725]                 envs <- base::Sys.getenv()
[18:01:06.725]                 names <- names(envs)
[18:01:06.725]                 common <- intersect(names, old_names)
[18:01:06.725]                 added <- setdiff(names, old_names)
[18:01:06.725]                 removed <- setdiff(old_names, names)
[18:01:06.725]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.725]                   envs[common]]
[18:01:06.725]                 NAMES <- toupper(changed)
[18:01:06.725]                 args <- list()
[18:01:06.725]                 for (kk in seq_along(NAMES)) {
[18:01:06.725]                   name <- changed[[kk]]
[18:01:06.725]                   NAME <- NAMES[[kk]]
[18:01:06.725]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.725]                     next
[18:01:06.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.725]                 }
[18:01:06.725]                 NAMES <- toupper(added)
[18:01:06.725]                 for (kk in seq_along(NAMES)) {
[18:01:06.725]                   name <- added[[kk]]
[18:01:06.725]                   NAME <- NAMES[[kk]]
[18:01:06.725]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.725]                     next
[18:01:06.725]                   args[[name]] <- ""
[18:01:06.725]                 }
[18:01:06.725]                 NAMES <- toupper(removed)
[18:01:06.725]                 for (kk in seq_along(NAMES)) {
[18:01:06.725]                   name <- removed[[kk]]
[18:01:06.725]                   NAME <- NAMES[[kk]]
[18:01:06.725]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.725]                     next
[18:01:06.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.725]                 }
[18:01:06.725]                 if (length(args) > 0) 
[18:01:06.725]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.725]             }
[18:01:06.725]             else {
[18:01:06.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.725]             }
[18:01:06.725]             {
[18:01:06.725]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.725]                   0L) {
[18:01:06.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.725]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.725]                   base::options(opts)
[18:01:06.725]                 }
[18:01:06.725]                 {
[18:01:06.725]                   {
[18:01:06.725]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.725]                     NULL
[18:01:06.725]                   }
[18:01:06.725]                   options(future.plan = NULL)
[18:01:06.725]                   if (is.na(NA_character_)) 
[18:01:06.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.725]                     .init = FALSE)
[18:01:06.725]                 }
[18:01:06.725]             }
[18:01:06.725]         }
[18:01:06.725]     })
[18:01:06.725]     if (TRUE) {
[18:01:06.725]         base::sink(type = "output", split = FALSE)
[18:01:06.725]         if (TRUE) {
[18:01:06.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.725]         }
[18:01:06.725]         else {
[18:01:06.725]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.725]         }
[18:01:06.725]         base::close(...future.stdout)
[18:01:06.725]         ...future.stdout <- NULL
[18:01:06.725]     }
[18:01:06.725]     ...future.result$conditions <- ...future.conditions
[18:01:06.725]     ...future.result$finished <- base::Sys.time()
[18:01:06.725]     ...future.result
[18:01:06.725] }
[18:01:06.730] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[18:01:06.731] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:06.732] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:06.732] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:06.733] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.733] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[18:01:06.734] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[18:01:06.734] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:06.735] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.735] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:06.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.736] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[18:01:06.737] MultisessionFuture started
[18:01:06.738] - Launch lazy future ... done
[18:01:06.739] run() for ‘MultisessionFuture’ ... done
[18:01:06.739] Created future:
[18:01:06.739] MultisessionFuture:
[18:01:06.739] Label: ‘future_mapply-2’
[18:01:06.739] Expression:
[18:01:06.739] {
[18:01:06.739]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.739]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.739]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.739]         on.exit(options(oopts), add = TRUE)
[18:01:06.739]     }
[18:01:06.739]     {
[18:01:06.739]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.739]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.739]         do.call(mapply, args = args)
[18:01:06.739]     }
[18:01:06.739] }
[18:01:06.739] Lazy evaluation: FALSE
[18:01:06.739] Asynchronous evaluation: TRUE
[18:01:06.739] Local evaluation: TRUE
[18:01:06.739] Environment: R_GlobalEnv
[18:01:06.739] Capture standard output: TRUE
[18:01:06.739] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.739] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.739] Packages: <none>
[18:01:06.739] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.739] Resolved: FALSE
[18:01:06.739] Value: <not collected>
[18:01:06.739] Conditions captured: <none>
[18:01:06.739] Early signaling: FALSE
[18:01:06.739] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.739] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.752] Chunk #2 of 5 ... DONE
[18:01:06.753] Chunk #3 of 5 ...
[18:01:06.753]  - Finding globals in '...' for chunk #3 ...
[18:01:06.753] getGlobalsAndPackages() ...
[18:01:06.753] Searching for globals...
[18:01:06.754] 
[18:01:06.754] Searching for globals ... DONE
[18:01:06.754] - globals: [0] <none>
[18:01:06.755] getGlobalsAndPackages() ... DONE
[18:01:06.755]    + additional globals found: [n=0] 
[18:01:06.755]    + additional namespaces needed: [n=0] 
[18:01:06.755]  - Finding globals in '...' for chunk #3 ... DONE
[18:01:06.755]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:06.756]  - seeds: <none>
[18:01:06.756]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.756] getGlobalsAndPackages() ...
[18:01:06.756] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.756] Resolving globals: FALSE
[18:01:06.757] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:06.758] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.759] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.759] 
[18:01:06.759] getGlobalsAndPackages() ... DONE
[18:01:06.760] run() for ‘Future’ ...
[18:01:06.760] - state: ‘created’
[18:01:06.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.783] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.783] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.783]   - Field: ‘node’
[18:01:06.784]   - Field: ‘label’
[18:01:06.784]   - Field: ‘local’
[18:01:06.784]   - Field: ‘owner’
[18:01:06.784]   - Field: ‘envir’
[18:01:06.784]   - Field: ‘workers’
[18:01:06.785]   - Field: ‘packages’
[18:01:06.785]   - Field: ‘gc’
[18:01:06.785]   - Field: ‘conditions’
[18:01:06.785]   - Field: ‘persistent’
[18:01:06.785]   - Field: ‘expr’
[18:01:06.786]   - Field: ‘uuid’
[18:01:06.786]   - Field: ‘seed’
[18:01:06.786]   - Field: ‘version’
[18:01:06.786]   - Field: ‘result’
[18:01:06.786]   - Field: ‘asynchronous’
[18:01:06.787]   - Field: ‘calls’
[18:01:06.787]   - Field: ‘globals’
[18:01:06.787]   - Field: ‘stdout’
[18:01:06.787]   - Field: ‘earlySignal’
[18:01:06.787]   - Field: ‘lazy’
[18:01:06.788]   - Field: ‘state’
[18:01:06.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.788] - Launch lazy future ...
[18:01:06.788] Packages needed by the future expression (n = 0): <none>
[18:01:06.789] Packages needed by future strategies (n = 0): <none>
[18:01:06.790] {
[18:01:06.790]     {
[18:01:06.790]         {
[18:01:06.790]             ...future.startTime <- base::Sys.time()
[18:01:06.790]             {
[18:01:06.790]                 {
[18:01:06.790]                   {
[18:01:06.790]                     {
[18:01:06.790]                       base::local({
[18:01:06.790]                         has_future <- base::requireNamespace("future", 
[18:01:06.790]                           quietly = TRUE)
[18:01:06.790]                         if (has_future) {
[18:01:06.790]                           ns <- base::getNamespace("future")
[18:01:06.790]                           version <- ns[[".package"]][["version"]]
[18:01:06.790]                           if (is.null(version)) 
[18:01:06.790]                             version <- utils::packageVersion("future")
[18:01:06.790]                         }
[18:01:06.790]                         else {
[18:01:06.790]                           version <- NULL
[18:01:06.790]                         }
[18:01:06.790]                         if (!has_future || version < "1.8.0") {
[18:01:06.790]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.790]                             "", base::R.version$version.string), 
[18:01:06.790]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.790]                               "release", "version")], collapse = " "), 
[18:01:06.790]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.790]                             info)
[18:01:06.790]                           info <- base::paste(info, collapse = "; ")
[18:01:06.790]                           if (!has_future) {
[18:01:06.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.790]                               info)
[18:01:06.790]                           }
[18:01:06.790]                           else {
[18:01:06.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.790]                               info, version)
[18:01:06.790]                           }
[18:01:06.790]                           base::stop(msg)
[18:01:06.790]                         }
[18:01:06.790]                       })
[18:01:06.790]                     }
[18:01:06.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.790]                     base::options(mc.cores = 1L)
[18:01:06.790]                   }
[18:01:06.790]                   ...future.strategy.old <- future::plan("list")
[18:01:06.790]                   options(future.plan = NULL)
[18:01:06.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.790]                 }
[18:01:06.790]                 ...future.workdir <- getwd()
[18:01:06.790]             }
[18:01:06.790]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.790]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.790]         }
[18:01:06.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.790]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:06.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.790]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.790]             base::names(...future.oldOptions))
[18:01:06.790]     }
[18:01:06.790]     if (FALSE) {
[18:01:06.790]     }
[18:01:06.790]     else {
[18:01:06.790]         if (TRUE) {
[18:01:06.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.790]                 open = "w")
[18:01:06.790]         }
[18:01:06.790]         else {
[18:01:06.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.790]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.790]         }
[18:01:06.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.790]             base::sink(type = "output", split = FALSE)
[18:01:06.790]             base::close(...future.stdout)
[18:01:06.790]         }, add = TRUE)
[18:01:06.790]     }
[18:01:06.790]     ...future.frame <- base::sys.nframe()
[18:01:06.790]     ...future.conditions <- base::list()
[18:01:06.790]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.790]     if (FALSE) {
[18:01:06.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.790]     }
[18:01:06.790]     ...future.result <- base::tryCatch({
[18:01:06.790]         base::withCallingHandlers({
[18:01:06.790]             ...future.value <- base::withVisible(base::local({
[18:01:06.790]                 ...future.makeSendCondition <- base::local({
[18:01:06.790]                   sendCondition <- NULL
[18:01:06.790]                   function(frame = 1L) {
[18:01:06.790]                     if (is.function(sendCondition)) 
[18:01:06.790]                       return(sendCondition)
[18:01:06.790]                     ns <- getNamespace("parallel")
[18:01:06.790]                     if (exists("sendData", mode = "function", 
[18:01:06.790]                       envir = ns)) {
[18:01:06.790]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.790]                         envir = ns)
[18:01:06.790]                       envir <- sys.frame(frame)
[18:01:06.790]                       master <- NULL
[18:01:06.790]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.790]                         !identical(envir, emptyenv())) {
[18:01:06.790]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.790]                           inherits = FALSE)) {
[18:01:06.790]                           master <- get("master", mode = "list", 
[18:01:06.790]                             envir = envir, inherits = FALSE)
[18:01:06.790]                           if (inherits(master, c("SOCKnode", 
[18:01:06.790]                             "SOCK0node"))) {
[18:01:06.790]                             sendCondition <<- function(cond) {
[18:01:06.790]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.790]                                 success = TRUE)
[18:01:06.790]                               parallel_sendData(master, data)
[18:01:06.790]                             }
[18:01:06.790]                             return(sendCondition)
[18:01:06.790]                           }
[18:01:06.790]                         }
[18:01:06.790]                         frame <- frame + 1L
[18:01:06.790]                         envir <- sys.frame(frame)
[18:01:06.790]                       }
[18:01:06.790]                     }
[18:01:06.790]                     sendCondition <<- function(cond) NULL
[18:01:06.790]                   }
[18:01:06.790]                 })
[18:01:06.790]                 withCallingHandlers({
[18:01:06.790]                   {
[18:01:06.790]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.790]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.790]                       ...future.globals.maxSize)) {
[18:01:06.790]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.790]                       on.exit(options(oopts), add = TRUE)
[18:01:06.790]                     }
[18:01:06.790]                     {
[18:01:06.790]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.790]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.790]                         USE.NAMES = FALSE)
[18:01:06.790]                       do.call(mapply, args = args)
[18:01:06.790]                     }
[18:01:06.790]                   }
[18:01:06.790]                 }, immediateCondition = function(cond) {
[18:01:06.790]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.790]                   sendCondition(cond)
[18:01:06.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.790]                   {
[18:01:06.790]                     inherits <- base::inherits
[18:01:06.790]                     invokeRestart <- base::invokeRestart
[18:01:06.790]                     is.null <- base::is.null
[18:01:06.790]                     muffled <- FALSE
[18:01:06.790]                     if (inherits(cond, "message")) {
[18:01:06.790]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.790]                       if (muffled) 
[18:01:06.790]                         invokeRestart("muffleMessage")
[18:01:06.790]                     }
[18:01:06.790]                     else if (inherits(cond, "warning")) {
[18:01:06.790]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.790]                       if (muffled) 
[18:01:06.790]                         invokeRestart("muffleWarning")
[18:01:06.790]                     }
[18:01:06.790]                     else if (inherits(cond, "condition")) {
[18:01:06.790]                       if (!is.null(pattern)) {
[18:01:06.790]                         computeRestarts <- base::computeRestarts
[18:01:06.790]                         grepl <- base::grepl
[18:01:06.790]                         restarts <- computeRestarts(cond)
[18:01:06.790]                         for (restart in restarts) {
[18:01:06.790]                           name <- restart$name
[18:01:06.790]                           if (is.null(name)) 
[18:01:06.790]                             next
[18:01:06.790]                           if (!grepl(pattern, name)) 
[18:01:06.790]                             next
[18:01:06.790]                           invokeRestart(restart)
[18:01:06.790]                           muffled <- TRUE
[18:01:06.790]                           break
[18:01:06.790]                         }
[18:01:06.790]                       }
[18:01:06.790]                     }
[18:01:06.790]                     invisible(muffled)
[18:01:06.790]                   }
[18:01:06.790]                   muffleCondition(cond)
[18:01:06.790]                 })
[18:01:06.790]             }))
[18:01:06.790]             future::FutureResult(value = ...future.value$value, 
[18:01:06.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.790]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.790]                     ...future.globalenv.names))
[18:01:06.790]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.790]         }, condition = base::local({
[18:01:06.790]             c <- base::c
[18:01:06.790]             inherits <- base::inherits
[18:01:06.790]             invokeRestart <- base::invokeRestart
[18:01:06.790]             length <- base::length
[18:01:06.790]             list <- base::list
[18:01:06.790]             seq.int <- base::seq.int
[18:01:06.790]             signalCondition <- base::signalCondition
[18:01:06.790]             sys.calls <- base::sys.calls
[18:01:06.790]             `[[` <- base::`[[`
[18:01:06.790]             `+` <- base::`+`
[18:01:06.790]             `<<-` <- base::`<<-`
[18:01:06.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.790]                   3L)]
[18:01:06.790]             }
[18:01:06.790]             function(cond) {
[18:01:06.790]                 is_error <- inherits(cond, "error")
[18:01:06.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.790]                   NULL)
[18:01:06.790]                 if (is_error) {
[18:01:06.790]                   sessionInformation <- function() {
[18:01:06.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.790]                       search = base::search(), system = base::Sys.info())
[18:01:06.790]                   }
[18:01:06.790]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.790]                     cond$call), session = sessionInformation(), 
[18:01:06.790]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.790]                   signalCondition(cond)
[18:01:06.790]                 }
[18:01:06.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.790]                 "immediateCondition"))) {
[18:01:06.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.790]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.790]                   if (TRUE && !signal) {
[18:01:06.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.790]                     {
[18:01:06.790]                       inherits <- base::inherits
[18:01:06.790]                       invokeRestart <- base::invokeRestart
[18:01:06.790]                       is.null <- base::is.null
[18:01:06.790]                       muffled <- FALSE
[18:01:06.790]                       if (inherits(cond, "message")) {
[18:01:06.790]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.790]                         if (muffled) 
[18:01:06.790]                           invokeRestart("muffleMessage")
[18:01:06.790]                       }
[18:01:06.790]                       else if (inherits(cond, "warning")) {
[18:01:06.790]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.790]                         if (muffled) 
[18:01:06.790]                           invokeRestart("muffleWarning")
[18:01:06.790]                       }
[18:01:06.790]                       else if (inherits(cond, "condition")) {
[18:01:06.790]                         if (!is.null(pattern)) {
[18:01:06.790]                           computeRestarts <- base::computeRestarts
[18:01:06.790]                           grepl <- base::grepl
[18:01:06.790]                           restarts <- computeRestarts(cond)
[18:01:06.790]                           for (restart in restarts) {
[18:01:06.790]                             name <- restart$name
[18:01:06.790]                             if (is.null(name)) 
[18:01:06.790]                               next
[18:01:06.790]                             if (!grepl(pattern, name)) 
[18:01:06.790]                               next
[18:01:06.790]                             invokeRestart(restart)
[18:01:06.790]                             muffled <- TRUE
[18:01:06.790]                             break
[18:01:06.790]                           }
[18:01:06.790]                         }
[18:01:06.790]                       }
[18:01:06.790]                       invisible(muffled)
[18:01:06.790]                     }
[18:01:06.790]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.790]                   }
[18:01:06.790]                 }
[18:01:06.790]                 else {
[18:01:06.790]                   if (TRUE) {
[18:01:06.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.790]                     {
[18:01:06.790]                       inherits <- base::inherits
[18:01:06.790]                       invokeRestart <- base::invokeRestart
[18:01:06.790]                       is.null <- base::is.null
[18:01:06.790]                       muffled <- FALSE
[18:01:06.790]                       if (inherits(cond, "message")) {
[18:01:06.790]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.790]                         if (muffled) 
[18:01:06.790]                           invokeRestart("muffleMessage")
[18:01:06.790]                       }
[18:01:06.790]                       else if (inherits(cond, "warning")) {
[18:01:06.790]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.790]                         if (muffled) 
[18:01:06.790]                           invokeRestart("muffleWarning")
[18:01:06.790]                       }
[18:01:06.790]                       else if (inherits(cond, "condition")) {
[18:01:06.790]                         if (!is.null(pattern)) {
[18:01:06.790]                           computeRestarts <- base::computeRestarts
[18:01:06.790]                           grepl <- base::grepl
[18:01:06.790]                           restarts <- computeRestarts(cond)
[18:01:06.790]                           for (restart in restarts) {
[18:01:06.790]                             name <- restart$name
[18:01:06.790]                             if (is.null(name)) 
[18:01:06.790]                               next
[18:01:06.790]                             if (!grepl(pattern, name)) 
[18:01:06.790]                               next
[18:01:06.790]                             invokeRestart(restart)
[18:01:06.790]                             muffled <- TRUE
[18:01:06.790]                             break
[18:01:06.790]                           }
[18:01:06.790]                         }
[18:01:06.790]                       }
[18:01:06.790]                       invisible(muffled)
[18:01:06.790]                     }
[18:01:06.790]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.790]                   }
[18:01:06.790]                 }
[18:01:06.790]             }
[18:01:06.790]         }))
[18:01:06.790]     }, error = function(ex) {
[18:01:06.790]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.790]                 ...future.rng), started = ...future.startTime, 
[18:01:06.790]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.790]             version = "1.8"), class = "FutureResult")
[18:01:06.790]     }, finally = {
[18:01:06.790]         if (!identical(...future.workdir, getwd())) 
[18:01:06.790]             setwd(...future.workdir)
[18:01:06.790]         {
[18:01:06.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.790]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.790]             }
[18:01:06.790]             base::options(...future.oldOptions)
[18:01:06.790]             if (.Platform$OS.type == "windows") {
[18:01:06.790]                 old_names <- names(...future.oldEnvVars)
[18:01:06.790]                 envs <- base::Sys.getenv()
[18:01:06.790]                 names <- names(envs)
[18:01:06.790]                 common <- intersect(names, old_names)
[18:01:06.790]                 added <- setdiff(names, old_names)
[18:01:06.790]                 removed <- setdiff(old_names, names)
[18:01:06.790]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.790]                   envs[common]]
[18:01:06.790]                 NAMES <- toupper(changed)
[18:01:06.790]                 args <- list()
[18:01:06.790]                 for (kk in seq_along(NAMES)) {
[18:01:06.790]                   name <- changed[[kk]]
[18:01:06.790]                   NAME <- NAMES[[kk]]
[18:01:06.790]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.790]                     next
[18:01:06.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.790]                 }
[18:01:06.790]                 NAMES <- toupper(added)
[18:01:06.790]                 for (kk in seq_along(NAMES)) {
[18:01:06.790]                   name <- added[[kk]]
[18:01:06.790]                   NAME <- NAMES[[kk]]
[18:01:06.790]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.790]                     next
[18:01:06.790]                   args[[name]] <- ""
[18:01:06.790]                 }
[18:01:06.790]                 NAMES <- toupper(removed)
[18:01:06.790]                 for (kk in seq_along(NAMES)) {
[18:01:06.790]                   name <- removed[[kk]]
[18:01:06.790]                   NAME <- NAMES[[kk]]
[18:01:06.790]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.790]                     next
[18:01:06.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.790]                 }
[18:01:06.790]                 if (length(args) > 0) 
[18:01:06.790]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.790]             }
[18:01:06.790]             else {
[18:01:06.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.790]             }
[18:01:06.790]             {
[18:01:06.790]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.790]                   0L) {
[18:01:06.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.790]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.790]                   base::options(opts)
[18:01:06.790]                 }
[18:01:06.790]                 {
[18:01:06.790]                   {
[18:01:06.790]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.790]                     NULL
[18:01:06.790]                   }
[18:01:06.790]                   options(future.plan = NULL)
[18:01:06.790]                   if (is.na(NA_character_)) 
[18:01:06.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.790]                     .init = FALSE)
[18:01:06.790]                 }
[18:01:06.790]             }
[18:01:06.790]         }
[18:01:06.790]     })
[18:01:06.790]     if (TRUE) {
[18:01:06.790]         base::sink(type = "output", split = FALSE)
[18:01:06.790]         if (TRUE) {
[18:01:06.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.790]         }
[18:01:06.790]         else {
[18:01:06.790]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.790]         }
[18:01:06.790]         base::close(...future.stdout)
[18:01:06.790]         ...future.stdout <- NULL
[18:01:06.790]     }
[18:01:06.790]     ...future.result$conditions <- ...future.conditions
[18:01:06.790]     ...future.result$finished <- base::Sys.time()
[18:01:06.790]     ...future.result
[18:01:06.790] }
[18:01:06.794] Poll #1 (0): usedNodes() = 2, workers = 2
[18:01:06.805] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.805] - Validating connection of MultisessionFuture
[18:01:06.805] - received message: FutureResult
[18:01:06.806] - Received FutureResult
[18:01:06.806] - Erased future from FutureRegistry
[18:01:06.806] result() for ClusterFuture ...
[18:01:06.806] - result already collected: FutureResult
[18:01:06.806] result() for ClusterFuture ... done
[18:01:06.807] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.807] result() for ClusterFuture ...
[18:01:06.807] - result already collected: FutureResult
[18:01:06.807] result() for ClusterFuture ... done
[18:01:06.807] result() for ClusterFuture ...
[18:01:06.808] - result already collected: FutureResult
[18:01:06.808] result() for ClusterFuture ... done
[18:01:06.809] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[18:01:06.809] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:06.810] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:06.811] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:06.811] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.812] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[18:01:06.813] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[18:01:06.813] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:06.814] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.814] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:06.815] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.815] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[18:01:06.816] MultisessionFuture started
[18:01:06.816] - Launch lazy future ... done
[18:01:06.816] run() for ‘MultisessionFuture’ ... done
[18:01:06.817] Created future:
[18:01:06.817] MultisessionFuture:
[18:01:06.817] Label: ‘future_mapply-3’
[18:01:06.817] Expression:
[18:01:06.817] {
[18:01:06.817]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.817]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.817]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.817]         on.exit(options(oopts), add = TRUE)
[18:01:06.817]     }
[18:01:06.817]     {
[18:01:06.817]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.817]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.817]         do.call(mapply, args = args)
[18:01:06.817]     }
[18:01:06.817] }
[18:01:06.817] Lazy evaluation: FALSE
[18:01:06.817] Asynchronous evaluation: TRUE
[18:01:06.817] Local evaluation: TRUE
[18:01:06.817] Environment: R_GlobalEnv
[18:01:06.817] Capture standard output: TRUE
[18:01:06.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.817] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.817] Packages: <none>
[18:01:06.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.817] Resolved: FALSE
[18:01:06.817] Value: <not collected>
[18:01:06.817] Conditions captured: <none>
[18:01:06.817] Early signaling: FALSE
[18:01:06.817] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.817] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.829] Chunk #3 of 5 ... DONE
[18:01:06.830] Chunk #4 of 5 ...
[18:01:06.830]  - Finding globals in '...' for chunk #4 ...
[18:01:06.830] getGlobalsAndPackages() ...
[18:01:06.830] Searching for globals...
[18:01:06.831] 
[18:01:06.831] Searching for globals ... DONE
[18:01:06.832] - globals: [0] <none>
[18:01:06.832] getGlobalsAndPackages() ... DONE
[18:01:06.832]    + additional globals found: [n=0] 
[18:01:06.832]    + additional namespaces needed: [n=0] 
[18:01:06.832]  - Finding globals in '...' for chunk #4 ... DONE
[18:01:06.833]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:06.833]  - seeds: <none>
[18:01:06.833]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.833] getGlobalsAndPackages() ...
[18:01:06.833] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.834] Resolving globals: FALSE
[18:01:06.835] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:06.836] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.836] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.836] 
[18:01:06.836] getGlobalsAndPackages() ... DONE
[18:01:06.837] run() for ‘Future’ ...
[18:01:06.837] - state: ‘created’
[18:01:06.837] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.861] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.862]   - Field: ‘node’
[18:01:06.862]   - Field: ‘label’
[18:01:06.862]   - Field: ‘local’
[18:01:06.862]   - Field: ‘owner’
[18:01:06.863]   - Field: ‘envir’
[18:01:06.863]   - Field: ‘workers’
[18:01:06.863]   - Field: ‘packages’
[18:01:06.863]   - Field: ‘gc’
[18:01:06.863]   - Field: ‘conditions’
[18:01:06.864]   - Field: ‘persistent’
[18:01:06.864]   - Field: ‘expr’
[18:01:06.864]   - Field: ‘uuid’
[18:01:06.864]   - Field: ‘seed’
[18:01:06.864]   - Field: ‘version’
[18:01:06.865]   - Field: ‘result’
[18:01:06.865]   - Field: ‘asynchronous’
[18:01:06.865]   - Field: ‘calls’
[18:01:06.865]   - Field: ‘globals’
[18:01:06.865]   - Field: ‘stdout’
[18:01:06.868]   - Field: ‘earlySignal’
[18:01:06.868]   - Field: ‘lazy’
[18:01:06.869]   - Field: ‘state’
[18:01:06.869] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.869] - Launch lazy future ...
[18:01:06.870] Packages needed by the future expression (n = 0): <none>
[18:01:06.870] Packages needed by future strategies (n = 0): <none>
[18:01:06.871] {
[18:01:06.871]     {
[18:01:06.871]         {
[18:01:06.871]             ...future.startTime <- base::Sys.time()
[18:01:06.871]             {
[18:01:06.871]                 {
[18:01:06.871]                   {
[18:01:06.871]                     {
[18:01:06.871]                       base::local({
[18:01:06.871]                         has_future <- base::requireNamespace("future", 
[18:01:06.871]                           quietly = TRUE)
[18:01:06.871]                         if (has_future) {
[18:01:06.871]                           ns <- base::getNamespace("future")
[18:01:06.871]                           version <- ns[[".package"]][["version"]]
[18:01:06.871]                           if (is.null(version)) 
[18:01:06.871]                             version <- utils::packageVersion("future")
[18:01:06.871]                         }
[18:01:06.871]                         else {
[18:01:06.871]                           version <- NULL
[18:01:06.871]                         }
[18:01:06.871]                         if (!has_future || version < "1.8.0") {
[18:01:06.871]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.871]                             "", base::R.version$version.string), 
[18:01:06.871]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.871]                               "release", "version")], collapse = " "), 
[18:01:06.871]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.871]                             info)
[18:01:06.871]                           info <- base::paste(info, collapse = "; ")
[18:01:06.871]                           if (!has_future) {
[18:01:06.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.871]                               info)
[18:01:06.871]                           }
[18:01:06.871]                           else {
[18:01:06.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.871]                               info, version)
[18:01:06.871]                           }
[18:01:06.871]                           base::stop(msg)
[18:01:06.871]                         }
[18:01:06.871]                       })
[18:01:06.871]                     }
[18:01:06.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.871]                     base::options(mc.cores = 1L)
[18:01:06.871]                   }
[18:01:06.871]                   ...future.strategy.old <- future::plan("list")
[18:01:06.871]                   options(future.plan = NULL)
[18:01:06.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.871]                 }
[18:01:06.871]                 ...future.workdir <- getwd()
[18:01:06.871]             }
[18:01:06.871]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.871]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.871]         }
[18:01:06.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.871]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:06.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.871]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.871]             base::names(...future.oldOptions))
[18:01:06.871]     }
[18:01:06.871]     if (FALSE) {
[18:01:06.871]     }
[18:01:06.871]     else {
[18:01:06.871]         if (TRUE) {
[18:01:06.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.871]                 open = "w")
[18:01:06.871]         }
[18:01:06.871]         else {
[18:01:06.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.871]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.871]         }
[18:01:06.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.871]             base::sink(type = "output", split = FALSE)
[18:01:06.871]             base::close(...future.stdout)
[18:01:06.871]         }, add = TRUE)
[18:01:06.871]     }
[18:01:06.871]     ...future.frame <- base::sys.nframe()
[18:01:06.871]     ...future.conditions <- base::list()
[18:01:06.871]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.871]     if (FALSE) {
[18:01:06.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.871]     }
[18:01:06.871]     ...future.result <- base::tryCatch({
[18:01:06.871]         base::withCallingHandlers({
[18:01:06.871]             ...future.value <- base::withVisible(base::local({
[18:01:06.871]                 ...future.makeSendCondition <- base::local({
[18:01:06.871]                   sendCondition <- NULL
[18:01:06.871]                   function(frame = 1L) {
[18:01:06.871]                     if (is.function(sendCondition)) 
[18:01:06.871]                       return(sendCondition)
[18:01:06.871]                     ns <- getNamespace("parallel")
[18:01:06.871]                     if (exists("sendData", mode = "function", 
[18:01:06.871]                       envir = ns)) {
[18:01:06.871]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.871]                         envir = ns)
[18:01:06.871]                       envir <- sys.frame(frame)
[18:01:06.871]                       master <- NULL
[18:01:06.871]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.871]                         !identical(envir, emptyenv())) {
[18:01:06.871]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.871]                           inherits = FALSE)) {
[18:01:06.871]                           master <- get("master", mode = "list", 
[18:01:06.871]                             envir = envir, inherits = FALSE)
[18:01:06.871]                           if (inherits(master, c("SOCKnode", 
[18:01:06.871]                             "SOCK0node"))) {
[18:01:06.871]                             sendCondition <<- function(cond) {
[18:01:06.871]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.871]                                 success = TRUE)
[18:01:06.871]                               parallel_sendData(master, data)
[18:01:06.871]                             }
[18:01:06.871]                             return(sendCondition)
[18:01:06.871]                           }
[18:01:06.871]                         }
[18:01:06.871]                         frame <- frame + 1L
[18:01:06.871]                         envir <- sys.frame(frame)
[18:01:06.871]                       }
[18:01:06.871]                     }
[18:01:06.871]                     sendCondition <<- function(cond) NULL
[18:01:06.871]                   }
[18:01:06.871]                 })
[18:01:06.871]                 withCallingHandlers({
[18:01:06.871]                   {
[18:01:06.871]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.871]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.871]                       ...future.globals.maxSize)) {
[18:01:06.871]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.871]                       on.exit(options(oopts), add = TRUE)
[18:01:06.871]                     }
[18:01:06.871]                     {
[18:01:06.871]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.871]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.871]                         USE.NAMES = FALSE)
[18:01:06.871]                       do.call(mapply, args = args)
[18:01:06.871]                     }
[18:01:06.871]                   }
[18:01:06.871]                 }, immediateCondition = function(cond) {
[18:01:06.871]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.871]                   sendCondition(cond)
[18:01:06.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.871]                   {
[18:01:06.871]                     inherits <- base::inherits
[18:01:06.871]                     invokeRestart <- base::invokeRestart
[18:01:06.871]                     is.null <- base::is.null
[18:01:06.871]                     muffled <- FALSE
[18:01:06.871]                     if (inherits(cond, "message")) {
[18:01:06.871]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.871]                       if (muffled) 
[18:01:06.871]                         invokeRestart("muffleMessage")
[18:01:06.871]                     }
[18:01:06.871]                     else if (inherits(cond, "warning")) {
[18:01:06.871]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.871]                       if (muffled) 
[18:01:06.871]                         invokeRestart("muffleWarning")
[18:01:06.871]                     }
[18:01:06.871]                     else if (inherits(cond, "condition")) {
[18:01:06.871]                       if (!is.null(pattern)) {
[18:01:06.871]                         computeRestarts <- base::computeRestarts
[18:01:06.871]                         grepl <- base::grepl
[18:01:06.871]                         restarts <- computeRestarts(cond)
[18:01:06.871]                         for (restart in restarts) {
[18:01:06.871]                           name <- restart$name
[18:01:06.871]                           if (is.null(name)) 
[18:01:06.871]                             next
[18:01:06.871]                           if (!grepl(pattern, name)) 
[18:01:06.871]                             next
[18:01:06.871]                           invokeRestart(restart)
[18:01:06.871]                           muffled <- TRUE
[18:01:06.871]                           break
[18:01:06.871]                         }
[18:01:06.871]                       }
[18:01:06.871]                     }
[18:01:06.871]                     invisible(muffled)
[18:01:06.871]                   }
[18:01:06.871]                   muffleCondition(cond)
[18:01:06.871]                 })
[18:01:06.871]             }))
[18:01:06.871]             future::FutureResult(value = ...future.value$value, 
[18:01:06.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.871]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.871]                     ...future.globalenv.names))
[18:01:06.871]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.871]         }, condition = base::local({
[18:01:06.871]             c <- base::c
[18:01:06.871]             inherits <- base::inherits
[18:01:06.871]             invokeRestart <- base::invokeRestart
[18:01:06.871]             length <- base::length
[18:01:06.871]             list <- base::list
[18:01:06.871]             seq.int <- base::seq.int
[18:01:06.871]             signalCondition <- base::signalCondition
[18:01:06.871]             sys.calls <- base::sys.calls
[18:01:06.871]             `[[` <- base::`[[`
[18:01:06.871]             `+` <- base::`+`
[18:01:06.871]             `<<-` <- base::`<<-`
[18:01:06.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.871]                   3L)]
[18:01:06.871]             }
[18:01:06.871]             function(cond) {
[18:01:06.871]                 is_error <- inherits(cond, "error")
[18:01:06.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.871]                   NULL)
[18:01:06.871]                 if (is_error) {
[18:01:06.871]                   sessionInformation <- function() {
[18:01:06.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.871]                       search = base::search(), system = base::Sys.info())
[18:01:06.871]                   }
[18:01:06.871]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.871]                     cond$call), session = sessionInformation(), 
[18:01:06.871]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.871]                   signalCondition(cond)
[18:01:06.871]                 }
[18:01:06.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.871]                 "immediateCondition"))) {
[18:01:06.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.871]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.871]                   if (TRUE && !signal) {
[18:01:06.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.871]                     {
[18:01:06.871]                       inherits <- base::inherits
[18:01:06.871]                       invokeRestart <- base::invokeRestart
[18:01:06.871]                       is.null <- base::is.null
[18:01:06.871]                       muffled <- FALSE
[18:01:06.871]                       if (inherits(cond, "message")) {
[18:01:06.871]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.871]                         if (muffled) 
[18:01:06.871]                           invokeRestart("muffleMessage")
[18:01:06.871]                       }
[18:01:06.871]                       else if (inherits(cond, "warning")) {
[18:01:06.871]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.871]                         if (muffled) 
[18:01:06.871]                           invokeRestart("muffleWarning")
[18:01:06.871]                       }
[18:01:06.871]                       else if (inherits(cond, "condition")) {
[18:01:06.871]                         if (!is.null(pattern)) {
[18:01:06.871]                           computeRestarts <- base::computeRestarts
[18:01:06.871]                           grepl <- base::grepl
[18:01:06.871]                           restarts <- computeRestarts(cond)
[18:01:06.871]                           for (restart in restarts) {
[18:01:06.871]                             name <- restart$name
[18:01:06.871]                             if (is.null(name)) 
[18:01:06.871]                               next
[18:01:06.871]                             if (!grepl(pattern, name)) 
[18:01:06.871]                               next
[18:01:06.871]                             invokeRestart(restart)
[18:01:06.871]                             muffled <- TRUE
[18:01:06.871]                             break
[18:01:06.871]                           }
[18:01:06.871]                         }
[18:01:06.871]                       }
[18:01:06.871]                       invisible(muffled)
[18:01:06.871]                     }
[18:01:06.871]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.871]                   }
[18:01:06.871]                 }
[18:01:06.871]                 else {
[18:01:06.871]                   if (TRUE) {
[18:01:06.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.871]                     {
[18:01:06.871]                       inherits <- base::inherits
[18:01:06.871]                       invokeRestart <- base::invokeRestart
[18:01:06.871]                       is.null <- base::is.null
[18:01:06.871]                       muffled <- FALSE
[18:01:06.871]                       if (inherits(cond, "message")) {
[18:01:06.871]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.871]                         if (muffled) 
[18:01:06.871]                           invokeRestart("muffleMessage")
[18:01:06.871]                       }
[18:01:06.871]                       else if (inherits(cond, "warning")) {
[18:01:06.871]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.871]                         if (muffled) 
[18:01:06.871]                           invokeRestart("muffleWarning")
[18:01:06.871]                       }
[18:01:06.871]                       else if (inherits(cond, "condition")) {
[18:01:06.871]                         if (!is.null(pattern)) {
[18:01:06.871]                           computeRestarts <- base::computeRestarts
[18:01:06.871]                           grepl <- base::grepl
[18:01:06.871]                           restarts <- computeRestarts(cond)
[18:01:06.871]                           for (restart in restarts) {
[18:01:06.871]                             name <- restart$name
[18:01:06.871]                             if (is.null(name)) 
[18:01:06.871]                               next
[18:01:06.871]                             if (!grepl(pattern, name)) 
[18:01:06.871]                               next
[18:01:06.871]                             invokeRestart(restart)
[18:01:06.871]                             muffled <- TRUE
[18:01:06.871]                             break
[18:01:06.871]                           }
[18:01:06.871]                         }
[18:01:06.871]                       }
[18:01:06.871]                       invisible(muffled)
[18:01:06.871]                     }
[18:01:06.871]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.871]                   }
[18:01:06.871]                 }
[18:01:06.871]             }
[18:01:06.871]         }))
[18:01:06.871]     }, error = function(ex) {
[18:01:06.871]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.871]                 ...future.rng), started = ...future.startTime, 
[18:01:06.871]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.871]             version = "1.8"), class = "FutureResult")
[18:01:06.871]     }, finally = {
[18:01:06.871]         if (!identical(...future.workdir, getwd())) 
[18:01:06.871]             setwd(...future.workdir)
[18:01:06.871]         {
[18:01:06.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.871]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.871]             }
[18:01:06.871]             base::options(...future.oldOptions)
[18:01:06.871]             if (.Platform$OS.type == "windows") {
[18:01:06.871]                 old_names <- names(...future.oldEnvVars)
[18:01:06.871]                 envs <- base::Sys.getenv()
[18:01:06.871]                 names <- names(envs)
[18:01:06.871]                 common <- intersect(names, old_names)
[18:01:06.871]                 added <- setdiff(names, old_names)
[18:01:06.871]                 removed <- setdiff(old_names, names)
[18:01:06.871]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.871]                   envs[common]]
[18:01:06.871]                 NAMES <- toupper(changed)
[18:01:06.871]                 args <- list()
[18:01:06.871]                 for (kk in seq_along(NAMES)) {
[18:01:06.871]                   name <- changed[[kk]]
[18:01:06.871]                   NAME <- NAMES[[kk]]
[18:01:06.871]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.871]                     next
[18:01:06.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.871]                 }
[18:01:06.871]                 NAMES <- toupper(added)
[18:01:06.871]                 for (kk in seq_along(NAMES)) {
[18:01:06.871]                   name <- added[[kk]]
[18:01:06.871]                   NAME <- NAMES[[kk]]
[18:01:06.871]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.871]                     next
[18:01:06.871]                   args[[name]] <- ""
[18:01:06.871]                 }
[18:01:06.871]                 NAMES <- toupper(removed)
[18:01:06.871]                 for (kk in seq_along(NAMES)) {
[18:01:06.871]                   name <- removed[[kk]]
[18:01:06.871]                   NAME <- NAMES[[kk]]
[18:01:06.871]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.871]                     next
[18:01:06.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.871]                 }
[18:01:06.871]                 if (length(args) > 0) 
[18:01:06.871]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.871]             }
[18:01:06.871]             else {
[18:01:06.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.871]             }
[18:01:06.871]             {
[18:01:06.871]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.871]                   0L) {
[18:01:06.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.871]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.871]                   base::options(opts)
[18:01:06.871]                 }
[18:01:06.871]                 {
[18:01:06.871]                   {
[18:01:06.871]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.871]                     NULL
[18:01:06.871]                   }
[18:01:06.871]                   options(future.plan = NULL)
[18:01:06.871]                   if (is.na(NA_character_)) 
[18:01:06.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.871]                     .init = FALSE)
[18:01:06.871]                 }
[18:01:06.871]             }
[18:01:06.871]         }
[18:01:06.871]     })
[18:01:06.871]     if (TRUE) {
[18:01:06.871]         base::sink(type = "output", split = FALSE)
[18:01:06.871]         if (TRUE) {
[18:01:06.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.871]         }
[18:01:06.871]         else {
[18:01:06.871]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.871]         }
[18:01:06.871]         base::close(...future.stdout)
[18:01:06.871]         ...future.stdout <- NULL
[18:01:06.871]     }
[18:01:06.871]     ...future.result$conditions <- ...future.conditions
[18:01:06.871]     ...future.result$finished <- base::Sys.time()
[18:01:06.871]     ...future.result
[18:01:06.871] }
[18:01:06.875] Poll #1 (0): usedNodes() = 2, workers = 2
[18:01:06.886] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.887] - Validating connection of MultisessionFuture
[18:01:06.887] - received message: FutureResult
[18:01:06.887] - Received FutureResult
[18:01:06.887] - Erased future from FutureRegistry
[18:01:06.888] result() for ClusterFuture ...
[18:01:06.888] - result already collected: FutureResult
[18:01:06.888] result() for ClusterFuture ... done
[18:01:06.888] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.888] result() for ClusterFuture ...
[18:01:06.889] - result already collected: FutureResult
[18:01:06.889] result() for ClusterFuture ... done
[18:01:06.889] result() for ClusterFuture ...
[18:01:06.889] - result already collected: FutureResult
[18:01:06.889] result() for ClusterFuture ... done
[18:01:06.891] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[18:01:06.891] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:06.892] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:06.892] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:06.893] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.893] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[18:01:06.894] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[18:01:06.895] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:06.895] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.896] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:06.897] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:06.897] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[18:01:06.898] MultisessionFuture started
[18:01:06.898] - Launch lazy future ... done
[18:01:06.898] run() for ‘MultisessionFuture’ ... done
[18:01:06.899] Created future:
[18:01:06.899] MultisessionFuture:
[18:01:06.899] Label: ‘future_mapply-4’
[18:01:06.899] Expression:
[18:01:06.899] {
[18:01:06.899]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.899]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.899]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.899]         on.exit(options(oopts), add = TRUE)
[18:01:06.899]     }
[18:01:06.899]     {
[18:01:06.899]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.899]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.899]         do.call(mapply, args = args)
[18:01:06.899]     }
[18:01:06.899] }
[18:01:06.899] Lazy evaluation: FALSE
[18:01:06.899] Asynchronous evaluation: TRUE
[18:01:06.899] Local evaluation: TRUE
[18:01:06.899] Environment: R_GlobalEnv
[18:01:06.899] Capture standard output: TRUE
[18:01:06.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.899] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.899] Packages: <none>
[18:01:06.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.899] Resolved: FALSE
[18:01:06.899] Value: <not collected>
[18:01:06.899] Conditions captured: <none>
[18:01:06.899] Early signaling: FALSE
[18:01:06.899] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.899] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.912] Chunk #4 of 5 ... DONE
[18:01:06.912] Chunk #5 of 5 ...
[18:01:06.912]  - Finding globals in '...' for chunk #5 ...
[18:01:06.912] getGlobalsAndPackages() ...
[18:01:06.913] Searching for globals...
[18:01:06.913] 
[18:01:06.914] Searching for globals ... DONE
[18:01:06.914] - globals: [0] <none>
[18:01:06.914] getGlobalsAndPackages() ... DONE
[18:01:06.914]    + additional globals found: [n=0] 
[18:01:06.914]    + additional namespaces needed: [n=0] 
[18:01:06.915]  - Finding globals in '...' for chunk #5 ... DONE
[18:01:06.915]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[18:01:06.915]  - seeds: <none>
[18:01:06.915]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.915] getGlobalsAndPackages() ...
[18:01:06.916] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.916] Resolving globals: FALSE
[18:01:06.917] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:06.918] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:06.918] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:06.918] 
[18:01:06.919] getGlobalsAndPackages() ... DONE
[18:01:06.919] run() for ‘Future’ ...
[18:01:06.919] - state: ‘created’
[18:01:06.920] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:06.944] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:06.945]   - Field: ‘node’
[18:01:06.945]   - Field: ‘label’
[18:01:06.945]   - Field: ‘local’
[18:01:06.945]   - Field: ‘owner’
[18:01:06.945]   - Field: ‘envir’
[18:01:06.946]   - Field: ‘workers’
[18:01:06.946]   - Field: ‘packages’
[18:01:06.946]   - Field: ‘gc’
[18:01:06.946]   - Field: ‘conditions’
[18:01:06.946]   - Field: ‘persistent’
[18:01:06.947]   - Field: ‘expr’
[18:01:06.947]   - Field: ‘uuid’
[18:01:06.947]   - Field: ‘seed’
[18:01:06.947]   - Field: ‘version’
[18:01:06.947]   - Field: ‘result’
[18:01:06.948]   - Field: ‘asynchronous’
[18:01:06.948]   - Field: ‘calls’
[18:01:06.948]   - Field: ‘globals’
[18:01:06.948]   - Field: ‘stdout’
[18:01:06.948]   - Field: ‘earlySignal’
[18:01:06.949]   - Field: ‘lazy’
[18:01:06.949]   - Field: ‘state’
[18:01:06.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:06.949] - Launch lazy future ...
[18:01:06.950] Packages needed by the future expression (n = 0): <none>
[18:01:06.950] Packages needed by future strategies (n = 0): <none>
[18:01:06.951] {
[18:01:06.951]     {
[18:01:06.951]         {
[18:01:06.951]             ...future.startTime <- base::Sys.time()
[18:01:06.951]             {
[18:01:06.951]                 {
[18:01:06.951]                   {
[18:01:06.951]                     {
[18:01:06.951]                       base::local({
[18:01:06.951]                         has_future <- base::requireNamespace("future", 
[18:01:06.951]                           quietly = TRUE)
[18:01:06.951]                         if (has_future) {
[18:01:06.951]                           ns <- base::getNamespace("future")
[18:01:06.951]                           version <- ns[[".package"]][["version"]]
[18:01:06.951]                           if (is.null(version)) 
[18:01:06.951]                             version <- utils::packageVersion("future")
[18:01:06.951]                         }
[18:01:06.951]                         else {
[18:01:06.951]                           version <- NULL
[18:01:06.951]                         }
[18:01:06.951]                         if (!has_future || version < "1.8.0") {
[18:01:06.951]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:06.951]                             "", base::R.version$version.string), 
[18:01:06.951]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:06.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:06.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:06.951]                               "release", "version")], collapse = " "), 
[18:01:06.951]                             hostname = base::Sys.info()[["nodename"]])
[18:01:06.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:06.951]                             info)
[18:01:06.951]                           info <- base::paste(info, collapse = "; ")
[18:01:06.951]                           if (!has_future) {
[18:01:06.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:06.951]                               info)
[18:01:06.951]                           }
[18:01:06.951]                           else {
[18:01:06.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:06.951]                               info, version)
[18:01:06.951]                           }
[18:01:06.951]                           base::stop(msg)
[18:01:06.951]                         }
[18:01:06.951]                       })
[18:01:06.951]                     }
[18:01:06.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:06.951]                     base::options(mc.cores = 1L)
[18:01:06.951]                   }
[18:01:06.951]                   ...future.strategy.old <- future::plan("list")
[18:01:06.951]                   options(future.plan = NULL)
[18:01:06.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:06.951]                 }
[18:01:06.951]                 ...future.workdir <- getwd()
[18:01:06.951]             }
[18:01:06.951]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:06.951]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:06.951]         }
[18:01:06.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:06.951]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[18:01:06.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:06.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:06.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:06.951]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:06.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:06.951]             base::names(...future.oldOptions))
[18:01:06.951]     }
[18:01:06.951]     if (FALSE) {
[18:01:06.951]     }
[18:01:06.951]     else {
[18:01:06.951]         if (TRUE) {
[18:01:06.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:06.951]                 open = "w")
[18:01:06.951]         }
[18:01:06.951]         else {
[18:01:06.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:06.951]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:06.951]         }
[18:01:06.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:06.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:06.951]             base::sink(type = "output", split = FALSE)
[18:01:06.951]             base::close(...future.stdout)
[18:01:06.951]         }, add = TRUE)
[18:01:06.951]     }
[18:01:06.951]     ...future.frame <- base::sys.nframe()
[18:01:06.951]     ...future.conditions <- base::list()
[18:01:06.951]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:06.951]     if (FALSE) {
[18:01:06.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:06.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:06.951]     }
[18:01:06.951]     ...future.result <- base::tryCatch({
[18:01:06.951]         base::withCallingHandlers({
[18:01:06.951]             ...future.value <- base::withVisible(base::local({
[18:01:06.951]                 ...future.makeSendCondition <- base::local({
[18:01:06.951]                   sendCondition <- NULL
[18:01:06.951]                   function(frame = 1L) {
[18:01:06.951]                     if (is.function(sendCondition)) 
[18:01:06.951]                       return(sendCondition)
[18:01:06.951]                     ns <- getNamespace("parallel")
[18:01:06.951]                     if (exists("sendData", mode = "function", 
[18:01:06.951]                       envir = ns)) {
[18:01:06.951]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:06.951]                         envir = ns)
[18:01:06.951]                       envir <- sys.frame(frame)
[18:01:06.951]                       master <- NULL
[18:01:06.951]                       while (!identical(envir, .GlobalEnv) && 
[18:01:06.951]                         !identical(envir, emptyenv())) {
[18:01:06.951]                         if (exists("master", mode = "list", envir = envir, 
[18:01:06.951]                           inherits = FALSE)) {
[18:01:06.951]                           master <- get("master", mode = "list", 
[18:01:06.951]                             envir = envir, inherits = FALSE)
[18:01:06.951]                           if (inherits(master, c("SOCKnode", 
[18:01:06.951]                             "SOCK0node"))) {
[18:01:06.951]                             sendCondition <<- function(cond) {
[18:01:06.951]                               data <- list(type = "VALUE", value = cond, 
[18:01:06.951]                                 success = TRUE)
[18:01:06.951]                               parallel_sendData(master, data)
[18:01:06.951]                             }
[18:01:06.951]                             return(sendCondition)
[18:01:06.951]                           }
[18:01:06.951]                         }
[18:01:06.951]                         frame <- frame + 1L
[18:01:06.951]                         envir <- sys.frame(frame)
[18:01:06.951]                       }
[18:01:06.951]                     }
[18:01:06.951]                     sendCondition <<- function(cond) NULL
[18:01:06.951]                   }
[18:01:06.951]                 })
[18:01:06.951]                 withCallingHandlers({
[18:01:06.951]                   {
[18:01:06.951]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.951]                     if (!identical(...future.globals.maxSize.org, 
[18:01:06.951]                       ...future.globals.maxSize)) {
[18:01:06.951]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.951]                       on.exit(options(oopts), add = TRUE)
[18:01:06.951]                     }
[18:01:06.951]                     {
[18:01:06.951]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.951]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:06.951]                         USE.NAMES = FALSE)
[18:01:06.951]                       do.call(mapply, args = args)
[18:01:06.951]                     }
[18:01:06.951]                   }
[18:01:06.951]                 }, immediateCondition = function(cond) {
[18:01:06.951]                   sendCondition <- ...future.makeSendCondition()
[18:01:06.951]                   sendCondition(cond)
[18:01:06.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.951]                   {
[18:01:06.951]                     inherits <- base::inherits
[18:01:06.951]                     invokeRestart <- base::invokeRestart
[18:01:06.951]                     is.null <- base::is.null
[18:01:06.951]                     muffled <- FALSE
[18:01:06.951]                     if (inherits(cond, "message")) {
[18:01:06.951]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:06.951]                       if (muffled) 
[18:01:06.951]                         invokeRestart("muffleMessage")
[18:01:06.951]                     }
[18:01:06.951]                     else if (inherits(cond, "warning")) {
[18:01:06.951]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:06.951]                       if (muffled) 
[18:01:06.951]                         invokeRestart("muffleWarning")
[18:01:06.951]                     }
[18:01:06.951]                     else if (inherits(cond, "condition")) {
[18:01:06.951]                       if (!is.null(pattern)) {
[18:01:06.951]                         computeRestarts <- base::computeRestarts
[18:01:06.951]                         grepl <- base::grepl
[18:01:06.951]                         restarts <- computeRestarts(cond)
[18:01:06.951]                         for (restart in restarts) {
[18:01:06.951]                           name <- restart$name
[18:01:06.951]                           if (is.null(name)) 
[18:01:06.951]                             next
[18:01:06.951]                           if (!grepl(pattern, name)) 
[18:01:06.951]                             next
[18:01:06.951]                           invokeRestart(restart)
[18:01:06.951]                           muffled <- TRUE
[18:01:06.951]                           break
[18:01:06.951]                         }
[18:01:06.951]                       }
[18:01:06.951]                     }
[18:01:06.951]                     invisible(muffled)
[18:01:06.951]                   }
[18:01:06.951]                   muffleCondition(cond)
[18:01:06.951]                 })
[18:01:06.951]             }))
[18:01:06.951]             future::FutureResult(value = ...future.value$value, 
[18:01:06.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.951]                   ...future.rng), globalenv = if (FALSE) 
[18:01:06.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:06.951]                     ...future.globalenv.names))
[18:01:06.951]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:06.951]         }, condition = base::local({
[18:01:06.951]             c <- base::c
[18:01:06.951]             inherits <- base::inherits
[18:01:06.951]             invokeRestart <- base::invokeRestart
[18:01:06.951]             length <- base::length
[18:01:06.951]             list <- base::list
[18:01:06.951]             seq.int <- base::seq.int
[18:01:06.951]             signalCondition <- base::signalCondition
[18:01:06.951]             sys.calls <- base::sys.calls
[18:01:06.951]             `[[` <- base::`[[`
[18:01:06.951]             `+` <- base::`+`
[18:01:06.951]             `<<-` <- base::`<<-`
[18:01:06.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:06.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:06.951]                   3L)]
[18:01:06.951]             }
[18:01:06.951]             function(cond) {
[18:01:06.951]                 is_error <- inherits(cond, "error")
[18:01:06.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:06.951]                   NULL)
[18:01:06.951]                 if (is_error) {
[18:01:06.951]                   sessionInformation <- function() {
[18:01:06.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:06.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:06.951]                       search = base::search(), system = base::Sys.info())
[18:01:06.951]                   }
[18:01:06.951]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:06.951]                     cond$call), session = sessionInformation(), 
[18:01:06.951]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:06.951]                   signalCondition(cond)
[18:01:06.951]                 }
[18:01:06.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:06.951]                 "immediateCondition"))) {
[18:01:06.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:06.951]                   ...future.conditions[[length(...future.conditions) + 
[18:01:06.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:06.951]                   if (TRUE && !signal) {
[18:01:06.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.951]                     {
[18:01:06.951]                       inherits <- base::inherits
[18:01:06.951]                       invokeRestart <- base::invokeRestart
[18:01:06.951]                       is.null <- base::is.null
[18:01:06.951]                       muffled <- FALSE
[18:01:06.951]                       if (inherits(cond, "message")) {
[18:01:06.951]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.951]                         if (muffled) 
[18:01:06.951]                           invokeRestart("muffleMessage")
[18:01:06.951]                       }
[18:01:06.951]                       else if (inherits(cond, "warning")) {
[18:01:06.951]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.951]                         if (muffled) 
[18:01:06.951]                           invokeRestart("muffleWarning")
[18:01:06.951]                       }
[18:01:06.951]                       else if (inherits(cond, "condition")) {
[18:01:06.951]                         if (!is.null(pattern)) {
[18:01:06.951]                           computeRestarts <- base::computeRestarts
[18:01:06.951]                           grepl <- base::grepl
[18:01:06.951]                           restarts <- computeRestarts(cond)
[18:01:06.951]                           for (restart in restarts) {
[18:01:06.951]                             name <- restart$name
[18:01:06.951]                             if (is.null(name)) 
[18:01:06.951]                               next
[18:01:06.951]                             if (!grepl(pattern, name)) 
[18:01:06.951]                               next
[18:01:06.951]                             invokeRestart(restart)
[18:01:06.951]                             muffled <- TRUE
[18:01:06.951]                             break
[18:01:06.951]                           }
[18:01:06.951]                         }
[18:01:06.951]                       }
[18:01:06.951]                       invisible(muffled)
[18:01:06.951]                     }
[18:01:06.951]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.951]                   }
[18:01:06.951]                 }
[18:01:06.951]                 else {
[18:01:06.951]                   if (TRUE) {
[18:01:06.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:06.951]                     {
[18:01:06.951]                       inherits <- base::inherits
[18:01:06.951]                       invokeRestart <- base::invokeRestart
[18:01:06.951]                       is.null <- base::is.null
[18:01:06.951]                       muffled <- FALSE
[18:01:06.951]                       if (inherits(cond, "message")) {
[18:01:06.951]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:06.951]                         if (muffled) 
[18:01:06.951]                           invokeRestart("muffleMessage")
[18:01:06.951]                       }
[18:01:06.951]                       else if (inherits(cond, "warning")) {
[18:01:06.951]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:06.951]                         if (muffled) 
[18:01:06.951]                           invokeRestart("muffleWarning")
[18:01:06.951]                       }
[18:01:06.951]                       else if (inherits(cond, "condition")) {
[18:01:06.951]                         if (!is.null(pattern)) {
[18:01:06.951]                           computeRestarts <- base::computeRestarts
[18:01:06.951]                           grepl <- base::grepl
[18:01:06.951]                           restarts <- computeRestarts(cond)
[18:01:06.951]                           for (restart in restarts) {
[18:01:06.951]                             name <- restart$name
[18:01:06.951]                             if (is.null(name)) 
[18:01:06.951]                               next
[18:01:06.951]                             if (!grepl(pattern, name)) 
[18:01:06.951]                               next
[18:01:06.951]                             invokeRestart(restart)
[18:01:06.951]                             muffled <- TRUE
[18:01:06.951]                             break
[18:01:06.951]                           }
[18:01:06.951]                         }
[18:01:06.951]                       }
[18:01:06.951]                       invisible(muffled)
[18:01:06.951]                     }
[18:01:06.951]                     muffleCondition(cond, pattern = "^muffle")
[18:01:06.951]                   }
[18:01:06.951]                 }
[18:01:06.951]             }
[18:01:06.951]         }))
[18:01:06.951]     }, error = function(ex) {
[18:01:06.951]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:06.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:06.951]                 ...future.rng), started = ...future.startTime, 
[18:01:06.951]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:06.951]             version = "1.8"), class = "FutureResult")
[18:01:06.951]     }, finally = {
[18:01:06.951]         if (!identical(...future.workdir, getwd())) 
[18:01:06.951]             setwd(...future.workdir)
[18:01:06.951]         {
[18:01:06.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:06.951]                 ...future.oldOptions$nwarnings <- NULL
[18:01:06.951]             }
[18:01:06.951]             base::options(...future.oldOptions)
[18:01:06.951]             if (.Platform$OS.type == "windows") {
[18:01:06.951]                 old_names <- names(...future.oldEnvVars)
[18:01:06.951]                 envs <- base::Sys.getenv()
[18:01:06.951]                 names <- names(envs)
[18:01:06.951]                 common <- intersect(names, old_names)
[18:01:06.951]                 added <- setdiff(names, old_names)
[18:01:06.951]                 removed <- setdiff(old_names, names)
[18:01:06.951]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:06.951]                   envs[common]]
[18:01:06.951]                 NAMES <- toupper(changed)
[18:01:06.951]                 args <- list()
[18:01:06.951]                 for (kk in seq_along(NAMES)) {
[18:01:06.951]                   name <- changed[[kk]]
[18:01:06.951]                   NAME <- NAMES[[kk]]
[18:01:06.951]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.951]                     next
[18:01:06.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.951]                 }
[18:01:06.951]                 NAMES <- toupper(added)
[18:01:06.951]                 for (kk in seq_along(NAMES)) {
[18:01:06.951]                   name <- added[[kk]]
[18:01:06.951]                   NAME <- NAMES[[kk]]
[18:01:06.951]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.951]                     next
[18:01:06.951]                   args[[name]] <- ""
[18:01:06.951]                 }
[18:01:06.951]                 NAMES <- toupper(removed)
[18:01:06.951]                 for (kk in seq_along(NAMES)) {
[18:01:06.951]                   name <- removed[[kk]]
[18:01:06.951]                   NAME <- NAMES[[kk]]
[18:01:06.951]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:06.951]                     next
[18:01:06.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:06.951]                 }
[18:01:06.951]                 if (length(args) > 0) 
[18:01:06.951]                   base::do.call(base::Sys.setenv, args = args)
[18:01:06.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:06.951]             }
[18:01:06.951]             else {
[18:01:06.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:06.951]             }
[18:01:06.951]             {
[18:01:06.951]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:06.951]                   0L) {
[18:01:06.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:06.951]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:06.951]                   base::options(opts)
[18:01:06.951]                 }
[18:01:06.951]                 {
[18:01:06.951]                   {
[18:01:06.951]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:06.951]                     NULL
[18:01:06.951]                   }
[18:01:06.951]                   options(future.plan = NULL)
[18:01:06.951]                   if (is.na(NA_character_)) 
[18:01:06.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:06.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:06.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:06.951]                     .init = FALSE)
[18:01:06.951]                 }
[18:01:06.951]             }
[18:01:06.951]         }
[18:01:06.951]     })
[18:01:06.951]     if (TRUE) {
[18:01:06.951]         base::sink(type = "output", split = FALSE)
[18:01:06.951]         if (TRUE) {
[18:01:06.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:06.951]         }
[18:01:06.951]         else {
[18:01:06.951]             ...future.result["stdout"] <- base::list(NULL)
[18:01:06.951]         }
[18:01:06.951]         base::close(...future.stdout)
[18:01:06.951]         ...future.stdout <- NULL
[18:01:06.951]     }
[18:01:06.951]     ...future.result$conditions <- ...future.conditions
[18:01:06.951]     ...future.result$finished <- base::Sys.time()
[18:01:06.951]     ...future.result
[18:01:06.951] }
[18:01:06.955] Poll #1 (0): usedNodes() = 2, workers = 2
[18:01:06.966] receiveMessageFromWorker() for ClusterFuture ...
[18:01:06.967] - Validating connection of MultisessionFuture
[18:01:06.967] - received message: FutureResult
[18:01:06.968] - Received FutureResult
[18:01:06.968] - Erased future from FutureRegistry
[18:01:06.968] result() for ClusterFuture ...
[18:01:06.968] - result already collected: FutureResult
[18:01:06.968] result() for ClusterFuture ... done
[18:01:06.969] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:06.969] result() for ClusterFuture ...
[18:01:06.969] - result already collected: FutureResult
[18:01:06.969] result() for ClusterFuture ... done
[18:01:06.969] result() for ClusterFuture ...
[18:01:06.970] - result already collected: FutureResult
[18:01:06.970] result() for ClusterFuture ... done
[18:01:06.971] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[18:01:06.972] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:06.972] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:06.973] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:06.974] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.974] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[18:01:06.975] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[18:01:06.976] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:06.976] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.977] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:06.977] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:06.978] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[18:01:06.979] MultisessionFuture started
[18:01:06.979] - Launch lazy future ... done
[18:01:06.979] run() for ‘MultisessionFuture’ ... done
[18:01:06.979] Created future:
[18:01:06.980] MultisessionFuture:
[18:01:06.980] Label: ‘future_mapply-5’
[18:01:06.980] Expression:
[18:01:06.980] {
[18:01:06.980]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:06.980]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:06.980]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:06.980]         on.exit(options(oopts), add = TRUE)
[18:01:06.980]     }
[18:01:06.980]     {
[18:01:06.980]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:06.980]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:06.980]         do.call(mapply, args = args)
[18:01:06.980]     }
[18:01:06.980] }
[18:01:06.980] Lazy evaluation: FALSE
[18:01:06.980] Asynchronous evaluation: TRUE
[18:01:06.980] Local evaluation: TRUE
[18:01:06.980] Environment: R_GlobalEnv
[18:01:06.980] Capture standard output: TRUE
[18:01:06.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:06.980] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:06.980] Packages: <none>
[18:01:06.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:06.980] Resolved: FALSE
[18:01:06.980] Value: <not collected>
[18:01:06.980] Conditions captured: <none>
[18:01:06.980] Early signaling: FALSE
[18:01:06.980] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:06.980] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:06.994] Chunk #5 of 5 ... DONE
[18:01:06.994] Launching 5 futures (chunks) ... DONE
[18:01:06.994] Resolving 5 futures (chunks) ...
[18:01:06.994] resolve() on list ...
[18:01:06.994]  recursive: 0
[18:01:06.995]  length: 5
[18:01:06.995] 
[18:01:06.995] Future #1
[18:01:06.995] result() for ClusterFuture ...
[18:01:06.996] - result already collected: FutureResult
[18:01:06.996] result() for ClusterFuture ... done
[18:01:06.996] result() for ClusterFuture ...
[18:01:06.996] - result already collected: FutureResult
[18:01:06.997] result() for ClusterFuture ... done
[18:01:06.997] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:06.997] - nx: 5
[18:01:06.997] - relay: TRUE
[18:01:06.997] - stdout: TRUE
[18:01:06.998] - signal: TRUE
[18:01:06.998] - resignal: FALSE
[18:01:06.998] - force: TRUE
[18:01:06.998] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[18:01:06.999] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[18:01:06.999]  - until=1
[18:01:06.999]  - relaying element #1
[18:01:06.999] result() for ClusterFuture ...
[18:01:06.999] - result already collected: FutureResult
[18:01:07.000] result() for ClusterFuture ... done
[18:01:07.000] result() for ClusterFuture ...
[18:01:07.000] - result already collected: FutureResult
[18:01:07.000] result() for ClusterFuture ... done
[18:01:07.001] result() for ClusterFuture ...
[18:01:07.001] - result already collected: FutureResult
[18:01:07.001] result() for ClusterFuture ... done
[18:01:07.001] result() for ClusterFuture ...
[18:01:07.001] - result already collected: FutureResult
[18:01:07.002] result() for ClusterFuture ... done
[18:01:07.002] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:07.002] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:07.002] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:07.002]  length: 4 (resolved future 1)
[18:01:07.003] Future #2
[18:01:07.003] result() for ClusterFuture ...
[18:01:07.003] - result already collected: FutureResult
[18:01:07.003] result() for ClusterFuture ... done
[18:01:07.003] result() for ClusterFuture ...
[18:01:07.004] - result already collected: FutureResult
[18:01:07.004] result() for ClusterFuture ... done
[18:01:07.004] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:07.004] - nx: 5
[18:01:07.004] - relay: TRUE
[18:01:07.005] - stdout: TRUE
[18:01:07.005] - signal: TRUE
[18:01:07.005] - resignal: FALSE
[18:01:07.005] - force: TRUE
[18:01:07.005] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:07.006] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[18:01:07.006]  - until=2
[18:01:07.006]  - relaying element #2
[18:01:07.006] result() for ClusterFuture ...
[18:01:07.007] - result already collected: FutureResult
[18:01:07.007] result() for ClusterFuture ... done
[18:01:07.007] result() for ClusterFuture ...
[18:01:07.007] - result already collected: FutureResult
[18:01:07.007] result() for ClusterFuture ... done
[18:01:07.008] result() for ClusterFuture ...
[18:01:07.008] - result already collected: FutureResult
[18:01:07.008] result() for ClusterFuture ... done
[18:01:07.008] result() for ClusterFuture ...
[18:01:07.008] - result already collected: FutureResult
[18:01:07.009] result() for ClusterFuture ... done
[18:01:07.009] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:07.009] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:07.009] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:07.009]  length: 3 (resolved future 2)
[18:01:07.010] Future #3
[18:01:07.010] result() for ClusterFuture ...
[18:01:07.010] - result already collected: FutureResult
[18:01:07.010] result() for ClusterFuture ... done
[18:01:07.010] result() for ClusterFuture ...
[18:01:07.011] - result already collected: FutureResult
[18:01:07.011] result() for ClusterFuture ... done
[18:01:07.011] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:01:07.011] - nx: 5
[18:01:07.011] - relay: TRUE
[18:01:07.012] - stdout: TRUE
[18:01:07.012] - signal: TRUE
[18:01:07.012] - resignal: FALSE
[18:01:07.012] - force: TRUE
[18:01:07.012] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:07.012] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[18:01:07.013]  - until=3
[18:01:07.013]  - relaying element #3
[18:01:07.013] result() for ClusterFuture ...
[18:01:07.013] - result already collected: FutureResult
[18:01:07.013] result() for ClusterFuture ... done
[18:01:07.014] result() for ClusterFuture ...
[18:01:07.014] - result already collected: FutureResult
[18:01:07.014] result() for ClusterFuture ... done
[18:01:07.014] result() for ClusterFuture ...
[18:01:07.014] - result already collected: FutureResult
[18:01:07.015] result() for ClusterFuture ... done
[18:01:07.015] result() for ClusterFuture ...
[18:01:07.015] - result already collected: FutureResult
[18:01:07.015] result() for ClusterFuture ... done
[18:01:07.015] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:07.016] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:07.016] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:01:07.016]  length: 2 (resolved future 3)
[18:01:07.017] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.017] - Validating connection of MultisessionFuture
[18:01:07.018] - received message: FutureResult
[18:01:07.018] - Received FutureResult
[18:01:07.018] - Erased future from FutureRegistry
[18:01:07.018] result() for ClusterFuture ...
[18:01:07.019] - result already collected: FutureResult
[18:01:07.019] result() for ClusterFuture ... done
[18:01:07.021] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.021] Future #4
[18:01:07.022] result() for ClusterFuture ...
[18:01:07.022] - result already collected: FutureResult
[18:01:07.022] result() for ClusterFuture ... done
[18:01:07.022] result() for ClusterFuture ...
[18:01:07.022] - result already collected: FutureResult
[18:01:07.023] result() for ClusterFuture ... done
[18:01:07.024] signalConditionsASAP(MultisessionFuture, pos=4) ...
[18:01:07.024] - nx: 5
[18:01:07.024] - relay: TRUE
[18:01:07.024] - stdout: TRUE
[18:01:07.024] - signal: TRUE
[18:01:07.025] - resignal: FALSE
[18:01:07.025] - force: TRUE
[18:01:07.025] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:07.025] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[18:01:07.025]  - until=4
[18:01:07.026]  - relaying element #4
[18:01:07.026] result() for ClusterFuture ...
[18:01:07.026] - result already collected: FutureResult
[18:01:07.026] result() for ClusterFuture ... done
[18:01:07.026] result() for ClusterFuture ...
[18:01:07.027] - result already collected: FutureResult
[18:01:07.027] result() for ClusterFuture ... done
[18:01:07.027] result() for ClusterFuture ...
[18:01:07.027] - result already collected: FutureResult
[18:01:07.027] result() for ClusterFuture ... done
[18:01:07.028] result() for ClusterFuture ...
[18:01:07.028] - result already collected: FutureResult
[18:01:07.028] result() for ClusterFuture ... done
[18:01:07.028] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:07.028] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:07.029] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[18:01:07.029]  length: 1 (resolved future 4)
[18:01:07.030] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.030] - Validating connection of MultisessionFuture
[18:01:07.030] - received message: FutureResult
[18:01:07.031] - Received FutureResult
[18:01:07.031] - Erased future from FutureRegistry
[18:01:07.031] result() for ClusterFuture ...
[18:01:07.031] - result already collected: FutureResult
[18:01:07.031] result() for ClusterFuture ... done
[18:01:07.032] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.032] Future #5
[18:01:07.032] result() for ClusterFuture ...
[18:01:07.032] - result already collected: FutureResult
[18:01:07.032] result() for ClusterFuture ... done
[18:01:07.033] result() for ClusterFuture ...
[18:01:07.033] - result already collected: FutureResult
[18:01:07.033] result() for ClusterFuture ... done
[18:01:07.033] signalConditionsASAP(MultisessionFuture, pos=5) ...
[18:01:07.033] - nx: 5
[18:01:07.033] - relay: TRUE
[18:01:07.034] - stdout: TRUE
[18:01:07.034] - signal: TRUE
[18:01:07.034] - resignal: FALSE
[18:01:07.034] - force: TRUE
[18:01:07.034] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:07.035] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[18:01:07.035]  - until=5
[18:01:07.035]  - relaying element #5
[18:01:07.035] result() for ClusterFuture ...
[18:01:07.035] - result already collected: FutureResult
[18:01:07.036] result() for ClusterFuture ... done
[18:01:07.036] result() for ClusterFuture ...
[18:01:07.036] - result already collected: FutureResult
[18:01:07.036] result() for ClusterFuture ... done
[18:01:07.037] result() for ClusterFuture ...
[18:01:07.037] - result already collected: FutureResult
[18:01:07.037] result() for ClusterFuture ... done
[18:01:07.037] result() for ClusterFuture ...
[18:01:07.037] - result already collected: FutureResult
[18:01:07.037] result() for ClusterFuture ... done
[18:01:07.038] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:07.038] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:07.038] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[18:01:07.038]  length: 0 (resolved future 5)
[18:01:07.038] Relaying remaining futures
[18:01:07.039] signalConditionsASAP(NULL, pos=0) ...
[18:01:07.039] - nx: 5
[18:01:07.039] - relay: TRUE
[18:01:07.039] - stdout: TRUE
[18:01:07.039] - signal: TRUE
[18:01:07.039] - resignal: FALSE
[18:01:07.040] - force: TRUE
[18:01:07.040] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:07.040] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[18:01:07.040] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:07.040] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[18:01:07.041] signalConditionsASAP(NULL, pos=0) ... done
[18:01:07.041] resolve() on list ... DONE
[18:01:07.041] result() for ClusterFuture ...
[18:01:07.041] - result already collected: FutureResult
[18:01:07.041] result() for ClusterFuture ... done
[18:01:07.042] result() for ClusterFuture ...
[18:01:07.042] - result already collected: FutureResult
[18:01:07.042] result() for ClusterFuture ... done
[18:01:07.042] result() for ClusterFuture ...
[18:01:07.042] - result already collected: FutureResult
[18:01:07.042] result() for ClusterFuture ... done
[18:01:07.043] result() for ClusterFuture ...
[18:01:07.043] - result already collected: FutureResult
[18:01:07.043] result() for ClusterFuture ... done
[18:01:07.043] result() for ClusterFuture ...
[18:01:07.043] - result already collected: FutureResult
[18:01:07.044] result() for ClusterFuture ... done
[18:01:07.044] result() for ClusterFuture ...
[18:01:07.044] - result already collected: FutureResult
[18:01:07.044] result() for ClusterFuture ... done
[18:01:07.044] result() for ClusterFuture ...
[18:01:07.045] - result already collected: FutureResult
[18:01:07.045] result() for ClusterFuture ... done
[18:01:07.045] result() for ClusterFuture ...
[18:01:07.045] - result already collected: FutureResult
[18:01:07.045] result() for ClusterFuture ... done
[18:01:07.046] result() for ClusterFuture ...
[18:01:07.046] - result already collected: FutureResult
[18:01:07.046] result() for ClusterFuture ... done
[18:01:07.046] result() for ClusterFuture ...
[18:01:07.046] - result already collected: FutureResult
[18:01:07.047] result() for ClusterFuture ... done
[18:01:07.047]  - Number of value chunks collected: 5
[18:01:07.047] Resolving 5 futures (chunks) ... DONE
[18:01:07.047] Reducing values from 5 chunks ...
[18:01:07.047]  - Number of values collected after concatenation: 5
[18:01:07.047]  - Number of values expected: 5
[18:01:07.048] Reducing values from 5 chunks ... DONE
[18:01:07.048] future_mapply() ... DONE
[18:01:07.048] future_mapply() ...
[18:01:07.055] Number of chunks: 2
[18:01:07.055] getGlobalsAndPackagesXApply() ...
[18:01:07.055]  - future.globals: TRUE
[18:01:07.055] getGlobalsAndPackages() ...
[18:01:07.056] Searching for globals...
[18:01:07.059] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:07.059] Searching for globals ... DONE
[18:01:07.059] Resolving globals: FALSE
[18:01:07.060] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:07.061] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:07.061] - globals: [1] ‘FUN’
[18:01:07.061] 
[18:01:07.061] getGlobalsAndPackages() ... DONE
[18:01:07.062]  - globals found/used: [n=1] ‘FUN’
[18:01:07.062]  - needed namespaces: [n=0] 
[18:01:07.062] Finding globals ... DONE
[18:01:07.062] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:07.063] List of 2
[18:01:07.063]  $ ...future.FUN:function (C, k)  
[18:01:07.063]  $ MoreArgs     : list()
[18:01:07.063]  - attr(*, "where")=List of 2
[18:01:07.063]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:07.063]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:07.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:07.063]  - attr(*, "resolved")= logi FALSE
[18:01:07.063]  - attr(*, "total_size")= num NA
[18:01:07.068] Packages to be attached in all futures: [n=0] 
[18:01:07.068] getGlobalsAndPackagesXApply() ... DONE
[18:01:07.069] Number of futures (= number of chunks): 2
[18:01:07.069] Launching 2 futures (chunks) ...
[18:01:07.069] Chunk #1 of 2 ...
[18:01:07.069]  - Finding globals in '...' for chunk #1 ...
[18:01:07.070] getGlobalsAndPackages() ...
[18:01:07.070] Searching for globals...
[18:01:07.071] 
[18:01:07.071] Searching for globals ... DONE
[18:01:07.071] - globals: [0] <none>
[18:01:07.071] getGlobalsAndPackages() ... DONE
[18:01:07.071]    + additional globals found: [n=0] 
[18:01:07.072]    + additional namespaces needed: [n=0] 
[18:01:07.072]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:07.072]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.072]  - seeds: <none>
[18:01:07.072]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.073] getGlobalsAndPackages() ...
[18:01:07.073] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.073] Resolving globals: FALSE
[18:01:07.074] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:07.075] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:07.076] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.076] 
[18:01:07.076] getGlobalsAndPackages() ... DONE
[18:01:07.077] run() for ‘Future’ ...
[18:01:07.077] - state: ‘created’
[18:01:07.077] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.101]   - Field: ‘node’
[18:01:07.101]   - Field: ‘label’
[18:01:07.101]   - Field: ‘local’
[18:01:07.102]   - Field: ‘owner’
[18:01:07.102]   - Field: ‘envir’
[18:01:07.102]   - Field: ‘workers’
[18:01:07.102]   - Field: ‘packages’
[18:01:07.102]   - Field: ‘gc’
[18:01:07.103]   - Field: ‘conditions’
[18:01:07.103]   - Field: ‘persistent’
[18:01:07.103]   - Field: ‘expr’
[18:01:07.103]   - Field: ‘uuid’
[18:01:07.103]   - Field: ‘seed’
[18:01:07.104]   - Field: ‘version’
[18:01:07.104]   - Field: ‘result’
[18:01:07.104]   - Field: ‘asynchronous’
[18:01:07.104]   - Field: ‘calls’
[18:01:07.104]   - Field: ‘globals’
[18:01:07.105]   - Field: ‘stdout’
[18:01:07.105]   - Field: ‘earlySignal’
[18:01:07.105]   - Field: ‘lazy’
[18:01:07.105]   - Field: ‘state’
[18:01:07.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.105] - Launch lazy future ...
[18:01:07.106] Packages needed by the future expression (n = 0): <none>
[18:01:07.106] Packages needed by future strategies (n = 0): <none>
[18:01:07.108] {
[18:01:07.108]     {
[18:01:07.108]         {
[18:01:07.108]             ...future.startTime <- base::Sys.time()
[18:01:07.108]             {
[18:01:07.108]                 {
[18:01:07.108]                   {
[18:01:07.108]                     {
[18:01:07.108]                       base::local({
[18:01:07.108]                         has_future <- base::requireNamespace("future", 
[18:01:07.108]                           quietly = TRUE)
[18:01:07.108]                         if (has_future) {
[18:01:07.108]                           ns <- base::getNamespace("future")
[18:01:07.108]                           version <- ns[[".package"]][["version"]]
[18:01:07.108]                           if (is.null(version)) 
[18:01:07.108]                             version <- utils::packageVersion("future")
[18:01:07.108]                         }
[18:01:07.108]                         else {
[18:01:07.108]                           version <- NULL
[18:01:07.108]                         }
[18:01:07.108]                         if (!has_future || version < "1.8.0") {
[18:01:07.108]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.108]                             "", base::R.version$version.string), 
[18:01:07.108]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.108]                               "release", "version")], collapse = " "), 
[18:01:07.108]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.108]                             info)
[18:01:07.108]                           info <- base::paste(info, collapse = "; ")
[18:01:07.108]                           if (!has_future) {
[18:01:07.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.108]                               info)
[18:01:07.108]                           }
[18:01:07.108]                           else {
[18:01:07.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.108]                               info, version)
[18:01:07.108]                           }
[18:01:07.108]                           base::stop(msg)
[18:01:07.108]                         }
[18:01:07.108]                       })
[18:01:07.108]                     }
[18:01:07.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.108]                     base::options(mc.cores = 1L)
[18:01:07.108]                   }
[18:01:07.108]                   ...future.strategy.old <- future::plan("list")
[18:01:07.108]                   options(future.plan = NULL)
[18:01:07.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.108]                 }
[18:01:07.108]                 ...future.workdir <- getwd()
[18:01:07.108]             }
[18:01:07.108]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.108]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.108]         }
[18:01:07.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.108]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.108]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.108]             base::names(...future.oldOptions))
[18:01:07.108]     }
[18:01:07.108]     if (FALSE) {
[18:01:07.108]     }
[18:01:07.108]     else {
[18:01:07.108]         if (TRUE) {
[18:01:07.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.108]                 open = "w")
[18:01:07.108]         }
[18:01:07.108]         else {
[18:01:07.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.108]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.108]         }
[18:01:07.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.108]             base::sink(type = "output", split = FALSE)
[18:01:07.108]             base::close(...future.stdout)
[18:01:07.108]         }, add = TRUE)
[18:01:07.108]     }
[18:01:07.108]     ...future.frame <- base::sys.nframe()
[18:01:07.108]     ...future.conditions <- base::list()
[18:01:07.108]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.108]     if (FALSE) {
[18:01:07.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.108]     }
[18:01:07.108]     ...future.result <- base::tryCatch({
[18:01:07.108]         base::withCallingHandlers({
[18:01:07.108]             ...future.value <- base::withVisible(base::local({
[18:01:07.108]                 ...future.makeSendCondition <- base::local({
[18:01:07.108]                   sendCondition <- NULL
[18:01:07.108]                   function(frame = 1L) {
[18:01:07.108]                     if (is.function(sendCondition)) 
[18:01:07.108]                       return(sendCondition)
[18:01:07.108]                     ns <- getNamespace("parallel")
[18:01:07.108]                     if (exists("sendData", mode = "function", 
[18:01:07.108]                       envir = ns)) {
[18:01:07.108]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.108]                         envir = ns)
[18:01:07.108]                       envir <- sys.frame(frame)
[18:01:07.108]                       master <- NULL
[18:01:07.108]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.108]                         !identical(envir, emptyenv())) {
[18:01:07.108]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.108]                           inherits = FALSE)) {
[18:01:07.108]                           master <- get("master", mode = "list", 
[18:01:07.108]                             envir = envir, inherits = FALSE)
[18:01:07.108]                           if (inherits(master, c("SOCKnode", 
[18:01:07.108]                             "SOCK0node"))) {
[18:01:07.108]                             sendCondition <<- function(cond) {
[18:01:07.108]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.108]                                 success = TRUE)
[18:01:07.108]                               parallel_sendData(master, data)
[18:01:07.108]                             }
[18:01:07.108]                             return(sendCondition)
[18:01:07.108]                           }
[18:01:07.108]                         }
[18:01:07.108]                         frame <- frame + 1L
[18:01:07.108]                         envir <- sys.frame(frame)
[18:01:07.108]                       }
[18:01:07.108]                     }
[18:01:07.108]                     sendCondition <<- function(cond) NULL
[18:01:07.108]                   }
[18:01:07.108]                 })
[18:01:07.108]                 withCallingHandlers({
[18:01:07.108]                   {
[18:01:07.108]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.108]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.108]                       ...future.globals.maxSize)) {
[18:01:07.108]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.108]                       on.exit(options(oopts), add = TRUE)
[18:01:07.108]                     }
[18:01:07.108]                     {
[18:01:07.108]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.108]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.108]                         USE.NAMES = FALSE)
[18:01:07.108]                       do.call(mapply, args = args)
[18:01:07.108]                     }
[18:01:07.108]                   }
[18:01:07.108]                 }, immediateCondition = function(cond) {
[18:01:07.108]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.108]                   sendCondition(cond)
[18:01:07.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.108]                   {
[18:01:07.108]                     inherits <- base::inherits
[18:01:07.108]                     invokeRestart <- base::invokeRestart
[18:01:07.108]                     is.null <- base::is.null
[18:01:07.108]                     muffled <- FALSE
[18:01:07.108]                     if (inherits(cond, "message")) {
[18:01:07.108]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.108]                       if (muffled) 
[18:01:07.108]                         invokeRestart("muffleMessage")
[18:01:07.108]                     }
[18:01:07.108]                     else if (inherits(cond, "warning")) {
[18:01:07.108]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.108]                       if (muffled) 
[18:01:07.108]                         invokeRestart("muffleWarning")
[18:01:07.108]                     }
[18:01:07.108]                     else if (inherits(cond, "condition")) {
[18:01:07.108]                       if (!is.null(pattern)) {
[18:01:07.108]                         computeRestarts <- base::computeRestarts
[18:01:07.108]                         grepl <- base::grepl
[18:01:07.108]                         restarts <- computeRestarts(cond)
[18:01:07.108]                         for (restart in restarts) {
[18:01:07.108]                           name <- restart$name
[18:01:07.108]                           if (is.null(name)) 
[18:01:07.108]                             next
[18:01:07.108]                           if (!grepl(pattern, name)) 
[18:01:07.108]                             next
[18:01:07.108]                           invokeRestart(restart)
[18:01:07.108]                           muffled <- TRUE
[18:01:07.108]                           break
[18:01:07.108]                         }
[18:01:07.108]                       }
[18:01:07.108]                     }
[18:01:07.108]                     invisible(muffled)
[18:01:07.108]                   }
[18:01:07.108]                   muffleCondition(cond)
[18:01:07.108]                 })
[18:01:07.108]             }))
[18:01:07.108]             future::FutureResult(value = ...future.value$value, 
[18:01:07.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.108]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.108]                     ...future.globalenv.names))
[18:01:07.108]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.108]         }, condition = base::local({
[18:01:07.108]             c <- base::c
[18:01:07.108]             inherits <- base::inherits
[18:01:07.108]             invokeRestart <- base::invokeRestart
[18:01:07.108]             length <- base::length
[18:01:07.108]             list <- base::list
[18:01:07.108]             seq.int <- base::seq.int
[18:01:07.108]             signalCondition <- base::signalCondition
[18:01:07.108]             sys.calls <- base::sys.calls
[18:01:07.108]             `[[` <- base::`[[`
[18:01:07.108]             `+` <- base::`+`
[18:01:07.108]             `<<-` <- base::`<<-`
[18:01:07.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.108]                   3L)]
[18:01:07.108]             }
[18:01:07.108]             function(cond) {
[18:01:07.108]                 is_error <- inherits(cond, "error")
[18:01:07.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.108]                   NULL)
[18:01:07.108]                 if (is_error) {
[18:01:07.108]                   sessionInformation <- function() {
[18:01:07.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.108]                       search = base::search(), system = base::Sys.info())
[18:01:07.108]                   }
[18:01:07.108]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.108]                     cond$call), session = sessionInformation(), 
[18:01:07.108]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.108]                   signalCondition(cond)
[18:01:07.108]                 }
[18:01:07.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.108]                 "immediateCondition"))) {
[18:01:07.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.108]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.108]                   if (TRUE && !signal) {
[18:01:07.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.108]                     {
[18:01:07.108]                       inherits <- base::inherits
[18:01:07.108]                       invokeRestart <- base::invokeRestart
[18:01:07.108]                       is.null <- base::is.null
[18:01:07.108]                       muffled <- FALSE
[18:01:07.108]                       if (inherits(cond, "message")) {
[18:01:07.108]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.108]                         if (muffled) 
[18:01:07.108]                           invokeRestart("muffleMessage")
[18:01:07.108]                       }
[18:01:07.108]                       else if (inherits(cond, "warning")) {
[18:01:07.108]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.108]                         if (muffled) 
[18:01:07.108]                           invokeRestart("muffleWarning")
[18:01:07.108]                       }
[18:01:07.108]                       else if (inherits(cond, "condition")) {
[18:01:07.108]                         if (!is.null(pattern)) {
[18:01:07.108]                           computeRestarts <- base::computeRestarts
[18:01:07.108]                           grepl <- base::grepl
[18:01:07.108]                           restarts <- computeRestarts(cond)
[18:01:07.108]                           for (restart in restarts) {
[18:01:07.108]                             name <- restart$name
[18:01:07.108]                             if (is.null(name)) 
[18:01:07.108]                               next
[18:01:07.108]                             if (!grepl(pattern, name)) 
[18:01:07.108]                               next
[18:01:07.108]                             invokeRestart(restart)
[18:01:07.108]                             muffled <- TRUE
[18:01:07.108]                             break
[18:01:07.108]                           }
[18:01:07.108]                         }
[18:01:07.108]                       }
[18:01:07.108]                       invisible(muffled)
[18:01:07.108]                     }
[18:01:07.108]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.108]                   }
[18:01:07.108]                 }
[18:01:07.108]                 else {
[18:01:07.108]                   if (TRUE) {
[18:01:07.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.108]                     {
[18:01:07.108]                       inherits <- base::inherits
[18:01:07.108]                       invokeRestart <- base::invokeRestart
[18:01:07.108]                       is.null <- base::is.null
[18:01:07.108]                       muffled <- FALSE
[18:01:07.108]                       if (inherits(cond, "message")) {
[18:01:07.108]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.108]                         if (muffled) 
[18:01:07.108]                           invokeRestart("muffleMessage")
[18:01:07.108]                       }
[18:01:07.108]                       else if (inherits(cond, "warning")) {
[18:01:07.108]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.108]                         if (muffled) 
[18:01:07.108]                           invokeRestart("muffleWarning")
[18:01:07.108]                       }
[18:01:07.108]                       else if (inherits(cond, "condition")) {
[18:01:07.108]                         if (!is.null(pattern)) {
[18:01:07.108]                           computeRestarts <- base::computeRestarts
[18:01:07.108]                           grepl <- base::grepl
[18:01:07.108]                           restarts <- computeRestarts(cond)
[18:01:07.108]                           for (restart in restarts) {
[18:01:07.108]                             name <- restart$name
[18:01:07.108]                             if (is.null(name)) 
[18:01:07.108]                               next
[18:01:07.108]                             if (!grepl(pattern, name)) 
[18:01:07.108]                               next
[18:01:07.108]                             invokeRestart(restart)
[18:01:07.108]                             muffled <- TRUE
[18:01:07.108]                             break
[18:01:07.108]                           }
[18:01:07.108]                         }
[18:01:07.108]                       }
[18:01:07.108]                       invisible(muffled)
[18:01:07.108]                     }
[18:01:07.108]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.108]                   }
[18:01:07.108]                 }
[18:01:07.108]             }
[18:01:07.108]         }))
[18:01:07.108]     }, error = function(ex) {
[18:01:07.108]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.108]                 ...future.rng), started = ...future.startTime, 
[18:01:07.108]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.108]             version = "1.8"), class = "FutureResult")
[18:01:07.108]     }, finally = {
[18:01:07.108]         if (!identical(...future.workdir, getwd())) 
[18:01:07.108]             setwd(...future.workdir)
[18:01:07.108]         {
[18:01:07.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.108]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.108]             }
[18:01:07.108]             base::options(...future.oldOptions)
[18:01:07.108]             if (.Platform$OS.type == "windows") {
[18:01:07.108]                 old_names <- names(...future.oldEnvVars)
[18:01:07.108]                 envs <- base::Sys.getenv()
[18:01:07.108]                 names <- names(envs)
[18:01:07.108]                 common <- intersect(names, old_names)
[18:01:07.108]                 added <- setdiff(names, old_names)
[18:01:07.108]                 removed <- setdiff(old_names, names)
[18:01:07.108]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.108]                   envs[common]]
[18:01:07.108]                 NAMES <- toupper(changed)
[18:01:07.108]                 args <- list()
[18:01:07.108]                 for (kk in seq_along(NAMES)) {
[18:01:07.108]                   name <- changed[[kk]]
[18:01:07.108]                   NAME <- NAMES[[kk]]
[18:01:07.108]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.108]                     next
[18:01:07.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.108]                 }
[18:01:07.108]                 NAMES <- toupper(added)
[18:01:07.108]                 for (kk in seq_along(NAMES)) {
[18:01:07.108]                   name <- added[[kk]]
[18:01:07.108]                   NAME <- NAMES[[kk]]
[18:01:07.108]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.108]                     next
[18:01:07.108]                   args[[name]] <- ""
[18:01:07.108]                 }
[18:01:07.108]                 NAMES <- toupper(removed)
[18:01:07.108]                 for (kk in seq_along(NAMES)) {
[18:01:07.108]                   name <- removed[[kk]]
[18:01:07.108]                   NAME <- NAMES[[kk]]
[18:01:07.108]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.108]                     next
[18:01:07.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.108]                 }
[18:01:07.108]                 if (length(args) > 0) 
[18:01:07.108]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.108]             }
[18:01:07.108]             else {
[18:01:07.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.108]             }
[18:01:07.108]             {
[18:01:07.108]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.108]                   0L) {
[18:01:07.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.108]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.108]                   base::options(opts)
[18:01:07.108]                 }
[18:01:07.108]                 {
[18:01:07.108]                   {
[18:01:07.108]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.108]                     NULL
[18:01:07.108]                   }
[18:01:07.108]                   options(future.plan = NULL)
[18:01:07.108]                   if (is.na(NA_character_)) 
[18:01:07.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.108]                     .init = FALSE)
[18:01:07.108]                 }
[18:01:07.108]             }
[18:01:07.108]         }
[18:01:07.108]     })
[18:01:07.108]     if (TRUE) {
[18:01:07.108]         base::sink(type = "output", split = FALSE)
[18:01:07.108]         if (TRUE) {
[18:01:07.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.108]         }
[18:01:07.108]         else {
[18:01:07.108]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.108]         }
[18:01:07.108]         base::close(...future.stdout)
[18:01:07.108]         ...future.stdout <- NULL
[18:01:07.108]     }
[18:01:07.108]     ...future.result$conditions <- ...future.conditions
[18:01:07.108]     ...future.result$finished <- base::Sys.time()
[18:01:07.108]     ...future.result
[18:01:07.108] }
[18:01:07.113] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[18:01:07.113] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:07.114] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:07.115] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:07.115] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.116] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[18:01:07.117] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[18:01:07.117] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:07.118] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:07.119] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.119] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[18:01:07.120] MultisessionFuture started
[18:01:07.121] - Launch lazy future ... done
[18:01:07.122] run() for ‘MultisessionFuture’ ... done
[18:01:07.122] Created future:
[18:01:07.122] MultisessionFuture:
[18:01:07.122] Label: ‘future_.mapply-1’
[18:01:07.122] Expression:
[18:01:07.122] {
[18:01:07.122]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.122]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.122]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.122]         on.exit(options(oopts), add = TRUE)
[18:01:07.122]     }
[18:01:07.122]     {
[18:01:07.122]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.122]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.122]         do.call(mapply, args = args)
[18:01:07.122]     }
[18:01:07.122] }
[18:01:07.122] Lazy evaluation: FALSE
[18:01:07.122] Asynchronous evaluation: TRUE
[18:01:07.122] Local evaluation: TRUE
[18:01:07.122] Environment: R_GlobalEnv
[18:01:07.122] Capture standard output: TRUE
[18:01:07.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.122] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.122] Packages: <none>
[18:01:07.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.122] Resolved: FALSE
[18:01:07.122] Value: <not collected>
[18:01:07.122] Conditions captured: <none>
[18:01:07.122] Early signaling: FALSE
[18:01:07.122] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.122] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.135] Chunk #1 of 2 ... DONE
[18:01:07.135] Chunk #2 of 2 ...
[18:01:07.136]  - Finding globals in '...' for chunk #2 ...
[18:01:07.136] getGlobalsAndPackages() ...
[18:01:07.136] Searching for globals...
[18:01:07.137] 
[18:01:07.137] Searching for globals ... DONE
[18:01:07.137] - globals: [0] <none>
[18:01:07.137] getGlobalsAndPackages() ... DONE
[18:01:07.138]    + additional globals found: [n=0] 
[18:01:07.138]    + additional namespaces needed: [n=0] 
[18:01:07.138]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:07.138]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.138]  - seeds: <none>
[18:01:07.139]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.139] getGlobalsAndPackages() ...
[18:01:07.139] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.139] Resolving globals: FALSE
[18:01:07.140] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:07.141] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:07.141] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.142] 
[18:01:07.142] getGlobalsAndPackages() ... DONE
[18:01:07.142] run() for ‘Future’ ...
[18:01:07.143] - state: ‘created’
[18:01:07.143] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.168] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.169]   - Field: ‘node’
[18:01:07.169]   - Field: ‘label’
[18:01:07.169]   - Field: ‘local’
[18:01:07.169]   - Field: ‘owner’
[18:01:07.170]   - Field: ‘envir’
[18:01:07.170]   - Field: ‘workers’
[18:01:07.170]   - Field: ‘packages’
[18:01:07.170]   - Field: ‘gc’
[18:01:07.170]   - Field: ‘conditions’
[18:01:07.171]   - Field: ‘persistent’
[18:01:07.171]   - Field: ‘expr’
[18:01:07.171]   - Field: ‘uuid’
[18:01:07.171]   - Field: ‘seed’
[18:01:07.171]   - Field: ‘version’
[18:01:07.171]   - Field: ‘result’
[18:01:07.172]   - Field: ‘asynchronous’
[18:01:07.172]   - Field: ‘calls’
[18:01:07.172]   - Field: ‘globals’
[18:01:07.172]   - Field: ‘stdout’
[18:01:07.172]   - Field: ‘earlySignal’
[18:01:07.173]   - Field: ‘lazy’
[18:01:07.173]   - Field: ‘state’
[18:01:07.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.173] - Launch lazy future ...
[18:01:07.174] Packages needed by the future expression (n = 0): <none>
[18:01:07.174] Packages needed by future strategies (n = 0): <none>
[18:01:07.175] {
[18:01:07.175]     {
[18:01:07.175]         {
[18:01:07.175]             ...future.startTime <- base::Sys.time()
[18:01:07.175]             {
[18:01:07.175]                 {
[18:01:07.175]                   {
[18:01:07.175]                     {
[18:01:07.175]                       base::local({
[18:01:07.175]                         has_future <- base::requireNamespace("future", 
[18:01:07.175]                           quietly = TRUE)
[18:01:07.175]                         if (has_future) {
[18:01:07.175]                           ns <- base::getNamespace("future")
[18:01:07.175]                           version <- ns[[".package"]][["version"]]
[18:01:07.175]                           if (is.null(version)) 
[18:01:07.175]                             version <- utils::packageVersion("future")
[18:01:07.175]                         }
[18:01:07.175]                         else {
[18:01:07.175]                           version <- NULL
[18:01:07.175]                         }
[18:01:07.175]                         if (!has_future || version < "1.8.0") {
[18:01:07.175]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.175]                             "", base::R.version$version.string), 
[18:01:07.175]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.175]                               "release", "version")], collapse = " "), 
[18:01:07.175]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.175]                             info)
[18:01:07.175]                           info <- base::paste(info, collapse = "; ")
[18:01:07.175]                           if (!has_future) {
[18:01:07.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.175]                               info)
[18:01:07.175]                           }
[18:01:07.175]                           else {
[18:01:07.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.175]                               info, version)
[18:01:07.175]                           }
[18:01:07.175]                           base::stop(msg)
[18:01:07.175]                         }
[18:01:07.175]                       })
[18:01:07.175]                     }
[18:01:07.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.175]                     base::options(mc.cores = 1L)
[18:01:07.175]                   }
[18:01:07.175]                   ...future.strategy.old <- future::plan("list")
[18:01:07.175]                   options(future.plan = NULL)
[18:01:07.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.175]                 }
[18:01:07.175]                 ...future.workdir <- getwd()
[18:01:07.175]             }
[18:01:07.175]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.175]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.175]         }
[18:01:07.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.175]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.175]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.175]             base::names(...future.oldOptions))
[18:01:07.175]     }
[18:01:07.175]     if (FALSE) {
[18:01:07.175]     }
[18:01:07.175]     else {
[18:01:07.175]         if (TRUE) {
[18:01:07.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.175]                 open = "w")
[18:01:07.175]         }
[18:01:07.175]         else {
[18:01:07.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.175]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.175]         }
[18:01:07.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.175]             base::sink(type = "output", split = FALSE)
[18:01:07.175]             base::close(...future.stdout)
[18:01:07.175]         }, add = TRUE)
[18:01:07.175]     }
[18:01:07.175]     ...future.frame <- base::sys.nframe()
[18:01:07.175]     ...future.conditions <- base::list()
[18:01:07.175]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.175]     if (FALSE) {
[18:01:07.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.175]     }
[18:01:07.175]     ...future.result <- base::tryCatch({
[18:01:07.175]         base::withCallingHandlers({
[18:01:07.175]             ...future.value <- base::withVisible(base::local({
[18:01:07.175]                 ...future.makeSendCondition <- base::local({
[18:01:07.175]                   sendCondition <- NULL
[18:01:07.175]                   function(frame = 1L) {
[18:01:07.175]                     if (is.function(sendCondition)) 
[18:01:07.175]                       return(sendCondition)
[18:01:07.175]                     ns <- getNamespace("parallel")
[18:01:07.175]                     if (exists("sendData", mode = "function", 
[18:01:07.175]                       envir = ns)) {
[18:01:07.175]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.175]                         envir = ns)
[18:01:07.175]                       envir <- sys.frame(frame)
[18:01:07.175]                       master <- NULL
[18:01:07.175]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.175]                         !identical(envir, emptyenv())) {
[18:01:07.175]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.175]                           inherits = FALSE)) {
[18:01:07.175]                           master <- get("master", mode = "list", 
[18:01:07.175]                             envir = envir, inherits = FALSE)
[18:01:07.175]                           if (inherits(master, c("SOCKnode", 
[18:01:07.175]                             "SOCK0node"))) {
[18:01:07.175]                             sendCondition <<- function(cond) {
[18:01:07.175]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.175]                                 success = TRUE)
[18:01:07.175]                               parallel_sendData(master, data)
[18:01:07.175]                             }
[18:01:07.175]                             return(sendCondition)
[18:01:07.175]                           }
[18:01:07.175]                         }
[18:01:07.175]                         frame <- frame + 1L
[18:01:07.175]                         envir <- sys.frame(frame)
[18:01:07.175]                       }
[18:01:07.175]                     }
[18:01:07.175]                     sendCondition <<- function(cond) NULL
[18:01:07.175]                   }
[18:01:07.175]                 })
[18:01:07.175]                 withCallingHandlers({
[18:01:07.175]                   {
[18:01:07.175]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.175]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.175]                       ...future.globals.maxSize)) {
[18:01:07.175]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.175]                       on.exit(options(oopts), add = TRUE)
[18:01:07.175]                     }
[18:01:07.175]                     {
[18:01:07.175]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.175]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.175]                         USE.NAMES = FALSE)
[18:01:07.175]                       do.call(mapply, args = args)
[18:01:07.175]                     }
[18:01:07.175]                   }
[18:01:07.175]                 }, immediateCondition = function(cond) {
[18:01:07.175]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.175]                   sendCondition(cond)
[18:01:07.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.175]                   {
[18:01:07.175]                     inherits <- base::inherits
[18:01:07.175]                     invokeRestart <- base::invokeRestart
[18:01:07.175]                     is.null <- base::is.null
[18:01:07.175]                     muffled <- FALSE
[18:01:07.175]                     if (inherits(cond, "message")) {
[18:01:07.175]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.175]                       if (muffled) 
[18:01:07.175]                         invokeRestart("muffleMessage")
[18:01:07.175]                     }
[18:01:07.175]                     else if (inherits(cond, "warning")) {
[18:01:07.175]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.175]                       if (muffled) 
[18:01:07.175]                         invokeRestart("muffleWarning")
[18:01:07.175]                     }
[18:01:07.175]                     else if (inherits(cond, "condition")) {
[18:01:07.175]                       if (!is.null(pattern)) {
[18:01:07.175]                         computeRestarts <- base::computeRestarts
[18:01:07.175]                         grepl <- base::grepl
[18:01:07.175]                         restarts <- computeRestarts(cond)
[18:01:07.175]                         for (restart in restarts) {
[18:01:07.175]                           name <- restart$name
[18:01:07.175]                           if (is.null(name)) 
[18:01:07.175]                             next
[18:01:07.175]                           if (!grepl(pattern, name)) 
[18:01:07.175]                             next
[18:01:07.175]                           invokeRestart(restart)
[18:01:07.175]                           muffled <- TRUE
[18:01:07.175]                           break
[18:01:07.175]                         }
[18:01:07.175]                       }
[18:01:07.175]                     }
[18:01:07.175]                     invisible(muffled)
[18:01:07.175]                   }
[18:01:07.175]                   muffleCondition(cond)
[18:01:07.175]                 })
[18:01:07.175]             }))
[18:01:07.175]             future::FutureResult(value = ...future.value$value, 
[18:01:07.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.175]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.175]                     ...future.globalenv.names))
[18:01:07.175]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.175]         }, condition = base::local({
[18:01:07.175]             c <- base::c
[18:01:07.175]             inherits <- base::inherits
[18:01:07.175]             invokeRestart <- base::invokeRestart
[18:01:07.175]             length <- base::length
[18:01:07.175]             list <- base::list
[18:01:07.175]             seq.int <- base::seq.int
[18:01:07.175]             signalCondition <- base::signalCondition
[18:01:07.175]             sys.calls <- base::sys.calls
[18:01:07.175]             `[[` <- base::`[[`
[18:01:07.175]             `+` <- base::`+`
[18:01:07.175]             `<<-` <- base::`<<-`
[18:01:07.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.175]                   3L)]
[18:01:07.175]             }
[18:01:07.175]             function(cond) {
[18:01:07.175]                 is_error <- inherits(cond, "error")
[18:01:07.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.175]                   NULL)
[18:01:07.175]                 if (is_error) {
[18:01:07.175]                   sessionInformation <- function() {
[18:01:07.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.175]                       search = base::search(), system = base::Sys.info())
[18:01:07.175]                   }
[18:01:07.175]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.175]                     cond$call), session = sessionInformation(), 
[18:01:07.175]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.175]                   signalCondition(cond)
[18:01:07.175]                 }
[18:01:07.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.175]                 "immediateCondition"))) {
[18:01:07.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.175]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.175]                   if (TRUE && !signal) {
[18:01:07.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.175]                     {
[18:01:07.175]                       inherits <- base::inherits
[18:01:07.175]                       invokeRestart <- base::invokeRestart
[18:01:07.175]                       is.null <- base::is.null
[18:01:07.175]                       muffled <- FALSE
[18:01:07.175]                       if (inherits(cond, "message")) {
[18:01:07.175]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.175]                         if (muffled) 
[18:01:07.175]                           invokeRestart("muffleMessage")
[18:01:07.175]                       }
[18:01:07.175]                       else if (inherits(cond, "warning")) {
[18:01:07.175]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.175]                         if (muffled) 
[18:01:07.175]                           invokeRestart("muffleWarning")
[18:01:07.175]                       }
[18:01:07.175]                       else if (inherits(cond, "condition")) {
[18:01:07.175]                         if (!is.null(pattern)) {
[18:01:07.175]                           computeRestarts <- base::computeRestarts
[18:01:07.175]                           grepl <- base::grepl
[18:01:07.175]                           restarts <- computeRestarts(cond)
[18:01:07.175]                           for (restart in restarts) {
[18:01:07.175]                             name <- restart$name
[18:01:07.175]                             if (is.null(name)) 
[18:01:07.175]                               next
[18:01:07.175]                             if (!grepl(pattern, name)) 
[18:01:07.175]                               next
[18:01:07.175]                             invokeRestart(restart)
[18:01:07.175]                             muffled <- TRUE
[18:01:07.175]                             break
[18:01:07.175]                           }
[18:01:07.175]                         }
[18:01:07.175]                       }
[18:01:07.175]                       invisible(muffled)
[18:01:07.175]                     }
[18:01:07.175]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.175]                   }
[18:01:07.175]                 }
[18:01:07.175]                 else {
[18:01:07.175]                   if (TRUE) {
[18:01:07.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.175]                     {
[18:01:07.175]                       inherits <- base::inherits
[18:01:07.175]                       invokeRestart <- base::invokeRestart
[18:01:07.175]                       is.null <- base::is.null
[18:01:07.175]                       muffled <- FALSE
[18:01:07.175]                       if (inherits(cond, "message")) {
[18:01:07.175]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.175]                         if (muffled) 
[18:01:07.175]                           invokeRestart("muffleMessage")
[18:01:07.175]                       }
[18:01:07.175]                       else if (inherits(cond, "warning")) {
[18:01:07.175]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.175]                         if (muffled) 
[18:01:07.175]                           invokeRestart("muffleWarning")
[18:01:07.175]                       }
[18:01:07.175]                       else if (inherits(cond, "condition")) {
[18:01:07.175]                         if (!is.null(pattern)) {
[18:01:07.175]                           computeRestarts <- base::computeRestarts
[18:01:07.175]                           grepl <- base::grepl
[18:01:07.175]                           restarts <- computeRestarts(cond)
[18:01:07.175]                           for (restart in restarts) {
[18:01:07.175]                             name <- restart$name
[18:01:07.175]                             if (is.null(name)) 
[18:01:07.175]                               next
[18:01:07.175]                             if (!grepl(pattern, name)) 
[18:01:07.175]                               next
[18:01:07.175]                             invokeRestart(restart)
[18:01:07.175]                             muffled <- TRUE
[18:01:07.175]                             break
[18:01:07.175]                           }
[18:01:07.175]                         }
[18:01:07.175]                       }
[18:01:07.175]                       invisible(muffled)
[18:01:07.175]                     }
[18:01:07.175]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.175]                   }
[18:01:07.175]                 }
[18:01:07.175]             }
[18:01:07.175]         }))
[18:01:07.175]     }, error = function(ex) {
[18:01:07.175]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.175]                 ...future.rng), started = ...future.startTime, 
[18:01:07.175]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.175]             version = "1.8"), class = "FutureResult")
[18:01:07.175]     }, finally = {
[18:01:07.175]         if (!identical(...future.workdir, getwd())) 
[18:01:07.175]             setwd(...future.workdir)
[18:01:07.175]         {
[18:01:07.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.175]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.175]             }
[18:01:07.175]             base::options(...future.oldOptions)
[18:01:07.175]             if (.Platform$OS.type == "windows") {
[18:01:07.175]                 old_names <- names(...future.oldEnvVars)
[18:01:07.175]                 envs <- base::Sys.getenv()
[18:01:07.175]                 names <- names(envs)
[18:01:07.175]                 common <- intersect(names, old_names)
[18:01:07.175]                 added <- setdiff(names, old_names)
[18:01:07.175]                 removed <- setdiff(old_names, names)
[18:01:07.175]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.175]                   envs[common]]
[18:01:07.175]                 NAMES <- toupper(changed)
[18:01:07.175]                 args <- list()
[18:01:07.175]                 for (kk in seq_along(NAMES)) {
[18:01:07.175]                   name <- changed[[kk]]
[18:01:07.175]                   NAME <- NAMES[[kk]]
[18:01:07.175]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.175]                     next
[18:01:07.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.175]                 }
[18:01:07.175]                 NAMES <- toupper(added)
[18:01:07.175]                 for (kk in seq_along(NAMES)) {
[18:01:07.175]                   name <- added[[kk]]
[18:01:07.175]                   NAME <- NAMES[[kk]]
[18:01:07.175]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.175]                     next
[18:01:07.175]                   args[[name]] <- ""
[18:01:07.175]                 }
[18:01:07.175]                 NAMES <- toupper(removed)
[18:01:07.175]                 for (kk in seq_along(NAMES)) {
[18:01:07.175]                   name <- removed[[kk]]
[18:01:07.175]                   NAME <- NAMES[[kk]]
[18:01:07.175]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.175]                     next
[18:01:07.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.175]                 }
[18:01:07.175]                 if (length(args) > 0) 
[18:01:07.175]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.175]             }
[18:01:07.175]             else {
[18:01:07.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.175]             }
[18:01:07.175]             {
[18:01:07.175]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.175]                   0L) {
[18:01:07.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.175]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.175]                   base::options(opts)
[18:01:07.175]                 }
[18:01:07.175]                 {
[18:01:07.175]                   {
[18:01:07.175]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.175]                     NULL
[18:01:07.175]                   }
[18:01:07.175]                   options(future.plan = NULL)
[18:01:07.175]                   if (is.na(NA_character_)) 
[18:01:07.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.175]                     .init = FALSE)
[18:01:07.175]                 }
[18:01:07.175]             }
[18:01:07.175]         }
[18:01:07.175]     })
[18:01:07.175]     if (TRUE) {
[18:01:07.175]         base::sink(type = "output", split = FALSE)
[18:01:07.175]         if (TRUE) {
[18:01:07.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.175]         }
[18:01:07.175]         else {
[18:01:07.175]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.175]         }
[18:01:07.175]         base::close(...future.stdout)
[18:01:07.175]         ...future.stdout <- NULL
[18:01:07.175]     }
[18:01:07.175]     ...future.result$conditions <- ...future.conditions
[18:01:07.175]     ...future.result$finished <- base::Sys.time()
[18:01:07.175]     ...future.result
[18:01:07.175] }
[18:01:07.180] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[18:01:07.180] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:07.181] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:07.181] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:07.182] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.183] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[18:01:07.183] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[18:01:07.184] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:07.184] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.185] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:07.185] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.186] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[18:01:07.187] MultisessionFuture started
[18:01:07.187] - Launch lazy future ... done
[18:01:07.187] run() for ‘MultisessionFuture’ ... done
[18:01:07.187] Created future:
[18:01:07.188] MultisessionFuture:
[18:01:07.188] Label: ‘future_.mapply-2’
[18:01:07.188] Expression:
[18:01:07.188] {
[18:01:07.188]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.188]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.188]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.188]         on.exit(options(oopts), add = TRUE)
[18:01:07.188]     }
[18:01:07.188]     {
[18:01:07.188]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.188]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.188]         do.call(mapply, args = args)
[18:01:07.188]     }
[18:01:07.188] }
[18:01:07.188] Lazy evaluation: FALSE
[18:01:07.188] Asynchronous evaluation: TRUE
[18:01:07.188] Local evaluation: TRUE
[18:01:07.188] Environment: R_GlobalEnv
[18:01:07.188] Capture standard output: TRUE
[18:01:07.188] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.188] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.188] Packages: <none>
[18:01:07.188] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.188] Resolved: FALSE
[18:01:07.188] Value: <not collected>
[18:01:07.188] Conditions captured: <none>
[18:01:07.188] Early signaling: FALSE
[18:01:07.188] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.188] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.200] Chunk #2 of 2 ... DONE
[18:01:07.200] Launching 2 futures (chunks) ... DONE
[18:01:07.201] Resolving 2 futures (chunks) ...
[18:01:07.201] resolve() on list ...
[18:01:07.201]  recursive: 0
[18:01:07.201]  length: 2
[18:01:07.201] 
[18:01:07.202] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.203] - Validating connection of MultisessionFuture
[18:01:07.203] - received message: FutureResult
[18:01:07.203] - Received FutureResult
[18:01:07.203] - Erased future from FutureRegistry
[18:01:07.203] result() for ClusterFuture ...
[18:01:07.204] - result already collected: FutureResult
[18:01:07.204] result() for ClusterFuture ... done
[18:01:07.204] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.204] Future #1
[18:01:07.204] result() for ClusterFuture ...
[18:01:07.205] - result already collected: FutureResult
[18:01:07.205] result() for ClusterFuture ... done
[18:01:07.205] result() for ClusterFuture ...
[18:01:07.205] - result already collected: FutureResult
[18:01:07.205] result() for ClusterFuture ... done
[18:01:07.205] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:07.206] - nx: 2
[18:01:07.206] - relay: TRUE
[18:01:07.206] - stdout: TRUE
[18:01:07.206] - signal: TRUE
[18:01:07.206] - resignal: FALSE
[18:01:07.207] - force: TRUE
[18:01:07.207] - relayed: [n=2] FALSE, FALSE
[18:01:07.207] - queued futures: [n=2] FALSE, FALSE
[18:01:07.207]  - until=1
[18:01:07.207]  - relaying element #1
[18:01:07.207] result() for ClusterFuture ...
[18:01:07.208] - result already collected: FutureResult
[18:01:07.208] result() for ClusterFuture ... done
[18:01:07.208] result() for ClusterFuture ...
[18:01:07.208] - result already collected: FutureResult
[18:01:07.208] result() for ClusterFuture ... done
[18:01:07.209] result() for ClusterFuture ...
[18:01:07.209] - result already collected: FutureResult
[18:01:07.209] result() for ClusterFuture ... done
[18:01:07.209] result() for ClusterFuture ...
[18:01:07.209] - result already collected: FutureResult
[18:01:07.209] result() for ClusterFuture ... done
[18:01:07.210] - relayed: [n=2] TRUE, FALSE
[18:01:07.210] - queued futures: [n=2] TRUE, FALSE
[18:01:07.210] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:07.210]  length: 1 (resolved future 1)
[18:01:07.232] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.233] - Validating connection of MultisessionFuture
[18:01:07.233] - received message: FutureResult
[18:01:07.233] - Received FutureResult
[18:01:07.233] - Erased future from FutureRegistry
[18:01:07.234] result() for ClusterFuture ...
[18:01:07.234] - result already collected: FutureResult
[18:01:07.234] result() for ClusterFuture ... done
[18:01:07.234] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.234] Future #2
[18:01:07.234] result() for ClusterFuture ...
[18:01:07.235] - result already collected: FutureResult
[18:01:07.235] result() for ClusterFuture ... done
[18:01:07.235] result() for ClusterFuture ...
[18:01:07.235] - result already collected: FutureResult
[18:01:07.235] result() for ClusterFuture ... done
[18:01:07.236] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:07.236] - nx: 2
[18:01:07.236] - relay: TRUE
[18:01:07.236] - stdout: TRUE
[18:01:07.236] - signal: TRUE
[18:01:07.236] - resignal: FALSE
[18:01:07.237] - force: TRUE
[18:01:07.237] - relayed: [n=2] TRUE, FALSE
[18:01:07.237] - queued futures: [n=2] TRUE, FALSE
[18:01:07.237]  - until=2
[18:01:07.237]  - relaying element #2
[18:01:07.238] result() for ClusterFuture ...
[18:01:07.238] - result already collected: FutureResult
[18:01:07.238] result() for ClusterFuture ... done
[18:01:07.238] result() for ClusterFuture ...
[18:01:07.238] - result already collected: FutureResult
[18:01:07.238] result() for ClusterFuture ... done
[18:01:07.239] result() for ClusterFuture ...
[18:01:07.239] - result already collected: FutureResult
[18:01:07.239] result() for ClusterFuture ... done
[18:01:07.239] result() for ClusterFuture ...
[18:01:07.239] - result already collected: FutureResult
[18:01:07.240] result() for ClusterFuture ... done
[18:01:07.240] - relayed: [n=2] TRUE, TRUE
[18:01:07.240] - queued futures: [n=2] TRUE, TRUE
[18:01:07.240] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:07.240]  length: 0 (resolved future 2)
[18:01:07.241] Relaying remaining futures
[18:01:07.241] signalConditionsASAP(NULL, pos=0) ...
[18:01:07.241] - nx: 2
[18:01:07.241] - relay: TRUE
[18:01:07.241] - stdout: TRUE
[18:01:07.241] - signal: TRUE
[18:01:07.242] - resignal: FALSE
[18:01:07.242] - force: TRUE
[18:01:07.242] - relayed: [n=2] TRUE, TRUE
[18:01:07.242] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:07.242] - relayed: [n=2] TRUE, TRUE
[18:01:07.243] - queued futures: [n=2] TRUE, TRUE
[18:01:07.243] signalConditionsASAP(NULL, pos=0) ... done
[18:01:07.243] resolve() on list ... DONE
[18:01:07.243] result() for ClusterFuture ...
[18:01:07.243] - result already collected: FutureResult
[18:01:07.243] result() for ClusterFuture ... done
[18:01:07.244] result() for ClusterFuture ...
[18:01:07.244] - result already collected: FutureResult
[18:01:07.244] result() for ClusterFuture ... done
[18:01:07.244] result() for ClusterFuture ...
[18:01:07.244] - result already collected: FutureResult
[18:01:07.245] result() for ClusterFuture ... done
[18:01:07.245] result() for ClusterFuture ...
[18:01:07.245] - result already collected: FutureResult
[18:01:07.245] result() for ClusterFuture ... done
[18:01:07.245]  - Number of value chunks collected: 2
[18:01:07.245] Resolving 2 futures (chunks) ... DONE
[18:01:07.246] Reducing values from 2 chunks ...
[18:01:07.246]  - Number of values collected after concatenation: 5
[18:01:07.246]  - Number of values expected: 5
[18:01:07.246] Reducing values from 2 chunks ... DONE
[18:01:07.246] future_mapply() ... DONE
[18:01:07.247] future_mapply() ...
[18:01:07.253] Number of chunks: 3
[18:01:07.253] Index remapping (attribute 'ordering'): [n = 5] 2, 5, 4, 1, 3
[18:01:07.253] getGlobalsAndPackagesXApply() ...
[18:01:07.254]  - future.globals: TRUE
[18:01:07.254] getGlobalsAndPackages() ...
[18:01:07.254] Searching for globals...
[18:01:07.256] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:07.257] Searching for globals ... DONE
[18:01:07.257] Resolving globals: FALSE
[18:01:07.258] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:07.258] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:07.258] - globals: [1] ‘FUN’
[18:01:07.259] 
[18:01:07.259] getGlobalsAndPackages() ... DONE
[18:01:07.259]  - globals found/used: [n=1] ‘FUN’
[18:01:07.259]  - needed namespaces: [n=0] 
[18:01:07.259] Finding globals ... DONE
[18:01:07.260] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:07.260] List of 2
[18:01:07.260]  $ ...future.FUN:function (C, k)  
[18:01:07.260]  $ MoreArgs     : NULL
[18:01:07.260]  - attr(*, "where")=List of 2
[18:01:07.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:07.260]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:07.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:07.260]  - attr(*, "resolved")= logi FALSE
[18:01:07.260]  - attr(*, "total_size")= num NA
[18:01:07.265] Packages to be attached in all futures: [n=0] 
[18:01:07.265] getGlobalsAndPackagesXApply() ... DONE
[18:01:07.265] Number of futures (= number of chunks): 3
[18:01:07.266] Launching 3 futures (chunks) ...
[18:01:07.266] Chunk #1 of 3 ...
[18:01:07.266]  - Finding globals in '...' for chunk #1 ...
[18:01:07.266] getGlobalsAndPackages() ...
[18:01:07.266] Searching for globals...
[18:01:07.267] 
[18:01:07.267] Searching for globals ... DONE
[18:01:07.267] - globals: [0] <none>
[18:01:07.268] getGlobalsAndPackages() ... DONE
[18:01:07.268]    + additional globals found: [n=0] 
[18:01:07.268]    + additional namespaces needed: [n=0] 
[18:01:07.268]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:07.268]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:01:07.268]  - seeds: <none>
[18:01:07.269]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.269] getGlobalsAndPackages() ...
[18:01:07.269] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.269] Resolving globals: FALSE
[18:01:07.270] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:07.271] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:07.271] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.272] 
[18:01:07.272] getGlobalsAndPackages() ... DONE
[18:01:07.272] run() for ‘Future’ ...
[18:01:07.272] - state: ‘created’
[18:01:07.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.295]   - Field: ‘node’
[18:01:07.296]   - Field: ‘label’
[18:01:07.296]   - Field: ‘local’
[18:01:07.296]   - Field: ‘owner’
[18:01:07.296]   - Field: ‘envir’
[18:01:07.296]   - Field: ‘workers’
[18:01:07.297]   - Field: ‘packages’
[18:01:07.297]   - Field: ‘gc’
[18:01:07.297]   - Field: ‘conditions’
[18:01:07.297]   - Field: ‘persistent’
[18:01:07.297]   - Field: ‘expr’
[18:01:07.298]   - Field: ‘uuid’
[18:01:07.298]   - Field: ‘seed’
[18:01:07.298]   - Field: ‘version’
[18:01:07.298]   - Field: ‘result’
[18:01:07.298]   - Field: ‘asynchronous’
[18:01:07.298]   - Field: ‘calls’
[18:01:07.299]   - Field: ‘globals’
[18:01:07.299]   - Field: ‘stdout’
[18:01:07.299]   - Field: ‘earlySignal’
[18:01:07.299]   - Field: ‘lazy’
[18:01:07.299]   - Field: ‘state’
[18:01:07.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.300] - Launch lazy future ...
[18:01:07.300] Packages needed by the future expression (n = 0): <none>
[18:01:07.301] Packages needed by future strategies (n = 0): <none>
[18:01:07.302] {
[18:01:07.302]     {
[18:01:07.302]         {
[18:01:07.302]             ...future.startTime <- base::Sys.time()
[18:01:07.302]             {
[18:01:07.302]                 {
[18:01:07.302]                   {
[18:01:07.302]                     {
[18:01:07.302]                       base::local({
[18:01:07.302]                         has_future <- base::requireNamespace("future", 
[18:01:07.302]                           quietly = TRUE)
[18:01:07.302]                         if (has_future) {
[18:01:07.302]                           ns <- base::getNamespace("future")
[18:01:07.302]                           version <- ns[[".package"]][["version"]]
[18:01:07.302]                           if (is.null(version)) 
[18:01:07.302]                             version <- utils::packageVersion("future")
[18:01:07.302]                         }
[18:01:07.302]                         else {
[18:01:07.302]                           version <- NULL
[18:01:07.302]                         }
[18:01:07.302]                         if (!has_future || version < "1.8.0") {
[18:01:07.302]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.302]                             "", base::R.version$version.string), 
[18:01:07.302]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.302]                               "release", "version")], collapse = " "), 
[18:01:07.302]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.302]                             info)
[18:01:07.302]                           info <- base::paste(info, collapse = "; ")
[18:01:07.302]                           if (!has_future) {
[18:01:07.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.302]                               info)
[18:01:07.302]                           }
[18:01:07.302]                           else {
[18:01:07.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.302]                               info, version)
[18:01:07.302]                           }
[18:01:07.302]                           base::stop(msg)
[18:01:07.302]                         }
[18:01:07.302]                       })
[18:01:07.302]                     }
[18:01:07.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.302]                     base::options(mc.cores = 1L)
[18:01:07.302]                   }
[18:01:07.302]                   ...future.strategy.old <- future::plan("list")
[18:01:07.302]                   options(future.plan = NULL)
[18:01:07.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.302]                 }
[18:01:07.302]                 ...future.workdir <- getwd()
[18:01:07.302]             }
[18:01:07.302]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.302]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.302]         }
[18:01:07.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.302]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:01:07.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.302]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.302]             base::names(...future.oldOptions))
[18:01:07.302]     }
[18:01:07.302]     if (FALSE) {
[18:01:07.302]     }
[18:01:07.302]     else {
[18:01:07.302]         if (TRUE) {
[18:01:07.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.302]                 open = "w")
[18:01:07.302]         }
[18:01:07.302]         else {
[18:01:07.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.302]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.302]         }
[18:01:07.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.302]             base::sink(type = "output", split = FALSE)
[18:01:07.302]             base::close(...future.stdout)
[18:01:07.302]         }, add = TRUE)
[18:01:07.302]     }
[18:01:07.302]     ...future.frame <- base::sys.nframe()
[18:01:07.302]     ...future.conditions <- base::list()
[18:01:07.302]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.302]     if (FALSE) {
[18:01:07.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.302]     }
[18:01:07.302]     ...future.result <- base::tryCatch({
[18:01:07.302]         base::withCallingHandlers({
[18:01:07.302]             ...future.value <- base::withVisible(base::local({
[18:01:07.302]                 ...future.makeSendCondition <- base::local({
[18:01:07.302]                   sendCondition <- NULL
[18:01:07.302]                   function(frame = 1L) {
[18:01:07.302]                     if (is.function(sendCondition)) 
[18:01:07.302]                       return(sendCondition)
[18:01:07.302]                     ns <- getNamespace("parallel")
[18:01:07.302]                     if (exists("sendData", mode = "function", 
[18:01:07.302]                       envir = ns)) {
[18:01:07.302]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.302]                         envir = ns)
[18:01:07.302]                       envir <- sys.frame(frame)
[18:01:07.302]                       master <- NULL
[18:01:07.302]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.302]                         !identical(envir, emptyenv())) {
[18:01:07.302]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.302]                           inherits = FALSE)) {
[18:01:07.302]                           master <- get("master", mode = "list", 
[18:01:07.302]                             envir = envir, inherits = FALSE)
[18:01:07.302]                           if (inherits(master, c("SOCKnode", 
[18:01:07.302]                             "SOCK0node"))) {
[18:01:07.302]                             sendCondition <<- function(cond) {
[18:01:07.302]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.302]                                 success = TRUE)
[18:01:07.302]                               parallel_sendData(master, data)
[18:01:07.302]                             }
[18:01:07.302]                             return(sendCondition)
[18:01:07.302]                           }
[18:01:07.302]                         }
[18:01:07.302]                         frame <- frame + 1L
[18:01:07.302]                         envir <- sys.frame(frame)
[18:01:07.302]                       }
[18:01:07.302]                     }
[18:01:07.302]                     sendCondition <<- function(cond) NULL
[18:01:07.302]                   }
[18:01:07.302]                 })
[18:01:07.302]                 withCallingHandlers({
[18:01:07.302]                   {
[18:01:07.302]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.302]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.302]                       ...future.globals.maxSize)) {
[18:01:07.302]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.302]                       on.exit(options(oopts), add = TRUE)
[18:01:07.302]                     }
[18:01:07.302]                     {
[18:01:07.302]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.302]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.302]                         USE.NAMES = FALSE)
[18:01:07.302]                       do.call(mapply, args = args)
[18:01:07.302]                     }
[18:01:07.302]                   }
[18:01:07.302]                 }, immediateCondition = function(cond) {
[18:01:07.302]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.302]                   sendCondition(cond)
[18:01:07.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.302]                   {
[18:01:07.302]                     inherits <- base::inherits
[18:01:07.302]                     invokeRestart <- base::invokeRestart
[18:01:07.302]                     is.null <- base::is.null
[18:01:07.302]                     muffled <- FALSE
[18:01:07.302]                     if (inherits(cond, "message")) {
[18:01:07.302]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.302]                       if (muffled) 
[18:01:07.302]                         invokeRestart("muffleMessage")
[18:01:07.302]                     }
[18:01:07.302]                     else if (inherits(cond, "warning")) {
[18:01:07.302]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.302]                       if (muffled) 
[18:01:07.302]                         invokeRestart("muffleWarning")
[18:01:07.302]                     }
[18:01:07.302]                     else if (inherits(cond, "condition")) {
[18:01:07.302]                       if (!is.null(pattern)) {
[18:01:07.302]                         computeRestarts <- base::computeRestarts
[18:01:07.302]                         grepl <- base::grepl
[18:01:07.302]                         restarts <- computeRestarts(cond)
[18:01:07.302]                         for (restart in restarts) {
[18:01:07.302]                           name <- restart$name
[18:01:07.302]                           if (is.null(name)) 
[18:01:07.302]                             next
[18:01:07.302]                           if (!grepl(pattern, name)) 
[18:01:07.302]                             next
[18:01:07.302]                           invokeRestart(restart)
[18:01:07.302]                           muffled <- TRUE
[18:01:07.302]                           break
[18:01:07.302]                         }
[18:01:07.302]                       }
[18:01:07.302]                     }
[18:01:07.302]                     invisible(muffled)
[18:01:07.302]                   }
[18:01:07.302]                   muffleCondition(cond)
[18:01:07.302]                 })
[18:01:07.302]             }))
[18:01:07.302]             future::FutureResult(value = ...future.value$value, 
[18:01:07.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.302]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.302]                     ...future.globalenv.names))
[18:01:07.302]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.302]         }, condition = base::local({
[18:01:07.302]             c <- base::c
[18:01:07.302]             inherits <- base::inherits
[18:01:07.302]             invokeRestart <- base::invokeRestart
[18:01:07.302]             length <- base::length
[18:01:07.302]             list <- base::list
[18:01:07.302]             seq.int <- base::seq.int
[18:01:07.302]             signalCondition <- base::signalCondition
[18:01:07.302]             sys.calls <- base::sys.calls
[18:01:07.302]             `[[` <- base::`[[`
[18:01:07.302]             `+` <- base::`+`
[18:01:07.302]             `<<-` <- base::`<<-`
[18:01:07.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.302]                   3L)]
[18:01:07.302]             }
[18:01:07.302]             function(cond) {
[18:01:07.302]                 is_error <- inherits(cond, "error")
[18:01:07.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.302]                   NULL)
[18:01:07.302]                 if (is_error) {
[18:01:07.302]                   sessionInformation <- function() {
[18:01:07.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.302]                       search = base::search(), system = base::Sys.info())
[18:01:07.302]                   }
[18:01:07.302]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.302]                     cond$call), session = sessionInformation(), 
[18:01:07.302]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.302]                   signalCondition(cond)
[18:01:07.302]                 }
[18:01:07.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.302]                 "immediateCondition"))) {
[18:01:07.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.302]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.302]                   if (TRUE && !signal) {
[18:01:07.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.302]                     {
[18:01:07.302]                       inherits <- base::inherits
[18:01:07.302]                       invokeRestart <- base::invokeRestart
[18:01:07.302]                       is.null <- base::is.null
[18:01:07.302]                       muffled <- FALSE
[18:01:07.302]                       if (inherits(cond, "message")) {
[18:01:07.302]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.302]                         if (muffled) 
[18:01:07.302]                           invokeRestart("muffleMessage")
[18:01:07.302]                       }
[18:01:07.302]                       else if (inherits(cond, "warning")) {
[18:01:07.302]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.302]                         if (muffled) 
[18:01:07.302]                           invokeRestart("muffleWarning")
[18:01:07.302]                       }
[18:01:07.302]                       else if (inherits(cond, "condition")) {
[18:01:07.302]                         if (!is.null(pattern)) {
[18:01:07.302]                           computeRestarts <- base::computeRestarts
[18:01:07.302]                           grepl <- base::grepl
[18:01:07.302]                           restarts <- computeRestarts(cond)
[18:01:07.302]                           for (restart in restarts) {
[18:01:07.302]                             name <- restart$name
[18:01:07.302]                             if (is.null(name)) 
[18:01:07.302]                               next
[18:01:07.302]                             if (!grepl(pattern, name)) 
[18:01:07.302]                               next
[18:01:07.302]                             invokeRestart(restart)
[18:01:07.302]                             muffled <- TRUE
[18:01:07.302]                             break
[18:01:07.302]                           }
[18:01:07.302]                         }
[18:01:07.302]                       }
[18:01:07.302]                       invisible(muffled)
[18:01:07.302]                     }
[18:01:07.302]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.302]                   }
[18:01:07.302]                 }
[18:01:07.302]                 else {
[18:01:07.302]                   if (TRUE) {
[18:01:07.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.302]                     {
[18:01:07.302]                       inherits <- base::inherits
[18:01:07.302]                       invokeRestart <- base::invokeRestart
[18:01:07.302]                       is.null <- base::is.null
[18:01:07.302]                       muffled <- FALSE
[18:01:07.302]                       if (inherits(cond, "message")) {
[18:01:07.302]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.302]                         if (muffled) 
[18:01:07.302]                           invokeRestart("muffleMessage")
[18:01:07.302]                       }
[18:01:07.302]                       else if (inherits(cond, "warning")) {
[18:01:07.302]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.302]                         if (muffled) 
[18:01:07.302]                           invokeRestart("muffleWarning")
[18:01:07.302]                       }
[18:01:07.302]                       else if (inherits(cond, "condition")) {
[18:01:07.302]                         if (!is.null(pattern)) {
[18:01:07.302]                           computeRestarts <- base::computeRestarts
[18:01:07.302]                           grepl <- base::grepl
[18:01:07.302]                           restarts <- computeRestarts(cond)
[18:01:07.302]                           for (restart in restarts) {
[18:01:07.302]                             name <- restart$name
[18:01:07.302]                             if (is.null(name)) 
[18:01:07.302]                               next
[18:01:07.302]                             if (!grepl(pattern, name)) 
[18:01:07.302]                               next
[18:01:07.302]                             invokeRestart(restart)
[18:01:07.302]                             muffled <- TRUE
[18:01:07.302]                             break
[18:01:07.302]                           }
[18:01:07.302]                         }
[18:01:07.302]                       }
[18:01:07.302]                       invisible(muffled)
[18:01:07.302]                     }
[18:01:07.302]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.302]                   }
[18:01:07.302]                 }
[18:01:07.302]             }
[18:01:07.302]         }))
[18:01:07.302]     }, error = function(ex) {
[18:01:07.302]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.302]                 ...future.rng), started = ...future.startTime, 
[18:01:07.302]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.302]             version = "1.8"), class = "FutureResult")
[18:01:07.302]     }, finally = {
[18:01:07.302]         if (!identical(...future.workdir, getwd())) 
[18:01:07.302]             setwd(...future.workdir)
[18:01:07.302]         {
[18:01:07.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.302]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.302]             }
[18:01:07.302]             base::options(...future.oldOptions)
[18:01:07.302]             if (.Platform$OS.type == "windows") {
[18:01:07.302]                 old_names <- names(...future.oldEnvVars)
[18:01:07.302]                 envs <- base::Sys.getenv()
[18:01:07.302]                 names <- names(envs)
[18:01:07.302]                 common <- intersect(names, old_names)
[18:01:07.302]                 added <- setdiff(names, old_names)
[18:01:07.302]                 removed <- setdiff(old_names, names)
[18:01:07.302]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.302]                   envs[common]]
[18:01:07.302]                 NAMES <- toupper(changed)
[18:01:07.302]                 args <- list()
[18:01:07.302]                 for (kk in seq_along(NAMES)) {
[18:01:07.302]                   name <- changed[[kk]]
[18:01:07.302]                   NAME <- NAMES[[kk]]
[18:01:07.302]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.302]                     next
[18:01:07.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.302]                 }
[18:01:07.302]                 NAMES <- toupper(added)
[18:01:07.302]                 for (kk in seq_along(NAMES)) {
[18:01:07.302]                   name <- added[[kk]]
[18:01:07.302]                   NAME <- NAMES[[kk]]
[18:01:07.302]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.302]                     next
[18:01:07.302]                   args[[name]] <- ""
[18:01:07.302]                 }
[18:01:07.302]                 NAMES <- toupper(removed)
[18:01:07.302]                 for (kk in seq_along(NAMES)) {
[18:01:07.302]                   name <- removed[[kk]]
[18:01:07.302]                   NAME <- NAMES[[kk]]
[18:01:07.302]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.302]                     next
[18:01:07.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.302]                 }
[18:01:07.302]                 if (length(args) > 0) 
[18:01:07.302]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.302]             }
[18:01:07.302]             else {
[18:01:07.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.302]             }
[18:01:07.302]             {
[18:01:07.302]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.302]                   0L) {
[18:01:07.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.302]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.302]                   base::options(opts)
[18:01:07.302]                 }
[18:01:07.302]                 {
[18:01:07.302]                   {
[18:01:07.302]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.302]                     NULL
[18:01:07.302]                   }
[18:01:07.302]                   options(future.plan = NULL)
[18:01:07.302]                   if (is.na(NA_character_)) 
[18:01:07.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.302]                     .init = FALSE)
[18:01:07.302]                 }
[18:01:07.302]             }
[18:01:07.302]         }
[18:01:07.302]     })
[18:01:07.302]     if (TRUE) {
[18:01:07.302]         base::sink(type = "output", split = FALSE)
[18:01:07.302]         if (TRUE) {
[18:01:07.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.302]         }
[18:01:07.302]         else {
[18:01:07.302]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.302]         }
[18:01:07.302]         base::close(...future.stdout)
[18:01:07.302]         ...future.stdout <- NULL
[18:01:07.302]     }
[18:01:07.302]     ...future.result$conditions <- ...future.conditions
[18:01:07.302]     ...future.result$finished <- base::Sys.time()
[18:01:07.302]     ...future.result
[18:01:07.302] }
[18:01:07.307] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[18:01:07.307] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:07.308] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:07.308] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:07.309] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.310] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[18:01:07.310] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[18:01:07.311] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:07.312] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.312] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:07.313] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.313] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[18:01:07.314] MultisessionFuture started
[18:01:07.314] - Launch lazy future ... done
[18:01:07.314] run() for ‘MultisessionFuture’ ... done
[18:01:07.314] Created future:
[18:01:07.315] MultisessionFuture:
[18:01:07.315] Label: ‘future_mapply-1’
[18:01:07.315] Expression:
[18:01:07.315] {
[18:01:07.315]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.315]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.315]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.315]         on.exit(options(oopts), add = TRUE)
[18:01:07.315]     }
[18:01:07.315]     {
[18:01:07.315]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.315]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.315]         do.call(mapply, args = args)
[18:01:07.315]     }
[18:01:07.315] }
[18:01:07.315] Lazy evaluation: FALSE
[18:01:07.315] Asynchronous evaluation: TRUE
[18:01:07.315] Local evaluation: TRUE
[18:01:07.315] Environment: R_GlobalEnv
[18:01:07.315] Capture standard output: TRUE
[18:01:07.315] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.315] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.315] Packages: <none>
[18:01:07.315] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.315] Resolved: FALSE
[18:01:07.315] Value: <not collected>
[18:01:07.315] Conditions captured: <none>
[18:01:07.315] Early signaling: FALSE
[18:01:07.315] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.315] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.327] Chunk #1 of 3 ... DONE
[18:01:07.327] Chunk #2 of 3 ...
[18:01:07.328]  - Finding globals in '...' for chunk #2 ...
[18:01:07.328] getGlobalsAndPackages() ...
[18:01:07.328] Searching for globals...
[18:01:07.329] 
[18:01:07.329] Searching for globals ... DONE
[18:01:07.329] - globals: [0] <none>
[18:01:07.329] getGlobalsAndPackages() ... DONE
[18:01:07.330]    + additional globals found: [n=0] 
[18:01:07.330]    + additional namespaces needed: [n=0] 
[18:01:07.330]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:07.330]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:01:07.330]  - seeds: <none>
[18:01:07.330]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.331] getGlobalsAndPackages() ...
[18:01:07.331] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.331] Resolving globals: FALSE
[18:01:07.332] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[18:01:07.333] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:07.333] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.333] 
[18:01:07.334] getGlobalsAndPackages() ... DONE
[18:01:07.334] run() for ‘Future’ ...
[18:01:07.334] - state: ‘created’
[18:01:07.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.363] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.363]   - Field: ‘node’
[18:01:07.364]   - Field: ‘label’
[18:01:07.364]   - Field: ‘local’
[18:01:07.364]   - Field: ‘owner’
[18:01:07.364]   - Field: ‘envir’
[18:01:07.365]   - Field: ‘workers’
[18:01:07.365]   - Field: ‘packages’
[18:01:07.365]   - Field: ‘gc’
[18:01:07.365]   - Field: ‘conditions’
[18:01:07.365]   - Field: ‘persistent’
[18:01:07.366]   - Field: ‘expr’
[18:01:07.366]   - Field: ‘uuid’
[18:01:07.366]   - Field: ‘seed’
[18:01:07.366]   - Field: ‘version’
[18:01:07.366]   - Field: ‘result’
[18:01:07.366]   - Field: ‘asynchronous’
[18:01:07.367]   - Field: ‘calls’
[18:01:07.367]   - Field: ‘globals’
[18:01:07.367]   - Field: ‘stdout’
[18:01:07.367]   - Field: ‘earlySignal’
[18:01:07.368]   - Field: ‘lazy’
[18:01:07.368]   - Field: ‘state’
[18:01:07.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.368] - Launch lazy future ...
[18:01:07.369] Packages needed by the future expression (n = 0): <none>
[18:01:07.369] Packages needed by future strategies (n = 0): <none>
[18:01:07.370] {
[18:01:07.370]     {
[18:01:07.370]         {
[18:01:07.370]             ...future.startTime <- base::Sys.time()
[18:01:07.370]             {
[18:01:07.370]                 {
[18:01:07.370]                   {
[18:01:07.370]                     {
[18:01:07.370]                       base::local({
[18:01:07.370]                         has_future <- base::requireNamespace("future", 
[18:01:07.370]                           quietly = TRUE)
[18:01:07.370]                         if (has_future) {
[18:01:07.370]                           ns <- base::getNamespace("future")
[18:01:07.370]                           version <- ns[[".package"]][["version"]]
[18:01:07.370]                           if (is.null(version)) 
[18:01:07.370]                             version <- utils::packageVersion("future")
[18:01:07.370]                         }
[18:01:07.370]                         else {
[18:01:07.370]                           version <- NULL
[18:01:07.370]                         }
[18:01:07.370]                         if (!has_future || version < "1.8.0") {
[18:01:07.370]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.370]                             "", base::R.version$version.string), 
[18:01:07.370]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.370]                               "release", "version")], collapse = " "), 
[18:01:07.370]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.370]                             info)
[18:01:07.370]                           info <- base::paste(info, collapse = "; ")
[18:01:07.370]                           if (!has_future) {
[18:01:07.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.370]                               info)
[18:01:07.370]                           }
[18:01:07.370]                           else {
[18:01:07.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.370]                               info, version)
[18:01:07.370]                           }
[18:01:07.370]                           base::stop(msg)
[18:01:07.370]                         }
[18:01:07.370]                       })
[18:01:07.370]                     }
[18:01:07.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.370]                     base::options(mc.cores = 1L)
[18:01:07.370]                   }
[18:01:07.370]                   ...future.strategy.old <- future::plan("list")
[18:01:07.370]                   options(future.plan = NULL)
[18:01:07.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.370]                 }
[18:01:07.370]                 ...future.workdir <- getwd()
[18:01:07.370]             }
[18:01:07.370]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.370]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.370]         }
[18:01:07.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.370]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:01:07.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.370]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.370]             base::names(...future.oldOptions))
[18:01:07.370]     }
[18:01:07.370]     if (FALSE) {
[18:01:07.370]     }
[18:01:07.370]     else {
[18:01:07.370]         if (TRUE) {
[18:01:07.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.370]                 open = "w")
[18:01:07.370]         }
[18:01:07.370]         else {
[18:01:07.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.370]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.370]         }
[18:01:07.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.370]             base::sink(type = "output", split = FALSE)
[18:01:07.370]             base::close(...future.stdout)
[18:01:07.370]         }, add = TRUE)
[18:01:07.370]     }
[18:01:07.370]     ...future.frame <- base::sys.nframe()
[18:01:07.370]     ...future.conditions <- base::list()
[18:01:07.370]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.370]     if (FALSE) {
[18:01:07.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.370]     }
[18:01:07.370]     ...future.result <- base::tryCatch({
[18:01:07.370]         base::withCallingHandlers({
[18:01:07.370]             ...future.value <- base::withVisible(base::local({
[18:01:07.370]                 ...future.makeSendCondition <- base::local({
[18:01:07.370]                   sendCondition <- NULL
[18:01:07.370]                   function(frame = 1L) {
[18:01:07.370]                     if (is.function(sendCondition)) 
[18:01:07.370]                       return(sendCondition)
[18:01:07.370]                     ns <- getNamespace("parallel")
[18:01:07.370]                     if (exists("sendData", mode = "function", 
[18:01:07.370]                       envir = ns)) {
[18:01:07.370]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.370]                         envir = ns)
[18:01:07.370]                       envir <- sys.frame(frame)
[18:01:07.370]                       master <- NULL
[18:01:07.370]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.370]                         !identical(envir, emptyenv())) {
[18:01:07.370]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.370]                           inherits = FALSE)) {
[18:01:07.370]                           master <- get("master", mode = "list", 
[18:01:07.370]                             envir = envir, inherits = FALSE)
[18:01:07.370]                           if (inherits(master, c("SOCKnode", 
[18:01:07.370]                             "SOCK0node"))) {
[18:01:07.370]                             sendCondition <<- function(cond) {
[18:01:07.370]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.370]                                 success = TRUE)
[18:01:07.370]                               parallel_sendData(master, data)
[18:01:07.370]                             }
[18:01:07.370]                             return(sendCondition)
[18:01:07.370]                           }
[18:01:07.370]                         }
[18:01:07.370]                         frame <- frame + 1L
[18:01:07.370]                         envir <- sys.frame(frame)
[18:01:07.370]                       }
[18:01:07.370]                     }
[18:01:07.370]                     sendCondition <<- function(cond) NULL
[18:01:07.370]                   }
[18:01:07.370]                 })
[18:01:07.370]                 withCallingHandlers({
[18:01:07.370]                   {
[18:01:07.370]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.370]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.370]                       ...future.globals.maxSize)) {
[18:01:07.370]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.370]                       on.exit(options(oopts), add = TRUE)
[18:01:07.370]                     }
[18:01:07.370]                     {
[18:01:07.370]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.370]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.370]                         USE.NAMES = FALSE)
[18:01:07.370]                       do.call(mapply, args = args)
[18:01:07.370]                     }
[18:01:07.370]                   }
[18:01:07.370]                 }, immediateCondition = function(cond) {
[18:01:07.370]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.370]                   sendCondition(cond)
[18:01:07.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.370]                   {
[18:01:07.370]                     inherits <- base::inherits
[18:01:07.370]                     invokeRestart <- base::invokeRestart
[18:01:07.370]                     is.null <- base::is.null
[18:01:07.370]                     muffled <- FALSE
[18:01:07.370]                     if (inherits(cond, "message")) {
[18:01:07.370]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.370]                       if (muffled) 
[18:01:07.370]                         invokeRestart("muffleMessage")
[18:01:07.370]                     }
[18:01:07.370]                     else if (inherits(cond, "warning")) {
[18:01:07.370]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.370]                       if (muffled) 
[18:01:07.370]                         invokeRestart("muffleWarning")
[18:01:07.370]                     }
[18:01:07.370]                     else if (inherits(cond, "condition")) {
[18:01:07.370]                       if (!is.null(pattern)) {
[18:01:07.370]                         computeRestarts <- base::computeRestarts
[18:01:07.370]                         grepl <- base::grepl
[18:01:07.370]                         restarts <- computeRestarts(cond)
[18:01:07.370]                         for (restart in restarts) {
[18:01:07.370]                           name <- restart$name
[18:01:07.370]                           if (is.null(name)) 
[18:01:07.370]                             next
[18:01:07.370]                           if (!grepl(pattern, name)) 
[18:01:07.370]                             next
[18:01:07.370]                           invokeRestart(restart)
[18:01:07.370]                           muffled <- TRUE
[18:01:07.370]                           break
[18:01:07.370]                         }
[18:01:07.370]                       }
[18:01:07.370]                     }
[18:01:07.370]                     invisible(muffled)
[18:01:07.370]                   }
[18:01:07.370]                   muffleCondition(cond)
[18:01:07.370]                 })
[18:01:07.370]             }))
[18:01:07.370]             future::FutureResult(value = ...future.value$value, 
[18:01:07.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.370]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.370]                     ...future.globalenv.names))
[18:01:07.370]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.370]         }, condition = base::local({
[18:01:07.370]             c <- base::c
[18:01:07.370]             inherits <- base::inherits
[18:01:07.370]             invokeRestart <- base::invokeRestart
[18:01:07.370]             length <- base::length
[18:01:07.370]             list <- base::list
[18:01:07.370]             seq.int <- base::seq.int
[18:01:07.370]             signalCondition <- base::signalCondition
[18:01:07.370]             sys.calls <- base::sys.calls
[18:01:07.370]             `[[` <- base::`[[`
[18:01:07.370]             `+` <- base::`+`
[18:01:07.370]             `<<-` <- base::`<<-`
[18:01:07.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.370]                   3L)]
[18:01:07.370]             }
[18:01:07.370]             function(cond) {
[18:01:07.370]                 is_error <- inherits(cond, "error")
[18:01:07.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.370]                   NULL)
[18:01:07.370]                 if (is_error) {
[18:01:07.370]                   sessionInformation <- function() {
[18:01:07.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.370]                       search = base::search(), system = base::Sys.info())
[18:01:07.370]                   }
[18:01:07.370]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.370]                     cond$call), session = sessionInformation(), 
[18:01:07.370]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.370]                   signalCondition(cond)
[18:01:07.370]                 }
[18:01:07.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.370]                 "immediateCondition"))) {
[18:01:07.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.370]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.370]                   if (TRUE && !signal) {
[18:01:07.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.370]                     {
[18:01:07.370]                       inherits <- base::inherits
[18:01:07.370]                       invokeRestart <- base::invokeRestart
[18:01:07.370]                       is.null <- base::is.null
[18:01:07.370]                       muffled <- FALSE
[18:01:07.370]                       if (inherits(cond, "message")) {
[18:01:07.370]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.370]                         if (muffled) 
[18:01:07.370]                           invokeRestart("muffleMessage")
[18:01:07.370]                       }
[18:01:07.370]                       else if (inherits(cond, "warning")) {
[18:01:07.370]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.370]                         if (muffled) 
[18:01:07.370]                           invokeRestart("muffleWarning")
[18:01:07.370]                       }
[18:01:07.370]                       else if (inherits(cond, "condition")) {
[18:01:07.370]                         if (!is.null(pattern)) {
[18:01:07.370]                           computeRestarts <- base::computeRestarts
[18:01:07.370]                           grepl <- base::grepl
[18:01:07.370]                           restarts <- computeRestarts(cond)
[18:01:07.370]                           for (restart in restarts) {
[18:01:07.370]                             name <- restart$name
[18:01:07.370]                             if (is.null(name)) 
[18:01:07.370]                               next
[18:01:07.370]                             if (!grepl(pattern, name)) 
[18:01:07.370]                               next
[18:01:07.370]                             invokeRestart(restart)
[18:01:07.370]                             muffled <- TRUE
[18:01:07.370]                             break
[18:01:07.370]                           }
[18:01:07.370]                         }
[18:01:07.370]                       }
[18:01:07.370]                       invisible(muffled)
[18:01:07.370]                     }
[18:01:07.370]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.370]                   }
[18:01:07.370]                 }
[18:01:07.370]                 else {
[18:01:07.370]                   if (TRUE) {
[18:01:07.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.370]                     {
[18:01:07.370]                       inherits <- base::inherits
[18:01:07.370]                       invokeRestart <- base::invokeRestart
[18:01:07.370]                       is.null <- base::is.null
[18:01:07.370]                       muffled <- FALSE
[18:01:07.370]                       if (inherits(cond, "message")) {
[18:01:07.370]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.370]                         if (muffled) 
[18:01:07.370]                           invokeRestart("muffleMessage")
[18:01:07.370]                       }
[18:01:07.370]                       else if (inherits(cond, "warning")) {
[18:01:07.370]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.370]                         if (muffled) 
[18:01:07.370]                           invokeRestart("muffleWarning")
[18:01:07.370]                       }
[18:01:07.370]                       else if (inherits(cond, "condition")) {
[18:01:07.370]                         if (!is.null(pattern)) {
[18:01:07.370]                           computeRestarts <- base::computeRestarts
[18:01:07.370]                           grepl <- base::grepl
[18:01:07.370]                           restarts <- computeRestarts(cond)
[18:01:07.370]                           for (restart in restarts) {
[18:01:07.370]                             name <- restart$name
[18:01:07.370]                             if (is.null(name)) 
[18:01:07.370]                               next
[18:01:07.370]                             if (!grepl(pattern, name)) 
[18:01:07.370]                               next
[18:01:07.370]                             invokeRestart(restart)
[18:01:07.370]                             muffled <- TRUE
[18:01:07.370]                             break
[18:01:07.370]                           }
[18:01:07.370]                         }
[18:01:07.370]                       }
[18:01:07.370]                       invisible(muffled)
[18:01:07.370]                     }
[18:01:07.370]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.370]                   }
[18:01:07.370]                 }
[18:01:07.370]             }
[18:01:07.370]         }))
[18:01:07.370]     }, error = function(ex) {
[18:01:07.370]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.370]                 ...future.rng), started = ...future.startTime, 
[18:01:07.370]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.370]             version = "1.8"), class = "FutureResult")
[18:01:07.370]     }, finally = {
[18:01:07.370]         if (!identical(...future.workdir, getwd())) 
[18:01:07.370]             setwd(...future.workdir)
[18:01:07.370]         {
[18:01:07.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.370]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.370]             }
[18:01:07.370]             base::options(...future.oldOptions)
[18:01:07.370]             if (.Platform$OS.type == "windows") {
[18:01:07.370]                 old_names <- names(...future.oldEnvVars)
[18:01:07.370]                 envs <- base::Sys.getenv()
[18:01:07.370]                 names <- names(envs)
[18:01:07.370]                 common <- intersect(names, old_names)
[18:01:07.370]                 added <- setdiff(names, old_names)
[18:01:07.370]                 removed <- setdiff(old_names, names)
[18:01:07.370]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.370]                   envs[common]]
[18:01:07.370]                 NAMES <- toupper(changed)
[18:01:07.370]                 args <- list()
[18:01:07.370]                 for (kk in seq_along(NAMES)) {
[18:01:07.370]                   name <- changed[[kk]]
[18:01:07.370]                   NAME <- NAMES[[kk]]
[18:01:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.370]                     next
[18:01:07.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.370]                 }
[18:01:07.370]                 NAMES <- toupper(added)
[18:01:07.370]                 for (kk in seq_along(NAMES)) {
[18:01:07.370]                   name <- added[[kk]]
[18:01:07.370]                   NAME <- NAMES[[kk]]
[18:01:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.370]                     next
[18:01:07.370]                   args[[name]] <- ""
[18:01:07.370]                 }
[18:01:07.370]                 NAMES <- toupper(removed)
[18:01:07.370]                 for (kk in seq_along(NAMES)) {
[18:01:07.370]                   name <- removed[[kk]]
[18:01:07.370]                   NAME <- NAMES[[kk]]
[18:01:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.370]                     next
[18:01:07.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.370]                 }
[18:01:07.370]                 if (length(args) > 0) 
[18:01:07.370]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.370]             }
[18:01:07.370]             else {
[18:01:07.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.370]             }
[18:01:07.370]             {
[18:01:07.370]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.370]                   0L) {
[18:01:07.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.370]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.370]                   base::options(opts)
[18:01:07.370]                 }
[18:01:07.370]                 {
[18:01:07.370]                   {
[18:01:07.370]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.370]                     NULL
[18:01:07.370]                   }
[18:01:07.370]                   options(future.plan = NULL)
[18:01:07.370]                   if (is.na(NA_character_)) 
[18:01:07.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.370]                     .init = FALSE)
[18:01:07.370]                 }
[18:01:07.370]             }
[18:01:07.370]         }
[18:01:07.370]     })
[18:01:07.370]     if (TRUE) {
[18:01:07.370]         base::sink(type = "output", split = FALSE)
[18:01:07.370]         if (TRUE) {
[18:01:07.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.370]         }
[18:01:07.370]         else {
[18:01:07.370]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.370]         }
[18:01:07.370]         base::close(...future.stdout)
[18:01:07.370]         ...future.stdout <- NULL
[18:01:07.370]     }
[18:01:07.370]     ...future.result$conditions <- ...future.conditions
[18:01:07.370]     ...future.result$finished <- base::Sys.time()
[18:01:07.370]     ...future.result
[18:01:07.370] }
[18:01:07.375] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[18:01:07.376] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:07.376] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:07.377] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:07.378] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.378] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[18:01:07.379] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[18:01:07.379] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:07.380] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.380] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:07.381] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.381] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[18:01:07.382] MultisessionFuture started
[18:01:07.382] - Launch lazy future ... done
[18:01:07.383] run() for ‘MultisessionFuture’ ... done
[18:01:07.383] Created future:
[18:01:07.383] MultisessionFuture:
[18:01:07.383] Label: ‘future_mapply-2’
[18:01:07.383] Expression:
[18:01:07.383] {
[18:01:07.383]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.383]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.383]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.383]         on.exit(options(oopts), add = TRUE)
[18:01:07.383]     }
[18:01:07.383]     {
[18:01:07.383]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.383]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.383]         do.call(mapply, args = args)
[18:01:07.383]     }
[18:01:07.383] }
[18:01:07.383] Lazy evaluation: FALSE
[18:01:07.383] Asynchronous evaluation: TRUE
[18:01:07.383] Local evaluation: TRUE
[18:01:07.383] Environment: R_GlobalEnv
[18:01:07.383] Capture standard output: TRUE
[18:01:07.383] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.383] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.383] Packages: <none>
[18:01:07.383] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.383] Resolved: FALSE
[18:01:07.383] Value: <not collected>
[18:01:07.383] Conditions captured: <none>
[18:01:07.383] Early signaling: FALSE
[18:01:07.383] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.383] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.396] Chunk #2 of 3 ... DONE
[18:01:07.396] Chunk #3 of 3 ...
[18:01:07.396]  - Finding globals in '...' for chunk #3 ...
[18:01:07.396] getGlobalsAndPackages() ...
[18:01:07.397] Searching for globals...
[18:01:07.397] 
[18:01:07.398] Searching for globals ... DONE
[18:01:07.398] - globals: [0] <none>
[18:01:07.398] getGlobalsAndPackages() ... DONE
[18:01:07.398]    + additional globals found: [n=0] 
[18:01:07.398]    + additional namespaces needed: [n=0] 
[18:01:07.398]  - Finding globals in '...' for chunk #3 ... DONE
[18:01:07.399]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[18:01:07.399]  - seeds: <none>
[18:01:07.399]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.399] getGlobalsAndPackages() ...
[18:01:07.399] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.400] Resolving globals: FALSE
[18:01:07.401] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:07.402] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:07.402] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.402] 
[18:01:07.402] getGlobalsAndPackages() ... DONE
[18:01:07.403] run() for ‘Future’ ...
[18:01:07.403] - state: ‘created’
[18:01:07.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.428]   - Field: ‘node’
[18:01:07.428]   - Field: ‘label’
[18:01:07.428]   - Field: ‘local’
[18:01:07.428]   - Field: ‘owner’
[18:01:07.429]   - Field: ‘envir’
[18:01:07.429]   - Field: ‘workers’
[18:01:07.429]   - Field: ‘packages’
[18:01:07.429]   - Field: ‘gc’
[18:01:07.429]   - Field: ‘conditions’
[18:01:07.430]   - Field: ‘persistent’
[18:01:07.430]   - Field: ‘expr’
[18:01:07.430]   - Field: ‘uuid’
[18:01:07.430]   - Field: ‘seed’
[18:01:07.430]   - Field: ‘version’
[18:01:07.430]   - Field: ‘result’
[18:01:07.431]   - Field: ‘asynchronous’
[18:01:07.431]   - Field: ‘calls’
[18:01:07.431]   - Field: ‘globals’
[18:01:07.431]   - Field: ‘stdout’
[18:01:07.431]   - Field: ‘earlySignal’
[18:01:07.432]   - Field: ‘lazy’
[18:01:07.432]   - Field: ‘state’
[18:01:07.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.432] - Launch lazy future ...
[18:01:07.433] Packages needed by the future expression (n = 0): <none>
[18:01:07.433] Packages needed by future strategies (n = 0): <none>
[18:01:07.434] {
[18:01:07.434]     {
[18:01:07.434]         {
[18:01:07.434]             ...future.startTime <- base::Sys.time()
[18:01:07.434]             {
[18:01:07.434]                 {
[18:01:07.434]                   {
[18:01:07.434]                     {
[18:01:07.434]                       base::local({
[18:01:07.434]                         has_future <- base::requireNamespace("future", 
[18:01:07.434]                           quietly = TRUE)
[18:01:07.434]                         if (has_future) {
[18:01:07.434]                           ns <- base::getNamespace("future")
[18:01:07.434]                           version <- ns[[".package"]][["version"]]
[18:01:07.434]                           if (is.null(version)) 
[18:01:07.434]                             version <- utils::packageVersion("future")
[18:01:07.434]                         }
[18:01:07.434]                         else {
[18:01:07.434]                           version <- NULL
[18:01:07.434]                         }
[18:01:07.434]                         if (!has_future || version < "1.8.0") {
[18:01:07.434]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.434]                             "", base::R.version$version.string), 
[18:01:07.434]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.434]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.434]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.434]                               "release", "version")], collapse = " "), 
[18:01:07.434]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.434]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.434]                             info)
[18:01:07.434]                           info <- base::paste(info, collapse = "; ")
[18:01:07.434]                           if (!has_future) {
[18:01:07.434]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.434]                               info)
[18:01:07.434]                           }
[18:01:07.434]                           else {
[18:01:07.434]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.434]                               info, version)
[18:01:07.434]                           }
[18:01:07.434]                           base::stop(msg)
[18:01:07.434]                         }
[18:01:07.434]                       })
[18:01:07.434]                     }
[18:01:07.434]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.434]                     base::options(mc.cores = 1L)
[18:01:07.434]                   }
[18:01:07.434]                   ...future.strategy.old <- future::plan("list")
[18:01:07.434]                   options(future.plan = NULL)
[18:01:07.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.434]                 }
[18:01:07.434]                 ...future.workdir <- getwd()
[18:01:07.434]             }
[18:01:07.434]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.434]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.434]         }
[18:01:07.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.434]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[18:01:07.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.434]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.434]             base::names(...future.oldOptions))
[18:01:07.434]     }
[18:01:07.434]     if (FALSE) {
[18:01:07.434]     }
[18:01:07.434]     else {
[18:01:07.434]         if (TRUE) {
[18:01:07.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.434]                 open = "w")
[18:01:07.434]         }
[18:01:07.434]         else {
[18:01:07.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.434]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.434]         }
[18:01:07.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.434]             base::sink(type = "output", split = FALSE)
[18:01:07.434]             base::close(...future.stdout)
[18:01:07.434]         }, add = TRUE)
[18:01:07.434]     }
[18:01:07.434]     ...future.frame <- base::sys.nframe()
[18:01:07.434]     ...future.conditions <- base::list()
[18:01:07.434]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.434]     if (FALSE) {
[18:01:07.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.434]     }
[18:01:07.434]     ...future.result <- base::tryCatch({
[18:01:07.434]         base::withCallingHandlers({
[18:01:07.434]             ...future.value <- base::withVisible(base::local({
[18:01:07.434]                 ...future.makeSendCondition <- base::local({
[18:01:07.434]                   sendCondition <- NULL
[18:01:07.434]                   function(frame = 1L) {
[18:01:07.434]                     if (is.function(sendCondition)) 
[18:01:07.434]                       return(sendCondition)
[18:01:07.434]                     ns <- getNamespace("parallel")
[18:01:07.434]                     if (exists("sendData", mode = "function", 
[18:01:07.434]                       envir = ns)) {
[18:01:07.434]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.434]                         envir = ns)
[18:01:07.434]                       envir <- sys.frame(frame)
[18:01:07.434]                       master <- NULL
[18:01:07.434]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.434]                         !identical(envir, emptyenv())) {
[18:01:07.434]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.434]                           inherits = FALSE)) {
[18:01:07.434]                           master <- get("master", mode = "list", 
[18:01:07.434]                             envir = envir, inherits = FALSE)
[18:01:07.434]                           if (inherits(master, c("SOCKnode", 
[18:01:07.434]                             "SOCK0node"))) {
[18:01:07.434]                             sendCondition <<- function(cond) {
[18:01:07.434]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.434]                                 success = TRUE)
[18:01:07.434]                               parallel_sendData(master, data)
[18:01:07.434]                             }
[18:01:07.434]                             return(sendCondition)
[18:01:07.434]                           }
[18:01:07.434]                         }
[18:01:07.434]                         frame <- frame + 1L
[18:01:07.434]                         envir <- sys.frame(frame)
[18:01:07.434]                       }
[18:01:07.434]                     }
[18:01:07.434]                     sendCondition <<- function(cond) NULL
[18:01:07.434]                   }
[18:01:07.434]                 })
[18:01:07.434]                 withCallingHandlers({
[18:01:07.434]                   {
[18:01:07.434]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.434]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.434]                       ...future.globals.maxSize)) {
[18:01:07.434]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.434]                       on.exit(options(oopts), add = TRUE)
[18:01:07.434]                     }
[18:01:07.434]                     {
[18:01:07.434]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.434]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.434]                         USE.NAMES = FALSE)
[18:01:07.434]                       do.call(mapply, args = args)
[18:01:07.434]                     }
[18:01:07.434]                   }
[18:01:07.434]                 }, immediateCondition = function(cond) {
[18:01:07.434]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.434]                   sendCondition(cond)
[18:01:07.434]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.434]                   {
[18:01:07.434]                     inherits <- base::inherits
[18:01:07.434]                     invokeRestart <- base::invokeRestart
[18:01:07.434]                     is.null <- base::is.null
[18:01:07.434]                     muffled <- FALSE
[18:01:07.434]                     if (inherits(cond, "message")) {
[18:01:07.434]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.434]                       if (muffled) 
[18:01:07.434]                         invokeRestart("muffleMessage")
[18:01:07.434]                     }
[18:01:07.434]                     else if (inherits(cond, "warning")) {
[18:01:07.434]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.434]                       if (muffled) 
[18:01:07.434]                         invokeRestart("muffleWarning")
[18:01:07.434]                     }
[18:01:07.434]                     else if (inherits(cond, "condition")) {
[18:01:07.434]                       if (!is.null(pattern)) {
[18:01:07.434]                         computeRestarts <- base::computeRestarts
[18:01:07.434]                         grepl <- base::grepl
[18:01:07.434]                         restarts <- computeRestarts(cond)
[18:01:07.434]                         for (restart in restarts) {
[18:01:07.434]                           name <- restart$name
[18:01:07.434]                           if (is.null(name)) 
[18:01:07.434]                             next
[18:01:07.434]                           if (!grepl(pattern, name)) 
[18:01:07.434]                             next
[18:01:07.434]                           invokeRestart(restart)
[18:01:07.434]                           muffled <- TRUE
[18:01:07.434]                           break
[18:01:07.434]                         }
[18:01:07.434]                       }
[18:01:07.434]                     }
[18:01:07.434]                     invisible(muffled)
[18:01:07.434]                   }
[18:01:07.434]                   muffleCondition(cond)
[18:01:07.434]                 })
[18:01:07.434]             }))
[18:01:07.434]             future::FutureResult(value = ...future.value$value, 
[18:01:07.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.434]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.434]                     ...future.globalenv.names))
[18:01:07.434]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.434]         }, condition = base::local({
[18:01:07.434]             c <- base::c
[18:01:07.434]             inherits <- base::inherits
[18:01:07.434]             invokeRestart <- base::invokeRestart
[18:01:07.434]             length <- base::length
[18:01:07.434]             list <- base::list
[18:01:07.434]             seq.int <- base::seq.int
[18:01:07.434]             signalCondition <- base::signalCondition
[18:01:07.434]             sys.calls <- base::sys.calls
[18:01:07.434]             `[[` <- base::`[[`
[18:01:07.434]             `+` <- base::`+`
[18:01:07.434]             `<<-` <- base::`<<-`
[18:01:07.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.434]                   3L)]
[18:01:07.434]             }
[18:01:07.434]             function(cond) {
[18:01:07.434]                 is_error <- inherits(cond, "error")
[18:01:07.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.434]                   NULL)
[18:01:07.434]                 if (is_error) {
[18:01:07.434]                   sessionInformation <- function() {
[18:01:07.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.434]                       search = base::search(), system = base::Sys.info())
[18:01:07.434]                   }
[18:01:07.434]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.434]                     cond$call), session = sessionInformation(), 
[18:01:07.434]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.434]                   signalCondition(cond)
[18:01:07.434]                 }
[18:01:07.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.434]                 "immediateCondition"))) {
[18:01:07.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.434]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.434]                   if (TRUE && !signal) {
[18:01:07.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.434]                     {
[18:01:07.434]                       inherits <- base::inherits
[18:01:07.434]                       invokeRestart <- base::invokeRestart
[18:01:07.434]                       is.null <- base::is.null
[18:01:07.434]                       muffled <- FALSE
[18:01:07.434]                       if (inherits(cond, "message")) {
[18:01:07.434]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.434]                         if (muffled) 
[18:01:07.434]                           invokeRestart("muffleMessage")
[18:01:07.434]                       }
[18:01:07.434]                       else if (inherits(cond, "warning")) {
[18:01:07.434]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.434]                         if (muffled) 
[18:01:07.434]                           invokeRestart("muffleWarning")
[18:01:07.434]                       }
[18:01:07.434]                       else if (inherits(cond, "condition")) {
[18:01:07.434]                         if (!is.null(pattern)) {
[18:01:07.434]                           computeRestarts <- base::computeRestarts
[18:01:07.434]                           grepl <- base::grepl
[18:01:07.434]                           restarts <- computeRestarts(cond)
[18:01:07.434]                           for (restart in restarts) {
[18:01:07.434]                             name <- restart$name
[18:01:07.434]                             if (is.null(name)) 
[18:01:07.434]                               next
[18:01:07.434]                             if (!grepl(pattern, name)) 
[18:01:07.434]                               next
[18:01:07.434]                             invokeRestart(restart)
[18:01:07.434]                             muffled <- TRUE
[18:01:07.434]                             break
[18:01:07.434]                           }
[18:01:07.434]                         }
[18:01:07.434]                       }
[18:01:07.434]                       invisible(muffled)
[18:01:07.434]                     }
[18:01:07.434]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.434]                   }
[18:01:07.434]                 }
[18:01:07.434]                 else {
[18:01:07.434]                   if (TRUE) {
[18:01:07.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.434]                     {
[18:01:07.434]                       inherits <- base::inherits
[18:01:07.434]                       invokeRestart <- base::invokeRestart
[18:01:07.434]                       is.null <- base::is.null
[18:01:07.434]                       muffled <- FALSE
[18:01:07.434]                       if (inherits(cond, "message")) {
[18:01:07.434]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.434]                         if (muffled) 
[18:01:07.434]                           invokeRestart("muffleMessage")
[18:01:07.434]                       }
[18:01:07.434]                       else if (inherits(cond, "warning")) {
[18:01:07.434]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.434]                         if (muffled) 
[18:01:07.434]                           invokeRestart("muffleWarning")
[18:01:07.434]                       }
[18:01:07.434]                       else if (inherits(cond, "condition")) {
[18:01:07.434]                         if (!is.null(pattern)) {
[18:01:07.434]                           computeRestarts <- base::computeRestarts
[18:01:07.434]                           grepl <- base::grepl
[18:01:07.434]                           restarts <- computeRestarts(cond)
[18:01:07.434]                           for (restart in restarts) {
[18:01:07.434]                             name <- restart$name
[18:01:07.434]                             if (is.null(name)) 
[18:01:07.434]                               next
[18:01:07.434]                             if (!grepl(pattern, name)) 
[18:01:07.434]                               next
[18:01:07.434]                             invokeRestart(restart)
[18:01:07.434]                             muffled <- TRUE
[18:01:07.434]                             break
[18:01:07.434]                           }
[18:01:07.434]                         }
[18:01:07.434]                       }
[18:01:07.434]                       invisible(muffled)
[18:01:07.434]                     }
[18:01:07.434]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.434]                   }
[18:01:07.434]                 }
[18:01:07.434]             }
[18:01:07.434]         }))
[18:01:07.434]     }, error = function(ex) {
[18:01:07.434]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.434]                 ...future.rng), started = ...future.startTime, 
[18:01:07.434]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.434]             version = "1.8"), class = "FutureResult")
[18:01:07.434]     }, finally = {
[18:01:07.434]         if (!identical(...future.workdir, getwd())) 
[18:01:07.434]             setwd(...future.workdir)
[18:01:07.434]         {
[18:01:07.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.434]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.434]             }
[18:01:07.434]             base::options(...future.oldOptions)
[18:01:07.434]             if (.Platform$OS.type == "windows") {
[18:01:07.434]                 old_names <- names(...future.oldEnvVars)
[18:01:07.434]                 envs <- base::Sys.getenv()
[18:01:07.434]                 names <- names(envs)
[18:01:07.434]                 common <- intersect(names, old_names)
[18:01:07.434]                 added <- setdiff(names, old_names)
[18:01:07.434]                 removed <- setdiff(old_names, names)
[18:01:07.434]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.434]                   envs[common]]
[18:01:07.434]                 NAMES <- toupper(changed)
[18:01:07.434]                 args <- list()
[18:01:07.434]                 for (kk in seq_along(NAMES)) {
[18:01:07.434]                   name <- changed[[kk]]
[18:01:07.434]                   NAME <- NAMES[[kk]]
[18:01:07.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.434]                     next
[18:01:07.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.434]                 }
[18:01:07.434]                 NAMES <- toupper(added)
[18:01:07.434]                 for (kk in seq_along(NAMES)) {
[18:01:07.434]                   name <- added[[kk]]
[18:01:07.434]                   NAME <- NAMES[[kk]]
[18:01:07.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.434]                     next
[18:01:07.434]                   args[[name]] <- ""
[18:01:07.434]                 }
[18:01:07.434]                 NAMES <- toupper(removed)
[18:01:07.434]                 for (kk in seq_along(NAMES)) {
[18:01:07.434]                   name <- removed[[kk]]
[18:01:07.434]                   NAME <- NAMES[[kk]]
[18:01:07.434]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.434]                     next
[18:01:07.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.434]                 }
[18:01:07.434]                 if (length(args) > 0) 
[18:01:07.434]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.434]             }
[18:01:07.434]             else {
[18:01:07.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.434]             }
[18:01:07.434]             {
[18:01:07.434]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.434]                   0L) {
[18:01:07.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.434]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.434]                   base::options(opts)
[18:01:07.434]                 }
[18:01:07.434]                 {
[18:01:07.434]                   {
[18:01:07.434]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.434]                     NULL
[18:01:07.434]                   }
[18:01:07.434]                   options(future.plan = NULL)
[18:01:07.434]                   if (is.na(NA_character_)) 
[18:01:07.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.434]                     .init = FALSE)
[18:01:07.434]                 }
[18:01:07.434]             }
[18:01:07.434]         }
[18:01:07.434]     })
[18:01:07.434]     if (TRUE) {
[18:01:07.434]         base::sink(type = "output", split = FALSE)
[18:01:07.434]         if (TRUE) {
[18:01:07.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.434]         }
[18:01:07.434]         else {
[18:01:07.434]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.434]         }
[18:01:07.434]         base::close(...future.stdout)
[18:01:07.434]         ...future.stdout <- NULL
[18:01:07.434]     }
[18:01:07.434]     ...future.result$conditions <- ...future.conditions
[18:01:07.434]     ...future.result$finished <- base::Sys.time()
[18:01:07.434]     ...future.result
[18:01:07.434] }
[18:01:07.438] Poll #1 (0): usedNodes() = 2, workers = 2
[18:01:07.449] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.450] - Validating connection of MultisessionFuture
[18:01:07.450] - received message: FutureResult
[18:01:07.450] - Received FutureResult
[18:01:07.450] - Erased future from FutureRegistry
[18:01:07.451] result() for ClusterFuture ...
[18:01:07.451] - result already collected: FutureResult
[18:01:07.451] result() for ClusterFuture ... done
[18:01:07.451] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.451] result() for ClusterFuture ...
[18:01:07.452] - result already collected: FutureResult
[18:01:07.452] result() for ClusterFuture ... done
[18:01:07.452] result() for ClusterFuture ...
[18:01:07.452] - result already collected: FutureResult
[18:01:07.452] result() for ClusterFuture ... done
[18:01:07.454] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[18:01:07.454] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:07.455] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:07.455] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:07.456] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.457] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[18:01:07.457] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[18:01:07.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:07.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.459] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:07.460] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.460] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[18:01:07.461] MultisessionFuture started
[18:01:07.461] - Launch lazy future ... done
[18:01:07.461] run() for ‘MultisessionFuture’ ... done
[18:01:07.462] Created future:
[18:01:07.462] MultisessionFuture:
[18:01:07.462] Label: ‘future_mapply-3’
[18:01:07.462] Expression:
[18:01:07.462] {
[18:01:07.462]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.462]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.462]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.462]         on.exit(options(oopts), add = TRUE)
[18:01:07.462]     }
[18:01:07.462]     {
[18:01:07.462]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.462]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.462]         do.call(mapply, args = args)
[18:01:07.462]     }
[18:01:07.462] }
[18:01:07.462] Lazy evaluation: FALSE
[18:01:07.462] Asynchronous evaluation: TRUE
[18:01:07.462] Local evaluation: TRUE
[18:01:07.462] Environment: R_GlobalEnv
[18:01:07.462] Capture standard output: TRUE
[18:01:07.462] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.462] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.462] Packages: <none>
[18:01:07.462] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.462] Resolved: FALSE
[18:01:07.462] Value: <not collected>
[18:01:07.462] Conditions captured: <none>
[18:01:07.462] Early signaling: FALSE
[18:01:07.462] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.462] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.475] Chunk #3 of 3 ... DONE
[18:01:07.475] Launching 3 futures (chunks) ... DONE
[18:01:07.475] Resolving 3 futures (chunks) ...
[18:01:07.475] resolve() on list ...
[18:01:07.475]  recursive: 0
[18:01:07.476]  length: 3
[18:01:07.476] 
[18:01:07.476] Future #1
[18:01:07.476] result() for ClusterFuture ...
[18:01:07.476] - result already collected: FutureResult
[18:01:07.477] result() for ClusterFuture ... done
[18:01:07.477] result() for ClusterFuture ...
[18:01:07.477] - result already collected: FutureResult
[18:01:07.477] result() for ClusterFuture ... done
[18:01:07.477] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:07.477] - nx: 3
[18:01:07.478] - relay: TRUE
[18:01:07.478] - stdout: TRUE
[18:01:07.478] - signal: TRUE
[18:01:07.478] - resignal: FALSE
[18:01:07.478] - force: TRUE
[18:01:07.479] - relayed: [n=3] FALSE, FALSE, FALSE
[18:01:07.479] - queued futures: [n=3] FALSE, FALSE, FALSE
[18:01:07.479]  - until=1
[18:01:07.479]  - relaying element #1
[18:01:07.479] result() for ClusterFuture ...
[18:01:07.483] - result already collected: FutureResult
[18:01:07.483] result() for ClusterFuture ... done
[18:01:07.483] result() for ClusterFuture ...
[18:01:07.483] - result already collected: FutureResult
[18:01:07.483] result() for ClusterFuture ... done
[18:01:07.484] result() for ClusterFuture ...
[18:01:07.484] - result already collected: FutureResult
[18:01:07.484] result() for ClusterFuture ... done
[18:01:07.484] result() for ClusterFuture ...
[18:01:07.484] - result already collected: FutureResult
[18:01:07.485] result() for ClusterFuture ... done
[18:01:07.485] - relayed: [n=3] TRUE, FALSE, FALSE
[18:01:07.485] - queued futures: [n=3] TRUE, FALSE, FALSE
[18:01:07.485] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:07.485]  length: 2 (resolved future 1)
[18:01:07.486] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.487] - Validating connection of MultisessionFuture
[18:01:07.487] - received message: FutureResult
[18:01:07.487] - Received FutureResult
[18:01:07.487] - Erased future from FutureRegistry
[18:01:07.488] result() for ClusterFuture ...
[18:01:07.488] - result already collected: FutureResult
[18:01:07.488] result() for ClusterFuture ... done
[18:01:07.488] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.488] Future #2
[18:01:07.488] result() for ClusterFuture ...
[18:01:07.489] - result already collected: FutureResult
[18:01:07.489] result() for ClusterFuture ... done
[18:01:07.489] result() for ClusterFuture ...
[18:01:07.489] - result already collected: FutureResult
[18:01:07.489] result() for ClusterFuture ... done
[18:01:07.490] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:07.490] - nx: 3
[18:01:07.490] - relay: TRUE
[18:01:07.490] - stdout: TRUE
[18:01:07.490] - signal: TRUE
[18:01:07.490] - resignal: FALSE
[18:01:07.491] - force: TRUE
[18:01:07.491] - relayed: [n=3] TRUE, FALSE, FALSE
[18:01:07.491] - queued futures: [n=3] TRUE, FALSE, FALSE
[18:01:07.491]  - until=2
[18:01:07.491]  - relaying element #2
[18:01:07.492] result() for ClusterFuture ...
[18:01:07.492] - result already collected: FutureResult
[18:01:07.492] result() for ClusterFuture ... done
[18:01:07.492] result() for ClusterFuture ...
[18:01:07.492] - result already collected: FutureResult
[18:01:07.492] result() for ClusterFuture ... done
[18:01:07.493] result() for ClusterFuture ...
[18:01:07.493] - result already collected: FutureResult
[18:01:07.493] result() for ClusterFuture ... done
[18:01:07.493] result() for ClusterFuture ...
[18:01:07.493] - result already collected: FutureResult
[18:01:07.493] result() for ClusterFuture ... done
[18:01:07.494] - relayed: [n=3] TRUE, TRUE, FALSE
[18:01:07.494] - queued futures: [n=3] TRUE, TRUE, FALSE
[18:01:07.494] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:07.494]  length: 1 (resolved future 2)
[18:01:07.516] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.517] - Validating connection of MultisessionFuture
[18:01:07.517] - received message: FutureResult
[18:01:07.517] - Received FutureResult
[18:01:07.517] - Erased future from FutureRegistry
[18:01:07.518] result() for ClusterFuture ...
[18:01:07.518] - result already collected: FutureResult
[18:01:07.518] result() for ClusterFuture ... done
[18:01:07.518] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.518] Future #3
[18:01:07.519] result() for ClusterFuture ...
[18:01:07.519] - result already collected: FutureResult
[18:01:07.519] result() for ClusterFuture ... done
[18:01:07.519] result() for ClusterFuture ...
[18:01:07.519] - result already collected: FutureResult
[18:01:07.519] result() for ClusterFuture ... done
[18:01:07.520] signalConditionsASAP(MultisessionFuture, pos=3) ...
[18:01:07.520] - nx: 3
[18:01:07.520] - relay: TRUE
[18:01:07.520] - stdout: TRUE
[18:01:07.520] - signal: TRUE
[18:01:07.521] - resignal: FALSE
[18:01:07.521] - force: TRUE
[18:01:07.521] - relayed: [n=3] TRUE, TRUE, FALSE
[18:01:07.521] - queued futures: [n=3] TRUE, TRUE, FALSE
[18:01:07.521]  - until=3
[18:01:07.522]  - relaying element #3
[18:01:07.522] result() for ClusterFuture ...
[18:01:07.522] - result already collected: FutureResult
[18:01:07.522] result() for ClusterFuture ... done
[18:01:07.522] result() for ClusterFuture ...
[18:01:07.523] - result already collected: FutureResult
[18:01:07.523] result() for ClusterFuture ... done
[18:01:07.523] result() for ClusterFuture ...
[18:01:07.523] - result already collected: FutureResult
[18:01:07.523] result() for ClusterFuture ... done
[18:01:07.524] result() for ClusterFuture ...
[18:01:07.524] - result already collected: FutureResult
[18:01:07.524] result() for ClusterFuture ... done
[18:01:07.524] - relayed: [n=3] TRUE, TRUE, TRUE
[18:01:07.524] - queued futures: [n=3] TRUE, TRUE, TRUE
[18:01:07.524] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[18:01:07.525]  length: 0 (resolved future 3)
[18:01:07.525] Relaying remaining futures
[18:01:07.525] signalConditionsASAP(NULL, pos=0) ...
[18:01:07.525] - nx: 3
[18:01:07.525] - relay: TRUE
[18:01:07.526] - stdout: TRUE
[18:01:07.526] - signal: TRUE
[18:01:07.526] - resignal: FALSE
[18:01:07.526] - force: TRUE
[18:01:07.526] - relayed: [n=3] TRUE, TRUE, TRUE
[18:01:07.526] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[18:01:07.527] - relayed: [n=3] TRUE, TRUE, TRUE
[18:01:07.527] - queued futures: [n=3] TRUE, TRUE, TRUE
[18:01:07.527] signalConditionsASAP(NULL, pos=0) ... done
[18:01:07.527] resolve() on list ... DONE
[18:01:07.527] result() for ClusterFuture ...
[18:01:07.528] - result already collected: FutureResult
[18:01:07.528] result() for ClusterFuture ... done
[18:01:07.528] result() for ClusterFuture ...
[18:01:07.528] - result already collected: FutureResult
[18:01:07.528] result() for ClusterFuture ... done
[18:01:07.529] result() for ClusterFuture ...
[18:01:07.529] - result already collected: FutureResult
[18:01:07.529] result() for ClusterFuture ... done
[18:01:07.529] result() for ClusterFuture ...
[18:01:07.529] - result already collected: FutureResult
[18:01:07.530] result() for ClusterFuture ... done
[18:01:07.530] result() for ClusterFuture ...
[18:01:07.530] - result already collected: FutureResult
[18:01:07.530] result() for ClusterFuture ... done
[18:01:07.530] result() for ClusterFuture ...
[18:01:07.530] - result already collected: FutureResult
[18:01:07.531] result() for ClusterFuture ... done
[18:01:07.531]  - Number of value chunks collected: 3
[18:01:07.531] Resolving 3 futures (chunks) ... DONE
[18:01:07.531] Reducing values from 3 chunks ...
[18:01:07.531]  - Number of values collected after concatenation: 5
[18:01:07.532]  - Number of values expected: 5
[18:01:07.532] Reverse index remapping (attribute 'ordering'): [n = 5] 4, 1, 5, 3, 2
[18:01:07.532] Reducing values from 3 chunks ... DONE
[18:01:07.532] future_mapply() ... DONE
[18:01:07.533] future_mapply() ...
[18:01:07.539] Number of chunks: 2
[18:01:07.539] getGlobalsAndPackagesXApply() ...
[18:01:07.540]  - future.globals: TRUE
[18:01:07.540] getGlobalsAndPackages() ...
[18:01:07.540] Searching for globals...
[18:01:07.542] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:07.543] Searching for globals ... DONE
[18:01:07.543] Resolving globals: FALSE
[18:01:07.544] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:07.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:07.545] - globals: [1] ‘FUN’
[18:01:07.545] 
[18:01:07.545] getGlobalsAndPackages() ... DONE
[18:01:07.545]  - globals found/used: [n=1] ‘FUN’
[18:01:07.545]  - needed namespaces: [n=0] 
[18:01:07.546] Finding globals ... DONE
[18:01:07.546] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:07.546] List of 2
[18:01:07.546]  $ ...future.FUN:function (C, k)  
[18:01:07.546]  $ MoreArgs     : list()
[18:01:07.546]  - attr(*, "where")=List of 2
[18:01:07.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:07.546]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:07.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:07.546]  - attr(*, "resolved")= logi FALSE
[18:01:07.546]  - attr(*, "total_size")= num NA
[18:01:07.551] Packages to be attached in all futures: [n=0] 
[18:01:07.551] getGlobalsAndPackagesXApply() ... DONE
[18:01:07.552] Number of futures (= number of chunks): 2
[18:01:07.552] Launching 2 futures (chunks) ...
[18:01:07.552] Chunk #1 of 2 ...
[18:01:07.552]  - Finding globals in '...' for chunk #1 ...
[18:01:07.553] getGlobalsAndPackages() ...
[18:01:07.553] Searching for globals...
[18:01:07.554] 
[18:01:07.554] Searching for globals ... DONE
[18:01:07.554] - globals: [0] <none>
[18:01:07.554] getGlobalsAndPackages() ... DONE
[18:01:07.554]    + additional globals found: [n=0] 
[18:01:07.555]    + additional namespaces needed: [n=0] 
[18:01:07.555]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:07.555]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.555]  - seeds: <none>
[18:01:07.555]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.556] getGlobalsAndPackages() ...
[18:01:07.556] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.556] Resolving globals: FALSE
[18:01:07.557] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:07.558] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:07.558] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.558] 
[18:01:07.559] getGlobalsAndPackages() ... DONE
[18:01:07.559] run() for ‘Future’ ...
[18:01:07.559] - state: ‘created’
[18:01:07.560] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.582]   - Field: ‘node’
[18:01:07.583]   - Field: ‘label’
[18:01:07.583]   - Field: ‘local’
[18:01:07.583]   - Field: ‘owner’
[18:01:07.583]   - Field: ‘envir’
[18:01:07.583]   - Field: ‘workers’
[18:01:07.584]   - Field: ‘packages’
[18:01:07.584]   - Field: ‘gc’
[18:01:07.584]   - Field: ‘conditions’
[18:01:07.584]   - Field: ‘persistent’
[18:01:07.584]   - Field: ‘expr’
[18:01:07.585]   - Field: ‘uuid’
[18:01:07.585]   - Field: ‘seed’
[18:01:07.585]   - Field: ‘version’
[18:01:07.585]   - Field: ‘result’
[18:01:07.585]   - Field: ‘asynchronous’
[18:01:07.586]   - Field: ‘calls’
[18:01:07.586]   - Field: ‘globals’
[18:01:07.586]   - Field: ‘stdout’
[18:01:07.586]   - Field: ‘earlySignal’
[18:01:07.586]   - Field: ‘lazy’
[18:01:07.587]   - Field: ‘state’
[18:01:07.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.587] - Launch lazy future ...
[18:01:07.587] Packages needed by the future expression (n = 0): <none>
[18:01:07.588] Packages needed by future strategies (n = 0): <none>
[18:01:07.589] {
[18:01:07.589]     {
[18:01:07.589]         {
[18:01:07.589]             ...future.startTime <- base::Sys.time()
[18:01:07.589]             {
[18:01:07.589]                 {
[18:01:07.589]                   {
[18:01:07.589]                     {
[18:01:07.589]                       base::local({
[18:01:07.589]                         has_future <- base::requireNamespace("future", 
[18:01:07.589]                           quietly = TRUE)
[18:01:07.589]                         if (has_future) {
[18:01:07.589]                           ns <- base::getNamespace("future")
[18:01:07.589]                           version <- ns[[".package"]][["version"]]
[18:01:07.589]                           if (is.null(version)) 
[18:01:07.589]                             version <- utils::packageVersion("future")
[18:01:07.589]                         }
[18:01:07.589]                         else {
[18:01:07.589]                           version <- NULL
[18:01:07.589]                         }
[18:01:07.589]                         if (!has_future || version < "1.8.0") {
[18:01:07.589]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.589]                             "", base::R.version$version.string), 
[18:01:07.589]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.589]                               "release", "version")], collapse = " "), 
[18:01:07.589]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.589]                             info)
[18:01:07.589]                           info <- base::paste(info, collapse = "; ")
[18:01:07.589]                           if (!has_future) {
[18:01:07.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.589]                               info)
[18:01:07.589]                           }
[18:01:07.589]                           else {
[18:01:07.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.589]                               info, version)
[18:01:07.589]                           }
[18:01:07.589]                           base::stop(msg)
[18:01:07.589]                         }
[18:01:07.589]                       })
[18:01:07.589]                     }
[18:01:07.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.589]                     base::options(mc.cores = 1L)
[18:01:07.589]                   }
[18:01:07.589]                   ...future.strategy.old <- future::plan("list")
[18:01:07.589]                   options(future.plan = NULL)
[18:01:07.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.589]                 }
[18:01:07.589]                 ...future.workdir <- getwd()
[18:01:07.589]             }
[18:01:07.589]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.589]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.589]         }
[18:01:07.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.589]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.589]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.589]             base::names(...future.oldOptions))
[18:01:07.589]     }
[18:01:07.589]     if (FALSE) {
[18:01:07.589]     }
[18:01:07.589]     else {
[18:01:07.589]         if (TRUE) {
[18:01:07.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.589]                 open = "w")
[18:01:07.589]         }
[18:01:07.589]         else {
[18:01:07.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.589]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.589]         }
[18:01:07.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.589]             base::sink(type = "output", split = FALSE)
[18:01:07.589]             base::close(...future.stdout)
[18:01:07.589]         }, add = TRUE)
[18:01:07.589]     }
[18:01:07.589]     ...future.frame <- base::sys.nframe()
[18:01:07.589]     ...future.conditions <- base::list()
[18:01:07.589]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.589]     if (FALSE) {
[18:01:07.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.589]     }
[18:01:07.589]     ...future.result <- base::tryCatch({
[18:01:07.589]         base::withCallingHandlers({
[18:01:07.589]             ...future.value <- base::withVisible(base::local({
[18:01:07.589]                 ...future.makeSendCondition <- base::local({
[18:01:07.589]                   sendCondition <- NULL
[18:01:07.589]                   function(frame = 1L) {
[18:01:07.589]                     if (is.function(sendCondition)) 
[18:01:07.589]                       return(sendCondition)
[18:01:07.589]                     ns <- getNamespace("parallel")
[18:01:07.589]                     if (exists("sendData", mode = "function", 
[18:01:07.589]                       envir = ns)) {
[18:01:07.589]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.589]                         envir = ns)
[18:01:07.589]                       envir <- sys.frame(frame)
[18:01:07.589]                       master <- NULL
[18:01:07.589]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.589]                         !identical(envir, emptyenv())) {
[18:01:07.589]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.589]                           inherits = FALSE)) {
[18:01:07.589]                           master <- get("master", mode = "list", 
[18:01:07.589]                             envir = envir, inherits = FALSE)
[18:01:07.589]                           if (inherits(master, c("SOCKnode", 
[18:01:07.589]                             "SOCK0node"))) {
[18:01:07.589]                             sendCondition <<- function(cond) {
[18:01:07.589]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.589]                                 success = TRUE)
[18:01:07.589]                               parallel_sendData(master, data)
[18:01:07.589]                             }
[18:01:07.589]                             return(sendCondition)
[18:01:07.589]                           }
[18:01:07.589]                         }
[18:01:07.589]                         frame <- frame + 1L
[18:01:07.589]                         envir <- sys.frame(frame)
[18:01:07.589]                       }
[18:01:07.589]                     }
[18:01:07.589]                     sendCondition <<- function(cond) NULL
[18:01:07.589]                   }
[18:01:07.589]                 })
[18:01:07.589]                 withCallingHandlers({
[18:01:07.589]                   {
[18:01:07.589]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.589]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.589]                       ...future.globals.maxSize)) {
[18:01:07.589]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.589]                       on.exit(options(oopts), add = TRUE)
[18:01:07.589]                     }
[18:01:07.589]                     {
[18:01:07.589]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.589]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.589]                         USE.NAMES = FALSE)
[18:01:07.589]                       do.call(mapply, args = args)
[18:01:07.589]                     }
[18:01:07.589]                   }
[18:01:07.589]                 }, immediateCondition = function(cond) {
[18:01:07.589]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.589]                   sendCondition(cond)
[18:01:07.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.589]                   {
[18:01:07.589]                     inherits <- base::inherits
[18:01:07.589]                     invokeRestart <- base::invokeRestart
[18:01:07.589]                     is.null <- base::is.null
[18:01:07.589]                     muffled <- FALSE
[18:01:07.589]                     if (inherits(cond, "message")) {
[18:01:07.589]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.589]                       if (muffled) 
[18:01:07.589]                         invokeRestart("muffleMessage")
[18:01:07.589]                     }
[18:01:07.589]                     else if (inherits(cond, "warning")) {
[18:01:07.589]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.589]                       if (muffled) 
[18:01:07.589]                         invokeRestart("muffleWarning")
[18:01:07.589]                     }
[18:01:07.589]                     else if (inherits(cond, "condition")) {
[18:01:07.589]                       if (!is.null(pattern)) {
[18:01:07.589]                         computeRestarts <- base::computeRestarts
[18:01:07.589]                         grepl <- base::grepl
[18:01:07.589]                         restarts <- computeRestarts(cond)
[18:01:07.589]                         for (restart in restarts) {
[18:01:07.589]                           name <- restart$name
[18:01:07.589]                           if (is.null(name)) 
[18:01:07.589]                             next
[18:01:07.589]                           if (!grepl(pattern, name)) 
[18:01:07.589]                             next
[18:01:07.589]                           invokeRestart(restart)
[18:01:07.589]                           muffled <- TRUE
[18:01:07.589]                           break
[18:01:07.589]                         }
[18:01:07.589]                       }
[18:01:07.589]                     }
[18:01:07.589]                     invisible(muffled)
[18:01:07.589]                   }
[18:01:07.589]                   muffleCondition(cond)
[18:01:07.589]                 })
[18:01:07.589]             }))
[18:01:07.589]             future::FutureResult(value = ...future.value$value, 
[18:01:07.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.589]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.589]                     ...future.globalenv.names))
[18:01:07.589]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.589]         }, condition = base::local({
[18:01:07.589]             c <- base::c
[18:01:07.589]             inherits <- base::inherits
[18:01:07.589]             invokeRestart <- base::invokeRestart
[18:01:07.589]             length <- base::length
[18:01:07.589]             list <- base::list
[18:01:07.589]             seq.int <- base::seq.int
[18:01:07.589]             signalCondition <- base::signalCondition
[18:01:07.589]             sys.calls <- base::sys.calls
[18:01:07.589]             `[[` <- base::`[[`
[18:01:07.589]             `+` <- base::`+`
[18:01:07.589]             `<<-` <- base::`<<-`
[18:01:07.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.589]                   3L)]
[18:01:07.589]             }
[18:01:07.589]             function(cond) {
[18:01:07.589]                 is_error <- inherits(cond, "error")
[18:01:07.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.589]                   NULL)
[18:01:07.589]                 if (is_error) {
[18:01:07.589]                   sessionInformation <- function() {
[18:01:07.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.589]                       search = base::search(), system = base::Sys.info())
[18:01:07.589]                   }
[18:01:07.589]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.589]                     cond$call), session = sessionInformation(), 
[18:01:07.589]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.589]                   signalCondition(cond)
[18:01:07.589]                 }
[18:01:07.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.589]                 "immediateCondition"))) {
[18:01:07.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.589]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.589]                   if (TRUE && !signal) {
[18:01:07.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.589]                     {
[18:01:07.589]                       inherits <- base::inherits
[18:01:07.589]                       invokeRestart <- base::invokeRestart
[18:01:07.589]                       is.null <- base::is.null
[18:01:07.589]                       muffled <- FALSE
[18:01:07.589]                       if (inherits(cond, "message")) {
[18:01:07.589]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.589]                         if (muffled) 
[18:01:07.589]                           invokeRestart("muffleMessage")
[18:01:07.589]                       }
[18:01:07.589]                       else if (inherits(cond, "warning")) {
[18:01:07.589]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.589]                         if (muffled) 
[18:01:07.589]                           invokeRestart("muffleWarning")
[18:01:07.589]                       }
[18:01:07.589]                       else if (inherits(cond, "condition")) {
[18:01:07.589]                         if (!is.null(pattern)) {
[18:01:07.589]                           computeRestarts <- base::computeRestarts
[18:01:07.589]                           grepl <- base::grepl
[18:01:07.589]                           restarts <- computeRestarts(cond)
[18:01:07.589]                           for (restart in restarts) {
[18:01:07.589]                             name <- restart$name
[18:01:07.589]                             if (is.null(name)) 
[18:01:07.589]                               next
[18:01:07.589]                             if (!grepl(pattern, name)) 
[18:01:07.589]                               next
[18:01:07.589]                             invokeRestart(restart)
[18:01:07.589]                             muffled <- TRUE
[18:01:07.589]                             break
[18:01:07.589]                           }
[18:01:07.589]                         }
[18:01:07.589]                       }
[18:01:07.589]                       invisible(muffled)
[18:01:07.589]                     }
[18:01:07.589]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.589]                   }
[18:01:07.589]                 }
[18:01:07.589]                 else {
[18:01:07.589]                   if (TRUE) {
[18:01:07.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.589]                     {
[18:01:07.589]                       inherits <- base::inherits
[18:01:07.589]                       invokeRestart <- base::invokeRestart
[18:01:07.589]                       is.null <- base::is.null
[18:01:07.589]                       muffled <- FALSE
[18:01:07.589]                       if (inherits(cond, "message")) {
[18:01:07.589]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.589]                         if (muffled) 
[18:01:07.589]                           invokeRestart("muffleMessage")
[18:01:07.589]                       }
[18:01:07.589]                       else if (inherits(cond, "warning")) {
[18:01:07.589]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.589]                         if (muffled) 
[18:01:07.589]                           invokeRestart("muffleWarning")
[18:01:07.589]                       }
[18:01:07.589]                       else if (inherits(cond, "condition")) {
[18:01:07.589]                         if (!is.null(pattern)) {
[18:01:07.589]                           computeRestarts <- base::computeRestarts
[18:01:07.589]                           grepl <- base::grepl
[18:01:07.589]                           restarts <- computeRestarts(cond)
[18:01:07.589]                           for (restart in restarts) {
[18:01:07.589]                             name <- restart$name
[18:01:07.589]                             if (is.null(name)) 
[18:01:07.589]                               next
[18:01:07.589]                             if (!grepl(pattern, name)) 
[18:01:07.589]                               next
[18:01:07.589]                             invokeRestart(restart)
[18:01:07.589]                             muffled <- TRUE
[18:01:07.589]                             break
[18:01:07.589]                           }
[18:01:07.589]                         }
[18:01:07.589]                       }
[18:01:07.589]                       invisible(muffled)
[18:01:07.589]                     }
[18:01:07.589]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.589]                   }
[18:01:07.589]                 }
[18:01:07.589]             }
[18:01:07.589]         }))
[18:01:07.589]     }, error = function(ex) {
[18:01:07.589]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.589]                 ...future.rng), started = ...future.startTime, 
[18:01:07.589]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.589]             version = "1.8"), class = "FutureResult")
[18:01:07.589]     }, finally = {
[18:01:07.589]         if (!identical(...future.workdir, getwd())) 
[18:01:07.589]             setwd(...future.workdir)
[18:01:07.589]         {
[18:01:07.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.589]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.589]             }
[18:01:07.589]             base::options(...future.oldOptions)
[18:01:07.589]             if (.Platform$OS.type == "windows") {
[18:01:07.589]                 old_names <- names(...future.oldEnvVars)
[18:01:07.589]                 envs <- base::Sys.getenv()
[18:01:07.589]                 names <- names(envs)
[18:01:07.589]                 common <- intersect(names, old_names)
[18:01:07.589]                 added <- setdiff(names, old_names)
[18:01:07.589]                 removed <- setdiff(old_names, names)
[18:01:07.589]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.589]                   envs[common]]
[18:01:07.589]                 NAMES <- toupper(changed)
[18:01:07.589]                 args <- list()
[18:01:07.589]                 for (kk in seq_along(NAMES)) {
[18:01:07.589]                   name <- changed[[kk]]
[18:01:07.589]                   NAME <- NAMES[[kk]]
[18:01:07.589]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.589]                     next
[18:01:07.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.589]                 }
[18:01:07.589]                 NAMES <- toupper(added)
[18:01:07.589]                 for (kk in seq_along(NAMES)) {
[18:01:07.589]                   name <- added[[kk]]
[18:01:07.589]                   NAME <- NAMES[[kk]]
[18:01:07.589]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.589]                     next
[18:01:07.589]                   args[[name]] <- ""
[18:01:07.589]                 }
[18:01:07.589]                 NAMES <- toupper(removed)
[18:01:07.589]                 for (kk in seq_along(NAMES)) {
[18:01:07.589]                   name <- removed[[kk]]
[18:01:07.589]                   NAME <- NAMES[[kk]]
[18:01:07.589]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.589]                     next
[18:01:07.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.589]                 }
[18:01:07.589]                 if (length(args) > 0) 
[18:01:07.589]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.589]             }
[18:01:07.589]             else {
[18:01:07.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.589]             }
[18:01:07.589]             {
[18:01:07.589]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.589]                   0L) {
[18:01:07.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.589]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.589]                   base::options(opts)
[18:01:07.589]                 }
[18:01:07.589]                 {
[18:01:07.589]                   {
[18:01:07.589]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.589]                     NULL
[18:01:07.589]                   }
[18:01:07.589]                   options(future.plan = NULL)
[18:01:07.589]                   if (is.na(NA_character_)) 
[18:01:07.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.589]                     .init = FALSE)
[18:01:07.589]                 }
[18:01:07.589]             }
[18:01:07.589]         }
[18:01:07.589]     })
[18:01:07.589]     if (TRUE) {
[18:01:07.589]         base::sink(type = "output", split = FALSE)
[18:01:07.589]         if (TRUE) {
[18:01:07.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.589]         }
[18:01:07.589]         else {
[18:01:07.589]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.589]         }
[18:01:07.589]         base::close(...future.stdout)
[18:01:07.589]         ...future.stdout <- NULL
[18:01:07.589]     }
[18:01:07.589]     ...future.result$conditions <- ...future.conditions
[18:01:07.589]     ...future.result$finished <- base::Sys.time()
[18:01:07.589]     ...future.result
[18:01:07.589] }
[18:01:07.594] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[18:01:07.594] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:07.595] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:07.596] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:07.597] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.597] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[18:01:07.598] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[18:01:07.598] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:07.599] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:07.600] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.601] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[18:01:07.602] MultisessionFuture started
[18:01:07.603] - Launch lazy future ... done
[18:01:07.603] run() for ‘MultisessionFuture’ ... done
[18:01:07.603] Created future:
[18:01:07.603] MultisessionFuture:
[18:01:07.603] Label: ‘future_.mapply-1’
[18:01:07.603] Expression:
[18:01:07.603] {
[18:01:07.603]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.603]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.603]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.603]         on.exit(options(oopts), add = TRUE)
[18:01:07.603]     }
[18:01:07.603]     {
[18:01:07.603]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.603]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.603]         do.call(mapply, args = args)
[18:01:07.603]     }
[18:01:07.603] }
[18:01:07.603] Lazy evaluation: FALSE
[18:01:07.603] Asynchronous evaluation: TRUE
[18:01:07.603] Local evaluation: TRUE
[18:01:07.603] Environment: R_GlobalEnv
[18:01:07.603] Capture standard output: TRUE
[18:01:07.603] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.603] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.603] Packages: <none>
[18:01:07.603] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.603] Resolved: FALSE
[18:01:07.603] Value: <not collected>
[18:01:07.603] Conditions captured: <none>
[18:01:07.603] Early signaling: FALSE
[18:01:07.603] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.603] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.616] Chunk #1 of 2 ... DONE
[18:01:07.617] Chunk #2 of 2 ...
[18:01:07.617]  - Finding globals in '...' for chunk #2 ...
[18:01:07.617] getGlobalsAndPackages() ...
[18:01:07.617] Searching for globals...
[18:01:07.618] 
[18:01:07.618] Searching for globals ... DONE
[18:01:07.618] - globals: [0] <none>
[18:01:07.619] getGlobalsAndPackages() ... DONE
[18:01:07.619]    + additional globals found: [n=0] 
[18:01:07.619]    + additional namespaces needed: [n=0] 
[18:01:07.619]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:07.619]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.620]  - seeds: <none>
[18:01:07.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.620] getGlobalsAndPackages() ...
[18:01:07.620] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.620] Resolving globals: FALSE
[18:01:07.621] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:07.622] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:07.622] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.623] 
[18:01:07.623] getGlobalsAndPackages() ... DONE
[18:01:07.623] run() for ‘Future’ ...
[18:01:07.624] - state: ‘created’
[18:01:07.624] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.650]   - Field: ‘node’
[18:01:07.650]   - Field: ‘label’
[18:01:07.650]   - Field: ‘local’
[18:01:07.650]   - Field: ‘owner’
[18:01:07.650]   - Field: ‘envir’
[18:01:07.651]   - Field: ‘workers’
[18:01:07.651]   - Field: ‘packages’
[18:01:07.651]   - Field: ‘gc’
[18:01:07.651]   - Field: ‘conditions’
[18:01:07.651]   - Field: ‘persistent’
[18:01:07.652]   - Field: ‘expr’
[18:01:07.652]   - Field: ‘uuid’
[18:01:07.652]   - Field: ‘seed’
[18:01:07.652]   - Field: ‘version’
[18:01:07.652]   - Field: ‘result’
[18:01:07.653]   - Field: ‘asynchronous’
[18:01:07.653]   - Field: ‘calls’
[18:01:07.653]   - Field: ‘globals’
[18:01:07.653]   - Field: ‘stdout’
[18:01:07.653]   - Field: ‘earlySignal’
[18:01:07.654]   - Field: ‘lazy’
[18:01:07.654]   - Field: ‘state’
[18:01:07.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.654] - Launch lazy future ...
[18:01:07.655] Packages needed by the future expression (n = 0): <none>
[18:01:07.655] Packages needed by future strategies (n = 0): <none>
[18:01:07.656] {
[18:01:07.656]     {
[18:01:07.656]         {
[18:01:07.656]             ...future.startTime <- base::Sys.time()
[18:01:07.656]             {
[18:01:07.656]                 {
[18:01:07.656]                   {
[18:01:07.656]                     {
[18:01:07.656]                       base::local({
[18:01:07.656]                         has_future <- base::requireNamespace("future", 
[18:01:07.656]                           quietly = TRUE)
[18:01:07.656]                         if (has_future) {
[18:01:07.656]                           ns <- base::getNamespace("future")
[18:01:07.656]                           version <- ns[[".package"]][["version"]]
[18:01:07.656]                           if (is.null(version)) 
[18:01:07.656]                             version <- utils::packageVersion("future")
[18:01:07.656]                         }
[18:01:07.656]                         else {
[18:01:07.656]                           version <- NULL
[18:01:07.656]                         }
[18:01:07.656]                         if (!has_future || version < "1.8.0") {
[18:01:07.656]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.656]                             "", base::R.version$version.string), 
[18:01:07.656]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.656]                               "release", "version")], collapse = " "), 
[18:01:07.656]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.656]                             info)
[18:01:07.656]                           info <- base::paste(info, collapse = "; ")
[18:01:07.656]                           if (!has_future) {
[18:01:07.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.656]                               info)
[18:01:07.656]                           }
[18:01:07.656]                           else {
[18:01:07.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.656]                               info, version)
[18:01:07.656]                           }
[18:01:07.656]                           base::stop(msg)
[18:01:07.656]                         }
[18:01:07.656]                       })
[18:01:07.656]                     }
[18:01:07.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.656]                     base::options(mc.cores = 1L)
[18:01:07.656]                   }
[18:01:07.656]                   ...future.strategy.old <- future::plan("list")
[18:01:07.656]                   options(future.plan = NULL)
[18:01:07.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.656]                 }
[18:01:07.656]                 ...future.workdir <- getwd()
[18:01:07.656]             }
[18:01:07.656]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.656]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.656]         }
[18:01:07.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.656]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.656]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.656]             base::names(...future.oldOptions))
[18:01:07.656]     }
[18:01:07.656]     if (FALSE) {
[18:01:07.656]     }
[18:01:07.656]     else {
[18:01:07.656]         if (TRUE) {
[18:01:07.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.656]                 open = "w")
[18:01:07.656]         }
[18:01:07.656]         else {
[18:01:07.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.656]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.656]         }
[18:01:07.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.656]             base::sink(type = "output", split = FALSE)
[18:01:07.656]             base::close(...future.stdout)
[18:01:07.656]         }, add = TRUE)
[18:01:07.656]     }
[18:01:07.656]     ...future.frame <- base::sys.nframe()
[18:01:07.656]     ...future.conditions <- base::list()
[18:01:07.656]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.656]     if (FALSE) {
[18:01:07.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.656]     }
[18:01:07.656]     ...future.result <- base::tryCatch({
[18:01:07.656]         base::withCallingHandlers({
[18:01:07.656]             ...future.value <- base::withVisible(base::local({
[18:01:07.656]                 ...future.makeSendCondition <- base::local({
[18:01:07.656]                   sendCondition <- NULL
[18:01:07.656]                   function(frame = 1L) {
[18:01:07.656]                     if (is.function(sendCondition)) 
[18:01:07.656]                       return(sendCondition)
[18:01:07.656]                     ns <- getNamespace("parallel")
[18:01:07.656]                     if (exists("sendData", mode = "function", 
[18:01:07.656]                       envir = ns)) {
[18:01:07.656]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.656]                         envir = ns)
[18:01:07.656]                       envir <- sys.frame(frame)
[18:01:07.656]                       master <- NULL
[18:01:07.656]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.656]                         !identical(envir, emptyenv())) {
[18:01:07.656]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.656]                           inherits = FALSE)) {
[18:01:07.656]                           master <- get("master", mode = "list", 
[18:01:07.656]                             envir = envir, inherits = FALSE)
[18:01:07.656]                           if (inherits(master, c("SOCKnode", 
[18:01:07.656]                             "SOCK0node"))) {
[18:01:07.656]                             sendCondition <<- function(cond) {
[18:01:07.656]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.656]                                 success = TRUE)
[18:01:07.656]                               parallel_sendData(master, data)
[18:01:07.656]                             }
[18:01:07.656]                             return(sendCondition)
[18:01:07.656]                           }
[18:01:07.656]                         }
[18:01:07.656]                         frame <- frame + 1L
[18:01:07.656]                         envir <- sys.frame(frame)
[18:01:07.656]                       }
[18:01:07.656]                     }
[18:01:07.656]                     sendCondition <<- function(cond) NULL
[18:01:07.656]                   }
[18:01:07.656]                 })
[18:01:07.656]                 withCallingHandlers({
[18:01:07.656]                   {
[18:01:07.656]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.656]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.656]                       ...future.globals.maxSize)) {
[18:01:07.656]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.656]                       on.exit(options(oopts), add = TRUE)
[18:01:07.656]                     }
[18:01:07.656]                     {
[18:01:07.656]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.656]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.656]                         USE.NAMES = FALSE)
[18:01:07.656]                       do.call(mapply, args = args)
[18:01:07.656]                     }
[18:01:07.656]                   }
[18:01:07.656]                 }, immediateCondition = function(cond) {
[18:01:07.656]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.656]                   sendCondition(cond)
[18:01:07.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.656]                   {
[18:01:07.656]                     inherits <- base::inherits
[18:01:07.656]                     invokeRestart <- base::invokeRestart
[18:01:07.656]                     is.null <- base::is.null
[18:01:07.656]                     muffled <- FALSE
[18:01:07.656]                     if (inherits(cond, "message")) {
[18:01:07.656]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.656]                       if (muffled) 
[18:01:07.656]                         invokeRestart("muffleMessage")
[18:01:07.656]                     }
[18:01:07.656]                     else if (inherits(cond, "warning")) {
[18:01:07.656]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.656]                       if (muffled) 
[18:01:07.656]                         invokeRestart("muffleWarning")
[18:01:07.656]                     }
[18:01:07.656]                     else if (inherits(cond, "condition")) {
[18:01:07.656]                       if (!is.null(pattern)) {
[18:01:07.656]                         computeRestarts <- base::computeRestarts
[18:01:07.656]                         grepl <- base::grepl
[18:01:07.656]                         restarts <- computeRestarts(cond)
[18:01:07.656]                         for (restart in restarts) {
[18:01:07.656]                           name <- restart$name
[18:01:07.656]                           if (is.null(name)) 
[18:01:07.656]                             next
[18:01:07.656]                           if (!grepl(pattern, name)) 
[18:01:07.656]                             next
[18:01:07.656]                           invokeRestart(restart)
[18:01:07.656]                           muffled <- TRUE
[18:01:07.656]                           break
[18:01:07.656]                         }
[18:01:07.656]                       }
[18:01:07.656]                     }
[18:01:07.656]                     invisible(muffled)
[18:01:07.656]                   }
[18:01:07.656]                   muffleCondition(cond)
[18:01:07.656]                 })
[18:01:07.656]             }))
[18:01:07.656]             future::FutureResult(value = ...future.value$value, 
[18:01:07.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.656]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.656]                     ...future.globalenv.names))
[18:01:07.656]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.656]         }, condition = base::local({
[18:01:07.656]             c <- base::c
[18:01:07.656]             inherits <- base::inherits
[18:01:07.656]             invokeRestart <- base::invokeRestart
[18:01:07.656]             length <- base::length
[18:01:07.656]             list <- base::list
[18:01:07.656]             seq.int <- base::seq.int
[18:01:07.656]             signalCondition <- base::signalCondition
[18:01:07.656]             sys.calls <- base::sys.calls
[18:01:07.656]             `[[` <- base::`[[`
[18:01:07.656]             `+` <- base::`+`
[18:01:07.656]             `<<-` <- base::`<<-`
[18:01:07.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.656]                   3L)]
[18:01:07.656]             }
[18:01:07.656]             function(cond) {
[18:01:07.656]                 is_error <- inherits(cond, "error")
[18:01:07.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.656]                   NULL)
[18:01:07.656]                 if (is_error) {
[18:01:07.656]                   sessionInformation <- function() {
[18:01:07.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.656]                       search = base::search(), system = base::Sys.info())
[18:01:07.656]                   }
[18:01:07.656]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.656]                     cond$call), session = sessionInformation(), 
[18:01:07.656]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.656]                   signalCondition(cond)
[18:01:07.656]                 }
[18:01:07.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.656]                 "immediateCondition"))) {
[18:01:07.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.656]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.656]                   if (TRUE && !signal) {
[18:01:07.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.656]                     {
[18:01:07.656]                       inherits <- base::inherits
[18:01:07.656]                       invokeRestart <- base::invokeRestart
[18:01:07.656]                       is.null <- base::is.null
[18:01:07.656]                       muffled <- FALSE
[18:01:07.656]                       if (inherits(cond, "message")) {
[18:01:07.656]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.656]                         if (muffled) 
[18:01:07.656]                           invokeRestart("muffleMessage")
[18:01:07.656]                       }
[18:01:07.656]                       else if (inherits(cond, "warning")) {
[18:01:07.656]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.656]                         if (muffled) 
[18:01:07.656]                           invokeRestart("muffleWarning")
[18:01:07.656]                       }
[18:01:07.656]                       else if (inherits(cond, "condition")) {
[18:01:07.656]                         if (!is.null(pattern)) {
[18:01:07.656]                           computeRestarts <- base::computeRestarts
[18:01:07.656]                           grepl <- base::grepl
[18:01:07.656]                           restarts <- computeRestarts(cond)
[18:01:07.656]                           for (restart in restarts) {
[18:01:07.656]                             name <- restart$name
[18:01:07.656]                             if (is.null(name)) 
[18:01:07.656]                               next
[18:01:07.656]                             if (!grepl(pattern, name)) 
[18:01:07.656]                               next
[18:01:07.656]                             invokeRestart(restart)
[18:01:07.656]                             muffled <- TRUE
[18:01:07.656]                             break
[18:01:07.656]                           }
[18:01:07.656]                         }
[18:01:07.656]                       }
[18:01:07.656]                       invisible(muffled)
[18:01:07.656]                     }
[18:01:07.656]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.656]                   }
[18:01:07.656]                 }
[18:01:07.656]                 else {
[18:01:07.656]                   if (TRUE) {
[18:01:07.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.656]                     {
[18:01:07.656]                       inherits <- base::inherits
[18:01:07.656]                       invokeRestart <- base::invokeRestart
[18:01:07.656]                       is.null <- base::is.null
[18:01:07.656]                       muffled <- FALSE
[18:01:07.656]                       if (inherits(cond, "message")) {
[18:01:07.656]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.656]                         if (muffled) 
[18:01:07.656]                           invokeRestart("muffleMessage")
[18:01:07.656]                       }
[18:01:07.656]                       else if (inherits(cond, "warning")) {
[18:01:07.656]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.656]                         if (muffled) 
[18:01:07.656]                           invokeRestart("muffleWarning")
[18:01:07.656]                       }
[18:01:07.656]                       else if (inherits(cond, "condition")) {
[18:01:07.656]                         if (!is.null(pattern)) {
[18:01:07.656]                           computeRestarts <- base::computeRestarts
[18:01:07.656]                           grepl <- base::grepl
[18:01:07.656]                           restarts <- computeRestarts(cond)
[18:01:07.656]                           for (restart in restarts) {
[18:01:07.656]                             name <- restart$name
[18:01:07.656]                             if (is.null(name)) 
[18:01:07.656]                               next
[18:01:07.656]                             if (!grepl(pattern, name)) 
[18:01:07.656]                               next
[18:01:07.656]                             invokeRestart(restart)
[18:01:07.656]                             muffled <- TRUE
[18:01:07.656]                             break
[18:01:07.656]                           }
[18:01:07.656]                         }
[18:01:07.656]                       }
[18:01:07.656]                       invisible(muffled)
[18:01:07.656]                     }
[18:01:07.656]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.656]                   }
[18:01:07.656]                 }
[18:01:07.656]             }
[18:01:07.656]         }))
[18:01:07.656]     }, error = function(ex) {
[18:01:07.656]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.656]                 ...future.rng), started = ...future.startTime, 
[18:01:07.656]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.656]             version = "1.8"), class = "FutureResult")
[18:01:07.656]     }, finally = {
[18:01:07.656]         if (!identical(...future.workdir, getwd())) 
[18:01:07.656]             setwd(...future.workdir)
[18:01:07.656]         {
[18:01:07.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.656]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.656]             }
[18:01:07.656]             base::options(...future.oldOptions)
[18:01:07.656]             if (.Platform$OS.type == "windows") {
[18:01:07.656]                 old_names <- names(...future.oldEnvVars)
[18:01:07.656]                 envs <- base::Sys.getenv()
[18:01:07.656]                 names <- names(envs)
[18:01:07.656]                 common <- intersect(names, old_names)
[18:01:07.656]                 added <- setdiff(names, old_names)
[18:01:07.656]                 removed <- setdiff(old_names, names)
[18:01:07.656]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.656]                   envs[common]]
[18:01:07.656]                 NAMES <- toupper(changed)
[18:01:07.656]                 args <- list()
[18:01:07.656]                 for (kk in seq_along(NAMES)) {
[18:01:07.656]                   name <- changed[[kk]]
[18:01:07.656]                   NAME <- NAMES[[kk]]
[18:01:07.656]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.656]                     next
[18:01:07.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.656]                 }
[18:01:07.656]                 NAMES <- toupper(added)
[18:01:07.656]                 for (kk in seq_along(NAMES)) {
[18:01:07.656]                   name <- added[[kk]]
[18:01:07.656]                   NAME <- NAMES[[kk]]
[18:01:07.656]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.656]                     next
[18:01:07.656]                   args[[name]] <- ""
[18:01:07.656]                 }
[18:01:07.656]                 NAMES <- toupper(removed)
[18:01:07.656]                 for (kk in seq_along(NAMES)) {
[18:01:07.656]                   name <- removed[[kk]]
[18:01:07.656]                   NAME <- NAMES[[kk]]
[18:01:07.656]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.656]                     next
[18:01:07.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.656]                 }
[18:01:07.656]                 if (length(args) > 0) 
[18:01:07.656]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.656]             }
[18:01:07.656]             else {
[18:01:07.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.656]             }
[18:01:07.656]             {
[18:01:07.656]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.656]                   0L) {
[18:01:07.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.656]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.656]                   base::options(opts)
[18:01:07.656]                 }
[18:01:07.656]                 {
[18:01:07.656]                   {
[18:01:07.656]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.656]                     NULL
[18:01:07.656]                   }
[18:01:07.656]                   options(future.plan = NULL)
[18:01:07.656]                   if (is.na(NA_character_)) 
[18:01:07.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.656]                     .init = FALSE)
[18:01:07.656]                 }
[18:01:07.656]             }
[18:01:07.656]         }
[18:01:07.656]     })
[18:01:07.656]     if (TRUE) {
[18:01:07.656]         base::sink(type = "output", split = FALSE)
[18:01:07.656]         if (TRUE) {
[18:01:07.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.656]         }
[18:01:07.656]         else {
[18:01:07.656]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.656]         }
[18:01:07.656]         base::close(...future.stdout)
[18:01:07.656]         ...future.stdout <- NULL
[18:01:07.656]     }
[18:01:07.656]     ...future.result$conditions <- ...future.conditions
[18:01:07.656]     ...future.result$finished <- base::Sys.time()
[18:01:07.656]     ...future.result
[18:01:07.656] }
[18:01:07.662] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[18:01:07.662] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:07.663] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:07.663] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:07.664] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.664] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[18:01:07.665] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[18:01:07.665] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:07.666] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.666] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:07.667] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.667] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[18:01:07.668] MultisessionFuture started
[18:01:07.668] - Launch lazy future ... done
[18:01:07.669] run() for ‘MultisessionFuture’ ... done
[18:01:07.669] Created future:
[18:01:07.669] MultisessionFuture:
[18:01:07.669] Label: ‘future_.mapply-2’
[18:01:07.669] Expression:
[18:01:07.669] {
[18:01:07.669]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.669]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.669]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.669]         on.exit(options(oopts), add = TRUE)
[18:01:07.669]     }
[18:01:07.669]     {
[18:01:07.669]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.669]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.669]         do.call(mapply, args = args)
[18:01:07.669]     }
[18:01:07.669] }
[18:01:07.669] Lazy evaluation: FALSE
[18:01:07.669] Asynchronous evaluation: TRUE
[18:01:07.669] Local evaluation: TRUE
[18:01:07.669] Environment: R_GlobalEnv
[18:01:07.669] Capture standard output: TRUE
[18:01:07.669] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.669] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.669] Packages: <none>
[18:01:07.669] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.669] Resolved: FALSE
[18:01:07.669] Value: <not collected>
[18:01:07.669] Conditions captured: <none>
[18:01:07.669] Early signaling: FALSE
[18:01:07.669] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.669] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.682] Chunk #2 of 2 ... DONE
[18:01:07.682] Launching 2 futures (chunks) ... DONE
[18:01:07.682] Resolving 2 futures (chunks) ...
[18:01:07.682] resolve() on list ...
[18:01:07.683]  recursive: 0
[18:01:07.683]  length: 2
[18:01:07.683] 
[18:01:07.684] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.684] - Validating connection of MultisessionFuture
[18:01:07.684] - received message: FutureResult
[18:01:07.685] - Received FutureResult
[18:01:07.685] - Erased future from FutureRegistry
[18:01:07.685] result() for ClusterFuture ...
[18:01:07.685] - result already collected: FutureResult
[18:01:07.685] result() for ClusterFuture ... done
[18:01:07.686] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.686] Future #1
[18:01:07.686] result() for ClusterFuture ...
[18:01:07.686] - result already collected: FutureResult
[18:01:07.686] result() for ClusterFuture ... done
[18:01:07.686] result() for ClusterFuture ...
[18:01:07.687] - result already collected: FutureResult
[18:01:07.687] result() for ClusterFuture ... done
[18:01:07.687] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:07.687] - nx: 2
[18:01:07.687] - relay: TRUE
[18:01:07.688] - stdout: TRUE
[18:01:07.688] - signal: TRUE
[18:01:07.688] - resignal: FALSE
[18:01:07.688] - force: TRUE
[18:01:07.688] - relayed: [n=2] FALSE, FALSE
[18:01:07.688] - queued futures: [n=2] FALSE, FALSE
[18:01:07.689]  - until=1
[18:01:07.689]  - relaying element #1
[18:01:07.689] result() for ClusterFuture ...
[18:01:07.689] - result already collected: FutureResult
[18:01:07.689] result() for ClusterFuture ... done
[18:01:07.690] result() for ClusterFuture ...
[18:01:07.690] - result already collected: FutureResult
[18:01:07.690] result() for ClusterFuture ... done
[18:01:07.690] result() for ClusterFuture ...
[18:01:07.690] - result already collected: FutureResult
[18:01:07.690] result() for ClusterFuture ... done
[18:01:07.691] result() for ClusterFuture ...
[18:01:07.691] - result already collected: FutureResult
[18:01:07.691] result() for ClusterFuture ... done
[18:01:07.691] - relayed: [n=2] TRUE, FALSE
[18:01:07.691] - queued futures: [n=2] TRUE, FALSE
[18:01:07.692] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:07.692]  length: 1 (resolved future 1)
[18:01:07.714] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.714] - Validating connection of MultisessionFuture
[18:01:07.715] - received message: FutureResult
[18:01:07.715] - Received FutureResult
[18:01:07.715] - Erased future from FutureRegistry
[18:01:07.715] result() for ClusterFuture ...
[18:01:07.715] - result already collected: FutureResult
[18:01:07.716] result() for ClusterFuture ... done
[18:01:07.716] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.716] Future #2
[18:01:07.716] result() for ClusterFuture ...
[18:01:07.716] - result already collected: FutureResult
[18:01:07.717] result() for ClusterFuture ... done
[18:01:07.717] result() for ClusterFuture ...
[18:01:07.717] - result already collected: FutureResult
[18:01:07.717] result() for ClusterFuture ... done
[18:01:07.717] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:07.717] - nx: 2
[18:01:07.718] - relay: TRUE
[18:01:07.718] - stdout: TRUE
[18:01:07.718] - signal: TRUE
[18:01:07.718] - resignal: FALSE
[18:01:07.718] - force: TRUE
[18:01:07.718] - relayed: [n=2] TRUE, FALSE
[18:01:07.719] - queued futures: [n=2] TRUE, FALSE
[18:01:07.719]  - until=2
[18:01:07.719]  - relaying element #2
[18:01:07.719] result() for ClusterFuture ...
[18:01:07.719] - result already collected: FutureResult
[18:01:07.720] result() for ClusterFuture ... done
[18:01:07.720] result() for ClusterFuture ...
[18:01:07.720] - result already collected: FutureResult
[18:01:07.720] result() for ClusterFuture ... done
[18:01:07.720] result() for ClusterFuture ...
[18:01:07.721] - result already collected: FutureResult
[18:01:07.721] result() for ClusterFuture ... done
[18:01:07.721] result() for ClusterFuture ...
[18:01:07.721] - result already collected: FutureResult
[18:01:07.721] result() for ClusterFuture ... done
[18:01:07.721] - relayed: [n=2] TRUE, TRUE
[18:01:07.722] - queued futures: [n=2] TRUE, TRUE
[18:01:07.722] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:07.722]  length: 0 (resolved future 2)
[18:01:07.722] Relaying remaining futures
[18:01:07.722] signalConditionsASAP(NULL, pos=0) ...
[18:01:07.723] - nx: 2
[18:01:07.723] - relay: TRUE
[18:01:07.723] - stdout: TRUE
[18:01:07.723] - signal: TRUE
[18:01:07.723] - resignal: FALSE
[18:01:07.723] - force: TRUE
[18:01:07.724] - relayed: [n=2] TRUE, TRUE
[18:01:07.724] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:07.724] - relayed: [n=2] TRUE, TRUE
[18:01:07.724] - queued futures: [n=2] TRUE, TRUE
[18:01:07.724] signalConditionsASAP(NULL, pos=0) ... done
[18:01:07.725] resolve() on list ... DONE
[18:01:07.725] result() for ClusterFuture ...
[18:01:07.725] - result already collected: FutureResult
[18:01:07.725] result() for ClusterFuture ... done
[18:01:07.725] result() for ClusterFuture ...
[18:01:07.726] - result already collected: FutureResult
[18:01:07.726] result() for ClusterFuture ... done
[18:01:07.726] result() for ClusterFuture ...
[18:01:07.726] - result already collected: FutureResult
[18:01:07.726] result() for ClusterFuture ... done
[18:01:07.726] result() for ClusterFuture ...
[18:01:07.727] - result already collected: FutureResult
[18:01:07.727] result() for ClusterFuture ... done
[18:01:07.727]  - Number of value chunks collected: 2
[18:01:07.727] Resolving 2 futures (chunks) ... DONE
[18:01:07.727] Reducing values from 2 chunks ...
[18:01:07.728]  - Number of values collected after concatenation: 5
[18:01:07.728]  - Number of values expected: 5
[18:01:07.728] Reducing values from 2 chunks ... DONE
[18:01:07.728] future_mapply() ... DONE
[18:01:07.729] future_mapply() ...
[18:01:07.735] Number of chunks: 2
[18:01:07.735] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[18:01:07.735] getGlobalsAndPackagesXApply() ...
[18:01:07.736]  - future.globals: TRUE
[18:01:07.736] getGlobalsAndPackages() ...
[18:01:07.736] Searching for globals...
[18:01:07.738] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:07.739] Searching for globals ... DONE
[18:01:07.739] Resolving globals: FALSE
[18:01:07.740] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:07.740] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:07.740] - globals: [1] ‘FUN’
[18:01:07.741] 
[18:01:07.741] getGlobalsAndPackages() ... DONE
[18:01:07.741]  - globals found/used: [n=1] ‘FUN’
[18:01:07.741]  - needed namespaces: [n=0] 
[18:01:07.741] Finding globals ... DONE
[18:01:07.742] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:07.742] List of 2
[18:01:07.742]  $ ...future.FUN:function (C, k)  
[18:01:07.742]  $ MoreArgs     : NULL
[18:01:07.742]  - attr(*, "where")=List of 2
[18:01:07.742]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:07.742]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:07.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:07.742]  - attr(*, "resolved")= logi FALSE
[18:01:07.742]  - attr(*, "total_size")= num NA
[18:01:07.747] Packages to be attached in all futures: [n=0] 
[18:01:07.747] getGlobalsAndPackagesXApply() ... DONE
[18:01:07.747] Number of futures (= number of chunks): 2
[18:01:07.748] Launching 2 futures (chunks) ...
[18:01:07.748] Chunk #1 of 2 ...
[18:01:07.748]  - Finding globals in '...' for chunk #1 ...
[18:01:07.748] getGlobalsAndPackages() ...
[18:01:07.748] Searching for globals...
[18:01:07.749] 
[18:01:07.749] Searching for globals ... DONE
[18:01:07.750] - globals: [0] <none>
[18:01:07.750] getGlobalsAndPackages() ... DONE
[18:01:07.750]    + additional globals found: [n=0] 
[18:01:07.750]    + additional namespaces needed: [n=0] 
[18:01:07.750]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:07.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.751]  - seeds: <none>
[18:01:07.751]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.751] getGlobalsAndPackages() ...
[18:01:07.751] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.751] Resolving globals: FALSE
[18:01:07.755] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:07.756] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:07.756] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.757] 
[18:01:07.757] getGlobalsAndPackages() ... DONE
[18:01:07.757] run() for ‘Future’ ...
[18:01:07.758] - state: ‘created’
[18:01:07.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.781] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.781]   - Field: ‘node’
[18:01:07.781]   - Field: ‘label’
[18:01:07.781]   - Field: ‘local’
[18:01:07.781]   - Field: ‘owner’
[18:01:07.782]   - Field: ‘envir’
[18:01:07.782]   - Field: ‘workers’
[18:01:07.782]   - Field: ‘packages’
[18:01:07.782]   - Field: ‘gc’
[18:01:07.782]   - Field: ‘conditions’
[18:01:07.783]   - Field: ‘persistent’
[18:01:07.783]   - Field: ‘expr’
[18:01:07.783]   - Field: ‘uuid’
[18:01:07.783]   - Field: ‘seed’
[18:01:07.783]   - Field: ‘version’
[18:01:07.784]   - Field: ‘result’
[18:01:07.784]   - Field: ‘asynchronous’
[18:01:07.784]   - Field: ‘calls’
[18:01:07.784]   - Field: ‘globals’
[18:01:07.784]   - Field: ‘stdout’
[18:01:07.784]   - Field: ‘earlySignal’
[18:01:07.785]   - Field: ‘lazy’
[18:01:07.785]   - Field: ‘state’
[18:01:07.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.785] - Launch lazy future ...
[18:01:07.786] Packages needed by the future expression (n = 0): <none>
[18:01:07.786] Packages needed by future strategies (n = 0): <none>
[18:01:07.787] {
[18:01:07.787]     {
[18:01:07.787]         {
[18:01:07.787]             ...future.startTime <- base::Sys.time()
[18:01:07.787]             {
[18:01:07.787]                 {
[18:01:07.787]                   {
[18:01:07.787]                     {
[18:01:07.787]                       base::local({
[18:01:07.787]                         has_future <- base::requireNamespace("future", 
[18:01:07.787]                           quietly = TRUE)
[18:01:07.787]                         if (has_future) {
[18:01:07.787]                           ns <- base::getNamespace("future")
[18:01:07.787]                           version <- ns[[".package"]][["version"]]
[18:01:07.787]                           if (is.null(version)) 
[18:01:07.787]                             version <- utils::packageVersion("future")
[18:01:07.787]                         }
[18:01:07.787]                         else {
[18:01:07.787]                           version <- NULL
[18:01:07.787]                         }
[18:01:07.787]                         if (!has_future || version < "1.8.0") {
[18:01:07.787]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.787]                             "", base::R.version$version.string), 
[18:01:07.787]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.787]                               "release", "version")], collapse = " "), 
[18:01:07.787]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.787]                             info)
[18:01:07.787]                           info <- base::paste(info, collapse = "; ")
[18:01:07.787]                           if (!has_future) {
[18:01:07.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.787]                               info)
[18:01:07.787]                           }
[18:01:07.787]                           else {
[18:01:07.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.787]                               info, version)
[18:01:07.787]                           }
[18:01:07.787]                           base::stop(msg)
[18:01:07.787]                         }
[18:01:07.787]                       })
[18:01:07.787]                     }
[18:01:07.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.787]                     base::options(mc.cores = 1L)
[18:01:07.787]                   }
[18:01:07.787]                   ...future.strategy.old <- future::plan("list")
[18:01:07.787]                   options(future.plan = NULL)
[18:01:07.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.787]                 }
[18:01:07.787]                 ...future.workdir <- getwd()
[18:01:07.787]             }
[18:01:07.787]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.787]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.787]         }
[18:01:07.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.787]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.787]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.787]             base::names(...future.oldOptions))
[18:01:07.787]     }
[18:01:07.787]     if (FALSE) {
[18:01:07.787]     }
[18:01:07.787]     else {
[18:01:07.787]         if (TRUE) {
[18:01:07.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.787]                 open = "w")
[18:01:07.787]         }
[18:01:07.787]         else {
[18:01:07.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.787]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.787]         }
[18:01:07.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.787]             base::sink(type = "output", split = FALSE)
[18:01:07.787]             base::close(...future.stdout)
[18:01:07.787]         }, add = TRUE)
[18:01:07.787]     }
[18:01:07.787]     ...future.frame <- base::sys.nframe()
[18:01:07.787]     ...future.conditions <- base::list()
[18:01:07.787]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.787]     if (FALSE) {
[18:01:07.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.787]     }
[18:01:07.787]     ...future.result <- base::tryCatch({
[18:01:07.787]         base::withCallingHandlers({
[18:01:07.787]             ...future.value <- base::withVisible(base::local({
[18:01:07.787]                 ...future.makeSendCondition <- base::local({
[18:01:07.787]                   sendCondition <- NULL
[18:01:07.787]                   function(frame = 1L) {
[18:01:07.787]                     if (is.function(sendCondition)) 
[18:01:07.787]                       return(sendCondition)
[18:01:07.787]                     ns <- getNamespace("parallel")
[18:01:07.787]                     if (exists("sendData", mode = "function", 
[18:01:07.787]                       envir = ns)) {
[18:01:07.787]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.787]                         envir = ns)
[18:01:07.787]                       envir <- sys.frame(frame)
[18:01:07.787]                       master <- NULL
[18:01:07.787]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.787]                         !identical(envir, emptyenv())) {
[18:01:07.787]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.787]                           inherits = FALSE)) {
[18:01:07.787]                           master <- get("master", mode = "list", 
[18:01:07.787]                             envir = envir, inherits = FALSE)
[18:01:07.787]                           if (inherits(master, c("SOCKnode", 
[18:01:07.787]                             "SOCK0node"))) {
[18:01:07.787]                             sendCondition <<- function(cond) {
[18:01:07.787]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.787]                                 success = TRUE)
[18:01:07.787]                               parallel_sendData(master, data)
[18:01:07.787]                             }
[18:01:07.787]                             return(sendCondition)
[18:01:07.787]                           }
[18:01:07.787]                         }
[18:01:07.787]                         frame <- frame + 1L
[18:01:07.787]                         envir <- sys.frame(frame)
[18:01:07.787]                       }
[18:01:07.787]                     }
[18:01:07.787]                     sendCondition <<- function(cond) NULL
[18:01:07.787]                   }
[18:01:07.787]                 })
[18:01:07.787]                 withCallingHandlers({
[18:01:07.787]                   {
[18:01:07.787]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.787]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.787]                       ...future.globals.maxSize)) {
[18:01:07.787]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.787]                       on.exit(options(oopts), add = TRUE)
[18:01:07.787]                     }
[18:01:07.787]                     {
[18:01:07.787]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.787]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.787]                         USE.NAMES = FALSE)
[18:01:07.787]                       do.call(mapply, args = args)
[18:01:07.787]                     }
[18:01:07.787]                   }
[18:01:07.787]                 }, immediateCondition = function(cond) {
[18:01:07.787]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.787]                   sendCondition(cond)
[18:01:07.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.787]                   {
[18:01:07.787]                     inherits <- base::inherits
[18:01:07.787]                     invokeRestart <- base::invokeRestart
[18:01:07.787]                     is.null <- base::is.null
[18:01:07.787]                     muffled <- FALSE
[18:01:07.787]                     if (inherits(cond, "message")) {
[18:01:07.787]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.787]                       if (muffled) 
[18:01:07.787]                         invokeRestart("muffleMessage")
[18:01:07.787]                     }
[18:01:07.787]                     else if (inherits(cond, "warning")) {
[18:01:07.787]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.787]                       if (muffled) 
[18:01:07.787]                         invokeRestart("muffleWarning")
[18:01:07.787]                     }
[18:01:07.787]                     else if (inherits(cond, "condition")) {
[18:01:07.787]                       if (!is.null(pattern)) {
[18:01:07.787]                         computeRestarts <- base::computeRestarts
[18:01:07.787]                         grepl <- base::grepl
[18:01:07.787]                         restarts <- computeRestarts(cond)
[18:01:07.787]                         for (restart in restarts) {
[18:01:07.787]                           name <- restart$name
[18:01:07.787]                           if (is.null(name)) 
[18:01:07.787]                             next
[18:01:07.787]                           if (!grepl(pattern, name)) 
[18:01:07.787]                             next
[18:01:07.787]                           invokeRestart(restart)
[18:01:07.787]                           muffled <- TRUE
[18:01:07.787]                           break
[18:01:07.787]                         }
[18:01:07.787]                       }
[18:01:07.787]                     }
[18:01:07.787]                     invisible(muffled)
[18:01:07.787]                   }
[18:01:07.787]                   muffleCondition(cond)
[18:01:07.787]                 })
[18:01:07.787]             }))
[18:01:07.787]             future::FutureResult(value = ...future.value$value, 
[18:01:07.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.787]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.787]                     ...future.globalenv.names))
[18:01:07.787]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.787]         }, condition = base::local({
[18:01:07.787]             c <- base::c
[18:01:07.787]             inherits <- base::inherits
[18:01:07.787]             invokeRestart <- base::invokeRestart
[18:01:07.787]             length <- base::length
[18:01:07.787]             list <- base::list
[18:01:07.787]             seq.int <- base::seq.int
[18:01:07.787]             signalCondition <- base::signalCondition
[18:01:07.787]             sys.calls <- base::sys.calls
[18:01:07.787]             `[[` <- base::`[[`
[18:01:07.787]             `+` <- base::`+`
[18:01:07.787]             `<<-` <- base::`<<-`
[18:01:07.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.787]                   3L)]
[18:01:07.787]             }
[18:01:07.787]             function(cond) {
[18:01:07.787]                 is_error <- inherits(cond, "error")
[18:01:07.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.787]                   NULL)
[18:01:07.787]                 if (is_error) {
[18:01:07.787]                   sessionInformation <- function() {
[18:01:07.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.787]                       search = base::search(), system = base::Sys.info())
[18:01:07.787]                   }
[18:01:07.787]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.787]                     cond$call), session = sessionInformation(), 
[18:01:07.787]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.787]                   signalCondition(cond)
[18:01:07.787]                 }
[18:01:07.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.787]                 "immediateCondition"))) {
[18:01:07.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.787]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.787]                   if (TRUE && !signal) {
[18:01:07.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.787]                     {
[18:01:07.787]                       inherits <- base::inherits
[18:01:07.787]                       invokeRestart <- base::invokeRestart
[18:01:07.787]                       is.null <- base::is.null
[18:01:07.787]                       muffled <- FALSE
[18:01:07.787]                       if (inherits(cond, "message")) {
[18:01:07.787]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.787]                         if (muffled) 
[18:01:07.787]                           invokeRestart("muffleMessage")
[18:01:07.787]                       }
[18:01:07.787]                       else if (inherits(cond, "warning")) {
[18:01:07.787]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.787]                         if (muffled) 
[18:01:07.787]                           invokeRestart("muffleWarning")
[18:01:07.787]                       }
[18:01:07.787]                       else if (inherits(cond, "condition")) {
[18:01:07.787]                         if (!is.null(pattern)) {
[18:01:07.787]                           computeRestarts <- base::computeRestarts
[18:01:07.787]                           grepl <- base::grepl
[18:01:07.787]                           restarts <- computeRestarts(cond)
[18:01:07.787]                           for (restart in restarts) {
[18:01:07.787]                             name <- restart$name
[18:01:07.787]                             if (is.null(name)) 
[18:01:07.787]                               next
[18:01:07.787]                             if (!grepl(pattern, name)) 
[18:01:07.787]                               next
[18:01:07.787]                             invokeRestart(restart)
[18:01:07.787]                             muffled <- TRUE
[18:01:07.787]                             break
[18:01:07.787]                           }
[18:01:07.787]                         }
[18:01:07.787]                       }
[18:01:07.787]                       invisible(muffled)
[18:01:07.787]                     }
[18:01:07.787]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.787]                   }
[18:01:07.787]                 }
[18:01:07.787]                 else {
[18:01:07.787]                   if (TRUE) {
[18:01:07.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.787]                     {
[18:01:07.787]                       inherits <- base::inherits
[18:01:07.787]                       invokeRestart <- base::invokeRestart
[18:01:07.787]                       is.null <- base::is.null
[18:01:07.787]                       muffled <- FALSE
[18:01:07.787]                       if (inherits(cond, "message")) {
[18:01:07.787]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.787]                         if (muffled) 
[18:01:07.787]                           invokeRestart("muffleMessage")
[18:01:07.787]                       }
[18:01:07.787]                       else if (inherits(cond, "warning")) {
[18:01:07.787]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.787]                         if (muffled) 
[18:01:07.787]                           invokeRestart("muffleWarning")
[18:01:07.787]                       }
[18:01:07.787]                       else if (inherits(cond, "condition")) {
[18:01:07.787]                         if (!is.null(pattern)) {
[18:01:07.787]                           computeRestarts <- base::computeRestarts
[18:01:07.787]                           grepl <- base::grepl
[18:01:07.787]                           restarts <- computeRestarts(cond)
[18:01:07.787]                           for (restart in restarts) {
[18:01:07.787]                             name <- restart$name
[18:01:07.787]                             if (is.null(name)) 
[18:01:07.787]                               next
[18:01:07.787]                             if (!grepl(pattern, name)) 
[18:01:07.787]                               next
[18:01:07.787]                             invokeRestart(restart)
[18:01:07.787]                             muffled <- TRUE
[18:01:07.787]                             break
[18:01:07.787]                           }
[18:01:07.787]                         }
[18:01:07.787]                       }
[18:01:07.787]                       invisible(muffled)
[18:01:07.787]                     }
[18:01:07.787]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.787]                   }
[18:01:07.787]                 }
[18:01:07.787]             }
[18:01:07.787]         }))
[18:01:07.787]     }, error = function(ex) {
[18:01:07.787]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.787]                 ...future.rng), started = ...future.startTime, 
[18:01:07.787]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.787]             version = "1.8"), class = "FutureResult")
[18:01:07.787]     }, finally = {
[18:01:07.787]         if (!identical(...future.workdir, getwd())) 
[18:01:07.787]             setwd(...future.workdir)
[18:01:07.787]         {
[18:01:07.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.787]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.787]             }
[18:01:07.787]             base::options(...future.oldOptions)
[18:01:07.787]             if (.Platform$OS.type == "windows") {
[18:01:07.787]                 old_names <- names(...future.oldEnvVars)
[18:01:07.787]                 envs <- base::Sys.getenv()
[18:01:07.787]                 names <- names(envs)
[18:01:07.787]                 common <- intersect(names, old_names)
[18:01:07.787]                 added <- setdiff(names, old_names)
[18:01:07.787]                 removed <- setdiff(old_names, names)
[18:01:07.787]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.787]                   envs[common]]
[18:01:07.787]                 NAMES <- toupper(changed)
[18:01:07.787]                 args <- list()
[18:01:07.787]                 for (kk in seq_along(NAMES)) {
[18:01:07.787]                   name <- changed[[kk]]
[18:01:07.787]                   NAME <- NAMES[[kk]]
[18:01:07.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.787]                     next
[18:01:07.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.787]                 }
[18:01:07.787]                 NAMES <- toupper(added)
[18:01:07.787]                 for (kk in seq_along(NAMES)) {
[18:01:07.787]                   name <- added[[kk]]
[18:01:07.787]                   NAME <- NAMES[[kk]]
[18:01:07.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.787]                     next
[18:01:07.787]                   args[[name]] <- ""
[18:01:07.787]                 }
[18:01:07.787]                 NAMES <- toupper(removed)
[18:01:07.787]                 for (kk in seq_along(NAMES)) {
[18:01:07.787]                   name <- removed[[kk]]
[18:01:07.787]                   NAME <- NAMES[[kk]]
[18:01:07.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.787]                     next
[18:01:07.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.787]                 }
[18:01:07.787]                 if (length(args) > 0) 
[18:01:07.787]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.787]             }
[18:01:07.787]             else {
[18:01:07.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.787]             }
[18:01:07.787]             {
[18:01:07.787]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.787]                   0L) {
[18:01:07.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.787]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.787]                   base::options(opts)
[18:01:07.787]                 }
[18:01:07.787]                 {
[18:01:07.787]                   {
[18:01:07.787]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.787]                     NULL
[18:01:07.787]                   }
[18:01:07.787]                   options(future.plan = NULL)
[18:01:07.787]                   if (is.na(NA_character_)) 
[18:01:07.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.787]                     .init = FALSE)
[18:01:07.787]                 }
[18:01:07.787]             }
[18:01:07.787]         }
[18:01:07.787]     })
[18:01:07.787]     if (TRUE) {
[18:01:07.787]         base::sink(type = "output", split = FALSE)
[18:01:07.787]         if (TRUE) {
[18:01:07.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.787]         }
[18:01:07.787]         else {
[18:01:07.787]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.787]         }
[18:01:07.787]         base::close(...future.stdout)
[18:01:07.787]         ...future.stdout <- NULL
[18:01:07.787]     }
[18:01:07.787]     ...future.result$conditions <- ...future.conditions
[18:01:07.787]     ...future.result$finished <- base::Sys.time()
[18:01:07.787]     ...future.result
[18:01:07.787] }
[18:01:07.792] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[18:01:07.792] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:07.793] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:07.793] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:07.794] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.795] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[18:01:07.795] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[18:01:07.796] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:07.796] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.797] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:07.798] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.798] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[18:01:07.799] MultisessionFuture started
[18:01:07.799] - Launch lazy future ... done
[18:01:07.799] run() for ‘MultisessionFuture’ ... done
[18:01:07.799] Created future:
[18:01:07.800] MultisessionFuture:
[18:01:07.800] Label: ‘future_mapply-1’
[18:01:07.800] Expression:
[18:01:07.800] {
[18:01:07.800]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.800]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.800]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.800]         on.exit(options(oopts), add = TRUE)
[18:01:07.800]     }
[18:01:07.800]     {
[18:01:07.800]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.800]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.800]         do.call(mapply, args = args)
[18:01:07.800]     }
[18:01:07.800] }
[18:01:07.800] Lazy evaluation: FALSE
[18:01:07.800] Asynchronous evaluation: TRUE
[18:01:07.800] Local evaluation: TRUE
[18:01:07.800] Environment: R_GlobalEnv
[18:01:07.800] Capture standard output: TRUE
[18:01:07.800] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.800] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.800] Packages: <none>
[18:01:07.800] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.800] Resolved: FALSE
[18:01:07.800] Value: <not collected>
[18:01:07.800] Conditions captured: <none>
[18:01:07.800] Early signaling: FALSE
[18:01:07.800] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.800] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.812] Chunk #1 of 2 ... DONE
[18:01:07.812] Chunk #2 of 2 ...
[18:01:07.813]  - Finding globals in '...' for chunk #2 ...
[18:01:07.813] getGlobalsAndPackages() ...
[18:01:07.813] Searching for globals...
[18:01:07.814] 
[18:01:07.814] Searching for globals ... DONE
[18:01:07.814] - globals: [0] <none>
[18:01:07.814] getGlobalsAndPackages() ... DONE
[18:01:07.815]    + additional globals found: [n=0] 
[18:01:07.815]    + additional namespaces needed: [n=0] 
[18:01:07.815]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:07.815]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.815]  - seeds: <none>
[18:01:07.816]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.816] getGlobalsAndPackages() ...
[18:01:07.816] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.816] Resolving globals: FALSE
[18:01:07.817] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:07.819] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:07.819] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.819] 
[18:01:07.819] getGlobalsAndPackages() ... DONE
[18:01:07.820] run() for ‘Future’ ...
[18:01:07.820] - state: ‘created’
[18:01:07.821] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.843]   - Field: ‘node’
[18:01:07.843]   - Field: ‘label’
[18:01:07.844]   - Field: ‘local’
[18:01:07.844]   - Field: ‘owner’
[18:01:07.844]   - Field: ‘envir’
[18:01:07.844]   - Field: ‘workers’
[18:01:07.844]   - Field: ‘packages’
[18:01:07.845]   - Field: ‘gc’
[18:01:07.845]   - Field: ‘conditions’
[18:01:07.845]   - Field: ‘persistent’
[18:01:07.845]   - Field: ‘expr’
[18:01:07.845]   - Field: ‘uuid’
[18:01:07.846]   - Field: ‘seed’
[18:01:07.846]   - Field: ‘version’
[18:01:07.846]   - Field: ‘result’
[18:01:07.846]   - Field: ‘asynchronous’
[18:01:07.846]   - Field: ‘calls’
[18:01:07.847]   - Field: ‘globals’
[18:01:07.847]   - Field: ‘stdout’
[18:01:07.847]   - Field: ‘earlySignal’
[18:01:07.847]   - Field: ‘lazy’
[18:01:07.847]   - Field: ‘state’
[18:01:07.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.848] - Launch lazy future ...
[18:01:07.848] Packages needed by the future expression (n = 0): <none>
[18:01:07.848] Packages needed by future strategies (n = 0): <none>
[18:01:07.849] {
[18:01:07.849]     {
[18:01:07.849]         {
[18:01:07.849]             ...future.startTime <- base::Sys.time()
[18:01:07.849]             {
[18:01:07.849]                 {
[18:01:07.849]                   {
[18:01:07.849]                     {
[18:01:07.849]                       base::local({
[18:01:07.849]                         has_future <- base::requireNamespace("future", 
[18:01:07.849]                           quietly = TRUE)
[18:01:07.849]                         if (has_future) {
[18:01:07.849]                           ns <- base::getNamespace("future")
[18:01:07.849]                           version <- ns[[".package"]][["version"]]
[18:01:07.849]                           if (is.null(version)) 
[18:01:07.849]                             version <- utils::packageVersion("future")
[18:01:07.849]                         }
[18:01:07.849]                         else {
[18:01:07.849]                           version <- NULL
[18:01:07.849]                         }
[18:01:07.849]                         if (!has_future || version < "1.8.0") {
[18:01:07.849]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.849]                             "", base::R.version$version.string), 
[18:01:07.849]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.849]                               "release", "version")], collapse = " "), 
[18:01:07.849]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.849]                             info)
[18:01:07.849]                           info <- base::paste(info, collapse = "; ")
[18:01:07.849]                           if (!has_future) {
[18:01:07.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.849]                               info)
[18:01:07.849]                           }
[18:01:07.849]                           else {
[18:01:07.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.849]                               info, version)
[18:01:07.849]                           }
[18:01:07.849]                           base::stop(msg)
[18:01:07.849]                         }
[18:01:07.849]                       })
[18:01:07.849]                     }
[18:01:07.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.849]                     base::options(mc.cores = 1L)
[18:01:07.849]                   }
[18:01:07.849]                   ...future.strategy.old <- future::plan("list")
[18:01:07.849]                   options(future.plan = NULL)
[18:01:07.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.849]                 }
[18:01:07.849]                 ...future.workdir <- getwd()
[18:01:07.849]             }
[18:01:07.849]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.849]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.849]         }
[18:01:07.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.849]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.849]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.849]             base::names(...future.oldOptions))
[18:01:07.849]     }
[18:01:07.849]     if (FALSE) {
[18:01:07.849]     }
[18:01:07.849]     else {
[18:01:07.849]         if (TRUE) {
[18:01:07.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.849]                 open = "w")
[18:01:07.849]         }
[18:01:07.849]         else {
[18:01:07.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.849]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.849]         }
[18:01:07.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.849]             base::sink(type = "output", split = FALSE)
[18:01:07.849]             base::close(...future.stdout)
[18:01:07.849]         }, add = TRUE)
[18:01:07.849]     }
[18:01:07.849]     ...future.frame <- base::sys.nframe()
[18:01:07.849]     ...future.conditions <- base::list()
[18:01:07.849]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.849]     if (FALSE) {
[18:01:07.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.849]     }
[18:01:07.849]     ...future.result <- base::tryCatch({
[18:01:07.849]         base::withCallingHandlers({
[18:01:07.849]             ...future.value <- base::withVisible(base::local({
[18:01:07.849]                 ...future.makeSendCondition <- base::local({
[18:01:07.849]                   sendCondition <- NULL
[18:01:07.849]                   function(frame = 1L) {
[18:01:07.849]                     if (is.function(sendCondition)) 
[18:01:07.849]                       return(sendCondition)
[18:01:07.849]                     ns <- getNamespace("parallel")
[18:01:07.849]                     if (exists("sendData", mode = "function", 
[18:01:07.849]                       envir = ns)) {
[18:01:07.849]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.849]                         envir = ns)
[18:01:07.849]                       envir <- sys.frame(frame)
[18:01:07.849]                       master <- NULL
[18:01:07.849]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.849]                         !identical(envir, emptyenv())) {
[18:01:07.849]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.849]                           inherits = FALSE)) {
[18:01:07.849]                           master <- get("master", mode = "list", 
[18:01:07.849]                             envir = envir, inherits = FALSE)
[18:01:07.849]                           if (inherits(master, c("SOCKnode", 
[18:01:07.849]                             "SOCK0node"))) {
[18:01:07.849]                             sendCondition <<- function(cond) {
[18:01:07.849]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.849]                                 success = TRUE)
[18:01:07.849]                               parallel_sendData(master, data)
[18:01:07.849]                             }
[18:01:07.849]                             return(sendCondition)
[18:01:07.849]                           }
[18:01:07.849]                         }
[18:01:07.849]                         frame <- frame + 1L
[18:01:07.849]                         envir <- sys.frame(frame)
[18:01:07.849]                       }
[18:01:07.849]                     }
[18:01:07.849]                     sendCondition <<- function(cond) NULL
[18:01:07.849]                   }
[18:01:07.849]                 })
[18:01:07.849]                 withCallingHandlers({
[18:01:07.849]                   {
[18:01:07.849]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.849]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.849]                       ...future.globals.maxSize)) {
[18:01:07.849]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.849]                       on.exit(options(oopts), add = TRUE)
[18:01:07.849]                     }
[18:01:07.849]                     {
[18:01:07.849]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.849]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.849]                         USE.NAMES = FALSE)
[18:01:07.849]                       do.call(mapply, args = args)
[18:01:07.849]                     }
[18:01:07.849]                   }
[18:01:07.849]                 }, immediateCondition = function(cond) {
[18:01:07.849]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.849]                   sendCondition(cond)
[18:01:07.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.849]                   {
[18:01:07.849]                     inherits <- base::inherits
[18:01:07.849]                     invokeRestart <- base::invokeRestart
[18:01:07.849]                     is.null <- base::is.null
[18:01:07.849]                     muffled <- FALSE
[18:01:07.849]                     if (inherits(cond, "message")) {
[18:01:07.849]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.849]                       if (muffled) 
[18:01:07.849]                         invokeRestart("muffleMessage")
[18:01:07.849]                     }
[18:01:07.849]                     else if (inherits(cond, "warning")) {
[18:01:07.849]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.849]                       if (muffled) 
[18:01:07.849]                         invokeRestart("muffleWarning")
[18:01:07.849]                     }
[18:01:07.849]                     else if (inherits(cond, "condition")) {
[18:01:07.849]                       if (!is.null(pattern)) {
[18:01:07.849]                         computeRestarts <- base::computeRestarts
[18:01:07.849]                         grepl <- base::grepl
[18:01:07.849]                         restarts <- computeRestarts(cond)
[18:01:07.849]                         for (restart in restarts) {
[18:01:07.849]                           name <- restart$name
[18:01:07.849]                           if (is.null(name)) 
[18:01:07.849]                             next
[18:01:07.849]                           if (!grepl(pattern, name)) 
[18:01:07.849]                             next
[18:01:07.849]                           invokeRestart(restart)
[18:01:07.849]                           muffled <- TRUE
[18:01:07.849]                           break
[18:01:07.849]                         }
[18:01:07.849]                       }
[18:01:07.849]                     }
[18:01:07.849]                     invisible(muffled)
[18:01:07.849]                   }
[18:01:07.849]                   muffleCondition(cond)
[18:01:07.849]                 })
[18:01:07.849]             }))
[18:01:07.849]             future::FutureResult(value = ...future.value$value, 
[18:01:07.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.849]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.849]                     ...future.globalenv.names))
[18:01:07.849]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.849]         }, condition = base::local({
[18:01:07.849]             c <- base::c
[18:01:07.849]             inherits <- base::inherits
[18:01:07.849]             invokeRestart <- base::invokeRestart
[18:01:07.849]             length <- base::length
[18:01:07.849]             list <- base::list
[18:01:07.849]             seq.int <- base::seq.int
[18:01:07.849]             signalCondition <- base::signalCondition
[18:01:07.849]             sys.calls <- base::sys.calls
[18:01:07.849]             `[[` <- base::`[[`
[18:01:07.849]             `+` <- base::`+`
[18:01:07.849]             `<<-` <- base::`<<-`
[18:01:07.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.849]                   3L)]
[18:01:07.849]             }
[18:01:07.849]             function(cond) {
[18:01:07.849]                 is_error <- inherits(cond, "error")
[18:01:07.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.849]                   NULL)
[18:01:07.849]                 if (is_error) {
[18:01:07.849]                   sessionInformation <- function() {
[18:01:07.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.849]                       search = base::search(), system = base::Sys.info())
[18:01:07.849]                   }
[18:01:07.849]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.849]                     cond$call), session = sessionInformation(), 
[18:01:07.849]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.849]                   signalCondition(cond)
[18:01:07.849]                 }
[18:01:07.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.849]                 "immediateCondition"))) {
[18:01:07.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.849]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.849]                   if (TRUE && !signal) {
[18:01:07.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.849]                     {
[18:01:07.849]                       inherits <- base::inherits
[18:01:07.849]                       invokeRestart <- base::invokeRestart
[18:01:07.849]                       is.null <- base::is.null
[18:01:07.849]                       muffled <- FALSE
[18:01:07.849]                       if (inherits(cond, "message")) {
[18:01:07.849]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.849]                         if (muffled) 
[18:01:07.849]                           invokeRestart("muffleMessage")
[18:01:07.849]                       }
[18:01:07.849]                       else if (inherits(cond, "warning")) {
[18:01:07.849]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.849]                         if (muffled) 
[18:01:07.849]                           invokeRestart("muffleWarning")
[18:01:07.849]                       }
[18:01:07.849]                       else if (inherits(cond, "condition")) {
[18:01:07.849]                         if (!is.null(pattern)) {
[18:01:07.849]                           computeRestarts <- base::computeRestarts
[18:01:07.849]                           grepl <- base::grepl
[18:01:07.849]                           restarts <- computeRestarts(cond)
[18:01:07.849]                           for (restart in restarts) {
[18:01:07.849]                             name <- restart$name
[18:01:07.849]                             if (is.null(name)) 
[18:01:07.849]                               next
[18:01:07.849]                             if (!grepl(pattern, name)) 
[18:01:07.849]                               next
[18:01:07.849]                             invokeRestart(restart)
[18:01:07.849]                             muffled <- TRUE
[18:01:07.849]                             break
[18:01:07.849]                           }
[18:01:07.849]                         }
[18:01:07.849]                       }
[18:01:07.849]                       invisible(muffled)
[18:01:07.849]                     }
[18:01:07.849]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.849]                   }
[18:01:07.849]                 }
[18:01:07.849]                 else {
[18:01:07.849]                   if (TRUE) {
[18:01:07.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.849]                     {
[18:01:07.849]                       inherits <- base::inherits
[18:01:07.849]                       invokeRestart <- base::invokeRestart
[18:01:07.849]                       is.null <- base::is.null
[18:01:07.849]                       muffled <- FALSE
[18:01:07.849]                       if (inherits(cond, "message")) {
[18:01:07.849]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.849]                         if (muffled) 
[18:01:07.849]                           invokeRestart("muffleMessage")
[18:01:07.849]                       }
[18:01:07.849]                       else if (inherits(cond, "warning")) {
[18:01:07.849]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.849]                         if (muffled) 
[18:01:07.849]                           invokeRestart("muffleWarning")
[18:01:07.849]                       }
[18:01:07.849]                       else if (inherits(cond, "condition")) {
[18:01:07.849]                         if (!is.null(pattern)) {
[18:01:07.849]                           computeRestarts <- base::computeRestarts
[18:01:07.849]                           grepl <- base::grepl
[18:01:07.849]                           restarts <- computeRestarts(cond)
[18:01:07.849]                           for (restart in restarts) {
[18:01:07.849]                             name <- restart$name
[18:01:07.849]                             if (is.null(name)) 
[18:01:07.849]                               next
[18:01:07.849]                             if (!grepl(pattern, name)) 
[18:01:07.849]                               next
[18:01:07.849]                             invokeRestart(restart)
[18:01:07.849]                             muffled <- TRUE
[18:01:07.849]                             break
[18:01:07.849]                           }
[18:01:07.849]                         }
[18:01:07.849]                       }
[18:01:07.849]                       invisible(muffled)
[18:01:07.849]                     }
[18:01:07.849]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.849]                   }
[18:01:07.849]                 }
[18:01:07.849]             }
[18:01:07.849]         }))
[18:01:07.849]     }, error = function(ex) {
[18:01:07.849]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.849]                 ...future.rng), started = ...future.startTime, 
[18:01:07.849]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.849]             version = "1.8"), class = "FutureResult")
[18:01:07.849]     }, finally = {
[18:01:07.849]         if (!identical(...future.workdir, getwd())) 
[18:01:07.849]             setwd(...future.workdir)
[18:01:07.849]         {
[18:01:07.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.849]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.849]             }
[18:01:07.849]             base::options(...future.oldOptions)
[18:01:07.849]             if (.Platform$OS.type == "windows") {
[18:01:07.849]                 old_names <- names(...future.oldEnvVars)
[18:01:07.849]                 envs <- base::Sys.getenv()
[18:01:07.849]                 names <- names(envs)
[18:01:07.849]                 common <- intersect(names, old_names)
[18:01:07.849]                 added <- setdiff(names, old_names)
[18:01:07.849]                 removed <- setdiff(old_names, names)
[18:01:07.849]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.849]                   envs[common]]
[18:01:07.849]                 NAMES <- toupper(changed)
[18:01:07.849]                 args <- list()
[18:01:07.849]                 for (kk in seq_along(NAMES)) {
[18:01:07.849]                   name <- changed[[kk]]
[18:01:07.849]                   NAME <- NAMES[[kk]]
[18:01:07.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.849]                     next
[18:01:07.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.849]                 }
[18:01:07.849]                 NAMES <- toupper(added)
[18:01:07.849]                 for (kk in seq_along(NAMES)) {
[18:01:07.849]                   name <- added[[kk]]
[18:01:07.849]                   NAME <- NAMES[[kk]]
[18:01:07.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.849]                     next
[18:01:07.849]                   args[[name]] <- ""
[18:01:07.849]                 }
[18:01:07.849]                 NAMES <- toupper(removed)
[18:01:07.849]                 for (kk in seq_along(NAMES)) {
[18:01:07.849]                   name <- removed[[kk]]
[18:01:07.849]                   NAME <- NAMES[[kk]]
[18:01:07.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.849]                     next
[18:01:07.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.849]                 }
[18:01:07.849]                 if (length(args) > 0) 
[18:01:07.849]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.849]             }
[18:01:07.849]             else {
[18:01:07.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.849]             }
[18:01:07.849]             {
[18:01:07.849]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.849]                   0L) {
[18:01:07.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.849]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.849]                   base::options(opts)
[18:01:07.849]                 }
[18:01:07.849]                 {
[18:01:07.849]                   {
[18:01:07.849]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.849]                     NULL
[18:01:07.849]                   }
[18:01:07.849]                   options(future.plan = NULL)
[18:01:07.849]                   if (is.na(NA_character_)) 
[18:01:07.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.849]                     .init = FALSE)
[18:01:07.849]                 }
[18:01:07.849]             }
[18:01:07.849]         }
[18:01:07.849]     })
[18:01:07.849]     if (TRUE) {
[18:01:07.849]         base::sink(type = "output", split = FALSE)
[18:01:07.849]         if (TRUE) {
[18:01:07.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.849]         }
[18:01:07.849]         else {
[18:01:07.849]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.849]         }
[18:01:07.849]         base::close(...future.stdout)
[18:01:07.849]         ...future.stdout <- NULL
[18:01:07.849]     }
[18:01:07.849]     ...future.result$conditions <- ...future.conditions
[18:01:07.849]     ...future.result$finished <- base::Sys.time()
[18:01:07.849]     ...future.result
[18:01:07.849] }
[18:01:07.854] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[18:01:07.855] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:07.856] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:07.856] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:07.857] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.857] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[18:01:07.858] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[18:01:07.858] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:07.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.859] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:07.860] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:07.860] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[18:01:07.861] MultisessionFuture started
[18:01:07.861] - Launch lazy future ... done
[18:01:07.861] run() for ‘MultisessionFuture’ ... done
[18:01:07.862] Created future:
[18:01:07.862] MultisessionFuture:
[18:01:07.862] Label: ‘future_mapply-2’
[18:01:07.862] Expression:
[18:01:07.862] {
[18:01:07.862]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.862]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.862]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.862]         on.exit(options(oopts), add = TRUE)
[18:01:07.862]     }
[18:01:07.862]     {
[18:01:07.862]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.862]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.862]         do.call(mapply, args = args)
[18:01:07.862]     }
[18:01:07.862] }
[18:01:07.862] Lazy evaluation: FALSE
[18:01:07.862] Asynchronous evaluation: TRUE
[18:01:07.862] Local evaluation: TRUE
[18:01:07.862] Environment: R_GlobalEnv
[18:01:07.862] Capture standard output: TRUE
[18:01:07.862] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.862] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.862] Packages: <none>
[18:01:07.862] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.862] Resolved: FALSE
[18:01:07.862] Value: <not collected>
[18:01:07.862] Conditions captured: <none>
[18:01:07.862] Early signaling: FALSE
[18:01:07.862] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.862] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.875] Chunk #2 of 2 ... DONE
[18:01:07.875] Launching 2 futures (chunks) ... DONE
[18:01:07.875] Resolving 2 futures (chunks) ...
[18:01:07.876] resolve() on list ...
[18:01:07.876]  recursive: 0
[18:01:07.876]  length: 2
[18:01:07.876] 
[18:01:07.877] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.878] - Validating connection of MultisessionFuture
[18:01:07.878] - received message: FutureResult
[18:01:07.878] - Received FutureResult
[18:01:07.879] - Erased future from FutureRegistry
[18:01:07.879] result() for ClusterFuture ...
[18:01:07.879] - result already collected: FutureResult
[18:01:07.879] result() for ClusterFuture ... done
[18:01:07.879] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.880] Future #1
[18:01:07.880] result() for ClusterFuture ...
[18:01:07.880] - result already collected: FutureResult
[18:01:07.880] result() for ClusterFuture ... done
[18:01:07.880] result() for ClusterFuture ...
[18:01:07.881] - result already collected: FutureResult
[18:01:07.881] result() for ClusterFuture ... done
[18:01:07.881] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:07.881] - nx: 2
[18:01:07.881] - relay: TRUE
[18:01:07.882] - stdout: TRUE
[18:01:07.882] - signal: TRUE
[18:01:07.882] - resignal: FALSE
[18:01:07.882] - force: TRUE
[18:01:07.882] - relayed: [n=2] FALSE, FALSE
[18:01:07.882] - queued futures: [n=2] FALSE, FALSE
[18:01:07.883]  - until=1
[18:01:07.883]  - relaying element #1
[18:01:07.883] result() for ClusterFuture ...
[18:01:07.883] - result already collected: FutureResult
[18:01:07.883] result() for ClusterFuture ... done
[18:01:07.884] result() for ClusterFuture ...
[18:01:07.884] - result already collected: FutureResult
[18:01:07.884] result() for ClusterFuture ... done
[18:01:07.884] result() for ClusterFuture ...
[18:01:07.884] - result already collected: FutureResult
[18:01:07.885] result() for ClusterFuture ... done
[18:01:07.885] result() for ClusterFuture ...
[18:01:07.885] - result already collected: FutureResult
[18:01:07.885] result() for ClusterFuture ... done
[18:01:07.885] - relayed: [n=2] TRUE, FALSE
[18:01:07.886] - queued futures: [n=2] TRUE, FALSE
[18:01:07.886] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:07.886]  length: 1 (resolved future 1)
[18:01:07.908] receiveMessageFromWorker() for ClusterFuture ...
[18:01:07.909] - Validating connection of MultisessionFuture
[18:01:07.909] - received message: FutureResult
[18:01:07.909] - Received FutureResult
[18:01:07.909] - Erased future from FutureRegistry
[18:01:07.910] result() for ClusterFuture ...
[18:01:07.910] - result already collected: FutureResult
[18:01:07.910] result() for ClusterFuture ... done
[18:01:07.910] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:07.910] Future #2
[18:01:07.911] result() for ClusterFuture ...
[18:01:07.911] - result already collected: FutureResult
[18:01:07.911] result() for ClusterFuture ... done
[18:01:07.911] result() for ClusterFuture ...
[18:01:07.911] - result already collected: FutureResult
[18:01:07.912] result() for ClusterFuture ... done
[18:01:07.912] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:07.912] - nx: 2
[18:01:07.912] - relay: TRUE
[18:01:07.912] - stdout: TRUE
[18:01:07.912] - signal: TRUE
[18:01:07.913] - resignal: FALSE
[18:01:07.913] - force: TRUE
[18:01:07.913] - relayed: [n=2] TRUE, FALSE
[18:01:07.913] - queued futures: [n=2] TRUE, FALSE
[18:01:07.913]  - until=2
[18:01:07.914]  - relaying element #2
[18:01:07.914] result() for ClusterFuture ...
[18:01:07.914] - result already collected: FutureResult
[18:01:07.914] result() for ClusterFuture ... done
[18:01:07.914] result() for ClusterFuture ...
[18:01:07.914] - result already collected: FutureResult
[18:01:07.915] result() for ClusterFuture ... done
[18:01:07.915] result() for ClusterFuture ...
[18:01:07.915] - result already collected: FutureResult
[18:01:07.915] result() for ClusterFuture ... done
[18:01:07.916] result() for ClusterFuture ...
[18:01:07.916] - result already collected: FutureResult
[18:01:07.916] result() for ClusterFuture ... done
[18:01:07.916] - relayed: [n=2] TRUE, TRUE
[18:01:07.916] - queued futures: [n=2] TRUE, TRUE
[18:01:07.916] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:07.917]  length: 0 (resolved future 2)
[18:01:07.917] Relaying remaining futures
[18:01:07.917] signalConditionsASAP(NULL, pos=0) ...
[18:01:07.917] - nx: 2
[18:01:07.917] - relay: TRUE
[18:01:07.918] - stdout: TRUE
[18:01:07.918] - signal: TRUE
[18:01:07.918] - resignal: FALSE
[18:01:07.918] - force: TRUE
[18:01:07.918] - relayed: [n=2] TRUE, TRUE
[18:01:07.918] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:07.919] - relayed: [n=2] TRUE, TRUE
[18:01:07.919] - queued futures: [n=2] TRUE, TRUE
[18:01:07.919] signalConditionsASAP(NULL, pos=0) ... done
[18:01:07.919] resolve() on list ... DONE
[18:01:07.919] result() for ClusterFuture ...
[18:01:07.920] - result already collected: FutureResult
[18:01:07.920] result() for ClusterFuture ... done
[18:01:07.920] result() for ClusterFuture ...
[18:01:07.920] - result already collected: FutureResult
[18:01:07.920] result() for ClusterFuture ... done
[18:01:07.921] result() for ClusterFuture ...
[18:01:07.921] - result already collected: FutureResult
[18:01:07.921] result() for ClusterFuture ... done
[18:01:07.921] result() for ClusterFuture ...
[18:01:07.921] - result already collected: FutureResult
[18:01:07.922] result() for ClusterFuture ... done
[18:01:07.922]  - Number of value chunks collected: 2
[18:01:07.922] Resolving 2 futures (chunks) ... DONE
[18:01:07.922] Reducing values from 2 chunks ...
[18:01:07.922]  - Number of values collected after concatenation: 5
[18:01:07.922]  - Number of values expected: 5
[18:01:07.923] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[18:01:07.923] Reducing values from 2 chunks ... DONE
[18:01:07.923] future_mapply() ... DONE
[18:01:07.924] future_mapply() ...
[18:01:07.930] Number of chunks: 2
[18:01:07.930] getGlobalsAndPackagesXApply() ...
[18:01:07.930]  - future.globals: TRUE
[18:01:07.930] getGlobalsAndPackages() ...
[18:01:07.931] Searching for globals...
[18:01:07.933] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[18:01:07.934] Searching for globals ... DONE
[18:01:07.934] Resolving globals: FALSE
[18:01:07.935] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[18:01:07.935] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[18:01:07.936] - globals: [1] ‘FUN’
[18:01:07.936] 
[18:01:07.936] getGlobalsAndPackages() ... DONE
[18:01:07.936]  - globals found/used: [n=1] ‘FUN’
[18:01:07.937]  - needed namespaces: [n=0] 
[18:01:07.937] Finding globals ... DONE
[18:01:07.937] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:07.937] List of 2
[18:01:07.937]  $ ...future.FUN:function (C, k)  
[18:01:07.937]  $ MoreArgs     : list()
[18:01:07.937]  - attr(*, "where")=List of 2
[18:01:07.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:07.937]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:07.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:07.937]  - attr(*, "resolved")= logi FALSE
[18:01:07.937]  - attr(*, "total_size")= num NA
[18:01:07.943] Packages to be attached in all futures: [n=0] 
[18:01:07.943] getGlobalsAndPackagesXApply() ... DONE
[18:01:07.943] Number of futures (= number of chunks): 2
[18:01:07.943] Launching 2 futures (chunks) ...
[18:01:07.944] Chunk #1 of 2 ...
[18:01:07.944]  - Finding globals in '...' for chunk #1 ...
[18:01:07.944] getGlobalsAndPackages() ...
[18:01:07.944] Searching for globals...
[18:01:07.945] 
[18:01:07.945] Searching for globals ... DONE
[18:01:07.945] - globals: [0] <none>
[18:01:07.946] getGlobalsAndPackages() ... DONE
[18:01:07.946]    + additional globals found: [n=0] 
[18:01:07.946]    + additional namespaces needed: [n=0] 
[18:01:07.946]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:07.946]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:07.947]  - seeds: <none>
[18:01:07.947]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.947] getGlobalsAndPackages() ...
[18:01:07.947] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.948] Resolving globals: FALSE
[18:01:07.949] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[18:01:07.950] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:07.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:07.950] 
[18:01:07.950] getGlobalsAndPackages() ... DONE
[18:01:07.951] run() for ‘Future’ ...
[18:01:07.951] - state: ‘created’
[18:01:07.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:07.973] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:07.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:07.974]   - Field: ‘node’
[18:01:07.974]   - Field: ‘label’
[18:01:07.974]   - Field: ‘local’
[18:01:07.974]   - Field: ‘owner’
[18:01:07.975]   - Field: ‘envir’
[18:01:07.975]   - Field: ‘workers’
[18:01:07.975]   - Field: ‘packages’
[18:01:07.975]   - Field: ‘gc’
[18:01:07.975]   - Field: ‘conditions’
[18:01:07.976]   - Field: ‘persistent’
[18:01:07.976]   - Field: ‘expr’
[18:01:07.976]   - Field: ‘uuid’
[18:01:07.976]   - Field: ‘seed’
[18:01:07.976]   - Field: ‘version’
[18:01:07.977]   - Field: ‘result’
[18:01:07.977]   - Field: ‘asynchronous’
[18:01:07.977]   - Field: ‘calls’
[18:01:07.977]   - Field: ‘globals’
[18:01:07.977]   - Field: ‘stdout’
[18:01:07.978]   - Field: ‘earlySignal’
[18:01:07.978]   - Field: ‘lazy’
[18:01:07.978]   - Field: ‘state’
[18:01:07.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:07.978] - Launch lazy future ...
[18:01:07.979] Packages needed by the future expression (n = 0): <none>
[18:01:07.979] Packages needed by future strategies (n = 0): <none>
[18:01:07.980] {
[18:01:07.980]     {
[18:01:07.980]         {
[18:01:07.980]             ...future.startTime <- base::Sys.time()
[18:01:07.980]             {
[18:01:07.980]                 {
[18:01:07.980]                   {
[18:01:07.980]                     {
[18:01:07.980]                       base::local({
[18:01:07.980]                         has_future <- base::requireNamespace("future", 
[18:01:07.980]                           quietly = TRUE)
[18:01:07.980]                         if (has_future) {
[18:01:07.980]                           ns <- base::getNamespace("future")
[18:01:07.980]                           version <- ns[[".package"]][["version"]]
[18:01:07.980]                           if (is.null(version)) 
[18:01:07.980]                             version <- utils::packageVersion("future")
[18:01:07.980]                         }
[18:01:07.980]                         else {
[18:01:07.980]                           version <- NULL
[18:01:07.980]                         }
[18:01:07.980]                         if (!has_future || version < "1.8.0") {
[18:01:07.980]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:07.980]                             "", base::R.version$version.string), 
[18:01:07.980]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:07.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:07.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:07.980]                               "release", "version")], collapse = " "), 
[18:01:07.980]                             hostname = base::Sys.info()[["nodename"]])
[18:01:07.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:07.980]                             info)
[18:01:07.980]                           info <- base::paste(info, collapse = "; ")
[18:01:07.980]                           if (!has_future) {
[18:01:07.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:07.980]                               info)
[18:01:07.980]                           }
[18:01:07.980]                           else {
[18:01:07.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:07.980]                               info, version)
[18:01:07.980]                           }
[18:01:07.980]                           base::stop(msg)
[18:01:07.980]                         }
[18:01:07.980]                       })
[18:01:07.980]                     }
[18:01:07.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:07.980]                     base::options(mc.cores = 1L)
[18:01:07.980]                   }
[18:01:07.980]                   ...future.strategy.old <- future::plan("list")
[18:01:07.980]                   options(future.plan = NULL)
[18:01:07.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:07.980]                 }
[18:01:07.980]                 ...future.workdir <- getwd()
[18:01:07.980]             }
[18:01:07.980]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:07.980]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:07.980]         }
[18:01:07.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:07.980]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:07.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:07.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:07.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:07.980]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:07.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:07.980]             base::names(...future.oldOptions))
[18:01:07.980]     }
[18:01:07.980]     if (FALSE) {
[18:01:07.980]     }
[18:01:07.980]     else {
[18:01:07.980]         if (TRUE) {
[18:01:07.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:07.980]                 open = "w")
[18:01:07.980]         }
[18:01:07.980]         else {
[18:01:07.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:07.980]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:07.980]         }
[18:01:07.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:07.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:07.980]             base::sink(type = "output", split = FALSE)
[18:01:07.980]             base::close(...future.stdout)
[18:01:07.980]         }, add = TRUE)
[18:01:07.980]     }
[18:01:07.980]     ...future.frame <- base::sys.nframe()
[18:01:07.980]     ...future.conditions <- base::list()
[18:01:07.980]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:07.980]     if (FALSE) {
[18:01:07.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:07.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:07.980]     }
[18:01:07.980]     ...future.result <- base::tryCatch({
[18:01:07.980]         base::withCallingHandlers({
[18:01:07.980]             ...future.value <- base::withVisible(base::local({
[18:01:07.980]                 ...future.makeSendCondition <- base::local({
[18:01:07.980]                   sendCondition <- NULL
[18:01:07.980]                   function(frame = 1L) {
[18:01:07.980]                     if (is.function(sendCondition)) 
[18:01:07.980]                       return(sendCondition)
[18:01:07.980]                     ns <- getNamespace("parallel")
[18:01:07.980]                     if (exists("sendData", mode = "function", 
[18:01:07.980]                       envir = ns)) {
[18:01:07.980]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:07.980]                         envir = ns)
[18:01:07.980]                       envir <- sys.frame(frame)
[18:01:07.980]                       master <- NULL
[18:01:07.980]                       while (!identical(envir, .GlobalEnv) && 
[18:01:07.980]                         !identical(envir, emptyenv())) {
[18:01:07.980]                         if (exists("master", mode = "list", envir = envir, 
[18:01:07.980]                           inherits = FALSE)) {
[18:01:07.980]                           master <- get("master", mode = "list", 
[18:01:07.980]                             envir = envir, inherits = FALSE)
[18:01:07.980]                           if (inherits(master, c("SOCKnode", 
[18:01:07.980]                             "SOCK0node"))) {
[18:01:07.980]                             sendCondition <<- function(cond) {
[18:01:07.980]                               data <- list(type = "VALUE", value = cond, 
[18:01:07.980]                                 success = TRUE)
[18:01:07.980]                               parallel_sendData(master, data)
[18:01:07.980]                             }
[18:01:07.980]                             return(sendCondition)
[18:01:07.980]                           }
[18:01:07.980]                         }
[18:01:07.980]                         frame <- frame + 1L
[18:01:07.980]                         envir <- sys.frame(frame)
[18:01:07.980]                       }
[18:01:07.980]                     }
[18:01:07.980]                     sendCondition <<- function(cond) NULL
[18:01:07.980]                   }
[18:01:07.980]                 })
[18:01:07.980]                 withCallingHandlers({
[18:01:07.980]                   {
[18:01:07.980]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.980]                     if (!identical(...future.globals.maxSize.org, 
[18:01:07.980]                       ...future.globals.maxSize)) {
[18:01:07.980]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.980]                       on.exit(options(oopts), add = TRUE)
[18:01:07.980]                     }
[18:01:07.980]                     {
[18:01:07.980]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.980]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:07.980]                         USE.NAMES = FALSE)
[18:01:07.980]                       do.call(mapply, args = args)
[18:01:07.980]                     }
[18:01:07.980]                   }
[18:01:07.980]                 }, immediateCondition = function(cond) {
[18:01:07.980]                   sendCondition <- ...future.makeSendCondition()
[18:01:07.980]                   sendCondition(cond)
[18:01:07.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.980]                   {
[18:01:07.980]                     inherits <- base::inherits
[18:01:07.980]                     invokeRestart <- base::invokeRestart
[18:01:07.980]                     is.null <- base::is.null
[18:01:07.980]                     muffled <- FALSE
[18:01:07.980]                     if (inherits(cond, "message")) {
[18:01:07.980]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:07.980]                       if (muffled) 
[18:01:07.980]                         invokeRestart("muffleMessage")
[18:01:07.980]                     }
[18:01:07.980]                     else if (inherits(cond, "warning")) {
[18:01:07.980]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:07.980]                       if (muffled) 
[18:01:07.980]                         invokeRestart("muffleWarning")
[18:01:07.980]                     }
[18:01:07.980]                     else if (inherits(cond, "condition")) {
[18:01:07.980]                       if (!is.null(pattern)) {
[18:01:07.980]                         computeRestarts <- base::computeRestarts
[18:01:07.980]                         grepl <- base::grepl
[18:01:07.980]                         restarts <- computeRestarts(cond)
[18:01:07.980]                         for (restart in restarts) {
[18:01:07.980]                           name <- restart$name
[18:01:07.980]                           if (is.null(name)) 
[18:01:07.980]                             next
[18:01:07.980]                           if (!grepl(pattern, name)) 
[18:01:07.980]                             next
[18:01:07.980]                           invokeRestart(restart)
[18:01:07.980]                           muffled <- TRUE
[18:01:07.980]                           break
[18:01:07.980]                         }
[18:01:07.980]                       }
[18:01:07.980]                     }
[18:01:07.980]                     invisible(muffled)
[18:01:07.980]                   }
[18:01:07.980]                   muffleCondition(cond)
[18:01:07.980]                 })
[18:01:07.980]             }))
[18:01:07.980]             future::FutureResult(value = ...future.value$value, 
[18:01:07.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.980]                   ...future.rng), globalenv = if (FALSE) 
[18:01:07.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:07.980]                     ...future.globalenv.names))
[18:01:07.980]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:07.980]         }, condition = base::local({
[18:01:07.980]             c <- base::c
[18:01:07.980]             inherits <- base::inherits
[18:01:07.980]             invokeRestart <- base::invokeRestart
[18:01:07.980]             length <- base::length
[18:01:07.980]             list <- base::list
[18:01:07.980]             seq.int <- base::seq.int
[18:01:07.980]             signalCondition <- base::signalCondition
[18:01:07.980]             sys.calls <- base::sys.calls
[18:01:07.980]             `[[` <- base::`[[`
[18:01:07.980]             `+` <- base::`+`
[18:01:07.980]             `<<-` <- base::`<<-`
[18:01:07.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:07.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:07.980]                   3L)]
[18:01:07.980]             }
[18:01:07.980]             function(cond) {
[18:01:07.980]                 is_error <- inherits(cond, "error")
[18:01:07.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:07.980]                   NULL)
[18:01:07.980]                 if (is_error) {
[18:01:07.980]                   sessionInformation <- function() {
[18:01:07.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:07.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:07.980]                       search = base::search(), system = base::Sys.info())
[18:01:07.980]                   }
[18:01:07.980]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:07.980]                     cond$call), session = sessionInformation(), 
[18:01:07.980]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:07.980]                   signalCondition(cond)
[18:01:07.980]                 }
[18:01:07.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:07.980]                 "immediateCondition"))) {
[18:01:07.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:07.980]                   ...future.conditions[[length(...future.conditions) + 
[18:01:07.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:07.980]                   if (TRUE && !signal) {
[18:01:07.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.980]                     {
[18:01:07.980]                       inherits <- base::inherits
[18:01:07.980]                       invokeRestart <- base::invokeRestart
[18:01:07.980]                       is.null <- base::is.null
[18:01:07.980]                       muffled <- FALSE
[18:01:07.980]                       if (inherits(cond, "message")) {
[18:01:07.980]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.980]                         if (muffled) 
[18:01:07.980]                           invokeRestart("muffleMessage")
[18:01:07.980]                       }
[18:01:07.980]                       else if (inherits(cond, "warning")) {
[18:01:07.980]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.980]                         if (muffled) 
[18:01:07.980]                           invokeRestart("muffleWarning")
[18:01:07.980]                       }
[18:01:07.980]                       else if (inherits(cond, "condition")) {
[18:01:07.980]                         if (!is.null(pattern)) {
[18:01:07.980]                           computeRestarts <- base::computeRestarts
[18:01:07.980]                           grepl <- base::grepl
[18:01:07.980]                           restarts <- computeRestarts(cond)
[18:01:07.980]                           for (restart in restarts) {
[18:01:07.980]                             name <- restart$name
[18:01:07.980]                             if (is.null(name)) 
[18:01:07.980]                               next
[18:01:07.980]                             if (!grepl(pattern, name)) 
[18:01:07.980]                               next
[18:01:07.980]                             invokeRestart(restart)
[18:01:07.980]                             muffled <- TRUE
[18:01:07.980]                             break
[18:01:07.980]                           }
[18:01:07.980]                         }
[18:01:07.980]                       }
[18:01:07.980]                       invisible(muffled)
[18:01:07.980]                     }
[18:01:07.980]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.980]                   }
[18:01:07.980]                 }
[18:01:07.980]                 else {
[18:01:07.980]                   if (TRUE) {
[18:01:07.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:07.980]                     {
[18:01:07.980]                       inherits <- base::inherits
[18:01:07.980]                       invokeRestart <- base::invokeRestart
[18:01:07.980]                       is.null <- base::is.null
[18:01:07.980]                       muffled <- FALSE
[18:01:07.980]                       if (inherits(cond, "message")) {
[18:01:07.980]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:07.980]                         if (muffled) 
[18:01:07.980]                           invokeRestart("muffleMessage")
[18:01:07.980]                       }
[18:01:07.980]                       else if (inherits(cond, "warning")) {
[18:01:07.980]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:07.980]                         if (muffled) 
[18:01:07.980]                           invokeRestart("muffleWarning")
[18:01:07.980]                       }
[18:01:07.980]                       else if (inherits(cond, "condition")) {
[18:01:07.980]                         if (!is.null(pattern)) {
[18:01:07.980]                           computeRestarts <- base::computeRestarts
[18:01:07.980]                           grepl <- base::grepl
[18:01:07.980]                           restarts <- computeRestarts(cond)
[18:01:07.980]                           for (restart in restarts) {
[18:01:07.980]                             name <- restart$name
[18:01:07.980]                             if (is.null(name)) 
[18:01:07.980]                               next
[18:01:07.980]                             if (!grepl(pattern, name)) 
[18:01:07.980]                               next
[18:01:07.980]                             invokeRestart(restart)
[18:01:07.980]                             muffled <- TRUE
[18:01:07.980]                             break
[18:01:07.980]                           }
[18:01:07.980]                         }
[18:01:07.980]                       }
[18:01:07.980]                       invisible(muffled)
[18:01:07.980]                     }
[18:01:07.980]                     muffleCondition(cond, pattern = "^muffle")
[18:01:07.980]                   }
[18:01:07.980]                 }
[18:01:07.980]             }
[18:01:07.980]         }))
[18:01:07.980]     }, error = function(ex) {
[18:01:07.980]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:07.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:07.980]                 ...future.rng), started = ...future.startTime, 
[18:01:07.980]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:07.980]             version = "1.8"), class = "FutureResult")
[18:01:07.980]     }, finally = {
[18:01:07.980]         if (!identical(...future.workdir, getwd())) 
[18:01:07.980]             setwd(...future.workdir)
[18:01:07.980]         {
[18:01:07.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:07.980]                 ...future.oldOptions$nwarnings <- NULL
[18:01:07.980]             }
[18:01:07.980]             base::options(...future.oldOptions)
[18:01:07.980]             if (.Platform$OS.type == "windows") {
[18:01:07.980]                 old_names <- names(...future.oldEnvVars)
[18:01:07.980]                 envs <- base::Sys.getenv()
[18:01:07.980]                 names <- names(envs)
[18:01:07.980]                 common <- intersect(names, old_names)
[18:01:07.980]                 added <- setdiff(names, old_names)
[18:01:07.980]                 removed <- setdiff(old_names, names)
[18:01:07.980]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:07.980]                   envs[common]]
[18:01:07.980]                 NAMES <- toupper(changed)
[18:01:07.980]                 args <- list()
[18:01:07.980]                 for (kk in seq_along(NAMES)) {
[18:01:07.980]                   name <- changed[[kk]]
[18:01:07.980]                   NAME <- NAMES[[kk]]
[18:01:07.980]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.980]                     next
[18:01:07.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.980]                 }
[18:01:07.980]                 NAMES <- toupper(added)
[18:01:07.980]                 for (kk in seq_along(NAMES)) {
[18:01:07.980]                   name <- added[[kk]]
[18:01:07.980]                   NAME <- NAMES[[kk]]
[18:01:07.980]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.980]                     next
[18:01:07.980]                   args[[name]] <- ""
[18:01:07.980]                 }
[18:01:07.980]                 NAMES <- toupper(removed)
[18:01:07.980]                 for (kk in seq_along(NAMES)) {
[18:01:07.980]                   name <- removed[[kk]]
[18:01:07.980]                   NAME <- NAMES[[kk]]
[18:01:07.980]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:07.980]                     next
[18:01:07.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:07.980]                 }
[18:01:07.980]                 if (length(args) > 0) 
[18:01:07.980]                   base::do.call(base::Sys.setenv, args = args)
[18:01:07.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:07.980]             }
[18:01:07.980]             else {
[18:01:07.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:07.980]             }
[18:01:07.980]             {
[18:01:07.980]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:07.980]                   0L) {
[18:01:07.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:07.980]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:07.980]                   base::options(opts)
[18:01:07.980]                 }
[18:01:07.980]                 {
[18:01:07.980]                   {
[18:01:07.980]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:07.980]                     NULL
[18:01:07.980]                   }
[18:01:07.980]                   options(future.plan = NULL)
[18:01:07.980]                   if (is.na(NA_character_)) 
[18:01:07.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:07.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:07.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:07.980]                     .init = FALSE)
[18:01:07.980]                 }
[18:01:07.980]             }
[18:01:07.980]         }
[18:01:07.980]     })
[18:01:07.980]     if (TRUE) {
[18:01:07.980]         base::sink(type = "output", split = FALSE)
[18:01:07.980]         if (TRUE) {
[18:01:07.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:07.980]         }
[18:01:07.980]         else {
[18:01:07.980]             ...future.result["stdout"] <- base::list(NULL)
[18:01:07.980]         }
[18:01:07.980]         base::close(...future.stdout)
[18:01:07.980]         ...future.stdout <- NULL
[18:01:07.980]     }
[18:01:07.980]     ...future.result$conditions <- ...future.conditions
[18:01:07.980]     ...future.result$finished <- base::Sys.time()
[18:01:07.980]     ...future.result
[18:01:07.980] }
[18:01:07.985] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[18:01:07.985] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[18:01:07.986] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[18:01:07.986] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:07.987] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.988] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[18:01:07.988] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[18:01:07.989] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:07.990] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.990] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:07.991] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:07.991] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[18:01:07.992] MultisessionFuture started
[18:01:07.992] - Launch lazy future ... done
[18:01:07.992] run() for ‘MultisessionFuture’ ... done
[18:01:07.993] Created future:
[18:01:07.993] MultisessionFuture:
[18:01:07.993] Label: ‘future_.mapply-1’
[18:01:07.993] Expression:
[18:01:07.993] {
[18:01:07.993]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:07.993]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:07.993]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:07.993]         on.exit(options(oopts), add = TRUE)
[18:01:07.993]     }
[18:01:07.993]     {
[18:01:07.993]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:07.993]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:07.993]         do.call(mapply, args = args)
[18:01:07.993]     }
[18:01:07.993] }
[18:01:07.993] Lazy evaluation: FALSE
[18:01:07.993] Asynchronous evaluation: TRUE
[18:01:07.993] Local evaluation: TRUE
[18:01:07.993] Environment: R_GlobalEnv
[18:01:07.993] Capture standard output: TRUE
[18:01:07.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:07.993] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:07.993] Packages: <none>
[18:01:07.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:07.993] Resolved: FALSE
[18:01:07.993] Value: <not collected>
[18:01:07.993] Conditions captured: <none>
[18:01:07.993] Early signaling: FALSE
[18:01:07.993] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:07.993] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.005] Chunk #1 of 2 ... DONE
[18:01:08.006] Chunk #2 of 2 ...
[18:01:08.006]  - Finding globals in '...' for chunk #2 ...
[18:01:08.006] getGlobalsAndPackages() ...
[18:01:08.006] Searching for globals...
[18:01:08.007] 
[18:01:08.007] Searching for globals ... DONE
[18:01:08.007] - globals: [0] <none>
[18:01:08.008] getGlobalsAndPackages() ... DONE
[18:01:08.008]    + additional globals found: [n=0] 
[18:01:08.008]    + additional namespaces needed: [n=0] 
[18:01:08.008]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:08.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.009]  - seeds: <none>
[18:01:08.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.009] getGlobalsAndPackages() ...
[18:01:08.010] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.010] Resolving globals: FALSE
[18:01:08.011] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[18:01:08.012] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:08.012] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.012] 
[18:01:08.012] getGlobalsAndPackages() ... DONE
[18:01:08.013] run() for ‘Future’ ...
[18:01:08.013] - state: ‘created’
[18:01:08.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.036] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.037] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.037]   - Field: ‘node’
[18:01:08.037]   - Field: ‘label’
[18:01:08.037]   - Field: ‘local’
[18:01:08.038]   - Field: ‘owner’
[18:01:08.038]   - Field: ‘envir’
[18:01:08.038]   - Field: ‘workers’
[18:01:08.038]   - Field: ‘packages’
[18:01:08.038]   - Field: ‘gc’
[18:01:08.039]   - Field: ‘conditions’
[18:01:08.039]   - Field: ‘persistent’
[18:01:08.039]   - Field: ‘expr’
[18:01:08.039]   - Field: ‘uuid’
[18:01:08.039]   - Field: ‘seed’
[18:01:08.040]   - Field: ‘version’
[18:01:08.040]   - Field: ‘result’
[18:01:08.040]   - Field: ‘asynchronous’
[18:01:08.040]   - Field: ‘calls’
[18:01:08.040]   - Field: ‘globals’
[18:01:08.040]   - Field: ‘stdout’
[18:01:08.041]   - Field: ‘earlySignal’
[18:01:08.041]   - Field: ‘lazy’
[18:01:08.041]   - Field: ‘state’
[18:01:08.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.041] - Launch lazy future ...
[18:01:08.042] Packages needed by the future expression (n = 0): <none>
[18:01:08.042] Packages needed by future strategies (n = 0): <none>
[18:01:08.043] {
[18:01:08.043]     {
[18:01:08.043]         {
[18:01:08.043]             ...future.startTime <- base::Sys.time()
[18:01:08.043]             {
[18:01:08.043]                 {
[18:01:08.043]                   {
[18:01:08.043]                     {
[18:01:08.043]                       base::local({
[18:01:08.043]                         has_future <- base::requireNamespace("future", 
[18:01:08.043]                           quietly = TRUE)
[18:01:08.043]                         if (has_future) {
[18:01:08.043]                           ns <- base::getNamespace("future")
[18:01:08.043]                           version <- ns[[".package"]][["version"]]
[18:01:08.043]                           if (is.null(version)) 
[18:01:08.043]                             version <- utils::packageVersion("future")
[18:01:08.043]                         }
[18:01:08.043]                         else {
[18:01:08.043]                           version <- NULL
[18:01:08.043]                         }
[18:01:08.043]                         if (!has_future || version < "1.8.0") {
[18:01:08.043]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.043]                             "", base::R.version$version.string), 
[18:01:08.043]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.043]                               "release", "version")], collapse = " "), 
[18:01:08.043]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.043]                             info)
[18:01:08.043]                           info <- base::paste(info, collapse = "; ")
[18:01:08.043]                           if (!has_future) {
[18:01:08.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.043]                               info)
[18:01:08.043]                           }
[18:01:08.043]                           else {
[18:01:08.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.043]                               info, version)
[18:01:08.043]                           }
[18:01:08.043]                           base::stop(msg)
[18:01:08.043]                         }
[18:01:08.043]                       })
[18:01:08.043]                     }
[18:01:08.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.043]                     base::options(mc.cores = 1L)
[18:01:08.043]                   }
[18:01:08.043]                   ...future.strategy.old <- future::plan("list")
[18:01:08.043]                   options(future.plan = NULL)
[18:01:08.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.043]                 }
[18:01:08.043]                 ...future.workdir <- getwd()
[18:01:08.043]             }
[18:01:08.043]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.043]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.043]         }
[18:01:08.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.043]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.043]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.043]             base::names(...future.oldOptions))
[18:01:08.043]     }
[18:01:08.043]     if (FALSE) {
[18:01:08.043]     }
[18:01:08.043]     else {
[18:01:08.043]         if (TRUE) {
[18:01:08.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.043]                 open = "w")
[18:01:08.043]         }
[18:01:08.043]         else {
[18:01:08.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.043]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.043]         }
[18:01:08.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.043]             base::sink(type = "output", split = FALSE)
[18:01:08.043]             base::close(...future.stdout)
[18:01:08.043]         }, add = TRUE)
[18:01:08.043]     }
[18:01:08.043]     ...future.frame <- base::sys.nframe()
[18:01:08.043]     ...future.conditions <- base::list()
[18:01:08.043]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.043]     if (FALSE) {
[18:01:08.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.043]     }
[18:01:08.043]     ...future.result <- base::tryCatch({
[18:01:08.043]         base::withCallingHandlers({
[18:01:08.043]             ...future.value <- base::withVisible(base::local({
[18:01:08.043]                 ...future.makeSendCondition <- base::local({
[18:01:08.043]                   sendCondition <- NULL
[18:01:08.043]                   function(frame = 1L) {
[18:01:08.043]                     if (is.function(sendCondition)) 
[18:01:08.043]                       return(sendCondition)
[18:01:08.043]                     ns <- getNamespace("parallel")
[18:01:08.043]                     if (exists("sendData", mode = "function", 
[18:01:08.043]                       envir = ns)) {
[18:01:08.043]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.043]                         envir = ns)
[18:01:08.043]                       envir <- sys.frame(frame)
[18:01:08.043]                       master <- NULL
[18:01:08.043]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.043]                         !identical(envir, emptyenv())) {
[18:01:08.043]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.043]                           inherits = FALSE)) {
[18:01:08.043]                           master <- get("master", mode = "list", 
[18:01:08.043]                             envir = envir, inherits = FALSE)
[18:01:08.043]                           if (inherits(master, c("SOCKnode", 
[18:01:08.043]                             "SOCK0node"))) {
[18:01:08.043]                             sendCondition <<- function(cond) {
[18:01:08.043]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.043]                                 success = TRUE)
[18:01:08.043]                               parallel_sendData(master, data)
[18:01:08.043]                             }
[18:01:08.043]                             return(sendCondition)
[18:01:08.043]                           }
[18:01:08.043]                         }
[18:01:08.043]                         frame <- frame + 1L
[18:01:08.043]                         envir <- sys.frame(frame)
[18:01:08.043]                       }
[18:01:08.043]                     }
[18:01:08.043]                     sendCondition <<- function(cond) NULL
[18:01:08.043]                   }
[18:01:08.043]                 })
[18:01:08.043]                 withCallingHandlers({
[18:01:08.043]                   {
[18:01:08.043]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.043]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.043]                       ...future.globals.maxSize)) {
[18:01:08.043]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.043]                       on.exit(options(oopts), add = TRUE)
[18:01:08.043]                     }
[18:01:08.043]                     {
[18:01:08.043]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.043]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.043]                         USE.NAMES = FALSE)
[18:01:08.043]                       do.call(mapply, args = args)
[18:01:08.043]                     }
[18:01:08.043]                   }
[18:01:08.043]                 }, immediateCondition = function(cond) {
[18:01:08.043]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.043]                   sendCondition(cond)
[18:01:08.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.043]                   {
[18:01:08.043]                     inherits <- base::inherits
[18:01:08.043]                     invokeRestart <- base::invokeRestart
[18:01:08.043]                     is.null <- base::is.null
[18:01:08.043]                     muffled <- FALSE
[18:01:08.043]                     if (inherits(cond, "message")) {
[18:01:08.043]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.043]                       if (muffled) 
[18:01:08.043]                         invokeRestart("muffleMessage")
[18:01:08.043]                     }
[18:01:08.043]                     else if (inherits(cond, "warning")) {
[18:01:08.043]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.043]                       if (muffled) 
[18:01:08.043]                         invokeRestart("muffleWarning")
[18:01:08.043]                     }
[18:01:08.043]                     else if (inherits(cond, "condition")) {
[18:01:08.043]                       if (!is.null(pattern)) {
[18:01:08.043]                         computeRestarts <- base::computeRestarts
[18:01:08.043]                         grepl <- base::grepl
[18:01:08.043]                         restarts <- computeRestarts(cond)
[18:01:08.043]                         for (restart in restarts) {
[18:01:08.043]                           name <- restart$name
[18:01:08.043]                           if (is.null(name)) 
[18:01:08.043]                             next
[18:01:08.043]                           if (!grepl(pattern, name)) 
[18:01:08.043]                             next
[18:01:08.043]                           invokeRestart(restart)
[18:01:08.043]                           muffled <- TRUE
[18:01:08.043]                           break
[18:01:08.043]                         }
[18:01:08.043]                       }
[18:01:08.043]                     }
[18:01:08.043]                     invisible(muffled)
[18:01:08.043]                   }
[18:01:08.043]                   muffleCondition(cond)
[18:01:08.043]                 })
[18:01:08.043]             }))
[18:01:08.043]             future::FutureResult(value = ...future.value$value, 
[18:01:08.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.043]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.043]                     ...future.globalenv.names))
[18:01:08.043]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.043]         }, condition = base::local({
[18:01:08.043]             c <- base::c
[18:01:08.043]             inherits <- base::inherits
[18:01:08.043]             invokeRestart <- base::invokeRestart
[18:01:08.043]             length <- base::length
[18:01:08.043]             list <- base::list
[18:01:08.043]             seq.int <- base::seq.int
[18:01:08.043]             signalCondition <- base::signalCondition
[18:01:08.043]             sys.calls <- base::sys.calls
[18:01:08.043]             `[[` <- base::`[[`
[18:01:08.043]             `+` <- base::`+`
[18:01:08.043]             `<<-` <- base::`<<-`
[18:01:08.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.043]                   3L)]
[18:01:08.043]             }
[18:01:08.043]             function(cond) {
[18:01:08.043]                 is_error <- inherits(cond, "error")
[18:01:08.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.043]                   NULL)
[18:01:08.043]                 if (is_error) {
[18:01:08.043]                   sessionInformation <- function() {
[18:01:08.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.043]                       search = base::search(), system = base::Sys.info())
[18:01:08.043]                   }
[18:01:08.043]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.043]                     cond$call), session = sessionInformation(), 
[18:01:08.043]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.043]                   signalCondition(cond)
[18:01:08.043]                 }
[18:01:08.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.043]                 "immediateCondition"))) {
[18:01:08.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.043]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.043]                   if (TRUE && !signal) {
[18:01:08.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.043]                     {
[18:01:08.043]                       inherits <- base::inherits
[18:01:08.043]                       invokeRestart <- base::invokeRestart
[18:01:08.043]                       is.null <- base::is.null
[18:01:08.043]                       muffled <- FALSE
[18:01:08.043]                       if (inherits(cond, "message")) {
[18:01:08.043]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.043]                         if (muffled) 
[18:01:08.043]                           invokeRestart("muffleMessage")
[18:01:08.043]                       }
[18:01:08.043]                       else if (inherits(cond, "warning")) {
[18:01:08.043]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.043]                         if (muffled) 
[18:01:08.043]                           invokeRestart("muffleWarning")
[18:01:08.043]                       }
[18:01:08.043]                       else if (inherits(cond, "condition")) {
[18:01:08.043]                         if (!is.null(pattern)) {
[18:01:08.043]                           computeRestarts <- base::computeRestarts
[18:01:08.043]                           grepl <- base::grepl
[18:01:08.043]                           restarts <- computeRestarts(cond)
[18:01:08.043]                           for (restart in restarts) {
[18:01:08.043]                             name <- restart$name
[18:01:08.043]                             if (is.null(name)) 
[18:01:08.043]                               next
[18:01:08.043]                             if (!grepl(pattern, name)) 
[18:01:08.043]                               next
[18:01:08.043]                             invokeRestart(restart)
[18:01:08.043]                             muffled <- TRUE
[18:01:08.043]                             break
[18:01:08.043]                           }
[18:01:08.043]                         }
[18:01:08.043]                       }
[18:01:08.043]                       invisible(muffled)
[18:01:08.043]                     }
[18:01:08.043]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.043]                   }
[18:01:08.043]                 }
[18:01:08.043]                 else {
[18:01:08.043]                   if (TRUE) {
[18:01:08.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.043]                     {
[18:01:08.043]                       inherits <- base::inherits
[18:01:08.043]                       invokeRestart <- base::invokeRestart
[18:01:08.043]                       is.null <- base::is.null
[18:01:08.043]                       muffled <- FALSE
[18:01:08.043]                       if (inherits(cond, "message")) {
[18:01:08.043]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.043]                         if (muffled) 
[18:01:08.043]                           invokeRestart("muffleMessage")
[18:01:08.043]                       }
[18:01:08.043]                       else if (inherits(cond, "warning")) {
[18:01:08.043]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.043]                         if (muffled) 
[18:01:08.043]                           invokeRestart("muffleWarning")
[18:01:08.043]                       }
[18:01:08.043]                       else if (inherits(cond, "condition")) {
[18:01:08.043]                         if (!is.null(pattern)) {
[18:01:08.043]                           computeRestarts <- base::computeRestarts
[18:01:08.043]                           grepl <- base::grepl
[18:01:08.043]                           restarts <- computeRestarts(cond)
[18:01:08.043]                           for (restart in restarts) {
[18:01:08.043]                             name <- restart$name
[18:01:08.043]                             if (is.null(name)) 
[18:01:08.043]                               next
[18:01:08.043]                             if (!grepl(pattern, name)) 
[18:01:08.043]                               next
[18:01:08.043]                             invokeRestart(restart)
[18:01:08.043]                             muffled <- TRUE
[18:01:08.043]                             break
[18:01:08.043]                           }
[18:01:08.043]                         }
[18:01:08.043]                       }
[18:01:08.043]                       invisible(muffled)
[18:01:08.043]                     }
[18:01:08.043]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.043]                   }
[18:01:08.043]                 }
[18:01:08.043]             }
[18:01:08.043]         }))
[18:01:08.043]     }, error = function(ex) {
[18:01:08.043]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.043]                 ...future.rng), started = ...future.startTime, 
[18:01:08.043]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.043]             version = "1.8"), class = "FutureResult")
[18:01:08.043]     }, finally = {
[18:01:08.043]         if (!identical(...future.workdir, getwd())) 
[18:01:08.043]             setwd(...future.workdir)
[18:01:08.043]         {
[18:01:08.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.043]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.043]             }
[18:01:08.043]             base::options(...future.oldOptions)
[18:01:08.043]             if (.Platform$OS.type == "windows") {
[18:01:08.043]                 old_names <- names(...future.oldEnvVars)
[18:01:08.043]                 envs <- base::Sys.getenv()
[18:01:08.043]                 names <- names(envs)
[18:01:08.043]                 common <- intersect(names, old_names)
[18:01:08.043]                 added <- setdiff(names, old_names)
[18:01:08.043]                 removed <- setdiff(old_names, names)
[18:01:08.043]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.043]                   envs[common]]
[18:01:08.043]                 NAMES <- toupper(changed)
[18:01:08.043]                 args <- list()
[18:01:08.043]                 for (kk in seq_along(NAMES)) {
[18:01:08.043]                   name <- changed[[kk]]
[18:01:08.043]                   NAME <- NAMES[[kk]]
[18:01:08.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.043]                     next
[18:01:08.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.043]                 }
[18:01:08.043]                 NAMES <- toupper(added)
[18:01:08.043]                 for (kk in seq_along(NAMES)) {
[18:01:08.043]                   name <- added[[kk]]
[18:01:08.043]                   NAME <- NAMES[[kk]]
[18:01:08.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.043]                     next
[18:01:08.043]                   args[[name]] <- ""
[18:01:08.043]                 }
[18:01:08.043]                 NAMES <- toupper(removed)
[18:01:08.043]                 for (kk in seq_along(NAMES)) {
[18:01:08.043]                   name <- removed[[kk]]
[18:01:08.043]                   NAME <- NAMES[[kk]]
[18:01:08.043]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.043]                     next
[18:01:08.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.043]                 }
[18:01:08.043]                 if (length(args) > 0) 
[18:01:08.043]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.043]             }
[18:01:08.043]             else {
[18:01:08.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.043]             }
[18:01:08.043]             {
[18:01:08.043]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.043]                   0L) {
[18:01:08.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.043]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.043]                   base::options(opts)
[18:01:08.043]                 }
[18:01:08.043]                 {
[18:01:08.043]                   {
[18:01:08.043]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.043]                     NULL
[18:01:08.043]                   }
[18:01:08.043]                   options(future.plan = NULL)
[18:01:08.043]                   if (is.na(NA_character_)) 
[18:01:08.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.043]                     .init = FALSE)
[18:01:08.043]                 }
[18:01:08.043]             }
[18:01:08.043]         }
[18:01:08.043]     })
[18:01:08.043]     if (TRUE) {
[18:01:08.043]         base::sink(type = "output", split = FALSE)
[18:01:08.043]         if (TRUE) {
[18:01:08.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.043]         }
[18:01:08.043]         else {
[18:01:08.043]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.043]         }
[18:01:08.043]         base::close(...future.stdout)
[18:01:08.043]         ...future.stdout <- NULL
[18:01:08.043]     }
[18:01:08.043]     ...future.result$conditions <- ...future.conditions
[18:01:08.043]     ...future.result$finished <- base::Sys.time()
[18:01:08.043]     ...future.result
[18:01:08.043] }
[18:01:08.049] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[18:01:08.049] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[18:01:08.050] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[18:01:08.051] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:08.051] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.052] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[18:01:08.053] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[18:01:08.053] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:08.054] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.054] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:08.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.055] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[18:01:08.056] MultisessionFuture started
[18:01:08.056] - Launch lazy future ... done
[18:01:08.056] run() for ‘MultisessionFuture’ ... done
[18:01:08.057] Created future:
[18:01:08.057] MultisessionFuture:
[18:01:08.057] Label: ‘future_.mapply-2’
[18:01:08.057] Expression:
[18:01:08.057] {
[18:01:08.057]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.057]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.057]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.057]         on.exit(options(oopts), add = TRUE)
[18:01:08.057]     }
[18:01:08.057]     {
[18:01:08.057]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.057]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.057]         do.call(mapply, args = args)
[18:01:08.057]     }
[18:01:08.057] }
[18:01:08.057] Lazy evaluation: FALSE
[18:01:08.057] Asynchronous evaluation: TRUE
[18:01:08.057] Local evaluation: TRUE
[18:01:08.057] Environment: R_GlobalEnv
[18:01:08.057] Capture standard output: TRUE
[18:01:08.057] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.057] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.057] Packages: <none>
[18:01:08.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.057] Resolved: FALSE
[18:01:08.057] Value: <not collected>
[18:01:08.057] Conditions captured: <none>
[18:01:08.057] Early signaling: FALSE
[18:01:08.057] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.057] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.073] Chunk #2 of 2 ... DONE
[18:01:08.073] Launching 2 futures (chunks) ... DONE
[18:01:08.073] Resolving 2 futures (chunks) ...
[18:01:08.074] resolve() on list ...
[18:01:08.074]  recursive: 0
[18:01:08.074]  length: 2
[18:01:08.074] 
[18:01:08.075] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.075] - Validating connection of MultisessionFuture
[18:01:08.076] - received message: FutureResult
[18:01:08.076] - Received FutureResult
[18:01:08.076] - Erased future from FutureRegistry
[18:01:08.076] result() for ClusterFuture ...
[18:01:08.077] - result already collected: FutureResult
[18:01:08.077] result() for ClusterFuture ... done
[18:01:08.077] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.077] Future #1
[18:01:08.077] result() for ClusterFuture ...
[18:01:08.077] - result already collected: FutureResult
[18:01:08.078] result() for ClusterFuture ... done
[18:01:08.078] result() for ClusterFuture ...
[18:01:08.078] - result already collected: FutureResult
[18:01:08.078] result() for ClusterFuture ... done
[18:01:08.078] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:08.079] - nx: 2
[18:01:08.079] - relay: TRUE
[18:01:08.079] - stdout: TRUE
[18:01:08.079] - signal: TRUE
[18:01:08.079] - resignal: FALSE
[18:01:08.079] - force: TRUE
[18:01:08.080] - relayed: [n=2] FALSE, FALSE
[18:01:08.080] - queued futures: [n=2] FALSE, FALSE
[18:01:08.080]  - until=1
[18:01:08.080]  - relaying element #1
[18:01:08.080] result() for ClusterFuture ...
[18:01:08.081] - result already collected: FutureResult
[18:01:08.081] result() for ClusterFuture ... done
[18:01:08.081] result() for ClusterFuture ...
[18:01:08.081] - result already collected: FutureResult
[18:01:08.081] result() for ClusterFuture ... done
[18:01:08.081] result() for ClusterFuture ...
[18:01:08.082] - result already collected: FutureResult
[18:01:08.082] result() for ClusterFuture ... done
[18:01:08.082] result() for ClusterFuture ...
[18:01:08.082] - result already collected: FutureResult
[18:01:08.082] result() for ClusterFuture ... done
[18:01:08.083] - relayed: [n=2] TRUE, FALSE
[18:01:08.083] - queued futures: [n=2] TRUE, FALSE
[18:01:08.083] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:08.083]  length: 1 (resolved future 1)
[18:01:08.105] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.105] - Validating connection of MultisessionFuture
[18:01:08.106] - received message: FutureResult
[18:01:08.106] - Received FutureResult
[18:01:08.106] - Erased future from FutureRegistry
[18:01:08.106] result() for ClusterFuture ...
[18:01:08.107] - result already collected: FutureResult
[18:01:08.107] result() for ClusterFuture ... done
[18:01:08.107] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.107] Future #2
[18:01:08.107] result() for ClusterFuture ...
[18:01:08.108] - result already collected: FutureResult
[18:01:08.108] result() for ClusterFuture ... done
[18:01:08.108] result() for ClusterFuture ...
[18:01:08.108] - result already collected: FutureResult
[18:01:08.108] result() for ClusterFuture ... done
[18:01:08.108] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:08.109] - nx: 2
[18:01:08.109] - relay: TRUE
[18:01:08.109] - stdout: TRUE
[18:01:08.109] - signal: TRUE
[18:01:08.109] - resignal: FALSE
[18:01:08.110] - force: TRUE
[18:01:08.110] - relayed: [n=2] TRUE, FALSE
[18:01:08.110] - queued futures: [n=2] TRUE, FALSE
[18:01:08.110]  - until=2
[18:01:08.110]  - relaying element #2
[18:01:08.110] result() for ClusterFuture ...
[18:01:08.111] - result already collected: FutureResult
[18:01:08.111] result() for ClusterFuture ... done
[18:01:08.111] result() for ClusterFuture ...
[18:01:08.111] - result already collected: FutureResult
[18:01:08.111] result() for ClusterFuture ... done
[18:01:08.112] result() for ClusterFuture ...
[18:01:08.112] - result already collected: FutureResult
[18:01:08.112] result() for ClusterFuture ... done
[18:01:08.112] result() for ClusterFuture ...
[18:01:08.112] - result already collected: FutureResult
[18:01:08.112] result() for ClusterFuture ... done
[18:01:08.113] - relayed: [n=2] TRUE, TRUE
[18:01:08.113] - queued futures: [n=2] TRUE, TRUE
[18:01:08.113] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:08.113]  length: 0 (resolved future 2)
[18:01:08.113] Relaying remaining futures
[18:01:08.114] signalConditionsASAP(NULL, pos=0) ...
[18:01:08.114] - nx: 2
[18:01:08.114] - relay: TRUE
[18:01:08.114] - stdout: TRUE
[18:01:08.114] - signal: TRUE
[18:01:08.114] - resignal: FALSE
[18:01:08.115] - force: TRUE
[18:01:08.115] - relayed: [n=2] TRUE, TRUE
[18:01:08.115] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:08.115] - relayed: [n=2] TRUE, TRUE
[18:01:08.115] - queued futures: [n=2] TRUE, TRUE
[18:01:08.116] signalConditionsASAP(NULL, pos=0) ... done
[18:01:08.116] resolve() on list ... DONE
[18:01:08.116] result() for ClusterFuture ...
[18:01:08.116] - result already collected: FutureResult
[18:01:08.116] result() for ClusterFuture ... done
[18:01:08.116] result() for ClusterFuture ...
[18:01:08.117] - result already collected: FutureResult
[18:01:08.117] result() for ClusterFuture ... done
[18:01:08.117] result() for ClusterFuture ...
[18:01:08.117] - result already collected: FutureResult
[18:01:08.117] result() for ClusterFuture ... done
[18:01:08.118] result() for ClusterFuture ...
[18:01:08.118] - result already collected: FutureResult
[18:01:08.118] result() for ClusterFuture ... done
[18:01:08.118]  - Number of value chunks collected: 2
[18:01:08.118] Resolving 2 futures (chunks) ... DONE
[18:01:08.119] Reducing values from 2 chunks ...
[18:01:08.119]  - Number of values collected after concatenation: 5
[18:01:08.119]  - Number of values expected: 5
[18:01:08.119] Reducing values from 2 chunks ... DONE
[18:01:08.119] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[18:01:08.120] future_mapply() ...
[18:01:08.126] Number of chunks: 1
[18:01:08.126] getGlobalsAndPackagesXApply() ...
[18:01:08.126]  - future.globals: TRUE
[18:01:08.126] getGlobalsAndPackages() ...
[18:01:08.127] Searching for globals...
[18:01:08.129] - globals found: [1] ‘FUN’
[18:01:08.129] Searching for globals ... DONE
[18:01:08.129] Resolving globals: FALSE
[18:01:08.130] The total size of the 1 globals is 848 bytes (848 bytes)
[18:01:08.130] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:01:08.130] - globals: [1] ‘FUN’
[18:01:08.131] 
[18:01:08.131] getGlobalsAndPackages() ... DONE
[18:01:08.131]  - globals found/used: [n=1] ‘FUN’
[18:01:08.131]  - needed namespaces: [n=0] 
[18:01:08.131] Finding globals ... DONE
[18:01:08.132] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:08.132] List of 2
[18:01:08.132]  $ ...future.FUN:function (x)  
[18:01:08.132]  $ MoreArgs     : NULL
[18:01:08.132]  - attr(*, "where")=List of 2
[18:01:08.132]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:08.132]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:08.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:08.132]  - attr(*, "resolved")= logi FALSE
[18:01:08.132]  - attr(*, "total_size")= num NA
[18:01:08.137] Packages to be attached in all futures: [n=0] 
[18:01:08.137] getGlobalsAndPackagesXApply() ... DONE
[18:01:08.137] Number of futures (= number of chunks): 1
[18:01:08.138] Launching 1 futures (chunks) ...
[18:01:08.138] Chunk #1 of 1 ...
[18:01:08.138]  - Finding globals in '...' for chunk #1 ...
[18:01:08.138] getGlobalsAndPackages() ...
[18:01:08.138] Searching for globals...
[18:01:08.139] 
[18:01:08.139] Searching for globals ... DONE
[18:01:08.139] - globals: [0] <none>
[18:01:08.139] getGlobalsAndPackages() ... DONE
[18:01:08.140]    + additional globals found: [n=0] 
[18:01:08.140]    + additional namespaces needed: [n=0] 
[18:01:08.140]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:08.140]  - seeds: <none>
[18:01:08.140]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.141] getGlobalsAndPackages() ...
[18:01:08.141] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.141] Resolving globals: FALSE
[18:01:08.142] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[18:01:08.143] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:08.143] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.143] 
[18:01:08.144] getGlobalsAndPackages() ... DONE
[18:01:08.144] run() for ‘Future’ ...
[18:01:08.144] - state: ‘created’
[18:01:08.144] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.168] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.168]   - Field: ‘node’
[18:01:08.168]   - Field: ‘label’
[18:01:08.169]   - Field: ‘local’
[18:01:08.169]   - Field: ‘owner’
[18:01:08.169]   - Field: ‘envir’
[18:01:08.169]   - Field: ‘workers’
[18:01:08.169]   - Field: ‘packages’
[18:01:08.170]   - Field: ‘gc’
[18:01:08.170]   - Field: ‘conditions’
[18:01:08.170]   - Field: ‘persistent’
[18:01:08.170]   - Field: ‘expr’
[18:01:08.170]   - Field: ‘uuid’
[18:01:08.171]   - Field: ‘seed’
[18:01:08.171]   - Field: ‘version’
[18:01:08.171]   - Field: ‘result’
[18:01:08.171]   - Field: ‘asynchronous’
[18:01:08.171]   - Field: ‘calls’
[18:01:08.172]   - Field: ‘globals’
[18:01:08.172]   - Field: ‘stdout’
[18:01:08.172]   - Field: ‘earlySignal’
[18:01:08.172]   - Field: ‘lazy’
[18:01:08.172]   - Field: ‘state’
[18:01:08.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.173] - Launch lazy future ...
[18:01:08.173] Packages needed by the future expression (n = 0): <none>
[18:01:08.174] Packages needed by future strategies (n = 0): <none>
[18:01:08.174] {
[18:01:08.174]     {
[18:01:08.174]         {
[18:01:08.174]             ...future.startTime <- base::Sys.time()
[18:01:08.174]             {
[18:01:08.174]                 {
[18:01:08.174]                   {
[18:01:08.174]                     {
[18:01:08.174]                       base::local({
[18:01:08.174]                         has_future <- base::requireNamespace("future", 
[18:01:08.174]                           quietly = TRUE)
[18:01:08.174]                         if (has_future) {
[18:01:08.174]                           ns <- base::getNamespace("future")
[18:01:08.174]                           version <- ns[[".package"]][["version"]]
[18:01:08.174]                           if (is.null(version)) 
[18:01:08.174]                             version <- utils::packageVersion("future")
[18:01:08.174]                         }
[18:01:08.174]                         else {
[18:01:08.174]                           version <- NULL
[18:01:08.174]                         }
[18:01:08.174]                         if (!has_future || version < "1.8.0") {
[18:01:08.174]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.174]                             "", base::R.version$version.string), 
[18:01:08.174]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.174]                               "release", "version")], collapse = " "), 
[18:01:08.174]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.174]                             info)
[18:01:08.174]                           info <- base::paste(info, collapse = "; ")
[18:01:08.174]                           if (!has_future) {
[18:01:08.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.174]                               info)
[18:01:08.174]                           }
[18:01:08.174]                           else {
[18:01:08.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.174]                               info, version)
[18:01:08.174]                           }
[18:01:08.174]                           base::stop(msg)
[18:01:08.174]                         }
[18:01:08.174]                       })
[18:01:08.174]                     }
[18:01:08.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.174]                     base::options(mc.cores = 1L)
[18:01:08.174]                   }
[18:01:08.174]                   ...future.strategy.old <- future::plan("list")
[18:01:08.174]                   options(future.plan = NULL)
[18:01:08.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.174]                 }
[18:01:08.174]                 ...future.workdir <- getwd()
[18:01:08.174]             }
[18:01:08.174]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.174]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.174]         }
[18:01:08.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:08.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.174]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.174]             base::names(...future.oldOptions))
[18:01:08.174]     }
[18:01:08.174]     if (FALSE) {
[18:01:08.174]     }
[18:01:08.174]     else {
[18:01:08.174]         if (TRUE) {
[18:01:08.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.174]                 open = "w")
[18:01:08.174]         }
[18:01:08.174]         else {
[18:01:08.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.174]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.174]         }
[18:01:08.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.174]             base::sink(type = "output", split = FALSE)
[18:01:08.174]             base::close(...future.stdout)
[18:01:08.174]         }, add = TRUE)
[18:01:08.174]     }
[18:01:08.174]     ...future.frame <- base::sys.nframe()
[18:01:08.174]     ...future.conditions <- base::list()
[18:01:08.174]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.174]     if (FALSE) {
[18:01:08.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.174]     }
[18:01:08.174]     ...future.result <- base::tryCatch({
[18:01:08.174]         base::withCallingHandlers({
[18:01:08.174]             ...future.value <- base::withVisible(base::local({
[18:01:08.174]                 ...future.makeSendCondition <- base::local({
[18:01:08.174]                   sendCondition <- NULL
[18:01:08.174]                   function(frame = 1L) {
[18:01:08.174]                     if (is.function(sendCondition)) 
[18:01:08.174]                       return(sendCondition)
[18:01:08.174]                     ns <- getNamespace("parallel")
[18:01:08.174]                     if (exists("sendData", mode = "function", 
[18:01:08.174]                       envir = ns)) {
[18:01:08.174]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.174]                         envir = ns)
[18:01:08.174]                       envir <- sys.frame(frame)
[18:01:08.174]                       master <- NULL
[18:01:08.174]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.174]                         !identical(envir, emptyenv())) {
[18:01:08.174]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.174]                           inherits = FALSE)) {
[18:01:08.174]                           master <- get("master", mode = "list", 
[18:01:08.174]                             envir = envir, inherits = FALSE)
[18:01:08.174]                           if (inherits(master, c("SOCKnode", 
[18:01:08.174]                             "SOCK0node"))) {
[18:01:08.174]                             sendCondition <<- function(cond) {
[18:01:08.174]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.174]                                 success = TRUE)
[18:01:08.174]                               parallel_sendData(master, data)
[18:01:08.174]                             }
[18:01:08.174]                             return(sendCondition)
[18:01:08.174]                           }
[18:01:08.174]                         }
[18:01:08.174]                         frame <- frame + 1L
[18:01:08.174]                         envir <- sys.frame(frame)
[18:01:08.174]                       }
[18:01:08.174]                     }
[18:01:08.174]                     sendCondition <<- function(cond) NULL
[18:01:08.174]                   }
[18:01:08.174]                 })
[18:01:08.174]                 withCallingHandlers({
[18:01:08.174]                   {
[18:01:08.174]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.174]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.174]                       ...future.globals.maxSize)) {
[18:01:08.174]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.174]                       on.exit(options(oopts), add = TRUE)
[18:01:08.174]                     }
[18:01:08.174]                     {
[18:01:08.174]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.174]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.174]                         USE.NAMES = FALSE)
[18:01:08.174]                       do.call(mapply, args = args)
[18:01:08.174]                     }
[18:01:08.174]                   }
[18:01:08.174]                 }, immediateCondition = function(cond) {
[18:01:08.174]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.174]                   sendCondition(cond)
[18:01:08.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.174]                   {
[18:01:08.174]                     inherits <- base::inherits
[18:01:08.174]                     invokeRestart <- base::invokeRestart
[18:01:08.174]                     is.null <- base::is.null
[18:01:08.174]                     muffled <- FALSE
[18:01:08.174]                     if (inherits(cond, "message")) {
[18:01:08.174]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.174]                       if (muffled) 
[18:01:08.174]                         invokeRestart("muffleMessage")
[18:01:08.174]                     }
[18:01:08.174]                     else if (inherits(cond, "warning")) {
[18:01:08.174]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.174]                       if (muffled) 
[18:01:08.174]                         invokeRestart("muffleWarning")
[18:01:08.174]                     }
[18:01:08.174]                     else if (inherits(cond, "condition")) {
[18:01:08.174]                       if (!is.null(pattern)) {
[18:01:08.174]                         computeRestarts <- base::computeRestarts
[18:01:08.174]                         grepl <- base::grepl
[18:01:08.174]                         restarts <- computeRestarts(cond)
[18:01:08.174]                         for (restart in restarts) {
[18:01:08.174]                           name <- restart$name
[18:01:08.174]                           if (is.null(name)) 
[18:01:08.174]                             next
[18:01:08.174]                           if (!grepl(pattern, name)) 
[18:01:08.174]                             next
[18:01:08.174]                           invokeRestart(restart)
[18:01:08.174]                           muffled <- TRUE
[18:01:08.174]                           break
[18:01:08.174]                         }
[18:01:08.174]                       }
[18:01:08.174]                     }
[18:01:08.174]                     invisible(muffled)
[18:01:08.174]                   }
[18:01:08.174]                   muffleCondition(cond)
[18:01:08.174]                 })
[18:01:08.174]             }))
[18:01:08.174]             future::FutureResult(value = ...future.value$value, 
[18:01:08.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.174]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.174]                     ...future.globalenv.names))
[18:01:08.174]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.174]         }, condition = base::local({
[18:01:08.174]             c <- base::c
[18:01:08.174]             inherits <- base::inherits
[18:01:08.174]             invokeRestart <- base::invokeRestart
[18:01:08.174]             length <- base::length
[18:01:08.174]             list <- base::list
[18:01:08.174]             seq.int <- base::seq.int
[18:01:08.174]             signalCondition <- base::signalCondition
[18:01:08.174]             sys.calls <- base::sys.calls
[18:01:08.174]             `[[` <- base::`[[`
[18:01:08.174]             `+` <- base::`+`
[18:01:08.174]             `<<-` <- base::`<<-`
[18:01:08.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.174]                   3L)]
[18:01:08.174]             }
[18:01:08.174]             function(cond) {
[18:01:08.174]                 is_error <- inherits(cond, "error")
[18:01:08.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.174]                   NULL)
[18:01:08.174]                 if (is_error) {
[18:01:08.174]                   sessionInformation <- function() {
[18:01:08.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.174]                       search = base::search(), system = base::Sys.info())
[18:01:08.174]                   }
[18:01:08.174]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.174]                     cond$call), session = sessionInformation(), 
[18:01:08.174]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.174]                   signalCondition(cond)
[18:01:08.174]                 }
[18:01:08.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.174]                 "immediateCondition"))) {
[18:01:08.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.174]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.174]                   if (TRUE && !signal) {
[18:01:08.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.174]                     {
[18:01:08.174]                       inherits <- base::inherits
[18:01:08.174]                       invokeRestart <- base::invokeRestart
[18:01:08.174]                       is.null <- base::is.null
[18:01:08.174]                       muffled <- FALSE
[18:01:08.174]                       if (inherits(cond, "message")) {
[18:01:08.174]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.174]                         if (muffled) 
[18:01:08.174]                           invokeRestart("muffleMessage")
[18:01:08.174]                       }
[18:01:08.174]                       else if (inherits(cond, "warning")) {
[18:01:08.174]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.174]                         if (muffled) 
[18:01:08.174]                           invokeRestart("muffleWarning")
[18:01:08.174]                       }
[18:01:08.174]                       else if (inherits(cond, "condition")) {
[18:01:08.174]                         if (!is.null(pattern)) {
[18:01:08.174]                           computeRestarts <- base::computeRestarts
[18:01:08.174]                           grepl <- base::grepl
[18:01:08.174]                           restarts <- computeRestarts(cond)
[18:01:08.174]                           for (restart in restarts) {
[18:01:08.174]                             name <- restart$name
[18:01:08.174]                             if (is.null(name)) 
[18:01:08.174]                               next
[18:01:08.174]                             if (!grepl(pattern, name)) 
[18:01:08.174]                               next
[18:01:08.174]                             invokeRestart(restart)
[18:01:08.174]                             muffled <- TRUE
[18:01:08.174]                             break
[18:01:08.174]                           }
[18:01:08.174]                         }
[18:01:08.174]                       }
[18:01:08.174]                       invisible(muffled)
[18:01:08.174]                     }
[18:01:08.174]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.174]                   }
[18:01:08.174]                 }
[18:01:08.174]                 else {
[18:01:08.174]                   if (TRUE) {
[18:01:08.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.174]                     {
[18:01:08.174]                       inherits <- base::inherits
[18:01:08.174]                       invokeRestart <- base::invokeRestart
[18:01:08.174]                       is.null <- base::is.null
[18:01:08.174]                       muffled <- FALSE
[18:01:08.174]                       if (inherits(cond, "message")) {
[18:01:08.174]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.174]                         if (muffled) 
[18:01:08.174]                           invokeRestart("muffleMessage")
[18:01:08.174]                       }
[18:01:08.174]                       else if (inherits(cond, "warning")) {
[18:01:08.174]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.174]                         if (muffled) 
[18:01:08.174]                           invokeRestart("muffleWarning")
[18:01:08.174]                       }
[18:01:08.174]                       else if (inherits(cond, "condition")) {
[18:01:08.174]                         if (!is.null(pattern)) {
[18:01:08.174]                           computeRestarts <- base::computeRestarts
[18:01:08.174]                           grepl <- base::grepl
[18:01:08.174]                           restarts <- computeRestarts(cond)
[18:01:08.174]                           for (restart in restarts) {
[18:01:08.174]                             name <- restart$name
[18:01:08.174]                             if (is.null(name)) 
[18:01:08.174]                               next
[18:01:08.174]                             if (!grepl(pattern, name)) 
[18:01:08.174]                               next
[18:01:08.174]                             invokeRestart(restart)
[18:01:08.174]                             muffled <- TRUE
[18:01:08.174]                             break
[18:01:08.174]                           }
[18:01:08.174]                         }
[18:01:08.174]                       }
[18:01:08.174]                       invisible(muffled)
[18:01:08.174]                     }
[18:01:08.174]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.174]                   }
[18:01:08.174]                 }
[18:01:08.174]             }
[18:01:08.174]         }))
[18:01:08.174]     }, error = function(ex) {
[18:01:08.174]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.174]                 ...future.rng), started = ...future.startTime, 
[18:01:08.174]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.174]             version = "1.8"), class = "FutureResult")
[18:01:08.174]     }, finally = {
[18:01:08.174]         if (!identical(...future.workdir, getwd())) 
[18:01:08.174]             setwd(...future.workdir)
[18:01:08.174]         {
[18:01:08.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.174]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.174]             }
[18:01:08.174]             base::options(...future.oldOptions)
[18:01:08.174]             if (.Platform$OS.type == "windows") {
[18:01:08.174]                 old_names <- names(...future.oldEnvVars)
[18:01:08.174]                 envs <- base::Sys.getenv()
[18:01:08.174]                 names <- names(envs)
[18:01:08.174]                 common <- intersect(names, old_names)
[18:01:08.174]                 added <- setdiff(names, old_names)
[18:01:08.174]                 removed <- setdiff(old_names, names)
[18:01:08.174]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.174]                   envs[common]]
[18:01:08.174]                 NAMES <- toupper(changed)
[18:01:08.174]                 args <- list()
[18:01:08.174]                 for (kk in seq_along(NAMES)) {
[18:01:08.174]                   name <- changed[[kk]]
[18:01:08.174]                   NAME <- NAMES[[kk]]
[18:01:08.174]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.174]                     next
[18:01:08.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.174]                 }
[18:01:08.174]                 NAMES <- toupper(added)
[18:01:08.174]                 for (kk in seq_along(NAMES)) {
[18:01:08.174]                   name <- added[[kk]]
[18:01:08.174]                   NAME <- NAMES[[kk]]
[18:01:08.174]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.174]                     next
[18:01:08.174]                   args[[name]] <- ""
[18:01:08.174]                 }
[18:01:08.174]                 NAMES <- toupper(removed)
[18:01:08.174]                 for (kk in seq_along(NAMES)) {
[18:01:08.174]                   name <- removed[[kk]]
[18:01:08.174]                   NAME <- NAMES[[kk]]
[18:01:08.174]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.174]                     next
[18:01:08.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.174]                 }
[18:01:08.174]                 if (length(args) > 0) 
[18:01:08.174]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.174]             }
[18:01:08.174]             else {
[18:01:08.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.174]             }
[18:01:08.174]             {
[18:01:08.174]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.174]                   0L) {
[18:01:08.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.174]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.174]                   base::options(opts)
[18:01:08.174]                 }
[18:01:08.174]                 {
[18:01:08.174]                   {
[18:01:08.174]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.174]                     NULL
[18:01:08.174]                   }
[18:01:08.174]                   options(future.plan = NULL)
[18:01:08.174]                   if (is.na(NA_character_)) 
[18:01:08.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.174]                     .init = FALSE)
[18:01:08.174]                 }
[18:01:08.174]             }
[18:01:08.174]         }
[18:01:08.174]     })
[18:01:08.174]     if (TRUE) {
[18:01:08.174]         base::sink(type = "output", split = FALSE)
[18:01:08.174]         if (TRUE) {
[18:01:08.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.174]         }
[18:01:08.174]         else {
[18:01:08.174]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.174]         }
[18:01:08.174]         base::close(...future.stdout)
[18:01:08.174]         ...future.stdout <- NULL
[18:01:08.174]     }
[18:01:08.174]     ...future.result$conditions <- ...future.conditions
[18:01:08.174]     ...future.result$finished <- base::Sys.time()
[18:01:08.174]     ...future.result
[18:01:08.174] }
[18:01:08.179] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[18:01:08.180] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[18:01:08.181] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[18:01:08.181] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:08.182] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.182] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:01:08.183] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:01:08.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:08.184] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.184] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:08.185] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.185] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[18:01:08.186] MultisessionFuture started
[18:01:08.187] - Launch lazy future ... done
[18:01:08.187] run() for ‘MultisessionFuture’ ... done
[18:01:08.187] Created future:
[18:01:08.187] MultisessionFuture:
[18:01:08.187] Label: ‘future_mapply-1’
[18:01:08.187] Expression:
[18:01:08.187] {
[18:01:08.187]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.187]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.187]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.187]         on.exit(options(oopts), add = TRUE)
[18:01:08.187]     }
[18:01:08.187]     {
[18:01:08.187]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.187]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.187]         do.call(mapply, args = args)
[18:01:08.187]     }
[18:01:08.187] }
[18:01:08.187] Lazy evaluation: FALSE
[18:01:08.187] Asynchronous evaluation: TRUE
[18:01:08.187] Local evaluation: TRUE
[18:01:08.187] Environment: R_GlobalEnv
[18:01:08.187] Capture standard output: TRUE
[18:01:08.187] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.187] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.187] Packages: <none>
[18:01:08.187] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.187] Resolved: FALSE
[18:01:08.187] Value: <not collected>
[18:01:08.187] Conditions captured: <none>
[18:01:08.187] Early signaling: FALSE
[18:01:08.187] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.187] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.200] Chunk #1 of 1 ... DONE
[18:01:08.200] Launching 1 futures (chunks) ... DONE
[18:01:08.200] Resolving 1 futures (chunks) ...
[18:01:08.200] resolve() on list ...
[18:01:08.201]  recursive: 0
[18:01:08.201]  length: 1
[18:01:08.201] 
[18:01:08.229] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.230] - Validating connection of MultisessionFuture
[18:01:08.230] - received message: FutureResult
[18:01:08.231] - Received FutureResult
[18:01:08.231] - Erased future from FutureRegistry
[18:01:08.231] result() for ClusterFuture ...
[18:01:08.231] - result already collected: FutureResult
[18:01:08.231] result() for ClusterFuture ... done
[18:01:08.232] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.232] Future #1
[18:01:08.232] result() for ClusterFuture ...
[18:01:08.232] - result already collected: FutureResult
[18:01:08.232] result() for ClusterFuture ... done
[18:01:08.233] result() for ClusterFuture ...
[18:01:08.233] - result already collected: FutureResult
[18:01:08.233] result() for ClusterFuture ... done
[18:01:08.233] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:08.233] - nx: 1
[18:01:08.234] - relay: TRUE
[18:01:08.234] - stdout: TRUE
[18:01:08.234] - signal: TRUE
[18:01:08.234] - resignal: FALSE
[18:01:08.234] - force: TRUE
[18:01:08.235] - relayed: [n=1] FALSE
[18:01:08.235] - queued futures: [n=1] FALSE
[18:01:08.235]  - until=1
[18:01:08.235]  - relaying element #1
[18:01:08.235] result() for ClusterFuture ...
[18:01:08.236] - result already collected: FutureResult
[18:01:08.236] result() for ClusterFuture ... done
[18:01:08.236] result() for ClusterFuture ...
[18:01:08.236] - result already collected: FutureResult
[18:01:08.236] result() for ClusterFuture ... done
[18:01:08.237] result() for ClusterFuture ...
[18:01:08.237] - result already collected: FutureResult
[18:01:08.237] result() for ClusterFuture ... done
[18:01:08.237] result() for ClusterFuture ...
[18:01:08.237] - result already collected: FutureResult
[18:01:08.237] result() for ClusterFuture ... done
[18:01:08.238] - relayed: [n=1] TRUE
[18:01:08.238] - queued futures: [n=1] TRUE
[18:01:08.238] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:08.238]  length: 0 (resolved future 1)
[18:01:08.238] Relaying remaining futures
[18:01:08.239] signalConditionsASAP(NULL, pos=0) ...
[18:01:08.239] - nx: 1
[18:01:08.239] - relay: TRUE
[18:01:08.239] - stdout: TRUE
[18:01:08.239] - signal: TRUE
[18:01:08.239] - resignal: FALSE
[18:01:08.240] - force: TRUE
[18:01:08.240] - relayed: [n=1] TRUE
[18:01:08.240] - queued futures: [n=1] TRUE
 - flush all
[18:01:08.240] - relayed: [n=1] TRUE
[18:01:08.240] - queued futures: [n=1] TRUE
[18:01:08.241] signalConditionsASAP(NULL, pos=0) ... done
[18:01:08.241] resolve() on list ... DONE
[18:01:08.241] result() for ClusterFuture ...
[18:01:08.241] - result already collected: FutureResult
[18:01:08.241] result() for ClusterFuture ... done
[18:01:08.242] result() for ClusterFuture ...
[18:01:08.242] - result already collected: FutureResult
[18:01:08.242] result() for ClusterFuture ... done
[18:01:08.242]  - Number of value chunks collected: 1
[18:01:08.242] Resolving 1 futures (chunks) ... DONE
[18:01:08.243] Reducing values from 1 chunks ...
[18:01:08.243]  - Number of values collected after concatenation: 1
[18:01:08.243]  - Number of values expected: 1
[18:01:08.243] Reducing values from 1 chunks ... DONE
[18:01:08.243] future_mapply() ... DONE
[18:01:08.244] future_mapply() ...
[18:01:08.249] Number of chunks: 1
[18:01:08.249] getGlobalsAndPackagesXApply() ...
[18:01:08.249]  - future.globals: TRUE
[18:01:08.250] getGlobalsAndPackages() ...
[18:01:08.250] Searching for globals...
[18:01:08.252] - globals found: [1] ‘FUN’
[18:01:08.252] Searching for globals ... DONE
[18:01:08.252] Resolving globals: FALSE
[18:01:08.253] The total size of the 1 globals is 848 bytes (848 bytes)
[18:01:08.253] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:01:08.254] - globals: [1] ‘FUN’
[18:01:08.254] 
[18:01:08.254] getGlobalsAndPackages() ... DONE
[18:01:08.254]  - globals found/used: [n=1] ‘FUN’
[18:01:08.254]  - needed namespaces: [n=0] 
[18:01:08.255] Finding globals ... DONE
[18:01:08.255] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:08.255] List of 2
[18:01:08.255]  $ ...future.FUN:function (x)  
[18:01:08.255]  $ MoreArgs     : list()
[18:01:08.255]  - attr(*, "where")=List of 2
[18:01:08.255]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:08.255]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:08.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:08.255]  - attr(*, "resolved")= logi FALSE
[18:01:08.255]  - attr(*, "total_size")= num NA
[18:01:08.260] Packages to be attached in all futures: [n=0] 
[18:01:08.260] getGlobalsAndPackagesXApply() ... DONE
[18:01:08.260] Number of futures (= number of chunks): 1
[18:01:08.261] Launching 1 futures (chunks) ...
[18:01:08.261] Chunk #1 of 1 ...
[18:01:08.261]  - Finding globals in '...' for chunk #1 ...
[18:01:08.261] getGlobalsAndPackages() ...
[18:01:08.261] Searching for globals...
[18:01:08.262] 
[18:01:08.262] Searching for globals ... DONE
[18:01:08.262] - globals: [0] <none>
[18:01:08.263] getGlobalsAndPackages() ... DONE
[18:01:08.263]    + additional globals found: [n=0] 
[18:01:08.263]    + additional namespaces needed: [n=0] 
[18:01:08.263]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:08.263]  - seeds: <none>
[18:01:08.264]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.264] getGlobalsAndPackages() ...
[18:01:08.264] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.264] Resolving globals: FALSE
[18:01:08.265] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[18:01:08.266] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[18:01:08.266] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.266] 
[18:01:08.267] getGlobalsAndPackages() ... DONE
[18:01:08.267] run() for ‘Future’ ...
[18:01:08.267] - state: ‘created’
[18:01:08.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.292] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.293]   - Field: ‘node’
[18:01:08.293]   - Field: ‘label’
[18:01:08.293]   - Field: ‘local’
[18:01:08.294]   - Field: ‘owner’
[18:01:08.294]   - Field: ‘envir’
[18:01:08.294]   - Field: ‘workers’
[18:01:08.294]   - Field: ‘packages’
[18:01:08.294]   - Field: ‘gc’
[18:01:08.295]   - Field: ‘conditions’
[18:01:08.295]   - Field: ‘persistent’
[18:01:08.295]   - Field: ‘expr’
[18:01:08.295]   - Field: ‘uuid’
[18:01:08.295]   - Field: ‘seed’
[18:01:08.296]   - Field: ‘version’
[18:01:08.296]   - Field: ‘result’
[18:01:08.296]   - Field: ‘asynchronous’
[18:01:08.296]   - Field: ‘calls’
[18:01:08.296]   - Field: ‘globals’
[18:01:08.296]   - Field: ‘stdout’
[18:01:08.297]   - Field: ‘earlySignal’
[18:01:08.297]   - Field: ‘lazy’
[18:01:08.297]   - Field: ‘state’
[18:01:08.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.297] - Launch lazy future ...
[18:01:08.298] Packages needed by the future expression (n = 0): <none>
[18:01:08.298] Packages needed by future strategies (n = 0): <none>
[18:01:08.299] {
[18:01:08.299]     {
[18:01:08.299]         {
[18:01:08.299]             ...future.startTime <- base::Sys.time()
[18:01:08.299]             {
[18:01:08.299]                 {
[18:01:08.299]                   {
[18:01:08.299]                     {
[18:01:08.299]                       base::local({
[18:01:08.299]                         has_future <- base::requireNamespace("future", 
[18:01:08.299]                           quietly = TRUE)
[18:01:08.299]                         if (has_future) {
[18:01:08.299]                           ns <- base::getNamespace("future")
[18:01:08.299]                           version <- ns[[".package"]][["version"]]
[18:01:08.299]                           if (is.null(version)) 
[18:01:08.299]                             version <- utils::packageVersion("future")
[18:01:08.299]                         }
[18:01:08.299]                         else {
[18:01:08.299]                           version <- NULL
[18:01:08.299]                         }
[18:01:08.299]                         if (!has_future || version < "1.8.0") {
[18:01:08.299]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.299]                             "", base::R.version$version.string), 
[18:01:08.299]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.299]                               "release", "version")], collapse = " "), 
[18:01:08.299]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.299]                             info)
[18:01:08.299]                           info <- base::paste(info, collapse = "; ")
[18:01:08.299]                           if (!has_future) {
[18:01:08.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.299]                               info)
[18:01:08.299]                           }
[18:01:08.299]                           else {
[18:01:08.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.299]                               info, version)
[18:01:08.299]                           }
[18:01:08.299]                           base::stop(msg)
[18:01:08.299]                         }
[18:01:08.299]                       })
[18:01:08.299]                     }
[18:01:08.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.299]                     base::options(mc.cores = 1L)
[18:01:08.299]                   }
[18:01:08.299]                   ...future.strategy.old <- future::plan("list")
[18:01:08.299]                   options(future.plan = NULL)
[18:01:08.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.299]                 }
[18:01:08.299]                 ...future.workdir <- getwd()
[18:01:08.299]             }
[18:01:08.299]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.299]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.299]         }
[18:01:08.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:08.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.299]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.299]             base::names(...future.oldOptions))
[18:01:08.299]     }
[18:01:08.299]     if (FALSE) {
[18:01:08.299]     }
[18:01:08.299]     else {
[18:01:08.299]         if (TRUE) {
[18:01:08.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.299]                 open = "w")
[18:01:08.299]         }
[18:01:08.299]         else {
[18:01:08.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.299]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.299]         }
[18:01:08.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.299]             base::sink(type = "output", split = FALSE)
[18:01:08.299]             base::close(...future.stdout)
[18:01:08.299]         }, add = TRUE)
[18:01:08.299]     }
[18:01:08.299]     ...future.frame <- base::sys.nframe()
[18:01:08.299]     ...future.conditions <- base::list()
[18:01:08.299]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.299]     if (FALSE) {
[18:01:08.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.299]     }
[18:01:08.299]     ...future.result <- base::tryCatch({
[18:01:08.299]         base::withCallingHandlers({
[18:01:08.299]             ...future.value <- base::withVisible(base::local({
[18:01:08.299]                 ...future.makeSendCondition <- base::local({
[18:01:08.299]                   sendCondition <- NULL
[18:01:08.299]                   function(frame = 1L) {
[18:01:08.299]                     if (is.function(sendCondition)) 
[18:01:08.299]                       return(sendCondition)
[18:01:08.299]                     ns <- getNamespace("parallel")
[18:01:08.299]                     if (exists("sendData", mode = "function", 
[18:01:08.299]                       envir = ns)) {
[18:01:08.299]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.299]                         envir = ns)
[18:01:08.299]                       envir <- sys.frame(frame)
[18:01:08.299]                       master <- NULL
[18:01:08.299]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.299]                         !identical(envir, emptyenv())) {
[18:01:08.299]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.299]                           inherits = FALSE)) {
[18:01:08.299]                           master <- get("master", mode = "list", 
[18:01:08.299]                             envir = envir, inherits = FALSE)
[18:01:08.299]                           if (inherits(master, c("SOCKnode", 
[18:01:08.299]                             "SOCK0node"))) {
[18:01:08.299]                             sendCondition <<- function(cond) {
[18:01:08.299]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.299]                                 success = TRUE)
[18:01:08.299]                               parallel_sendData(master, data)
[18:01:08.299]                             }
[18:01:08.299]                             return(sendCondition)
[18:01:08.299]                           }
[18:01:08.299]                         }
[18:01:08.299]                         frame <- frame + 1L
[18:01:08.299]                         envir <- sys.frame(frame)
[18:01:08.299]                       }
[18:01:08.299]                     }
[18:01:08.299]                     sendCondition <<- function(cond) NULL
[18:01:08.299]                   }
[18:01:08.299]                 })
[18:01:08.299]                 withCallingHandlers({
[18:01:08.299]                   {
[18:01:08.299]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.299]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.299]                       ...future.globals.maxSize)) {
[18:01:08.299]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.299]                       on.exit(options(oopts), add = TRUE)
[18:01:08.299]                     }
[18:01:08.299]                     {
[18:01:08.299]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.299]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.299]                         USE.NAMES = FALSE)
[18:01:08.299]                       do.call(mapply, args = args)
[18:01:08.299]                     }
[18:01:08.299]                   }
[18:01:08.299]                 }, immediateCondition = function(cond) {
[18:01:08.299]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.299]                   sendCondition(cond)
[18:01:08.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.299]                   {
[18:01:08.299]                     inherits <- base::inherits
[18:01:08.299]                     invokeRestart <- base::invokeRestart
[18:01:08.299]                     is.null <- base::is.null
[18:01:08.299]                     muffled <- FALSE
[18:01:08.299]                     if (inherits(cond, "message")) {
[18:01:08.299]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.299]                       if (muffled) 
[18:01:08.299]                         invokeRestart("muffleMessage")
[18:01:08.299]                     }
[18:01:08.299]                     else if (inherits(cond, "warning")) {
[18:01:08.299]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.299]                       if (muffled) 
[18:01:08.299]                         invokeRestart("muffleWarning")
[18:01:08.299]                     }
[18:01:08.299]                     else if (inherits(cond, "condition")) {
[18:01:08.299]                       if (!is.null(pattern)) {
[18:01:08.299]                         computeRestarts <- base::computeRestarts
[18:01:08.299]                         grepl <- base::grepl
[18:01:08.299]                         restarts <- computeRestarts(cond)
[18:01:08.299]                         for (restart in restarts) {
[18:01:08.299]                           name <- restart$name
[18:01:08.299]                           if (is.null(name)) 
[18:01:08.299]                             next
[18:01:08.299]                           if (!grepl(pattern, name)) 
[18:01:08.299]                             next
[18:01:08.299]                           invokeRestart(restart)
[18:01:08.299]                           muffled <- TRUE
[18:01:08.299]                           break
[18:01:08.299]                         }
[18:01:08.299]                       }
[18:01:08.299]                     }
[18:01:08.299]                     invisible(muffled)
[18:01:08.299]                   }
[18:01:08.299]                   muffleCondition(cond)
[18:01:08.299]                 })
[18:01:08.299]             }))
[18:01:08.299]             future::FutureResult(value = ...future.value$value, 
[18:01:08.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.299]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.299]                     ...future.globalenv.names))
[18:01:08.299]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.299]         }, condition = base::local({
[18:01:08.299]             c <- base::c
[18:01:08.299]             inherits <- base::inherits
[18:01:08.299]             invokeRestart <- base::invokeRestart
[18:01:08.299]             length <- base::length
[18:01:08.299]             list <- base::list
[18:01:08.299]             seq.int <- base::seq.int
[18:01:08.299]             signalCondition <- base::signalCondition
[18:01:08.299]             sys.calls <- base::sys.calls
[18:01:08.299]             `[[` <- base::`[[`
[18:01:08.299]             `+` <- base::`+`
[18:01:08.299]             `<<-` <- base::`<<-`
[18:01:08.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.299]                   3L)]
[18:01:08.299]             }
[18:01:08.299]             function(cond) {
[18:01:08.299]                 is_error <- inherits(cond, "error")
[18:01:08.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.299]                   NULL)
[18:01:08.299]                 if (is_error) {
[18:01:08.299]                   sessionInformation <- function() {
[18:01:08.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.299]                       search = base::search(), system = base::Sys.info())
[18:01:08.299]                   }
[18:01:08.299]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.299]                     cond$call), session = sessionInformation(), 
[18:01:08.299]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.299]                   signalCondition(cond)
[18:01:08.299]                 }
[18:01:08.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.299]                 "immediateCondition"))) {
[18:01:08.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.299]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.299]                   if (TRUE && !signal) {
[18:01:08.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.299]                     {
[18:01:08.299]                       inherits <- base::inherits
[18:01:08.299]                       invokeRestart <- base::invokeRestart
[18:01:08.299]                       is.null <- base::is.null
[18:01:08.299]                       muffled <- FALSE
[18:01:08.299]                       if (inherits(cond, "message")) {
[18:01:08.299]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.299]                         if (muffled) 
[18:01:08.299]                           invokeRestart("muffleMessage")
[18:01:08.299]                       }
[18:01:08.299]                       else if (inherits(cond, "warning")) {
[18:01:08.299]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.299]                         if (muffled) 
[18:01:08.299]                           invokeRestart("muffleWarning")
[18:01:08.299]                       }
[18:01:08.299]                       else if (inherits(cond, "condition")) {
[18:01:08.299]                         if (!is.null(pattern)) {
[18:01:08.299]                           computeRestarts <- base::computeRestarts
[18:01:08.299]                           grepl <- base::grepl
[18:01:08.299]                           restarts <- computeRestarts(cond)
[18:01:08.299]                           for (restart in restarts) {
[18:01:08.299]                             name <- restart$name
[18:01:08.299]                             if (is.null(name)) 
[18:01:08.299]                               next
[18:01:08.299]                             if (!grepl(pattern, name)) 
[18:01:08.299]                               next
[18:01:08.299]                             invokeRestart(restart)
[18:01:08.299]                             muffled <- TRUE
[18:01:08.299]                             break
[18:01:08.299]                           }
[18:01:08.299]                         }
[18:01:08.299]                       }
[18:01:08.299]                       invisible(muffled)
[18:01:08.299]                     }
[18:01:08.299]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.299]                   }
[18:01:08.299]                 }
[18:01:08.299]                 else {
[18:01:08.299]                   if (TRUE) {
[18:01:08.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.299]                     {
[18:01:08.299]                       inherits <- base::inherits
[18:01:08.299]                       invokeRestart <- base::invokeRestart
[18:01:08.299]                       is.null <- base::is.null
[18:01:08.299]                       muffled <- FALSE
[18:01:08.299]                       if (inherits(cond, "message")) {
[18:01:08.299]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.299]                         if (muffled) 
[18:01:08.299]                           invokeRestart("muffleMessage")
[18:01:08.299]                       }
[18:01:08.299]                       else if (inherits(cond, "warning")) {
[18:01:08.299]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.299]                         if (muffled) 
[18:01:08.299]                           invokeRestart("muffleWarning")
[18:01:08.299]                       }
[18:01:08.299]                       else if (inherits(cond, "condition")) {
[18:01:08.299]                         if (!is.null(pattern)) {
[18:01:08.299]                           computeRestarts <- base::computeRestarts
[18:01:08.299]                           grepl <- base::grepl
[18:01:08.299]                           restarts <- computeRestarts(cond)
[18:01:08.299]                           for (restart in restarts) {
[18:01:08.299]                             name <- restart$name
[18:01:08.299]                             if (is.null(name)) 
[18:01:08.299]                               next
[18:01:08.299]                             if (!grepl(pattern, name)) 
[18:01:08.299]                               next
[18:01:08.299]                             invokeRestart(restart)
[18:01:08.299]                             muffled <- TRUE
[18:01:08.299]                             break
[18:01:08.299]                           }
[18:01:08.299]                         }
[18:01:08.299]                       }
[18:01:08.299]                       invisible(muffled)
[18:01:08.299]                     }
[18:01:08.299]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.299]                   }
[18:01:08.299]                 }
[18:01:08.299]             }
[18:01:08.299]         }))
[18:01:08.299]     }, error = function(ex) {
[18:01:08.299]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.299]                 ...future.rng), started = ...future.startTime, 
[18:01:08.299]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.299]             version = "1.8"), class = "FutureResult")
[18:01:08.299]     }, finally = {
[18:01:08.299]         if (!identical(...future.workdir, getwd())) 
[18:01:08.299]             setwd(...future.workdir)
[18:01:08.299]         {
[18:01:08.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.299]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.299]             }
[18:01:08.299]             base::options(...future.oldOptions)
[18:01:08.299]             if (.Platform$OS.type == "windows") {
[18:01:08.299]                 old_names <- names(...future.oldEnvVars)
[18:01:08.299]                 envs <- base::Sys.getenv()
[18:01:08.299]                 names <- names(envs)
[18:01:08.299]                 common <- intersect(names, old_names)
[18:01:08.299]                 added <- setdiff(names, old_names)
[18:01:08.299]                 removed <- setdiff(old_names, names)
[18:01:08.299]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.299]                   envs[common]]
[18:01:08.299]                 NAMES <- toupper(changed)
[18:01:08.299]                 args <- list()
[18:01:08.299]                 for (kk in seq_along(NAMES)) {
[18:01:08.299]                   name <- changed[[kk]]
[18:01:08.299]                   NAME <- NAMES[[kk]]
[18:01:08.299]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.299]                     next
[18:01:08.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.299]                 }
[18:01:08.299]                 NAMES <- toupper(added)
[18:01:08.299]                 for (kk in seq_along(NAMES)) {
[18:01:08.299]                   name <- added[[kk]]
[18:01:08.299]                   NAME <- NAMES[[kk]]
[18:01:08.299]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.299]                     next
[18:01:08.299]                   args[[name]] <- ""
[18:01:08.299]                 }
[18:01:08.299]                 NAMES <- toupper(removed)
[18:01:08.299]                 for (kk in seq_along(NAMES)) {
[18:01:08.299]                   name <- removed[[kk]]
[18:01:08.299]                   NAME <- NAMES[[kk]]
[18:01:08.299]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.299]                     next
[18:01:08.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.299]                 }
[18:01:08.299]                 if (length(args) > 0) 
[18:01:08.299]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.299]             }
[18:01:08.299]             else {
[18:01:08.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.299]             }
[18:01:08.299]             {
[18:01:08.299]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.299]                   0L) {
[18:01:08.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.299]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.299]                   base::options(opts)
[18:01:08.299]                 }
[18:01:08.299]                 {
[18:01:08.299]                   {
[18:01:08.299]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.299]                     NULL
[18:01:08.299]                   }
[18:01:08.299]                   options(future.plan = NULL)
[18:01:08.299]                   if (is.na(NA_character_)) 
[18:01:08.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.299]                     .init = FALSE)
[18:01:08.299]                 }
[18:01:08.299]             }
[18:01:08.299]         }
[18:01:08.299]     })
[18:01:08.299]     if (TRUE) {
[18:01:08.299]         base::sink(type = "output", split = FALSE)
[18:01:08.299]         if (TRUE) {
[18:01:08.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.299]         }
[18:01:08.299]         else {
[18:01:08.299]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.299]         }
[18:01:08.299]         base::close(...future.stdout)
[18:01:08.299]         ...future.stdout <- NULL
[18:01:08.299]     }
[18:01:08.299]     ...future.result$conditions <- ...future.conditions
[18:01:08.299]     ...future.result$finished <- base::Sys.time()
[18:01:08.299]     ...future.result
[18:01:08.299] }
[18:01:08.304] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[18:01:08.305] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[18:01:08.305] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[18:01:08.306] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:08.307] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.307] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:01:08.308] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:01:08.308] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:08.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.309] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:08.310] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.310] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[18:01:08.311] MultisessionFuture started
[18:01:08.311] - Launch lazy future ... done
[18:01:08.311] run() for ‘MultisessionFuture’ ... done
[18:01:08.312] Created future:
[18:01:08.312] MultisessionFuture:
[18:01:08.312] Label: ‘future_.mapply-1’
[18:01:08.312] Expression:
[18:01:08.312] {
[18:01:08.312]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.312]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.312]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.312]         on.exit(options(oopts), add = TRUE)
[18:01:08.312]     }
[18:01:08.312]     {
[18:01:08.312]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.312]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.312]         do.call(mapply, args = args)
[18:01:08.312]     }
[18:01:08.312] }
[18:01:08.312] Lazy evaluation: FALSE
[18:01:08.312] Asynchronous evaluation: TRUE
[18:01:08.312] Local evaluation: TRUE
[18:01:08.312] Environment: R_GlobalEnv
[18:01:08.312] Capture standard output: TRUE
[18:01:08.312] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.312] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.312] Packages: <none>
[18:01:08.312] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.312] Resolved: FALSE
[18:01:08.312] Value: <not collected>
[18:01:08.312] Conditions captured: <none>
[18:01:08.312] Early signaling: FALSE
[18:01:08.312] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.312] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.324] Chunk #1 of 1 ... DONE
[18:01:08.325] Launching 1 futures (chunks) ... DONE
[18:01:08.325] Resolving 1 futures (chunks) ...
[18:01:08.325] resolve() on list ...
[18:01:08.325]  recursive: 0
[18:01:08.326]  length: 1
[18:01:08.326] 
[18:01:08.355] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.356] - Validating connection of MultisessionFuture
[18:01:08.356] - received message: FutureResult
[18:01:08.356] - Received FutureResult
[18:01:08.357] - Erased future from FutureRegistry
[18:01:08.357] result() for ClusterFuture ...
[18:01:08.357] - result already collected: FutureResult
[18:01:08.357] result() for ClusterFuture ... done
[18:01:08.357] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.358] Future #1
[18:01:08.358] result() for ClusterFuture ...
[18:01:08.358] - result already collected: FutureResult
[18:01:08.358] result() for ClusterFuture ... done
[18:01:08.358] result() for ClusterFuture ...
[18:01:08.359] - result already collected: FutureResult
[18:01:08.359] result() for ClusterFuture ... done
[18:01:08.359] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:08.359] - nx: 1
[18:01:08.359] - relay: TRUE
[18:01:08.360] - stdout: TRUE
[18:01:08.360] - signal: TRUE
[18:01:08.360] - resignal: FALSE
[18:01:08.360] - force: TRUE
[18:01:08.360] - relayed: [n=1] FALSE
[18:01:08.361] - queued futures: [n=1] FALSE
[18:01:08.361]  - until=1
[18:01:08.361]  - relaying element #1
[18:01:08.361] result() for ClusterFuture ...
[18:01:08.361] - result already collected: FutureResult
[18:01:08.362] result() for ClusterFuture ... done
[18:01:08.362] result() for ClusterFuture ...
[18:01:08.362] - result already collected: FutureResult
[18:01:08.362] result() for ClusterFuture ... done
[18:01:08.362] result() for ClusterFuture ...
[18:01:08.363] - result already collected: FutureResult
[18:01:08.363] result() for ClusterFuture ... done
[18:01:08.363] result() for ClusterFuture ...
[18:01:08.363] - result already collected: FutureResult
[18:01:08.363] result() for ClusterFuture ... done
[18:01:08.364] - relayed: [n=1] TRUE
[18:01:08.364] - queued futures: [n=1] TRUE
[18:01:08.364] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:08.364]  length: 0 (resolved future 1)
[18:01:08.364] Relaying remaining futures
[18:01:08.365] signalConditionsASAP(NULL, pos=0) ...
[18:01:08.365] - nx: 1
[18:01:08.365] - relay: TRUE
[18:01:08.365] - stdout: TRUE
[18:01:08.365] - signal: TRUE
[18:01:08.365] - resignal: FALSE
[18:01:08.366] - force: TRUE
[18:01:08.366] - relayed: [n=1] TRUE
[18:01:08.366] - queued futures: [n=1] TRUE
 - flush all
[18:01:08.366] - relayed: [n=1] TRUE
[18:01:08.367] - queued futures: [n=1] TRUE
[18:01:08.367] signalConditionsASAP(NULL, pos=0) ... done
[18:01:08.367] resolve() on list ... DONE
[18:01:08.367] result() for ClusterFuture ...
[18:01:08.367] - result already collected: FutureResult
[18:01:08.368] result() for ClusterFuture ... done
[18:01:08.368] result() for ClusterFuture ...
[18:01:08.368] - result already collected: FutureResult
[18:01:08.368] result() for ClusterFuture ... done
[18:01:08.369]  - Number of value chunks collected: 1
[18:01:08.369] Resolving 1 futures (chunks) ... DONE
[18:01:08.369] Reducing values from 1 chunks ...
[18:01:08.369]  - Number of values collected after concatenation: 1
[18:01:08.370]  - Number of values expected: 1
[18:01:08.370] Reducing values from 1 chunks ... DONE
[18:01:08.370] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[18:01:08.371] future_mapply() ...
[18:01:08.379] Number of chunks: 2
[18:01:08.382] getGlobalsAndPackagesXApply() ...
[18:01:08.382]  - future.globals: TRUE
[18:01:08.382] getGlobalsAndPackages() ...
[18:01:08.382] Searching for globals...
[18:01:08.384] - globals found: [1] ‘FUN’
[18:01:08.385] Searching for globals ... DONE
[18:01:08.385] Resolving globals: FALSE
[18:01:08.385] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:01:08.386] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:01:08.386] - globals: [1] ‘FUN’
[18:01:08.387] 
[18:01:08.387] getGlobalsAndPackages() ... DONE
[18:01:08.387]  - globals found/used: [n=1] ‘FUN’
[18:01:08.387]  - needed namespaces: [n=0] 
[18:01:08.387] Finding globals ... DONE
[18:01:08.388] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:08.388] List of 2
[18:01:08.388]  $ ...future.FUN:function (x, y)  
[18:01:08.388]  $ MoreArgs     :List of 1
[18:01:08.388]   ..$ y: int [1:2] 3 4
[18:01:08.388]  - attr(*, "where")=List of 2
[18:01:08.388]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:08.388]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:08.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:08.388]  - attr(*, "resolved")= logi FALSE
[18:01:08.388]  - attr(*, "total_size")= num NA
[18:01:08.393] Packages to be attached in all futures: [n=0] 
[18:01:08.394] getGlobalsAndPackagesXApply() ... DONE
[18:01:08.394] Number of futures (= number of chunks): 2
[18:01:08.394] Launching 2 futures (chunks) ...
[18:01:08.394] Chunk #1 of 2 ...
[18:01:08.395]  - Finding globals in '...' for chunk #1 ...
[18:01:08.395] getGlobalsAndPackages() ...
[18:01:08.395] Searching for globals...
[18:01:08.396] 
[18:01:08.396] Searching for globals ... DONE
[18:01:08.396] - globals: [0] <none>
[18:01:08.396] getGlobalsAndPackages() ... DONE
[18:01:08.396]    + additional globals found: [n=0] 
[18:01:08.397]    + additional namespaces needed: [n=0] 
[18:01:08.397]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:08.397]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.397]  - seeds: <none>
[18:01:08.397]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.398] getGlobalsAndPackages() ...
[18:01:08.398] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.398] Resolving globals: FALSE
[18:01:08.399] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:08.400] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:08.400] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.400] 
[18:01:08.400] getGlobalsAndPackages() ... DONE
[18:01:08.401] run() for ‘Future’ ...
[18:01:08.401] - state: ‘created’
[18:01:08.401] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.425]   - Field: ‘node’
[18:01:08.425]   - Field: ‘label’
[18:01:08.425]   - Field: ‘local’
[18:01:08.425]   - Field: ‘owner’
[18:01:08.425]   - Field: ‘envir’
[18:01:08.426]   - Field: ‘workers’
[18:01:08.426]   - Field: ‘packages’
[18:01:08.426]   - Field: ‘gc’
[18:01:08.426]   - Field: ‘conditions’
[18:01:08.426]   - Field: ‘persistent’
[18:01:08.427]   - Field: ‘expr’
[18:01:08.427]   - Field: ‘uuid’
[18:01:08.427]   - Field: ‘seed’
[18:01:08.427]   - Field: ‘version’
[18:01:08.427]   - Field: ‘result’
[18:01:08.428]   - Field: ‘asynchronous’
[18:01:08.428]   - Field: ‘calls’
[18:01:08.428]   - Field: ‘globals’
[18:01:08.428]   - Field: ‘stdout’
[18:01:08.428]   - Field: ‘earlySignal’
[18:01:08.429]   - Field: ‘lazy’
[18:01:08.429]   - Field: ‘state’
[18:01:08.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.429] - Launch lazy future ...
[18:01:08.430] Packages needed by the future expression (n = 0): <none>
[18:01:08.430] Packages needed by future strategies (n = 0): <none>
[18:01:08.431] {
[18:01:08.431]     {
[18:01:08.431]         {
[18:01:08.431]             ...future.startTime <- base::Sys.time()
[18:01:08.431]             {
[18:01:08.431]                 {
[18:01:08.431]                   {
[18:01:08.431]                     {
[18:01:08.431]                       base::local({
[18:01:08.431]                         has_future <- base::requireNamespace("future", 
[18:01:08.431]                           quietly = TRUE)
[18:01:08.431]                         if (has_future) {
[18:01:08.431]                           ns <- base::getNamespace("future")
[18:01:08.431]                           version <- ns[[".package"]][["version"]]
[18:01:08.431]                           if (is.null(version)) 
[18:01:08.431]                             version <- utils::packageVersion("future")
[18:01:08.431]                         }
[18:01:08.431]                         else {
[18:01:08.431]                           version <- NULL
[18:01:08.431]                         }
[18:01:08.431]                         if (!has_future || version < "1.8.0") {
[18:01:08.431]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.431]                             "", base::R.version$version.string), 
[18:01:08.431]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.431]                               "release", "version")], collapse = " "), 
[18:01:08.431]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.431]                             info)
[18:01:08.431]                           info <- base::paste(info, collapse = "; ")
[18:01:08.431]                           if (!has_future) {
[18:01:08.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.431]                               info)
[18:01:08.431]                           }
[18:01:08.431]                           else {
[18:01:08.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.431]                               info, version)
[18:01:08.431]                           }
[18:01:08.431]                           base::stop(msg)
[18:01:08.431]                         }
[18:01:08.431]                       })
[18:01:08.431]                     }
[18:01:08.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.431]                     base::options(mc.cores = 1L)
[18:01:08.431]                   }
[18:01:08.431]                   ...future.strategy.old <- future::plan("list")
[18:01:08.431]                   options(future.plan = NULL)
[18:01:08.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.431]                 }
[18:01:08.431]                 ...future.workdir <- getwd()
[18:01:08.431]             }
[18:01:08.431]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.431]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.431]         }
[18:01:08.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.431]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.431]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.431]             base::names(...future.oldOptions))
[18:01:08.431]     }
[18:01:08.431]     if (FALSE) {
[18:01:08.431]     }
[18:01:08.431]     else {
[18:01:08.431]         if (TRUE) {
[18:01:08.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.431]                 open = "w")
[18:01:08.431]         }
[18:01:08.431]         else {
[18:01:08.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.431]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.431]         }
[18:01:08.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.431]             base::sink(type = "output", split = FALSE)
[18:01:08.431]             base::close(...future.stdout)
[18:01:08.431]         }, add = TRUE)
[18:01:08.431]     }
[18:01:08.431]     ...future.frame <- base::sys.nframe()
[18:01:08.431]     ...future.conditions <- base::list()
[18:01:08.431]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.431]     if (FALSE) {
[18:01:08.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.431]     }
[18:01:08.431]     ...future.result <- base::tryCatch({
[18:01:08.431]         base::withCallingHandlers({
[18:01:08.431]             ...future.value <- base::withVisible(base::local({
[18:01:08.431]                 ...future.makeSendCondition <- base::local({
[18:01:08.431]                   sendCondition <- NULL
[18:01:08.431]                   function(frame = 1L) {
[18:01:08.431]                     if (is.function(sendCondition)) 
[18:01:08.431]                       return(sendCondition)
[18:01:08.431]                     ns <- getNamespace("parallel")
[18:01:08.431]                     if (exists("sendData", mode = "function", 
[18:01:08.431]                       envir = ns)) {
[18:01:08.431]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.431]                         envir = ns)
[18:01:08.431]                       envir <- sys.frame(frame)
[18:01:08.431]                       master <- NULL
[18:01:08.431]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.431]                         !identical(envir, emptyenv())) {
[18:01:08.431]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.431]                           inherits = FALSE)) {
[18:01:08.431]                           master <- get("master", mode = "list", 
[18:01:08.431]                             envir = envir, inherits = FALSE)
[18:01:08.431]                           if (inherits(master, c("SOCKnode", 
[18:01:08.431]                             "SOCK0node"))) {
[18:01:08.431]                             sendCondition <<- function(cond) {
[18:01:08.431]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.431]                                 success = TRUE)
[18:01:08.431]                               parallel_sendData(master, data)
[18:01:08.431]                             }
[18:01:08.431]                             return(sendCondition)
[18:01:08.431]                           }
[18:01:08.431]                         }
[18:01:08.431]                         frame <- frame + 1L
[18:01:08.431]                         envir <- sys.frame(frame)
[18:01:08.431]                       }
[18:01:08.431]                     }
[18:01:08.431]                     sendCondition <<- function(cond) NULL
[18:01:08.431]                   }
[18:01:08.431]                 })
[18:01:08.431]                 withCallingHandlers({
[18:01:08.431]                   {
[18:01:08.431]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.431]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.431]                       ...future.globals.maxSize)) {
[18:01:08.431]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.431]                       on.exit(options(oopts), add = TRUE)
[18:01:08.431]                     }
[18:01:08.431]                     {
[18:01:08.431]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.431]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.431]                         USE.NAMES = FALSE)
[18:01:08.431]                       do.call(mapply, args = args)
[18:01:08.431]                     }
[18:01:08.431]                   }
[18:01:08.431]                 }, immediateCondition = function(cond) {
[18:01:08.431]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.431]                   sendCondition(cond)
[18:01:08.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.431]                   {
[18:01:08.431]                     inherits <- base::inherits
[18:01:08.431]                     invokeRestart <- base::invokeRestart
[18:01:08.431]                     is.null <- base::is.null
[18:01:08.431]                     muffled <- FALSE
[18:01:08.431]                     if (inherits(cond, "message")) {
[18:01:08.431]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.431]                       if (muffled) 
[18:01:08.431]                         invokeRestart("muffleMessage")
[18:01:08.431]                     }
[18:01:08.431]                     else if (inherits(cond, "warning")) {
[18:01:08.431]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.431]                       if (muffled) 
[18:01:08.431]                         invokeRestart("muffleWarning")
[18:01:08.431]                     }
[18:01:08.431]                     else if (inherits(cond, "condition")) {
[18:01:08.431]                       if (!is.null(pattern)) {
[18:01:08.431]                         computeRestarts <- base::computeRestarts
[18:01:08.431]                         grepl <- base::grepl
[18:01:08.431]                         restarts <- computeRestarts(cond)
[18:01:08.431]                         for (restart in restarts) {
[18:01:08.431]                           name <- restart$name
[18:01:08.431]                           if (is.null(name)) 
[18:01:08.431]                             next
[18:01:08.431]                           if (!grepl(pattern, name)) 
[18:01:08.431]                             next
[18:01:08.431]                           invokeRestart(restart)
[18:01:08.431]                           muffled <- TRUE
[18:01:08.431]                           break
[18:01:08.431]                         }
[18:01:08.431]                       }
[18:01:08.431]                     }
[18:01:08.431]                     invisible(muffled)
[18:01:08.431]                   }
[18:01:08.431]                   muffleCondition(cond)
[18:01:08.431]                 })
[18:01:08.431]             }))
[18:01:08.431]             future::FutureResult(value = ...future.value$value, 
[18:01:08.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.431]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.431]                     ...future.globalenv.names))
[18:01:08.431]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.431]         }, condition = base::local({
[18:01:08.431]             c <- base::c
[18:01:08.431]             inherits <- base::inherits
[18:01:08.431]             invokeRestart <- base::invokeRestart
[18:01:08.431]             length <- base::length
[18:01:08.431]             list <- base::list
[18:01:08.431]             seq.int <- base::seq.int
[18:01:08.431]             signalCondition <- base::signalCondition
[18:01:08.431]             sys.calls <- base::sys.calls
[18:01:08.431]             `[[` <- base::`[[`
[18:01:08.431]             `+` <- base::`+`
[18:01:08.431]             `<<-` <- base::`<<-`
[18:01:08.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.431]                   3L)]
[18:01:08.431]             }
[18:01:08.431]             function(cond) {
[18:01:08.431]                 is_error <- inherits(cond, "error")
[18:01:08.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.431]                   NULL)
[18:01:08.431]                 if (is_error) {
[18:01:08.431]                   sessionInformation <- function() {
[18:01:08.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.431]                       search = base::search(), system = base::Sys.info())
[18:01:08.431]                   }
[18:01:08.431]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.431]                     cond$call), session = sessionInformation(), 
[18:01:08.431]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.431]                   signalCondition(cond)
[18:01:08.431]                 }
[18:01:08.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.431]                 "immediateCondition"))) {
[18:01:08.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.431]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.431]                   if (TRUE && !signal) {
[18:01:08.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.431]                     {
[18:01:08.431]                       inherits <- base::inherits
[18:01:08.431]                       invokeRestart <- base::invokeRestart
[18:01:08.431]                       is.null <- base::is.null
[18:01:08.431]                       muffled <- FALSE
[18:01:08.431]                       if (inherits(cond, "message")) {
[18:01:08.431]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.431]                         if (muffled) 
[18:01:08.431]                           invokeRestart("muffleMessage")
[18:01:08.431]                       }
[18:01:08.431]                       else if (inherits(cond, "warning")) {
[18:01:08.431]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.431]                         if (muffled) 
[18:01:08.431]                           invokeRestart("muffleWarning")
[18:01:08.431]                       }
[18:01:08.431]                       else if (inherits(cond, "condition")) {
[18:01:08.431]                         if (!is.null(pattern)) {
[18:01:08.431]                           computeRestarts <- base::computeRestarts
[18:01:08.431]                           grepl <- base::grepl
[18:01:08.431]                           restarts <- computeRestarts(cond)
[18:01:08.431]                           for (restart in restarts) {
[18:01:08.431]                             name <- restart$name
[18:01:08.431]                             if (is.null(name)) 
[18:01:08.431]                               next
[18:01:08.431]                             if (!grepl(pattern, name)) 
[18:01:08.431]                               next
[18:01:08.431]                             invokeRestart(restart)
[18:01:08.431]                             muffled <- TRUE
[18:01:08.431]                             break
[18:01:08.431]                           }
[18:01:08.431]                         }
[18:01:08.431]                       }
[18:01:08.431]                       invisible(muffled)
[18:01:08.431]                     }
[18:01:08.431]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.431]                   }
[18:01:08.431]                 }
[18:01:08.431]                 else {
[18:01:08.431]                   if (TRUE) {
[18:01:08.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.431]                     {
[18:01:08.431]                       inherits <- base::inherits
[18:01:08.431]                       invokeRestart <- base::invokeRestart
[18:01:08.431]                       is.null <- base::is.null
[18:01:08.431]                       muffled <- FALSE
[18:01:08.431]                       if (inherits(cond, "message")) {
[18:01:08.431]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.431]                         if (muffled) 
[18:01:08.431]                           invokeRestart("muffleMessage")
[18:01:08.431]                       }
[18:01:08.431]                       else if (inherits(cond, "warning")) {
[18:01:08.431]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.431]                         if (muffled) 
[18:01:08.431]                           invokeRestart("muffleWarning")
[18:01:08.431]                       }
[18:01:08.431]                       else if (inherits(cond, "condition")) {
[18:01:08.431]                         if (!is.null(pattern)) {
[18:01:08.431]                           computeRestarts <- base::computeRestarts
[18:01:08.431]                           grepl <- base::grepl
[18:01:08.431]                           restarts <- computeRestarts(cond)
[18:01:08.431]                           for (restart in restarts) {
[18:01:08.431]                             name <- restart$name
[18:01:08.431]                             if (is.null(name)) 
[18:01:08.431]                               next
[18:01:08.431]                             if (!grepl(pattern, name)) 
[18:01:08.431]                               next
[18:01:08.431]                             invokeRestart(restart)
[18:01:08.431]                             muffled <- TRUE
[18:01:08.431]                             break
[18:01:08.431]                           }
[18:01:08.431]                         }
[18:01:08.431]                       }
[18:01:08.431]                       invisible(muffled)
[18:01:08.431]                     }
[18:01:08.431]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.431]                   }
[18:01:08.431]                 }
[18:01:08.431]             }
[18:01:08.431]         }))
[18:01:08.431]     }, error = function(ex) {
[18:01:08.431]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.431]                 ...future.rng), started = ...future.startTime, 
[18:01:08.431]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.431]             version = "1.8"), class = "FutureResult")
[18:01:08.431]     }, finally = {
[18:01:08.431]         if (!identical(...future.workdir, getwd())) 
[18:01:08.431]             setwd(...future.workdir)
[18:01:08.431]         {
[18:01:08.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.431]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.431]             }
[18:01:08.431]             base::options(...future.oldOptions)
[18:01:08.431]             if (.Platform$OS.type == "windows") {
[18:01:08.431]                 old_names <- names(...future.oldEnvVars)
[18:01:08.431]                 envs <- base::Sys.getenv()
[18:01:08.431]                 names <- names(envs)
[18:01:08.431]                 common <- intersect(names, old_names)
[18:01:08.431]                 added <- setdiff(names, old_names)
[18:01:08.431]                 removed <- setdiff(old_names, names)
[18:01:08.431]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.431]                   envs[common]]
[18:01:08.431]                 NAMES <- toupper(changed)
[18:01:08.431]                 args <- list()
[18:01:08.431]                 for (kk in seq_along(NAMES)) {
[18:01:08.431]                   name <- changed[[kk]]
[18:01:08.431]                   NAME <- NAMES[[kk]]
[18:01:08.431]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.431]                     next
[18:01:08.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.431]                 }
[18:01:08.431]                 NAMES <- toupper(added)
[18:01:08.431]                 for (kk in seq_along(NAMES)) {
[18:01:08.431]                   name <- added[[kk]]
[18:01:08.431]                   NAME <- NAMES[[kk]]
[18:01:08.431]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.431]                     next
[18:01:08.431]                   args[[name]] <- ""
[18:01:08.431]                 }
[18:01:08.431]                 NAMES <- toupper(removed)
[18:01:08.431]                 for (kk in seq_along(NAMES)) {
[18:01:08.431]                   name <- removed[[kk]]
[18:01:08.431]                   NAME <- NAMES[[kk]]
[18:01:08.431]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.431]                     next
[18:01:08.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.431]                 }
[18:01:08.431]                 if (length(args) > 0) 
[18:01:08.431]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.431]             }
[18:01:08.431]             else {
[18:01:08.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.431]             }
[18:01:08.431]             {
[18:01:08.431]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.431]                   0L) {
[18:01:08.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.431]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.431]                   base::options(opts)
[18:01:08.431]                 }
[18:01:08.431]                 {
[18:01:08.431]                   {
[18:01:08.431]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.431]                     NULL
[18:01:08.431]                   }
[18:01:08.431]                   options(future.plan = NULL)
[18:01:08.431]                   if (is.na(NA_character_)) 
[18:01:08.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.431]                     .init = FALSE)
[18:01:08.431]                 }
[18:01:08.431]             }
[18:01:08.431]         }
[18:01:08.431]     })
[18:01:08.431]     if (TRUE) {
[18:01:08.431]         base::sink(type = "output", split = FALSE)
[18:01:08.431]         if (TRUE) {
[18:01:08.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.431]         }
[18:01:08.431]         else {
[18:01:08.431]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.431]         }
[18:01:08.431]         base::close(...future.stdout)
[18:01:08.431]         ...future.stdout <- NULL
[18:01:08.431]     }
[18:01:08.431]     ...future.result$conditions <- ...future.conditions
[18:01:08.431]     ...future.result$finished <- base::Sys.time()
[18:01:08.431]     ...future.result
[18:01:08.431] }
[18:01:08.436] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[18:01:08.436] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[18:01:08.437] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[18:01:08.437] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[18:01:08.438] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[18:01:08.438] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:01:08.439] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:01:08.440] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:08.440] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.441] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:08.441] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.442] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[18:01:08.443] MultisessionFuture started
[18:01:08.443] - Launch lazy future ... done
[18:01:08.443] run() for ‘MultisessionFuture’ ... done
[18:01:08.443] Created future:
[18:01:08.444] MultisessionFuture:
[18:01:08.444] Label: ‘future_mapply-1’
[18:01:08.444] Expression:
[18:01:08.444] {
[18:01:08.444]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.444]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.444]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.444]         on.exit(options(oopts), add = TRUE)
[18:01:08.444]     }
[18:01:08.444]     {
[18:01:08.444]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.444]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.444]         do.call(mapply, args = args)
[18:01:08.444]     }
[18:01:08.444] }
[18:01:08.444] Lazy evaluation: FALSE
[18:01:08.444] Asynchronous evaluation: TRUE
[18:01:08.444] Local evaluation: TRUE
[18:01:08.444] Environment: R_GlobalEnv
[18:01:08.444] Capture standard output: TRUE
[18:01:08.444] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.444] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.444] Packages: <none>
[18:01:08.444] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.444] Resolved: FALSE
[18:01:08.444] Value: <not collected>
[18:01:08.444] Conditions captured: <none>
[18:01:08.444] Early signaling: FALSE
[18:01:08.444] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.444] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.456] Chunk #1 of 2 ... DONE
[18:01:08.457] Chunk #2 of 2 ...
[18:01:08.457]  - Finding globals in '...' for chunk #2 ...
[18:01:08.457] getGlobalsAndPackages() ...
[18:01:08.457] Searching for globals...
[18:01:08.458] 
[18:01:08.458] Searching for globals ... DONE
[18:01:08.459] - globals: [0] <none>
[18:01:08.459] getGlobalsAndPackages() ... DONE
[18:01:08.459]    + additional globals found: [n=0] 
[18:01:08.459]    + additional namespaces needed: [n=0] 
[18:01:08.459]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:08.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.460]  - seeds: <none>
[18:01:08.460]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.460] getGlobalsAndPackages() ...
[18:01:08.460] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.461] Resolving globals: FALSE
[18:01:08.462] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:08.463] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:08.463] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.463] 
[18:01:08.463] getGlobalsAndPackages() ... DONE
[18:01:08.464] run() for ‘Future’ ...
[18:01:08.464] - state: ‘created’
[18:01:08.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.487] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.488]   - Field: ‘node’
[18:01:08.488]   - Field: ‘label’
[18:01:08.488]   - Field: ‘local’
[18:01:08.488]   - Field: ‘owner’
[18:01:08.488]   - Field: ‘envir’
[18:01:08.489]   - Field: ‘workers’
[18:01:08.489]   - Field: ‘packages’
[18:01:08.489]   - Field: ‘gc’
[18:01:08.489]   - Field: ‘conditions’
[18:01:08.489]   - Field: ‘persistent’
[18:01:08.490]   - Field: ‘expr’
[18:01:08.490]   - Field: ‘uuid’
[18:01:08.490]   - Field: ‘seed’
[18:01:08.490]   - Field: ‘version’
[18:01:08.490]   - Field: ‘result’
[18:01:08.491]   - Field: ‘asynchronous’
[18:01:08.491]   - Field: ‘calls’
[18:01:08.491]   - Field: ‘globals’
[18:01:08.491]   - Field: ‘stdout’
[18:01:08.491]   - Field: ‘earlySignal’
[18:01:08.492]   - Field: ‘lazy’
[18:01:08.492]   - Field: ‘state’
[18:01:08.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.492] - Launch lazy future ...
[18:01:08.493] Packages needed by the future expression (n = 0): <none>
[18:01:08.493] Packages needed by future strategies (n = 0): <none>
[18:01:08.494] {
[18:01:08.494]     {
[18:01:08.494]         {
[18:01:08.494]             ...future.startTime <- base::Sys.time()
[18:01:08.494]             {
[18:01:08.494]                 {
[18:01:08.494]                   {
[18:01:08.494]                     {
[18:01:08.494]                       base::local({
[18:01:08.494]                         has_future <- base::requireNamespace("future", 
[18:01:08.494]                           quietly = TRUE)
[18:01:08.494]                         if (has_future) {
[18:01:08.494]                           ns <- base::getNamespace("future")
[18:01:08.494]                           version <- ns[[".package"]][["version"]]
[18:01:08.494]                           if (is.null(version)) 
[18:01:08.494]                             version <- utils::packageVersion("future")
[18:01:08.494]                         }
[18:01:08.494]                         else {
[18:01:08.494]                           version <- NULL
[18:01:08.494]                         }
[18:01:08.494]                         if (!has_future || version < "1.8.0") {
[18:01:08.494]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.494]                             "", base::R.version$version.string), 
[18:01:08.494]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.494]                               "release", "version")], collapse = " "), 
[18:01:08.494]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.494]                             info)
[18:01:08.494]                           info <- base::paste(info, collapse = "; ")
[18:01:08.494]                           if (!has_future) {
[18:01:08.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.494]                               info)
[18:01:08.494]                           }
[18:01:08.494]                           else {
[18:01:08.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.494]                               info, version)
[18:01:08.494]                           }
[18:01:08.494]                           base::stop(msg)
[18:01:08.494]                         }
[18:01:08.494]                       })
[18:01:08.494]                     }
[18:01:08.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.494]                     base::options(mc.cores = 1L)
[18:01:08.494]                   }
[18:01:08.494]                   ...future.strategy.old <- future::plan("list")
[18:01:08.494]                   options(future.plan = NULL)
[18:01:08.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.494]                 }
[18:01:08.494]                 ...future.workdir <- getwd()
[18:01:08.494]             }
[18:01:08.494]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.494]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.494]         }
[18:01:08.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.494]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.494]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.494]             base::names(...future.oldOptions))
[18:01:08.494]     }
[18:01:08.494]     if (FALSE) {
[18:01:08.494]     }
[18:01:08.494]     else {
[18:01:08.494]         if (TRUE) {
[18:01:08.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.494]                 open = "w")
[18:01:08.494]         }
[18:01:08.494]         else {
[18:01:08.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.494]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.494]         }
[18:01:08.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.494]             base::sink(type = "output", split = FALSE)
[18:01:08.494]             base::close(...future.stdout)
[18:01:08.494]         }, add = TRUE)
[18:01:08.494]     }
[18:01:08.494]     ...future.frame <- base::sys.nframe()
[18:01:08.494]     ...future.conditions <- base::list()
[18:01:08.494]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.494]     if (FALSE) {
[18:01:08.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.494]     }
[18:01:08.494]     ...future.result <- base::tryCatch({
[18:01:08.494]         base::withCallingHandlers({
[18:01:08.494]             ...future.value <- base::withVisible(base::local({
[18:01:08.494]                 ...future.makeSendCondition <- base::local({
[18:01:08.494]                   sendCondition <- NULL
[18:01:08.494]                   function(frame = 1L) {
[18:01:08.494]                     if (is.function(sendCondition)) 
[18:01:08.494]                       return(sendCondition)
[18:01:08.494]                     ns <- getNamespace("parallel")
[18:01:08.494]                     if (exists("sendData", mode = "function", 
[18:01:08.494]                       envir = ns)) {
[18:01:08.494]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.494]                         envir = ns)
[18:01:08.494]                       envir <- sys.frame(frame)
[18:01:08.494]                       master <- NULL
[18:01:08.494]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.494]                         !identical(envir, emptyenv())) {
[18:01:08.494]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.494]                           inherits = FALSE)) {
[18:01:08.494]                           master <- get("master", mode = "list", 
[18:01:08.494]                             envir = envir, inherits = FALSE)
[18:01:08.494]                           if (inherits(master, c("SOCKnode", 
[18:01:08.494]                             "SOCK0node"))) {
[18:01:08.494]                             sendCondition <<- function(cond) {
[18:01:08.494]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.494]                                 success = TRUE)
[18:01:08.494]                               parallel_sendData(master, data)
[18:01:08.494]                             }
[18:01:08.494]                             return(sendCondition)
[18:01:08.494]                           }
[18:01:08.494]                         }
[18:01:08.494]                         frame <- frame + 1L
[18:01:08.494]                         envir <- sys.frame(frame)
[18:01:08.494]                       }
[18:01:08.494]                     }
[18:01:08.494]                     sendCondition <<- function(cond) NULL
[18:01:08.494]                   }
[18:01:08.494]                 })
[18:01:08.494]                 withCallingHandlers({
[18:01:08.494]                   {
[18:01:08.494]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.494]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.494]                       ...future.globals.maxSize)) {
[18:01:08.494]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.494]                       on.exit(options(oopts), add = TRUE)
[18:01:08.494]                     }
[18:01:08.494]                     {
[18:01:08.494]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.494]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.494]                         USE.NAMES = FALSE)
[18:01:08.494]                       do.call(mapply, args = args)
[18:01:08.494]                     }
[18:01:08.494]                   }
[18:01:08.494]                 }, immediateCondition = function(cond) {
[18:01:08.494]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.494]                   sendCondition(cond)
[18:01:08.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.494]                   {
[18:01:08.494]                     inherits <- base::inherits
[18:01:08.494]                     invokeRestart <- base::invokeRestart
[18:01:08.494]                     is.null <- base::is.null
[18:01:08.494]                     muffled <- FALSE
[18:01:08.494]                     if (inherits(cond, "message")) {
[18:01:08.494]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.494]                       if (muffled) 
[18:01:08.494]                         invokeRestart("muffleMessage")
[18:01:08.494]                     }
[18:01:08.494]                     else if (inherits(cond, "warning")) {
[18:01:08.494]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.494]                       if (muffled) 
[18:01:08.494]                         invokeRestart("muffleWarning")
[18:01:08.494]                     }
[18:01:08.494]                     else if (inherits(cond, "condition")) {
[18:01:08.494]                       if (!is.null(pattern)) {
[18:01:08.494]                         computeRestarts <- base::computeRestarts
[18:01:08.494]                         grepl <- base::grepl
[18:01:08.494]                         restarts <- computeRestarts(cond)
[18:01:08.494]                         for (restart in restarts) {
[18:01:08.494]                           name <- restart$name
[18:01:08.494]                           if (is.null(name)) 
[18:01:08.494]                             next
[18:01:08.494]                           if (!grepl(pattern, name)) 
[18:01:08.494]                             next
[18:01:08.494]                           invokeRestart(restart)
[18:01:08.494]                           muffled <- TRUE
[18:01:08.494]                           break
[18:01:08.494]                         }
[18:01:08.494]                       }
[18:01:08.494]                     }
[18:01:08.494]                     invisible(muffled)
[18:01:08.494]                   }
[18:01:08.494]                   muffleCondition(cond)
[18:01:08.494]                 })
[18:01:08.494]             }))
[18:01:08.494]             future::FutureResult(value = ...future.value$value, 
[18:01:08.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.494]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.494]                     ...future.globalenv.names))
[18:01:08.494]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.494]         }, condition = base::local({
[18:01:08.494]             c <- base::c
[18:01:08.494]             inherits <- base::inherits
[18:01:08.494]             invokeRestart <- base::invokeRestart
[18:01:08.494]             length <- base::length
[18:01:08.494]             list <- base::list
[18:01:08.494]             seq.int <- base::seq.int
[18:01:08.494]             signalCondition <- base::signalCondition
[18:01:08.494]             sys.calls <- base::sys.calls
[18:01:08.494]             `[[` <- base::`[[`
[18:01:08.494]             `+` <- base::`+`
[18:01:08.494]             `<<-` <- base::`<<-`
[18:01:08.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.494]                   3L)]
[18:01:08.494]             }
[18:01:08.494]             function(cond) {
[18:01:08.494]                 is_error <- inherits(cond, "error")
[18:01:08.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.494]                   NULL)
[18:01:08.494]                 if (is_error) {
[18:01:08.494]                   sessionInformation <- function() {
[18:01:08.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.494]                       search = base::search(), system = base::Sys.info())
[18:01:08.494]                   }
[18:01:08.494]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.494]                     cond$call), session = sessionInformation(), 
[18:01:08.494]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.494]                   signalCondition(cond)
[18:01:08.494]                 }
[18:01:08.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.494]                 "immediateCondition"))) {
[18:01:08.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.494]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.494]                   if (TRUE && !signal) {
[18:01:08.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.494]                     {
[18:01:08.494]                       inherits <- base::inherits
[18:01:08.494]                       invokeRestart <- base::invokeRestart
[18:01:08.494]                       is.null <- base::is.null
[18:01:08.494]                       muffled <- FALSE
[18:01:08.494]                       if (inherits(cond, "message")) {
[18:01:08.494]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.494]                         if (muffled) 
[18:01:08.494]                           invokeRestart("muffleMessage")
[18:01:08.494]                       }
[18:01:08.494]                       else if (inherits(cond, "warning")) {
[18:01:08.494]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.494]                         if (muffled) 
[18:01:08.494]                           invokeRestart("muffleWarning")
[18:01:08.494]                       }
[18:01:08.494]                       else if (inherits(cond, "condition")) {
[18:01:08.494]                         if (!is.null(pattern)) {
[18:01:08.494]                           computeRestarts <- base::computeRestarts
[18:01:08.494]                           grepl <- base::grepl
[18:01:08.494]                           restarts <- computeRestarts(cond)
[18:01:08.494]                           for (restart in restarts) {
[18:01:08.494]                             name <- restart$name
[18:01:08.494]                             if (is.null(name)) 
[18:01:08.494]                               next
[18:01:08.494]                             if (!grepl(pattern, name)) 
[18:01:08.494]                               next
[18:01:08.494]                             invokeRestart(restart)
[18:01:08.494]                             muffled <- TRUE
[18:01:08.494]                             break
[18:01:08.494]                           }
[18:01:08.494]                         }
[18:01:08.494]                       }
[18:01:08.494]                       invisible(muffled)
[18:01:08.494]                     }
[18:01:08.494]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.494]                   }
[18:01:08.494]                 }
[18:01:08.494]                 else {
[18:01:08.494]                   if (TRUE) {
[18:01:08.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.494]                     {
[18:01:08.494]                       inherits <- base::inherits
[18:01:08.494]                       invokeRestart <- base::invokeRestart
[18:01:08.494]                       is.null <- base::is.null
[18:01:08.494]                       muffled <- FALSE
[18:01:08.494]                       if (inherits(cond, "message")) {
[18:01:08.494]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.494]                         if (muffled) 
[18:01:08.494]                           invokeRestart("muffleMessage")
[18:01:08.494]                       }
[18:01:08.494]                       else if (inherits(cond, "warning")) {
[18:01:08.494]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.494]                         if (muffled) 
[18:01:08.494]                           invokeRestart("muffleWarning")
[18:01:08.494]                       }
[18:01:08.494]                       else if (inherits(cond, "condition")) {
[18:01:08.494]                         if (!is.null(pattern)) {
[18:01:08.494]                           computeRestarts <- base::computeRestarts
[18:01:08.494]                           grepl <- base::grepl
[18:01:08.494]                           restarts <- computeRestarts(cond)
[18:01:08.494]                           for (restart in restarts) {
[18:01:08.494]                             name <- restart$name
[18:01:08.494]                             if (is.null(name)) 
[18:01:08.494]                               next
[18:01:08.494]                             if (!grepl(pattern, name)) 
[18:01:08.494]                               next
[18:01:08.494]                             invokeRestart(restart)
[18:01:08.494]                             muffled <- TRUE
[18:01:08.494]                             break
[18:01:08.494]                           }
[18:01:08.494]                         }
[18:01:08.494]                       }
[18:01:08.494]                       invisible(muffled)
[18:01:08.494]                     }
[18:01:08.494]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.494]                   }
[18:01:08.494]                 }
[18:01:08.494]             }
[18:01:08.494]         }))
[18:01:08.494]     }, error = function(ex) {
[18:01:08.494]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.494]                 ...future.rng), started = ...future.startTime, 
[18:01:08.494]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.494]             version = "1.8"), class = "FutureResult")
[18:01:08.494]     }, finally = {
[18:01:08.494]         if (!identical(...future.workdir, getwd())) 
[18:01:08.494]             setwd(...future.workdir)
[18:01:08.494]         {
[18:01:08.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.494]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.494]             }
[18:01:08.494]             base::options(...future.oldOptions)
[18:01:08.494]             if (.Platform$OS.type == "windows") {
[18:01:08.494]                 old_names <- names(...future.oldEnvVars)
[18:01:08.494]                 envs <- base::Sys.getenv()
[18:01:08.494]                 names <- names(envs)
[18:01:08.494]                 common <- intersect(names, old_names)
[18:01:08.494]                 added <- setdiff(names, old_names)
[18:01:08.494]                 removed <- setdiff(old_names, names)
[18:01:08.494]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.494]                   envs[common]]
[18:01:08.494]                 NAMES <- toupper(changed)
[18:01:08.494]                 args <- list()
[18:01:08.494]                 for (kk in seq_along(NAMES)) {
[18:01:08.494]                   name <- changed[[kk]]
[18:01:08.494]                   NAME <- NAMES[[kk]]
[18:01:08.494]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.494]                     next
[18:01:08.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.494]                 }
[18:01:08.494]                 NAMES <- toupper(added)
[18:01:08.494]                 for (kk in seq_along(NAMES)) {
[18:01:08.494]                   name <- added[[kk]]
[18:01:08.494]                   NAME <- NAMES[[kk]]
[18:01:08.494]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.494]                     next
[18:01:08.494]                   args[[name]] <- ""
[18:01:08.494]                 }
[18:01:08.494]                 NAMES <- toupper(removed)
[18:01:08.494]                 for (kk in seq_along(NAMES)) {
[18:01:08.494]                   name <- removed[[kk]]
[18:01:08.494]                   NAME <- NAMES[[kk]]
[18:01:08.494]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.494]                     next
[18:01:08.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.494]                 }
[18:01:08.494]                 if (length(args) > 0) 
[18:01:08.494]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.494]             }
[18:01:08.494]             else {
[18:01:08.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.494]             }
[18:01:08.494]             {
[18:01:08.494]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.494]                   0L) {
[18:01:08.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.494]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.494]                   base::options(opts)
[18:01:08.494]                 }
[18:01:08.494]                 {
[18:01:08.494]                   {
[18:01:08.494]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.494]                     NULL
[18:01:08.494]                   }
[18:01:08.494]                   options(future.plan = NULL)
[18:01:08.494]                   if (is.na(NA_character_)) 
[18:01:08.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.494]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.494]                     .init = FALSE)
[18:01:08.494]                 }
[18:01:08.494]             }
[18:01:08.494]         }
[18:01:08.494]     })
[18:01:08.494]     if (TRUE) {
[18:01:08.494]         base::sink(type = "output", split = FALSE)
[18:01:08.494]         if (TRUE) {
[18:01:08.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.494]         }
[18:01:08.494]         else {
[18:01:08.494]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.494]         }
[18:01:08.494]         base::close(...future.stdout)
[18:01:08.494]         ...future.stdout <- NULL
[18:01:08.494]     }
[18:01:08.494]     ...future.result$conditions <- ...future.conditions
[18:01:08.494]     ...future.result$finished <- base::Sys.time()
[18:01:08.494]     ...future.result
[18:01:08.494] }
[18:01:08.499] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[18:01:08.499] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[18:01:08.500] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[18:01:08.500] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[18:01:08.501] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[18:01:08.501] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:01:08.502] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:01:08.503] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:08.503] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.504] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:08.504] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.505] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[18:01:08.506] MultisessionFuture started
[18:01:08.506] - Launch lazy future ... done
[18:01:08.506] run() for ‘MultisessionFuture’ ... done
[18:01:08.506] Created future:
[18:01:08.507] MultisessionFuture:
[18:01:08.507] Label: ‘future_mapply-2’
[18:01:08.507] Expression:
[18:01:08.507] {
[18:01:08.507]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.507]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.507]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.507]         on.exit(options(oopts), add = TRUE)
[18:01:08.507]     }
[18:01:08.507]     {
[18:01:08.507]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.507]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.507]         do.call(mapply, args = args)
[18:01:08.507]     }
[18:01:08.507] }
[18:01:08.507] Lazy evaluation: FALSE
[18:01:08.507] Asynchronous evaluation: TRUE
[18:01:08.507] Local evaluation: TRUE
[18:01:08.507] Environment: R_GlobalEnv
[18:01:08.507] Capture standard output: TRUE
[18:01:08.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.507] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.507] Packages: <none>
[18:01:08.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.507] Resolved: FALSE
[18:01:08.507] Value: <not collected>
[18:01:08.507] Conditions captured: <none>
[18:01:08.507] Early signaling: FALSE
[18:01:08.507] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.519] Chunk #2 of 2 ... DONE
[18:01:08.519] Launching 2 futures (chunks) ... DONE
[18:01:08.520] Resolving 2 futures (chunks) ...
[18:01:08.520] resolve() on list ...
[18:01:08.520]  recursive: 0
[18:01:08.520]  length: 2
[18:01:08.520] 
[18:01:08.521] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.521] - Validating connection of MultisessionFuture
[18:01:08.522] - received message: FutureResult
[18:01:08.522] - Received FutureResult
[18:01:08.522] - Erased future from FutureRegistry
[18:01:08.522] result() for ClusterFuture ...
[18:01:08.523] - result already collected: FutureResult
[18:01:08.523] result() for ClusterFuture ... done
[18:01:08.523] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.523] Future #1
[18:01:08.523] result() for ClusterFuture ...
[18:01:08.524] - result already collected: FutureResult
[18:01:08.524] result() for ClusterFuture ... done
[18:01:08.524] result() for ClusterFuture ...
[18:01:08.524] - result already collected: FutureResult
[18:01:08.524] result() for ClusterFuture ... done
[18:01:08.524] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:08.525] - nx: 2
[18:01:08.525] - relay: TRUE
[18:01:08.525] - stdout: TRUE
[18:01:08.525] - signal: TRUE
[18:01:08.525] - resignal: FALSE
[18:01:08.525] - force: TRUE
[18:01:08.526] - relayed: [n=2] FALSE, FALSE
[18:01:08.526] - queued futures: [n=2] FALSE, FALSE
[18:01:08.526]  - until=1
[18:01:08.526]  - relaying element #1
[18:01:08.526] result() for ClusterFuture ...
[18:01:08.527] - result already collected: FutureResult
[18:01:08.527] result() for ClusterFuture ... done
[18:01:08.527] result() for ClusterFuture ...
[18:01:08.527] - result already collected: FutureResult
[18:01:08.527] result() for ClusterFuture ... done
[18:01:08.528] result() for ClusterFuture ...
[18:01:08.528] - result already collected: FutureResult
[18:01:08.528] result() for ClusterFuture ... done
[18:01:08.528] result() for ClusterFuture ...
[18:01:08.528] - result already collected: FutureResult
[18:01:08.528] result() for ClusterFuture ... done
[18:01:08.529] - relayed: [n=2] TRUE, FALSE
[18:01:08.529] - queued futures: [n=2] TRUE, FALSE
[18:01:08.529] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:08.529]  length: 1 (resolved future 1)
[18:01:08.551] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.552] - Validating connection of MultisessionFuture
[18:01:08.552] - received message: FutureResult
[18:01:08.552] - Received FutureResult
[18:01:08.552] - Erased future from FutureRegistry
[18:01:08.553] result() for ClusterFuture ...
[18:01:08.553] - result already collected: FutureResult
[18:01:08.553] result() for ClusterFuture ... done
[18:01:08.553] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.553] Future #2
[18:01:08.554] result() for ClusterFuture ...
[18:01:08.554] - result already collected: FutureResult
[18:01:08.554] result() for ClusterFuture ... done
[18:01:08.554] result() for ClusterFuture ...
[18:01:08.554] - result already collected: FutureResult
[18:01:08.554] result() for ClusterFuture ... done
[18:01:08.555] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:08.555] - nx: 2
[18:01:08.555] - relay: TRUE
[18:01:08.555] - stdout: TRUE
[18:01:08.555] - signal: TRUE
[18:01:08.556] - resignal: FALSE
[18:01:08.556] - force: TRUE
[18:01:08.556] - relayed: [n=2] TRUE, FALSE
[18:01:08.556] - queued futures: [n=2] TRUE, FALSE
[18:01:08.556]  - until=2
[18:01:08.557]  - relaying element #2
[18:01:08.557] result() for ClusterFuture ...
[18:01:08.557] - result already collected: FutureResult
[18:01:08.557] result() for ClusterFuture ... done
[18:01:08.557] result() for ClusterFuture ...
[18:01:08.557] - result already collected: FutureResult
[18:01:08.558] result() for ClusterFuture ... done
[18:01:08.558] result() for ClusterFuture ...
[18:01:08.558] - result already collected: FutureResult
[18:01:08.558] result() for ClusterFuture ... done
[18:01:08.559] result() for ClusterFuture ...
[18:01:08.559] - result already collected: FutureResult
[18:01:08.559] result() for ClusterFuture ... done
[18:01:08.559] - relayed: [n=2] TRUE, TRUE
[18:01:08.559] - queued futures: [n=2] TRUE, TRUE
[18:01:08.559] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:08.560]  length: 0 (resolved future 2)
[18:01:08.560] Relaying remaining futures
[18:01:08.560] signalConditionsASAP(NULL, pos=0) ...
[18:01:08.560] - nx: 2
[18:01:08.560] - relay: TRUE
[18:01:08.561] - stdout: TRUE
[18:01:08.561] - signal: TRUE
[18:01:08.561] - resignal: FALSE
[18:01:08.561] - force: TRUE
[18:01:08.561] - relayed: [n=2] TRUE, TRUE
[18:01:08.561] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:08.562] - relayed: [n=2] TRUE, TRUE
[18:01:08.562] - queued futures: [n=2] TRUE, TRUE
[18:01:08.562] signalConditionsASAP(NULL, pos=0) ... done
[18:01:08.562] resolve() on list ... DONE
[18:01:08.562] result() for ClusterFuture ...
[18:01:08.563] - result already collected: FutureResult
[18:01:08.563] result() for ClusterFuture ... done
[18:01:08.563] result() for ClusterFuture ...
[18:01:08.563] - result already collected: FutureResult
[18:01:08.563] result() for ClusterFuture ... done
[18:01:08.564] result() for ClusterFuture ...
[18:01:08.564] - result already collected: FutureResult
[18:01:08.564] result() for ClusterFuture ... done
[18:01:08.564] result() for ClusterFuture ...
[18:01:08.564] - result already collected: FutureResult
[18:01:08.565] result() for ClusterFuture ... done
[18:01:08.565]  - Number of value chunks collected: 2
[18:01:08.565] Resolving 2 futures (chunks) ... DONE
[18:01:08.565] Reducing values from 2 chunks ...
[18:01:08.565]  - Number of values collected after concatenation: 2
[18:01:08.565]  - Number of values expected: 2
[18:01:08.566] Reducing values from 2 chunks ... DONE
[18:01:08.566] future_mapply() ... DONE
[18:01:08.566] future_mapply() ...
[18:01:08.566] Generating random seeds ...
[18:01:08.567] Generating random seed streams for 2 elements ...
[18:01:08.567] Generating random seed streams for 2 elements ... DONE
[18:01:08.567] Generating random seeds ... DONE
[18:01:08.567] Will set RNG state on exit: 10407, 833575094, 401713147, -389418712, -199817385, -1835501991, 2146488288
[18:01:08.574] Number of chunks: 2
[18:01:08.574] getGlobalsAndPackagesXApply() ...
[18:01:08.574]  - future.globals: TRUE
[18:01:08.574] getGlobalsAndPackages() ...
[18:01:08.575] Searching for globals...
[18:01:08.577] - globals found: [1] ‘FUN’
[18:01:08.577] Searching for globals ... DONE
[18:01:08.577] Resolving globals: FALSE
[18:01:08.578] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:01:08.578] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:01:08.579] - globals: [1] ‘FUN’
[18:01:08.579] 
[18:01:08.579] getGlobalsAndPackages() ... DONE
[18:01:08.579]  - globals found/used: [n=1] ‘FUN’
[18:01:08.579]  - needed namespaces: [n=0] 
[18:01:08.580] Finding globals ... DONE
[18:01:08.580] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:08.580] List of 2
[18:01:08.580]  $ ...future.FUN:function (x, y)  
[18:01:08.580]  $ MoreArgs     :List of 1
[18:01:08.580]   ..$ y: int [1:2] 3 4
[18:01:08.580]  - attr(*, "where")=List of 2
[18:01:08.580]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:08.580]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:08.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:08.580]  - attr(*, "resolved")= logi FALSE
[18:01:08.580]  - attr(*, "total_size")= num NA
[18:01:08.586] Packages to be attached in all futures: [n=0] 
[18:01:08.586] getGlobalsAndPackagesXApply() ... DONE
[18:01:08.587] Number of futures (= number of chunks): 2
[18:01:08.587] Launching 2 futures (chunks) ...
[18:01:08.587] Chunk #1 of 2 ...
[18:01:08.587]  - Finding globals in '...' for chunk #1 ...
[18:01:08.588] getGlobalsAndPackages() ...
[18:01:08.588] Searching for globals...
[18:01:08.588] 
[18:01:08.589] Searching for globals ... DONE
[18:01:08.589] - globals: [0] <none>
[18:01:08.589] getGlobalsAndPackages() ... DONE
[18:01:08.589]    + additional globals found: [n=0] 
[18:01:08.589]    + additional namespaces needed: [n=0] 
[18:01:08.590]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:08.590]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.590]  - seeds: [1] <seeds>
[18:01:08.590]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.590] getGlobalsAndPackages() ...
[18:01:08.591] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.591] Resolving globals: FALSE
[18:01:08.592] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[18:01:08.593] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:01:08.593] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.593] 
[18:01:08.593] getGlobalsAndPackages() ... DONE
[18:01:08.594] run() for ‘Future’ ...
[18:01:08.594] - state: ‘created’
[18:01:08.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.618]   - Field: ‘node’
[18:01:08.618]   - Field: ‘label’
[18:01:08.618]   - Field: ‘local’
[18:01:08.619]   - Field: ‘owner’
[18:01:08.619]   - Field: ‘envir’
[18:01:08.619]   - Field: ‘workers’
[18:01:08.619]   - Field: ‘packages’
[18:01:08.619]   - Field: ‘gc’
[18:01:08.620]   - Field: ‘conditions’
[18:01:08.620]   - Field: ‘persistent’
[18:01:08.620]   - Field: ‘expr’
[18:01:08.620]   - Field: ‘uuid’
[18:01:08.620]   - Field: ‘seed’
[18:01:08.621]   - Field: ‘version’
[18:01:08.621]   - Field: ‘result’
[18:01:08.621]   - Field: ‘asynchronous’
[18:01:08.621]   - Field: ‘calls’
[18:01:08.621]   - Field: ‘globals’
[18:01:08.621]   - Field: ‘stdout’
[18:01:08.622]   - Field: ‘earlySignal’
[18:01:08.622]   - Field: ‘lazy’
[18:01:08.622]   - Field: ‘state’
[18:01:08.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.622] - Launch lazy future ...
[18:01:08.623] Packages needed by the future expression (n = 0): <none>
[18:01:08.623] Packages needed by future strategies (n = 0): <none>
[18:01:08.624] {
[18:01:08.624]     {
[18:01:08.624]         {
[18:01:08.624]             ...future.startTime <- base::Sys.time()
[18:01:08.624]             {
[18:01:08.624]                 {
[18:01:08.624]                   {
[18:01:08.624]                     {
[18:01:08.624]                       base::local({
[18:01:08.624]                         has_future <- base::requireNamespace("future", 
[18:01:08.624]                           quietly = TRUE)
[18:01:08.624]                         if (has_future) {
[18:01:08.624]                           ns <- base::getNamespace("future")
[18:01:08.624]                           version <- ns[[".package"]][["version"]]
[18:01:08.624]                           if (is.null(version)) 
[18:01:08.624]                             version <- utils::packageVersion("future")
[18:01:08.624]                         }
[18:01:08.624]                         else {
[18:01:08.624]                           version <- NULL
[18:01:08.624]                         }
[18:01:08.624]                         if (!has_future || version < "1.8.0") {
[18:01:08.624]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.624]                             "", base::R.version$version.string), 
[18:01:08.624]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.624]                               "release", "version")], collapse = " "), 
[18:01:08.624]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.624]                             info)
[18:01:08.624]                           info <- base::paste(info, collapse = "; ")
[18:01:08.624]                           if (!has_future) {
[18:01:08.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.624]                               info)
[18:01:08.624]                           }
[18:01:08.624]                           else {
[18:01:08.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.624]                               info, version)
[18:01:08.624]                           }
[18:01:08.624]                           base::stop(msg)
[18:01:08.624]                         }
[18:01:08.624]                       })
[18:01:08.624]                     }
[18:01:08.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.624]                     base::options(mc.cores = 1L)
[18:01:08.624]                   }
[18:01:08.624]                   ...future.strategy.old <- future::plan("list")
[18:01:08.624]                   options(future.plan = NULL)
[18:01:08.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.624]                 }
[18:01:08.624]                 ...future.workdir <- getwd()
[18:01:08.624]             }
[18:01:08.624]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.624]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.624]         }
[18:01:08.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.624]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.624]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.624]             base::names(...future.oldOptions))
[18:01:08.624]     }
[18:01:08.624]     if (FALSE) {
[18:01:08.624]     }
[18:01:08.624]     else {
[18:01:08.624]         if (TRUE) {
[18:01:08.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.624]                 open = "w")
[18:01:08.624]         }
[18:01:08.624]         else {
[18:01:08.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.624]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.624]         }
[18:01:08.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.624]             base::sink(type = "output", split = FALSE)
[18:01:08.624]             base::close(...future.stdout)
[18:01:08.624]         }, add = TRUE)
[18:01:08.624]     }
[18:01:08.624]     ...future.frame <- base::sys.nframe()
[18:01:08.624]     ...future.conditions <- base::list()
[18:01:08.624]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.624]     if (FALSE) {
[18:01:08.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.624]     }
[18:01:08.624]     ...future.result <- base::tryCatch({
[18:01:08.624]         base::withCallingHandlers({
[18:01:08.624]             ...future.value <- base::withVisible(base::local({
[18:01:08.624]                 ...future.makeSendCondition <- base::local({
[18:01:08.624]                   sendCondition <- NULL
[18:01:08.624]                   function(frame = 1L) {
[18:01:08.624]                     if (is.function(sendCondition)) 
[18:01:08.624]                       return(sendCondition)
[18:01:08.624]                     ns <- getNamespace("parallel")
[18:01:08.624]                     if (exists("sendData", mode = "function", 
[18:01:08.624]                       envir = ns)) {
[18:01:08.624]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.624]                         envir = ns)
[18:01:08.624]                       envir <- sys.frame(frame)
[18:01:08.624]                       master <- NULL
[18:01:08.624]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.624]                         !identical(envir, emptyenv())) {
[18:01:08.624]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.624]                           inherits = FALSE)) {
[18:01:08.624]                           master <- get("master", mode = "list", 
[18:01:08.624]                             envir = envir, inherits = FALSE)
[18:01:08.624]                           if (inherits(master, c("SOCKnode", 
[18:01:08.624]                             "SOCK0node"))) {
[18:01:08.624]                             sendCondition <<- function(cond) {
[18:01:08.624]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.624]                                 success = TRUE)
[18:01:08.624]                               parallel_sendData(master, data)
[18:01:08.624]                             }
[18:01:08.624]                             return(sendCondition)
[18:01:08.624]                           }
[18:01:08.624]                         }
[18:01:08.624]                         frame <- frame + 1L
[18:01:08.624]                         envir <- sys.frame(frame)
[18:01:08.624]                       }
[18:01:08.624]                     }
[18:01:08.624]                     sendCondition <<- function(cond) NULL
[18:01:08.624]                   }
[18:01:08.624]                 })
[18:01:08.624]                 withCallingHandlers({
[18:01:08.624]                   {
[18:01:08.624]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.624]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.624]                       ...future.globals.maxSize)) {
[18:01:08.624]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.624]                       on.exit(options(oopts), add = TRUE)
[18:01:08.624]                     }
[18:01:08.624]                     {
[18:01:08.624]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:08.624]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:08.624]                           envir = globalenv(), inherits = FALSE)
[18:01:08.624]                         ...future.FUN(...)
[18:01:08.624]                       }
[18:01:08.624]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:08.624]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:08.624]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.624]                         USE.NAMES = FALSE)
[18:01:08.624]                       do.call(mapply, args = args)
[18:01:08.624]                     }
[18:01:08.624]                   }
[18:01:08.624]                 }, immediateCondition = function(cond) {
[18:01:08.624]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.624]                   sendCondition(cond)
[18:01:08.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.624]                   {
[18:01:08.624]                     inherits <- base::inherits
[18:01:08.624]                     invokeRestart <- base::invokeRestart
[18:01:08.624]                     is.null <- base::is.null
[18:01:08.624]                     muffled <- FALSE
[18:01:08.624]                     if (inherits(cond, "message")) {
[18:01:08.624]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.624]                       if (muffled) 
[18:01:08.624]                         invokeRestart("muffleMessage")
[18:01:08.624]                     }
[18:01:08.624]                     else if (inherits(cond, "warning")) {
[18:01:08.624]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.624]                       if (muffled) 
[18:01:08.624]                         invokeRestart("muffleWarning")
[18:01:08.624]                     }
[18:01:08.624]                     else if (inherits(cond, "condition")) {
[18:01:08.624]                       if (!is.null(pattern)) {
[18:01:08.624]                         computeRestarts <- base::computeRestarts
[18:01:08.624]                         grepl <- base::grepl
[18:01:08.624]                         restarts <- computeRestarts(cond)
[18:01:08.624]                         for (restart in restarts) {
[18:01:08.624]                           name <- restart$name
[18:01:08.624]                           if (is.null(name)) 
[18:01:08.624]                             next
[18:01:08.624]                           if (!grepl(pattern, name)) 
[18:01:08.624]                             next
[18:01:08.624]                           invokeRestart(restart)
[18:01:08.624]                           muffled <- TRUE
[18:01:08.624]                           break
[18:01:08.624]                         }
[18:01:08.624]                       }
[18:01:08.624]                     }
[18:01:08.624]                     invisible(muffled)
[18:01:08.624]                   }
[18:01:08.624]                   muffleCondition(cond)
[18:01:08.624]                 })
[18:01:08.624]             }))
[18:01:08.624]             future::FutureResult(value = ...future.value$value, 
[18:01:08.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.624]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.624]                     ...future.globalenv.names))
[18:01:08.624]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.624]         }, condition = base::local({
[18:01:08.624]             c <- base::c
[18:01:08.624]             inherits <- base::inherits
[18:01:08.624]             invokeRestart <- base::invokeRestart
[18:01:08.624]             length <- base::length
[18:01:08.624]             list <- base::list
[18:01:08.624]             seq.int <- base::seq.int
[18:01:08.624]             signalCondition <- base::signalCondition
[18:01:08.624]             sys.calls <- base::sys.calls
[18:01:08.624]             `[[` <- base::`[[`
[18:01:08.624]             `+` <- base::`+`
[18:01:08.624]             `<<-` <- base::`<<-`
[18:01:08.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.624]                   3L)]
[18:01:08.624]             }
[18:01:08.624]             function(cond) {
[18:01:08.624]                 is_error <- inherits(cond, "error")
[18:01:08.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.624]                   NULL)
[18:01:08.624]                 if (is_error) {
[18:01:08.624]                   sessionInformation <- function() {
[18:01:08.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.624]                       search = base::search(), system = base::Sys.info())
[18:01:08.624]                   }
[18:01:08.624]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.624]                     cond$call), session = sessionInformation(), 
[18:01:08.624]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.624]                   signalCondition(cond)
[18:01:08.624]                 }
[18:01:08.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.624]                 "immediateCondition"))) {
[18:01:08.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.624]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.624]                   if (TRUE && !signal) {
[18:01:08.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.624]                     {
[18:01:08.624]                       inherits <- base::inherits
[18:01:08.624]                       invokeRestart <- base::invokeRestart
[18:01:08.624]                       is.null <- base::is.null
[18:01:08.624]                       muffled <- FALSE
[18:01:08.624]                       if (inherits(cond, "message")) {
[18:01:08.624]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.624]                         if (muffled) 
[18:01:08.624]                           invokeRestart("muffleMessage")
[18:01:08.624]                       }
[18:01:08.624]                       else if (inherits(cond, "warning")) {
[18:01:08.624]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.624]                         if (muffled) 
[18:01:08.624]                           invokeRestart("muffleWarning")
[18:01:08.624]                       }
[18:01:08.624]                       else if (inherits(cond, "condition")) {
[18:01:08.624]                         if (!is.null(pattern)) {
[18:01:08.624]                           computeRestarts <- base::computeRestarts
[18:01:08.624]                           grepl <- base::grepl
[18:01:08.624]                           restarts <- computeRestarts(cond)
[18:01:08.624]                           for (restart in restarts) {
[18:01:08.624]                             name <- restart$name
[18:01:08.624]                             if (is.null(name)) 
[18:01:08.624]                               next
[18:01:08.624]                             if (!grepl(pattern, name)) 
[18:01:08.624]                               next
[18:01:08.624]                             invokeRestart(restart)
[18:01:08.624]                             muffled <- TRUE
[18:01:08.624]                             break
[18:01:08.624]                           }
[18:01:08.624]                         }
[18:01:08.624]                       }
[18:01:08.624]                       invisible(muffled)
[18:01:08.624]                     }
[18:01:08.624]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.624]                   }
[18:01:08.624]                 }
[18:01:08.624]                 else {
[18:01:08.624]                   if (TRUE) {
[18:01:08.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.624]                     {
[18:01:08.624]                       inherits <- base::inherits
[18:01:08.624]                       invokeRestart <- base::invokeRestart
[18:01:08.624]                       is.null <- base::is.null
[18:01:08.624]                       muffled <- FALSE
[18:01:08.624]                       if (inherits(cond, "message")) {
[18:01:08.624]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.624]                         if (muffled) 
[18:01:08.624]                           invokeRestart("muffleMessage")
[18:01:08.624]                       }
[18:01:08.624]                       else if (inherits(cond, "warning")) {
[18:01:08.624]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.624]                         if (muffled) 
[18:01:08.624]                           invokeRestart("muffleWarning")
[18:01:08.624]                       }
[18:01:08.624]                       else if (inherits(cond, "condition")) {
[18:01:08.624]                         if (!is.null(pattern)) {
[18:01:08.624]                           computeRestarts <- base::computeRestarts
[18:01:08.624]                           grepl <- base::grepl
[18:01:08.624]                           restarts <- computeRestarts(cond)
[18:01:08.624]                           for (restart in restarts) {
[18:01:08.624]                             name <- restart$name
[18:01:08.624]                             if (is.null(name)) 
[18:01:08.624]                               next
[18:01:08.624]                             if (!grepl(pattern, name)) 
[18:01:08.624]                               next
[18:01:08.624]                             invokeRestart(restart)
[18:01:08.624]                             muffled <- TRUE
[18:01:08.624]                             break
[18:01:08.624]                           }
[18:01:08.624]                         }
[18:01:08.624]                       }
[18:01:08.624]                       invisible(muffled)
[18:01:08.624]                     }
[18:01:08.624]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.624]                   }
[18:01:08.624]                 }
[18:01:08.624]             }
[18:01:08.624]         }))
[18:01:08.624]     }, error = function(ex) {
[18:01:08.624]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.624]                 ...future.rng), started = ...future.startTime, 
[18:01:08.624]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.624]             version = "1.8"), class = "FutureResult")
[18:01:08.624]     }, finally = {
[18:01:08.624]         if (!identical(...future.workdir, getwd())) 
[18:01:08.624]             setwd(...future.workdir)
[18:01:08.624]         {
[18:01:08.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.624]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.624]             }
[18:01:08.624]             base::options(...future.oldOptions)
[18:01:08.624]             if (.Platform$OS.type == "windows") {
[18:01:08.624]                 old_names <- names(...future.oldEnvVars)
[18:01:08.624]                 envs <- base::Sys.getenv()
[18:01:08.624]                 names <- names(envs)
[18:01:08.624]                 common <- intersect(names, old_names)
[18:01:08.624]                 added <- setdiff(names, old_names)
[18:01:08.624]                 removed <- setdiff(old_names, names)
[18:01:08.624]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.624]                   envs[common]]
[18:01:08.624]                 NAMES <- toupper(changed)
[18:01:08.624]                 args <- list()
[18:01:08.624]                 for (kk in seq_along(NAMES)) {
[18:01:08.624]                   name <- changed[[kk]]
[18:01:08.624]                   NAME <- NAMES[[kk]]
[18:01:08.624]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.624]                     next
[18:01:08.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.624]                 }
[18:01:08.624]                 NAMES <- toupper(added)
[18:01:08.624]                 for (kk in seq_along(NAMES)) {
[18:01:08.624]                   name <- added[[kk]]
[18:01:08.624]                   NAME <- NAMES[[kk]]
[18:01:08.624]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.624]                     next
[18:01:08.624]                   args[[name]] <- ""
[18:01:08.624]                 }
[18:01:08.624]                 NAMES <- toupper(removed)
[18:01:08.624]                 for (kk in seq_along(NAMES)) {
[18:01:08.624]                   name <- removed[[kk]]
[18:01:08.624]                   NAME <- NAMES[[kk]]
[18:01:08.624]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.624]                     next
[18:01:08.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.624]                 }
[18:01:08.624]                 if (length(args) > 0) 
[18:01:08.624]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.624]             }
[18:01:08.624]             else {
[18:01:08.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.624]             }
[18:01:08.624]             {
[18:01:08.624]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.624]                   0L) {
[18:01:08.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.624]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.624]                   base::options(opts)
[18:01:08.624]                 }
[18:01:08.624]                 {
[18:01:08.624]                   {
[18:01:08.624]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.624]                     NULL
[18:01:08.624]                   }
[18:01:08.624]                   options(future.plan = NULL)
[18:01:08.624]                   if (is.na(NA_character_)) 
[18:01:08.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.624]                     .init = FALSE)
[18:01:08.624]                 }
[18:01:08.624]             }
[18:01:08.624]         }
[18:01:08.624]     })
[18:01:08.624]     if (TRUE) {
[18:01:08.624]         base::sink(type = "output", split = FALSE)
[18:01:08.624]         if (TRUE) {
[18:01:08.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.624]         }
[18:01:08.624]         else {
[18:01:08.624]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.624]         }
[18:01:08.624]         base::close(...future.stdout)
[18:01:08.624]         ...future.stdout <- NULL
[18:01:08.624]     }
[18:01:08.624]     ...future.result$conditions <- ...future.conditions
[18:01:08.624]     ...future.result$finished <- base::Sys.time()
[18:01:08.624]     ...future.result
[18:01:08.624] }
[18:01:08.629] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[18:01:08.630] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[18:01:08.630] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[18:01:08.631] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[18:01:08.632] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[18:01:08.632] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:01:08.633] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:01:08.633] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[18:01:08.634] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[18:01:08.634] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:08.635] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.635] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[18:01:08.636] MultisessionFuture started
[18:01:08.636] - Launch lazy future ... done
[18:01:08.637] run() for ‘MultisessionFuture’ ... done
[18:01:08.637] Created future:
[18:01:08.637] MultisessionFuture:
[18:01:08.637] Label: ‘future_mapply-1’
[18:01:08.637] Expression:
[18:01:08.637] {
[18:01:08.637]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.637]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.637]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.637]         on.exit(options(oopts), add = TRUE)
[18:01:08.637]     }
[18:01:08.637]     {
[18:01:08.637]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:08.637]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:08.637]                 inherits = FALSE)
[18:01:08.637]             ...future.FUN(...)
[18:01:08.637]         }
[18:01:08.637]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:08.637]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:08.637]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.637]         do.call(mapply, args = args)
[18:01:08.637]     }
[18:01:08.637] }
[18:01:08.637] Lazy evaluation: FALSE
[18:01:08.637] Asynchronous evaluation: TRUE
[18:01:08.637] Local evaluation: TRUE
[18:01:08.637] Environment: R_GlobalEnv
[18:01:08.637] Capture standard output: TRUE
[18:01:08.637] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.637] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.637] Packages: <none>
[18:01:08.637] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:08.637] Resolved: FALSE
[18:01:08.637] Value: <not collected>
[18:01:08.637] Conditions captured: <none>
[18:01:08.637] Early signaling: FALSE
[18:01:08.637] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.637] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.650] Chunk #1 of 2 ... DONE
[18:01:08.650] Chunk #2 of 2 ...
[18:01:08.650]  - Finding globals in '...' for chunk #2 ...
[18:01:08.650] getGlobalsAndPackages() ...
[18:01:08.651] Searching for globals...
[18:01:08.651] 
[18:01:08.651] Searching for globals ... DONE
[18:01:08.652] - globals: [0] <none>
[18:01:08.652] getGlobalsAndPackages() ... DONE
[18:01:08.652]    + additional globals found: [n=0] 
[18:01:08.653]    + additional namespaces needed: [n=0] 
[18:01:08.653]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:08.653]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.653]  - seeds: [1] <seeds>
[18:01:08.653]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.654] getGlobalsAndPackages() ...
[18:01:08.654] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.654] Resolving globals: FALSE
[18:01:08.655] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[18:01:08.656] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[18:01:08.656] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.656] 
[18:01:08.657] getGlobalsAndPackages() ... DONE
[18:01:08.657] run() for ‘Future’ ...
[18:01:08.657] - state: ‘created’
[18:01:08.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.684] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.684]   - Field: ‘node’
[18:01:08.685]   - Field: ‘label’
[18:01:08.685]   - Field: ‘local’
[18:01:08.685]   - Field: ‘owner’
[18:01:08.685]   - Field: ‘envir’
[18:01:08.685]   - Field: ‘workers’
[18:01:08.686]   - Field: ‘packages’
[18:01:08.686]   - Field: ‘gc’
[18:01:08.686]   - Field: ‘conditions’
[18:01:08.686]   - Field: ‘persistent’
[18:01:08.686]   - Field: ‘expr’
[18:01:08.687]   - Field: ‘uuid’
[18:01:08.687]   - Field: ‘seed’
[18:01:08.687]   - Field: ‘version’
[18:01:08.687]   - Field: ‘result’
[18:01:08.687]   - Field: ‘asynchronous’
[18:01:08.688]   - Field: ‘calls’
[18:01:08.688]   - Field: ‘globals’
[18:01:08.688]   - Field: ‘stdout’
[18:01:08.688]   - Field: ‘earlySignal’
[18:01:08.688]   - Field: ‘lazy’
[18:01:08.689]   - Field: ‘state’
[18:01:08.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.689] - Launch lazy future ...
[18:01:08.690] Packages needed by the future expression (n = 0): <none>
[18:01:08.690] Packages needed by future strategies (n = 0): <none>
[18:01:08.691] {
[18:01:08.691]     {
[18:01:08.691]         {
[18:01:08.691]             ...future.startTime <- base::Sys.time()
[18:01:08.691]             {
[18:01:08.691]                 {
[18:01:08.691]                   {
[18:01:08.691]                     {
[18:01:08.691]                       base::local({
[18:01:08.691]                         has_future <- base::requireNamespace("future", 
[18:01:08.691]                           quietly = TRUE)
[18:01:08.691]                         if (has_future) {
[18:01:08.691]                           ns <- base::getNamespace("future")
[18:01:08.691]                           version <- ns[[".package"]][["version"]]
[18:01:08.691]                           if (is.null(version)) 
[18:01:08.691]                             version <- utils::packageVersion("future")
[18:01:08.691]                         }
[18:01:08.691]                         else {
[18:01:08.691]                           version <- NULL
[18:01:08.691]                         }
[18:01:08.691]                         if (!has_future || version < "1.8.0") {
[18:01:08.691]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.691]                             "", base::R.version$version.string), 
[18:01:08.691]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.691]                               "release", "version")], collapse = " "), 
[18:01:08.691]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.691]                             info)
[18:01:08.691]                           info <- base::paste(info, collapse = "; ")
[18:01:08.691]                           if (!has_future) {
[18:01:08.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.691]                               info)
[18:01:08.691]                           }
[18:01:08.691]                           else {
[18:01:08.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.691]                               info, version)
[18:01:08.691]                           }
[18:01:08.691]                           base::stop(msg)
[18:01:08.691]                         }
[18:01:08.691]                       })
[18:01:08.691]                     }
[18:01:08.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.691]                     base::options(mc.cores = 1L)
[18:01:08.691]                   }
[18:01:08.691]                   ...future.strategy.old <- future::plan("list")
[18:01:08.691]                   options(future.plan = NULL)
[18:01:08.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.691]                 }
[18:01:08.691]                 ...future.workdir <- getwd()
[18:01:08.691]             }
[18:01:08.691]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.691]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.691]         }
[18:01:08.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.691]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.691]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.691]             base::names(...future.oldOptions))
[18:01:08.691]     }
[18:01:08.691]     if (FALSE) {
[18:01:08.691]     }
[18:01:08.691]     else {
[18:01:08.691]         if (TRUE) {
[18:01:08.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.691]                 open = "w")
[18:01:08.691]         }
[18:01:08.691]         else {
[18:01:08.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.691]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.691]         }
[18:01:08.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.691]             base::sink(type = "output", split = FALSE)
[18:01:08.691]             base::close(...future.stdout)
[18:01:08.691]         }, add = TRUE)
[18:01:08.691]     }
[18:01:08.691]     ...future.frame <- base::sys.nframe()
[18:01:08.691]     ...future.conditions <- base::list()
[18:01:08.691]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.691]     if (FALSE) {
[18:01:08.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.691]     }
[18:01:08.691]     ...future.result <- base::tryCatch({
[18:01:08.691]         base::withCallingHandlers({
[18:01:08.691]             ...future.value <- base::withVisible(base::local({
[18:01:08.691]                 ...future.makeSendCondition <- base::local({
[18:01:08.691]                   sendCondition <- NULL
[18:01:08.691]                   function(frame = 1L) {
[18:01:08.691]                     if (is.function(sendCondition)) 
[18:01:08.691]                       return(sendCondition)
[18:01:08.691]                     ns <- getNamespace("parallel")
[18:01:08.691]                     if (exists("sendData", mode = "function", 
[18:01:08.691]                       envir = ns)) {
[18:01:08.691]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.691]                         envir = ns)
[18:01:08.691]                       envir <- sys.frame(frame)
[18:01:08.691]                       master <- NULL
[18:01:08.691]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.691]                         !identical(envir, emptyenv())) {
[18:01:08.691]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.691]                           inherits = FALSE)) {
[18:01:08.691]                           master <- get("master", mode = "list", 
[18:01:08.691]                             envir = envir, inherits = FALSE)
[18:01:08.691]                           if (inherits(master, c("SOCKnode", 
[18:01:08.691]                             "SOCK0node"))) {
[18:01:08.691]                             sendCondition <<- function(cond) {
[18:01:08.691]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.691]                                 success = TRUE)
[18:01:08.691]                               parallel_sendData(master, data)
[18:01:08.691]                             }
[18:01:08.691]                             return(sendCondition)
[18:01:08.691]                           }
[18:01:08.691]                         }
[18:01:08.691]                         frame <- frame + 1L
[18:01:08.691]                         envir <- sys.frame(frame)
[18:01:08.691]                       }
[18:01:08.691]                     }
[18:01:08.691]                     sendCondition <<- function(cond) NULL
[18:01:08.691]                   }
[18:01:08.691]                 })
[18:01:08.691]                 withCallingHandlers({
[18:01:08.691]                   {
[18:01:08.691]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.691]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.691]                       ...future.globals.maxSize)) {
[18:01:08.691]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.691]                       on.exit(options(oopts), add = TRUE)
[18:01:08.691]                     }
[18:01:08.691]                     {
[18:01:08.691]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:08.691]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:08.691]                           envir = globalenv(), inherits = FALSE)
[18:01:08.691]                         ...future.FUN(...)
[18:01:08.691]                       }
[18:01:08.691]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:08.691]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:08.691]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.691]                         USE.NAMES = FALSE)
[18:01:08.691]                       do.call(mapply, args = args)
[18:01:08.691]                     }
[18:01:08.691]                   }
[18:01:08.691]                 }, immediateCondition = function(cond) {
[18:01:08.691]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.691]                   sendCondition(cond)
[18:01:08.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.691]                   {
[18:01:08.691]                     inherits <- base::inherits
[18:01:08.691]                     invokeRestart <- base::invokeRestart
[18:01:08.691]                     is.null <- base::is.null
[18:01:08.691]                     muffled <- FALSE
[18:01:08.691]                     if (inherits(cond, "message")) {
[18:01:08.691]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.691]                       if (muffled) 
[18:01:08.691]                         invokeRestart("muffleMessage")
[18:01:08.691]                     }
[18:01:08.691]                     else if (inherits(cond, "warning")) {
[18:01:08.691]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.691]                       if (muffled) 
[18:01:08.691]                         invokeRestart("muffleWarning")
[18:01:08.691]                     }
[18:01:08.691]                     else if (inherits(cond, "condition")) {
[18:01:08.691]                       if (!is.null(pattern)) {
[18:01:08.691]                         computeRestarts <- base::computeRestarts
[18:01:08.691]                         grepl <- base::grepl
[18:01:08.691]                         restarts <- computeRestarts(cond)
[18:01:08.691]                         for (restart in restarts) {
[18:01:08.691]                           name <- restart$name
[18:01:08.691]                           if (is.null(name)) 
[18:01:08.691]                             next
[18:01:08.691]                           if (!grepl(pattern, name)) 
[18:01:08.691]                             next
[18:01:08.691]                           invokeRestart(restart)
[18:01:08.691]                           muffled <- TRUE
[18:01:08.691]                           break
[18:01:08.691]                         }
[18:01:08.691]                       }
[18:01:08.691]                     }
[18:01:08.691]                     invisible(muffled)
[18:01:08.691]                   }
[18:01:08.691]                   muffleCondition(cond)
[18:01:08.691]                 })
[18:01:08.691]             }))
[18:01:08.691]             future::FutureResult(value = ...future.value$value, 
[18:01:08.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.691]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.691]                     ...future.globalenv.names))
[18:01:08.691]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.691]         }, condition = base::local({
[18:01:08.691]             c <- base::c
[18:01:08.691]             inherits <- base::inherits
[18:01:08.691]             invokeRestart <- base::invokeRestart
[18:01:08.691]             length <- base::length
[18:01:08.691]             list <- base::list
[18:01:08.691]             seq.int <- base::seq.int
[18:01:08.691]             signalCondition <- base::signalCondition
[18:01:08.691]             sys.calls <- base::sys.calls
[18:01:08.691]             `[[` <- base::`[[`
[18:01:08.691]             `+` <- base::`+`
[18:01:08.691]             `<<-` <- base::`<<-`
[18:01:08.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.691]                   3L)]
[18:01:08.691]             }
[18:01:08.691]             function(cond) {
[18:01:08.691]                 is_error <- inherits(cond, "error")
[18:01:08.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.691]                   NULL)
[18:01:08.691]                 if (is_error) {
[18:01:08.691]                   sessionInformation <- function() {
[18:01:08.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.691]                       search = base::search(), system = base::Sys.info())
[18:01:08.691]                   }
[18:01:08.691]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.691]                     cond$call), session = sessionInformation(), 
[18:01:08.691]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.691]                   signalCondition(cond)
[18:01:08.691]                 }
[18:01:08.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.691]                 "immediateCondition"))) {
[18:01:08.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.691]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.691]                   if (TRUE && !signal) {
[18:01:08.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.691]                     {
[18:01:08.691]                       inherits <- base::inherits
[18:01:08.691]                       invokeRestart <- base::invokeRestart
[18:01:08.691]                       is.null <- base::is.null
[18:01:08.691]                       muffled <- FALSE
[18:01:08.691]                       if (inherits(cond, "message")) {
[18:01:08.691]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.691]                         if (muffled) 
[18:01:08.691]                           invokeRestart("muffleMessage")
[18:01:08.691]                       }
[18:01:08.691]                       else if (inherits(cond, "warning")) {
[18:01:08.691]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.691]                         if (muffled) 
[18:01:08.691]                           invokeRestart("muffleWarning")
[18:01:08.691]                       }
[18:01:08.691]                       else if (inherits(cond, "condition")) {
[18:01:08.691]                         if (!is.null(pattern)) {
[18:01:08.691]                           computeRestarts <- base::computeRestarts
[18:01:08.691]                           grepl <- base::grepl
[18:01:08.691]                           restarts <- computeRestarts(cond)
[18:01:08.691]                           for (restart in restarts) {
[18:01:08.691]                             name <- restart$name
[18:01:08.691]                             if (is.null(name)) 
[18:01:08.691]                               next
[18:01:08.691]                             if (!grepl(pattern, name)) 
[18:01:08.691]                               next
[18:01:08.691]                             invokeRestart(restart)
[18:01:08.691]                             muffled <- TRUE
[18:01:08.691]                             break
[18:01:08.691]                           }
[18:01:08.691]                         }
[18:01:08.691]                       }
[18:01:08.691]                       invisible(muffled)
[18:01:08.691]                     }
[18:01:08.691]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.691]                   }
[18:01:08.691]                 }
[18:01:08.691]                 else {
[18:01:08.691]                   if (TRUE) {
[18:01:08.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.691]                     {
[18:01:08.691]                       inherits <- base::inherits
[18:01:08.691]                       invokeRestart <- base::invokeRestart
[18:01:08.691]                       is.null <- base::is.null
[18:01:08.691]                       muffled <- FALSE
[18:01:08.691]                       if (inherits(cond, "message")) {
[18:01:08.691]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.691]                         if (muffled) 
[18:01:08.691]                           invokeRestart("muffleMessage")
[18:01:08.691]                       }
[18:01:08.691]                       else if (inherits(cond, "warning")) {
[18:01:08.691]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.691]                         if (muffled) 
[18:01:08.691]                           invokeRestart("muffleWarning")
[18:01:08.691]                       }
[18:01:08.691]                       else if (inherits(cond, "condition")) {
[18:01:08.691]                         if (!is.null(pattern)) {
[18:01:08.691]                           computeRestarts <- base::computeRestarts
[18:01:08.691]                           grepl <- base::grepl
[18:01:08.691]                           restarts <- computeRestarts(cond)
[18:01:08.691]                           for (restart in restarts) {
[18:01:08.691]                             name <- restart$name
[18:01:08.691]                             if (is.null(name)) 
[18:01:08.691]                               next
[18:01:08.691]                             if (!grepl(pattern, name)) 
[18:01:08.691]                               next
[18:01:08.691]                             invokeRestart(restart)
[18:01:08.691]                             muffled <- TRUE
[18:01:08.691]                             break
[18:01:08.691]                           }
[18:01:08.691]                         }
[18:01:08.691]                       }
[18:01:08.691]                       invisible(muffled)
[18:01:08.691]                     }
[18:01:08.691]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.691]                   }
[18:01:08.691]                 }
[18:01:08.691]             }
[18:01:08.691]         }))
[18:01:08.691]     }, error = function(ex) {
[18:01:08.691]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.691]                 ...future.rng), started = ...future.startTime, 
[18:01:08.691]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.691]             version = "1.8"), class = "FutureResult")
[18:01:08.691]     }, finally = {
[18:01:08.691]         if (!identical(...future.workdir, getwd())) 
[18:01:08.691]             setwd(...future.workdir)
[18:01:08.691]         {
[18:01:08.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.691]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.691]             }
[18:01:08.691]             base::options(...future.oldOptions)
[18:01:08.691]             if (.Platform$OS.type == "windows") {
[18:01:08.691]                 old_names <- names(...future.oldEnvVars)
[18:01:08.691]                 envs <- base::Sys.getenv()
[18:01:08.691]                 names <- names(envs)
[18:01:08.691]                 common <- intersect(names, old_names)
[18:01:08.691]                 added <- setdiff(names, old_names)
[18:01:08.691]                 removed <- setdiff(old_names, names)
[18:01:08.691]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.691]                   envs[common]]
[18:01:08.691]                 NAMES <- toupper(changed)
[18:01:08.691]                 args <- list()
[18:01:08.691]                 for (kk in seq_along(NAMES)) {
[18:01:08.691]                   name <- changed[[kk]]
[18:01:08.691]                   NAME <- NAMES[[kk]]
[18:01:08.691]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.691]                     next
[18:01:08.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.691]                 }
[18:01:08.691]                 NAMES <- toupper(added)
[18:01:08.691]                 for (kk in seq_along(NAMES)) {
[18:01:08.691]                   name <- added[[kk]]
[18:01:08.691]                   NAME <- NAMES[[kk]]
[18:01:08.691]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.691]                     next
[18:01:08.691]                   args[[name]] <- ""
[18:01:08.691]                 }
[18:01:08.691]                 NAMES <- toupper(removed)
[18:01:08.691]                 for (kk in seq_along(NAMES)) {
[18:01:08.691]                   name <- removed[[kk]]
[18:01:08.691]                   NAME <- NAMES[[kk]]
[18:01:08.691]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.691]                     next
[18:01:08.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.691]                 }
[18:01:08.691]                 if (length(args) > 0) 
[18:01:08.691]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.691]             }
[18:01:08.691]             else {
[18:01:08.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.691]             }
[18:01:08.691]             {
[18:01:08.691]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.691]                   0L) {
[18:01:08.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.691]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.691]                   base::options(opts)
[18:01:08.691]                 }
[18:01:08.691]                 {
[18:01:08.691]                   {
[18:01:08.691]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.691]                     NULL
[18:01:08.691]                   }
[18:01:08.691]                   options(future.plan = NULL)
[18:01:08.691]                   if (is.na(NA_character_)) 
[18:01:08.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.691]                     .init = FALSE)
[18:01:08.691]                 }
[18:01:08.691]             }
[18:01:08.691]         }
[18:01:08.691]     })
[18:01:08.691]     if (TRUE) {
[18:01:08.691]         base::sink(type = "output", split = FALSE)
[18:01:08.691]         if (TRUE) {
[18:01:08.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.691]         }
[18:01:08.691]         else {
[18:01:08.691]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.691]         }
[18:01:08.691]         base::close(...future.stdout)
[18:01:08.691]         ...future.stdout <- NULL
[18:01:08.691]     }
[18:01:08.691]     ...future.result$conditions <- ...future.conditions
[18:01:08.691]     ...future.result$finished <- base::Sys.time()
[18:01:08.691]     ...future.result
[18:01:08.691] }
[18:01:08.696] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[18:01:08.696] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[18:01:08.697] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[18:01:08.698] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[18:01:08.698] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[18:01:08.699] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:01:08.700] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:01:08.700] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[18:01:08.701] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[18:01:08.701] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:08.702] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.702] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[18:01:08.703] MultisessionFuture started
[18:01:08.704] - Launch lazy future ... done
[18:01:08.705] run() for ‘MultisessionFuture’ ... done
[18:01:08.705] Created future:
[18:01:08.705] MultisessionFuture:
[18:01:08.705] Label: ‘future_mapply-2’
[18:01:08.705] Expression:
[18:01:08.705] {
[18:01:08.705]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.705]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.705]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.705]         on.exit(options(oopts), add = TRUE)
[18:01:08.705]     }
[18:01:08.705]     {
[18:01:08.705]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:08.705]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:08.705]                 inherits = FALSE)
[18:01:08.705]             ...future.FUN(...)
[18:01:08.705]         }
[18:01:08.705]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:08.705]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:08.705]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.705]         do.call(mapply, args = args)
[18:01:08.705]     }
[18:01:08.705] }
[18:01:08.705] Lazy evaluation: FALSE
[18:01:08.705] Asynchronous evaluation: TRUE
[18:01:08.705] Local evaluation: TRUE
[18:01:08.705] Environment: R_GlobalEnv
[18:01:08.705] Capture standard output: TRUE
[18:01:08.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.705] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.705] Packages: <none>
[18:01:08.705] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:08.705] Resolved: FALSE
[18:01:08.705] Value: <not collected>
[18:01:08.705] Conditions captured: <none>
[18:01:08.705] Early signaling: FALSE
[18:01:08.705] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.705] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.718] Chunk #2 of 2 ... DONE
[18:01:08.718] Launching 2 futures (chunks) ... DONE
[18:01:08.719] Resolving 2 futures (chunks) ...
[18:01:08.719] resolve() on list ...
[18:01:08.719]  recursive: 0
[18:01:08.719]  length: 2
[18:01:08.719] 
[18:01:08.720] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.721] - Validating connection of MultisessionFuture
[18:01:08.721] - received message: FutureResult
[18:01:08.721] - Received FutureResult
[18:01:08.721] - Erased future from FutureRegistry
[18:01:08.722] result() for ClusterFuture ...
[18:01:08.722] - result already collected: FutureResult
[18:01:08.722] result() for ClusterFuture ... done
[18:01:08.722] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.722] Future #1
[18:01:08.723] result() for ClusterFuture ...
[18:01:08.723] - result already collected: FutureResult
[18:01:08.723] result() for ClusterFuture ... done
[18:01:08.723] result() for ClusterFuture ...
[18:01:08.723] - result already collected: FutureResult
[18:01:08.723] result() for ClusterFuture ... done
[18:01:08.724] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:08.724] - nx: 2
[18:01:08.724] - relay: TRUE
[18:01:08.724] - stdout: TRUE
[18:01:08.724] - signal: TRUE
[18:01:08.724] - resignal: FALSE
[18:01:08.725] - force: TRUE
[18:01:08.725] - relayed: [n=2] FALSE, FALSE
[18:01:08.725] - queued futures: [n=2] FALSE, FALSE
[18:01:08.725]  - until=1
[18:01:08.725]  - relaying element #1
[18:01:08.726] result() for ClusterFuture ...
[18:01:08.726] - result already collected: FutureResult
[18:01:08.726] result() for ClusterFuture ... done
[18:01:08.726] result() for ClusterFuture ...
[18:01:08.726] - result already collected: FutureResult
[18:01:08.726] result() for ClusterFuture ... done
[18:01:08.727] result() for ClusterFuture ...
[18:01:08.727] - result already collected: FutureResult
[18:01:08.727] result() for ClusterFuture ... done
[18:01:08.727] result() for ClusterFuture ...
[18:01:08.727] - result already collected: FutureResult
[18:01:08.728] result() for ClusterFuture ... done
[18:01:08.728] - relayed: [n=2] TRUE, FALSE
[18:01:08.728] - queued futures: [n=2] TRUE, FALSE
[18:01:08.728] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:08.728]  length: 1 (resolved future 1)
[18:01:08.750] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.751] - Validating connection of MultisessionFuture
[18:01:08.751] - received message: FutureResult
[18:01:08.751] - Received FutureResult
[18:01:08.751] - Erased future from FutureRegistry
[18:01:08.752] result() for ClusterFuture ...
[18:01:08.752] - result already collected: FutureResult
[18:01:08.752] result() for ClusterFuture ... done
[18:01:08.752] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.752] Future #2
[18:01:08.753] result() for ClusterFuture ...
[18:01:08.753] - result already collected: FutureResult
[18:01:08.753] result() for ClusterFuture ... done
[18:01:08.753] result() for ClusterFuture ...
[18:01:08.753] - result already collected: FutureResult
[18:01:08.753] result() for ClusterFuture ... done
[18:01:08.754] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:08.754] - nx: 2
[18:01:08.754] - relay: TRUE
[18:01:08.754] - stdout: TRUE
[18:01:08.754] - signal: TRUE
[18:01:08.755] - resignal: FALSE
[18:01:08.755] - force: TRUE
[18:01:08.755] - relayed: [n=2] TRUE, FALSE
[18:01:08.755] - queued futures: [n=2] TRUE, FALSE
[18:01:08.755]  - until=2
[18:01:08.755]  - relaying element #2
[18:01:08.756] result() for ClusterFuture ...
[18:01:08.756] - result already collected: FutureResult
[18:01:08.756] result() for ClusterFuture ... done
[18:01:08.756] result() for ClusterFuture ...
[18:01:08.756] - result already collected: FutureResult
[18:01:08.757] result() for ClusterFuture ... done
[18:01:08.757] result() for ClusterFuture ...
[18:01:08.757] - result already collected: FutureResult
[18:01:08.757] result() for ClusterFuture ... done
[18:01:08.757] result() for ClusterFuture ...
[18:01:08.757] - result already collected: FutureResult
[18:01:08.758] result() for ClusterFuture ... done
[18:01:08.758] - relayed: [n=2] TRUE, TRUE
[18:01:08.758] - queued futures: [n=2] TRUE, TRUE
[18:01:08.758] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:08.758]  length: 0 (resolved future 2)
[18:01:08.759] Relaying remaining futures
[18:01:08.759] signalConditionsASAP(NULL, pos=0) ...
[18:01:08.759] - nx: 2
[18:01:08.759] - relay: TRUE
[18:01:08.759] - stdout: TRUE
[18:01:08.759] - signal: TRUE
[18:01:08.760] - resignal: FALSE
[18:01:08.760] - force: TRUE
[18:01:08.760] - relayed: [n=2] TRUE, TRUE
[18:01:08.760] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:08.760] - relayed: [n=2] TRUE, TRUE
[18:01:08.761] - queued futures: [n=2] TRUE, TRUE
[18:01:08.761] signalConditionsASAP(NULL, pos=0) ... done
[18:01:08.761] resolve() on list ... DONE
[18:01:08.761] result() for ClusterFuture ...
[18:01:08.761] - result already collected: FutureResult
[18:01:08.761] result() for ClusterFuture ... done
[18:01:08.762] result() for ClusterFuture ...
[18:01:08.762] - result already collected: FutureResult
[18:01:08.762] result() for ClusterFuture ... done
[18:01:08.762] result() for ClusterFuture ...
[18:01:08.762] - result already collected: FutureResult
[18:01:08.763] result() for ClusterFuture ... done
[18:01:08.763] result() for ClusterFuture ...
[18:01:08.763] - result already collected: FutureResult
[18:01:08.763] result() for ClusterFuture ... done
[18:01:08.763]  - Number of value chunks collected: 2
[18:01:08.764] Resolving 2 futures (chunks) ... DONE
[18:01:08.764] Reducing values from 2 chunks ...
[18:01:08.764]  - Number of values collected after concatenation: 2
[18:01:08.764]  - Number of values expected: 2
[18:01:08.764] Reducing values from 2 chunks ... DONE
[18:01:08.764] future_mapply() ... DONE
[18:01:08.765] future_mapply() ...
[18:01:08.771] Number of chunks: 2
[18:01:08.771] getGlobalsAndPackagesXApply() ...
[18:01:08.771]  - future.globals: TRUE
[18:01:08.772] getGlobalsAndPackages() ...
[18:01:08.772] Searching for globals...
[18:01:08.774] - globals found: [1] ‘FUN’
[18:01:08.774] Searching for globals ... DONE
[18:01:08.774] Resolving globals: FALSE
[18:01:08.775] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[18:01:08.775] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[18:01:08.776] - globals: [1] ‘FUN’
[18:01:08.776] 
[18:01:08.776] getGlobalsAndPackages() ... DONE
[18:01:08.776]  - globals found/used: [n=1] ‘FUN’
[18:01:08.776]  - needed namespaces: [n=0] 
[18:01:08.777] Finding globals ... DONE
[18:01:08.777] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:08.777] List of 2
[18:01:08.777]  $ ...future.FUN:function (x, y)  
[18:01:08.777]  $ MoreArgs     :List of 1
[18:01:08.777]   ..$ y: int [1:2] 3 4
[18:01:08.777]  - attr(*, "where")=List of 2
[18:01:08.777]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:08.777]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:08.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:08.777]  - attr(*, "resolved")= logi FALSE
[18:01:08.777]  - attr(*, "total_size")= num NA
[18:01:08.783] Packages to be attached in all futures: [n=0] 
[18:01:08.783] getGlobalsAndPackagesXApply() ... DONE
[18:01:08.784] Number of futures (= number of chunks): 2
[18:01:08.784] Launching 2 futures (chunks) ...
[18:01:08.784] Chunk #1 of 2 ...
[18:01:08.784]  - Finding globals in '...' for chunk #1 ...
[18:01:08.785] getGlobalsAndPackages() ...
[18:01:08.785] Searching for globals...
[18:01:08.785] 
[18:01:08.785] Searching for globals ... DONE
[18:01:08.786] - globals: [0] <none>
[18:01:08.786] getGlobalsAndPackages() ... DONE
[18:01:08.786]    + additional globals found: [n=0] 
[18:01:08.786]    + additional namespaces needed: [n=0] 
[18:01:08.786]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:08.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.787]  - seeds: <none>
[18:01:08.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.787] getGlobalsAndPackages() ...
[18:01:08.787] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.788] Resolving globals: FALSE
[18:01:08.789] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:08.789] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:08.790] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.790] 
[18:01:08.790] getGlobalsAndPackages() ... DONE
[18:01:08.791] run() for ‘Future’ ...
[18:01:08.791] - state: ‘created’
[18:01:08.791] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.813] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.814]   - Field: ‘node’
[18:01:08.814]   - Field: ‘label’
[18:01:08.814]   - Field: ‘local’
[18:01:08.814]   - Field: ‘owner’
[18:01:08.815]   - Field: ‘envir’
[18:01:08.815]   - Field: ‘workers’
[18:01:08.815]   - Field: ‘packages’
[18:01:08.815]   - Field: ‘gc’
[18:01:08.815]   - Field: ‘conditions’
[18:01:08.816]   - Field: ‘persistent’
[18:01:08.816]   - Field: ‘expr’
[18:01:08.816]   - Field: ‘uuid’
[18:01:08.816]   - Field: ‘seed’
[18:01:08.816]   - Field: ‘version’
[18:01:08.817]   - Field: ‘result’
[18:01:08.817]   - Field: ‘asynchronous’
[18:01:08.817]   - Field: ‘calls’
[18:01:08.817]   - Field: ‘globals’
[18:01:08.817]   - Field: ‘stdout’
[18:01:08.818]   - Field: ‘earlySignal’
[18:01:08.818]   - Field: ‘lazy’
[18:01:08.818]   - Field: ‘state’
[18:01:08.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.818] - Launch lazy future ...
[18:01:08.819] Packages needed by the future expression (n = 0): <none>
[18:01:08.819] Packages needed by future strategies (n = 0): <none>
[18:01:08.820] {
[18:01:08.820]     {
[18:01:08.820]         {
[18:01:08.820]             ...future.startTime <- base::Sys.time()
[18:01:08.820]             {
[18:01:08.820]                 {
[18:01:08.820]                   {
[18:01:08.820]                     {
[18:01:08.820]                       base::local({
[18:01:08.820]                         has_future <- base::requireNamespace("future", 
[18:01:08.820]                           quietly = TRUE)
[18:01:08.820]                         if (has_future) {
[18:01:08.820]                           ns <- base::getNamespace("future")
[18:01:08.820]                           version <- ns[[".package"]][["version"]]
[18:01:08.820]                           if (is.null(version)) 
[18:01:08.820]                             version <- utils::packageVersion("future")
[18:01:08.820]                         }
[18:01:08.820]                         else {
[18:01:08.820]                           version <- NULL
[18:01:08.820]                         }
[18:01:08.820]                         if (!has_future || version < "1.8.0") {
[18:01:08.820]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.820]                             "", base::R.version$version.string), 
[18:01:08.820]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.820]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.820]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.820]                               "release", "version")], collapse = " "), 
[18:01:08.820]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.820]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.820]                             info)
[18:01:08.820]                           info <- base::paste(info, collapse = "; ")
[18:01:08.820]                           if (!has_future) {
[18:01:08.820]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.820]                               info)
[18:01:08.820]                           }
[18:01:08.820]                           else {
[18:01:08.820]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.820]                               info, version)
[18:01:08.820]                           }
[18:01:08.820]                           base::stop(msg)
[18:01:08.820]                         }
[18:01:08.820]                       })
[18:01:08.820]                     }
[18:01:08.820]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.820]                     base::options(mc.cores = 1L)
[18:01:08.820]                   }
[18:01:08.820]                   ...future.strategy.old <- future::plan("list")
[18:01:08.820]                   options(future.plan = NULL)
[18:01:08.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.820]                 }
[18:01:08.820]                 ...future.workdir <- getwd()
[18:01:08.820]             }
[18:01:08.820]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.820]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.820]         }
[18:01:08.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.820]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.820]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.820]             base::names(...future.oldOptions))
[18:01:08.820]     }
[18:01:08.820]     if (FALSE) {
[18:01:08.820]     }
[18:01:08.820]     else {
[18:01:08.820]         if (TRUE) {
[18:01:08.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.820]                 open = "w")
[18:01:08.820]         }
[18:01:08.820]         else {
[18:01:08.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.820]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.820]         }
[18:01:08.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.820]             base::sink(type = "output", split = FALSE)
[18:01:08.820]             base::close(...future.stdout)
[18:01:08.820]         }, add = TRUE)
[18:01:08.820]     }
[18:01:08.820]     ...future.frame <- base::sys.nframe()
[18:01:08.820]     ...future.conditions <- base::list()
[18:01:08.820]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.820]     if (FALSE) {
[18:01:08.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.820]     }
[18:01:08.820]     ...future.result <- base::tryCatch({
[18:01:08.820]         base::withCallingHandlers({
[18:01:08.820]             ...future.value <- base::withVisible(base::local({
[18:01:08.820]                 ...future.makeSendCondition <- base::local({
[18:01:08.820]                   sendCondition <- NULL
[18:01:08.820]                   function(frame = 1L) {
[18:01:08.820]                     if (is.function(sendCondition)) 
[18:01:08.820]                       return(sendCondition)
[18:01:08.820]                     ns <- getNamespace("parallel")
[18:01:08.820]                     if (exists("sendData", mode = "function", 
[18:01:08.820]                       envir = ns)) {
[18:01:08.820]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.820]                         envir = ns)
[18:01:08.820]                       envir <- sys.frame(frame)
[18:01:08.820]                       master <- NULL
[18:01:08.820]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.820]                         !identical(envir, emptyenv())) {
[18:01:08.820]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.820]                           inherits = FALSE)) {
[18:01:08.820]                           master <- get("master", mode = "list", 
[18:01:08.820]                             envir = envir, inherits = FALSE)
[18:01:08.820]                           if (inherits(master, c("SOCKnode", 
[18:01:08.820]                             "SOCK0node"))) {
[18:01:08.820]                             sendCondition <<- function(cond) {
[18:01:08.820]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.820]                                 success = TRUE)
[18:01:08.820]                               parallel_sendData(master, data)
[18:01:08.820]                             }
[18:01:08.820]                             return(sendCondition)
[18:01:08.820]                           }
[18:01:08.820]                         }
[18:01:08.820]                         frame <- frame + 1L
[18:01:08.820]                         envir <- sys.frame(frame)
[18:01:08.820]                       }
[18:01:08.820]                     }
[18:01:08.820]                     sendCondition <<- function(cond) NULL
[18:01:08.820]                   }
[18:01:08.820]                 })
[18:01:08.820]                 withCallingHandlers({
[18:01:08.820]                   {
[18:01:08.820]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.820]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.820]                       ...future.globals.maxSize)) {
[18:01:08.820]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.820]                       on.exit(options(oopts), add = TRUE)
[18:01:08.820]                     }
[18:01:08.820]                     {
[18:01:08.820]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.820]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.820]                         USE.NAMES = FALSE)
[18:01:08.820]                       do.call(mapply, args = args)
[18:01:08.820]                     }
[18:01:08.820]                   }
[18:01:08.820]                 }, immediateCondition = function(cond) {
[18:01:08.820]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.820]                   sendCondition(cond)
[18:01:08.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.820]                   {
[18:01:08.820]                     inherits <- base::inherits
[18:01:08.820]                     invokeRestart <- base::invokeRestart
[18:01:08.820]                     is.null <- base::is.null
[18:01:08.820]                     muffled <- FALSE
[18:01:08.820]                     if (inherits(cond, "message")) {
[18:01:08.820]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.820]                       if (muffled) 
[18:01:08.820]                         invokeRestart("muffleMessage")
[18:01:08.820]                     }
[18:01:08.820]                     else if (inherits(cond, "warning")) {
[18:01:08.820]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.820]                       if (muffled) 
[18:01:08.820]                         invokeRestart("muffleWarning")
[18:01:08.820]                     }
[18:01:08.820]                     else if (inherits(cond, "condition")) {
[18:01:08.820]                       if (!is.null(pattern)) {
[18:01:08.820]                         computeRestarts <- base::computeRestarts
[18:01:08.820]                         grepl <- base::grepl
[18:01:08.820]                         restarts <- computeRestarts(cond)
[18:01:08.820]                         for (restart in restarts) {
[18:01:08.820]                           name <- restart$name
[18:01:08.820]                           if (is.null(name)) 
[18:01:08.820]                             next
[18:01:08.820]                           if (!grepl(pattern, name)) 
[18:01:08.820]                             next
[18:01:08.820]                           invokeRestart(restart)
[18:01:08.820]                           muffled <- TRUE
[18:01:08.820]                           break
[18:01:08.820]                         }
[18:01:08.820]                       }
[18:01:08.820]                     }
[18:01:08.820]                     invisible(muffled)
[18:01:08.820]                   }
[18:01:08.820]                   muffleCondition(cond)
[18:01:08.820]                 })
[18:01:08.820]             }))
[18:01:08.820]             future::FutureResult(value = ...future.value$value, 
[18:01:08.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.820]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.820]                     ...future.globalenv.names))
[18:01:08.820]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.820]         }, condition = base::local({
[18:01:08.820]             c <- base::c
[18:01:08.820]             inherits <- base::inherits
[18:01:08.820]             invokeRestart <- base::invokeRestart
[18:01:08.820]             length <- base::length
[18:01:08.820]             list <- base::list
[18:01:08.820]             seq.int <- base::seq.int
[18:01:08.820]             signalCondition <- base::signalCondition
[18:01:08.820]             sys.calls <- base::sys.calls
[18:01:08.820]             `[[` <- base::`[[`
[18:01:08.820]             `+` <- base::`+`
[18:01:08.820]             `<<-` <- base::`<<-`
[18:01:08.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.820]                   3L)]
[18:01:08.820]             }
[18:01:08.820]             function(cond) {
[18:01:08.820]                 is_error <- inherits(cond, "error")
[18:01:08.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.820]                   NULL)
[18:01:08.820]                 if (is_error) {
[18:01:08.820]                   sessionInformation <- function() {
[18:01:08.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.820]                       search = base::search(), system = base::Sys.info())
[18:01:08.820]                   }
[18:01:08.820]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.820]                     cond$call), session = sessionInformation(), 
[18:01:08.820]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.820]                   signalCondition(cond)
[18:01:08.820]                 }
[18:01:08.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.820]                 "immediateCondition"))) {
[18:01:08.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.820]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.820]                   if (TRUE && !signal) {
[18:01:08.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.820]                     {
[18:01:08.820]                       inherits <- base::inherits
[18:01:08.820]                       invokeRestart <- base::invokeRestart
[18:01:08.820]                       is.null <- base::is.null
[18:01:08.820]                       muffled <- FALSE
[18:01:08.820]                       if (inherits(cond, "message")) {
[18:01:08.820]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.820]                         if (muffled) 
[18:01:08.820]                           invokeRestart("muffleMessage")
[18:01:08.820]                       }
[18:01:08.820]                       else if (inherits(cond, "warning")) {
[18:01:08.820]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.820]                         if (muffled) 
[18:01:08.820]                           invokeRestart("muffleWarning")
[18:01:08.820]                       }
[18:01:08.820]                       else if (inherits(cond, "condition")) {
[18:01:08.820]                         if (!is.null(pattern)) {
[18:01:08.820]                           computeRestarts <- base::computeRestarts
[18:01:08.820]                           grepl <- base::grepl
[18:01:08.820]                           restarts <- computeRestarts(cond)
[18:01:08.820]                           for (restart in restarts) {
[18:01:08.820]                             name <- restart$name
[18:01:08.820]                             if (is.null(name)) 
[18:01:08.820]                               next
[18:01:08.820]                             if (!grepl(pattern, name)) 
[18:01:08.820]                               next
[18:01:08.820]                             invokeRestart(restart)
[18:01:08.820]                             muffled <- TRUE
[18:01:08.820]                             break
[18:01:08.820]                           }
[18:01:08.820]                         }
[18:01:08.820]                       }
[18:01:08.820]                       invisible(muffled)
[18:01:08.820]                     }
[18:01:08.820]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.820]                   }
[18:01:08.820]                 }
[18:01:08.820]                 else {
[18:01:08.820]                   if (TRUE) {
[18:01:08.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.820]                     {
[18:01:08.820]                       inherits <- base::inherits
[18:01:08.820]                       invokeRestart <- base::invokeRestart
[18:01:08.820]                       is.null <- base::is.null
[18:01:08.820]                       muffled <- FALSE
[18:01:08.820]                       if (inherits(cond, "message")) {
[18:01:08.820]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.820]                         if (muffled) 
[18:01:08.820]                           invokeRestart("muffleMessage")
[18:01:08.820]                       }
[18:01:08.820]                       else if (inherits(cond, "warning")) {
[18:01:08.820]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.820]                         if (muffled) 
[18:01:08.820]                           invokeRestart("muffleWarning")
[18:01:08.820]                       }
[18:01:08.820]                       else if (inherits(cond, "condition")) {
[18:01:08.820]                         if (!is.null(pattern)) {
[18:01:08.820]                           computeRestarts <- base::computeRestarts
[18:01:08.820]                           grepl <- base::grepl
[18:01:08.820]                           restarts <- computeRestarts(cond)
[18:01:08.820]                           for (restart in restarts) {
[18:01:08.820]                             name <- restart$name
[18:01:08.820]                             if (is.null(name)) 
[18:01:08.820]                               next
[18:01:08.820]                             if (!grepl(pattern, name)) 
[18:01:08.820]                               next
[18:01:08.820]                             invokeRestart(restart)
[18:01:08.820]                             muffled <- TRUE
[18:01:08.820]                             break
[18:01:08.820]                           }
[18:01:08.820]                         }
[18:01:08.820]                       }
[18:01:08.820]                       invisible(muffled)
[18:01:08.820]                     }
[18:01:08.820]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.820]                   }
[18:01:08.820]                 }
[18:01:08.820]             }
[18:01:08.820]         }))
[18:01:08.820]     }, error = function(ex) {
[18:01:08.820]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.820]                 ...future.rng), started = ...future.startTime, 
[18:01:08.820]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.820]             version = "1.8"), class = "FutureResult")
[18:01:08.820]     }, finally = {
[18:01:08.820]         if (!identical(...future.workdir, getwd())) 
[18:01:08.820]             setwd(...future.workdir)
[18:01:08.820]         {
[18:01:08.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.820]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.820]             }
[18:01:08.820]             base::options(...future.oldOptions)
[18:01:08.820]             if (.Platform$OS.type == "windows") {
[18:01:08.820]                 old_names <- names(...future.oldEnvVars)
[18:01:08.820]                 envs <- base::Sys.getenv()
[18:01:08.820]                 names <- names(envs)
[18:01:08.820]                 common <- intersect(names, old_names)
[18:01:08.820]                 added <- setdiff(names, old_names)
[18:01:08.820]                 removed <- setdiff(old_names, names)
[18:01:08.820]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.820]                   envs[common]]
[18:01:08.820]                 NAMES <- toupper(changed)
[18:01:08.820]                 args <- list()
[18:01:08.820]                 for (kk in seq_along(NAMES)) {
[18:01:08.820]                   name <- changed[[kk]]
[18:01:08.820]                   NAME <- NAMES[[kk]]
[18:01:08.820]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.820]                     next
[18:01:08.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.820]                 }
[18:01:08.820]                 NAMES <- toupper(added)
[18:01:08.820]                 for (kk in seq_along(NAMES)) {
[18:01:08.820]                   name <- added[[kk]]
[18:01:08.820]                   NAME <- NAMES[[kk]]
[18:01:08.820]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.820]                     next
[18:01:08.820]                   args[[name]] <- ""
[18:01:08.820]                 }
[18:01:08.820]                 NAMES <- toupper(removed)
[18:01:08.820]                 for (kk in seq_along(NAMES)) {
[18:01:08.820]                   name <- removed[[kk]]
[18:01:08.820]                   NAME <- NAMES[[kk]]
[18:01:08.820]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.820]                     next
[18:01:08.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.820]                 }
[18:01:08.820]                 if (length(args) > 0) 
[18:01:08.820]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.820]             }
[18:01:08.820]             else {
[18:01:08.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.820]             }
[18:01:08.820]             {
[18:01:08.820]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.820]                   0L) {
[18:01:08.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.820]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.820]                   base::options(opts)
[18:01:08.820]                 }
[18:01:08.820]                 {
[18:01:08.820]                   {
[18:01:08.820]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.820]                     NULL
[18:01:08.820]                   }
[18:01:08.820]                   options(future.plan = NULL)
[18:01:08.820]                   if (is.na(NA_character_)) 
[18:01:08.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.820]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.820]                     .init = FALSE)
[18:01:08.820]                 }
[18:01:08.820]             }
[18:01:08.820]         }
[18:01:08.820]     })
[18:01:08.820]     if (TRUE) {
[18:01:08.820]         base::sink(type = "output", split = FALSE)
[18:01:08.820]         if (TRUE) {
[18:01:08.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.820]         }
[18:01:08.820]         else {
[18:01:08.820]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.820]         }
[18:01:08.820]         base::close(...future.stdout)
[18:01:08.820]         ...future.stdout <- NULL
[18:01:08.820]     }
[18:01:08.820]     ...future.result$conditions <- ...future.conditions
[18:01:08.820]     ...future.result$finished <- base::Sys.time()
[18:01:08.820]     ...future.result
[18:01:08.820] }
[18:01:08.825] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[18:01:08.825] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[18:01:08.826] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[18:01:08.826] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[18:01:08.827] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[18:01:08.828] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:01:08.828] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:01:08.829] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:08.830] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.830] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:08.831] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:08.831] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[18:01:08.832] MultisessionFuture started
[18:01:08.832] - Launch lazy future ... done
[18:01:08.832] run() for ‘MultisessionFuture’ ... done
[18:01:08.833] Created future:
[18:01:08.833] MultisessionFuture:
[18:01:08.833] Label: ‘future_.mapply-1’
[18:01:08.833] Expression:
[18:01:08.833] {
[18:01:08.833]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.833]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.833]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.833]         on.exit(options(oopts), add = TRUE)
[18:01:08.833]     }
[18:01:08.833]     {
[18:01:08.833]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.833]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.833]         do.call(mapply, args = args)
[18:01:08.833]     }
[18:01:08.833] }
[18:01:08.833] Lazy evaluation: FALSE
[18:01:08.833] Asynchronous evaluation: TRUE
[18:01:08.833] Local evaluation: TRUE
[18:01:08.833] Environment: R_GlobalEnv
[18:01:08.833] Capture standard output: TRUE
[18:01:08.833] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.833] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.833] Packages: <none>
[18:01:08.833] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.833] Resolved: FALSE
[18:01:08.833] Value: <not collected>
[18:01:08.833] Conditions captured: <none>
[18:01:08.833] Early signaling: FALSE
[18:01:08.833] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.833] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.845] Chunk #1 of 2 ... DONE
[18:01:08.846] Chunk #2 of 2 ...
[18:01:08.846]  - Finding globals in '...' for chunk #2 ...
[18:01:08.846] getGlobalsAndPackages() ...
[18:01:08.846] Searching for globals...
[18:01:08.847] 
[18:01:08.847] Searching for globals ... DONE
[18:01:08.847] - globals: [0] <none>
[18:01:08.847] getGlobalsAndPackages() ... DONE
[18:01:08.848]    + additional globals found: [n=0] 
[18:01:08.848]    + additional namespaces needed: [n=0] 
[18:01:08.848]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:08.848]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.848]  - seeds: <none>
[18:01:08.849]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.849] getGlobalsAndPackages() ...
[18:01:08.849] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.849] Resolving globals: FALSE
[18:01:08.850] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[18:01:08.851] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[18:01:08.851] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.851] 
[18:01:08.852] getGlobalsAndPackages() ... DONE
[18:01:08.852] run() for ‘Future’ ...
[18:01:08.852] - state: ‘created’
[18:01:08.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:08.875] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:08.875]   - Field: ‘node’
[18:01:08.876]   - Field: ‘label’
[18:01:08.876]   - Field: ‘local’
[18:01:08.876]   - Field: ‘owner’
[18:01:08.876]   - Field: ‘envir’
[18:01:08.876]   - Field: ‘workers’
[18:01:08.877]   - Field: ‘packages’
[18:01:08.877]   - Field: ‘gc’
[18:01:08.877]   - Field: ‘conditions’
[18:01:08.877]   - Field: ‘persistent’
[18:01:08.877]   - Field: ‘expr’
[18:01:08.878]   - Field: ‘uuid’
[18:01:08.878]   - Field: ‘seed’
[18:01:08.878]   - Field: ‘version’
[18:01:08.878]   - Field: ‘result’
[18:01:08.878]   - Field: ‘asynchronous’
[18:01:08.879]   - Field: ‘calls’
[18:01:08.879]   - Field: ‘globals’
[18:01:08.879]   - Field: ‘stdout’
[18:01:08.879]   - Field: ‘earlySignal’
[18:01:08.879]   - Field: ‘lazy’
[18:01:08.880]   - Field: ‘state’
[18:01:08.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:08.880] - Launch lazy future ...
[18:01:08.880] Packages needed by the future expression (n = 0): <none>
[18:01:08.881] Packages needed by future strategies (n = 0): <none>
[18:01:08.881] {
[18:01:08.881]     {
[18:01:08.881]         {
[18:01:08.881]             ...future.startTime <- base::Sys.time()
[18:01:08.881]             {
[18:01:08.881]                 {
[18:01:08.881]                   {
[18:01:08.881]                     {
[18:01:08.881]                       base::local({
[18:01:08.881]                         has_future <- base::requireNamespace("future", 
[18:01:08.881]                           quietly = TRUE)
[18:01:08.881]                         if (has_future) {
[18:01:08.881]                           ns <- base::getNamespace("future")
[18:01:08.881]                           version <- ns[[".package"]][["version"]]
[18:01:08.881]                           if (is.null(version)) 
[18:01:08.881]                             version <- utils::packageVersion("future")
[18:01:08.881]                         }
[18:01:08.881]                         else {
[18:01:08.881]                           version <- NULL
[18:01:08.881]                         }
[18:01:08.881]                         if (!has_future || version < "1.8.0") {
[18:01:08.881]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:08.881]                             "", base::R.version$version.string), 
[18:01:08.881]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:08.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:08.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:08.881]                               "release", "version")], collapse = " "), 
[18:01:08.881]                             hostname = base::Sys.info()[["nodename"]])
[18:01:08.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:08.881]                             info)
[18:01:08.881]                           info <- base::paste(info, collapse = "; ")
[18:01:08.881]                           if (!has_future) {
[18:01:08.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:08.881]                               info)
[18:01:08.881]                           }
[18:01:08.881]                           else {
[18:01:08.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:08.881]                               info, version)
[18:01:08.881]                           }
[18:01:08.881]                           base::stop(msg)
[18:01:08.881]                         }
[18:01:08.881]                       })
[18:01:08.881]                     }
[18:01:08.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:08.881]                     base::options(mc.cores = 1L)
[18:01:08.881]                   }
[18:01:08.881]                   ...future.strategy.old <- future::plan("list")
[18:01:08.881]                   options(future.plan = NULL)
[18:01:08.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:08.881]                 }
[18:01:08.881]                 ...future.workdir <- getwd()
[18:01:08.881]             }
[18:01:08.881]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:08.881]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:08.881]         }
[18:01:08.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:08.881]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:08.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:08.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:08.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:08.881]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:08.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:08.881]             base::names(...future.oldOptions))
[18:01:08.881]     }
[18:01:08.881]     if (FALSE) {
[18:01:08.881]     }
[18:01:08.881]     else {
[18:01:08.881]         if (TRUE) {
[18:01:08.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:08.881]                 open = "w")
[18:01:08.881]         }
[18:01:08.881]         else {
[18:01:08.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:08.881]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:08.881]         }
[18:01:08.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:08.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:08.881]             base::sink(type = "output", split = FALSE)
[18:01:08.881]             base::close(...future.stdout)
[18:01:08.881]         }, add = TRUE)
[18:01:08.881]     }
[18:01:08.881]     ...future.frame <- base::sys.nframe()
[18:01:08.881]     ...future.conditions <- base::list()
[18:01:08.881]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:08.881]     if (FALSE) {
[18:01:08.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:08.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:08.881]     }
[18:01:08.881]     ...future.result <- base::tryCatch({
[18:01:08.881]         base::withCallingHandlers({
[18:01:08.881]             ...future.value <- base::withVisible(base::local({
[18:01:08.881]                 ...future.makeSendCondition <- base::local({
[18:01:08.881]                   sendCondition <- NULL
[18:01:08.881]                   function(frame = 1L) {
[18:01:08.881]                     if (is.function(sendCondition)) 
[18:01:08.881]                       return(sendCondition)
[18:01:08.881]                     ns <- getNamespace("parallel")
[18:01:08.881]                     if (exists("sendData", mode = "function", 
[18:01:08.881]                       envir = ns)) {
[18:01:08.881]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:08.881]                         envir = ns)
[18:01:08.881]                       envir <- sys.frame(frame)
[18:01:08.881]                       master <- NULL
[18:01:08.881]                       while (!identical(envir, .GlobalEnv) && 
[18:01:08.881]                         !identical(envir, emptyenv())) {
[18:01:08.881]                         if (exists("master", mode = "list", envir = envir, 
[18:01:08.881]                           inherits = FALSE)) {
[18:01:08.881]                           master <- get("master", mode = "list", 
[18:01:08.881]                             envir = envir, inherits = FALSE)
[18:01:08.881]                           if (inherits(master, c("SOCKnode", 
[18:01:08.881]                             "SOCK0node"))) {
[18:01:08.881]                             sendCondition <<- function(cond) {
[18:01:08.881]                               data <- list(type = "VALUE", value = cond, 
[18:01:08.881]                                 success = TRUE)
[18:01:08.881]                               parallel_sendData(master, data)
[18:01:08.881]                             }
[18:01:08.881]                             return(sendCondition)
[18:01:08.881]                           }
[18:01:08.881]                         }
[18:01:08.881]                         frame <- frame + 1L
[18:01:08.881]                         envir <- sys.frame(frame)
[18:01:08.881]                       }
[18:01:08.881]                     }
[18:01:08.881]                     sendCondition <<- function(cond) NULL
[18:01:08.881]                   }
[18:01:08.881]                 })
[18:01:08.881]                 withCallingHandlers({
[18:01:08.881]                   {
[18:01:08.881]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.881]                     if (!identical(...future.globals.maxSize.org, 
[18:01:08.881]                       ...future.globals.maxSize)) {
[18:01:08.881]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.881]                       on.exit(options(oopts), add = TRUE)
[18:01:08.881]                     }
[18:01:08.881]                     {
[18:01:08.881]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.881]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:08.881]                         USE.NAMES = FALSE)
[18:01:08.881]                       do.call(mapply, args = args)
[18:01:08.881]                     }
[18:01:08.881]                   }
[18:01:08.881]                 }, immediateCondition = function(cond) {
[18:01:08.881]                   sendCondition <- ...future.makeSendCondition()
[18:01:08.881]                   sendCondition(cond)
[18:01:08.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.881]                   {
[18:01:08.881]                     inherits <- base::inherits
[18:01:08.881]                     invokeRestart <- base::invokeRestart
[18:01:08.881]                     is.null <- base::is.null
[18:01:08.881]                     muffled <- FALSE
[18:01:08.881]                     if (inherits(cond, "message")) {
[18:01:08.881]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:08.881]                       if (muffled) 
[18:01:08.881]                         invokeRestart("muffleMessage")
[18:01:08.881]                     }
[18:01:08.881]                     else if (inherits(cond, "warning")) {
[18:01:08.881]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:08.881]                       if (muffled) 
[18:01:08.881]                         invokeRestart("muffleWarning")
[18:01:08.881]                     }
[18:01:08.881]                     else if (inherits(cond, "condition")) {
[18:01:08.881]                       if (!is.null(pattern)) {
[18:01:08.881]                         computeRestarts <- base::computeRestarts
[18:01:08.881]                         grepl <- base::grepl
[18:01:08.881]                         restarts <- computeRestarts(cond)
[18:01:08.881]                         for (restart in restarts) {
[18:01:08.881]                           name <- restart$name
[18:01:08.881]                           if (is.null(name)) 
[18:01:08.881]                             next
[18:01:08.881]                           if (!grepl(pattern, name)) 
[18:01:08.881]                             next
[18:01:08.881]                           invokeRestart(restart)
[18:01:08.881]                           muffled <- TRUE
[18:01:08.881]                           break
[18:01:08.881]                         }
[18:01:08.881]                       }
[18:01:08.881]                     }
[18:01:08.881]                     invisible(muffled)
[18:01:08.881]                   }
[18:01:08.881]                   muffleCondition(cond)
[18:01:08.881]                 })
[18:01:08.881]             }))
[18:01:08.881]             future::FutureResult(value = ...future.value$value, 
[18:01:08.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.881]                   ...future.rng), globalenv = if (FALSE) 
[18:01:08.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:08.881]                     ...future.globalenv.names))
[18:01:08.881]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:08.881]         }, condition = base::local({
[18:01:08.881]             c <- base::c
[18:01:08.881]             inherits <- base::inherits
[18:01:08.881]             invokeRestart <- base::invokeRestart
[18:01:08.881]             length <- base::length
[18:01:08.881]             list <- base::list
[18:01:08.881]             seq.int <- base::seq.int
[18:01:08.881]             signalCondition <- base::signalCondition
[18:01:08.881]             sys.calls <- base::sys.calls
[18:01:08.881]             `[[` <- base::`[[`
[18:01:08.881]             `+` <- base::`+`
[18:01:08.881]             `<<-` <- base::`<<-`
[18:01:08.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:08.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:08.881]                   3L)]
[18:01:08.881]             }
[18:01:08.881]             function(cond) {
[18:01:08.881]                 is_error <- inherits(cond, "error")
[18:01:08.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:08.881]                   NULL)
[18:01:08.881]                 if (is_error) {
[18:01:08.881]                   sessionInformation <- function() {
[18:01:08.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:08.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:08.881]                       search = base::search(), system = base::Sys.info())
[18:01:08.881]                   }
[18:01:08.881]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:08.881]                     cond$call), session = sessionInformation(), 
[18:01:08.881]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:08.881]                   signalCondition(cond)
[18:01:08.881]                 }
[18:01:08.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:08.881]                 "immediateCondition"))) {
[18:01:08.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:08.881]                   ...future.conditions[[length(...future.conditions) + 
[18:01:08.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:08.881]                   if (TRUE && !signal) {
[18:01:08.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.881]                     {
[18:01:08.881]                       inherits <- base::inherits
[18:01:08.881]                       invokeRestart <- base::invokeRestart
[18:01:08.881]                       is.null <- base::is.null
[18:01:08.881]                       muffled <- FALSE
[18:01:08.881]                       if (inherits(cond, "message")) {
[18:01:08.881]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.881]                         if (muffled) 
[18:01:08.881]                           invokeRestart("muffleMessage")
[18:01:08.881]                       }
[18:01:08.881]                       else if (inherits(cond, "warning")) {
[18:01:08.881]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.881]                         if (muffled) 
[18:01:08.881]                           invokeRestart("muffleWarning")
[18:01:08.881]                       }
[18:01:08.881]                       else if (inherits(cond, "condition")) {
[18:01:08.881]                         if (!is.null(pattern)) {
[18:01:08.881]                           computeRestarts <- base::computeRestarts
[18:01:08.881]                           grepl <- base::grepl
[18:01:08.881]                           restarts <- computeRestarts(cond)
[18:01:08.881]                           for (restart in restarts) {
[18:01:08.881]                             name <- restart$name
[18:01:08.881]                             if (is.null(name)) 
[18:01:08.881]                               next
[18:01:08.881]                             if (!grepl(pattern, name)) 
[18:01:08.881]                               next
[18:01:08.881]                             invokeRestart(restart)
[18:01:08.881]                             muffled <- TRUE
[18:01:08.881]                             break
[18:01:08.881]                           }
[18:01:08.881]                         }
[18:01:08.881]                       }
[18:01:08.881]                       invisible(muffled)
[18:01:08.881]                     }
[18:01:08.881]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.881]                   }
[18:01:08.881]                 }
[18:01:08.881]                 else {
[18:01:08.881]                   if (TRUE) {
[18:01:08.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:08.881]                     {
[18:01:08.881]                       inherits <- base::inherits
[18:01:08.881]                       invokeRestart <- base::invokeRestart
[18:01:08.881]                       is.null <- base::is.null
[18:01:08.881]                       muffled <- FALSE
[18:01:08.881]                       if (inherits(cond, "message")) {
[18:01:08.881]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:08.881]                         if (muffled) 
[18:01:08.881]                           invokeRestart("muffleMessage")
[18:01:08.881]                       }
[18:01:08.881]                       else if (inherits(cond, "warning")) {
[18:01:08.881]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:08.881]                         if (muffled) 
[18:01:08.881]                           invokeRestart("muffleWarning")
[18:01:08.881]                       }
[18:01:08.881]                       else if (inherits(cond, "condition")) {
[18:01:08.881]                         if (!is.null(pattern)) {
[18:01:08.881]                           computeRestarts <- base::computeRestarts
[18:01:08.881]                           grepl <- base::grepl
[18:01:08.881]                           restarts <- computeRestarts(cond)
[18:01:08.881]                           for (restart in restarts) {
[18:01:08.881]                             name <- restart$name
[18:01:08.881]                             if (is.null(name)) 
[18:01:08.881]                               next
[18:01:08.881]                             if (!grepl(pattern, name)) 
[18:01:08.881]                               next
[18:01:08.881]                             invokeRestart(restart)
[18:01:08.881]                             muffled <- TRUE
[18:01:08.881]                             break
[18:01:08.881]                           }
[18:01:08.881]                         }
[18:01:08.881]                       }
[18:01:08.881]                       invisible(muffled)
[18:01:08.881]                     }
[18:01:08.881]                     muffleCondition(cond, pattern = "^muffle")
[18:01:08.881]                   }
[18:01:08.881]                 }
[18:01:08.881]             }
[18:01:08.881]         }))
[18:01:08.881]     }, error = function(ex) {
[18:01:08.881]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:08.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:08.881]                 ...future.rng), started = ...future.startTime, 
[18:01:08.881]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:08.881]             version = "1.8"), class = "FutureResult")
[18:01:08.881]     }, finally = {
[18:01:08.881]         if (!identical(...future.workdir, getwd())) 
[18:01:08.881]             setwd(...future.workdir)
[18:01:08.881]         {
[18:01:08.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:08.881]                 ...future.oldOptions$nwarnings <- NULL
[18:01:08.881]             }
[18:01:08.881]             base::options(...future.oldOptions)
[18:01:08.881]             if (.Platform$OS.type == "windows") {
[18:01:08.881]                 old_names <- names(...future.oldEnvVars)
[18:01:08.881]                 envs <- base::Sys.getenv()
[18:01:08.881]                 names <- names(envs)
[18:01:08.881]                 common <- intersect(names, old_names)
[18:01:08.881]                 added <- setdiff(names, old_names)
[18:01:08.881]                 removed <- setdiff(old_names, names)
[18:01:08.881]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:08.881]                   envs[common]]
[18:01:08.881]                 NAMES <- toupper(changed)
[18:01:08.881]                 args <- list()
[18:01:08.881]                 for (kk in seq_along(NAMES)) {
[18:01:08.881]                   name <- changed[[kk]]
[18:01:08.881]                   NAME <- NAMES[[kk]]
[18:01:08.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.881]                     next
[18:01:08.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.881]                 }
[18:01:08.881]                 NAMES <- toupper(added)
[18:01:08.881]                 for (kk in seq_along(NAMES)) {
[18:01:08.881]                   name <- added[[kk]]
[18:01:08.881]                   NAME <- NAMES[[kk]]
[18:01:08.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.881]                     next
[18:01:08.881]                   args[[name]] <- ""
[18:01:08.881]                 }
[18:01:08.881]                 NAMES <- toupper(removed)
[18:01:08.881]                 for (kk in seq_along(NAMES)) {
[18:01:08.881]                   name <- removed[[kk]]
[18:01:08.881]                   NAME <- NAMES[[kk]]
[18:01:08.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:08.881]                     next
[18:01:08.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:08.881]                 }
[18:01:08.881]                 if (length(args) > 0) 
[18:01:08.881]                   base::do.call(base::Sys.setenv, args = args)
[18:01:08.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:08.881]             }
[18:01:08.881]             else {
[18:01:08.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:08.881]             }
[18:01:08.881]             {
[18:01:08.881]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:08.881]                   0L) {
[18:01:08.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:08.881]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:08.881]                   base::options(opts)
[18:01:08.881]                 }
[18:01:08.881]                 {
[18:01:08.881]                   {
[18:01:08.881]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:08.881]                     NULL
[18:01:08.881]                   }
[18:01:08.881]                   options(future.plan = NULL)
[18:01:08.881]                   if (is.na(NA_character_)) 
[18:01:08.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:08.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:08.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:08.881]                     .init = FALSE)
[18:01:08.881]                 }
[18:01:08.881]             }
[18:01:08.881]         }
[18:01:08.881]     })
[18:01:08.881]     if (TRUE) {
[18:01:08.881]         base::sink(type = "output", split = FALSE)
[18:01:08.881]         if (TRUE) {
[18:01:08.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:08.881]         }
[18:01:08.881]         else {
[18:01:08.881]             ...future.result["stdout"] <- base::list(NULL)
[18:01:08.881]         }
[18:01:08.881]         base::close(...future.stdout)
[18:01:08.881]         ...future.stdout <- NULL
[18:01:08.881]     }
[18:01:08.881]     ...future.result$conditions <- ...future.conditions
[18:01:08.881]     ...future.result$finished <- base::Sys.time()
[18:01:08.881]     ...future.result
[18:01:08.881] }
[18:01:08.887] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[18:01:08.887] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[18:01:08.888] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[18:01:08.888] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[18:01:08.889] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[18:01:08.889] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:01:08.890] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:01:08.890] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:08.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:08.892] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:08.892] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[18:01:08.893] MultisessionFuture started
[18:01:08.894] - Launch lazy future ... done
[18:01:08.894] run() for ‘MultisessionFuture’ ... done
[18:01:08.894] Created future:
[18:01:08.894] MultisessionFuture:
[18:01:08.894] Label: ‘future_.mapply-2’
[18:01:08.894] Expression:
[18:01:08.894] {
[18:01:08.894]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:08.894]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:08.894]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:08.894]         on.exit(options(oopts), add = TRUE)
[18:01:08.894]     }
[18:01:08.894]     {
[18:01:08.894]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:08.894]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:08.894]         do.call(mapply, args = args)
[18:01:08.894]     }
[18:01:08.894] }
[18:01:08.894] Lazy evaluation: FALSE
[18:01:08.894] Asynchronous evaluation: TRUE
[18:01:08.894] Local evaluation: TRUE
[18:01:08.894] Environment: R_GlobalEnv
[18:01:08.894] Capture standard output: TRUE
[18:01:08.894] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:08.894] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:08.894] Packages: <none>
[18:01:08.894] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:08.894] Resolved: FALSE
[18:01:08.894] Value: <not collected>
[18:01:08.894] Conditions captured: <none>
[18:01:08.894] Early signaling: FALSE
[18:01:08.894] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:08.894] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:08.907] Chunk #2 of 2 ... DONE
[18:01:08.907] Launching 2 futures (chunks) ... DONE
[18:01:08.907] Resolving 2 futures (chunks) ...
[18:01:08.908] resolve() on list ...
[18:01:08.908]  recursive: 0
[18:01:08.908]  length: 2
[18:01:08.908] 
[18:01:08.909] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.909] - Validating connection of MultisessionFuture
[18:01:08.910] - received message: FutureResult
[18:01:08.910] - Received FutureResult
[18:01:08.910] - Erased future from FutureRegistry
[18:01:08.910] result() for ClusterFuture ...
[18:01:08.910] - result already collected: FutureResult
[18:01:08.911] result() for ClusterFuture ... done
[18:01:08.911] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.911] Future #1
[18:01:08.911] result() for ClusterFuture ...
[18:01:08.911] - result already collected: FutureResult
[18:01:08.912] result() for ClusterFuture ... done
[18:01:08.912] result() for ClusterFuture ...
[18:01:08.912] - result already collected: FutureResult
[18:01:08.912] result() for ClusterFuture ... done
[18:01:08.912] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:08.912] - nx: 2
[18:01:08.913] - relay: TRUE
[18:01:08.913] - stdout: TRUE
[18:01:08.913] - signal: TRUE
[18:01:08.913] - resignal: FALSE
[18:01:08.913] - force: TRUE
[18:01:08.913] - relayed: [n=2] FALSE, FALSE
[18:01:08.914] - queued futures: [n=2] FALSE, FALSE
[18:01:08.914]  - until=1
[18:01:08.914]  - relaying element #1
[18:01:08.914] result() for ClusterFuture ...
[18:01:08.914] - result already collected: FutureResult
[18:01:08.915] result() for ClusterFuture ... done
[18:01:08.915] result() for ClusterFuture ...
[18:01:08.915] - result already collected: FutureResult
[18:01:08.915] result() for ClusterFuture ... done
[18:01:08.915] result() for ClusterFuture ...
[18:01:08.916] - result already collected: FutureResult
[18:01:08.916] result() for ClusterFuture ... done
[18:01:08.916] result() for ClusterFuture ...
[18:01:08.916] - result already collected: FutureResult
[18:01:08.916] result() for ClusterFuture ... done
[18:01:08.916] - relayed: [n=2] TRUE, FALSE
[18:01:08.917] - queued futures: [n=2] TRUE, FALSE
[18:01:08.917] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:08.917]  length: 1 (resolved future 1)
[18:01:08.939] receiveMessageFromWorker() for ClusterFuture ...
[18:01:08.939] - Validating connection of MultisessionFuture
[18:01:08.940] - received message: FutureResult
[18:01:08.940] - Received FutureResult
[18:01:08.940] - Erased future from FutureRegistry
[18:01:08.941] result() for ClusterFuture ...
[18:01:08.941] - result already collected: FutureResult
[18:01:08.941] result() for ClusterFuture ... done
[18:01:08.941] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:08.941] Future #2
[18:01:08.941] result() for ClusterFuture ...
[18:01:08.942] - result already collected: FutureResult
[18:01:08.942] result() for ClusterFuture ... done
[18:01:08.942] result() for ClusterFuture ...
[18:01:08.942] - result already collected: FutureResult
[18:01:08.942] result() for ClusterFuture ... done
[18:01:08.943] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:08.943] - nx: 2
[18:01:08.943] - relay: TRUE
[18:01:08.943] - stdout: TRUE
[18:01:08.943] - signal: TRUE
[18:01:08.944] - resignal: FALSE
[18:01:08.944] - force: TRUE
[18:01:08.944] - relayed: [n=2] TRUE, FALSE
[18:01:08.944] - queued futures: [n=2] TRUE, FALSE
[18:01:08.944]  - until=2
[18:01:08.944]  - relaying element #2
[18:01:08.945] result() for ClusterFuture ...
[18:01:08.945] - result already collected: FutureResult
[18:01:08.945] result() for ClusterFuture ... done
[18:01:08.945] result() for ClusterFuture ...
[18:01:08.945] - result already collected: FutureResult
[18:01:08.946] result() for ClusterFuture ... done
[18:01:08.946] result() for ClusterFuture ...
[18:01:08.946] - result already collected: FutureResult
[18:01:08.946] result() for ClusterFuture ... done
[18:01:08.946] result() for ClusterFuture ...
[18:01:08.947] - result already collected: FutureResult
[18:01:08.947] result() for ClusterFuture ... done
[18:01:08.947] - relayed: [n=2] TRUE, TRUE
[18:01:08.947] - queued futures: [n=2] TRUE, TRUE
[18:01:08.947] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:08.948]  length: 0 (resolved future 2)
[18:01:08.948] Relaying remaining futures
[18:01:08.948] signalConditionsASAP(NULL, pos=0) ...
[18:01:08.948] - nx: 2
[18:01:08.948] - relay: TRUE
[18:01:08.948] - stdout: TRUE
[18:01:08.949] - signal: TRUE
[18:01:08.949] - resignal: FALSE
[18:01:08.949] - force: TRUE
[18:01:08.949] - relayed: [n=2] TRUE, TRUE
[18:01:08.949] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:08.950] - relayed: [n=2] TRUE, TRUE
[18:01:08.950] - queued futures: [n=2] TRUE, TRUE
[18:01:08.950] signalConditionsASAP(NULL, pos=0) ... done
[18:01:08.950] resolve() on list ... DONE
[18:01:08.950] result() for ClusterFuture ...
[18:01:08.951] - result already collected: FutureResult
[18:01:08.951] result() for ClusterFuture ... done
[18:01:08.951] result() for ClusterFuture ...
[18:01:08.951] - result already collected: FutureResult
[18:01:08.951] result() for ClusterFuture ... done
[18:01:08.952] result() for ClusterFuture ...
[18:01:08.952] - result already collected: FutureResult
[18:01:08.952] result() for ClusterFuture ... done
[18:01:08.952] result() for ClusterFuture ...
[18:01:08.952] - result already collected: FutureResult
[18:01:08.952] result() for ClusterFuture ... done
[18:01:08.953]  - Number of value chunks collected: 2
[18:01:08.953] Resolving 2 futures (chunks) ... DONE
[18:01:08.953] Reducing values from 2 chunks ...
[18:01:08.953]  - Number of values collected after concatenation: 2
[18:01:08.953]  - Number of values expected: 2
[18:01:08.954] Reducing values from 2 chunks ... DONE
[18:01:08.954] future_mapply() ... DONE
- Recycle arguments to same length ...
[18:01:08.954] future_mapply() ...
[18:01:08.961] Number of chunks: 2
[18:01:08.961] getGlobalsAndPackagesXApply() ...
[18:01:08.961]  - future.globals: TRUE
[18:01:08.965] getGlobalsAndPackages() ...
[18:01:08.965] Searching for globals...
[18:01:08.966] - globals found: [1] ‘FUN’
[18:01:08.967] Searching for globals ... DONE
[18:01:08.967] Resolving globals: FALSE
[18:01:08.967] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:08.968] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:08.968] - globals: [1] ‘FUN’
[18:01:08.969] 
[18:01:08.969] getGlobalsAndPackages() ... DONE
[18:01:08.969]  - globals found/used: [n=1] ‘FUN’
[18:01:08.969]  - needed namespaces: [n=0] 
[18:01:08.969] Finding globals ... DONE
[18:01:08.970] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:08.970] List of 2
[18:01:08.970]  $ ...future.FUN:function (x, ...)  
[18:01:08.970]  $ MoreArgs     : NULL
[18:01:08.970]  - attr(*, "where")=List of 2
[18:01:08.970]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:08.970]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:08.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:08.970]  - attr(*, "resolved")= logi FALSE
[18:01:08.970]  - attr(*, "total_size")= num NA
[18:01:08.975] Packages to be attached in all futures: [n=0] 
[18:01:08.975] getGlobalsAndPackagesXApply() ... DONE
[18:01:08.976] Number of futures (= number of chunks): 2
[18:01:08.976] Launching 2 futures (chunks) ...
[18:01:08.976] Chunk #1 of 2 ...
[18:01:08.976]  - Finding globals in '...' for chunk #1 ...
[18:01:08.977] getGlobalsAndPackages() ...
[18:01:08.977] Searching for globals...
[18:01:08.977] 
[18:01:08.978] Searching for globals ... DONE
[18:01:08.978] - globals: [0] <none>
[18:01:08.978] getGlobalsAndPackages() ... DONE
[18:01:08.978]    + additional globals found: [n=0] 
[18:01:08.978]    + additional namespaces needed: [n=0] 
[18:01:08.979]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:08.979]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:08.979]  - seeds: <none>
[18:01:08.979]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.980] getGlobalsAndPackages() ...
[18:01:08.980] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.980] Resolving globals: FALSE
[18:01:08.981] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:08.982] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:08.982] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:08.983] 
[18:01:08.983] getGlobalsAndPackages() ... DONE
[18:01:08.983] run() for ‘Future’ ...
[18:01:08.984] - state: ‘created’
[18:01:08.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.007] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.008]   - Field: ‘node’
[18:01:09.008]   - Field: ‘label’
[18:01:09.008]   - Field: ‘local’
[18:01:09.008]   - Field: ‘owner’
[18:01:09.009]   - Field: ‘envir’
[18:01:09.009]   - Field: ‘workers’
[18:01:09.009]   - Field: ‘packages’
[18:01:09.009]   - Field: ‘gc’
[18:01:09.009]   - Field: ‘conditions’
[18:01:09.010]   - Field: ‘persistent’
[18:01:09.010]   - Field: ‘expr’
[18:01:09.010]   - Field: ‘uuid’
[18:01:09.010]   - Field: ‘seed’
[18:01:09.010]   - Field: ‘version’
[18:01:09.011]   - Field: ‘result’
[18:01:09.011]   - Field: ‘asynchronous’
[18:01:09.011]   - Field: ‘calls’
[18:01:09.011]   - Field: ‘globals’
[18:01:09.011]   - Field: ‘stdout’
[18:01:09.011]   - Field: ‘earlySignal’
[18:01:09.012]   - Field: ‘lazy’
[18:01:09.012]   - Field: ‘state’
[18:01:09.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.012] - Launch lazy future ...
[18:01:09.013] Packages needed by the future expression (n = 0): <none>
[18:01:09.013] Packages needed by future strategies (n = 0): <none>
[18:01:09.014] {
[18:01:09.014]     {
[18:01:09.014]         {
[18:01:09.014]             ...future.startTime <- base::Sys.time()
[18:01:09.014]             {
[18:01:09.014]                 {
[18:01:09.014]                   {
[18:01:09.014]                     {
[18:01:09.014]                       base::local({
[18:01:09.014]                         has_future <- base::requireNamespace("future", 
[18:01:09.014]                           quietly = TRUE)
[18:01:09.014]                         if (has_future) {
[18:01:09.014]                           ns <- base::getNamespace("future")
[18:01:09.014]                           version <- ns[[".package"]][["version"]]
[18:01:09.014]                           if (is.null(version)) 
[18:01:09.014]                             version <- utils::packageVersion("future")
[18:01:09.014]                         }
[18:01:09.014]                         else {
[18:01:09.014]                           version <- NULL
[18:01:09.014]                         }
[18:01:09.014]                         if (!has_future || version < "1.8.0") {
[18:01:09.014]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.014]                             "", base::R.version$version.string), 
[18:01:09.014]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:09.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:09.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.014]                               "release", "version")], collapse = " "), 
[18:01:09.014]                             hostname = base::Sys.info()[["nodename"]])
[18:01:09.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.014]                             info)
[18:01:09.014]                           info <- base::paste(info, collapse = "; ")
[18:01:09.014]                           if (!has_future) {
[18:01:09.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.014]                               info)
[18:01:09.014]                           }
[18:01:09.014]                           else {
[18:01:09.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.014]                               info, version)
[18:01:09.014]                           }
[18:01:09.014]                           base::stop(msg)
[18:01:09.014]                         }
[18:01:09.014]                       })
[18:01:09.014]                     }
[18:01:09.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.014]                     base::options(mc.cores = 1L)
[18:01:09.014]                   }
[18:01:09.014]                   ...future.strategy.old <- future::plan("list")
[18:01:09.014]                   options(future.plan = NULL)
[18:01:09.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.014]                 }
[18:01:09.014]                 ...future.workdir <- getwd()
[18:01:09.014]             }
[18:01:09.014]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.014]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.014]         }
[18:01:09.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.014]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.014]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.014]             base::names(...future.oldOptions))
[18:01:09.014]     }
[18:01:09.014]     if (FALSE) {
[18:01:09.014]     }
[18:01:09.014]     else {
[18:01:09.014]         if (TRUE) {
[18:01:09.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.014]                 open = "w")
[18:01:09.014]         }
[18:01:09.014]         else {
[18:01:09.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.014]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.014]         }
[18:01:09.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.014]             base::sink(type = "output", split = FALSE)
[18:01:09.014]             base::close(...future.stdout)
[18:01:09.014]         }, add = TRUE)
[18:01:09.014]     }
[18:01:09.014]     ...future.frame <- base::sys.nframe()
[18:01:09.014]     ...future.conditions <- base::list()
[18:01:09.014]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.014]     if (FALSE) {
[18:01:09.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.014]     }
[18:01:09.014]     ...future.result <- base::tryCatch({
[18:01:09.014]         base::withCallingHandlers({
[18:01:09.014]             ...future.value <- base::withVisible(base::local({
[18:01:09.014]                 ...future.makeSendCondition <- base::local({
[18:01:09.014]                   sendCondition <- NULL
[18:01:09.014]                   function(frame = 1L) {
[18:01:09.014]                     if (is.function(sendCondition)) 
[18:01:09.014]                       return(sendCondition)
[18:01:09.014]                     ns <- getNamespace("parallel")
[18:01:09.014]                     if (exists("sendData", mode = "function", 
[18:01:09.014]                       envir = ns)) {
[18:01:09.014]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.014]                         envir = ns)
[18:01:09.014]                       envir <- sys.frame(frame)
[18:01:09.014]                       master <- NULL
[18:01:09.014]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.014]                         !identical(envir, emptyenv())) {
[18:01:09.014]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.014]                           inherits = FALSE)) {
[18:01:09.014]                           master <- get("master", mode = "list", 
[18:01:09.014]                             envir = envir, inherits = FALSE)
[18:01:09.014]                           if (inherits(master, c("SOCKnode", 
[18:01:09.014]                             "SOCK0node"))) {
[18:01:09.014]                             sendCondition <<- function(cond) {
[18:01:09.014]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.014]                                 success = TRUE)
[18:01:09.014]                               parallel_sendData(master, data)
[18:01:09.014]                             }
[18:01:09.014]                             return(sendCondition)
[18:01:09.014]                           }
[18:01:09.014]                         }
[18:01:09.014]                         frame <- frame + 1L
[18:01:09.014]                         envir <- sys.frame(frame)
[18:01:09.014]                       }
[18:01:09.014]                     }
[18:01:09.014]                     sendCondition <<- function(cond) NULL
[18:01:09.014]                   }
[18:01:09.014]                 })
[18:01:09.014]                 withCallingHandlers({
[18:01:09.014]                   {
[18:01:09.014]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.014]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.014]                       ...future.globals.maxSize)) {
[18:01:09.014]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.014]                       on.exit(options(oopts), add = TRUE)
[18:01:09.014]                     }
[18:01:09.014]                     {
[18:01:09.014]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.014]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.014]                         USE.NAMES = FALSE)
[18:01:09.014]                       do.call(mapply, args = args)
[18:01:09.014]                     }
[18:01:09.014]                   }
[18:01:09.014]                 }, immediateCondition = function(cond) {
[18:01:09.014]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.014]                   sendCondition(cond)
[18:01:09.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.014]                   {
[18:01:09.014]                     inherits <- base::inherits
[18:01:09.014]                     invokeRestart <- base::invokeRestart
[18:01:09.014]                     is.null <- base::is.null
[18:01:09.014]                     muffled <- FALSE
[18:01:09.014]                     if (inherits(cond, "message")) {
[18:01:09.014]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.014]                       if (muffled) 
[18:01:09.014]                         invokeRestart("muffleMessage")
[18:01:09.014]                     }
[18:01:09.014]                     else if (inherits(cond, "warning")) {
[18:01:09.014]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.014]                       if (muffled) 
[18:01:09.014]                         invokeRestart("muffleWarning")
[18:01:09.014]                     }
[18:01:09.014]                     else if (inherits(cond, "condition")) {
[18:01:09.014]                       if (!is.null(pattern)) {
[18:01:09.014]                         computeRestarts <- base::computeRestarts
[18:01:09.014]                         grepl <- base::grepl
[18:01:09.014]                         restarts <- computeRestarts(cond)
[18:01:09.014]                         for (restart in restarts) {
[18:01:09.014]                           name <- restart$name
[18:01:09.014]                           if (is.null(name)) 
[18:01:09.014]                             next
[18:01:09.014]                           if (!grepl(pattern, name)) 
[18:01:09.014]                             next
[18:01:09.014]                           invokeRestart(restart)
[18:01:09.014]                           muffled <- TRUE
[18:01:09.014]                           break
[18:01:09.014]                         }
[18:01:09.014]                       }
[18:01:09.014]                     }
[18:01:09.014]                     invisible(muffled)
[18:01:09.014]                   }
[18:01:09.014]                   muffleCondition(cond)
[18:01:09.014]                 })
[18:01:09.014]             }))
[18:01:09.014]             future::FutureResult(value = ...future.value$value, 
[18:01:09.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.014]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.014]                     ...future.globalenv.names))
[18:01:09.014]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.014]         }, condition = base::local({
[18:01:09.014]             c <- base::c
[18:01:09.014]             inherits <- base::inherits
[18:01:09.014]             invokeRestart <- base::invokeRestart
[18:01:09.014]             length <- base::length
[18:01:09.014]             list <- base::list
[18:01:09.014]             seq.int <- base::seq.int
[18:01:09.014]             signalCondition <- base::signalCondition
[18:01:09.014]             sys.calls <- base::sys.calls
[18:01:09.014]             `[[` <- base::`[[`
[18:01:09.014]             `+` <- base::`+`
[18:01:09.014]             `<<-` <- base::`<<-`
[18:01:09.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.014]                   3L)]
[18:01:09.014]             }
[18:01:09.014]             function(cond) {
[18:01:09.014]                 is_error <- inherits(cond, "error")
[18:01:09.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.014]                   NULL)
[18:01:09.014]                 if (is_error) {
[18:01:09.014]                   sessionInformation <- function() {
[18:01:09.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.014]                       search = base::search(), system = base::Sys.info())
[18:01:09.014]                   }
[18:01:09.014]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.014]                     cond$call), session = sessionInformation(), 
[18:01:09.014]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.014]                   signalCondition(cond)
[18:01:09.014]                 }
[18:01:09.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.014]                 "immediateCondition"))) {
[18:01:09.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.014]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.014]                   if (TRUE && !signal) {
[18:01:09.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.014]                     {
[18:01:09.014]                       inherits <- base::inherits
[18:01:09.014]                       invokeRestart <- base::invokeRestart
[18:01:09.014]                       is.null <- base::is.null
[18:01:09.014]                       muffled <- FALSE
[18:01:09.014]                       if (inherits(cond, "message")) {
[18:01:09.014]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.014]                         if (muffled) 
[18:01:09.014]                           invokeRestart("muffleMessage")
[18:01:09.014]                       }
[18:01:09.014]                       else if (inherits(cond, "warning")) {
[18:01:09.014]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.014]                         if (muffled) 
[18:01:09.014]                           invokeRestart("muffleWarning")
[18:01:09.014]                       }
[18:01:09.014]                       else if (inherits(cond, "condition")) {
[18:01:09.014]                         if (!is.null(pattern)) {
[18:01:09.014]                           computeRestarts <- base::computeRestarts
[18:01:09.014]                           grepl <- base::grepl
[18:01:09.014]                           restarts <- computeRestarts(cond)
[18:01:09.014]                           for (restart in restarts) {
[18:01:09.014]                             name <- restart$name
[18:01:09.014]                             if (is.null(name)) 
[18:01:09.014]                               next
[18:01:09.014]                             if (!grepl(pattern, name)) 
[18:01:09.014]                               next
[18:01:09.014]                             invokeRestart(restart)
[18:01:09.014]                             muffled <- TRUE
[18:01:09.014]                             break
[18:01:09.014]                           }
[18:01:09.014]                         }
[18:01:09.014]                       }
[18:01:09.014]                       invisible(muffled)
[18:01:09.014]                     }
[18:01:09.014]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.014]                   }
[18:01:09.014]                 }
[18:01:09.014]                 else {
[18:01:09.014]                   if (TRUE) {
[18:01:09.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.014]                     {
[18:01:09.014]                       inherits <- base::inherits
[18:01:09.014]                       invokeRestart <- base::invokeRestart
[18:01:09.014]                       is.null <- base::is.null
[18:01:09.014]                       muffled <- FALSE
[18:01:09.014]                       if (inherits(cond, "message")) {
[18:01:09.014]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.014]                         if (muffled) 
[18:01:09.014]                           invokeRestart("muffleMessage")
[18:01:09.014]                       }
[18:01:09.014]                       else if (inherits(cond, "warning")) {
[18:01:09.014]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.014]                         if (muffled) 
[18:01:09.014]                           invokeRestart("muffleWarning")
[18:01:09.014]                       }
[18:01:09.014]                       else if (inherits(cond, "condition")) {
[18:01:09.014]                         if (!is.null(pattern)) {
[18:01:09.014]                           computeRestarts <- base::computeRestarts
[18:01:09.014]                           grepl <- base::grepl
[18:01:09.014]                           restarts <- computeRestarts(cond)
[18:01:09.014]                           for (restart in restarts) {
[18:01:09.014]                             name <- restart$name
[18:01:09.014]                             if (is.null(name)) 
[18:01:09.014]                               next
[18:01:09.014]                             if (!grepl(pattern, name)) 
[18:01:09.014]                               next
[18:01:09.014]                             invokeRestart(restart)
[18:01:09.014]                             muffled <- TRUE
[18:01:09.014]                             break
[18:01:09.014]                           }
[18:01:09.014]                         }
[18:01:09.014]                       }
[18:01:09.014]                       invisible(muffled)
[18:01:09.014]                     }
[18:01:09.014]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.014]                   }
[18:01:09.014]                 }
[18:01:09.014]             }
[18:01:09.014]         }))
[18:01:09.014]     }, error = function(ex) {
[18:01:09.014]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.014]                 ...future.rng), started = ...future.startTime, 
[18:01:09.014]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.014]             version = "1.8"), class = "FutureResult")
[18:01:09.014]     }, finally = {
[18:01:09.014]         if (!identical(...future.workdir, getwd())) 
[18:01:09.014]             setwd(...future.workdir)
[18:01:09.014]         {
[18:01:09.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.014]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.014]             }
[18:01:09.014]             base::options(...future.oldOptions)
[18:01:09.014]             if (.Platform$OS.type == "windows") {
[18:01:09.014]                 old_names <- names(...future.oldEnvVars)
[18:01:09.014]                 envs <- base::Sys.getenv()
[18:01:09.014]                 names <- names(envs)
[18:01:09.014]                 common <- intersect(names, old_names)
[18:01:09.014]                 added <- setdiff(names, old_names)
[18:01:09.014]                 removed <- setdiff(old_names, names)
[18:01:09.014]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.014]                   envs[common]]
[18:01:09.014]                 NAMES <- toupper(changed)
[18:01:09.014]                 args <- list()
[18:01:09.014]                 for (kk in seq_along(NAMES)) {
[18:01:09.014]                   name <- changed[[kk]]
[18:01:09.014]                   NAME <- NAMES[[kk]]
[18:01:09.014]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.014]                     next
[18:01:09.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.014]                 }
[18:01:09.014]                 NAMES <- toupper(added)
[18:01:09.014]                 for (kk in seq_along(NAMES)) {
[18:01:09.014]                   name <- added[[kk]]
[18:01:09.014]                   NAME <- NAMES[[kk]]
[18:01:09.014]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.014]                     next
[18:01:09.014]                   args[[name]] <- ""
[18:01:09.014]                 }
[18:01:09.014]                 NAMES <- toupper(removed)
[18:01:09.014]                 for (kk in seq_along(NAMES)) {
[18:01:09.014]                   name <- removed[[kk]]
[18:01:09.014]                   NAME <- NAMES[[kk]]
[18:01:09.014]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.014]                     next
[18:01:09.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.014]                 }
[18:01:09.014]                 if (length(args) > 0) 
[18:01:09.014]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.014]             }
[18:01:09.014]             else {
[18:01:09.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.014]             }
[18:01:09.014]             {
[18:01:09.014]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.014]                   0L) {
[18:01:09.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.014]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.014]                   base::options(opts)
[18:01:09.014]                 }
[18:01:09.014]                 {
[18:01:09.014]                   {
[18:01:09.014]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.014]                     NULL
[18:01:09.014]                   }
[18:01:09.014]                   options(future.plan = NULL)
[18:01:09.014]                   if (is.na(NA_character_)) 
[18:01:09.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.014]                     .init = FALSE)
[18:01:09.014]                 }
[18:01:09.014]             }
[18:01:09.014]         }
[18:01:09.014]     })
[18:01:09.014]     if (TRUE) {
[18:01:09.014]         base::sink(type = "output", split = FALSE)
[18:01:09.014]         if (TRUE) {
[18:01:09.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.014]         }
[18:01:09.014]         else {
[18:01:09.014]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.014]         }
[18:01:09.014]         base::close(...future.stdout)
[18:01:09.014]         ...future.stdout <- NULL
[18:01:09.014]     }
[18:01:09.014]     ...future.result$conditions <- ...future.conditions
[18:01:09.014]     ...future.result$finished <- base::Sys.time()
[18:01:09.014]     ...future.result
[18:01:09.014] }
[18:01:09.019] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[18:01:09.019] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[18:01:09.020] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[18:01:09.020] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:09.021] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.022] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[18:01:09.022] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[18:01:09.023] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:09.024] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:09.025] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.025] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[18:01:09.026] MultisessionFuture started
[18:01:09.026] - Launch lazy future ... done
[18:01:09.026] run() for ‘MultisessionFuture’ ... done
[18:01:09.027] Created future:
[18:01:09.027] MultisessionFuture:
[18:01:09.027] Label: ‘future_mapply-1’
[18:01:09.027] Expression:
[18:01:09.027] {
[18:01:09.027]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.027]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.027]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.027]         on.exit(options(oopts), add = TRUE)
[18:01:09.027]     }
[18:01:09.027]     {
[18:01:09.027]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.027]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.027]         do.call(mapply, args = args)
[18:01:09.027]     }
[18:01:09.027] }
[18:01:09.027] Lazy evaluation: FALSE
[18:01:09.027] Asynchronous evaluation: TRUE
[18:01:09.027] Local evaluation: TRUE
[18:01:09.027] Environment: R_GlobalEnv
[18:01:09.027] Capture standard output: TRUE
[18:01:09.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.027] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.027] Packages: <none>
[18:01:09.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.027] Resolved: FALSE
[18:01:09.027] Value: <not collected>
[18:01:09.027] Conditions captured: <none>
[18:01:09.027] Early signaling: FALSE
[18:01:09.027] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.027] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.039] Chunk #1 of 2 ... DONE
[18:01:09.040] Chunk #2 of 2 ...
[18:01:09.040]  - Finding globals in '...' for chunk #2 ...
[18:01:09.040] getGlobalsAndPackages() ...
[18:01:09.040] Searching for globals...
[18:01:09.041] 
[18:01:09.041] Searching for globals ... DONE
[18:01:09.041] - globals: [0] <none>
[18:01:09.042] getGlobalsAndPackages() ... DONE
[18:01:09.042]    + additional globals found: [n=0] 
[18:01:09.042]    + additional namespaces needed: [n=0] 
[18:01:09.042]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:09.042]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.043]  - seeds: <none>
[18:01:09.043]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.043] getGlobalsAndPackages() ...
[18:01:09.043] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.043] Resolving globals: FALSE
[18:01:09.044] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:09.045] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.046] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.046] 
[18:01:09.046] getGlobalsAndPackages() ... DONE
[18:01:09.046] run() for ‘Future’ ...
[18:01:09.047] - state: ‘created’
[18:01:09.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.070]   - Field: ‘node’
[18:01:09.070]   - Field: ‘label’
[18:01:09.071]   - Field: ‘local’
[18:01:09.071]   - Field: ‘owner’
[18:01:09.071]   - Field: ‘envir’
[18:01:09.071]   - Field: ‘workers’
[18:01:09.071]   - Field: ‘packages’
[18:01:09.072]   - Field: ‘gc’
[18:01:09.072]   - Field: ‘conditions’
[18:01:09.072]   - Field: ‘persistent’
[18:01:09.072]   - Field: ‘expr’
[18:01:09.072]   - Field: ‘uuid’
[18:01:09.073]   - Field: ‘seed’
[18:01:09.073]   - Field: ‘version’
[18:01:09.073]   - Field: ‘result’
[18:01:09.073]   - Field: ‘asynchronous’
[18:01:09.073]   - Field: ‘calls’
[18:01:09.074]   - Field: ‘globals’
[18:01:09.074]   - Field: ‘stdout’
[18:01:09.074]   - Field: ‘earlySignal’
[18:01:09.074]   - Field: ‘lazy’
[18:01:09.074]   - Field: ‘state’
[18:01:09.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.075] - Launch lazy future ...
[18:01:09.075] Packages needed by the future expression (n = 0): <none>
[18:01:09.075] Packages needed by future strategies (n = 0): <none>
[18:01:09.076] {
[18:01:09.076]     {
[18:01:09.076]         {
[18:01:09.076]             ...future.startTime <- base::Sys.time()
[18:01:09.076]             {
[18:01:09.076]                 {
[18:01:09.076]                   {
[18:01:09.076]                     {
[18:01:09.076]                       base::local({
[18:01:09.076]                         has_future <- base::requireNamespace("future", 
[18:01:09.076]                           quietly = TRUE)
[18:01:09.076]                         if (has_future) {
[18:01:09.076]                           ns <- base::getNamespace("future")
[18:01:09.076]                           version <- ns[[".package"]][["version"]]
[18:01:09.076]                           if (is.null(version)) 
[18:01:09.076]                             version <- utils::packageVersion("future")
[18:01:09.076]                         }
[18:01:09.076]                         else {
[18:01:09.076]                           version <- NULL
[18:01:09.076]                         }
[18:01:09.076]                         if (!has_future || version < "1.8.0") {
[18:01:09.076]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.076]                             "", base::R.version$version.string), 
[18:01:09.076]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:09.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:09.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.076]                               "release", "version")], collapse = " "), 
[18:01:09.076]                             hostname = base::Sys.info()[["nodename"]])
[18:01:09.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.076]                             info)
[18:01:09.076]                           info <- base::paste(info, collapse = "; ")
[18:01:09.076]                           if (!has_future) {
[18:01:09.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.076]                               info)
[18:01:09.076]                           }
[18:01:09.076]                           else {
[18:01:09.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.076]                               info, version)
[18:01:09.076]                           }
[18:01:09.076]                           base::stop(msg)
[18:01:09.076]                         }
[18:01:09.076]                       })
[18:01:09.076]                     }
[18:01:09.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.076]                     base::options(mc.cores = 1L)
[18:01:09.076]                   }
[18:01:09.076]                   ...future.strategy.old <- future::plan("list")
[18:01:09.076]                   options(future.plan = NULL)
[18:01:09.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.076]                 }
[18:01:09.076]                 ...future.workdir <- getwd()
[18:01:09.076]             }
[18:01:09.076]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.076]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.076]         }
[18:01:09.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.076]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.076]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.076]             base::names(...future.oldOptions))
[18:01:09.076]     }
[18:01:09.076]     if (FALSE) {
[18:01:09.076]     }
[18:01:09.076]     else {
[18:01:09.076]         if (TRUE) {
[18:01:09.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.076]                 open = "w")
[18:01:09.076]         }
[18:01:09.076]         else {
[18:01:09.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.076]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.076]         }
[18:01:09.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.076]             base::sink(type = "output", split = FALSE)
[18:01:09.076]             base::close(...future.stdout)
[18:01:09.076]         }, add = TRUE)
[18:01:09.076]     }
[18:01:09.076]     ...future.frame <- base::sys.nframe()
[18:01:09.076]     ...future.conditions <- base::list()
[18:01:09.076]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.076]     if (FALSE) {
[18:01:09.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.076]     }
[18:01:09.076]     ...future.result <- base::tryCatch({
[18:01:09.076]         base::withCallingHandlers({
[18:01:09.076]             ...future.value <- base::withVisible(base::local({
[18:01:09.076]                 ...future.makeSendCondition <- base::local({
[18:01:09.076]                   sendCondition <- NULL
[18:01:09.076]                   function(frame = 1L) {
[18:01:09.076]                     if (is.function(sendCondition)) 
[18:01:09.076]                       return(sendCondition)
[18:01:09.076]                     ns <- getNamespace("parallel")
[18:01:09.076]                     if (exists("sendData", mode = "function", 
[18:01:09.076]                       envir = ns)) {
[18:01:09.076]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.076]                         envir = ns)
[18:01:09.076]                       envir <- sys.frame(frame)
[18:01:09.076]                       master <- NULL
[18:01:09.076]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.076]                         !identical(envir, emptyenv())) {
[18:01:09.076]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.076]                           inherits = FALSE)) {
[18:01:09.076]                           master <- get("master", mode = "list", 
[18:01:09.076]                             envir = envir, inherits = FALSE)
[18:01:09.076]                           if (inherits(master, c("SOCKnode", 
[18:01:09.076]                             "SOCK0node"))) {
[18:01:09.076]                             sendCondition <<- function(cond) {
[18:01:09.076]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.076]                                 success = TRUE)
[18:01:09.076]                               parallel_sendData(master, data)
[18:01:09.076]                             }
[18:01:09.076]                             return(sendCondition)
[18:01:09.076]                           }
[18:01:09.076]                         }
[18:01:09.076]                         frame <- frame + 1L
[18:01:09.076]                         envir <- sys.frame(frame)
[18:01:09.076]                       }
[18:01:09.076]                     }
[18:01:09.076]                     sendCondition <<- function(cond) NULL
[18:01:09.076]                   }
[18:01:09.076]                 })
[18:01:09.076]                 withCallingHandlers({
[18:01:09.076]                   {
[18:01:09.076]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.076]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.076]                       ...future.globals.maxSize)) {
[18:01:09.076]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.076]                       on.exit(options(oopts), add = TRUE)
[18:01:09.076]                     }
[18:01:09.076]                     {
[18:01:09.076]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.076]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.076]                         USE.NAMES = FALSE)
[18:01:09.076]                       do.call(mapply, args = args)
[18:01:09.076]                     }
[18:01:09.076]                   }
[18:01:09.076]                 }, immediateCondition = function(cond) {
[18:01:09.076]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.076]                   sendCondition(cond)
[18:01:09.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.076]                   {
[18:01:09.076]                     inherits <- base::inherits
[18:01:09.076]                     invokeRestart <- base::invokeRestart
[18:01:09.076]                     is.null <- base::is.null
[18:01:09.076]                     muffled <- FALSE
[18:01:09.076]                     if (inherits(cond, "message")) {
[18:01:09.076]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.076]                       if (muffled) 
[18:01:09.076]                         invokeRestart("muffleMessage")
[18:01:09.076]                     }
[18:01:09.076]                     else if (inherits(cond, "warning")) {
[18:01:09.076]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.076]                       if (muffled) 
[18:01:09.076]                         invokeRestart("muffleWarning")
[18:01:09.076]                     }
[18:01:09.076]                     else if (inherits(cond, "condition")) {
[18:01:09.076]                       if (!is.null(pattern)) {
[18:01:09.076]                         computeRestarts <- base::computeRestarts
[18:01:09.076]                         grepl <- base::grepl
[18:01:09.076]                         restarts <- computeRestarts(cond)
[18:01:09.076]                         for (restart in restarts) {
[18:01:09.076]                           name <- restart$name
[18:01:09.076]                           if (is.null(name)) 
[18:01:09.076]                             next
[18:01:09.076]                           if (!grepl(pattern, name)) 
[18:01:09.076]                             next
[18:01:09.076]                           invokeRestart(restart)
[18:01:09.076]                           muffled <- TRUE
[18:01:09.076]                           break
[18:01:09.076]                         }
[18:01:09.076]                       }
[18:01:09.076]                     }
[18:01:09.076]                     invisible(muffled)
[18:01:09.076]                   }
[18:01:09.076]                   muffleCondition(cond)
[18:01:09.076]                 })
[18:01:09.076]             }))
[18:01:09.076]             future::FutureResult(value = ...future.value$value, 
[18:01:09.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.076]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.076]                     ...future.globalenv.names))
[18:01:09.076]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.076]         }, condition = base::local({
[18:01:09.076]             c <- base::c
[18:01:09.076]             inherits <- base::inherits
[18:01:09.076]             invokeRestart <- base::invokeRestart
[18:01:09.076]             length <- base::length
[18:01:09.076]             list <- base::list
[18:01:09.076]             seq.int <- base::seq.int
[18:01:09.076]             signalCondition <- base::signalCondition
[18:01:09.076]             sys.calls <- base::sys.calls
[18:01:09.076]             `[[` <- base::`[[`
[18:01:09.076]             `+` <- base::`+`
[18:01:09.076]             `<<-` <- base::`<<-`
[18:01:09.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.076]                   3L)]
[18:01:09.076]             }
[18:01:09.076]             function(cond) {
[18:01:09.076]                 is_error <- inherits(cond, "error")
[18:01:09.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.076]                   NULL)
[18:01:09.076]                 if (is_error) {
[18:01:09.076]                   sessionInformation <- function() {
[18:01:09.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.076]                       search = base::search(), system = base::Sys.info())
[18:01:09.076]                   }
[18:01:09.076]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.076]                     cond$call), session = sessionInformation(), 
[18:01:09.076]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.076]                   signalCondition(cond)
[18:01:09.076]                 }
[18:01:09.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.076]                 "immediateCondition"))) {
[18:01:09.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.076]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.076]                   if (TRUE && !signal) {
[18:01:09.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.076]                     {
[18:01:09.076]                       inherits <- base::inherits
[18:01:09.076]                       invokeRestart <- base::invokeRestart
[18:01:09.076]                       is.null <- base::is.null
[18:01:09.076]                       muffled <- FALSE
[18:01:09.076]                       if (inherits(cond, "message")) {
[18:01:09.076]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.076]                         if (muffled) 
[18:01:09.076]                           invokeRestart("muffleMessage")
[18:01:09.076]                       }
[18:01:09.076]                       else if (inherits(cond, "warning")) {
[18:01:09.076]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.076]                         if (muffled) 
[18:01:09.076]                           invokeRestart("muffleWarning")
[18:01:09.076]                       }
[18:01:09.076]                       else if (inherits(cond, "condition")) {
[18:01:09.076]                         if (!is.null(pattern)) {
[18:01:09.076]                           computeRestarts <- base::computeRestarts
[18:01:09.076]                           grepl <- base::grepl
[18:01:09.076]                           restarts <- computeRestarts(cond)
[18:01:09.076]                           for (restart in restarts) {
[18:01:09.076]                             name <- restart$name
[18:01:09.076]                             if (is.null(name)) 
[18:01:09.076]                               next
[18:01:09.076]                             if (!grepl(pattern, name)) 
[18:01:09.076]                               next
[18:01:09.076]                             invokeRestart(restart)
[18:01:09.076]                             muffled <- TRUE
[18:01:09.076]                             break
[18:01:09.076]                           }
[18:01:09.076]                         }
[18:01:09.076]                       }
[18:01:09.076]                       invisible(muffled)
[18:01:09.076]                     }
[18:01:09.076]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.076]                   }
[18:01:09.076]                 }
[18:01:09.076]                 else {
[18:01:09.076]                   if (TRUE) {
[18:01:09.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.076]                     {
[18:01:09.076]                       inherits <- base::inherits
[18:01:09.076]                       invokeRestart <- base::invokeRestart
[18:01:09.076]                       is.null <- base::is.null
[18:01:09.076]                       muffled <- FALSE
[18:01:09.076]                       if (inherits(cond, "message")) {
[18:01:09.076]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.076]                         if (muffled) 
[18:01:09.076]                           invokeRestart("muffleMessage")
[18:01:09.076]                       }
[18:01:09.076]                       else if (inherits(cond, "warning")) {
[18:01:09.076]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.076]                         if (muffled) 
[18:01:09.076]                           invokeRestart("muffleWarning")
[18:01:09.076]                       }
[18:01:09.076]                       else if (inherits(cond, "condition")) {
[18:01:09.076]                         if (!is.null(pattern)) {
[18:01:09.076]                           computeRestarts <- base::computeRestarts
[18:01:09.076]                           grepl <- base::grepl
[18:01:09.076]                           restarts <- computeRestarts(cond)
[18:01:09.076]                           for (restart in restarts) {
[18:01:09.076]                             name <- restart$name
[18:01:09.076]                             if (is.null(name)) 
[18:01:09.076]                               next
[18:01:09.076]                             if (!grepl(pattern, name)) 
[18:01:09.076]                               next
[18:01:09.076]                             invokeRestart(restart)
[18:01:09.076]                             muffled <- TRUE
[18:01:09.076]                             break
[18:01:09.076]                           }
[18:01:09.076]                         }
[18:01:09.076]                       }
[18:01:09.076]                       invisible(muffled)
[18:01:09.076]                     }
[18:01:09.076]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.076]                   }
[18:01:09.076]                 }
[18:01:09.076]             }
[18:01:09.076]         }))
[18:01:09.076]     }, error = function(ex) {
[18:01:09.076]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.076]                 ...future.rng), started = ...future.startTime, 
[18:01:09.076]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.076]             version = "1.8"), class = "FutureResult")
[18:01:09.076]     }, finally = {
[18:01:09.076]         if (!identical(...future.workdir, getwd())) 
[18:01:09.076]             setwd(...future.workdir)
[18:01:09.076]         {
[18:01:09.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.076]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.076]             }
[18:01:09.076]             base::options(...future.oldOptions)
[18:01:09.076]             if (.Platform$OS.type == "windows") {
[18:01:09.076]                 old_names <- names(...future.oldEnvVars)
[18:01:09.076]                 envs <- base::Sys.getenv()
[18:01:09.076]                 names <- names(envs)
[18:01:09.076]                 common <- intersect(names, old_names)
[18:01:09.076]                 added <- setdiff(names, old_names)
[18:01:09.076]                 removed <- setdiff(old_names, names)
[18:01:09.076]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.076]                   envs[common]]
[18:01:09.076]                 NAMES <- toupper(changed)
[18:01:09.076]                 args <- list()
[18:01:09.076]                 for (kk in seq_along(NAMES)) {
[18:01:09.076]                   name <- changed[[kk]]
[18:01:09.076]                   NAME <- NAMES[[kk]]
[18:01:09.076]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.076]                     next
[18:01:09.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.076]                 }
[18:01:09.076]                 NAMES <- toupper(added)
[18:01:09.076]                 for (kk in seq_along(NAMES)) {
[18:01:09.076]                   name <- added[[kk]]
[18:01:09.076]                   NAME <- NAMES[[kk]]
[18:01:09.076]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.076]                     next
[18:01:09.076]                   args[[name]] <- ""
[18:01:09.076]                 }
[18:01:09.076]                 NAMES <- toupper(removed)
[18:01:09.076]                 for (kk in seq_along(NAMES)) {
[18:01:09.076]                   name <- removed[[kk]]
[18:01:09.076]                   NAME <- NAMES[[kk]]
[18:01:09.076]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.076]                     next
[18:01:09.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.076]                 }
[18:01:09.076]                 if (length(args) > 0) 
[18:01:09.076]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.076]             }
[18:01:09.076]             else {
[18:01:09.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.076]             }
[18:01:09.076]             {
[18:01:09.076]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.076]                   0L) {
[18:01:09.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.076]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.076]                   base::options(opts)
[18:01:09.076]                 }
[18:01:09.076]                 {
[18:01:09.076]                   {
[18:01:09.076]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.076]                     NULL
[18:01:09.076]                   }
[18:01:09.076]                   options(future.plan = NULL)
[18:01:09.076]                   if (is.na(NA_character_)) 
[18:01:09.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.076]                     .init = FALSE)
[18:01:09.076]                 }
[18:01:09.076]             }
[18:01:09.076]         }
[18:01:09.076]     })
[18:01:09.076]     if (TRUE) {
[18:01:09.076]         base::sink(type = "output", split = FALSE)
[18:01:09.076]         if (TRUE) {
[18:01:09.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.076]         }
[18:01:09.076]         else {
[18:01:09.076]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.076]         }
[18:01:09.076]         base::close(...future.stdout)
[18:01:09.076]         ...future.stdout <- NULL
[18:01:09.076]     }
[18:01:09.076]     ...future.result$conditions <- ...future.conditions
[18:01:09.076]     ...future.result$finished <- base::Sys.time()
[18:01:09.076]     ...future.result
[18:01:09.076] }
[18:01:09.082] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[18:01:09.082] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[18:01:09.083] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[18:01:09.083] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:09.084] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.085] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:09.085] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:09.086] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:09.086] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.087] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:09.088] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.088] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[18:01:09.089] MultisessionFuture started
[18:01:09.089] - Launch lazy future ... done
[18:01:09.089] run() for ‘MultisessionFuture’ ... done
[18:01:09.089] Created future:
[18:01:09.090] MultisessionFuture:
[18:01:09.090] Label: ‘future_mapply-2’
[18:01:09.090] Expression:
[18:01:09.090] {
[18:01:09.090]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.090]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.090]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.090]         on.exit(options(oopts), add = TRUE)
[18:01:09.090]     }
[18:01:09.090]     {
[18:01:09.090]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.090]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.090]         do.call(mapply, args = args)
[18:01:09.090]     }
[18:01:09.090] }
[18:01:09.090] Lazy evaluation: FALSE
[18:01:09.090] Asynchronous evaluation: TRUE
[18:01:09.090] Local evaluation: TRUE
[18:01:09.090] Environment: R_GlobalEnv
[18:01:09.090] Capture standard output: TRUE
[18:01:09.090] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.090] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.090] Packages: <none>
[18:01:09.090] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.090] Resolved: FALSE
[18:01:09.090] Value: <not collected>
[18:01:09.090] Conditions captured: <none>
[18:01:09.090] Early signaling: FALSE
[18:01:09.090] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.090] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.102] Chunk #2 of 2 ... DONE
[18:01:09.103] Launching 2 futures (chunks) ... DONE
[18:01:09.103] Resolving 2 futures (chunks) ...
[18:01:09.103] resolve() on list ...
[18:01:09.103]  recursive: 0
[18:01:09.103]  length: 2
[18:01:09.104] 
[18:01:09.104] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.105] - Validating connection of MultisessionFuture
[18:01:09.105] - received message: FutureResult
[18:01:09.105] - Received FutureResult
[18:01:09.105] - Erased future from FutureRegistry
[18:01:09.106] result() for ClusterFuture ...
[18:01:09.106] - result already collected: FutureResult
[18:01:09.106] result() for ClusterFuture ... done
[18:01:09.106] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.106] Future #1
[18:01:09.107] result() for ClusterFuture ...
[18:01:09.107] - result already collected: FutureResult
[18:01:09.107] result() for ClusterFuture ... done
[18:01:09.107] result() for ClusterFuture ...
[18:01:09.107] - result already collected: FutureResult
[18:01:09.107] result() for ClusterFuture ... done
[18:01:09.108] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:09.108] - nx: 2
[18:01:09.108] - relay: TRUE
[18:01:09.108] - stdout: TRUE
[18:01:09.108] - signal: TRUE
[18:01:09.109] - resignal: FALSE
[18:01:09.109] - force: TRUE
[18:01:09.109] - relayed: [n=2] FALSE, FALSE
[18:01:09.109] - queued futures: [n=2] FALSE, FALSE
[18:01:09.109]  - until=1
[18:01:09.109]  - relaying element #1
[18:01:09.110] result() for ClusterFuture ...
[18:01:09.110] - result already collected: FutureResult
[18:01:09.110] result() for ClusterFuture ... done
[18:01:09.110] result() for ClusterFuture ...
[18:01:09.110] - result already collected: FutureResult
[18:01:09.111] result() for ClusterFuture ... done
[18:01:09.111] result() for ClusterFuture ...
[18:01:09.111] - result already collected: FutureResult
[18:01:09.111] result() for ClusterFuture ... done
[18:01:09.111] result() for ClusterFuture ...
[18:01:09.111] - result already collected: FutureResult
[18:01:09.112] result() for ClusterFuture ... done
[18:01:09.112] - relayed: [n=2] TRUE, FALSE
[18:01:09.112] - queued futures: [n=2] TRUE, FALSE
[18:01:09.112] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:09.112]  length: 1 (resolved future 1)
[18:01:09.134] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.135] - Validating connection of MultisessionFuture
[18:01:09.135] - received message: FutureResult
[18:01:09.135] - Received FutureResult
[18:01:09.136] - Erased future from FutureRegistry
[18:01:09.136] result() for ClusterFuture ...
[18:01:09.136] - result already collected: FutureResult
[18:01:09.136] result() for ClusterFuture ... done
[18:01:09.136] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.136] Future #2
[18:01:09.137] result() for ClusterFuture ...
[18:01:09.137] - result already collected: FutureResult
[18:01:09.137] result() for ClusterFuture ... done
[18:01:09.137] result() for ClusterFuture ...
[18:01:09.137] - result already collected: FutureResult
[18:01:09.138] result() for ClusterFuture ... done
[18:01:09.138] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:09.138] - nx: 2
[18:01:09.138] - relay: TRUE
[18:01:09.138] - stdout: TRUE
[18:01:09.139] - signal: TRUE
[18:01:09.139] - resignal: FALSE
[18:01:09.139] - force: TRUE
[18:01:09.139] - relayed: [n=2] TRUE, FALSE
[18:01:09.139] - queued futures: [n=2] TRUE, FALSE
[18:01:09.140]  - until=2
[18:01:09.140]  - relaying element #2
[18:01:09.140] result() for ClusterFuture ...
[18:01:09.140] - result already collected: FutureResult
[18:01:09.140] result() for ClusterFuture ... done
[18:01:09.140] result() for ClusterFuture ...
[18:01:09.141] - result already collected: FutureResult
[18:01:09.141] result() for ClusterFuture ... done
[18:01:09.141] result() for ClusterFuture ...
[18:01:09.141] - result already collected: FutureResult
[18:01:09.141] result() for ClusterFuture ... done
[18:01:09.142] result() for ClusterFuture ...
[18:01:09.142] - result already collected: FutureResult
[18:01:09.142] result() for ClusterFuture ... done
[18:01:09.142] - relayed: [n=2] TRUE, TRUE
[18:01:09.142] - queued futures: [n=2] TRUE, TRUE
[18:01:09.143] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:09.143]  length: 0 (resolved future 2)
[18:01:09.143] Relaying remaining futures
[18:01:09.143] signalConditionsASAP(NULL, pos=0) ...
[18:01:09.143] - nx: 2
[18:01:09.143] - relay: TRUE
[18:01:09.144] - stdout: TRUE
[18:01:09.144] - signal: TRUE
[18:01:09.144] - resignal: FALSE
[18:01:09.144] - force: TRUE
[18:01:09.144] - relayed: [n=2] TRUE, TRUE
[18:01:09.145] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:09.145] - relayed: [n=2] TRUE, TRUE
[18:01:09.145] - queued futures: [n=2] TRUE, TRUE
[18:01:09.145] signalConditionsASAP(NULL, pos=0) ... done
[18:01:09.145] resolve() on list ... DONE
[18:01:09.146] result() for ClusterFuture ...
[18:01:09.146] - result already collected: FutureResult
[18:01:09.146] result() for ClusterFuture ... done
[18:01:09.146] result() for ClusterFuture ...
[18:01:09.146] - result already collected: FutureResult
[18:01:09.147] result() for ClusterFuture ... done
[18:01:09.147] result() for ClusterFuture ...
[18:01:09.147] - result already collected: FutureResult
[18:01:09.147] result() for ClusterFuture ... done
[18:01:09.147] result() for ClusterFuture ...
[18:01:09.148] - result already collected: FutureResult
[18:01:09.148] result() for ClusterFuture ... done
[18:01:09.148]  - Number of value chunks collected: 2
[18:01:09.148] Resolving 2 futures (chunks) ... DONE
[18:01:09.148] Reducing values from 2 chunks ...
[18:01:09.148]  - Number of values collected after concatenation: 4
[18:01:09.149]  - Number of values expected: 4
[18:01:09.149] Reducing values from 2 chunks ... DONE
[18:01:09.149] future_mapply() ... DONE
- Parallel RNG ...
[18:01:09.149] future_mapply() ...
[18:01:09.150] Generating random seeds ...
[18:01:09.150] Generating random seed streams for 4 elements ...
[18:01:09.150] Generating random seed streams for 4 elements ... DONE
[18:01:09.150] Generating random seeds ... DONE
[18:01:09.151] Will set RNG state on exit: 10407, -389418712, -632951378, 452049987, 2146488288, -326844498, -474502023
[18:01:09.157] Number of chunks: 2
[18:01:09.157] getGlobalsAndPackagesXApply() ...
[18:01:09.157]  - future.globals: TRUE
[18:01:09.158] getGlobalsAndPackages() ...
[18:01:09.158] Searching for globals...
[18:01:09.160] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[18:01:09.160] Searching for globals ... DONE
[18:01:09.161] Resolving globals: FALSE
[18:01:09.162] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[18:01:09.162] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[18:01:09.162] - globals: [1] ‘FUN’
[18:01:09.163] - packages: [1] ‘stats’
[18:01:09.163] getGlobalsAndPackages() ... DONE
[18:01:09.163]  - globals found/used: [n=1] ‘FUN’
[18:01:09.163]  - needed namespaces: [n=1] ‘stats’
[18:01:09.164] Finding globals ... DONE
[18:01:09.164] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:09.164] List of 2
[18:01:09.164]  $ ...future.FUN:function (n, min = 0, max = 1)  
[18:01:09.164]  $ MoreArgs     :List of 1
[18:01:09.164]   ..$ min: num 1
[18:01:09.164]  - attr(*, "where")=List of 2
[18:01:09.164]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:09.164]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:09.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:09.164]  - attr(*, "resolved")= logi FALSE
[18:01:09.164]  - attr(*, "total_size")= num NA
[18:01:09.170] Packages to be attached in all futures: [n=1] ‘stats’
[18:01:09.170] getGlobalsAndPackagesXApply() ... DONE
[18:01:09.170] Number of futures (= number of chunks): 2
[18:01:09.170] Launching 2 futures (chunks) ...
[18:01:09.171] Chunk #1 of 2 ...
[18:01:09.171]  - Finding globals in '...' for chunk #1 ...
[18:01:09.171] getGlobalsAndPackages() ...
[18:01:09.171] Searching for globals...
[18:01:09.172] 
[18:01:09.172] Searching for globals ... DONE
[18:01:09.172] - globals: [0] <none>
[18:01:09.172] getGlobalsAndPackages() ... DONE
[18:01:09.173]    + additional globals found: [n=0] 
[18:01:09.173]    + additional namespaces needed: [n=0] 
[18:01:09.173]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:09.173]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.173]  - seeds: [2] <seeds>
[18:01:09.174]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.174] getGlobalsAndPackages() ...
[18:01:09.174] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.174] Resolving globals: FALSE
[18:01:09.175] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[18:01:09.176] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[18:01:09.177] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.177] - packages: [1] ‘stats’
[18:01:09.177] getGlobalsAndPackages() ... DONE
[18:01:09.177] run() for ‘Future’ ...
[18:01:09.178] - state: ‘created’
[18:01:09.178] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.202]   - Field: ‘node’
[18:01:09.202]   - Field: ‘label’
[18:01:09.202]   - Field: ‘local’
[18:01:09.202]   - Field: ‘owner’
[18:01:09.202]   - Field: ‘envir’
[18:01:09.203]   - Field: ‘workers’
[18:01:09.203]   - Field: ‘packages’
[18:01:09.203]   - Field: ‘gc’
[18:01:09.203]   - Field: ‘conditions’
[18:01:09.203]   - Field: ‘persistent’
[18:01:09.204]   - Field: ‘expr’
[18:01:09.204]   - Field: ‘uuid’
[18:01:09.204]   - Field: ‘seed’
[18:01:09.204]   - Field: ‘version’
[18:01:09.204]   - Field: ‘result’
[18:01:09.205]   - Field: ‘asynchronous’
[18:01:09.205]   - Field: ‘calls’
[18:01:09.205]   - Field: ‘globals’
[18:01:09.205]   - Field: ‘stdout’
[18:01:09.205]   - Field: ‘earlySignal’
[18:01:09.206]   - Field: ‘lazy’
[18:01:09.206]   - Field: ‘state’
[18:01:09.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.206] - Launch lazy future ...
[18:01:09.207] Packages needed by the future expression (n = 1): ‘stats’
[18:01:09.207] Packages needed by future strategies (n = 0): <none>
[18:01:09.208] {
[18:01:09.208]     {
[18:01:09.208]         {
[18:01:09.208]             ...future.startTime <- base::Sys.time()
[18:01:09.208]             {
[18:01:09.208]                 {
[18:01:09.208]                   {
[18:01:09.208]                     {
[18:01:09.208]                       {
[18:01:09.208]                         base::local({
[18:01:09.208]                           has_future <- base::requireNamespace("future", 
[18:01:09.208]                             quietly = TRUE)
[18:01:09.208]                           if (has_future) {
[18:01:09.208]                             ns <- base::getNamespace("future")
[18:01:09.208]                             version <- ns[[".package"]][["version"]]
[18:01:09.208]                             if (is.null(version)) 
[18:01:09.208]                               version <- utils::packageVersion("future")
[18:01:09.208]                           }
[18:01:09.208]                           else {
[18:01:09.208]                             version <- NULL
[18:01:09.208]                           }
[18:01:09.208]                           if (!has_future || version < "1.8.0") {
[18:01:09.208]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.208]                               "", base::R.version$version.string), 
[18:01:09.208]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:09.208]                                 base::R.version$platform, 8 * 
[18:01:09.208]                                   base::.Machine$sizeof.pointer), 
[18:01:09.208]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.208]                                 "release", "version")], collapse = " "), 
[18:01:09.208]                               hostname = base::Sys.info()[["nodename"]])
[18:01:09.208]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.208]                               info)
[18:01:09.208]                             info <- base::paste(info, collapse = "; ")
[18:01:09.208]                             if (!has_future) {
[18:01:09.208]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.208]                                 info)
[18:01:09.208]                             }
[18:01:09.208]                             else {
[18:01:09.208]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.208]                                 info, version)
[18:01:09.208]                             }
[18:01:09.208]                             base::stop(msg)
[18:01:09.208]                           }
[18:01:09.208]                         })
[18:01:09.208]                       }
[18:01:09.208]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.208]                       base::options(mc.cores = 1L)
[18:01:09.208]                     }
[18:01:09.208]                     base::local({
[18:01:09.208]                       for (pkg in "stats") {
[18:01:09.208]                         base::loadNamespace(pkg)
[18:01:09.208]                         base::library(pkg, character.only = TRUE)
[18:01:09.208]                       }
[18:01:09.208]                     })
[18:01:09.208]                   }
[18:01:09.208]                   ...future.strategy.old <- future::plan("list")
[18:01:09.208]                   options(future.plan = NULL)
[18:01:09.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.208]                 }
[18:01:09.208]                 ...future.workdir <- getwd()
[18:01:09.208]             }
[18:01:09.208]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.208]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.208]         }
[18:01:09.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.208]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.208]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.208]             base::names(...future.oldOptions))
[18:01:09.208]     }
[18:01:09.208]     if (FALSE) {
[18:01:09.208]     }
[18:01:09.208]     else {
[18:01:09.208]         if (TRUE) {
[18:01:09.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.208]                 open = "w")
[18:01:09.208]         }
[18:01:09.208]         else {
[18:01:09.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.208]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.208]         }
[18:01:09.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.208]             base::sink(type = "output", split = FALSE)
[18:01:09.208]             base::close(...future.stdout)
[18:01:09.208]         }, add = TRUE)
[18:01:09.208]     }
[18:01:09.208]     ...future.frame <- base::sys.nframe()
[18:01:09.208]     ...future.conditions <- base::list()
[18:01:09.208]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.208]     if (FALSE) {
[18:01:09.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.208]     }
[18:01:09.208]     ...future.result <- base::tryCatch({
[18:01:09.208]         base::withCallingHandlers({
[18:01:09.208]             ...future.value <- base::withVisible(base::local({
[18:01:09.208]                 ...future.makeSendCondition <- base::local({
[18:01:09.208]                   sendCondition <- NULL
[18:01:09.208]                   function(frame = 1L) {
[18:01:09.208]                     if (is.function(sendCondition)) 
[18:01:09.208]                       return(sendCondition)
[18:01:09.208]                     ns <- getNamespace("parallel")
[18:01:09.208]                     if (exists("sendData", mode = "function", 
[18:01:09.208]                       envir = ns)) {
[18:01:09.208]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.208]                         envir = ns)
[18:01:09.208]                       envir <- sys.frame(frame)
[18:01:09.208]                       master <- NULL
[18:01:09.208]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.208]                         !identical(envir, emptyenv())) {
[18:01:09.208]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.208]                           inherits = FALSE)) {
[18:01:09.208]                           master <- get("master", mode = "list", 
[18:01:09.208]                             envir = envir, inherits = FALSE)
[18:01:09.208]                           if (inherits(master, c("SOCKnode", 
[18:01:09.208]                             "SOCK0node"))) {
[18:01:09.208]                             sendCondition <<- function(cond) {
[18:01:09.208]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.208]                                 success = TRUE)
[18:01:09.208]                               parallel_sendData(master, data)
[18:01:09.208]                             }
[18:01:09.208]                             return(sendCondition)
[18:01:09.208]                           }
[18:01:09.208]                         }
[18:01:09.208]                         frame <- frame + 1L
[18:01:09.208]                         envir <- sys.frame(frame)
[18:01:09.208]                       }
[18:01:09.208]                     }
[18:01:09.208]                     sendCondition <<- function(cond) NULL
[18:01:09.208]                   }
[18:01:09.208]                 })
[18:01:09.208]                 withCallingHandlers({
[18:01:09.208]                   {
[18:01:09.208]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.208]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.208]                       ...future.globals.maxSize)) {
[18:01:09.208]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.208]                       on.exit(options(oopts), add = TRUE)
[18:01:09.208]                     }
[18:01:09.208]                     {
[18:01:09.208]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:09.208]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:09.208]                           envir = globalenv(), inherits = FALSE)
[18:01:09.208]                         ...future.FUN(...)
[18:01:09.208]                       }
[18:01:09.208]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:09.208]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:09.208]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.208]                         USE.NAMES = FALSE)
[18:01:09.208]                       do.call(mapply, args = args)
[18:01:09.208]                     }
[18:01:09.208]                   }
[18:01:09.208]                 }, immediateCondition = function(cond) {
[18:01:09.208]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.208]                   sendCondition(cond)
[18:01:09.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.208]                   {
[18:01:09.208]                     inherits <- base::inherits
[18:01:09.208]                     invokeRestart <- base::invokeRestart
[18:01:09.208]                     is.null <- base::is.null
[18:01:09.208]                     muffled <- FALSE
[18:01:09.208]                     if (inherits(cond, "message")) {
[18:01:09.208]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.208]                       if (muffled) 
[18:01:09.208]                         invokeRestart("muffleMessage")
[18:01:09.208]                     }
[18:01:09.208]                     else if (inherits(cond, "warning")) {
[18:01:09.208]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.208]                       if (muffled) 
[18:01:09.208]                         invokeRestart("muffleWarning")
[18:01:09.208]                     }
[18:01:09.208]                     else if (inherits(cond, "condition")) {
[18:01:09.208]                       if (!is.null(pattern)) {
[18:01:09.208]                         computeRestarts <- base::computeRestarts
[18:01:09.208]                         grepl <- base::grepl
[18:01:09.208]                         restarts <- computeRestarts(cond)
[18:01:09.208]                         for (restart in restarts) {
[18:01:09.208]                           name <- restart$name
[18:01:09.208]                           if (is.null(name)) 
[18:01:09.208]                             next
[18:01:09.208]                           if (!grepl(pattern, name)) 
[18:01:09.208]                             next
[18:01:09.208]                           invokeRestart(restart)
[18:01:09.208]                           muffled <- TRUE
[18:01:09.208]                           break
[18:01:09.208]                         }
[18:01:09.208]                       }
[18:01:09.208]                     }
[18:01:09.208]                     invisible(muffled)
[18:01:09.208]                   }
[18:01:09.208]                   muffleCondition(cond)
[18:01:09.208]                 })
[18:01:09.208]             }))
[18:01:09.208]             future::FutureResult(value = ...future.value$value, 
[18:01:09.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.208]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.208]                     ...future.globalenv.names))
[18:01:09.208]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.208]         }, condition = base::local({
[18:01:09.208]             c <- base::c
[18:01:09.208]             inherits <- base::inherits
[18:01:09.208]             invokeRestart <- base::invokeRestart
[18:01:09.208]             length <- base::length
[18:01:09.208]             list <- base::list
[18:01:09.208]             seq.int <- base::seq.int
[18:01:09.208]             signalCondition <- base::signalCondition
[18:01:09.208]             sys.calls <- base::sys.calls
[18:01:09.208]             `[[` <- base::`[[`
[18:01:09.208]             `+` <- base::`+`
[18:01:09.208]             `<<-` <- base::`<<-`
[18:01:09.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.208]                   3L)]
[18:01:09.208]             }
[18:01:09.208]             function(cond) {
[18:01:09.208]                 is_error <- inherits(cond, "error")
[18:01:09.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.208]                   NULL)
[18:01:09.208]                 if (is_error) {
[18:01:09.208]                   sessionInformation <- function() {
[18:01:09.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.208]                       search = base::search(), system = base::Sys.info())
[18:01:09.208]                   }
[18:01:09.208]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.208]                     cond$call), session = sessionInformation(), 
[18:01:09.208]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.208]                   signalCondition(cond)
[18:01:09.208]                 }
[18:01:09.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.208]                 "immediateCondition"))) {
[18:01:09.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.208]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.208]                   if (TRUE && !signal) {
[18:01:09.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.208]                     {
[18:01:09.208]                       inherits <- base::inherits
[18:01:09.208]                       invokeRestart <- base::invokeRestart
[18:01:09.208]                       is.null <- base::is.null
[18:01:09.208]                       muffled <- FALSE
[18:01:09.208]                       if (inherits(cond, "message")) {
[18:01:09.208]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.208]                         if (muffled) 
[18:01:09.208]                           invokeRestart("muffleMessage")
[18:01:09.208]                       }
[18:01:09.208]                       else if (inherits(cond, "warning")) {
[18:01:09.208]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.208]                         if (muffled) 
[18:01:09.208]                           invokeRestart("muffleWarning")
[18:01:09.208]                       }
[18:01:09.208]                       else if (inherits(cond, "condition")) {
[18:01:09.208]                         if (!is.null(pattern)) {
[18:01:09.208]                           computeRestarts <- base::computeRestarts
[18:01:09.208]                           grepl <- base::grepl
[18:01:09.208]                           restarts <- computeRestarts(cond)
[18:01:09.208]                           for (restart in restarts) {
[18:01:09.208]                             name <- restart$name
[18:01:09.208]                             if (is.null(name)) 
[18:01:09.208]                               next
[18:01:09.208]                             if (!grepl(pattern, name)) 
[18:01:09.208]                               next
[18:01:09.208]                             invokeRestart(restart)
[18:01:09.208]                             muffled <- TRUE
[18:01:09.208]                             break
[18:01:09.208]                           }
[18:01:09.208]                         }
[18:01:09.208]                       }
[18:01:09.208]                       invisible(muffled)
[18:01:09.208]                     }
[18:01:09.208]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.208]                   }
[18:01:09.208]                 }
[18:01:09.208]                 else {
[18:01:09.208]                   if (TRUE) {
[18:01:09.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.208]                     {
[18:01:09.208]                       inherits <- base::inherits
[18:01:09.208]                       invokeRestart <- base::invokeRestart
[18:01:09.208]                       is.null <- base::is.null
[18:01:09.208]                       muffled <- FALSE
[18:01:09.208]                       if (inherits(cond, "message")) {
[18:01:09.208]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.208]                         if (muffled) 
[18:01:09.208]                           invokeRestart("muffleMessage")
[18:01:09.208]                       }
[18:01:09.208]                       else if (inherits(cond, "warning")) {
[18:01:09.208]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.208]                         if (muffled) 
[18:01:09.208]                           invokeRestart("muffleWarning")
[18:01:09.208]                       }
[18:01:09.208]                       else if (inherits(cond, "condition")) {
[18:01:09.208]                         if (!is.null(pattern)) {
[18:01:09.208]                           computeRestarts <- base::computeRestarts
[18:01:09.208]                           grepl <- base::grepl
[18:01:09.208]                           restarts <- computeRestarts(cond)
[18:01:09.208]                           for (restart in restarts) {
[18:01:09.208]                             name <- restart$name
[18:01:09.208]                             if (is.null(name)) 
[18:01:09.208]                               next
[18:01:09.208]                             if (!grepl(pattern, name)) 
[18:01:09.208]                               next
[18:01:09.208]                             invokeRestart(restart)
[18:01:09.208]                             muffled <- TRUE
[18:01:09.208]                             break
[18:01:09.208]                           }
[18:01:09.208]                         }
[18:01:09.208]                       }
[18:01:09.208]                       invisible(muffled)
[18:01:09.208]                     }
[18:01:09.208]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.208]                   }
[18:01:09.208]                 }
[18:01:09.208]             }
[18:01:09.208]         }))
[18:01:09.208]     }, error = function(ex) {
[18:01:09.208]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.208]                 ...future.rng), started = ...future.startTime, 
[18:01:09.208]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.208]             version = "1.8"), class = "FutureResult")
[18:01:09.208]     }, finally = {
[18:01:09.208]         if (!identical(...future.workdir, getwd())) 
[18:01:09.208]             setwd(...future.workdir)
[18:01:09.208]         {
[18:01:09.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.208]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.208]             }
[18:01:09.208]             base::options(...future.oldOptions)
[18:01:09.208]             if (.Platform$OS.type == "windows") {
[18:01:09.208]                 old_names <- names(...future.oldEnvVars)
[18:01:09.208]                 envs <- base::Sys.getenv()
[18:01:09.208]                 names <- names(envs)
[18:01:09.208]                 common <- intersect(names, old_names)
[18:01:09.208]                 added <- setdiff(names, old_names)
[18:01:09.208]                 removed <- setdiff(old_names, names)
[18:01:09.208]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.208]                   envs[common]]
[18:01:09.208]                 NAMES <- toupper(changed)
[18:01:09.208]                 args <- list()
[18:01:09.208]                 for (kk in seq_along(NAMES)) {
[18:01:09.208]                   name <- changed[[kk]]
[18:01:09.208]                   NAME <- NAMES[[kk]]
[18:01:09.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.208]                     next
[18:01:09.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.208]                 }
[18:01:09.208]                 NAMES <- toupper(added)
[18:01:09.208]                 for (kk in seq_along(NAMES)) {
[18:01:09.208]                   name <- added[[kk]]
[18:01:09.208]                   NAME <- NAMES[[kk]]
[18:01:09.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.208]                     next
[18:01:09.208]                   args[[name]] <- ""
[18:01:09.208]                 }
[18:01:09.208]                 NAMES <- toupper(removed)
[18:01:09.208]                 for (kk in seq_along(NAMES)) {
[18:01:09.208]                   name <- removed[[kk]]
[18:01:09.208]                   NAME <- NAMES[[kk]]
[18:01:09.208]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.208]                     next
[18:01:09.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.208]                 }
[18:01:09.208]                 if (length(args) > 0) 
[18:01:09.208]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.208]             }
[18:01:09.208]             else {
[18:01:09.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.208]             }
[18:01:09.208]             {
[18:01:09.208]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.208]                   0L) {
[18:01:09.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.208]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.208]                   base::options(opts)
[18:01:09.208]                 }
[18:01:09.208]                 {
[18:01:09.208]                   {
[18:01:09.208]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.208]                     NULL
[18:01:09.208]                   }
[18:01:09.208]                   options(future.plan = NULL)
[18:01:09.208]                   if (is.na(NA_character_)) 
[18:01:09.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.208]                     .init = FALSE)
[18:01:09.208]                 }
[18:01:09.208]             }
[18:01:09.208]         }
[18:01:09.208]     })
[18:01:09.208]     if (TRUE) {
[18:01:09.208]         base::sink(type = "output", split = FALSE)
[18:01:09.208]         if (TRUE) {
[18:01:09.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.208]         }
[18:01:09.208]         else {
[18:01:09.208]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.208]         }
[18:01:09.208]         base::close(...future.stdout)
[18:01:09.208]         ...future.stdout <- NULL
[18:01:09.208]     }
[18:01:09.208]     ...future.result$conditions <- ...future.conditions
[18:01:09.208]     ...future.result$finished <- base::Sys.time()
[18:01:09.208]     ...future.result
[18:01:09.208] }
[18:01:09.214] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[18:01:09.214] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[18:01:09.215] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[18:01:09.215] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[18:01:09.216] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[18:01:09.216] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[18:01:09.217] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[18:01:09.217] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[18:01:09.218] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[18:01:09.219] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:09.219] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.220] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[18:01:09.221] MultisessionFuture started
[18:01:09.221] - Launch lazy future ... done
[18:01:09.221] run() for ‘MultisessionFuture’ ... done
[18:01:09.222] Created future:
[18:01:09.222] MultisessionFuture:
[18:01:09.222] Label: ‘future_mapply-1’
[18:01:09.222] Expression:
[18:01:09.222] {
[18:01:09.222]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.222]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.222]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.222]         on.exit(options(oopts), add = TRUE)
[18:01:09.222]     }
[18:01:09.222]     {
[18:01:09.222]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:09.222]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:09.222]                 inherits = FALSE)
[18:01:09.222]             ...future.FUN(...)
[18:01:09.222]         }
[18:01:09.222]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:09.222]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:09.222]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.222]         do.call(mapply, args = args)
[18:01:09.222]     }
[18:01:09.222] }
[18:01:09.222] Lazy evaluation: FALSE
[18:01:09.222] Asynchronous evaluation: TRUE
[18:01:09.222] Local evaluation: TRUE
[18:01:09.222] Environment: R_GlobalEnv
[18:01:09.222] Capture standard output: TRUE
[18:01:09.222] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.222] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.222] Packages: 1 packages (‘stats’)
[18:01:09.222] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:09.222] Resolved: FALSE
[18:01:09.222] Value: <not collected>
[18:01:09.222] Conditions captured: <none>
[18:01:09.222] Early signaling: FALSE
[18:01:09.222] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.222] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.236] Chunk #1 of 2 ... DONE
[18:01:09.236] Chunk #2 of 2 ...
[18:01:09.236]  - Finding globals in '...' for chunk #2 ...
[18:01:09.236] getGlobalsAndPackages() ...
[18:01:09.237] Searching for globals...
[18:01:09.237] 
[18:01:09.238] Searching for globals ... DONE
[18:01:09.238] - globals: [0] <none>
[18:01:09.238] getGlobalsAndPackages() ... DONE
[18:01:09.238]    + additional globals found: [n=0] 
[18:01:09.238]    + additional namespaces needed: [n=0] 
[18:01:09.239]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:09.239]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.239]  - seeds: [2] <seeds>
[18:01:09.239]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.239] getGlobalsAndPackages() ...
[18:01:09.240] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.240] Resolving globals: FALSE
[18:01:09.241] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[18:01:09.242] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[18:01:09.242] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.242] - packages: [1] ‘stats’
[18:01:09.243] getGlobalsAndPackages() ... DONE
[18:01:09.246] run() for ‘Future’ ...
[18:01:09.247] - state: ‘created’
[18:01:09.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.270]   - Field: ‘node’
[18:01:09.270]   - Field: ‘label’
[18:01:09.270]   - Field: ‘local’
[18:01:09.270]   - Field: ‘owner’
[18:01:09.271]   - Field: ‘envir’
[18:01:09.271]   - Field: ‘workers’
[18:01:09.271]   - Field: ‘packages’
[18:01:09.271]   - Field: ‘gc’
[18:01:09.271]   - Field: ‘conditions’
[18:01:09.272]   - Field: ‘persistent’
[18:01:09.272]   - Field: ‘expr’
[18:01:09.272]   - Field: ‘uuid’
[18:01:09.272]   - Field: ‘seed’
[18:01:09.272]   - Field: ‘version’
[18:01:09.272]   - Field: ‘result’
[18:01:09.273]   - Field: ‘asynchronous’
[18:01:09.273]   - Field: ‘calls’
[18:01:09.273]   - Field: ‘globals’
[18:01:09.273]   - Field: ‘stdout’
[18:01:09.273]   - Field: ‘earlySignal’
[18:01:09.274]   - Field: ‘lazy’
[18:01:09.274]   - Field: ‘state’
[18:01:09.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.274] - Launch lazy future ...
[18:01:09.275] Packages needed by the future expression (n = 1): ‘stats’
[18:01:09.275] Packages needed by future strategies (n = 0): <none>
[18:01:09.276] {
[18:01:09.276]     {
[18:01:09.276]         {
[18:01:09.276]             ...future.startTime <- base::Sys.time()
[18:01:09.276]             {
[18:01:09.276]                 {
[18:01:09.276]                   {
[18:01:09.276]                     {
[18:01:09.276]                       {
[18:01:09.276]                         base::local({
[18:01:09.276]                           has_future <- base::requireNamespace("future", 
[18:01:09.276]                             quietly = TRUE)
[18:01:09.276]                           if (has_future) {
[18:01:09.276]                             ns <- base::getNamespace("future")
[18:01:09.276]                             version <- ns[[".package"]][["version"]]
[18:01:09.276]                             if (is.null(version)) 
[18:01:09.276]                               version <- utils::packageVersion("future")
[18:01:09.276]                           }
[18:01:09.276]                           else {
[18:01:09.276]                             version <- NULL
[18:01:09.276]                           }
[18:01:09.276]                           if (!has_future || version < "1.8.0") {
[18:01:09.276]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.276]                               "", base::R.version$version.string), 
[18:01:09.276]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:09.276]                                 base::R.version$platform, 8 * 
[18:01:09.276]                                   base::.Machine$sizeof.pointer), 
[18:01:09.276]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.276]                                 "release", "version")], collapse = " "), 
[18:01:09.276]                               hostname = base::Sys.info()[["nodename"]])
[18:01:09.276]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.276]                               info)
[18:01:09.276]                             info <- base::paste(info, collapse = "; ")
[18:01:09.276]                             if (!has_future) {
[18:01:09.276]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.276]                                 info)
[18:01:09.276]                             }
[18:01:09.276]                             else {
[18:01:09.276]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.276]                                 info, version)
[18:01:09.276]                             }
[18:01:09.276]                             base::stop(msg)
[18:01:09.276]                           }
[18:01:09.276]                         })
[18:01:09.276]                       }
[18:01:09.276]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.276]                       base::options(mc.cores = 1L)
[18:01:09.276]                     }
[18:01:09.276]                     base::local({
[18:01:09.276]                       for (pkg in "stats") {
[18:01:09.276]                         base::loadNamespace(pkg)
[18:01:09.276]                         base::library(pkg, character.only = TRUE)
[18:01:09.276]                       }
[18:01:09.276]                     })
[18:01:09.276]                   }
[18:01:09.276]                   ...future.strategy.old <- future::plan("list")
[18:01:09.276]                   options(future.plan = NULL)
[18:01:09.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.276]                 }
[18:01:09.276]                 ...future.workdir <- getwd()
[18:01:09.276]             }
[18:01:09.276]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.276]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.276]         }
[18:01:09.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.276]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.276]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.276]             base::names(...future.oldOptions))
[18:01:09.276]     }
[18:01:09.276]     if (FALSE) {
[18:01:09.276]     }
[18:01:09.276]     else {
[18:01:09.276]         if (TRUE) {
[18:01:09.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.276]                 open = "w")
[18:01:09.276]         }
[18:01:09.276]         else {
[18:01:09.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.276]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.276]         }
[18:01:09.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.276]             base::sink(type = "output", split = FALSE)
[18:01:09.276]             base::close(...future.stdout)
[18:01:09.276]         }, add = TRUE)
[18:01:09.276]     }
[18:01:09.276]     ...future.frame <- base::sys.nframe()
[18:01:09.276]     ...future.conditions <- base::list()
[18:01:09.276]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.276]     if (FALSE) {
[18:01:09.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.276]     }
[18:01:09.276]     ...future.result <- base::tryCatch({
[18:01:09.276]         base::withCallingHandlers({
[18:01:09.276]             ...future.value <- base::withVisible(base::local({
[18:01:09.276]                 ...future.makeSendCondition <- base::local({
[18:01:09.276]                   sendCondition <- NULL
[18:01:09.276]                   function(frame = 1L) {
[18:01:09.276]                     if (is.function(sendCondition)) 
[18:01:09.276]                       return(sendCondition)
[18:01:09.276]                     ns <- getNamespace("parallel")
[18:01:09.276]                     if (exists("sendData", mode = "function", 
[18:01:09.276]                       envir = ns)) {
[18:01:09.276]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.276]                         envir = ns)
[18:01:09.276]                       envir <- sys.frame(frame)
[18:01:09.276]                       master <- NULL
[18:01:09.276]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.276]                         !identical(envir, emptyenv())) {
[18:01:09.276]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.276]                           inherits = FALSE)) {
[18:01:09.276]                           master <- get("master", mode = "list", 
[18:01:09.276]                             envir = envir, inherits = FALSE)
[18:01:09.276]                           if (inherits(master, c("SOCKnode", 
[18:01:09.276]                             "SOCK0node"))) {
[18:01:09.276]                             sendCondition <<- function(cond) {
[18:01:09.276]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.276]                                 success = TRUE)
[18:01:09.276]                               parallel_sendData(master, data)
[18:01:09.276]                             }
[18:01:09.276]                             return(sendCondition)
[18:01:09.276]                           }
[18:01:09.276]                         }
[18:01:09.276]                         frame <- frame + 1L
[18:01:09.276]                         envir <- sys.frame(frame)
[18:01:09.276]                       }
[18:01:09.276]                     }
[18:01:09.276]                     sendCondition <<- function(cond) NULL
[18:01:09.276]                   }
[18:01:09.276]                 })
[18:01:09.276]                 withCallingHandlers({
[18:01:09.276]                   {
[18:01:09.276]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.276]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.276]                       ...future.globals.maxSize)) {
[18:01:09.276]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.276]                       on.exit(options(oopts), add = TRUE)
[18:01:09.276]                     }
[18:01:09.276]                     {
[18:01:09.276]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:09.276]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[18:01:09.276]                           envir = globalenv(), inherits = FALSE)
[18:01:09.276]                         ...future.FUN(...)
[18:01:09.276]                       }
[18:01:09.276]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:09.276]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:09.276]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.276]                         USE.NAMES = FALSE)
[18:01:09.276]                       do.call(mapply, args = args)
[18:01:09.276]                     }
[18:01:09.276]                   }
[18:01:09.276]                 }, immediateCondition = function(cond) {
[18:01:09.276]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.276]                   sendCondition(cond)
[18:01:09.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.276]                   {
[18:01:09.276]                     inherits <- base::inherits
[18:01:09.276]                     invokeRestart <- base::invokeRestart
[18:01:09.276]                     is.null <- base::is.null
[18:01:09.276]                     muffled <- FALSE
[18:01:09.276]                     if (inherits(cond, "message")) {
[18:01:09.276]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.276]                       if (muffled) 
[18:01:09.276]                         invokeRestart("muffleMessage")
[18:01:09.276]                     }
[18:01:09.276]                     else if (inherits(cond, "warning")) {
[18:01:09.276]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.276]                       if (muffled) 
[18:01:09.276]                         invokeRestart("muffleWarning")
[18:01:09.276]                     }
[18:01:09.276]                     else if (inherits(cond, "condition")) {
[18:01:09.276]                       if (!is.null(pattern)) {
[18:01:09.276]                         computeRestarts <- base::computeRestarts
[18:01:09.276]                         grepl <- base::grepl
[18:01:09.276]                         restarts <- computeRestarts(cond)
[18:01:09.276]                         for (restart in restarts) {
[18:01:09.276]                           name <- restart$name
[18:01:09.276]                           if (is.null(name)) 
[18:01:09.276]                             next
[18:01:09.276]                           if (!grepl(pattern, name)) 
[18:01:09.276]                             next
[18:01:09.276]                           invokeRestart(restart)
[18:01:09.276]                           muffled <- TRUE
[18:01:09.276]                           break
[18:01:09.276]                         }
[18:01:09.276]                       }
[18:01:09.276]                     }
[18:01:09.276]                     invisible(muffled)
[18:01:09.276]                   }
[18:01:09.276]                   muffleCondition(cond)
[18:01:09.276]                 })
[18:01:09.276]             }))
[18:01:09.276]             future::FutureResult(value = ...future.value$value, 
[18:01:09.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.276]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.276]                     ...future.globalenv.names))
[18:01:09.276]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.276]         }, condition = base::local({
[18:01:09.276]             c <- base::c
[18:01:09.276]             inherits <- base::inherits
[18:01:09.276]             invokeRestart <- base::invokeRestart
[18:01:09.276]             length <- base::length
[18:01:09.276]             list <- base::list
[18:01:09.276]             seq.int <- base::seq.int
[18:01:09.276]             signalCondition <- base::signalCondition
[18:01:09.276]             sys.calls <- base::sys.calls
[18:01:09.276]             `[[` <- base::`[[`
[18:01:09.276]             `+` <- base::`+`
[18:01:09.276]             `<<-` <- base::`<<-`
[18:01:09.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.276]                   3L)]
[18:01:09.276]             }
[18:01:09.276]             function(cond) {
[18:01:09.276]                 is_error <- inherits(cond, "error")
[18:01:09.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.276]                   NULL)
[18:01:09.276]                 if (is_error) {
[18:01:09.276]                   sessionInformation <- function() {
[18:01:09.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.276]                       search = base::search(), system = base::Sys.info())
[18:01:09.276]                   }
[18:01:09.276]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.276]                     cond$call), session = sessionInformation(), 
[18:01:09.276]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.276]                   signalCondition(cond)
[18:01:09.276]                 }
[18:01:09.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.276]                 "immediateCondition"))) {
[18:01:09.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.276]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.276]                   if (TRUE && !signal) {
[18:01:09.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.276]                     {
[18:01:09.276]                       inherits <- base::inherits
[18:01:09.276]                       invokeRestart <- base::invokeRestart
[18:01:09.276]                       is.null <- base::is.null
[18:01:09.276]                       muffled <- FALSE
[18:01:09.276]                       if (inherits(cond, "message")) {
[18:01:09.276]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.276]                         if (muffled) 
[18:01:09.276]                           invokeRestart("muffleMessage")
[18:01:09.276]                       }
[18:01:09.276]                       else if (inherits(cond, "warning")) {
[18:01:09.276]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.276]                         if (muffled) 
[18:01:09.276]                           invokeRestart("muffleWarning")
[18:01:09.276]                       }
[18:01:09.276]                       else if (inherits(cond, "condition")) {
[18:01:09.276]                         if (!is.null(pattern)) {
[18:01:09.276]                           computeRestarts <- base::computeRestarts
[18:01:09.276]                           grepl <- base::grepl
[18:01:09.276]                           restarts <- computeRestarts(cond)
[18:01:09.276]                           for (restart in restarts) {
[18:01:09.276]                             name <- restart$name
[18:01:09.276]                             if (is.null(name)) 
[18:01:09.276]                               next
[18:01:09.276]                             if (!grepl(pattern, name)) 
[18:01:09.276]                               next
[18:01:09.276]                             invokeRestart(restart)
[18:01:09.276]                             muffled <- TRUE
[18:01:09.276]                             break
[18:01:09.276]                           }
[18:01:09.276]                         }
[18:01:09.276]                       }
[18:01:09.276]                       invisible(muffled)
[18:01:09.276]                     }
[18:01:09.276]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.276]                   }
[18:01:09.276]                 }
[18:01:09.276]                 else {
[18:01:09.276]                   if (TRUE) {
[18:01:09.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.276]                     {
[18:01:09.276]                       inherits <- base::inherits
[18:01:09.276]                       invokeRestart <- base::invokeRestart
[18:01:09.276]                       is.null <- base::is.null
[18:01:09.276]                       muffled <- FALSE
[18:01:09.276]                       if (inherits(cond, "message")) {
[18:01:09.276]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.276]                         if (muffled) 
[18:01:09.276]                           invokeRestart("muffleMessage")
[18:01:09.276]                       }
[18:01:09.276]                       else if (inherits(cond, "warning")) {
[18:01:09.276]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.276]                         if (muffled) 
[18:01:09.276]                           invokeRestart("muffleWarning")
[18:01:09.276]                       }
[18:01:09.276]                       else if (inherits(cond, "condition")) {
[18:01:09.276]                         if (!is.null(pattern)) {
[18:01:09.276]                           computeRestarts <- base::computeRestarts
[18:01:09.276]                           grepl <- base::grepl
[18:01:09.276]                           restarts <- computeRestarts(cond)
[18:01:09.276]                           for (restart in restarts) {
[18:01:09.276]                             name <- restart$name
[18:01:09.276]                             if (is.null(name)) 
[18:01:09.276]                               next
[18:01:09.276]                             if (!grepl(pattern, name)) 
[18:01:09.276]                               next
[18:01:09.276]                             invokeRestart(restart)
[18:01:09.276]                             muffled <- TRUE
[18:01:09.276]                             break
[18:01:09.276]                           }
[18:01:09.276]                         }
[18:01:09.276]                       }
[18:01:09.276]                       invisible(muffled)
[18:01:09.276]                     }
[18:01:09.276]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.276]                   }
[18:01:09.276]                 }
[18:01:09.276]             }
[18:01:09.276]         }))
[18:01:09.276]     }, error = function(ex) {
[18:01:09.276]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.276]                 ...future.rng), started = ...future.startTime, 
[18:01:09.276]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.276]             version = "1.8"), class = "FutureResult")
[18:01:09.276]     }, finally = {
[18:01:09.276]         if (!identical(...future.workdir, getwd())) 
[18:01:09.276]             setwd(...future.workdir)
[18:01:09.276]         {
[18:01:09.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.276]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.276]             }
[18:01:09.276]             base::options(...future.oldOptions)
[18:01:09.276]             if (.Platform$OS.type == "windows") {
[18:01:09.276]                 old_names <- names(...future.oldEnvVars)
[18:01:09.276]                 envs <- base::Sys.getenv()
[18:01:09.276]                 names <- names(envs)
[18:01:09.276]                 common <- intersect(names, old_names)
[18:01:09.276]                 added <- setdiff(names, old_names)
[18:01:09.276]                 removed <- setdiff(old_names, names)
[18:01:09.276]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.276]                   envs[common]]
[18:01:09.276]                 NAMES <- toupper(changed)
[18:01:09.276]                 args <- list()
[18:01:09.276]                 for (kk in seq_along(NAMES)) {
[18:01:09.276]                   name <- changed[[kk]]
[18:01:09.276]                   NAME <- NAMES[[kk]]
[18:01:09.276]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.276]                     next
[18:01:09.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.276]                 }
[18:01:09.276]                 NAMES <- toupper(added)
[18:01:09.276]                 for (kk in seq_along(NAMES)) {
[18:01:09.276]                   name <- added[[kk]]
[18:01:09.276]                   NAME <- NAMES[[kk]]
[18:01:09.276]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.276]                     next
[18:01:09.276]                   args[[name]] <- ""
[18:01:09.276]                 }
[18:01:09.276]                 NAMES <- toupper(removed)
[18:01:09.276]                 for (kk in seq_along(NAMES)) {
[18:01:09.276]                   name <- removed[[kk]]
[18:01:09.276]                   NAME <- NAMES[[kk]]
[18:01:09.276]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.276]                     next
[18:01:09.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.276]                 }
[18:01:09.276]                 if (length(args) > 0) 
[18:01:09.276]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.276]             }
[18:01:09.276]             else {
[18:01:09.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.276]             }
[18:01:09.276]             {
[18:01:09.276]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.276]                   0L) {
[18:01:09.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.276]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.276]                   base::options(opts)
[18:01:09.276]                 }
[18:01:09.276]                 {
[18:01:09.276]                   {
[18:01:09.276]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.276]                     NULL
[18:01:09.276]                   }
[18:01:09.276]                   options(future.plan = NULL)
[18:01:09.276]                   if (is.na(NA_character_)) 
[18:01:09.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.276]                     .init = FALSE)
[18:01:09.276]                 }
[18:01:09.276]             }
[18:01:09.276]         }
[18:01:09.276]     })
[18:01:09.276]     if (TRUE) {
[18:01:09.276]         base::sink(type = "output", split = FALSE)
[18:01:09.276]         if (TRUE) {
[18:01:09.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.276]         }
[18:01:09.276]         else {
[18:01:09.276]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.276]         }
[18:01:09.276]         base::close(...future.stdout)
[18:01:09.276]         ...future.stdout <- NULL
[18:01:09.276]     }
[18:01:09.276]     ...future.result$conditions <- ...future.conditions
[18:01:09.276]     ...future.result$finished <- base::Sys.time()
[18:01:09.276]     ...future.result
[18:01:09.276] }
[18:01:09.281] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[18:01:09.282] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[18:01:09.282] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[18:01:09.283] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[18:01:09.284] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[18:01:09.284] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:09.285] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:09.285] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[18:01:09.286] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[18:01:09.287] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:09.287] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.288] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[18:01:09.289] MultisessionFuture started
[18:01:09.289] - Launch lazy future ... done
[18:01:09.289] run() for ‘MultisessionFuture’ ... done
[18:01:09.289] Created future:
[18:01:09.289] MultisessionFuture:
[18:01:09.289] Label: ‘future_mapply-2’
[18:01:09.289] Expression:
[18:01:09.289] {
[18:01:09.289]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.289]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.289]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.289]         on.exit(options(oopts), add = TRUE)
[18:01:09.289]     }
[18:01:09.289]     {
[18:01:09.289]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[18:01:09.289]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[18:01:09.289]                 inherits = FALSE)
[18:01:09.289]             ...future.FUN(...)
[18:01:09.289]         }
[18:01:09.289]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[18:01:09.289]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[18:01:09.289]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.289]         do.call(mapply, args = args)
[18:01:09.289]     }
[18:01:09.289] }
[18:01:09.289] Lazy evaluation: FALSE
[18:01:09.289] Asynchronous evaluation: TRUE
[18:01:09.289] Local evaluation: TRUE
[18:01:09.289] Environment: R_GlobalEnv
[18:01:09.289] Capture standard output: TRUE
[18:01:09.289] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.289] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.289] Packages: 1 packages (‘stats’)
[18:01:09.289] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[18:01:09.289] Resolved: FALSE
[18:01:09.289] Value: <not collected>
[18:01:09.289] Conditions captured: <none>
[18:01:09.289] Early signaling: FALSE
[18:01:09.289] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.289] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.302] Chunk #2 of 2 ... DONE
[18:01:09.302] Launching 2 futures (chunks) ... DONE
[18:01:09.303] Resolving 2 futures (chunks) ...
[18:01:09.303] resolve() on list ...
[18:01:09.303]  recursive: 0
[18:01:09.303]  length: 2
[18:01:09.303] 
[18:01:09.304] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.305] - Validating connection of MultisessionFuture
[18:01:09.305] - received message: FutureResult
[18:01:09.305] - Received FutureResult
[18:01:09.305] - Erased future from FutureRegistry
[18:01:09.306] result() for ClusterFuture ...
[18:01:09.306] - result already collected: FutureResult
[18:01:09.306] result() for ClusterFuture ... done
[18:01:09.306] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.306] Future #1
[18:01:09.306] result() for ClusterFuture ...
[18:01:09.307] - result already collected: FutureResult
[18:01:09.307] result() for ClusterFuture ... done
[18:01:09.307] result() for ClusterFuture ...
[18:01:09.307] - result already collected: FutureResult
[18:01:09.307] result() for ClusterFuture ... done
[18:01:09.308] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:09.308] - nx: 2
[18:01:09.308] - relay: TRUE
[18:01:09.308] - stdout: TRUE
[18:01:09.308] - signal: TRUE
[18:01:09.308] - resignal: FALSE
[18:01:09.309] - force: TRUE
[18:01:09.309] - relayed: [n=2] FALSE, FALSE
[18:01:09.309] - queued futures: [n=2] FALSE, FALSE
[18:01:09.309]  - until=1
[18:01:09.309]  - relaying element #1
[18:01:09.309] result() for ClusterFuture ...
[18:01:09.310] - result already collected: FutureResult
[18:01:09.310] result() for ClusterFuture ... done
[18:01:09.310] result() for ClusterFuture ...
[18:01:09.310] - result already collected: FutureResult
[18:01:09.310] result() for ClusterFuture ... done
[18:01:09.311] result() for ClusterFuture ...
[18:01:09.311] - result already collected: FutureResult
[18:01:09.311] result() for ClusterFuture ... done
[18:01:09.311] result() for ClusterFuture ...
[18:01:09.311] - result already collected: FutureResult
[18:01:09.311] result() for ClusterFuture ... done
[18:01:09.312] - relayed: [n=2] TRUE, FALSE
[18:01:09.312] - queued futures: [n=2] TRUE, FALSE
[18:01:09.312] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:09.312]  length: 1 (resolved future 1)
[18:01:09.334] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.335] - Validating connection of MultisessionFuture
[18:01:09.335] - received message: FutureResult
[18:01:09.335] - Received FutureResult
[18:01:09.335] - Erased future from FutureRegistry
[18:01:09.336] result() for ClusterFuture ...
[18:01:09.336] - result already collected: FutureResult
[18:01:09.336] result() for ClusterFuture ... done
[18:01:09.336] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.336] Future #2
[18:01:09.337] result() for ClusterFuture ...
[18:01:09.337] - result already collected: FutureResult
[18:01:09.337] result() for ClusterFuture ... done
[18:01:09.337] result() for ClusterFuture ...
[18:01:09.337] - result already collected: FutureResult
[18:01:09.338] result() for ClusterFuture ... done
[18:01:09.338] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:09.338] - nx: 2
[18:01:09.338] - relay: TRUE
[18:01:09.338] - stdout: TRUE
[18:01:09.338] - signal: TRUE
[18:01:09.339] - resignal: FALSE
[18:01:09.339] - force: TRUE
[18:01:09.339] - relayed: [n=2] TRUE, FALSE
[18:01:09.339] - queued futures: [n=2] TRUE, FALSE
[18:01:09.339]  - until=2
[18:01:09.340]  - relaying element #2
[18:01:09.340] result() for ClusterFuture ...
[18:01:09.340] - result already collected: FutureResult
[18:01:09.340] result() for ClusterFuture ... done
[18:01:09.340] result() for ClusterFuture ...
[18:01:09.341] - result already collected: FutureResult
[18:01:09.341] result() for ClusterFuture ... done
[18:01:09.341] result() for ClusterFuture ...
[18:01:09.341] - result already collected: FutureResult
[18:01:09.341] result() for ClusterFuture ... done
[18:01:09.342] result() for ClusterFuture ...
[18:01:09.342] - result already collected: FutureResult
[18:01:09.342] result() for ClusterFuture ... done
[18:01:09.342] - relayed: [n=2] TRUE, TRUE
[18:01:09.342] - queued futures: [n=2] TRUE, TRUE
[18:01:09.343] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:09.343]  length: 0 (resolved future 2)
[18:01:09.343] Relaying remaining futures
[18:01:09.343] signalConditionsASAP(NULL, pos=0) ...
[18:01:09.343] - nx: 2
[18:01:09.344] - relay: TRUE
[18:01:09.344] - stdout: TRUE
[18:01:09.344] - signal: TRUE
[18:01:09.344] - resignal: FALSE
[18:01:09.344] - force: TRUE
[18:01:09.344] - relayed: [n=2] TRUE, TRUE
[18:01:09.345] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:09.345] - relayed: [n=2] TRUE, TRUE
[18:01:09.345] - queued futures: [n=2] TRUE, TRUE
[18:01:09.345] signalConditionsASAP(NULL, pos=0) ... done
[18:01:09.346] resolve() on list ... DONE
[18:01:09.346] result() for ClusterFuture ...
[18:01:09.346] - result already collected: FutureResult
[18:01:09.346] result() for ClusterFuture ... done
[18:01:09.346] result() for ClusterFuture ...
[18:01:09.346] - result already collected: FutureResult
[18:01:09.347] result() for ClusterFuture ... done
[18:01:09.347] result() for ClusterFuture ...
[18:01:09.347] - result already collected: FutureResult
[18:01:09.348] result() for ClusterFuture ... done
[18:01:09.348] result() for ClusterFuture ...
[18:01:09.348] - result already collected: FutureResult
[18:01:09.348] result() for ClusterFuture ... done
[18:01:09.348]  - Number of value chunks collected: 2
[18:01:09.349] Resolving 2 futures (chunks) ... DONE
[18:01:09.349] Reducing values from 2 chunks ...
[18:01:09.349]  - Number of values collected after concatenation: 4
[18:01:09.349]  - Number of values expected: 4
[18:01:09.349] Reducing values from 2 chunks ... DONE
[18:01:09.350] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[18:01:09.350] future_mapply() ...
[18:01:09.356] Number of chunks: 2
[18:01:09.357] getGlobalsAndPackagesXApply() ...
[18:01:09.357]  - future.globals: TRUE
[18:01:09.357] getGlobalsAndPackages() ...
[18:01:09.357] Searching for globals...
[18:01:09.360] - globals found: [2] ‘FUN’, ‘UseMethod’
[18:01:09.360] Searching for globals ... DONE
[18:01:09.361] Resolving globals: FALSE
[18:01:09.361] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[18:01:09.362] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[18:01:09.362] - globals: [1] ‘FUN’
[18:01:09.362] - packages: [1] ‘stats’
[18:01:09.363] getGlobalsAndPackages() ... DONE
[18:01:09.363]  - globals found/used: [n=1] ‘FUN’
[18:01:09.363]  - needed namespaces: [n=1] ‘stats’
[18:01:09.363] Finding globals ... DONE
[18:01:09.364] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:09.364] List of 2
[18:01:09.364]  $ ...future.FUN:function (x, w, ...)  
[18:01:09.364]  $ MoreArgs     : NULL
[18:01:09.364]  - attr(*, "where")=List of 2
[18:01:09.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:09.364]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:09.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:09.364]  - attr(*, "resolved")= logi FALSE
[18:01:09.364]  - attr(*, "total_size")= num NA
[18:01:09.369] Packages to be attached in all futures: [n=1] ‘stats’
[18:01:09.369] getGlobalsAndPackagesXApply() ... DONE
[18:01:09.370] Number of futures (= number of chunks): 2
[18:01:09.370] Launching 2 futures (chunks) ...
[18:01:09.370] Chunk #1 of 2 ...
[18:01:09.371]  - Finding globals in '...' for chunk #1 ...
[18:01:09.371] getGlobalsAndPackages() ...
[18:01:09.371] Searching for globals...
[18:01:09.372] 
[18:01:09.372] Searching for globals ... DONE
[18:01:09.372] - globals: [0] <none>
[18:01:09.372] getGlobalsAndPackages() ... DONE
[18:01:09.372]    + additional globals found: [n=0] 
[18:01:09.373]    + additional namespaces needed: [n=0] 
[18:01:09.373]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:09.373]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.373]  - seeds: <none>
[18:01:09.373]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.374] getGlobalsAndPackages() ...
[18:01:09.374] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.374] Resolving globals: FALSE
[18:01:09.375] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[18:01:09.376] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.377] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.377] - packages: [1] ‘stats’
[18:01:09.377] getGlobalsAndPackages() ... DONE
[18:01:09.378] run() for ‘Future’ ...
[18:01:09.378] - state: ‘created’
[18:01:09.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.400]   - Field: ‘node’
[18:01:09.401]   - Field: ‘label’
[18:01:09.401]   - Field: ‘local’
[18:01:09.401]   - Field: ‘owner’
[18:01:09.401]   - Field: ‘envir’
[18:01:09.401]   - Field: ‘workers’
[18:01:09.402]   - Field: ‘packages’
[18:01:09.402]   - Field: ‘gc’
[18:01:09.402]   - Field: ‘conditions’
[18:01:09.402]   - Field: ‘persistent’
[18:01:09.402]   - Field: ‘expr’
[18:01:09.403]   - Field: ‘uuid’
[18:01:09.403]   - Field: ‘seed’
[18:01:09.403]   - Field: ‘version’
[18:01:09.403]   - Field: ‘result’
[18:01:09.403]   - Field: ‘asynchronous’
[18:01:09.403]   - Field: ‘calls’
[18:01:09.404]   - Field: ‘globals’
[18:01:09.404]   - Field: ‘stdout’
[18:01:09.404]   - Field: ‘earlySignal’
[18:01:09.404]   - Field: ‘lazy’
[18:01:09.404]   - Field: ‘state’
[18:01:09.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.405] - Launch lazy future ...
[18:01:09.405] Packages needed by the future expression (n = 1): ‘stats’
[18:01:09.406] Packages needed by future strategies (n = 0): <none>
[18:01:09.407] {
[18:01:09.407]     {
[18:01:09.407]         {
[18:01:09.407]             ...future.startTime <- base::Sys.time()
[18:01:09.407]             {
[18:01:09.407]                 {
[18:01:09.407]                   {
[18:01:09.407]                     {
[18:01:09.407]                       {
[18:01:09.407]                         base::local({
[18:01:09.407]                           has_future <- base::requireNamespace("future", 
[18:01:09.407]                             quietly = TRUE)
[18:01:09.407]                           if (has_future) {
[18:01:09.407]                             ns <- base::getNamespace("future")
[18:01:09.407]                             version <- ns[[".package"]][["version"]]
[18:01:09.407]                             if (is.null(version)) 
[18:01:09.407]                               version <- utils::packageVersion("future")
[18:01:09.407]                           }
[18:01:09.407]                           else {
[18:01:09.407]                             version <- NULL
[18:01:09.407]                           }
[18:01:09.407]                           if (!has_future || version < "1.8.0") {
[18:01:09.407]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.407]                               "", base::R.version$version.string), 
[18:01:09.407]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:09.407]                                 base::R.version$platform, 8 * 
[18:01:09.407]                                   base::.Machine$sizeof.pointer), 
[18:01:09.407]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.407]                                 "release", "version")], collapse = " "), 
[18:01:09.407]                               hostname = base::Sys.info()[["nodename"]])
[18:01:09.407]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.407]                               info)
[18:01:09.407]                             info <- base::paste(info, collapse = "; ")
[18:01:09.407]                             if (!has_future) {
[18:01:09.407]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.407]                                 info)
[18:01:09.407]                             }
[18:01:09.407]                             else {
[18:01:09.407]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.407]                                 info, version)
[18:01:09.407]                             }
[18:01:09.407]                             base::stop(msg)
[18:01:09.407]                           }
[18:01:09.407]                         })
[18:01:09.407]                       }
[18:01:09.407]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.407]                       base::options(mc.cores = 1L)
[18:01:09.407]                     }
[18:01:09.407]                     base::local({
[18:01:09.407]                       for (pkg in "stats") {
[18:01:09.407]                         base::loadNamespace(pkg)
[18:01:09.407]                         base::library(pkg, character.only = TRUE)
[18:01:09.407]                       }
[18:01:09.407]                     })
[18:01:09.407]                   }
[18:01:09.407]                   ...future.strategy.old <- future::plan("list")
[18:01:09.407]                   options(future.plan = NULL)
[18:01:09.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.407]                 }
[18:01:09.407]                 ...future.workdir <- getwd()
[18:01:09.407]             }
[18:01:09.407]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.407]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.407]         }
[18:01:09.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.407]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.407]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.407]             base::names(...future.oldOptions))
[18:01:09.407]     }
[18:01:09.407]     if (FALSE) {
[18:01:09.407]     }
[18:01:09.407]     else {
[18:01:09.407]         if (TRUE) {
[18:01:09.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.407]                 open = "w")
[18:01:09.407]         }
[18:01:09.407]         else {
[18:01:09.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.407]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.407]         }
[18:01:09.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.407]             base::sink(type = "output", split = FALSE)
[18:01:09.407]             base::close(...future.stdout)
[18:01:09.407]         }, add = TRUE)
[18:01:09.407]     }
[18:01:09.407]     ...future.frame <- base::sys.nframe()
[18:01:09.407]     ...future.conditions <- base::list()
[18:01:09.407]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.407]     if (FALSE) {
[18:01:09.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.407]     }
[18:01:09.407]     ...future.result <- base::tryCatch({
[18:01:09.407]         base::withCallingHandlers({
[18:01:09.407]             ...future.value <- base::withVisible(base::local({
[18:01:09.407]                 ...future.makeSendCondition <- base::local({
[18:01:09.407]                   sendCondition <- NULL
[18:01:09.407]                   function(frame = 1L) {
[18:01:09.407]                     if (is.function(sendCondition)) 
[18:01:09.407]                       return(sendCondition)
[18:01:09.407]                     ns <- getNamespace("parallel")
[18:01:09.407]                     if (exists("sendData", mode = "function", 
[18:01:09.407]                       envir = ns)) {
[18:01:09.407]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.407]                         envir = ns)
[18:01:09.407]                       envir <- sys.frame(frame)
[18:01:09.407]                       master <- NULL
[18:01:09.407]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.407]                         !identical(envir, emptyenv())) {
[18:01:09.407]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.407]                           inherits = FALSE)) {
[18:01:09.407]                           master <- get("master", mode = "list", 
[18:01:09.407]                             envir = envir, inherits = FALSE)
[18:01:09.407]                           if (inherits(master, c("SOCKnode", 
[18:01:09.407]                             "SOCK0node"))) {
[18:01:09.407]                             sendCondition <<- function(cond) {
[18:01:09.407]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.407]                                 success = TRUE)
[18:01:09.407]                               parallel_sendData(master, data)
[18:01:09.407]                             }
[18:01:09.407]                             return(sendCondition)
[18:01:09.407]                           }
[18:01:09.407]                         }
[18:01:09.407]                         frame <- frame + 1L
[18:01:09.407]                         envir <- sys.frame(frame)
[18:01:09.407]                       }
[18:01:09.407]                     }
[18:01:09.407]                     sendCondition <<- function(cond) NULL
[18:01:09.407]                   }
[18:01:09.407]                 })
[18:01:09.407]                 withCallingHandlers({
[18:01:09.407]                   {
[18:01:09.407]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.407]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.407]                       ...future.globals.maxSize)) {
[18:01:09.407]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.407]                       on.exit(options(oopts), add = TRUE)
[18:01:09.407]                     }
[18:01:09.407]                     {
[18:01:09.407]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.407]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.407]                         USE.NAMES = FALSE)
[18:01:09.407]                       do.call(mapply, args = args)
[18:01:09.407]                     }
[18:01:09.407]                   }
[18:01:09.407]                 }, immediateCondition = function(cond) {
[18:01:09.407]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.407]                   sendCondition(cond)
[18:01:09.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.407]                   {
[18:01:09.407]                     inherits <- base::inherits
[18:01:09.407]                     invokeRestart <- base::invokeRestart
[18:01:09.407]                     is.null <- base::is.null
[18:01:09.407]                     muffled <- FALSE
[18:01:09.407]                     if (inherits(cond, "message")) {
[18:01:09.407]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.407]                       if (muffled) 
[18:01:09.407]                         invokeRestart("muffleMessage")
[18:01:09.407]                     }
[18:01:09.407]                     else if (inherits(cond, "warning")) {
[18:01:09.407]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.407]                       if (muffled) 
[18:01:09.407]                         invokeRestart("muffleWarning")
[18:01:09.407]                     }
[18:01:09.407]                     else if (inherits(cond, "condition")) {
[18:01:09.407]                       if (!is.null(pattern)) {
[18:01:09.407]                         computeRestarts <- base::computeRestarts
[18:01:09.407]                         grepl <- base::grepl
[18:01:09.407]                         restarts <- computeRestarts(cond)
[18:01:09.407]                         for (restart in restarts) {
[18:01:09.407]                           name <- restart$name
[18:01:09.407]                           if (is.null(name)) 
[18:01:09.407]                             next
[18:01:09.407]                           if (!grepl(pattern, name)) 
[18:01:09.407]                             next
[18:01:09.407]                           invokeRestart(restart)
[18:01:09.407]                           muffled <- TRUE
[18:01:09.407]                           break
[18:01:09.407]                         }
[18:01:09.407]                       }
[18:01:09.407]                     }
[18:01:09.407]                     invisible(muffled)
[18:01:09.407]                   }
[18:01:09.407]                   muffleCondition(cond)
[18:01:09.407]                 })
[18:01:09.407]             }))
[18:01:09.407]             future::FutureResult(value = ...future.value$value, 
[18:01:09.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.407]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.407]                     ...future.globalenv.names))
[18:01:09.407]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.407]         }, condition = base::local({
[18:01:09.407]             c <- base::c
[18:01:09.407]             inherits <- base::inherits
[18:01:09.407]             invokeRestart <- base::invokeRestart
[18:01:09.407]             length <- base::length
[18:01:09.407]             list <- base::list
[18:01:09.407]             seq.int <- base::seq.int
[18:01:09.407]             signalCondition <- base::signalCondition
[18:01:09.407]             sys.calls <- base::sys.calls
[18:01:09.407]             `[[` <- base::`[[`
[18:01:09.407]             `+` <- base::`+`
[18:01:09.407]             `<<-` <- base::`<<-`
[18:01:09.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.407]                   3L)]
[18:01:09.407]             }
[18:01:09.407]             function(cond) {
[18:01:09.407]                 is_error <- inherits(cond, "error")
[18:01:09.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.407]                   NULL)
[18:01:09.407]                 if (is_error) {
[18:01:09.407]                   sessionInformation <- function() {
[18:01:09.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.407]                       search = base::search(), system = base::Sys.info())
[18:01:09.407]                   }
[18:01:09.407]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.407]                     cond$call), session = sessionInformation(), 
[18:01:09.407]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.407]                   signalCondition(cond)
[18:01:09.407]                 }
[18:01:09.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.407]                 "immediateCondition"))) {
[18:01:09.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.407]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.407]                   if (TRUE && !signal) {
[18:01:09.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.407]                     {
[18:01:09.407]                       inherits <- base::inherits
[18:01:09.407]                       invokeRestart <- base::invokeRestart
[18:01:09.407]                       is.null <- base::is.null
[18:01:09.407]                       muffled <- FALSE
[18:01:09.407]                       if (inherits(cond, "message")) {
[18:01:09.407]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.407]                         if (muffled) 
[18:01:09.407]                           invokeRestart("muffleMessage")
[18:01:09.407]                       }
[18:01:09.407]                       else if (inherits(cond, "warning")) {
[18:01:09.407]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.407]                         if (muffled) 
[18:01:09.407]                           invokeRestart("muffleWarning")
[18:01:09.407]                       }
[18:01:09.407]                       else if (inherits(cond, "condition")) {
[18:01:09.407]                         if (!is.null(pattern)) {
[18:01:09.407]                           computeRestarts <- base::computeRestarts
[18:01:09.407]                           grepl <- base::grepl
[18:01:09.407]                           restarts <- computeRestarts(cond)
[18:01:09.407]                           for (restart in restarts) {
[18:01:09.407]                             name <- restart$name
[18:01:09.407]                             if (is.null(name)) 
[18:01:09.407]                               next
[18:01:09.407]                             if (!grepl(pattern, name)) 
[18:01:09.407]                               next
[18:01:09.407]                             invokeRestart(restart)
[18:01:09.407]                             muffled <- TRUE
[18:01:09.407]                             break
[18:01:09.407]                           }
[18:01:09.407]                         }
[18:01:09.407]                       }
[18:01:09.407]                       invisible(muffled)
[18:01:09.407]                     }
[18:01:09.407]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.407]                   }
[18:01:09.407]                 }
[18:01:09.407]                 else {
[18:01:09.407]                   if (TRUE) {
[18:01:09.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.407]                     {
[18:01:09.407]                       inherits <- base::inherits
[18:01:09.407]                       invokeRestart <- base::invokeRestart
[18:01:09.407]                       is.null <- base::is.null
[18:01:09.407]                       muffled <- FALSE
[18:01:09.407]                       if (inherits(cond, "message")) {
[18:01:09.407]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.407]                         if (muffled) 
[18:01:09.407]                           invokeRestart("muffleMessage")
[18:01:09.407]                       }
[18:01:09.407]                       else if (inherits(cond, "warning")) {
[18:01:09.407]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.407]                         if (muffled) 
[18:01:09.407]                           invokeRestart("muffleWarning")
[18:01:09.407]                       }
[18:01:09.407]                       else if (inherits(cond, "condition")) {
[18:01:09.407]                         if (!is.null(pattern)) {
[18:01:09.407]                           computeRestarts <- base::computeRestarts
[18:01:09.407]                           grepl <- base::grepl
[18:01:09.407]                           restarts <- computeRestarts(cond)
[18:01:09.407]                           for (restart in restarts) {
[18:01:09.407]                             name <- restart$name
[18:01:09.407]                             if (is.null(name)) 
[18:01:09.407]                               next
[18:01:09.407]                             if (!grepl(pattern, name)) 
[18:01:09.407]                               next
[18:01:09.407]                             invokeRestart(restart)
[18:01:09.407]                             muffled <- TRUE
[18:01:09.407]                             break
[18:01:09.407]                           }
[18:01:09.407]                         }
[18:01:09.407]                       }
[18:01:09.407]                       invisible(muffled)
[18:01:09.407]                     }
[18:01:09.407]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.407]                   }
[18:01:09.407]                 }
[18:01:09.407]             }
[18:01:09.407]         }))
[18:01:09.407]     }, error = function(ex) {
[18:01:09.407]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.407]                 ...future.rng), started = ...future.startTime, 
[18:01:09.407]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.407]             version = "1.8"), class = "FutureResult")
[18:01:09.407]     }, finally = {
[18:01:09.407]         if (!identical(...future.workdir, getwd())) 
[18:01:09.407]             setwd(...future.workdir)
[18:01:09.407]         {
[18:01:09.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.407]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.407]             }
[18:01:09.407]             base::options(...future.oldOptions)
[18:01:09.407]             if (.Platform$OS.type == "windows") {
[18:01:09.407]                 old_names <- names(...future.oldEnvVars)
[18:01:09.407]                 envs <- base::Sys.getenv()
[18:01:09.407]                 names <- names(envs)
[18:01:09.407]                 common <- intersect(names, old_names)
[18:01:09.407]                 added <- setdiff(names, old_names)
[18:01:09.407]                 removed <- setdiff(old_names, names)
[18:01:09.407]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.407]                   envs[common]]
[18:01:09.407]                 NAMES <- toupper(changed)
[18:01:09.407]                 args <- list()
[18:01:09.407]                 for (kk in seq_along(NAMES)) {
[18:01:09.407]                   name <- changed[[kk]]
[18:01:09.407]                   NAME <- NAMES[[kk]]
[18:01:09.407]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.407]                     next
[18:01:09.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.407]                 }
[18:01:09.407]                 NAMES <- toupper(added)
[18:01:09.407]                 for (kk in seq_along(NAMES)) {
[18:01:09.407]                   name <- added[[kk]]
[18:01:09.407]                   NAME <- NAMES[[kk]]
[18:01:09.407]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.407]                     next
[18:01:09.407]                   args[[name]] <- ""
[18:01:09.407]                 }
[18:01:09.407]                 NAMES <- toupper(removed)
[18:01:09.407]                 for (kk in seq_along(NAMES)) {
[18:01:09.407]                   name <- removed[[kk]]
[18:01:09.407]                   NAME <- NAMES[[kk]]
[18:01:09.407]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.407]                     next
[18:01:09.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.407]                 }
[18:01:09.407]                 if (length(args) > 0) 
[18:01:09.407]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.407]             }
[18:01:09.407]             else {
[18:01:09.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.407]             }
[18:01:09.407]             {
[18:01:09.407]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.407]                   0L) {
[18:01:09.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.407]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.407]                   base::options(opts)
[18:01:09.407]                 }
[18:01:09.407]                 {
[18:01:09.407]                   {
[18:01:09.407]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.407]                     NULL
[18:01:09.407]                   }
[18:01:09.407]                   options(future.plan = NULL)
[18:01:09.407]                   if (is.na(NA_character_)) 
[18:01:09.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.407]                     .init = FALSE)
[18:01:09.407]                 }
[18:01:09.407]             }
[18:01:09.407]         }
[18:01:09.407]     })
[18:01:09.407]     if (TRUE) {
[18:01:09.407]         base::sink(type = "output", split = FALSE)
[18:01:09.407]         if (TRUE) {
[18:01:09.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.407]         }
[18:01:09.407]         else {
[18:01:09.407]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.407]         }
[18:01:09.407]         base::close(...future.stdout)
[18:01:09.407]         ...future.stdout <- NULL
[18:01:09.407]     }
[18:01:09.407]     ...future.result$conditions <- ...future.conditions
[18:01:09.407]     ...future.result$finished <- base::Sys.time()
[18:01:09.407]     ...future.result
[18:01:09.407] }
[18:01:09.412] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[18:01:09.412] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[18:01:09.413] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[18:01:09.413] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:09.414] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.414] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[18:01:09.415] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[18:01:09.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:09.416] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.417] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:09.417] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.418] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[18:01:09.419] MultisessionFuture started
[18:01:09.419] - Launch lazy future ... done
[18:01:09.419] run() for ‘MultisessionFuture’ ... done
[18:01:09.419] Created future:
[18:01:09.419] MultisessionFuture:
[18:01:09.419] Label: ‘future_Map-1’
[18:01:09.419] Expression:
[18:01:09.419] {
[18:01:09.419]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.419]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.419]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.419]         on.exit(options(oopts), add = TRUE)
[18:01:09.419]     }
[18:01:09.419]     {
[18:01:09.419]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.419]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.419]         do.call(mapply, args = args)
[18:01:09.419]     }
[18:01:09.419] }
[18:01:09.419] Lazy evaluation: FALSE
[18:01:09.419] Asynchronous evaluation: TRUE
[18:01:09.419] Local evaluation: TRUE
[18:01:09.419] Environment: R_GlobalEnv
[18:01:09.419] Capture standard output: TRUE
[18:01:09.419] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.419] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.419] Packages: 1 packages (‘stats’)
[18:01:09.419] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.419] Resolved: FALSE
[18:01:09.419] Value: <not collected>
[18:01:09.419] Conditions captured: <none>
[18:01:09.419] Early signaling: FALSE
[18:01:09.419] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.419] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.432] Chunk #1 of 2 ... DONE
[18:01:09.432] Chunk #2 of 2 ...
[18:01:09.433]  - Finding globals in '...' for chunk #2 ...
[18:01:09.433] getGlobalsAndPackages() ...
[18:01:09.433] Searching for globals...
[18:01:09.434] 
[18:01:09.434] Searching for globals ... DONE
[18:01:09.434] - globals: [0] <none>
[18:01:09.434] getGlobalsAndPackages() ... DONE
[18:01:09.435]    + additional globals found: [n=0] 
[18:01:09.435]    + additional namespaces needed: [n=0] 
[18:01:09.435]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:09.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.435]  - seeds: <none>
[18:01:09.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.436] getGlobalsAndPackages() ...
[18:01:09.436] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.436] Resolving globals: FALSE
[18:01:09.437] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[18:01:09.438] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.438] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.439] - packages: [1] ‘stats’
[18:01:09.439] getGlobalsAndPackages() ... DONE
[18:01:09.439] run() for ‘Future’ ...
[18:01:09.440] - state: ‘created’
[18:01:09.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.462] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.463]   - Field: ‘node’
[18:01:09.463]   - Field: ‘label’
[18:01:09.463]   - Field: ‘local’
[18:01:09.463]   - Field: ‘owner’
[18:01:09.463]   - Field: ‘envir’
[18:01:09.464]   - Field: ‘workers’
[18:01:09.464]   - Field: ‘packages’
[18:01:09.464]   - Field: ‘gc’
[18:01:09.464]   - Field: ‘conditions’
[18:01:09.464]   - Field: ‘persistent’
[18:01:09.465]   - Field: ‘expr’
[18:01:09.465]   - Field: ‘uuid’
[18:01:09.465]   - Field: ‘seed’
[18:01:09.465]   - Field: ‘version’
[18:01:09.465]   - Field: ‘result’
[18:01:09.466]   - Field: ‘asynchronous’
[18:01:09.466]   - Field: ‘calls’
[18:01:09.466]   - Field: ‘globals’
[18:01:09.466]   - Field: ‘stdout’
[18:01:09.466]   - Field: ‘earlySignal’
[18:01:09.467]   - Field: ‘lazy’
[18:01:09.467]   - Field: ‘state’
[18:01:09.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.467] - Launch lazy future ...
[18:01:09.468] Packages needed by the future expression (n = 1): ‘stats’
[18:01:09.468] Packages needed by future strategies (n = 0): <none>
[18:01:09.469] {
[18:01:09.469]     {
[18:01:09.469]         {
[18:01:09.469]             ...future.startTime <- base::Sys.time()
[18:01:09.469]             {
[18:01:09.469]                 {
[18:01:09.469]                   {
[18:01:09.469]                     {
[18:01:09.469]                       {
[18:01:09.469]                         base::local({
[18:01:09.469]                           has_future <- base::requireNamespace("future", 
[18:01:09.469]                             quietly = TRUE)
[18:01:09.469]                           if (has_future) {
[18:01:09.469]                             ns <- base::getNamespace("future")
[18:01:09.469]                             version <- ns[[".package"]][["version"]]
[18:01:09.469]                             if (is.null(version)) 
[18:01:09.469]                               version <- utils::packageVersion("future")
[18:01:09.469]                           }
[18:01:09.469]                           else {
[18:01:09.469]                             version <- NULL
[18:01:09.469]                           }
[18:01:09.469]                           if (!has_future || version < "1.8.0") {
[18:01:09.469]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.469]                               "", base::R.version$version.string), 
[18:01:09.469]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:09.469]                                 base::R.version$platform, 8 * 
[18:01:09.469]                                   base::.Machine$sizeof.pointer), 
[18:01:09.469]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.469]                                 "release", "version")], collapse = " "), 
[18:01:09.469]                               hostname = base::Sys.info()[["nodename"]])
[18:01:09.469]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.469]                               info)
[18:01:09.469]                             info <- base::paste(info, collapse = "; ")
[18:01:09.469]                             if (!has_future) {
[18:01:09.469]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.469]                                 info)
[18:01:09.469]                             }
[18:01:09.469]                             else {
[18:01:09.469]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.469]                                 info, version)
[18:01:09.469]                             }
[18:01:09.469]                             base::stop(msg)
[18:01:09.469]                           }
[18:01:09.469]                         })
[18:01:09.469]                       }
[18:01:09.469]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.469]                       base::options(mc.cores = 1L)
[18:01:09.469]                     }
[18:01:09.469]                     base::local({
[18:01:09.469]                       for (pkg in "stats") {
[18:01:09.469]                         base::loadNamespace(pkg)
[18:01:09.469]                         base::library(pkg, character.only = TRUE)
[18:01:09.469]                       }
[18:01:09.469]                     })
[18:01:09.469]                   }
[18:01:09.469]                   ...future.strategy.old <- future::plan("list")
[18:01:09.469]                   options(future.plan = NULL)
[18:01:09.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.469]                 }
[18:01:09.469]                 ...future.workdir <- getwd()
[18:01:09.469]             }
[18:01:09.469]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.469]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.469]         }
[18:01:09.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.469]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.469]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.469]             base::names(...future.oldOptions))
[18:01:09.469]     }
[18:01:09.469]     if (FALSE) {
[18:01:09.469]     }
[18:01:09.469]     else {
[18:01:09.469]         if (TRUE) {
[18:01:09.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.469]                 open = "w")
[18:01:09.469]         }
[18:01:09.469]         else {
[18:01:09.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.469]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.469]         }
[18:01:09.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.469]             base::sink(type = "output", split = FALSE)
[18:01:09.469]             base::close(...future.stdout)
[18:01:09.469]         }, add = TRUE)
[18:01:09.469]     }
[18:01:09.469]     ...future.frame <- base::sys.nframe()
[18:01:09.469]     ...future.conditions <- base::list()
[18:01:09.469]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.469]     if (FALSE) {
[18:01:09.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.469]     }
[18:01:09.469]     ...future.result <- base::tryCatch({
[18:01:09.469]         base::withCallingHandlers({
[18:01:09.469]             ...future.value <- base::withVisible(base::local({
[18:01:09.469]                 ...future.makeSendCondition <- base::local({
[18:01:09.469]                   sendCondition <- NULL
[18:01:09.469]                   function(frame = 1L) {
[18:01:09.469]                     if (is.function(sendCondition)) 
[18:01:09.469]                       return(sendCondition)
[18:01:09.469]                     ns <- getNamespace("parallel")
[18:01:09.469]                     if (exists("sendData", mode = "function", 
[18:01:09.469]                       envir = ns)) {
[18:01:09.469]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.469]                         envir = ns)
[18:01:09.469]                       envir <- sys.frame(frame)
[18:01:09.469]                       master <- NULL
[18:01:09.469]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.469]                         !identical(envir, emptyenv())) {
[18:01:09.469]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.469]                           inherits = FALSE)) {
[18:01:09.469]                           master <- get("master", mode = "list", 
[18:01:09.469]                             envir = envir, inherits = FALSE)
[18:01:09.469]                           if (inherits(master, c("SOCKnode", 
[18:01:09.469]                             "SOCK0node"))) {
[18:01:09.469]                             sendCondition <<- function(cond) {
[18:01:09.469]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.469]                                 success = TRUE)
[18:01:09.469]                               parallel_sendData(master, data)
[18:01:09.469]                             }
[18:01:09.469]                             return(sendCondition)
[18:01:09.469]                           }
[18:01:09.469]                         }
[18:01:09.469]                         frame <- frame + 1L
[18:01:09.469]                         envir <- sys.frame(frame)
[18:01:09.469]                       }
[18:01:09.469]                     }
[18:01:09.469]                     sendCondition <<- function(cond) NULL
[18:01:09.469]                   }
[18:01:09.469]                 })
[18:01:09.469]                 withCallingHandlers({
[18:01:09.469]                   {
[18:01:09.469]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.469]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.469]                       ...future.globals.maxSize)) {
[18:01:09.469]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.469]                       on.exit(options(oopts), add = TRUE)
[18:01:09.469]                     }
[18:01:09.469]                     {
[18:01:09.469]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.469]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.469]                         USE.NAMES = FALSE)
[18:01:09.469]                       do.call(mapply, args = args)
[18:01:09.469]                     }
[18:01:09.469]                   }
[18:01:09.469]                 }, immediateCondition = function(cond) {
[18:01:09.469]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.469]                   sendCondition(cond)
[18:01:09.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.469]                   {
[18:01:09.469]                     inherits <- base::inherits
[18:01:09.469]                     invokeRestart <- base::invokeRestart
[18:01:09.469]                     is.null <- base::is.null
[18:01:09.469]                     muffled <- FALSE
[18:01:09.469]                     if (inherits(cond, "message")) {
[18:01:09.469]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.469]                       if (muffled) 
[18:01:09.469]                         invokeRestart("muffleMessage")
[18:01:09.469]                     }
[18:01:09.469]                     else if (inherits(cond, "warning")) {
[18:01:09.469]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.469]                       if (muffled) 
[18:01:09.469]                         invokeRestart("muffleWarning")
[18:01:09.469]                     }
[18:01:09.469]                     else if (inherits(cond, "condition")) {
[18:01:09.469]                       if (!is.null(pattern)) {
[18:01:09.469]                         computeRestarts <- base::computeRestarts
[18:01:09.469]                         grepl <- base::grepl
[18:01:09.469]                         restarts <- computeRestarts(cond)
[18:01:09.469]                         for (restart in restarts) {
[18:01:09.469]                           name <- restart$name
[18:01:09.469]                           if (is.null(name)) 
[18:01:09.469]                             next
[18:01:09.469]                           if (!grepl(pattern, name)) 
[18:01:09.469]                             next
[18:01:09.469]                           invokeRestart(restart)
[18:01:09.469]                           muffled <- TRUE
[18:01:09.469]                           break
[18:01:09.469]                         }
[18:01:09.469]                       }
[18:01:09.469]                     }
[18:01:09.469]                     invisible(muffled)
[18:01:09.469]                   }
[18:01:09.469]                   muffleCondition(cond)
[18:01:09.469]                 })
[18:01:09.469]             }))
[18:01:09.469]             future::FutureResult(value = ...future.value$value, 
[18:01:09.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.469]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.469]                     ...future.globalenv.names))
[18:01:09.469]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.469]         }, condition = base::local({
[18:01:09.469]             c <- base::c
[18:01:09.469]             inherits <- base::inherits
[18:01:09.469]             invokeRestart <- base::invokeRestart
[18:01:09.469]             length <- base::length
[18:01:09.469]             list <- base::list
[18:01:09.469]             seq.int <- base::seq.int
[18:01:09.469]             signalCondition <- base::signalCondition
[18:01:09.469]             sys.calls <- base::sys.calls
[18:01:09.469]             `[[` <- base::`[[`
[18:01:09.469]             `+` <- base::`+`
[18:01:09.469]             `<<-` <- base::`<<-`
[18:01:09.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.469]                   3L)]
[18:01:09.469]             }
[18:01:09.469]             function(cond) {
[18:01:09.469]                 is_error <- inherits(cond, "error")
[18:01:09.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.469]                   NULL)
[18:01:09.469]                 if (is_error) {
[18:01:09.469]                   sessionInformation <- function() {
[18:01:09.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.469]                       search = base::search(), system = base::Sys.info())
[18:01:09.469]                   }
[18:01:09.469]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.469]                     cond$call), session = sessionInformation(), 
[18:01:09.469]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.469]                   signalCondition(cond)
[18:01:09.469]                 }
[18:01:09.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.469]                 "immediateCondition"))) {
[18:01:09.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.469]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.469]                   if (TRUE && !signal) {
[18:01:09.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.469]                     {
[18:01:09.469]                       inherits <- base::inherits
[18:01:09.469]                       invokeRestart <- base::invokeRestart
[18:01:09.469]                       is.null <- base::is.null
[18:01:09.469]                       muffled <- FALSE
[18:01:09.469]                       if (inherits(cond, "message")) {
[18:01:09.469]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.469]                         if (muffled) 
[18:01:09.469]                           invokeRestart("muffleMessage")
[18:01:09.469]                       }
[18:01:09.469]                       else if (inherits(cond, "warning")) {
[18:01:09.469]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.469]                         if (muffled) 
[18:01:09.469]                           invokeRestart("muffleWarning")
[18:01:09.469]                       }
[18:01:09.469]                       else if (inherits(cond, "condition")) {
[18:01:09.469]                         if (!is.null(pattern)) {
[18:01:09.469]                           computeRestarts <- base::computeRestarts
[18:01:09.469]                           grepl <- base::grepl
[18:01:09.469]                           restarts <- computeRestarts(cond)
[18:01:09.469]                           for (restart in restarts) {
[18:01:09.469]                             name <- restart$name
[18:01:09.469]                             if (is.null(name)) 
[18:01:09.469]                               next
[18:01:09.469]                             if (!grepl(pattern, name)) 
[18:01:09.469]                               next
[18:01:09.469]                             invokeRestart(restart)
[18:01:09.469]                             muffled <- TRUE
[18:01:09.469]                             break
[18:01:09.469]                           }
[18:01:09.469]                         }
[18:01:09.469]                       }
[18:01:09.469]                       invisible(muffled)
[18:01:09.469]                     }
[18:01:09.469]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.469]                   }
[18:01:09.469]                 }
[18:01:09.469]                 else {
[18:01:09.469]                   if (TRUE) {
[18:01:09.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.469]                     {
[18:01:09.469]                       inherits <- base::inherits
[18:01:09.469]                       invokeRestart <- base::invokeRestart
[18:01:09.469]                       is.null <- base::is.null
[18:01:09.469]                       muffled <- FALSE
[18:01:09.469]                       if (inherits(cond, "message")) {
[18:01:09.469]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.469]                         if (muffled) 
[18:01:09.469]                           invokeRestart("muffleMessage")
[18:01:09.469]                       }
[18:01:09.469]                       else if (inherits(cond, "warning")) {
[18:01:09.469]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.469]                         if (muffled) 
[18:01:09.469]                           invokeRestart("muffleWarning")
[18:01:09.469]                       }
[18:01:09.469]                       else if (inherits(cond, "condition")) {
[18:01:09.469]                         if (!is.null(pattern)) {
[18:01:09.469]                           computeRestarts <- base::computeRestarts
[18:01:09.469]                           grepl <- base::grepl
[18:01:09.469]                           restarts <- computeRestarts(cond)
[18:01:09.469]                           for (restart in restarts) {
[18:01:09.469]                             name <- restart$name
[18:01:09.469]                             if (is.null(name)) 
[18:01:09.469]                               next
[18:01:09.469]                             if (!grepl(pattern, name)) 
[18:01:09.469]                               next
[18:01:09.469]                             invokeRestart(restart)
[18:01:09.469]                             muffled <- TRUE
[18:01:09.469]                             break
[18:01:09.469]                           }
[18:01:09.469]                         }
[18:01:09.469]                       }
[18:01:09.469]                       invisible(muffled)
[18:01:09.469]                     }
[18:01:09.469]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.469]                   }
[18:01:09.469]                 }
[18:01:09.469]             }
[18:01:09.469]         }))
[18:01:09.469]     }, error = function(ex) {
[18:01:09.469]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.469]                 ...future.rng), started = ...future.startTime, 
[18:01:09.469]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.469]             version = "1.8"), class = "FutureResult")
[18:01:09.469]     }, finally = {
[18:01:09.469]         if (!identical(...future.workdir, getwd())) 
[18:01:09.469]             setwd(...future.workdir)
[18:01:09.469]         {
[18:01:09.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.469]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.469]             }
[18:01:09.469]             base::options(...future.oldOptions)
[18:01:09.469]             if (.Platform$OS.type == "windows") {
[18:01:09.469]                 old_names <- names(...future.oldEnvVars)
[18:01:09.469]                 envs <- base::Sys.getenv()
[18:01:09.469]                 names <- names(envs)
[18:01:09.469]                 common <- intersect(names, old_names)
[18:01:09.469]                 added <- setdiff(names, old_names)
[18:01:09.469]                 removed <- setdiff(old_names, names)
[18:01:09.469]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.469]                   envs[common]]
[18:01:09.469]                 NAMES <- toupper(changed)
[18:01:09.469]                 args <- list()
[18:01:09.469]                 for (kk in seq_along(NAMES)) {
[18:01:09.469]                   name <- changed[[kk]]
[18:01:09.469]                   NAME <- NAMES[[kk]]
[18:01:09.469]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.469]                     next
[18:01:09.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.469]                 }
[18:01:09.469]                 NAMES <- toupper(added)
[18:01:09.469]                 for (kk in seq_along(NAMES)) {
[18:01:09.469]                   name <- added[[kk]]
[18:01:09.469]                   NAME <- NAMES[[kk]]
[18:01:09.469]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.469]                     next
[18:01:09.469]                   args[[name]] <- ""
[18:01:09.469]                 }
[18:01:09.469]                 NAMES <- toupper(removed)
[18:01:09.469]                 for (kk in seq_along(NAMES)) {
[18:01:09.469]                   name <- removed[[kk]]
[18:01:09.469]                   NAME <- NAMES[[kk]]
[18:01:09.469]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.469]                     next
[18:01:09.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.469]                 }
[18:01:09.469]                 if (length(args) > 0) 
[18:01:09.469]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.469]             }
[18:01:09.469]             else {
[18:01:09.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.469]             }
[18:01:09.469]             {
[18:01:09.469]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.469]                   0L) {
[18:01:09.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.469]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.469]                   base::options(opts)
[18:01:09.469]                 }
[18:01:09.469]                 {
[18:01:09.469]                   {
[18:01:09.469]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.469]                     NULL
[18:01:09.469]                   }
[18:01:09.469]                   options(future.plan = NULL)
[18:01:09.469]                   if (is.na(NA_character_)) 
[18:01:09.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.469]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.469]                     .init = FALSE)
[18:01:09.469]                 }
[18:01:09.469]             }
[18:01:09.469]         }
[18:01:09.469]     })
[18:01:09.469]     if (TRUE) {
[18:01:09.469]         base::sink(type = "output", split = FALSE)
[18:01:09.469]         if (TRUE) {
[18:01:09.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.469]         }
[18:01:09.469]         else {
[18:01:09.469]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.469]         }
[18:01:09.469]         base::close(...future.stdout)
[18:01:09.469]         ...future.stdout <- NULL
[18:01:09.469]     }
[18:01:09.469]     ...future.result$conditions <- ...future.conditions
[18:01:09.469]     ...future.result$finished <- base::Sys.time()
[18:01:09.469]     ...future.result
[18:01:09.469] }
[18:01:09.474] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[18:01:09.475] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[18:01:09.475] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[18:01:09.476] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:09.476] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.477] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[18:01:09.478] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[18:01:09.478] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:09.479] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.479] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:09.480] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.480] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[18:01:09.481] MultisessionFuture started
[18:01:09.481] - Launch lazy future ... done
[18:01:09.482] run() for ‘MultisessionFuture’ ... done
[18:01:09.482] Created future:
[18:01:09.482] MultisessionFuture:
[18:01:09.482] Label: ‘future_Map-2’
[18:01:09.482] Expression:
[18:01:09.482] {
[18:01:09.482]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.482]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.482]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.482]         on.exit(options(oopts), add = TRUE)
[18:01:09.482]     }
[18:01:09.482]     {
[18:01:09.482]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.482]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.482]         do.call(mapply, args = args)
[18:01:09.482]     }
[18:01:09.482] }
[18:01:09.482] Lazy evaluation: FALSE
[18:01:09.482] Asynchronous evaluation: TRUE
[18:01:09.482] Local evaluation: TRUE
[18:01:09.482] Environment: R_GlobalEnv
[18:01:09.482] Capture standard output: TRUE
[18:01:09.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.482] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.482] Packages: 1 packages (‘stats’)
[18:01:09.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.482] Resolved: FALSE
[18:01:09.482] Value: <not collected>
[18:01:09.482] Conditions captured: <none>
[18:01:09.482] Early signaling: FALSE
[18:01:09.482] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.482] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.495] Chunk #2 of 2 ... DONE
[18:01:09.495] Launching 2 futures (chunks) ... DONE
[18:01:09.496] Resolving 2 futures (chunks) ...
[18:01:09.496] resolve() on list ...
[18:01:09.496]  recursive: 0
[18:01:09.496]  length: 2
[18:01:09.496] 
[18:01:09.497] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.498] - Validating connection of MultisessionFuture
[18:01:09.498] - received message: FutureResult
[18:01:09.498] - Received FutureResult
[18:01:09.499] - Erased future from FutureRegistry
[18:01:09.499] result() for ClusterFuture ...
[18:01:09.499] - result already collected: FutureResult
[18:01:09.499] result() for ClusterFuture ... done
[18:01:09.499] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.500] Future #1
[18:01:09.500] result() for ClusterFuture ...
[18:01:09.500] - result already collected: FutureResult
[18:01:09.500] result() for ClusterFuture ... done
[18:01:09.500] result() for ClusterFuture ...
[18:01:09.501] - result already collected: FutureResult
[18:01:09.501] result() for ClusterFuture ... done
[18:01:09.501] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:09.501] - nx: 2
[18:01:09.501] - relay: TRUE
[18:01:09.502] - stdout: TRUE
[18:01:09.502] - signal: TRUE
[18:01:09.502] - resignal: FALSE
[18:01:09.502] - force: TRUE
[18:01:09.502] - relayed: [n=2] FALSE, FALSE
[18:01:09.502] - queued futures: [n=2] FALSE, FALSE
[18:01:09.503]  - until=1
[18:01:09.503]  - relaying element #1
[18:01:09.503] result() for ClusterFuture ...
[18:01:09.503] - result already collected: FutureResult
[18:01:09.503] result() for ClusterFuture ... done
[18:01:09.504] result() for ClusterFuture ...
[18:01:09.504] - result already collected: FutureResult
[18:01:09.504] result() for ClusterFuture ... done
[18:01:09.504] result() for ClusterFuture ...
[18:01:09.504] - result already collected: FutureResult
[18:01:09.505] result() for ClusterFuture ... done
[18:01:09.505] result() for ClusterFuture ...
[18:01:09.505] - result already collected: FutureResult
[18:01:09.505] result() for ClusterFuture ... done
[18:01:09.505] - relayed: [n=2] TRUE, FALSE
[18:01:09.506] - queued futures: [n=2] TRUE, FALSE
[18:01:09.506] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:09.506]  length: 1 (resolved future 1)
[18:01:09.528] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.529] - Validating connection of MultisessionFuture
[18:01:09.529] - received message: FutureResult
[18:01:09.529] - Received FutureResult
[18:01:09.529] - Erased future from FutureRegistry
[18:01:09.530] result() for ClusterFuture ...
[18:01:09.530] - result already collected: FutureResult
[18:01:09.530] result() for ClusterFuture ... done
[18:01:09.530] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.530] Future #2
[18:01:09.531] result() for ClusterFuture ...
[18:01:09.531] - result already collected: FutureResult
[18:01:09.531] result() for ClusterFuture ... done
[18:01:09.531] result() for ClusterFuture ...
[18:01:09.531] - result already collected: FutureResult
[18:01:09.532] result() for ClusterFuture ... done
[18:01:09.532] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:09.532] - nx: 2
[18:01:09.532] - relay: TRUE
[18:01:09.532] - stdout: TRUE
[18:01:09.532] - signal: TRUE
[18:01:09.533] - resignal: FALSE
[18:01:09.533] - force: TRUE
[18:01:09.533] - relayed: [n=2] TRUE, FALSE
[18:01:09.533] - queued futures: [n=2] TRUE, FALSE
[18:01:09.533]  - until=2
[18:01:09.534]  - relaying element #2
[18:01:09.534] result() for ClusterFuture ...
[18:01:09.534] - result already collected: FutureResult
[18:01:09.534] result() for ClusterFuture ... done
[18:01:09.534] result() for ClusterFuture ...
[18:01:09.534] - result already collected: FutureResult
[18:01:09.535] result() for ClusterFuture ... done
[18:01:09.535] result() for ClusterFuture ...
[18:01:09.535] - result already collected: FutureResult
[18:01:09.535] result() for ClusterFuture ... done
[18:01:09.535] result() for ClusterFuture ...
[18:01:09.536] - result already collected: FutureResult
[18:01:09.536] result() for ClusterFuture ... done
[18:01:09.536] - relayed: [n=2] TRUE, TRUE
[18:01:09.536] - queued futures: [n=2] TRUE, TRUE
[18:01:09.536] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:09.537]  length: 0 (resolved future 2)
[18:01:09.537] Relaying remaining futures
[18:01:09.537] signalConditionsASAP(NULL, pos=0) ...
[18:01:09.537] - nx: 2
[18:01:09.537] - relay: TRUE
[18:01:09.537] - stdout: TRUE
[18:01:09.538] - signal: TRUE
[18:01:09.538] - resignal: FALSE
[18:01:09.538] - force: TRUE
[18:01:09.538] - relayed: [n=2] TRUE, TRUE
[18:01:09.538] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:09.539] - relayed: [n=2] TRUE, TRUE
[18:01:09.539] - queued futures: [n=2] TRUE, TRUE
[18:01:09.539] signalConditionsASAP(NULL, pos=0) ... done
[18:01:09.539] resolve() on list ... DONE
[18:01:09.539] result() for ClusterFuture ...
[18:01:09.540] - result already collected: FutureResult
[18:01:09.540] result() for ClusterFuture ... done
[18:01:09.540] result() for ClusterFuture ...
[18:01:09.540] - result already collected: FutureResult
[18:01:09.540] result() for ClusterFuture ... done
[18:01:09.541] result() for ClusterFuture ...
[18:01:09.541] - result already collected: FutureResult
[18:01:09.541] result() for ClusterFuture ... done
[18:01:09.541] result() for ClusterFuture ...
[18:01:09.541] - result already collected: FutureResult
[18:01:09.545] result() for ClusterFuture ... done
[18:01:09.545]  - Number of value chunks collected: 2
[18:01:09.545] Resolving 2 futures (chunks) ... DONE
[18:01:09.545] Reducing values from 2 chunks ...
[18:01:09.546]  - Number of values collected after concatenation: 5
[18:01:09.546]  - Number of values expected: 5
[18:01:09.546] Reducing values from 2 chunks ... DONE
[18:01:09.546] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[18:01:09.550] future_mapply() ...
[18:01:09.556] Number of chunks: 2
[18:01:09.556] getGlobalsAndPackagesXApply() ...
[18:01:09.557]  - future.globals: TRUE
[18:01:09.557] getGlobalsAndPackages() ...
[18:01:09.557] Searching for globals...
[18:01:09.558] - globals found: [1] ‘FUN’
[18:01:09.558] Searching for globals ... DONE
[18:01:09.559] Resolving globals: FALSE
[18:01:09.559] The total size of the 1 globals is 56 bytes (56 bytes)
[18:01:09.560] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[18:01:09.560] - globals: [1] ‘FUN’
[18:01:09.560] 
[18:01:09.560] getGlobalsAndPackages() ... DONE
[18:01:09.561]  - globals found/used: [n=1] ‘FUN’
[18:01:09.561]  - needed namespaces: [n=0] 
[18:01:09.561] Finding globals ... DONE
[18:01:09.561] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:09.562] List of 2
[18:01:09.562]  $ ...future.FUN:function (e1, e2)  
[18:01:09.562]  $ MoreArgs     : NULL
[18:01:09.562]  - attr(*, "where")=List of 2
[18:01:09.562]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:09.562]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:09.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:09.562]  - attr(*, "resolved")= logi FALSE
[18:01:09.562]  - attr(*, "total_size")= num NA
[18:01:09.566] Packages to be attached in all futures: [n=0] 
[18:01:09.567] getGlobalsAndPackagesXApply() ... DONE
[18:01:09.567] Number of futures (= number of chunks): 2
[18:01:09.567] Launching 2 futures (chunks) ...
[18:01:09.567] Chunk #1 of 2 ...
[18:01:09.568]  - Finding globals in '...' for chunk #1 ...
[18:01:09.568] getGlobalsAndPackages() ...
[18:01:09.568] Searching for globals...
[18:01:09.569] 
[18:01:09.569] Searching for globals ... DONE
[18:01:09.569] - globals: [0] <none>
[18:01:09.569] getGlobalsAndPackages() ... DONE
[18:01:09.569]    + additional globals found: [n=0] 
[18:01:09.570]    + additional namespaces needed: [n=0] 
[18:01:09.570]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:09.570]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.570]  - seeds: <none>
[18:01:09.570]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.571] getGlobalsAndPackages() ...
[18:01:09.571] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.571] Resolving globals: FALSE
[18:01:09.572] The total size of the 5 globals is 168 bytes (168 bytes)
[18:01:09.573] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.573] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.573] 
[18:01:09.573] getGlobalsAndPackages() ... DONE
[18:01:09.574] run() for ‘Future’ ...
[18:01:09.574] - state: ‘created’
[18:01:09.574] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.597] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.597]   - Field: ‘node’
[18:01:09.598]   - Field: ‘label’
[18:01:09.598]   - Field: ‘local’
[18:01:09.598]   - Field: ‘owner’
[18:01:09.598]   - Field: ‘envir’
[18:01:09.598]   - Field: ‘workers’
[18:01:09.599]   - Field: ‘packages’
[18:01:09.599]   - Field: ‘gc’
[18:01:09.599]   - Field: ‘conditions’
[18:01:09.599]   - Field: ‘persistent’
[18:01:09.599]   - Field: ‘expr’
[18:01:09.600]   - Field: ‘uuid’
[18:01:09.600]   - Field: ‘seed’
[18:01:09.600]   - Field: ‘version’
[18:01:09.600]   - Field: ‘result’
[18:01:09.600]   - Field: ‘asynchronous’
[18:01:09.600]   - Field: ‘calls’
[18:01:09.601]   - Field: ‘globals’
[18:01:09.601]   - Field: ‘stdout’
[18:01:09.601]   - Field: ‘earlySignal’
[18:01:09.601]   - Field: ‘lazy’
[18:01:09.601]   - Field: ‘state’
[18:01:09.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.602] - Launch lazy future ...
[18:01:09.602] Packages needed by the future expression (n = 0): <none>
[18:01:09.603] Packages needed by future strategies (n = 0): <none>
[18:01:09.603] {
[18:01:09.603]     {
[18:01:09.603]         {
[18:01:09.603]             ...future.startTime <- base::Sys.time()
[18:01:09.603]             {
[18:01:09.603]                 {
[18:01:09.603]                   {
[18:01:09.603]                     {
[18:01:09.603]                       base::local({
[18:01:09.603]                         has_future <- base::requireNamespace("future", 
[18:01:09.603]                           quietly = TRUE)
[18:01:09.603]                         if (has_future) {
[18:01:09.603]                           ns <- base::getNamespace("future")
[18:01:09.603]                           version <- ns[[".package"]][["version"]]
[18:01:09.603]                           if (is.null(version)) 
[18:01:09.603]                             version <- utils::packageVersion("future")
[18:01:09.603]                         }
[18:01:09.603]                         else {
[18:01:09.603]                           version <- NULL
[18:01:09.603]                         }
[18:01:09.603]                         if (!has_future || version < "1.8.0") {
[18:01:09.603]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.603]                             "", base::R.version$version.string), 
[18:01:09.603]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:09.603]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:09.603]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.603]                               "release", "version")], collapse = " "), 
[18:01:09.603]                             hostname = base::Sys.info()[["nodename"]])
[18:01:09.603]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.603]                             info)
[18:01:09.603]                           info <- base::paste(info, collapse = "; ")
[18:01:09.603]                           if (!has_future) {
[18:01:09.603]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.603]                               info)
[18:01:09.603]                           }
[18:01:09.603]                           else {
[18:01:09.603]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.603]                               info, version)
[18:01:09.603]                           }
[18:01:09.603]                           base::stop(msg)
[18:01:09.603]                         }
[18:01:09.603]                       })
[18:01:09.603]                     }
[18:01:09.603]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.603]                     base::options(mc.cores = 1L)
[18:01:09.603]                   }
[18:01:09.603]                   ...future.strategy.old <- future::plan("list")
[18:01:09.603]                   options(future.plan = NULL)
[18:01:09.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.603]                 }
[18:01:09.603]                 ...future.workdir <- getwd()
[18:01:09.603]             }
[18:01:09.603]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.603]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.603]         }
[18:01:09.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.603]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.603]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.603]             base::names(...future.oldOptions))
[18:01:09.603]     }
[18:01:09.603]     if (FALSE) {
[18:01:09.603]     }
[18:01:09.603]     else {
[18:01:09.603]         if (TRUE) {
[18:01:09.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.603]                 open = "w")
[18:01:09.603]         }
[18:01:09.603]         else {
[18:01:09.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.603]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.603]         }
[18:01:09.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.603]             base::sink(type = "output", split = FALSE)
[18:01:09.603]             base::close(...future.stdout)
[18:01:09.603]         }, add = TRUE)
[18:01:09.603]     }
[18:01:09.603]     ...future.frame <- base::sys.nframe()
[18:01:09.603]     ...future.conditions <- base::list()
[18:01:09.603]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.603]     if (FALSE) {
[18:01:09.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.603]     }
[18:01:09.603]     ...future.result <- base::tryCatch({
[18:01:09.603]         base::withCallingHandlers({
[18:01:09.603]             ...future.value <- base::withVisible(base::local({
[18:01:09.603]                 ...future.makeSendCondition <- base::local({
[18:01:09.603]                   sendCondition <- NULL
[18:01:09.603]                   function(frame = 1L) {
[18:01:09.603]                     if (is.function(sendCondition)) 
[18:01:09.603]                       return(sendCondition)
[18:01:09.603]                     ns <- getNamespace("parallel")
[18:01:09.603]                     if (exists("sendData", mode = "function", 
[18:01:09.603]                       envir = ns)) {
[18:01:09.603]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.603]                         envir = ns)
[18:01:09.603]                       envir <- sys.frame(frame)
[18:01:09.603]                       master <- NULL
[18:01:09.603]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.603]                         !identical(envir, emptyenv())) {
[18:01:09.603]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.603]                           inherits = FALSE)) {
[18:01:09.603]                           master <- get("master", mode = "list", 
[18:01:09.603]                             envir = envir, inherits = FALSE)
[18:01:09.603]                           if (inherits(master, c("SOCKnode", 
[18:01:09.603]                             "SOCK0node"))) {
[18:01:09.603]                             sendCondition <<- function(cond) {
[18:01:09.603]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.603]                                 success = TRUE)
[18:01:09.603]                               parallel_sendData(master, data)
[18:01:09.603]                             }
[18:01:09.603]                             return(sendCondition)
[18:01:09.603]                           }
[18:01:09.603]                         }
[18:01:09.603]                         frame <- frame + 1L
[18:01:09.603]                         envir <- sys.frame(frame)
[18:01:09.603]                       }
[18:01:09.603]                     }
[18:01:09.603]                     sendCondition <<- function(cond) NULL
[18:01:09.603]                   }
[18:01:09.603]                 })
[18:01:09.603]                 withCallingHandlers({
[18:01:09.603]                   {
[18:01:09.603]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.603]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.603]                       ...future.globals.maxSize)) {
[18:01:09.603]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.603]                       on.exit(options(oopts), add = TRUE)
[18:01:09.603]                     }
[18:01:09.603]                     {
[18:01:09.603]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.603]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.603]                         USE.NAMES = FALSE)
[18:01:09.603]                       do.call(mapply, args = args)
[18:01:09.603]                     }
[18:01:09.603]                   }
[18:01:09.603]                 }, immediateCondition = function(cond) {
[18:01:09.603]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.603]                   sendCondition(cond)
[18:01:09.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.603]                   {
[18:01:09.603]                     inherits <- base::inherits
[18:01:09.603]                     invokeRestart <- base::invokeRestart
[18:01:09.603]                     is.null <- base::is.null
[18:01:09.603]                     muffled <- FALSE
[18:01:09.603]                     if (inherits(cond, "message")) {
[18:01:09.603]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.603]                       if (muffled) 
[18:01:09.603]                         invokeRestart("muffleMessage")
[18:01:09.603]                     }
[18:01:09.603]                     else if (inherits(cond, "warning")) {
[18:01:09.603]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.603]                       if (muffled) 
[18:01:09.603]                         invokeRestart("muffleWarning")
[18:01:09.603]                     }
[18:01:09.603]                     else if (inherits(cond, "condition")) {
[18:01:09.603]                       if (!is.null(pattern)) {
[18:01:09.603]                         computeRestarts <- base::computeRestarts
[18:01:09.603]                         grepl <- base::grepl
[18:01:09.603]                         restarts <- computeRestarts(cond)
[18:01:09.603]                         for (restart in restarts) {
[18:01:09.603]                           name <- restart$name
[18:01:09.603]                           if (is.null(name)) 
[18:01:09.603]                             next
[18:01:09.603]                           if (!grepl(pattern, name)) 
[18:01:09.603]                             next
[18:01:09.603]                           invokeRestart(restart)
[18:01:09.603]                           muffled <- TRUE
[18:01:09.603]                           break
[18:01:09.603]                         }
[18:01:09.603]                       }
[18:01:09.603]                     }
[18:01:09.603]                     invisible(muffled)
[18:01:09.603]                   }
[18:01:09.603]                   muffleCondition(cond)
[18:01:09.603]                 })
[18:01:09.603]             }))
[18:01:09.603]             future::FutureResult(value = ...future.value$value, 
[18:01:09.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.603]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.603]                     ...future.globalenv.names))
[18:01:09.603]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.603]         }, condition = base::local({
[18:01:09.603]             c <- base::c
[18:01:09.603]             inherits <- base::inherits
[18:01:09.603]             invokeRestart <- base::invokeRestart
[18:01:09.603]             length <- base::length
[18:01:09.603]             list <- base::list
[18:01:09.603]             seq.int <- base::seq.int
[18:01:09.603]             signalCondition <- base::signalCondition
[18:01:09.603]             sys.calls <- base::sys.calls
[18:01:09.603]             `[[` <- base::`[[`
[18:01:09.603]             `+` <- base::`+`
[18:01:09.603]             `<<-` <- base::`<<-`
[18:01:09.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.603]                   3L)]
[18:01:09.603]             }
[18:01:09.603]             function(cond) {
[18:01:09.603]                 is_error <- inherits(cond, "error")
[18:01:09.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.603]                   NULL)
[18:01:09.603]                 if (is_error) {
[18:01:09.603]                   sessionInformation <- function() {
[18:01:09.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.603]                       search = base::search(), system = base::Sys.info())
[18:01:09.603]                   }
[18:01:09.603]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.603]                     cond$call), session = sessionInformation(), 
[18:01:09.603]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.603]                   signalCondition(cond)
[18:01:09.603]                 }
[18:01:09.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.603]                 "immediateCondition"))) {
[18:01:09.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.603]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.603]                   if (TRUE && !signal) {
[18:01:09.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.603]                     {
[18:01:09.603]                       inherits <- base::inherits
[18:01:09.603]                       invokeRestart <- base::invokeRestart
[18:01:09.603]                       is.null <- base::is.null
[18:01:09.603]                       muffled <- FALSE
[18:01:09.603]                       if (inherits(cond, "message")) {
[18:01:09.603]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.603]                         if (muffled) 
[18:01:09.603]                           invokeRestart("muffleMessage")
[18:01:09.603]                       }
[18:01:09.603]                       else if (inherits(cond, "warning")) {
[18:01:09.603]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.603]                         if (muffled) 
[18:01:09.603]                           invokeRestart("muffleWarning")
[18:01:09.603]                       }
[18:01:09.603]                       else if (inherits(cond, "condition")) {
[18:01:09.603]                         if (!is.null(pattern)) {
[18:01:09.603]                           computeRestarts <- base::computeRestarts
[18:01:09.603]                           grepl <- base::grepl
[18:01:09.603]                           restarts <- computeRestarts(cond)
[18:01:09.603]                           for (restart in restarts) {
[18:01:09.603]                             name <- restart$name
[18:01:09.603]                             if (is.null(name)) 
[18:01:09.603]                               next
[18:01:09.603]                             if (!grepl(pattern, name)) 
[18:01:09.603]                               next
[18:01:09.603]                             invokeRestart(restart)
[18:01:09.603]                             muffled <- TRUE
[18:01:09.603]                             break
[18:01:09.603]                           }
[18:01:09.603]                         }
[18:01:09.603]                       }
[18:01:09.603]                       invisible(muffled)
[18:01:09.603]                     }
[18:01:09.603]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.603]                   }
[18:01:09.603]                 }
[18:01:09.603]                 else {
[18:01:09.603]                   if (TRUE) {
[18:01:09.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.603]                     {
[18:01:09.603]                       inherits <- base::inherits
[18:01:09.603]                       invokeRestart <- base::invokeRestart
[18:01:09.603]                       is.null <- base::is.null
[18:01:09.603]                       muffled <- FALSE
[18:01:09.603]                       if (inherits(cond, "message")) {
[18:01:09.603]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.603]                         if (muffled) 
[18:01:09.603]                           invokeRestart("muffleMessage")
[18:01:09.603]                       }
[18:01:09.603]                       else if (inherits(cond, "warning")) {
[18:01:09.603]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.603]                         if (muffled) 
[18:01:09.603]                           invokeRestart("muffleWarning")
[18:01:09.603]                       }
[18:01:09.603]                       else if (inherits(cond, "condition")) {
[18:01:09.603]                         if (!is.null(pattern)) {
[18:01:09.603]                           computeRestarts <- base::computeRestarts
[18:01:09.603]                           grepl <- base::grepl
[18:01:09.603]                           restarts <- computeRestarts(cond)
[18:01:09.603]                           for (restart in restarts) {
[18:01:09.603]                             name <- restart$name
[18:01:09.603]                             if (is.null(name)) 
[18:01:09.603]                               next
[18:01:09.603]                             if (!grepl(pattern, name)) 
[18:01:09.603]                               next
[18:01:09.603]                             invokeRestart(restart)
[18:01:09.603]                             muffled <- TRUE
[18:01:09.603]                             break
[18:01:09.603]                           }
[18:01:09.603]                         }
[18:01:09.603]                       }
[18:01:09.603]                       invisible(muffled)
[18:01:09.603]                     }
[18:01:09.603]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.603]                   }
[18:01:09.603]                 }
[18:01:09.603]             }
[18:01:09.603]         }))
[18:01:09.603]     }, error = function(ex) {
[18:01:09.603]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.603]                 ...future.rng), started = ...future.startTime, 
[18:01:09.603]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.603]             version = "1.8"), class = "FutureResult")
[18:01:09.603]     }, finally = {
[18:01:09.603]         if (!identical(...future.workdir, getwd())) 
[18:01:09.603]             setwd(...future.workdir)
[18:01:09.603]         {
[18:01:09.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.603]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.603]             }
[18:01:09.603]             base::options(...future.oldOptions)
[18:01:09.603]             if (.Platform$OS.type == "windows") {
[18:01:09.603]                 old_names <- names(...future.oldEnvVars)
[18:01:09.603]                 envs <- base::Sys.getenv()
[18:01:09.603]                 names <- names(envs)
[18:01:09.603]                 common <- intersect(names, old_names)
[18:01:09.603]                 added <- setdiff(names, old_names)
[18:01:09.603]                 removed <- setdiff(old_names, names)
[18:01:09.603]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.603]                   envs[common]]
[18:01:09.603]                 NAMES <- toupper(changed)
[18:01:09.603]                 args <- list()
[18:01:09.603]                 for (kk in seq_along(NAMES)) {
[18:01:09.603]                   name <- changed[[kk]]
[18:01:09.603]                   NAME <- NAMES[[kk]]
[18:01:09.603]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.603]                     next
[18:01:09.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.603]                 }
[18:01:09.603]                 NAMES <- toupper(added)
[18:01:09.603]                 for (kk in seq_along(NAMES)) {
[18:01:09.603]                   name <- added[[kk]]
[18:01:09.603]                   NAME <- NAMES[[kk]]
[18:01:09.603]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.603]                     next
[18:01:09.603]                   args[[name]] <- ""
[18:01:09.603]                 }
[18:01:09.603]                 NAMES <- toupper(removed)
[18:01:09.603]                 for (kk in seq_along(NAMES)) {
[18:01:09.603]                   name <- removed[[kk]]
[18:01:09.603]                   NAME <- NAMES[[kk]]
[18:01:09.603]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.603]                     next
[18:01:09.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.603]                 }
[18:01:09.603]                 if (length(args) > 0) 
[18:01:09.603]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.603]             }
[18:01:09.603]             else {
[18:01:09.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.603]             }
[18:01:09.603]             {
[18:01:09.603]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.603]                   0L) {
[18:01:09.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.603]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.603]                   base::options(opts)
[18:01:09.603]                 }
[18:01:09.603]                 {
[18:01:09.603]                   {
[18:01:09.603]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.603]                     NULL
[18:01:09.603]                   }
[18:01:09.603]                   options(future.plan = NULL)
[18:01:09.603]                   if (is.na(NA_character_)) 
[18:01:09.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.603]                     .init = FALSE)
[18:01:09.603]                 }
[18:01:09.603]             }
[18:01:09.603]         }
[18:01:09.603]     })
[18:01:09.603]     if (TRUE) {
[18:01:09.603]         base::sink(type = "output", split = FALSE)
[18:01:09.603]         if (TRUE) {
[18:01:09.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.603]         }
[18:01:09.603]         else {
[18:01:09.603]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.603]         }
[18:01:09.603]         base::close(...future.stdout)
[18:01:09.603]         ...future.stdout <- NULL
[18:01:09.603]     }
[18:01:09.603]     ...future.result$conditions <- ...future.conditions
[18:01:09.603]     ...future.result$finished <- base::Sys.time()
[18:01:09.603]     ...future.result
[18:01:09.603] }
[18:01:09.609] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[18:01:09.609] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[18:01:09.610] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[18:01:09.610] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:09.611] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.611] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:01:09.612] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:01:09.612] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:09.613] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.613] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:09.614] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.615] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[18:01:09.615] MultisessionFuture started
[18:01:09.616] - Launch lazy future ... done
[18:01:09.616] run() for ‘MultisessionFuture’ ... done
[18:01:09.616] Created future:
[18:01:09.616] MultisessionFuture:
[18:01:09.616] Label: ‘future_Map-1’
[18:01:09.616] Expression:
[18:01:09.616] {
[18:01:09.616]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.616]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.616]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.616]         on.exit(options(oopts), add = TRUE)
[18:01:09.616]     }
[18:01:09.616]     {
[18:01:09.616]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.616]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.616]         do.call(mapply, args = args)
[18:01:09.616]     }
[18:01:09.616] }
[18:01:09.616] Lazy evaluation: FALSE
[18:01:09.616] Asynchronous evaluation: TRUE
[18:01:09.616] Local evaluation: TRUE
[18:01:09.616] Environment: R_GlobalEnv
[18:01:09.616] Capture standard output: TRUE
[18:01:09.616] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.616] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.616] Packages: <none>
[18:01:09.616] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.616] Resolved: FALSE
[18:01:09.616] Value: <not collected>
[18:01:09.616] Conditions captured: <none>
[18:01:09.616] Early signaling: FALSE
[18:01:09.616] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.616] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.629] Chunk #1 of 2 ... DONE
[18:01:09.629] Chunk #2 of 2 ...
[18:01:09.629]  - Finding globals in '...' for chunk #2 ...
[18:01:09.630] getGlobalsAndPackages() ...
[18:01:09.630] Searching for globals...
[18:01:09.631] 
[18:01:09.631] Searching for globals ... DONE
[18:01:09.631] - globals: [0] <none>
[18:01:09.631] getGlobalsAndPackages() ... DONE
[18:01:09.631]    + additional globals found: [n=0] 
[18:01:09.631]    + additional namespaces needed: [n=0] 
[18:01:09.632]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:09.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.632]  - seeds: <none>
[18:01:09.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.632] getGlobalsAndPackages() ...
[18:01:09.633] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.633] Resolving globals: FALSE
[18:01:09.634] The total size of the 5 globals is 280 bytes (280 bytes)
[18:01:09.635] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.635] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.635] 
[18:01:09.635] getGlobalsAndPackages() ... DONE
[18:01:09.636] run() for ‘Future’ ...
[18:01:09.636] - state: ‘created’
[18:01:09.636] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.659] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.659]   - Field: ‘node’
[18:01:09.659]   - Field: ‘label’
[18:01:09.660]   - Field: ‘local’
[18:01:09.660]   - Field: ‘owner’
[18:01:09.660]   - Field: ‘envir’
[18:01:09.660]   - Field: ‘workers’
[18:01:09.660]   - Field: ‘packages’
[18:01:09.661]   - Field: ‘gc’
[18:01:09.661]   - Field: ‘conditions’
[18:01:09.661]   - Field: ‘persistent’
[18:01:09.661]   - Field: ‘expr’
[18:01:09.661]   - Field: ‘uuid’
[18:01:09.662]   - Field: ‘seed’
[18:01:09.662]   - Field: ‘version’
[18:01:09.662]   - Field: ‘result’
[18:01:09.662]   - Field: ‘asynchronous’
[18:01:09.662]   - Field: ‘calls’
[18:01:09.663]   - Field: ‘globals’
[18:01:09.663]   - Field: ‘stdout’
[18:01:09.663]   - Field: ‘earlySignal’
[18:01:09.663]   - Field: ‘lazy’
[18:01:09.663]   - Field: ‘state’
[18:01:09.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.664] - Launch lazy future ...
[18:01:09.664] Packages needed by the future expression (n = 0): <none>
[18:01:09.664] Packages needed by future strategies (n = 0): <none>
[18:01:09.665] {
[18:01:09.665]     {
[18:01:09.665]         {
[18:01:09.665]             ...future.startTime <- base::Sys.time()
[18:01:09.665]             {
[18:01:09.665]                 {
[18:01:09.665]                   {
[18:01:09.665]                     {
[18:01:09.665]                       base::local({
[18:01:09.665]                         has_future <- base::requireNamespace("future", 
[18:01:09.665]                           quietly = TRUE)
[18:01:09.665]                         if (has_future) {
[18:01:09.665]                           ns <- base::getNamespace("future")
[18:01:09.665]                           version <- ns[[".package"]][["version"]]
[18:01:09.665]                           if (is.null(version)) 
[18:01:09.665]                             version <- utils::packageVersion("future")
[18:01:09.665]                         }
[18:01:09.665]                         else {
[18:01:09.665]                           version <- NULL
[18:01:09.665]                         }
[18:01:09.665]                         if (!has_future || version < "1.8.0") {
[18:01:09.665]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.665]                             "", base::R.version$version.string), 
[18:01:09.665]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:09.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:09.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.665]                               "release", "version")], collapse = " "), 
[18:01:09.665]                             hostname = base::Sys.info()[["nodename"]])
[18:01:09.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.665]                             info)
[18:01:09.665]                           info <- base::paste(info, collapse = "; ")
[18:01:09.665]                           if (!has_future) {
[18:01:09.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.665]                               info)
[18:01:09.665]                           }
[18:01:09.665]                           else {
[18:01:09.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.665]                               info, version)
[18:01:09.665]                           }
[18:01:09.665]                           base::stop(msg)
[18:01:09.665]                         }
[18:01:09.665]                       })
[18:01:09.665]                     }
[18:01:09.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.665]                     base::options(mc.cores = 1L)
[18:01:09.665]                   }
[18:01:09.665]                   ...future.strategy.old <- future::plan("list")
[18:01:09.665]                   options(future.plan = NULL)
[18:01:09.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.665]                 }
[18:01:09.665]                 ...future.workdir <- getwd()
[18:01:09.665]             }
[18:01:09.665]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.665]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.665]         }
[18:01:09.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.665]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.665]             base::names(...future.oldOptions))
[18:01:09.665]     }
[18:01:09.665]     if (FALSE) {
[18:01:09.665]     }
[18:01:09.665]     else {
[18:01:09.665]         if (TRUE) {
[18:01:09.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.665]                 open = "w")
[18:01:09.665]         }
[18:01:09.665]         else {
[18:01:09.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.665]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.665]         }
[18:01:09.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.665]             base::sink(type = "output", split = FALSE)
[18:01:09.665]             base::close(...future.stdout)
[18:01:09.665]         }, add = TRUE)
[18:01:09.665]     }
[18:01:09.665]     ...future.frame <- base::sys.nframe()
[18:01:09.665]     ...future.conditions <- base::list()
[18:01:09.665]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.665]     if (FALSE) {
[18:01:09.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.665]     }
[18:01:09.665]     ...future.result <- base::tryCatch({
[18:01:09.665]         base::withCallingHandlers({
[18:01:09.665]             ...future.value <- base::withVisible(base::local({
[18:01:09.665]                 ...future.makeSendCondition <- base::local({
[18:01:09.665]                   sendCondition <- NULL
[18:01:09.665]                   function(frame = 1L) {
[18:01:09.665]                     if (is.function(sendCondition)) 
[18:01:09.665]                       return(sendCondition)
[18:01:09.665]                     ns <- getNamespace("parallel")
[18:01:09.665]                     if (exists("sendData", mode = "function", 
[18:01:09.665]                       envir = ns)) {
[18:01:09.665]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.665]                         envir = ns)
[18:01:09.665]                       envir <- sys.frame(frame)
[18:01:09.665]                       master <- NULL
[18:01:09.665]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.665]                         !identical(envir, emptyenv())) {
[18:01:09.665]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.665]                           inherits = FALSE)) {
[18:01:09.665]                           master <- get("master", mode = "list", 
[18:01:09.665]                             envir = envir, inherits = FALSE)
[18:01:09.665]                           if (inherits(master, c("SOCKnode", 
[18:01:09.665]                             "SOCK0node"))) {
[18:01:09.665]                             sendCondition <<- function(cond) {
[18:01:09.665]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.665]                                 success = TRUE)
[18:01:09.665]                               parallel_sendData(master, data)
[18:01:09.665]                             }
[18:01:09.665]                             return(sendCondition)
[18:01:09.665]                           }
[18:01:09.665]                         }
[18:01:09.665]                         frame <- frame + 1L
[18:01:09.665]                         envir <- sys.frame(frame)
[18:01:09.665]                       }
[18:01:09.665]                     }
[18:01:09.665]                     sendCondition <<- function(cond) NULL
[18:01:09.665]                   }
[18:01:09.665]                 })
[18:01:09.665]                 withCallingHandlers({
[18:01:09.665]                   {
[18:01:09.665]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.665]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.665]                       ...future.globals.maxSize)) {
[18:01:09.665]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.665]                       on.exit(options(oopts), add = TRUE)
[18:01:09.665]                     }
[18:01:09.665]                     {
[18:01:09.665]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.665]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.665]                         USE.NAMES = FALSE)
[18:01:09.665]                       do.call(mapply, args = args)
[18:01:09.665]                     }
[18:01:09.665]                   }
[18:01:09.665]                 }, immediateCondition = function(cond) {
[18:01:09.665]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.665]                   sendCondition(cond)
[18:01:09.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.665]                   {
[18:01:09.665]                     inherits <- base::inherits
[18:01:09.665]                     invokeRestart <- base::invokeRestart
[18:01:09.665]                     is.null <- base::is.null
[18:01:09.665]                     muffled <- FALSE
[18:01:09.665]                     if (inherits(cond, "message")) {
[18:01:09.665]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.665]                       if (muffled) 
[18:01:09.665]                         invokeRestart("muffleMessage")
[18:01:09.665]                     }
[18:01:09.665]                     else if (inherits(cond, "warning")) {
[18:01:09.665]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.665]                       if (muffled) 
[18:01:09.665]                         invokeRestart("muffleWarning")
[18:01:09.665]                     }
[18:01:09.665]                     else if (inherits(cond, "condition")) {
[18:01:09.665]                       if (!is.null(pattern)) {
[18:01:09.665]                         computeRestarts <- base::computeRestarts
[18:01:09.665]                         grepl <- base::grepl
[18:01:09.665]                         restarts <- computeRestarts(cond)
[18:01:09.665]                         for (restart in restarts) {
[18:01:09.665]                           name <- restart$name
[18:01:09.665]                           if (is.null(name)) 
[18:01:09.665]                             next
[18:01:09.665]                           if (!grepl(pattern, name)) 
[18:01:09.665]                             next
[18:01:09.665]                           invokeRestart(restart)
[18:01:09.665]                           muffled <- TRUE
[18:01:09.665]                           break
[18:01:09.665]                         }
[18:01:09.665]                       }
[18:01:09.665]                     }
[18:01:09.665]                     invisible(muffled)
[18:01:09.665]                   }
[18:01:09.665]                   muffleCondition(cond)
[18:01:09.665]                 })
[18:01:09.665]             }))
[18:01:09.665]             future::FutureResult(value = ...future.value$value, 
[18:01:09.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.665]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.665]                     ...future.globalenv.names))
[18:01:09.665]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.665]         }, condition = base::local({
[18:01:09.665]             c <- base::c
[18:01:09.665]             inherits <- base::inherits
[18:01:09.665]             invokeRestart <- base::invokeRestart
[18:01:09.665]             length <- base::length
[18:01:09.665]             list <- base::list
[18:01:09.665]             seq.int <- base::seq.int
[18:01:09.665]             signalCondition <- base::signalCondition
[18:01:09.665]             sys.calls <- base::sys.calls
[18:01:09.665]             `[[` <- base::`[[`
[18:01:09.665]             `+` <- base::`+`
[18:01:09.665]             `<<-` <- base::`<<-`
[18:01:09.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.665]                   3L)]
[18:01:09.665]             }
[18:01:09.665]             function(cond) {
[18:01:09.665]                 is_error <- inherits(cond, "error")
[18:01:09.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.665]                   NULL)
[18:01:09.665]                 if (is_error) {
[18:01:09.665]                   sessionInformation <- function() {
[18:01:09.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.665]                       search = base::search(), system = base::Sys.info())
[18:01:09.665]                   }
[18:01:09.665]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.665]                     cond$call), session = sessionInformation(), 
[18:01:09.665]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.665]                   signalCondition(cond)
[18:01:09.665]                 }
[18:01:09.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.665]                 "immediateCondition"))) {
[18:01:09.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.665]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.665]                   if (TRUE && !signal) {
[18:01:09.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.665]                     {
[18:01:09.665]                       inherits <- base::inherits
[18:01:09.665]                       invokeRestart <- base::invokeRestart
[18:01:09.665]                       is.null <- base::is.null
[18:01:09.665]                       muffled <- FALSE
[18:01:09.665]                       if (inherits(cond, "message")) {
[18:01:09.665]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.665]                         if (muffled) 
[18:01:09.665]                           invokeRestart("muffleMessage")
[18:01:09.665]                       }
[18:01:09.665]                       else if (inherits(cond, "warning")) {
[18:01:09.665]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.665]                         if (muffled) 
[18:01:09.665]                           invokeRestart("muffleWarning")
[18:01:09.665]                       }
[18:01:09.665]                       else if (inherits(cond, "condition")) {
[18:01:09.665]                         if (!is.null(pattern)) {
[18:01:09.665]                           computeRestarts <- base::computeRestarts
[18:01:09.665]                           grepl <- base::grepl
[18:01:09.665]                           restarts <- computeRestarts(cond)
[18:01:09.665]                           for (restart in restarts) {
[18:01:09.665]                             name <- restart$name
[18:01:09.665]                             if (is.null(name)) 
[18:01:09.665]                               next
[18:01:09.665]                             if (!grepl(pattern, name)) 
[18:01:09.665]                               next
[18:01:09.665]                             invokeRestart(restart)
[18:01:09.665]                             muffled <- TRUE
[18:01:09.665]                             break
[18:01:09.665]                           }
[18:01:09.665]                         }
[18:01:09.665]                       }
[18:01:09.665]                       invisible(muffled)
[18:01:09.665]                     }
[18:01:09.665]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.665]                   }
[18:01:09.665]                 }
[18:01:09.665]                 else {
[18:01:09.665]                   if (TRUE) {
[18:01:09.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.665]                     {
[18:01:09.665]                       inherits <- base::inherits
[18:01:09.665]                       invokeRestart <- base::invokeRestart
[18:01:09.665]                       is.null <- base::is.null
[18:01:09.665]                       muffled <- FALSE
[18:01:09.665]                       if (inherits(cond, "message")) {
[18:01:09.665]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.665]                         if (muffled) 
[18:01:09.665]                           invokeRestart("muffleMessage")
[18:01:09.665]                       }
[18:01:09.665]                       else if (inherits(cond, "warning")) {
[18:01:09.665]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.665]                         if (muffled) 
[18:01:09.665]                           invokeRestart("muffleWarning")
[18:01:09.665]                       }
[18:01:09.665]                       else if (inherits(cond, "condition")) {
[18:01:09.665]                         if (!is.null(pattern)) {
[18:01:09.665]                           computeRestarts <- base::computeRestarts
[18:01:09.665]                           grepl <- base::grepl
[18:01:09.665]                           restarts <- computeRestarts(cond)
[18:01:09.665]                           for (restart in restarts) {
[18:01:09.665]                             name <- restart$name
[18:01:09.665]                             if (is.null(name)) 
[18:01:09.665]                               next
[18:01:09.665]                             if (!grepl(pattern, name)) 
[18:01:09.665]                               next
[18:01:09.665]                             invokeRestart(restart)
[18:01:09.665]                             muffled <- TRUE
[18:01:09.665]                             break
[18:01:09.665]                           }
[18:01:09.665]                         }
[18:01:09.665]                       }
[18:01:09.665]                       invisible(muffled)
[18:01:09.665]                     }
[18:01:09.665]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.665]                   }
[18:01:09.665]                 }
[18:01:09.665]             }
[18:01:09.665]         }))
[18:01:09.665]     }, error = function(ex) {
[18:01:09.665]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.665]                 ...future.rng), started = ...future.startTime, 
[18:01:09.665]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.665]             version = "1.8"), class = "FutureResult")
[18:01:09.665]     }, finally = {
[18:01:09.665]         if (!identical(...future.workdir, getwd())) 
[18:01:09.665]             setwd(...future.workdir)
[18:01:09.665]         {
[18:01:09.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.665]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.665]             }
[18:01:09.665]             base::options(...future.oldOptions)
[18:01:09.665]             if (.Platform$OS.type == "windows") {
[18:01:09.665]                 old_names <- names(...future.oldEnvVars)
[18:01:09.665]                 envs <- base::Sys.getenv()
[18:01:09.665]                 names <- names(envs)
[18:01:09.665]                 common <- intersect(names, old_names)
[18:01:09.665]                 added <- setdiff(names, old_names)
[18:01:09.665]                 removed <- setdiff(old_names, names)
[18:01:09.665]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.665]                   envs[common]]
[18:01:09.665]                 NAMES <- toupper(changed)
[18:01:09.665]                 args <- list()
[18:01:09.665]                 for (kk in seq_along(NAMES)) {
[18:01:09.665]                   name <- changed[[kk]]
[18:01:09.665]                   NAME <- NAMES[[kk]]
[18:01:09.665]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.665]                     next
[18:01:09.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.665]                 }
[18:01:09.665]                 NAMES <- toupper(added)
[18:01:09.665]                 for (kk in seq_along(NAMES)) {
[18:01:09.665]                   name <- added[[kk]]
[18:01:09.665]                   NAME <- NAMES[[kk]]
[18:01:09.665]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.665]                     next
[18:01:09.665]                   args[[name]] <- ""
[18:01:09.665]                 }
[18:01:09.665]                 NAMES <- toupper(removed)
[18:01:09.665]                 for (kk in seq_along(NAMES)) {
[18:01:09.665]                   name <- removed[[kk]]
[18:01:09.665]                   NAME <- NAMES[[kk]]
[18:01:09.665]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.665]                     next
[18:01:09.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.665]                 }
[18:01:09.665]                 if (length(args) > 0) 
[18:01:09.665]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.665]             }
[18:01:09.665]             else {
[18:01:09.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.665]             }
[18:01:09.665]             {
[18:01:09.665]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.665]                   0L) {
[18:01:09.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.665]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.665]                   base::options(opts)
[18:01:09.665]                 }
[18:01:09.665]                 {
[18:01:09.665]                   {
[18:01:09.665]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.665]                     NULL
[18:01:09.665]                   }
[18:01:09.665]                   options(future.plan = NULL)
[18:01:09.665]                   if (is.na(NA_character_)) 
[18:01:09.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.665]                     .init = FALSE)
[18:01:09.665]                 }
[18:01:09.665]             }
[18:01:09.665]         }
[18:01:09.665]     })
[18:01:09.665]     if (TRUE) {
[18:01:09.665]         base::sink(type = "output", split = FALSE)
[18:01:09.665]         if (TRUE) {
[18:01:09.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.665]         }
[18:01:09.665]         else {
[18:01:09.665]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.665]         }
[18:01:09.665]         base::close(...future.stdout)
[18:01:09.665]         ...future.stdout <- NULL
[18:01:09.665]     }
[18:01:09.665]     ...future.result$conditions <- ...future.conditions
[18:01:09.665]     ...future.result$finished <- base::Sys.time()
[18:01:09.665]     ...future.result
[18:01:09.665] }
[18:01:09.670] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[18:01:09.671] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[18:01:09.672] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[18:01:09.672] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:09.673] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.673] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[18:01:09.674] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[18:01:09.674] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:09.675] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.675] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:09.676] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.676] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[18:01:09.677] MultisessionFuture started
[18:01:09.677] - Launch lazy future ... done
[18:01:09.678] run() for ‘MultisessionFuture’ ... done
[18:01:09.678] Created future:
[18:01:09.678] MultisessionFuture:
[18:01:09.678] Label: ‘future_Map-2’
[18:01:09.678] Expression:
[18:01:09.678] {
[18:01:09.678]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.678]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.678]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.678]         on.exit(options(oopts), add = TRUE)
[18:01:09.678]     }
[18:01:09.678]     {
[18:01:09.678]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.678]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.678]         do.call(mapply, args = args)
[18:01:09.678]     }
[18:01:09.678] }
[18:01:09.678] Lazy evaluation: FALSE
[18:01:09.678] Asynchronous evaluation: TRUE
[18:01:09.678] Local evaluation: TRUE
[18:01:09.678] Environment: R_GlobalEnv
[18:01:09.678] Capture standard output: TRUE
[18:01:09.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.678] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.678] Packages: <none>
[18:01:09.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.678] Resolved: FALSE
[18:01:09.678] Value: <not collected>
[18:01:09.678] Conditions captured: <none>
[18:01:09.678] Early signaling: FALSE
[18:01:09.678] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.678] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.691] Chunk #2 of 2 ... DONE
[18:01:09.691] Launching 2 futures (chunks) ... DONE
[18:01:09.692] Resolving 2 futures (chunks) ...
[18:01:09.692] resolve() on list ...
[18:01:09.692]  recursive: 0
[18:01:09.692]  length: 2
[18:01:09.692] 
[18:01:09.693] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.694] - Validating connection of MultisessionFuture
[18:01:09.694] - received message: FutureResult
[18:01:09.694] - Received FutureResult
[18:01:09.694] - Erased future from FutureRegistry
[18:01:09.695] result() for ClusterFuture ...
[18:01:09.695] - result already collected: FutureResult
[18:01:09.695] result() for ClusterFuture ... done
[18:01:09.695] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.695] Future #1
[18:01:09.695] result() for ClusterFuture ...
[18:01:09.696] - result already collected: FutureResult
[18:01:09.696] result() for ClusterFuture ... done
[18:01:09.696] result() for ClusterFuture ...
[18:01:09.696] - result already collected: FutureResult
[18:01:09.696] result() for ClusterFuture ... done
[18:01:09.697] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:09.697] - nx: 2
[18:01:09.697] - relay: TRUE
[18:01:09.697] - stdout: TRUE
[18:01:09.697] - signal: TRUE
[18:01:09.697] - resignal: FALSE
[18:01:09.698] - force: TRUE
[18:01:09.698] - relayed: [n=2] FALSE, FALSE
[18:01:09.698] - queued futures: [n=2] FALSE, FALSE
[18:01:09.698]  - until=1
[18:01:09.698]  - relaying element #1
[18:01:09.699] result() for ClusterFuture ...
[18:01:09.699] - result already collected: FutureResult
[18:01:09.699] result() for ClusterFuture ... done
[18:01:09.699] result() for ClusterFuture ...
[18:01:09.699] - result already collected: FutureResult
[18:01:09.699] result() for ClusterFuture ... done
[18:01:09.700] result() for ClusterFuture ...
[18:01:09.700] - result already collected: FutureResult
[18:01:09.700] result() for ClusterFuture ... done
[18:01:09.700] result() for ClusterFuture ...
[18:01:09.700] - result already collected: FutureResult
[18:01:09.701] result() for ClusterFuture ... done
[18:01:09.701] - relayed: [n=2] TRUE, FALSE
[18:01:09.701] - queued futures: [n=2] TRUE, FALSE
[18:01:09.701] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:09.702]  length: 1 (resolved future 1)
[18:01:09.724] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.724] - Validating connection of MultisessionFuture
[18:01:09.724] - received message: FutureResult
[18:01:09.725] - Received FutureResult
[18:01:09.725] - Erased future from FutureRegistry
[18:01:09.725] result() for ClusterFuture ...
[18:01:09.725] - result already collected: FutureResult
[18:01:09.725] result() for ClusterFuture ... done
[18:01:09.726] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.726] Future #2
[18:01:09.726] result() for ClusterFuture ...
[18:01:09.726] - result already collected: FutureResult
[18:01:09.726] result() for ClusterFuture ... done
[18:01:09.727] result() for ClusterFuture ...
[18:01:09.727] - result already collected: FutureResult
[18:01:09.727] result() for ClusterFuture ... done
[18:01:09.727] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:09.727] - nx: 2
[18:01:09.728] - relay: TRUE
[18:01:09.728] - stdout: TRUE
[18:01:09.728] - signal: TRUE
[18:01:09.728] - resignal: FALSE
[18:01:09.728] - force: TRUE
[18:01:09.728] - relayed: [n=2] TRUE, FALSE
[18:01:09.729] - queued futures: [n=2] TRUE, FALSE
[18:01:09.729]  - until=2
[18:01:09.729]  - relaying element #2
[18:01:09.729] result() for ClusterFuture ...
[18:01:09.729] - result already collected: FutureResult
[18:01:09.730] result() for ClusterFuture ... done
[18:01:09.730] result() for ClusterFuture ...
[18:01:09.730] - result already collected: FutureResult
[18:01:09.730] result() for ClusterFuture ... done
[18:01:09.730] result() for ClusterFuture ...
[18:01:09.731] - result already collected: FutureResult
[18:01:09.731] result() for ClusterFuture ... done
[18:01:09.731] result() for ClusterFuture ...
[18:01:09.731] - result already collected: FutureResult
[18:01:09.731] result() for ClusterFuture ... done
[18:01:09.732] - relayed: [n=2] TRUE, TRUE
[18:01:09.732] - queued futures: [n=2] TRUE, TRUE
[18:01:09.732] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:09.732]  length: 0 (resolved future 2)
[18:01:09.732] Relaying remaining futures
[18:01:09.732] signalConditionsASAP(NULL, pos=0) ...
[18:01:09.733] - nx: 2
[18:01:09.733] - relay: TRUE
[18:01:09.733] - stdout: TRUE
[18:01:09.733] - signal: TRUE
[18:01:09.733] - resignal: FALSE
[18:01:09.734] - force: TRUE
[18:01:09.734] - relayed: [n=2] TRUE, TRUE
[18:01:09.734] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:09.734] - relayed: [n=2] TRUE, TRUE
[18:01:09.734] - queued futures: [n=2] TRUE, TRUE
[18:01:09.735] signalConditionsASAP(NULL, pos=0) ... done
[18:01:09.735] resolve() on list ... DONE
[18:01:09.735] result() for ClusterFuture ...
[18:01:09.735] - result already collected: FutureResult
[18:01:09.735] result() for ClusterFuture ... done
[18:01:09.736] result() for ClusterFuture ...
[18:01:09.736] - result already collected: FutureResult
[18:01:09.736] result() for ClusterFuture ... done
[18:01:09.736] result() for ClusterFuture ...
[18:01:09.736] - result already collected: FutureResult
[18:01:09.736] result() for ClusterFuture ... done
[18:01:09.737] result() for ClusterFuture ...
[18:01:09.737] - result already collected: FutureResult
[18:01:09.737] result() for ClusterFuture ... done
[18:01:09.737]  - Number of value chunks collected: 2
[18:01:09.737] Resolving 2 futures (chunks) ... DONE
[18:01:09.738] Reducing values from 2 chunks ...
[18:01:09.738]  - Number of values collected after concatenation: 3
[18:01:09.738]  - Number of values expected: 3
[18:01:09.738] Reducing values from 2 chunks ... DONE
[18:01:09.738] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[18:01:09.739] future_mapply() ...
[18:01:09.746] Number of chunks: 2
[18:01:09.746] getGlobalsAndPackagesXApply() ...
[18:01:09.746]  - future.globals: TRUE
[18:01:09.746] getGlobalsAndPackages() ...
[18:01:09.746] Searching for globals...
[18:01:09.748] - globals found: [1] ‘FUN’
[18:01:09.749] Searching for globals ... DONE
[18:01:09.749] Resolving globals: FALSE
[18:01:09.749] The total size of the 1 globals is 848 bytes (848 bytes)
[18:01:09.750] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[18:01:09.750] - globals: [1] ‘FUN’
[18:01:09.750] 
[18:01:09.751] getGlobalsAndPackages() ... DONE
[18:01:09.751]  - globals found/used: [n=1] ‘FUN’
[18:01:09.751]  - needed namespaces: [n=0] 
[18:01:09.751] Finding globals ... DONE
[18:01:09.752] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:01:09.752] List of 2
[18:01:09.752]  $ ...future.FUN:function (x)  
[18:01:09.752]  $ MoreArgs     : NULL
[18:01:09.752]  - attr(*, "where")=List of 2
[18:01:09.752]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:09.752]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:01:09.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:09.752]  - attr(*, "resolved")= logi FALSE
[18:01:09.752]  - attr(*, "total_size")= num NA
[18:01:09.757] Packages to be attached in all futures: [n=0] 
[18:01:09.757] getGlobalsAndPackagesXApply() ... DONE
[18:01:09.757] Number of futures (= number of chunks): 2
[18:01:09.757] Launching 2 futures (chunks) ...
[18:01:09.758] Chunk #1 of 2 ...
[18:01:09.758]  - Finding globals in '...' for chunk #1 ...
[18:01:09.758] getGlobalsAndPackages() ...
[18:01:09.758] Searching for globals...
[18:01:09.759] 
[18:01:09.759] Searching for globals ... DONE
[18:01:09.759] - globals: [0] <none>
[18:01:09.759] getGlobalsAndPackages() ... DONE
[18:01:09.759]    + additional globals found: [n=0] 
[18:01:09.760]    + additional namespaces needed: [n=0] 
[18:01:09.760]  - Finding globals in '...' for chunk #1 ... DONE
[18:01:09.760]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.760]  - seeds: <none>
[18:01:09.760]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.761] getGlobalsAndPackages() ...
[18:01:09.761] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.761] Resolving globals: FALSE
[18:01:09.762] The total size of the 5 globals is 904 bytes (904 bytes)
[18:01:09.763] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.763] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.763] 
[18:01:09.764] getGlobalsAndPackages() ... DONE
[18:01:09.764] run() for ‘Future’ ...
[18:01:09.764] - state: ‘created’
[18:01:09.765] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.789] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.790]   - Field: ‘node’
[18:01:09.790]   - Field: ‘label’
[18:01:09.790]   - Field: ‘local’
[18:01:09.790]   - Field: ‘owner’
[18:01:09.791]   - Field: ‘envir’
[18:01:09.791]   - Field: ‘workers’
[18:01:09.791]   - Field: ‘packages’
[18:01:09.791]   - Field: ‘gc’
[18:01:09.791]   - Field: ‘conditions’
[18:01:09.792]   - Field: ‘persistent’
[18:01:09.792]   - Field: ‘expr’
[18:01:09.792]   - Field: ‘uuid’
[18:01:09.792]   - Field: ‘seed’
[18:01:09.793]   - Field: ‘version’
[18:01:09.793]   - Field: ‘result’
[18:01:09.793]   - Field: ‘asynchronous’
[18:01:09.793]   - Field: ‘calls’
[18:01:09.793]   - Field: ‘globals’
[18:01:09.794]   - Field: ‘stdout’
[18:01:09.794]   - Field: ‘earlySignal’
[18:01:09.794]   - Field: ‘lazy’
[18:01:09.794]   - Field: ‘state’
[18:01:09.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.795] - Launch lazy future ...
[18:01:09.795] Packages needed by the future expression (n = 0): <none>
[18:01:09.795] Packages needed by future strategies (n = 0): <none>
[18:01:09.797] {
[18:01:09.797]     {
[18:01:09.797]         {
[18:01:09.797]             ...future.startTime <- base::Sys.time()
[18:01:09.797]             {
[18:01:09.797]                 {
[18:01:09.797]                   {
[18:01:09.797]                     {
[18:01:09.797]                       base::local({
[18:01:09.797]                         has_future <- base::requireNamespace("future", 
[18:01:09.797]                           quietly = TRUE)
[18:01:09.797]                         if (has_future) {
[18:01:09.797]                           ns <- base::getNamespace("future")
[18:01:09.797]                           version <- ns[[".package"]][["version"]]
[18:01:09.797]                           if (is.null(version)) 
[18:01:09.797]                             version <- utils::packageVersion("future")
[18:01:09.797]                         }
[18:01:09.797]                         else {
[18:01:09.797]                           version <- NULL
[18:01:09.797]                         }
[18:01:09.797]                         if (!has_future || version < "1.8.0") {
[18:01:09.797]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.797]                             "", base::R.version$version.string), 
[18:01:09.797]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:09.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:09.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.797]                               "release", "version")], collapse = " "), 
[18:01:09.797]                             hostname = base::Sys.info()[["nodename"]])
[18:01:09.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.797]                             info)
[18:01:09.797]                           info <- base::paste(info, collapse = "; ")
[18:01:09.797]                           if (!has_future) {
[18:01:09.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.797]                               info)
[18:01:09.797]                           }
[18:01:09.797]                           else {
[18:01:09.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.797]                               info, version)
[18:01:09.797]                           }
[18:01:09.797]                           base::stop(msg)
[18:01:09.797]                         }
[18:01:09.797]                       })
[18:01:09.797]                     }
[18:01:09.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.797]                     base::options(mc.cores = 1L)
[18:01:09.797]                   }
[18:01:09.797]                   ...future.strategy.old <- future::plan("list")
[18:01:09.797]                   options(future.plan = NULL)
[18:01:09.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.797]                 }
[18:01:09.797]                 ...future.workdir <- getwd()
[18:01:09.797]             }
[18:01:09.797]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.797]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.797]         }
[18:01:09.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.797]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.797]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.797]             base::names(...future.oldOptions))
[18:01:09.797]     }
[18:01:09.797]     if (FALSE) {
[18:01:09.797]     }
[18:01:09.797]     else {
[18:01:09.797]         if (TRUE) {
[18:01:09.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.797]                 open = "w")
[18:01:09.797]         }
[18:01:09.797]         else {
[18:01:09.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.797]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.797]         }
[18:01:09.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.797]             base::sink(type = "output", split = FALSE)
[18:01:09.797]             base::close(...future.stdout)
[18:01:09.797]         }, add = TRUE)
[18:01:09.797]     }
[18:01:09.797]     ...future.frame <- base::sys.nframe()
[18:01:09.797]     ...future.conditions <- base::list()
[18:01:09.797]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.797]     if (FALSE) {
[18:01:09.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.797]     }
[18:01:09.797]     ...future.result <- base::tryCatch({
[18:01:09.797]         base::withCallingHandlers({
[18:01:09.797]             ...future.value <- base::withVisible(base::local({
[18:01:09.797]                 ...future.makeSendCondition <- base::local({
[18:01:09.797]                   sendCondition <- NULL
[18:01:09.797]                   function(frame = 1L) {
[18:01:09.797]                     if (is.function(sendCondition)) 
[18:01:09.797]                       return(sendCondition)
[18:01:09.797]                     ns <- getNamespace("parallel")
[18:01:09.797]                     if (exists("sendData", mode = "function", 
[18:01:09.797]                       envir = ns)) {
[18:01:09.797]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.797]                         envir = ns)
[18:01:09.797]                       envir <- sys.frame(frame)
[18:01:09.797]                       master <- NULL
[18:01:09.797]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.797]                         !identical(envir, emptyenv())) {
[18:01:09.797]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.797]                           inherits = FALSE)) {
[18:01:09.797]                           master <- get("master", mode = "list", 
[18:01:09.797]                             envir = envir, inherits = FALSE)
[18:01:09.797]                           if (inherits(master, c("SOCKnode", 
[18:01:09.797]                             "SOCK0node"))) {
[18:01:09.797]                             sendCondition <<- function(cond) {
[18:01:09.797]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.797]                                 success = TRUE)
[18:01:09.797]                               parallel_sendData(master, data)
[18:01:09.797]                             }
[18:01:09.797]                             return(sendCondition)
[18:01:09.797]                           }
[18:01:09.797]                         }
[18:01:09.797]                         frame <- frame + 1L
[18:01:09.797]                         envir <- sys.frame(frame)
[18:01:09.797]                       }
[18:01:09.797]                     }
[18:01:09.797]                     sendCondition <<- function(cond) NULL
[18:01:09.797]                   }
[18:01:09.797]                 })
[18:01:09.797]                 withCallingHandlers({
[18:01:09.797]                   {
[18:01:09.797]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.797]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.797]                       ...future.globals.maxSize)) {
[18:01:09.797]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.797]                       on.exit(options(oopts), add = TRUE)
[18:01:09.797]                     }
[18:01:09.797]                     {
[18:01:09.797]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.797]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.797]                         USE.NAMES = FALSE)
[18:01:09.797]                       do.call(mapply, args = args)
[18:01:09.797]                     }
[18:01:09.797]                   }
[18:01:09.797]                 }, immediateCondition = function(cond) {
[18:01:09.797]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.797]                   sendCondition(cond)
[18:01:09.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.797]                   {
[18:01:09.797]                     inherits <- base::inherits
[18:01:09.797]                     invokeRestart <- base::invokeRestart
[18:01:09.797]                     is.null <- base::is.null
[18:01:09.797]                     muffled <- FALSE
[18:01:09.797]                     if (inherits(cond, "message")) {
[18:01:09.797]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.797]                       if (muffled) 
[18:01:09.797]                         invokeRestart("muffleMessage")
[18:01:09.797]                     }
[18:01:09.797]                     else if (inherits(cond, "warning")) {
[18:01:09.797]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.797]                       if (muffled) 
[18:01:09.797]                         invokeRestart("muffleWarning")
[18:01:09.797]                     }
[18:01:09.797]                     else if (inherits(cond, "condition")) {
[18:01:09.797]                       if (!is.null(pattern)) {
[18:01:09.797]                         computeRestarts <- base::computeRestarts
[18:01:09.797]                         grepl <- base::grepl
[18:01:09.797]                         restarts <- computeRestarts(cond)
[18:01:09.797]                         for (restart in restarts) {
[18:01:09.797]                           name <- restart$name
[18:01:09.797]                           if (is.null(name)) 
[18:01:09.797]                             next
[18:01:09.797]                           if (!grepl(pattern, name)) 
[18:01:09.797]                             next
[18:01:09.797]                           invokeRestart(restart)
[18:01:09.797]                           muffled <- TRUE
[18:01:09.797]                           break
[18:01:09.797]                         }
[18:01:09.797]                       }
[18:01:09.797]                     }
[18:01:09.797]                     invisible(muffled)
[18:01:09.797]                   }
[18:01:09.797]                   muffleCondition(cond)
[18:01:09.797]                 })
[18:01:09.797]             }))
[18:01:09.797]             future::FutureResult(value = ...future.value$value, 
[18:01:09.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.797]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.797]                     ...future.globalenv.names))
[18:01:09.797]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.797]         }, condition = base::local({
[18:01:09.797]             c <- base::c
[18:01:09.797]             inherits <- base::inherits
[18:01:09.797]             invokeRestart <- base::invokeRestart
[18:01:09.797]             length <- base::length
[18:01:09.797]             list <- base::list
[18:01:09.797]             seq.int <- base::seq.int
[18:01:09.797]             signalCondition <- base::signalCondition
[18:01:09.797]             sys.calls <- base::sys.calls
[18:01:09.797]             `[[` <- base::`[[`
[18:01:09.797]             `+` <- base::`+`
[18:01:09.797]             `<<-` <- base::`<<-`
[18:01:09.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.797]                   3L)]
[18:01:09.797]             }
[18:01:09.797]             function(cond) {
[18:01:09.797]                 is_error <- inherits(cond, "error")
[18:01:09.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.797]                   NULL)
[18:01:09.797]                 if (is_error) {
[18:01:09.797]                   sessionInformation <- function() {
[18:01:09.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.797]                       search = base::search(), system = base::Sys.info())
[18:01:09.797]                   }
[18:01:09.797]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.797]                     cond$call), session = sessionInformation(), 
[18:01:09.797]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.797]                   signalCondition(cond)
[18:01:09.797]                 }
[18:01:09.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.797]                 "immediateCondition"))) {
[18:01:09.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.797]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.797]                   if (TRUE && !signal) {
[18:01:09.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.797]                     {
[18:01:09.797]                       inherits <- base::inherits
[18:01:09.797]                       invokeRestart <- base::invokeRestart
[18:01:09.797]                       is.null <- base::is.null
[18:01:09.797]                       muffled <- FALSE
[18:01:09.797]                       if (inherits(cond, "message")) {
[18:01:09.797]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.797]                         if (muffled) 
[18:01:09.797]                           invokeRestart("muffleMessage")
[18:01:09.797]                       }
[18:01:09.797]                       else if (inherits(cond, "warning")) {
[18:01:09.797]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.797]                         if (muffled) 
[18:01:09.797]                           invokeRestart("muffleWarning")
[18:01:09.797]                       }
[18:01:09.797]                       else if (inherits(cond, "condition")) {
[18:01:09.797]                         if (!is.null(pattern)) {
[18:01:09.797]                           computeRestarts <- base::computeRestarts
[18:01:09.797]                           grepl <- base::grepl
[18:01:09.797]                           restarts <- computeRestarts(cond)
[18:01:09.797]                           for (restart in restarts) {
[18:01:09.797]                             name <- restart$name
[18:01:09.797]                             if (is.null(name)) 
[18:01:09.797]                               next
[18:01:09.797]                             if (!grepl(pattern, name)) 
[18:01:09.797]                               next
[18:01:09.797]                             invokeRestart(restart)
[18:01:09.797]                             muffled <- TRUE
[18:01:09.797]                             break
[18:01:09.797]                           }
[18:01:09.797]                         }
[18:01:09.797]                       }
[18:01:09.797]                       invisible(muffled)
[18:01:09.797]                     }
[18:01:09.797]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.797]                   }
[18:01:09.797]                 }
[18:01:09.797]                 else {
[18:01:09.797]                   if (TRUE) {
[18:01:09.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.797]                     {
[18:01:09.797]                       inherits <- base::inherits
[18:01:09.797]                       invokeRestart <- base::invokeRestart
[18:01:09.797]                       is.null <- base::is.null
[18:01:09.797]                       muffled <- FALSE
[18:01:09.797]                       if (inherits(cond, "message")) {
[18:01:09.797]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.797]                         if (muffled) 
[18:01:09.797]                           invokeRestart("muffleMessage")
[18:01:09.797]                       }
[18:01:09.797]                       else if (inherits(cond, "warning")) {
[18:01:09.797]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.797]                         if (muffled) 
[18:01:09.797]                           invokeRestart("muffleWarning")
[18:01:09.797]                       }
[18:01:09.797]                       else if (inherits(cond, "condition")) {
[18:01:09.797]                         if (!is.null(pattern)) {
[18:01:09.797]                           computeRestarts <- base::computeRestarts
[18:01:09.797]                           grepl <- base::grepl
[18:01:09.797]                           restarts <- computeRestarts(cond)
[18:01:09.797]                           for (restart in restarts) {
[18:01:09.797]                             name <- restart$name
[18:01:09.797]                             if (is.null(name)) 
[18:01:09.797]                               next
[18:01:09.797]                             if (!grepl(pattern, name)) 
[18:01:09.797]                               next
[18:01:09.797]                             invokeRestart(restart)
[18:01:09.797]                             muffled <- TRUE
[18:01:09.797]                             break
[18:01:09.797]                           }
[18:01:09.797]                         }
[18:01:09.797]                       }
[18:01:09.797]                       invisible(muffled)
[18:01:09.797]                     }
[18:01:09.797]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.797]                   }
[18:01:09.797]                 }
[18:01:09.797]             }
[18:01:09.797]         }))
[18:01:09.797]     }, error = function(ex) {
[18:01:09.797]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.797]                 ...future.rng), started = ...future.startTime, 
[18:01:09.797]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.797]             version = "1.8"), class = "FutureResult")
[18:01:09.797]     }, finally = {
[18:01:09.797]         if (!identical(...future.workdir, getwd())) 
[18:01:09.797]             setwd(...future.workdir)
[18:01:09.797]         {
[18:01:09.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.797]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.797]             }
[18:01:09.797]             base::options(...future.oldOptions)
[18:01:09.797]             if (.Platform$OS.type == "windows") {
[18:01:09.797]                 old_names <- names(...future.oldEnvVars)
[18:01:09.797]                 envs <- base::Sys.getenv()
[18:01:09.797]                 names <- names(envs)
[18:01:09.797]                 common <- intersect(names, old_names)
[18:01:09.797]                 added <- setdiff(names, old_names)
[18:01:09.797]                 removed <- setdiff(old_names, names)
[18:01:09.797]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.797]                   envs[common]]
[18:01:09.797]                 NAMES <- toupper(changed)
[18:01:09.797]                 args <- list()
[18:01:09.797]                 for (kk in seq_along(NAMES)) {
[18:01:09.797]                   name <- changed[[kk]]
[18:01:09.797]                   NAME <- NAMES[[kk]]
[18:01:09.797]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.797]                     next
[18:01:09.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.797]                 }
[18:01:09.797]                 NAMES <- toupper(added)
[18:01:09.797]                 for (kk in seq_along(NAMES)) {
[18:01:09.797]                   name <- added[[kk]]
[18:01:09.797]                   NAME <- NAMES[[kk]]
[18:01:09.797]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.797]                     next
[18:01:09.797]                   args[[name]] <- ""
[18:01:09.797]                 }
[18:01:09.797]                 NAMES <- toupper(removed)
[18:01:09.797]                 for (kk in seq_along(NAMES)) {
[18:01:09.797]                   name <- removed[[kk]]
[18:01:09.797]                   NAME <- NAMES[[kk]]
[18:01:09.797]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.797]                     next
[18:01:09.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.797]                 }
[18:01:09.797]                 if (length(args) > 0) 
[18:01:09.797]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.797]             }
[18:01:09.797]             else {
[18:01:09.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.797]             }
[18:01:09.797]             {
[18:01:09.797]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.797]                   0L) {
[18:01:09.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.797]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.797]                   base::options(opts)
[18:01:09.797]                 }
[18:01:09.797]                 {
[18:01:09.797]                   {
[18:01:09.797]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.797]                     NULL
[18:01:09.797]                   }
[18:01:09.797]                   options(future.plan = NULL)
[18:01:09.797]                   if (is.na(NA_character_)) 
[18:01:09.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.797]                     .init = FALSE)
[18:01:09.797]                 }
[18:01:09.797]             }
[18:01:09.797]         }
[18:01:09.797]     })
[18:01:09.797]     if (TRUE) {
[18:01:09.797]         base::sink(type = "output", split = FALSE)
[18:01:09.797]         if (TRUE) {
[18:01:09.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.797]         }
[18:01:09.797]         else {
[18:01:09.797]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.797]         }
[18:01:09.797]         base::close(...future.stdout)
[18:01:09.797]         ...future.stdout <- NULL
[18:01:09.797]     }
[18:01:09.797]     ...future.result$conditions <- ...future.conditions
[18:01:09.797]     ...future.result$finished <- base::Sys.time()
[18:01:09.797]     ...future.result
[18:01:09.797] }
[18:01:09.802] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[18:01:09.802] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[18:01:09.803] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[18:01:09.803] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:01:09.804] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.804] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:01:09.805] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:01:09.805] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:01:09.806] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.806] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:01:09.807] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:01:09.807] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[18:01:09.808] MultisessionFuture started
[18:01:09.808] - Launch lazy future ... done
[18:01:09.808] run() for ‘MultisessionFuture’ ... done
[18:01:09.809] Created future:
[18:01:09.809] MultisessionFuture:
[18:01:09.809] Label: ‘future_mapply-1’
[18:01:09.809] Expression:
[18:01:09.809] {
[18:01:09.809]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.809]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.809]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.809]         on.exit(options(oopts), add = TRUE)
[18:01:09.809]     }
[18:01:09.809]     {
[18:01:09.809]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.809]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.809]         do.call(mapply, args = args)
[18:01:09.809]     }
[18:01:09.809] }
[18:01:09.809] Lazy evaluation: FALSE
[18:01:09.809] Asynchronous evaluation: TRUE
[18:01:09.809] Local evaluation: TRUE
[18:01:09.809] Environment: R_GlobalEnv
[18:01:09.809] Capture standard output: TRUE
[18:01:09.809] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.809] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.809] Packages: <none>
[18:01:09.809] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.809] Resolved: FALSE
[18:01:09.809] Value: <not collected>
[18:01:09.809] Conditions captured: <none>
[18:01:09.809] Early signaling: FALSE
[18:01:09.809] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.809] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.822] Chunk #1 of 2 ... DONE
[18:01:09.822] Chunk #2 of 2 ...
[18:01:09.822]  - Finding globals in '...' for chunk #2 ...
[18:01:09.822] getGlobalsAndPackages() ...
[18:01:09.826] Searching for globals...
[18:01:09.827] 
[18:01:09.827] Searching for globals ... DONE
[18:01:09.827] - globals: [0] <none>
[18:01:09.827] getGlobalsAndPackages() ... DONE
[18:01:09.827]    + additional globals found: [n=0] 
[18:01:09.827]    + additional namespaces needed: [n=0] 
[18:01:09.828]  - Finding globals in '...' for chunk #2 ... DONE
[18:01:09.828]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:09.828]  - seeds: <none>
[18:01:09.828]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.828] getGlobalsAndPackages() ...
[18:01:09.829] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.829] Resolving globals: FALSE
[18:01:09.830] The total size of the 5 globals is 904 bytes (904 bytes)
[18:01:09.831] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:01:09.831] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:09.831] 
[18:01:09.831] getGlobalsAndPackages() ... DONE
[18:01:09.832] run() for ‘Future’ ...
[18:01:09.832] - state: ‘created’
[18:01:09.832] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:01:09.854] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:01:09.855]   - Field: ‘node’
[18:01:09.855]   - Field: ‘label’
[18:01:09.855]   - Field: ‘local’
[18:01:09.855]   - Field: ‘owner’
[18:01:09.856]   - Field: ‘envir’
[18:01:09.856]   - Field: ‘workers’
[18:01:09.856]   - Field: ‘packages’
[18:01:09.856]   - Field: ‘gc’
[18:01:09.856]   - Field: ‘conditions’
[18:01:09.857]   - Field: ‘persistent’
[18:01:09.857]   - Field: ‘expr’
[18:01:09.857]   - Field: ‘uuid’
[18:01:09.857]   - Field: ‘seed’
[18:01:09.857]   - Field: ‘version’
[18:01:09.858]   - Field: ‘result’
[18:01:09.858]   - Field: ‘asynchronous’
[18:01:09.858]   - Field: ‘calls’
[18:01:09.858]   - Field: ‘globals’
[18:01:09.858]   - Field: ‘stdout’
[18:01:09.859]   - Field: ‘earlySignal’
[18:01:09.859]   - Field: ‘lazy’
[18:01:09.859]   - Field: ‘state’
[18:01:09.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:01:09.859] - Launch lazy future ...
[18:01:09.860] Packages needed by the future expression (n = 0): <none>
[18:01:09.860] Packages needed by future strategies (n = 0): <none>
[18:01:09.861] {
[18:01:09.861]     {
[18:01:09.861]         {
[18:01:09.861]             ...future.startTime <- base::Sys.time()
[18:01:09.861]             {
[18:01:09.861]                 {
[18:01:09.861]                   {
[18:01:09.861]                     {
[18:01:09.861]                       base::local({
[18:01:09.861]                         has_future <- base::requireNamespace("future", 
[18:01:09.861]                           quietly = TRUE)
[18:01:09.861]                         if (has_future) {
[18:01:09.861]                           ns <- base::getNamespace("future")
[18:01:09.861]                           version <- ns[[".package"]][["version"]]
[18:01:09.861]                           if (is.null(version)) 
[18:01:09.861]                             version <- utils::packageVersion("future")
[18:01:09.861]                         }
[18:01:09.861]                         else {
[18:01:09.861]                           version <- NULL
[18:01:09.861]                         }
[18:01:09.861]                         if (!has_future || version < "1.8.0") {
[18:01:09.861]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:09.861]                             "", base::R.version$version.string), 
[18:01:09.861]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:09.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:09.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:09.861]                               "release", "version")], collapse = " "), 
[18:01:09.861]                             hostname = base::Sys.info()[["nodename"]])
[18:01:09.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:09.861]                             info)
[18:01:09.861]                           info <- base::paste(info, collapse = "; ")
[18:01:09.861]                           if (!has_future) {
[18:01:09.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:09.861]                               info)
[18:01:09.861]                           }
[18:01:09.861]                           else {
[18:01:09.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:09.861]                               info, version)
[18:01:09.861]                           }
[18:01:09.861]                           base::stop(msg)
[18:01:09.861]                         }
[18:01:09.861]                       })
[18:01:09.861]                     }
[18:01:09.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:09.861]                     base::options(mc.cores = 1L)
[18:01:09.861]                   }
[18:01:09.861]                   ...future.strategy.old <- future::plan("list")
[18:01:09.861]                   options(future.plan = NULL)
[18:01:09.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:09.861]                 }
[18:01:09.861]                 ...future.workdir <- getwd()
[18:01:09.861]             }
[18:01:09.861]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:09.861]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:09.861]         }
[18:01:09.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:09.861]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:09.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:09.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:09.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:09.861]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:09.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:09.861]             base::names(...future.oldOptions))
[18:01:09.861]     }
[18:01:09.861]     if (FALSE) {
[18:01:09.861]     }
[18:01:09.861]     else {
[18:01:09.861]         if (TRUE) {
[18:01:09.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:09.861]                 open = "w")
[18:01:09.861]         }
[18:01:09.861]         else {
[18:01:09.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:09.861]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:09.861]         }
[18:01:09.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:09.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:09.861]             base::sink(type = "output", split = FALSE)
[18:01:09.861]             base::close(...future.stdout)
[18:01:09.861]         }, add = TRUE)
[18:01:09.861]     }
[18:01:09.861]     ...future.frame <- base::sys.nframe()
[18:01:09.861]     ...future.conditions <- base::list()
[18:01:09.861]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:09.861]     if (FALSE) {
[18:01:09.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:09.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:09.861]     }
[18:01:09.861]     ...future.result <- base::tryCatch({
[18:01:09.861]         base::withCallingHandlers({
[18:01:09.861]             ...future.value <- base::withVisible(base::local({
[18:01:09.861]                 ...future.makeSendCondition <- base::local({
[18:01:09.861]                   sendCondition <- NULL
[18:01:09.861]                   function(frame = 1L) {
[18:01:09.861]                     if (is.function(sendCondition)) 
[18:01:09.861]                       return(sendCondition)
[18:01:09.861]                     ns <- getNamespace("parallel")
[18:01:09.861]                     if (exists("sendData", mode = "function", 
[18:01:09.861]                       envir = ns)) {
[18:01:09.861]                       parallel_sendData <- get("sendData", mode = "function", 
[18:01:09.861]                         envir = ns)
[18:01:09.861]                       envir <- sys.frame(frame)
[18:01:09.861]                       master <- NULL
[18:01:09.861]                       while (!identical(envir, .GlobalEnv) && 
[18:01:09.861]                         !identical(envir, emptyenv())) {
[18:01:09.861]                         if (exists("master", mode = "list", envir = envir, 
[18:01:09.861]                           inherits = FALSE)) {
[18:01:09.861]                           master <- get("master", mode = "list", 
[18:01:09.861]                             envir = envir, inherits = FALSE)
[18:01:09.861]                           if (inherits(master, c("SOCKnode", 
[18:01:09.861]                             "SOCK0node"))) {
[18:01:09.861]                             sendCondition <<- function(cond) {
[18:01:09.861]                               data <- list(type = "VALUE", value = cond, 
[18:01:09.861]                                 success = TRUE)
[18:01:09.861]                               parallel_sendData(master, data)
[18:01:09.861]                             }
[18:01:09.861]                             return(sendCondition)
[18:01:09.861]                           }
[18:01:09.861]                         }
[18:01:09.861]                         frame <- frame + 1L
[18:01:09.861]                         envir <- sys.frame(frame)
[18:01:09.861]                       }
[18:01:09.861]                     }
[18:01:09.861]                     sendCondition <<- function(cond) NULL
[18:01:09.861]                   }
[18:01:09.861]                 })
[18:01:09.861]                 withCallingHandlers({
[18:01:09.861]                   {
[18:01:09.861]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.861]                     if (!identical(...future.globals.maxSize.org, 
[18:01:09.861]                       ...future.globals.maxSize)) {
[18:01:09.861]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.861]                       on.exit(options(oopts), add = TRUE)
[18:01:09.861]                     }
[18:01:09.861]                     {
[18:01:09.861]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.861]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:01:09.861]                         USE.NAMES = FALSE)
[18:01:09.861]                       do.call(mapply, args = args)
[18:01:09.861]                     }
[18:01:09.861]                   }
[18:01:09.861]                 }, immediateCondition = function(cond) {
[18:01:09.861]                   sendCondition <- ...future.makeSendCondition()
[18:01:09.861]                   sendCondition(cond)
[18:01:09.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.861]                   {
[18:01:09.861]                     inherits <- base::inherits
[18:01:09.861]                     invokeRestart <- base::invokeRestart
[18:01:09.861]                     is.null <- base::is.null
[18:01:09.861]                     muffled <- FALSE
[18:01:09.861]                     if (inherits(cond, "message")) {
[18:01:09.861]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:09.861]                       if (muffled) 
[18:01:09.861]                         invokeRestart("muffleMessage")
[18:01:09.861]                     }
[18:01:09.861]                     else if (inherits(cond, "warning")) {
[18:01:09.861]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:09.861]                       if (muffled) 
[18:01:09.861]                         invokeRestart("muffleWarning")
[18:01:09.861]                     }
[18:01:09.861]                     else if (inherits(cond, "condition")) {
[18:01:09.861]                       if (!is.null(pattern)) {
[18:01:09.861]                         computeRestarts <- base::computeRestarts
[18:01:09.861]                         grepl <- base::grepl
[18:01:09.861]                         restarts <- computeRestarts(cond)
[18:01:09.861]                         for (restart in restarts) {
[18:01:09.861]                           name <- restart$name
[18:01:09.861]                           if (is.null(name)) 
[18:01:09.861]                             next
[18:01:09.861]                           if (!grepl(pattern, name)) 
[18:01:09.861]                             next
[18:01:09.861]                           invokeRestart(restart)
[18:01:09.861]                           muffled <- TRUE
[18:01:09.861]                           break
[18:01:09.861]                         }
[18:01:09.861]                       }
[18:01:09.861]                     }
[18:01:09.861]                     invisible(muffled)
[18:01:09.861]                   }
[18:01:09.861]                   muffleCondition(cond)
[18:01:09.861]                 })
[18:01:09.861]             }))
[18:01:09.861]             future::FutureResult(value = ...future.value$value, 
[18:01:09.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.861]                   ...future.rng), globalenv = if (FALSE) 
[18:01:09.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:09.861]                     ...future.globalenv.names))
[18:01:09.861]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:09.861]         }, condition = base::local({
[18:01:09.861]             c <- base::c
[18:01:09.861]             inherits <- base::inherits
[18:01:09.861]             invokeRestart <- base::invokeRestart
[18:01:09.861]             length <- base::length
[18:01:09.861]             list <- base::list
[18:01:09.861]             seq.int <- base::seq.int
[18:01:09.861]             signalCondition <- base::signalCondition
[18:01:09.861]             sys.calls <- base::sys.calls
[18:01:09.861]             `[[` <- base::`[[`
[18:01:09.861]             `+` <- base::`+`
[18:01:09.861]             `<<-` <- base::`<<-`
[18:01:09.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:09.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:09.861]                   3L)]
[18:01:09.861]             }
[18:01:09.861]             function(cond) {
[18:01:09.861]                 is_error <- inherits(cond, "error")
[18:01:09.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:09.861]                   NULL)
[18:01:09.861]                 if (is_error) {
[18:01:09.861]                   sessionInformation <- function() {
[18:01:09.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:09.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:09.861]                       search = base::search(), system = base::Sys.info())
[18:01:09.861]                   }
[18:01:09.861]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:09.861]                     cond$call), session = sessionInformation(), 
[18:01:09.861]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:09.861]                   signalCondition(cond)
[18:01:09.861]                 }
[18:01:09.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:09.861]                 "immediateCondition"))) {
[18:01:09.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:09.861]                   ...future.conditions[[length(...future.conditions) + 
[18:01:09.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:09.861]                   if (TRUE && !signal) {
[18:01:09.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.861]                     {
[18:01:09.861]                       inherits <- base::inherits
[18:01:09.861]                       invokeRestart <- base::invokeRestart
[18:01:09.861]                       is.null <- base::is.null
[18:01:09.861]                       muffled <- FALSE
[18:01:09.861]                       if (inherits(cond, "message")) {
[18:01:09.861]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.861]                         if (muffled) 
[18:01:09.861]                           invokeRestart("muffleMessage")
[18:01:09.861]                       }
[18:01:09.861]                       else if (inherits(cond, "warning")) {
[18:01:09.861]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.861]                         if (muffled) 
[18:01:09.861]                           invokeRestart("muffleWarning")
[18:01:09.861]                       }
[18:01:09.861]                       else if (inherits(cond, "condition")) {
[18:01:09.861]                         if (!is.null(pattern)) {
[18:01:09.861]                           computeRestarts <- base::computeRestarts
[18:01:09.861]                           grepl <- base::grepl
[18:01:09.861]                           restarts <- computeRestarts(cond)
[18:01:09.861]                           for (restart in restarts) {
[18:01:09.861]                             name <- restart$name
[18:01:09.861]                             if (is.null(name)) 
[18:01:09.861]                               next
[18:01:09.861]                             if (!grepl(pattern, name)) 
[18:01:09.861]                               next
[18:01:09.861]                             invokeRestart(restart)
[18:01:09.861]                             muffled <- TRUE
[18:01:09.861]                             break
[18:01:09.861]                           }
[18:01:09.861]                         }
[18:01:09.861]                       }
[18:01:09.861]                       invisible(muffled)
[18:01:09.861]                     }
[18:01:09.861]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.861]                   }
[18:01:09.861]                 }
[18:01:09.861]                 else {
[18:01:09.861]                   if (TRUE) {
[18:01:09.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:09.861]                     {
[18:01:09.861]                       inherits <- base::inherits
[18:01:09.861]                       invokeRestart <- base::invokeRestart
[18:01:09.861]                       is.null <- base::is.null
[18:01:09.861]                       muffled <- FALSE
[18:01:09.861]                       if (inherits(cond, "message")) {
[18:01:09.861]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:09.861]                         if (muffled) 
[18:01:09.861]                           invokeRestart("muffleMessage")
[18:01:09.861]                       }
[18:01:09.861]                       else if (inherits(cond, "warning")) {
[18:01:09.861]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:09.861]                         if (muffled) 
[18:01:09.861]                           invokeRestart("muffleWarning")
[18:01:09.861]                       }
[18:01:09.861]                       else if (inherits(cond, "condition")) {
[18:01:09.861]                         if (!is.null(pattern)) {
[18:01:09.861]                           computeRestarts <- base::computeRestarts
[18:01:09.861]                           grepl <- base::grepl
[18:01:09.861]                           restarts <- computeRestarts(cond)
[18:01:09.861]                           for (restart in restarts) {
[18:01:09.861]                             name <- restart$name
[18:01:09.861]                             if (is.null(name)) 
[18:01:09.861]                               next
[18:01:09.861]                             if (!grepl(pattern, name)) 
[18:01:09.861]                               next
[18:01:09.861]                             invokeRestart(restart)
[18:01:09.861]                             muffled <- TRUE
[18:01:09.861]                             break
[18:01:09.861]                           }
[18:01:09.861]                         }
[18:01:09.861]                       }
[18:01:09.861]                       invisible(muffled)
[18:01:09.861]                     }
[18:01:09.861]                     muffleCondition(cond, pattern = "^muffle")
[18:01:09.861]                   }
[18:01:09.861]                 }
[18:01:09.861]             }
[18:01:09.861]         }))
[18:01:09.861]     }, error = function(ex) {
[18:01:09.861]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:09.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:09.861]                 ...future.rng), started = ...future.startTime, 
[18:01:09.861]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:09.861]             version = "1.8"), class = "FutureResult")
[18:01:09.861]     }, finally = {
[18:01:09.861]         if (!identical(...future.workdir, getwd())) 
[18:01:09.861]             setwd(...future.workdir)
[18:01:09.861]         {
[18:01:09.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:09.861]                 ...future.oldOptions$nwarnings <- NULL
[18:01:09.861]             }
[18:01:09.861]             base::options(...future.oldOptions)
[18:01:09.861]             if (.Platform$OS.type == "windows") {
[18:01:09.861]                 old_names <- names(...future.oldEnvVars)
[18:01:09.861]                 envs <- base::Sys.getenv()
[18:01:09.861]                 names <- names(envs)
[18:01:09.861]                 common <- intersect(names, old_names)
[18:01:09.861]                 added <- setdiff(names, old_names)
[18:01:09.861]                 removed <- setdiff(old_names, names)
[18:01:09.861]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:09.861]                   envs[common]]
[18:01:09.861]                 NAMES <- toupper(changed)
[18:01:09.861]                 args <- list()
[18:01:09.861]                 for (kk in seq_along(NAMES)) {
[18:01:09.861]                   name <- changed[[kk]]
[18:01:09.861]                   NAME <- NAMES[[kk]]
[18:01:09.861]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.861]                     next
[18:01:09.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.861]                 }
[18:01:09.861]                 NAMES <- toupper(added)
[18:01:09.861]                 for (kk in seq_along(NAMES)) {
[18:01:09.861]                   name <- added[[kk]]
[18:01:09.861]                   NAME <- NAMES[[kk]]
[18:01:09.861]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.861]                     next
[18:01:09.861]                   args[[name]] <- ""
[18:01:09.861]                 }
[18:01:09.861]                 NAMES <- toupper(removed)
[18:01:09.861]                 for (kk in seq_along(NAMES)) {
[18:01:09.861]                   name <- removed[[kk]]
[18:01:09.861]                   NAME <- NAMES[[kk]]
[18:01:09.861]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:09.861]                     next
[18:01:09.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:09.861]                 }
[18:01:09.861]                 if (length(args) > 0) 
[18:01:09.861]                   base::do.call(base::Sys.setenv, args = args)
[18:01:09.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:09.861]             }
[18:01:09.861]             else {
[18:01:09.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:09.861]             }
[18:01:09.861]             {
[18:01:09.861]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:09.861]                   0L) {
[18:01:09.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:09.861]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:09.861]                   base::options(opts)
[18:01:09.861]                 }
[18:01:09.861]                 {
[18:01:09.861]                   {
[18:01:09.861]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:09.861]                     NULL
[18:01:09.861]                   }
[18:01:09.861]                   options(future.plan = NULL)
[18:01:09.861]                   if (is.na(NA_character_)) 
[18:01:09.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:09.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:09.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:09.861]                     .init = FALSE)
[18:01:09.861]                 }
[18:01:09.861]             }
[18:01:09.861]         }
[18:01:09.861]     })
[18:01:09.861]     if (TRUE) {
[18:01:09.861]         base::sink(type = "output", split = FALSE)
[18:01:09.861]         if (TRUE) {
[18:01:09.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:09.861]         }
[18:01:09.861]         else {
[18:01:09.861]             ...future.result["stdout"] <- base::list(NULL)
[18:01:09.861]         }
[18:01:09.861]         base::close(...future.stdout)
[18:01:09.861]         ...future.stdout <- NULL
[18:01:09.861]     }
[18:01:09.861]     ...future.result$conditions <- ...future.conditions
[18:01:09.861]     ...future.result$finished <- base::Sys.time()
[18:01:09.861]     ...future.result
[18:01:09.861] }
[18:01:09.866] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[18:01:09.866] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[18:01:09.867] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[18:01:09.868] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:01:09.868] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.869] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:01:09.869] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:01:09.870] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:01:09.871] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.871] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:01:09.872] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:01:09.872] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[18:01:09.873] MultisessionFuture started
[18:01:09.873] - Launch lazy future ... done
[18:01:09.873] run() for ‘MultisessionFuture’ ... done
[18:01:09.874] Created future:
[18:01:09.874] MultisessionFuture:
[18:01:09.874] Label: ‘future_mapply-2’
[18:01:09.874] Expression:
[18:01:09.874] {
[18:01:09.874]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:09.874]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:09.874]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:09.874]         on.exit(options(oopts), add = TRUE)
[18:01:09.874]     }
[18:01:09.874]     {
[18:01:09.874]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:01:09.874]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:01:09.874]         do.call(mapply, args = args)
[18:01:09.874]     }
[18:01:09.874] }
[18:01:09.874] Lazy evaluation: FALSE
[18:01:09.874] Asynchronous evaluation: TRUE
[18:01:09.874] Local evaluation: TRUE
[18:01:09.874] Environment: R_GlobalEnv
[18:01:09.874] Capture standard output: TRUE
[18:01:09.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:09.874] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:09.874] Packages: <none>
[18:01:09.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:09.874] Resolved: FALSE
[18:01:09.874] Value: <not collected>
[18:01:09.874] Conditions captured: <none>
[18:01:09.874] Early signaling: FALSE
[18:01:09.874] Owner process: 40b4ad2a-d04e-5feb-5345-f620200a0192
[18:01:09.874] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:09.886] Chunk #2 of 2 ... DONE
[18:01:09.887] Launching 2 futures (chunks) ... DONE
[18:01:09.887] Resolving 2 futures (chunks) ...
[18:01:09.887] resolve() on list ...
[18:01:09.888]  recursive: 0
[18:01:09.888]  length: 2
[18:01:09.888] 
[18:01:09.889] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.889] - Validating connection of MultisessionFuture
[18:01:09.889] - received message: FutureResult
[18:01:09.890] - Received FutureResult
[18:01:09.890] - Erased future from FutureRegistry
[18:01:09.890] result() for ClusterFuture ...
[18:01:09.890] - result already collected: FutureResult
[18:01:09.890] result() for ClusterFuture ... done
[18:01:09.891] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.891] Future #1
[18:01:09.891] result() for ClusterFuture ...
[18:01:09.891] - result already collected: FutureResult
[18:01:09.891] result() for ClusterFuture ... done
[18:01:09.892] result() for ClusterFuture ...
[18:01:09.892] - result already collected: FutureResult
[18:01:09.892] result() for ClusterFuture ... done
[18:01:09.892] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:01:09.892] - nx: 2
[18:01:09.893] - relay: TRUE
[18:01:09.893] - stdout: TRUE
[18:01:09.893] - signal: TRUE
[18:01:09.893] - resignal: FALSE
[18:01:09.893] - force: TRUE
[18:01:09.893] - relayed: [n=2] FALSE, FALSE
[18:01:09.894] - queued futures: [n=2] FALSE, FALSE
[18:01:09.894]  - until=1
[18:01:09.894]  - relaying element #1
[18:01:09.894] result() for ClusterFuture ...
[18:01:09.894] - result already collected: FutureResult
[18:01:09.894] result() for ClusterFuture ... done
[18:01:09.895] result() for ClusterFuture ...
[18:01:09.895] - result already collected: FutureResult
[18:01:09.895] result() for ClusterFuture ... done
[18:01:09.895] result() for ClusterFuture ...
[18:01:09.895] - result already collected: FutureResult
[18:01:09.896] result() for ClusterFuture ... done
[18:01:09.896] result() for ClusterFuture ...
[18:01:09.896] - result already collected: FutureResult
[18:01:09.896] result() for ClusterFuture ... done
[18:01:09.896] - relayed: [n=2] TRUE, FALSE
[18:01:09.896] - queued futures: [n=2] TRUE, FALSE
[18:01:09.897] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:01:09.897]  length: 1 (resolved future 1)
[18:01:09.919] receiveMessageFromWorker() for ClusterFuture ...
[18:01:09.919] - Validating connection of MultisessionFuture
[18:01:09.920] - received message: FutureResult
[18:01:09.920] - Received FutureResult
[18:01:09.920] - Erased future from FutureRegistry
[18:01:09.920] result() for ClusterFuture ...
[18:01:09.921] - result already collected: FutureResult
[18:01:09.921] result() for ClusterFuture ... done
[18:01:09.921] receiveMessageFromWorker() for ClusterFuture ... done
[18:01:09.921] Future #2
[18:01:09.921] result() for ClusterFuture ...
[18:01:09.922] - result already collected: FutureResult
[18:01:09.922] result() for ClusterFuture ... done
[18:01:09.922] result() for ClusterFuture ...
[18:01:09.922] - result already collected: FutureResult
[18:01:09.922] result() for ClusterFuture ... done
[18:01:09.922] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:01:09.923] - nx: 2
[18:01:09.923] - relay: TRUE
[18:01:09.923] - stdout: TRUE
[18:01:09.923] - signal: TRUE
[18:01:09.923] - resignal: FALSE
[18:01:09.923] - force: TRUE
[18:01:09.924] - relayed: [n=2] TRUE, FALSE
[18:01:09.924] - queued futures: [n=2] TRUE, FALSE
[18:01:09.924]  - until=2
[18:01:09.924]  - relaying element #2
[18:01:09.924] result() for ClusterFuture ...
[18:01:09.925] - result already collected: FutureResult
[18:01:09.925] result() for ClusterFuture ... done
[18:01:09.925] result() for ClusterFuture ...
[18:01:09.925] - result already collected: FutureResult
[18:01:09.925] result() for ClusterFuture ... done
[18:01:09.926] result() for ClusterFuture ...
[18:01:09.926] - result already collected: FutureResult
[18:01:09.926] result() for ClusterFuture ... done
[18:01:09.926] result() for ClusterFuture ...
[18:01:09.926] - result already collected: FutureResult
[18:01:09.926] result() for ClusterFuture ... done
[18:01:09.927] - relayed: [n=2] TRUE, TRUE
[18:01:09.927] - queued futures: [n=2] TRUE, TRUE
[18:01:09.927] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:01:09.927]  length: 0 (resolved future 2)
[18:01:09.927] Relaying remaining futures
[18:01:09.928] signalConditionsASAP(NULL, pos=0) ...
[18:01:09.928] - nx: 2
[18:01:09.928] - relay: TRUE
[18:01:09.928] - stdout: TRUE
[18:01:09.928] - signal: TRUE
[18:01:09.928] - resignal: FALSE
[18:01:09.929] - force: TRUE
[18:01:09.929] - relayed: [n=2] TRUE, TRUE
[18:01:09.929] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:09.929] - relayed: [n=2] TRUE, TRUE
[18:01:09.929] - queued futures: [n=2] TRUE, TRUE
[18:01:09.930] signalConditionsASAP(NULL, pos=0) ... done
[18:01:09.930] resolve() on list ... DONE
[18:01:09.930] result() for ClusterFuture ...
[18:01:09.930] - result already collected: FutureResult
[18:01:09.930] result() for ClusterFuture ... done
[18:01:09.931] result() for ClusterFuture ...
[18:01:09.931] - result already collected: FutureResult
[18:01:09.931] result() for ClusterFuture ... done
[18:01:09.931] result() for ClusterFuture ...
[18:01:09.931] - result already collected: FutureResult
[18:01:09.931] result() for ClusterFuture ... done
[18:01:09.932] result() for ClusterFuture ...
[18:01:09.932] - result already collected: FutureResult
[18:01:09.932] result() for ClusterFuture ... done
[18:01:09.933]  - Number of value chunks collected: 2
[18:01:09.933] Resolving 2 futures (chunks) ... DONE
[18:01:09.933] Reducing values from 2 chunks ...
[18:01:09.933]  - Number of values collected after concatenation: 2
[18:01:09.933]  - Number of values expected: 2
[18:01:09.933] Reducing values from 2 chunks ... DONE
[18:01:09.934] future_mapply() ... DONE
[18:01:09.934] plan(): Setting new future strategy stack:
[18:01:09.934] List of future strategies:
[18:01:09.934] 1. sequential:
[18:01:09.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:09.934]    - tweaked: FALSE
[18:01:09.934]    - call: plan(sequential)
[18:01:09.936] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[18:01:09.938] plan(): Setting new future strategy stack:
[18:01:09.938] List of future strategies:
[18:01:09.938] 1. FutureStrategy:
[18:01:09.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:09.938]    - tweaked: FALSE
[18:01:09.938]    - call: future::plan(oplan)
[18:01:09.939] plan(): nbrOfWorkers() = 1
> 
