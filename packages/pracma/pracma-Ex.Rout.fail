
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "pracma"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('pracma')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("abm3")
> ### * abm3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: abm3pc
> ### Title: Adams-Bashford-Moulton
> ### Aliases: abm3pc
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Attempt on a non-stiff equation
> #   y' = y^2 - y^3, y(0) = d, 0 <= t <= 2/d, d = 0.01
> f <- function(t, y) y^2 - y^3
> d <- 1/250
> abm1 <- abm3pc(f, 0, 2/d, d, n = 1/d)
> abm2 <- abm3pc(f, 0, 2/d, d, n = 2/d)
> ## Not run: 
> ##D plot(abm1$x, abm1$y, type = "l", col = "blue")
> ##D lines(abm2$x, abm2$y, type = "l", col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("accumarray")
> ### * accumarray
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: accumarray
> ### Title: Accumulate Vector Elements
> ### Aliases: accumarray uniq
> ### Keywords: array
> 
> ### ** Examples
> 
> ##  Examples for accumarray
> val = 101:105
> subs = as.matrix(c(1, 2, 4, 2, 4))
> accumarray(subs, val)
     [,1]
[1,]  101
[2,]  206
[3,]    0
[4,]  208
> # [101; 206; 0; 208]
> 
> val = 101:105
> subs <- matrix(c(1,2,2,2,2, 1,1,3,1,3, 1,2,2,2,2), ncol = 3)
> accumarray(subs, val)
, , 1

     [,1] [,2] [,3]
[1,]  101    0    0
[2,]    0    0    0

, , 2

     [,1] [,2] [,3]
[1,]    0    0    0
[2,]  206    0  208

> # , , 1
> # [,1] [,2] [,3]
> # [1,]  101    0    0
> # [2,]    0    0    0
> # , , 2
> # [,1] [,2] [,3]
> # [1,]    0    0    0
> # [2,]  206    0  208
> 
> val = 101:106
> subs <- matrix(c(1, 2, 1, 2, 3, 1, 4, 1, 4, 4, 4, 1), ncol = 2, byrow = TRUE)
> accumarray(subs, val, func = function(x) sum(diff(x)))
     [,1] [,2] [,3] [,4]
[1,]    0    1    0    0
[2,]    0    0    0    0
[3,]    0    0    0    0
[4,]    2    0    0    0
> # [,1] [,2] [,3] [,4]
> # [1,]    0    1    0    0
> # [2,]    0    0    0    0
> # [3,]    0    0    0    0
> # [4,]    2    0    0    0
> 
> val = 101:105
> subs = matrix(c(1, 1, 2, 1, 2, 3, 2, 1, 2, 3), ncol = 2, byrow = TRUE)
> accumarray(subs, val, sz = c(3, 3), func = max, fillval = NA)
     [,1] [,2] [,3]
[1,]  101   NA   NA
[2,]  104   NA  105
[3,]   NA   NA   NA
> # [,1] [,2] [,3]
> # [1,]  101   NA   NA
> # [2,]  104   NA  105
> # [3,]   NA   NA   NA
> 
> ##  Examples for uniq
> a <- c(1, 1, 5, 6, 2, 3, 3, 9, 8, 6, 2, 4)
> A <- uniq(a); A
$b
[1] 1 5 6 2 3 9 8 4

$m
[1]  2  3 10 11  7  8  9 12

$n
 [1] 1 1 2 3 4 5 5 6 7 3 4 8

> # A$b  1  5  6  2  3  9  8  4
> # A$m  2  3 10 11  7  8  9 12
> # A$n  1  1  2  3  4  5  5  6  7  3  4  8
> A <- uniq(a, first = TRUE); A
$b
[1] 1 5 6 2 3 9 8 4

$m
[1]  1  3  4  5  6  8  9 12

$n
 [1] 1 1 2 3 4 5 5 6 7 3 4 8

> # A$m  1  3  4  5  6  8  9 12
> 
> ##  Example: Subset sum problem
> # Distribution of unique sums among all combinations of a vectors.
> allsums <- function(a) {
+     S <- c(); C <- c()
+     for (k in 1:length(a)) {
+         U <- uniq(c(S, a[k], S + a[k]))
+         S <- U$b
+         C <- accumarray(U$n, c(C, 1, C))
+     }
+     o <- order(S); S <- S[o]; C <- C[o]
+     return(list(S = S, C = C))
+ }
> A <- allsums(seq(1, 9, by=2)); A
$S
 [1]  1  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25

$C
 [1] 1 1 1 1 1 1 2 2 2 1 2 2 1 2 2 2 1 1 1 1 1 1 1

> # A$S  1  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25
> # A$C  1  1  1  1  1  1  2  2  2  1  2  2  1  2  2  2  1  1  1  1  1  1  1
> 
> 
> 
> cleanEx()
> nameEx("agmean")
> ### * agmean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: agmean
> ### Title: Arithmetic-geometric Mean
> ### Aliases: agmean
> ### Keywords: arith
> 
> ### ** Examples
> 
> ##  Accuracy test: Gauss constant
> 1/agmean(1, sqrt(2))$agm - 0.834626841674073186  # 1.11e-16 < eps = 2.22e-16
[1] -1.110223e-16
> 
> ## Gauss' AGM-based computation of \pi
> a <- 1.0
> b <- 1.0/sqrt(2)
> s <- 0.5
> d <- 1L
> while (abs(a-b) > eps()) {
+     t <- a
+     a <- (a + b)*0.5
+     b <- sqrt(t*b)
+     c <- (a-t)*(a-t)
+     d <- 2L * d
+     s <- s - d*c
+ }
> approx_pi <- (a+b)^2 / s / 2.0
> abs(approx_pi - pi)             # 8.881784e-16 in 4 iterations
[1] 8.881784e-16
> 
> ##  Example: Approximate elliptic integral
> N <- 20
> m <- seq(0, 1, len = N+1)[1:N]
> E <- numeric(N)
> for (i in 1:N) {
+     f <- function(t) 1/sqrt(1 - m[i]^2 * sin(t)^2)
+     E[i] <- quad(f, 0, pi/2)
+ }
> A <- numeric(2*N-1)
> a <- 1
> b <- a * (1-m) / (m+1)
> 
> ## Not run: 
> ##D plot(m, E, main = "Elliptic Integrals vs. arith.-geom. Mean")
> ##D lines(m, (a+b)*pi / 4 / agmean(a, b)$agm, col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("aitken")
> ### * aitken
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aitken
> ### Title: Aitken' Method
> ### Aliases: aitken
> ### Keywords: math
> 
> ### ** Examples
> 
> # Find a zero of    f(x) = cos(x) - x*exp(x)
> # as fixpoint of  phi(x) = x + (cos(x) - x*exp(x))/2
> phi <- function(x) x + (cos(x) - x*exp(x))/2
> aitken(phi, 0)  #=> 0.5177574
[1] 0.5177574
> 
> 
> 
> cleanEx()
> nameEx("akima")
> ### * akima
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: akimaInterp
> ### Title: Univariate Akima Interpolation
> ### Aliases: akimaInterp
> ### Keywords: fitting
> 
> ### ** Examples
> 
> x <- c( 0,  2,  3,  5,  6,  8,  9,   11, 12, 14, 15)
> y <- c(10, 10, 10, 10, 10, 10, 10.5, 15, 50, 60, 85)
> xs <- seq(12, 14, 0.5)          # 12.0 12.5     13.0     13.5     14.0
> ys <- akimaInterp(x, y, xs)     # 50.0 54.57405 54.84360 55.19135 60.0
> xs; ys
[1] 12.0 12.5 13.0 13.5 14.0
[1] 50.00000 54.57405 54.84360 55.19135 60.00000
> 
> ## Not run: 
> ##D plot(x, y, col="blue", main = "Akima Interpolation")
> ##D xi <- linspace(0,15,51)
> ##D yi <- akimaInterp(x, y, xi)
> ##D lines(xi, yi, col = "darkred")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("andor")
> ### * andor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: and, or
> ### Title: Logical AND, OR (Matlab Style)
> ### Aliases: and or
> ### Keywords: logic
> 
> ### ** Examples
> 
> A <- matrix(c(0.5,  0.5,  0,    0.75, 0,
+               0.5,  0,    0.75, 0.05, 0.85,
+               0.35, 0,    0,    0,    0.01,
+               0.5,  0.65, 0.65, 0.05, 0), 4, 5, byrow=TRUE)
> B <- matrix(c( 0, 1, 0, 1, 0,
+                1, 1, 1, 0, 1,
+                0, 1, 1, 1, 0,
+                0, 1, 0, 0, 1), 4, 5, byrow=TRUE)
> 
> and(A, B)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1    0    1    0
[2,]    1    0    1    0    1
[3,]    0    0    0    0    0
[4,]    0    1    0    0    0
> or(A, B)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    0    1    0
[2,]    1    1    1    1    1
[3,]    1    1    1    1    1
[4,]    1    1    1    1    1
> 
> 
> 
> cleanEx()
> nameEx("andrews")
> ### * andrews
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: andrewsplot
> ### Title: Andrews' Curves
> ### Aliases: andrewsplot
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(iris)
> ##D s <- sample(1:4, 4)
> ##D A <- as.matrix(iris[, s])
> ##D f <- as.integer(iris[, 5])
> ##D andrewsplot(A, f, style = "pol")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("angle")
> ### * angle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: angle
> ### Title: Basic Complex Functions
> ### Aliases: Real Imag angle
> ### Keywords: arith
> 
> ### ** Examples
> 
> z <- c(0, 1, 1+1i, 1i)
> Real(z)   # Re(z)
[1] 0 1 1 0
> Imag(z)   # Im(z)
[1] 0 0 1 1
> Conj(z)   # Conj(z)
[1] 0+0i 1+0i 1-1i 0-1i
> abs(z)    # Mod(z)
[1] 0.000000 1.000000 1.414214 1.000000
> angle(z)
[1] 0.0000000 0.0000000 0.7853982 1.5707963
> 
> 
> 
> cleanEx()
> nameEx("anms")
> ### * anms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anms
> ### Title: Adaptive Nelder-Mead Minimization
> ### Aliases: anms
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Rosenbrock function
> rosenbrock <- function(x) {
+     n <- length(x)
+     x1 <- x[2:n]
+     x2 <- x[1:(n-1)]
+     sum(100*(x1-x2^2)^2 + (1-x2)^2)
+ }
> 
> anms(rosenbrock, c(0,0,0,0,0))
$xmin
[1] 1 1 1 1 1

$fmin
[1] 8.268732e-21

$nfeval
[1] 1153

> # $xmin
> # [1] 1 1 1 1 1
> # $fmin
> # [1] 8.268732e-21
> # $nfeval
> # [1] 1153
> 
> # To add constraints to the optimization problem, use a slightly 
> # modified objective function. Equality constraints not possible.
> # Warning: Avoid a starting value too near to the boundary !
> 
> ## Not run: 
> ##D # Example: 0.0 <= x <= 0.5
> ##D fun <- function(x) {
> ##D     if (any(x < 0) || any(x > 0.5)) 100
> ##D     else rosenbrock(x)
> ##D }
> ##D x0 <- rep(0.1, 5)
> ##D 
> ##D anms(fun, x0)
> ##D ## $xmin
> ##D ## [1] 0.500000000 0.263051265 0.079972922 0.016228138 0.000267922
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("arclength")
> ### * arclength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arclength
> ### Title: Arc Length of a Curve
> ### Aliases: arclength
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example: parametrized 3D-curve with t in 0..3*pi
> f <- function(t) c(sin(2*t), cos(t), t)
> arclength(f, 0, 3*pi)
$length
[1] 17.22203

$niter
[1] 8

$rel.err
[1] 1.292881e-06

> # $length:  17.22203            # true length 17.222032...
> 
> ##  Example: length of the sine curve
> f <- function(t) c(t, sin(t))
> arclength(f, 0, pi)             # true length  3.82019...
$length
[1] 3.820198

$niter
[1] 6

$rel.err
[1] 2.780094e-06

> 
> ## Example: Length of an ellipse with axes a = 1 and b = 0.5
> # parametrization x = a*cos(t), y = b*sin(t)
> a <- 1.0; b <- 0.5
> f <- function(t) c(a*cos(t), b*sin(t))
> L <- arclength(f, 0, 2*pi, tol = 1e-10)     #=> 4.84422411027
> # compare with elliptic integral of the second kind
> e <- sqrt(1 - b^2/a^2)                      # ellipticity
> L <- 4 * a * ellipke(e^2)$e                 #=> 4.84422411027
> 
> ## Not run: 
> ##D ##  Example: oscillating 1-dimensional function (from 0 to 5)
> ##D f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> ##D F <- function(t) c(t, f(t))
> ##D L <- arclength(F, 0, 5, tol = 1e-12, nmax = 25)
> ##D print(L$length, digits = 16)
> ##D # [1] 82.81020372882217         # true length 82.810203728822172...
> ##D 
> ##D # Split this computation in 10 steps (run time drops from 2 to 0.2 secs)
> ##D L <- 0
> ##D for (i in 1:10)
> ##D 	L <- L + arclength(F, (i-1)*0.5, i*0.5, tol = 1e-10)$length
> ##D print(L, digits = 16)
> ##D # [1] 82.81020372882216
> ##D 
> ##D # Alternative calculation of arc length
> ##D f1 <- function(x) sqrt(1 + complexstep(f, x)^2)
> ##D L1 <- quadgk(f1, 0, 5, tol = 1e-14)
> ##D print(L1, digits = 16)
> ##D # [1] 82.81020372882216
> ##D   
> ## End(Not run)
> 
> ## Not run: 
> ##D #-- --------------------------------------------------------------------
> ##D #   Arc-length parametrization of Fermat's spiral
> ##D #-- --------------------------------------------------------------------
> ##D # Fermat's spiral: r = a * sqrt(t) 
> ##D f <- function(t) 0.25 * sqrt(t) * c(cos(t), sin(t))
> ##D 
> ##D t1 <- 0; t2 <- 6*pi
> ##D a  <- 0; b  <- arclength(f, t1, t2)$length
> ##D fParam <- function(w) {
> ##D     fct <- function(u) arclength(f, a, u)$length - w
> ##D     urt <- uniroot(fct, c(a, 6*pi))
> ##D     urt$root
> ##D }
> ##D 
> ##D ts <- linspace(0, 6*pi, 250)
> ##D plot(matrix(f(ts), ncol=2), type='l', col="blue", 
> ##D      asp=1, xlab="", ylab = "",
> ##D      main = "Fermat's Spiral", sub="20 subparts of equal length")
> ##D 
> ##D for (i in seq(0.05, 0.95, by=0.05)) {
> ##D     v <- fParam(i*b); fv <- f(v)
> ##D     points(fv[1], f(v)[2], col="darkred", pch=20)
> ##D } 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("arnoldi")
> ### * arnoldi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arnoldi
> ### Title: Arnoldi Iteration
> ### Aliases: arnoldi
> ### Keywords: math
> 
> ### ** Examples
> 
> A <- matrix(c(-149,   -50,  -154,
+                537,   180,   546,
+                -27,    -9,   -25), nrow = 3, byrow = TRUE)
> a <- arnoldi(A, c(1,0,0))
> a
$Q
     [,1]       [,2]       [,3]
[1,]    1  0.0000000  0.0000000
[2,]    0  0.9987384 -0.0502159
[3,]    0 -0.0502159 -0.9987384

$H
          [,1]         [,2]        [,3]
[1,] -149.0000 -42.20367124  156.316506
[2,]  537.6783 152.55114875 -554.927153
[3,]    0.0000   0.07284727    2.448851

> ## $Q
> ##      [,1]       [,2]       [,3]
> ## [1,]    1  0.0000000  0.0000000
> ## [2,]    0  0.9987384 -0.0502159
> ## [3,]    0 -0.0502159 -0.9987384
> ## 
> ## $H
> ##           [,1]         [,2]        [,3]
> ## [1,] -149.0000 -42.20367124  156.316506
> ## [2,]  537.6783 152.55114875 -554.927153
> ## [3,]    0.0000   0.07284727    2.448851
> 
> a$Q %*% a$H %*% t(a$Q)
     [,1] [,2] [,3]
[1,] -149  -50 -154
[2,]  537  180  546
[3,]  -27   -9  -25
> ##      [,1] [,2] [,3]
> ## [1,] -149  -50 -154
> ## [2,]  537  180  546
> ## [3,]  -27   -9  -25
> 
> 
> 
> cleanEx()
> nameEx("barylag")
> ### * barylag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: barylag
> ### Title: Barycentric Lagrange Interpolation
> ### Aliases: barylag
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Generates an example with plot.
> # Input:
> #   fun  ---  function that shall be 'approximated'
> #   a, b ---  interval [a, b] to be used for the example
> #   n    ---  number of supporting nodes
> #   m    ---  number of interpolation points
> # Output
> #   plot of function, interpolation, and nodes
> #   return value is NULL (invisible)
> ## Not run: 
> ##D barycentricExample <- function(fun, a, b, n, m)
> ##D {
> ##D 	xi <- seq(a, b, len=n)
> ##D 	yi <- fun(xi)
> ##D 	x  <- seq(a, b, len=m)
> ##D 
> ##D 	y <- barylag(xi, yi, x)
> ##D 	plot(xi, yi, col="red", xlab="x", ylab="y",
> ##D 		main="Example of barycentric interpolation")
> ##D 
> ##D 	lines(x, fun(x), col="yellow", lwd=2)
> ##D 	lines(x, y, col="darkred")
> ##D 
> ##D 	grid()
> ##D }
> ##D 
> ##D barycentricExample(sin, -pi, pi, 11, 101)  # good interpolation
> ##D barycentricExample(runge, -1, 1, 21, 101)  # bad interpolation
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("barylag2d")
> ### * barylag2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: barylag2d
> ### Title: 2-D Barycentric Lagrange Interpolation
> ### Aliases: barylag2d
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from R-help
> xn <- c(4.05, 4.10, 4.15, 4.20, 4.25, 4.30, 4.35)
> yn <- c(60.0, 67.5, 75.0, 82.5, 90.0)
> foo <- matrix(c(
+         -137.8379, -158.8240, -165.4389, -166.4026, -166.2593,
+         -152.1720, -167.3145, -171.1368, -170.9200, -170.4605,
+         -162.2264, -172.5862, -174.1460, -172.9923, -172.2861,
+         -168.7746, -175.2218, -174.9667, -173.0803, -172.1853,
+         -172.4453, -175.7163, -174.0223, -171.5739, -170.5384,
+         -173.7736, -174.4891, -171.6713, -168.8025, -167.6662,
+         -173.2124, -171.8940, -168.2149, -165.0431, -163.8390),
+             nrow = 7, ncol = 5, byrow = TRUE)
> xf <- c(4.075, 4.1)
> yf <- c(63.75, 67.25)
> barylag2d(foo, xn, yn, xf, yf)
          [,1]      [,2]
[1,] -156.7964 -163.1753
[2,] -161.7495 -167.0424
> #  -156.7964 -163.1753
> #  -161.7495 -167.0424
> 
> # Find the minimum of the underlying function
> bar <- function(xy) barylag2d(foo, xn, yn, xy[1], xy[2])
> optim(c(4.25, 67.5), bar)  # "Nelder-Mead"
$par
[1]  4.230547 68.522747

$value
[1] -175.7959

$counts
function gradient 
      57       NA 

$convergence
[1] 0

$message
NULL

> # $par
> # 4.230547 68.522747
> # $value
> # -175.7959
> 
> ## Not run: 
> ##D # Image and contour plots
> ##D image(xn, yn, foo)
> ##D contour(xn, yn, foo, col="white", add = TRUE)
> ##D xs <- seq(4.05, 4.35, length.out = 51)
> ##D ys <- seq(60.0, 90.0, length.out = 51)
> ##D zz <- barylag2d(foo, xn, yn, xs, ys)
> ##D contour(xs, ys, zz, nlevels = 20, add = TRUE)
> ##D contour(xs, ys, zz, levels=c(-175, -175.5), add = TRUE)
> ##D points(4.23, 68.52)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("beep")
> ### * beep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: disp,beep
> ### Title: Utility functions (Matlab style)
> ### Aliases: disp beep
> ### Keywords: utilities
> 
> ### ** Examples
> 
> disp("Some text, and numbers:", pi, exp(1))
Some text, and numbers: 3.141593 2.718282 
> # beep()
> 
> 
> 
> cleanEx()
> nameEx("bernoulli")
> ### * bernoulli
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bernoulli
> ### Title: Bernoulli Numbers and Polynomials
> ### Aliases: bernoulli
> ### Keywords: specfun
> 
> ### ** Examples
> 
> bernoulli(10)
 [1]  1.00000000 -0.50000000  0.16666667  0.00000000 -0.03333333  0.00000000
 [7]  0.02380952  0.00000000 -0.03333333  0.00000000  0.07575758
> # 1.00000000 -0.50000000  0.16666667  0.00000000 -0.03333333
> # 0.00000000  0.02380952  0.00000000 -0.03333333  0.00000000  0.07575758
>                 #
> ## Not run: 
> ##D x1 <- linspace(0.3, 0.7, 2)
> ##D y1 <- bernoulli(1, x1)
> ##D plot(x1, y1, type='l', col='red', lwd=2,
> ##D      xlim=c(0.0, 1.0), ylim=c(-0.2, 0.2),
> ##D      xlab="", ylab="", main="Bernoulli Polynomials")
> ##D grid()
> ##D xs <- linspace(0, 1, 51)
> ##D lines(xs, bernoulli(2, xs), col="green", lwd=2)
> ##D lines(xs, bernoulli(3, xs), col="blue", lwd=2)
> ##D lines(xs, bernoulli(4, xs), col="cyan", lwd=2)
> ##D lines(xs, bernoulli(5, xs), col="brown", lwd=2)
> ##D lines(xs, bernoulli(6, xs), col="magenta", lwd=2)
> ##D legend(0.75, 0.2, c("B_1", "B_2", "B_3", "B_4", "B_5", "B_6"),
> ##D        col=c("red", "green", "blue", "cyan", "brown", "magenta"),
> ##D        lty=1, lwd=2)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("bernstein")
> ### * bernstein
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bernstein
> ### Title: Bernstein Polynomials
> ### Aliases: bernstein bernsteinb
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Example
> f <- function(x) sin(2*pi*x)
> xs <- linspace(0, 1)
> ys <- f(xs)
> ## Not run: 
> ##D plot(xs, ys, type='l', col="blue",
> ##D      main="Bernstein Polynomials")
> ##D grid()
> ##D b10  <- bernstein(f,  10, xs)
> ##D b100 <- bernstein(f, 100, xs)
> ##D lines(xs, b10,  col="magenta")
> ##D lines(xs, b100, col="red") 
> ## End(Not run)
> 
> # Bernstein basis polynomials
> ## Not run: 
> ##D xs <- linspace(0, 1)
> ##D plot(c(0,1), c(0,1), type='n',
> ##D      main="Bernstein Basis Polynomials")
> ##D grid()
> ##D n = 10
> ##D for (i in 0:n) {
> ##D     bs <- bernsteinb(i, n, xs)
> ##D     lines(xs, bs, col=i+1)
> ##D } 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("bisect")
> ### * bisect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bisect
> ### Title: Rootfinding Through Bisection or Secant Rule
> ### Aliases: bisect secant regulaFalsi
> ### Keywords: math
> 
> ### ** Examples
> 
> bisect(sin, 3.0, 4.0)
$root
[1] 3.141593

$f.root
[1] 1.224647e-16

$iter
[1] 52

$estim.prec
[1] 4.440892e-16

> # $root             $f.root             $iter   $estim.prec
> # 3.1415926536      1.2246467991e-16    52      4.4408920985e-16
> 
> bisect(sin, -1.0, 1.0)
$root
[1] 0

$f.root
[1] 0

$iter
[1] 2

$estim.prec
[1] 0

> # $root             $f.root             $iter   $estim.prec
> # 0                 0                   2       0
> 
> # Legendre polynomial of degree 5
> lp5 <- c(63, 0, -70, 0, 15, 0)/8
> f <- function(x) polyval(lp5, x)
> bisect(f, 0.6, 1)       # 0.9061798453      correct to 15 decimals
$root
[1] 0.9061798

$f.root
[1] 6.661338e-16

$iter
[1] 53

$estim.prec
[1] 1.110223e-16

> secant(f, 0.6, 1)       # 0.5384693         different root
$root
[1] 0.5384693

$f.root
[1] -1.872942e-10

$iter
[1] 7

$estim.prec
[1] 1.016315e-06

> regulaFalsi(f, 0.6, 1)  # 0.9061798459      correct to 10 decimals
$root
[1] 0.9061798

$f.root
[1] -3.996803e-15

$niter
[1] 11

$estim.prec
[1] 8.886614e-09

> 
> 
> 
> cleanEx()
> nameEx("bits")
> ### * bits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bits
> ### Title: Binary Representation
> ### Aliases: bits
> ### Keywords: arith
> 
> ### ** Examples
> 
> bits(2^10)        # "10000000000"
[1] "10000000000"
> bits(1 + 2^-10)   #  "1.000000000100000000000000000000000000000000000000000000"
[1] "1.000000000100000000000000000000000000000000000000000000"
> bits(pi)          # "11.001001000011111101101010100010001000010110100011000000"
[1] "11.001001000011111101101010100010001000010110100011000000"
> bits(1/3.0)       #  "0.010101010101010101010101010101010101010101010101010101"
[1] "0.010101010101010101010101010101010101010101010101010101"
> bits(1 + eps())   #  "1.000000000000000000000000000000000000000000000000000100"
[1] "1.000000000000000000000000000000000000000000000000000100"
> 
> 
> 
> cleanEx()
> nameEx("blanks")
> ### * blanks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blanks
> ### Title: String of Blank Carakters
> ### Aliases: blanks
> ### Keywords: string
> 
> ### ** Examples
> 
> blanks(6)
[1] "      "
> 
> 
> 
> cleanEx()
> nameEx("blkdiag")
> ### * blkdiag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blkdiag
> ### Title: Block Diagonal Matrix
> ### Aliases: blkdiag
> ### Keywords: array
> 
> ### ** Examples
> 
> a1 <- matrix(c(1,2), 1)
> a2 <- as.matrix(c(1,2))
> blkdiag(a1, diag(1, 2, 2), a2)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    0    0    0
[2,]    0    0    1    0    0
[3,]    0    0    0    1    0
[4,]    0    0    0    0    1
[5,]    0    0    0    0    2
> 
> 
> 
> cleanEx()
> nameEx("brentdekker")
> ### * brentdekker
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brentDekker
> ### Title: Brent-Dekker Root Finding Algorithm
> ### Aliases: brentDekker brent
> ### Keywords: math
> 
> ### ** Examples
> 
> # Legendre polynomial of degree 5
> lp5 <- c(63, 0, -70, 0, 15, 0)/8
> f <- function(x) polyval(lp5, x)
> brent(f, 0.6, 1)                # 0.9061798459 correct to 12 places
$root
[1] 0.9061798

$f.root
[1] -4.440892e-16

$f.calls
[1] 14

$estim.prec
[1] 2.306155e-12

> 
> 
> 
> cleanEx()
> nameEx("brown72")
> ### * brown72
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brown72
> ### Title: Brownian Motion
> ### Aliases: brown72
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(brown72)
> ##D plot(brown72, type = "l", col = "blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("broyden")
> ### * broyden
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: broyden
> ### Title: Broyden's Method
> ### Aliases: broyden
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from Quarteroni & Saleri
> F1 <- function(x) c(x[1]^2 + x[2]^2 - 1, sin(pi*x[1]/2) + x[2]^3)
> broyden(F1, x0 = c(1, 1))
$zero
[1]  0.4760958 -0.8793934

$fnorm
[1] 9.092626e-09

$niter
[1] 13

> # zero: 0.4760958 -0.8793934; fnorm: 9.092626e-09; niter: 13
> 
> F <- function(x) {
+     x1 <- x[1]; x2 <- x[2]; x3 <- x[3]
+     as.matrix(c(x1^2 + x2^2 + x3^2 - 1,
+                 x1^2 + x3^2 - 0.25,
+                 x1^2 + x2^2 - 4*x3), ncol = 1)
+ }
> x0 <- as.matrix(c(1, 1, 1))
> broyden(F, x0)
$zero
[1] 0.4407629 0.8660254 0.2360680

$fnorm
[1] 1.34325e-08

$niter
[1] 8

> # zero: 0.4407629 0.8660254 0.2360680; fnorm: 1.34325e-08; niter: 8
> 
> ##  Find the roots of the complex function sin(z)^2 + sqrt(z) - log(z)
> F2 <- function(x) {
+     z  <- x[1] + x[2]*1i
+     fz <- sin(z)^2 + sqrt(z) - log(z)
+     c(Re(fz), Im(fz))
+ }
> broyden(F2, c(1, 1))
$zero
[1] 0.2555197 0.8948303

$fnorm
[1] 7.284373e-10

$niter
[1] 13

> # zero   0.2555197 0.8948303 , i.e.  z0 = 0.2555 + 0.8948i
> # fnorm  7.284374e-10
> # niter  13
> 
> ##  Two more problematic examples
> F3 <- function(x)
+         c(2*x[1] - x[2] - exp(-x[1]), -x[1] + 2*x[2] - exp(-x[2]))
> broyden(F3, c(0, 0))
$zero
[1] 0.5671433 0.5671433

$fnorm
[1] 4.677305e-12

$niter
[1] 5

> # $zero   0.5671433 0.5671433   # x = exp(-x)
> 
> F4 <- function(x)   # Dennis Schnabel
+         c(x[1]^2 + x[2]^2 - 2, exp(x[1] - 1) + x[2]^3 - 2)
> broyden(F4, c(2.0, 0.5), maxiter = 100)
$zero
[1] 1 1

$fnorm
[1] 1.188186e-10

$niter
[1] 43

> 
> 
> 
> cleanEx()
> nameEx("bsxfun")
> ### * bsxfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bsxfun
> ### Title: Elementwise Function Application (Matlab Style)
> ### Aliases: bsxfun arrayfun
> ### Keywords: math
> 
> ### ** Examples
> 
> X <- matrix(rep(1:10, each = 10), 10, 10)
> Y <- t(X)
> bsxfun("*", X, Y)  # multiplication table
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    1    2    3    4    5    6    7    8    9    10
 [2,]    2    4    6    8   10   12   14   16   18    20
 [3,]    3    6    9   12   15   18   21   24   27    30
 [4,]    4    8   12   16   20   24   28   32   36    40
 [5,]    5   10   15   20   25   30   35   40   45    50
 [6,]    6   12   18   24   30   36   42   48   54    60
 [7,]    7   14   21   28   35   42   49   56   63    70
 [8,]    8   16   24   32   40   48   56   64   72    80
 [9,]    9   18   27   36   45   54   63   72   81    90
[10,]   10   20   30   40   50   60   70   80   90   100
> 
> f <- function(x, y) x[1] * y[1]     # function not vectorized
> A <- matrix(c(2, 3, 5, 7), 2, 2)
> B <- matrix(c(11, 13, 17, 19), 2, 2)
> arrayfun(f, A, B)
     [,1] [,2]
[1,]   22   85
[2,]   39  133
> 
> 
> 
> cleanEx()
> nameEx("bvp")
> ### * bvp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bvp
> ### Title: Boundary Value Problems
> ### Aliases: bvp
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Solve y'' = 2*x/(1+x^2)*y' - 2/(1+x^2) * y + 1
> ##  with y(0) = 1.25 and y(4) = -0.95 on the interval [0, 4]:
> f1 <- function(x) 2*x / (1 + x^2)
> f2 <- function(x)  -2 / (1 + x^2)
> f3 <- function(x) rep(1, length(x))     # vectorized constant function 1
> x <- c(0.0,   4.0)
> y <- c(1.25, -0.95)
> sol <- bvp(f1, f2, f3, x, y)
> ## Not run: 
> ##D plot(sol$xs, sol$ys, ylim = c(-2, 2),
> ##D      xlab = "", ylab = "", main = "Boundary Value Problem")
> ##D # The analytic solution is
> ##D sfun <- function(x) 1.25 + 0.4860896526*x - 2.25*x^2 + 
> ##D                     2*x*atan(x) - 1/2 * log(1+x^2) + 1/2 * x^2 * log(1+x^2)
> ##D xx <- linspace(0, 4)
> ##D yy <- sfun(xx)
> ##D lines(xx, yy, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cart2sph")
> ### * cart2sph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cart2sph
> ### Title: Coordinate Transformations
> ### Aliases: cart2sph sph2cart cart2pol pol2cart
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- 0.5*cos(pi/6); y <- 0.5*sin(pi/6); z <- sqrt(1 - x^2 - y^2)
> (s <-cart2sph(c(x, y, z)))      # 0.5235988 1.0471976 1.0000000
[1] 0.5235988 1.0471976 1.0000000
> sph2cart(s)                     # 0.4330127 0.2500000 0.8660254
[1] 0.4330127 0.2500000 0.8660254
> 
> cart2pol(c(1,1))                # 0.7853982 1.4142136
[1] 0.7853982 1.4142136
> cart2pol(c(1,1,0))              # 0.7853982 1.4142136 0.0000000
[1] 0.7853982 1.4142136 0.0000000
> pol2cart(c(pi/2, 1))            # 6.123234e-17 1.000000e+00
[1] 6.123234e-17 1.000000e+00
> pol2cart(c(pi/4, 1, 1))         # 0.7071068 0.7071068 1.0000000
[1] 0.7071068 0.7071068 1.0000000
> 
> ##  Transform spherical to cylindrical coordinates and vice versa
> #   sph2cyl <- function(th.ph.r) cart2pol(sph2cart(th.ph.r))
> #   cyl2sph <- function(phi.r.z) cart2sph(pol2cart(phi.r.z))
> 
> 
> 
> cleanEx()
> nameEx("cd")
> ### * cd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cd, pwd, what
> ### Title: Directory Functions (Matlab style)
> ### Aliases: cd pwd what
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # cd()
> # pwd()
> # what()
> 
> 
> 
> cleanEx()
> nameEx("ceil")
> ### * ceil
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ceil
> ### Title: Integer Functions (Matlab Style)
> ### Aliases: ceil Fix
> ### Keywords: arith
> 
> ### ** Examples
> 
> x <- c(-1.2, -0.8, 0, 0.5, 1.1, 2.9)
> ceil(x)
[1] -1  0  0  1  2  3
> Fix(x)
[1] -1  0  0  0  1  2
> 
> 
> 
> cleanEx()
> nameEx("charpoly")
> ### * charpoly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: charpoly
> ### Title: Characteristic Polynomial
> ### Aliases: charpoly
> ### Keywords: array
> 
> ### ** Examples
> 
> a <- magic(5)
> A <- charpoly(a, info = TRUE)
Error term: 0 
> A$cp
[1]        1      -65     -625    40625    78000 -5070000
> roots(A$cp)
[1]  65.00000 -21.27677  21.27677 -13.12628  13.12628
> A$det
[1] 5070000
> zapsmall(A$inv %*% a)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
> 
> 
> 
> cleanEx()
> nameEx("chebApprox")
> ### * chebApprox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chebApprox
> ### Title: Chebyshev Approximation
> ### Aliases: chebApprox
> ### Keywords: math
> 
> ### ** Examples
> 
> # Approximate sin(x) on [-pi, pi] with a polynomial of degree 9 !
> # This polynomial has to be beaten:
> # P(x) = x - 1/6*x^3 + 1/120*x^5 - 1/5040*x^7 + 1/362880*x^9
> 
> # Compare these polynomials
> p1 <- rev(c(0, 1, 0, -1/6, 0, 1/120, 0, -1/5040, 0, 1/362880))
> p2 <- chebCoeff(sin, -pi, pi, 9)
> 
> # Estimate the maximal distance
> x  <- seq(-pi, pi, length.out = 101)
> ys <- sin(x)
> yp <- polyval(p1, x)
> yc <- chebApprox(x, sin, -pi, pi, 9)
> max(abs(ys-yp))                       # 0.006925271
[1] 0.006925271
> max(abs(ys-yc))                       # 1.151207e-05
[1] 1.151207e-05
> 
> ## Not run: 
> ##D # Plot the corresponding curves
> ##D plot(x, ys, type = "l", col = "gray", lwd = 5)
> ##D lines(x, yp, col = "navy")
> ##D lines(x, yc, col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("chebCoeff")
> ### * chebCoeff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chebCoeff
> ### Title: Chebyshev Polynomials
> ### Aliases: chebCoeff
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Chebyshev coefficients for x^2 + 1
> n <- 4
> f2 <- function(x) x^2 + 1
> cC <- chebCoeff(f2, -1, 1, n)  #  3.0   0  0.5   0   0
> cC[1] <- cC[1]/2               # correcting the absolute Chebyshev term
>                                # i.e.  1.5*T_0 + 0.5*T_2
> cP <- chebPoly(n)              # summing up the polynomial coefficients
> p <- cC %*% cP                 #  0 0 1 0 1
> 
> 
> 
> cleanEx()
> nameEx("chebPoly")
> ### * chebPoly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chebPoly
> ### Title: Chebyshev Polynomials
> ### Aliases: chebPoly
> ### Keywords: math
> 
> ### ** Examples
> 
> chebPoly(6)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]    0    0    0    0    0    0    1
[2,]    0    0    0    0    0    1    0
[3,]    0    0    0    0    2    0   -1
[4,]    0    0    0    4    0   -3    0
[5,]    0    0    8    0   -8    0    1
[6,]    0   16    0  -20    0    5    0
[7,]   32    0  -48    0   18    0   -1
> 
> ## Not run: 
> ##D ##  Plot 6 Chebyshev Polynomials
> ##D plot(0, 0, type="n", xlim=c(-1, 1), ylim=c(-1.2, 1.2),
> ##D     main="Chebyshev Polynomials for n=1..6", xlab="x", ylab="y")
> ##D grid()
> ##D x <- seq(-1, 1, length.out = 101)
> ##D for (i in 1:6) {
> ##D     y <- chebPoly(i, x)
> ##D     lines(x, y, col=i)
> ##D }
> ##D legend(x = 0.55, y = 1.2, c("n=1", "n=2", "n=3", "n=4", "n=5", "n=6"),
> ##D     col = 1:6, lty = 1, bg="whitesmoke", cex = 0.75)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("circlefit")
> ### * circlefit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: circlefit
> ### Title: Fitting a Circle
> ### Aliases: circlefit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> # set.seed(8421)
> n  <- 20
> w  <- 2*pi*runif(n)
> xp <- cos(w) + 1 + 0.25 * (runif(n) - 0.5)
> yp <- sin(w) + 1 + 0.25 * (runif(n) - 0.5)
> 
> circe <- circlefit(xp, yp)  #=> 0.9899628 1.0044920 1.0256633
RMS error: 0.05993561 
>                             # RMS error: 0.07631986 
> ## Not run: 
> ##D x0 <- circe[1]; y0 <- circe[2]; r0 <- circe[3]
> ##D plot(c(-0.2, 2.2), c(-0.2, 2.2), type="n", asp=1)
> ##D grid()
> ##D abline(h=0, col="gray"); abline(v=0, col="gray")
> ##D points(xp, yp, col="darkred")
> ##D 
> ##D w  <- seq(0, 2*pi, len=100)
> ##D xx <- r0 * cos(w) + x0
> ##D yy <- r0 * sin(w) + y0
> ##D lines(xx, yy, col="blue")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("clear")
> ### * clear
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clear, who(s), ver
> ### Title: Clear function (Matlab style)
> ### Aliases: clear ver who whos
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # clear()  # DON'T
> # who()
> # whos()
> # ver()
> 
> 
> 
> cleanEx()
> nameEx("clenshaw_curtis")
> ### * clenshaw_curtis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clenshaw_curtis
> ### Title: Clenshaw-Curtis Quadrature Formula
> ### Aliases: clenshaw_curtis
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Quadrature with Chebyshev nodes and weights
> f <- function(x) sin(x+cos(10*exp(x))/3)
> ## Not run: ezplot(f, -1, 1, fill = TRUE)
> cc <- clenshaw_curtis(f, n = 64)  #=>  0.0325036517151 , true error > 1.3e-10
> 
> 
> 
> cleanEx()
> nameEx("combs")
> ### * combs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combs
> ### Title: Generate Combinations
> ### Aliases: combs
> ### Keywords: arith
> 
> ### ** Examples
> 
> combs(seq(2, 10, by=2), m = 3)
      [,1] [,2] [,3]
 [1,]    2    4    6
 [2,]    2    4    8
 [3,]    2    4   10
 [4,]    2    6    8
 [5,]    2    6   10
 [6,]    2    8   10
 [7,]    4    6    8
 [8,]    4    6   10
 [9,]    4    8   10
[10,]    6    8   10
> 
> 
> 
> cleanEx()
> nameEx("compan")
> ### * compan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compan
> ### Title: Companion Matrix
> ### Aliases: compan
> ### Keywords: array
> 
> ### ** Examples
> 
>   p <- c(1, 0, -7, 6)
>   compan(p)
     [,1] [,2] [,3]
[1,]    0    7   -6
[2,]    1    0    0
[3,]    0    1    0
>   # 0  7 -6
>   # 1  0  0
>   # 0  1  0
> 
> 
> 
> cleanEx()
> nameEx("complexstep")
> ### * complexstep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complexstep
> ### Title: Complex Step Derivatives
> ### Aliases: complexstep grad_csd jacobian_csd hessian_csd laplacian_csd
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from Martins et al.
> f <- function(x) exp(x)/sqrt(sin(x)^3 + cos(x)^3)  # derivative at x0 = 1.5
> # central diff formula    # 4.05342789402801, error 1e-10
> # numDeriv::grad(f, 1.5)  # 4.05342789388197, error 1e-12  Richardson
> # pracma::numderiv        # 4.05342789389868, error 5e-14  Richardson
> complexstep(f, 1.5)       # 4.05342789389862, error 1e-15
[1] 4.053428
> # Symbolic calculation:   # 4.05342789389862
> 
> jacobian_csd(f, 1.5)
         [,1]
[1,] 4.053428
> 
> f1 <- function(x) sum(sin(x))
> grad_csd(f1, rep(2*pi, 3))
[1] 1 1 1
> ## [1] 1 1 1
> 
> laplacian_csd(f1, rep(pi/2, 3))
[1] -3
> ## [1] -3
> 
> f2 <- function(x) c(sin(x[1]) * exp(-x[2]))
> hessian_csd(f2, c(0.1, 0.5, 0.9))
            [,1]        [,2] [,3]
[1,] -0.06055203 -0.60350053    0
[2,] -0.60350053  0.06055203    0
[3,]  0.00000000  0.00000000    0
> ##             [,1]        [,2] [,3]
> ## [1,] -0.06055203 -0.60350053    0
> ## [2,] -0.60350053  0.06055203    0
> ## [3,]  0.00000000  0.00000000    0
> 
> f3 <- function(u) {
+     x <- u[1]; y <- u[2]; z <- u[3]
+     matrix(c(exp(x^+y^2), sin(x+y), sin(x)*cos(y), x^2 - y^2), 2, 2)
+   }
> jacobian_csd(f3, c(1,1,1))
           [,1]       [,2] [,3]
[1,]  2.7182818  0.0000000    0
[2,] -0.4161468 -0.4161468    0
[3,]  0.2919266 -0.7080734    0
[4,]  2.0000000 -2.0000000    0
> ##            [,1]       [,2] [,3]
> ## [1,]  2.7182818  0.0000000    0
> ## [2,] -0.4161468 -0.4161468    0
> ## [3,]  0.2919266 -0.7080734    0
> ## [4,]  2.0000000 -2.0000000    0
> 
> 
> 
> cleanEx()
> nameEx("cond")
> ### * cond
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cond
> ### Title: Matrix Condition
> ### Aliases: cond
> ### Keywords: array
> 
> ### ** Examples
> 
> cond(hilb(8))
[1] 15257575538
> 
> 
> 
> cleanEx()
> nameEx("conv")
> ### * conv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conv
> ### Title: Polynomial Convolution
> ### Aliases: conv
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> conv(c(1, 1, 1), 1)
[1] 1 1 1
> conv(c(1, 1, 1), c(0, 0, 1))
[1] 3.330669e-17 8.881784e-17 1.000000e+00 1.000000e+00 1.000000e+00
> conv(c(-0.5, 1, -1), c(0.5, 0, 1))
[1] -0.25  0.50 -1.00  1.00 -1.00
> 
> 
> 
> cleanEx()
> nameEx("cotes")
> ### * cotes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cotes
> ### Title: Newton-Cotes Formulas
> ### Aliases: cotes
> ### Keywords: math
> 
> ### ** Examples
> 
> cotes(sin, 0, pi/2, 20, 2)      # 0.999485905248533
[1] 0.9994859
> cotes(sin, 0, pi/2, 20, 3)      # 1.000000211546591
[1] 1
> cotes(sin, 0, pi/2, 20, 4)      # 1.000000391824184
[1] 1
> cotes(sin, 0, pi/2, 20, 5)      # 0.999999999501637
[1] 1
> cotes(sin, 0, pi/2, 20, 6)      # 0.999999998927507
[1] 1
> cotes(sin, 0, pi/2, 20, 7)      # 1.000000000000363  odd degree is better
[1] 1
> cotes(sin, 0, pi/2, 20, 8)      # 1.000000000002231
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("cranknic")
> ### * cranknic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cranknic
> ### Title: Crank-Nicolson Method
> ### Aliases: cranknic
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Newton's example
> f <- function(x, y) 1 - 3*x + y + x^2 + x*y
> sol100  <- cranknic(f, 0, 1, 0, N = 100)
> sol1000 <- cranknic(f, 0, 1, 0, N = 1000)
> 
> ## Not run: 
> ##D # Euler's forward approach
> ##D feuler <- function(f, t0, t1, y0, n) {
> ##D     h <- (t1 - t0)/n;  x <- seq(t0, t1, by = h)
> ##D     y <- numeric(n+1); y[1] <- y0
> ##D     for (i in 1:n) y[i+1] <- y[i] + h * f(x[i], y[i])
> ##D     return(list(x = x, y = y))
> ##D }
> ##D 
> ##D solode <- ode23(f, 0, 1, 0)
> ##D soleul <- feuler(f, 0, 1, 0, 100)
> ##D 
> ##D plot(soleul$x, soleul$y, type = "l", col = "blue", 
> ##D      xlab = "", ylab = "", main = "Newton's example")
> ##D lines(solode$t, solode$y, col = "gray", lwd = 3)
> ##D lines(sol100$t, sol100$y, col = "red")
> ##D lines(sol1000$t, sol1000$y, col = "green")
> ##D grid()
> ##D 
> ##D ##  System of differential equations
> ##D # "Herr und Hund"
> ##D fhh <- function(x, y) {
> ##D     y1 <- y[1]; y2 <- y[2]
> ##D     s <- sqrt(y1^2 + y2^2)
> ##D     dy1 <- 0.5 - 0.5*y1/s
> ##D     dy2 <- -0.5*y2/s
> ##D     return(c(dy1, dy2))
> ##D }
> ##D 
> ##D sol <- cranknic(fhh, 0, 60, c(0, 10))
> ##D plot(sol$y[, 1], sol$y[, 2], type = "l", col = "blue",
> ##D      xlab = "", ylab = "", main = '"Herr und Hund"')
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cross")
> ### * cross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cross
> ### Title: Vector Cross Product
> ### Aliases: cross
> ### Keywords: array
> 
> ### ** Examples
> 
>   cross(c(1, 2, 3), c(4, 5, 6))  # -3  6 -3
[1] -3  6 -3
> 
> 
> 
> cleanEx()
> nameEx("crossn")
> ### * crossn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossn
> ### Title: n-dimensional Vector Cross Product
> ### Aliases: crossn
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- matrix(c(1,0,0, 0,1,0), nrow=2, ncol=3, byrow=TRUE)
> crossn(A)  #=> 0 0 1
[1] 0 0 1
> 
> x <- c(1.0, 0.0, 0.0)
> y <- c(1.0, 0.5, 0.0)
> z <- c(0.0, 0.0, 1.0)
> identical(dot(x, crossn(rbind(y, z))), det(rbind(x, y, z)))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("cubicspline")
> ### * cubicspline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cubicspline
> ### Title: Interpolating Cubic Spline
> ### Aliases: cubicspline
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Example: Average temperatures at different latitudes
> x <- seq(-55, 65, by = 10)
> y <- c(-3.25, -3.37, -3.35, -3.20, -3.12, -3.02, -3.02,
+        -3.07, -3.17, -3.32, -3.30, -3.22, -3.10)
> xs <- seq(-60, 70, by = 1)
> 
> # Generate a function for this
> pp <- cubicspline(x, y)
> ppfun <- function(xs) ppval(pp, xs)
> 
> ## Not run: 
> ##D # Plot with and without endpoint correction
> ##D plot(x, y, col = "darkblue",
> ##D            xlim = c(-60, 70), ylim = c(-3.5, -2.8),
> ##D            xlab = "Latitude", ylab = "Temp. Difference",
> ##D            main = "Earth Temperatures per Latitude")
> ##D lines(spline(x, y), col = "darkgray")
> ##D grid()
> ##D 
> ##D ys <- cubicspline(x, y, xs, endp2nd = TRUE)     # der = 0 at endpoints
> ##D lines(xs, ys, col = "red")
> ##D ys <- cubicspline(x, y, xs)                     # no endpoint condition
> ##D lines(xs, ys, col = "darkred")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("curvefit")
> ### * curvefit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curvefit
> ### Title: Parametric Curve Fit
> ### Aliases: curvefit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Approximating half circle arc with small perturbations
> N <- 50
> u <- linspace(0, pi, N)
> x <- cos(u) + 0.05 * randn(1, N)
> y <- sin(u) + 0.05 * randn(1, N)
> n <- 8
> cfit1 <- curvefit(u, x, y, n)
> ## Not run: 
> ##D plot(x, y, col = "darkgray", pch = 19, asp = 1)
> ##D xp <- cfit1$xp; yp <- cfit1$yp
> ##D lines(xp, yp, col="blue")
> ##D grid()
> ## End(Not run)
> 
> ##  Fix the end points at t = 0 and t = pi
> U <- c(0, pi)
> V <- matrix(c(1, 0, -1, 0), 2, 2, byrow = TRUE)
> cfit2 <- curvefit(u, x, y, n, U, V)
> ## Not run: 
> ##D xp <- cfit2$xp; yp <- cfit2$yp
> ##D lines(xp, yp, col="red")
> ## End(Not run)
> 
> ## Not run: 
> ##D ##  Archimedian spiral
> ##D n <- 8
> ##D u <- linspace(0, 3*pi, 50)
> ##D a <- 1.0
> ##D x <- as.matrix(a*u*cos(u))
> ##D y <- as.matrix(a*u*sin(u))
> ##D plot(x, y, type = "p", pch = 19, col = "darkgray", asp = 1)
> ##D lines(x, y, col = "darkgray", lwd = 3)
> ##D cfit <- curvefit(u, x, y, n)
> ##D px <- c(cfit$px); py <- c(cfit$py)
> ##D v <- linspace(0, 3*pi, 200)
> ##D xs <- polyval(px, v)
> ##D ys <- polyval(py, v)
> ##D lines(xs, ys, col = "navy")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cutpoints")
> ### * cutpoints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cutpoints
> ### Title: Find Cutting Points
> ### Aliases: cutpoints
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> N <- 100; x <- sort(runif(N))
> cp <- cutpoints(x, 6, 0.9)
> n <- length(cp$cutp)
> 
> # Print out
> nocp <- rle(findInterval(x, c(-Inf, cp$cutp, Inf)))$lengths
> cbind(c(-Inf, cp$cutp), c(cp$cutp, Inf), nocp)
                           nocp
[1,]       -Inf 0.04113279    2
[2,] 0.04113279 0.15993057    9
[3,] 0.15993057 0.22588597    6
[4,] 0.22588597 0.28041202    6
[5,] 0.28041202 0.58620959   33
[6,] 0.58620959 0.97626205   43
[7,] 0.97626205        Inf    1
> 
> # Define a factor from the cutting points
> fx <- cut(x, breaks = c(-Inf, cp$cutp, Inf))
> 
> ## Not run: 
> ##D # Plot points and cutting points
> ##D plot(x, rep(0, N), col="gray", ann = FALSE)
> ##D points(cp$cutp, rep(0, n), pch="|", col=2)
> ##D 
> ##D # Compare with k-means clustering
> ##D km <- kmeans(x, n)
> ##D points(x, rep(0, N), col = km$cluster, pch = "+")
> ##D 
> ##D ##  A 2-dimensional example
> ##D x <- y <- c()
> ##D for (i in 1:9) {
> ##D   for (j in 1:9) {
> ##D     x <- c(x, i + rnorm(20, 0, 0.2))
> ##D     y <- c(y, j + rnorm(20, 0, 0.2))
> ##D   }
> ##D }
> ##D cpx <- cutpoints(x, 8, 0)
> ##D cpy <- cutpoints(y, 8, 0)
> ##D 
> ##D plot(x, y, pch = 18, col=rgb(0.5,0.5,0.5), axes=FALSE, ann=FALSE)
> ##D for (xi in cpx$cutp) abline(v=xi, col=2, lty=2)
> ##D for (yi in cpy$cutp) abline(h=yi, col=2, lty=2)
> ##D 
> ##D km <- kmeans(cbind(x, y), 81)
> ##D points(x, y, col=km$cluster)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("dblquad")
> ### * dblquad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dblquad
> ### Title: Double and Triple Integration
> ### Aliases: dblquad triplequad
> ### Keywords: math
> 
> ### ** Examples
> 
> f1 <- function(x, y) x^2 + y^2
> dblquad(f1, -1, 1, -1, 1)       #   2.666666667 , i.e. 8/3 . err = 0
[1] 2.666667
> 
> f2 <- function(x, y) y*sin(x)+x*cos(y)
> dblquad(f2, pi, 2*pi, 0, pi)    #  -9.869604401 , i.e. -pi^2, err = 0
[1] -9.869604
> 
> # f3 <- function(x, y) sqrt((1 - (x^2 + y^2)) * (x^2 + y^2 <= 1))
> f3 <- function(x, y) sqrt(pmax(0, 1 - (x^2 + y^2)))
> dblquad(f3, -1, 1, -1, 1)       #   2.094395124 , i.e. 2/3*pi , err = 2e-8
[1] 2.094395
> 
> f4 <- function(x, y, z) y*sin(x)+z*cos(x)
> triplequad(f4, 0,pi, 0,1, -1,1) # - 2.0 => -2.220446e-16
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("deconv")
> ### * deconv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deconv
> ### Title: Deconvolution
> ### Aliases: deconv
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> b <- c(10, 40, 100, 160, 170, 120)
> a <- c(1, 2, 3, 4)
> 
> p <- deconv(b, a)
> p$q                #=> 10 20 30
[1] 10 20 30
> p$r                #=>  0  0  0
[1] 0 0 0
> 
> 
> 
> cleanEx()
> nameEx("deeve")
> ### * deeve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deeve
> ### Title: Event Detection in ODE solution
> ### Aliases: deeve
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Damped pendulum:  y'' = -0.3 y' - sin(y)
> #   y1 = y, y2 = y':  y1' = y2,  y2' = -0.3*y2 - sin(y1)
> f <- function(t, y) {
+ 	dy1 <- y[2]
+ 	dy2 <- -0.3*y[2] - sin(y[1])
+ 	return(c(dy1, dy2))
+ }
> sol <- rk4sys(f, 0, 10, c(pi/2, 0), 100)
> deeve(sol$x, sol$y[,1])                   # y1 = 0 : elongation in [sec]
[1] 2.073507 5.414753 8.650250
> # [1] 2.073507 5.414753 8.650250
> # matplot(sol$x, sol$y); grid()
> 
> 
> 
> cleanEx()
> nameEx("deg2rad")
> ### * deg2rad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deg2rad
> ### Title: Degrees to Radians
> ### Aliases: deg2rad rad2deg
> ### Keywords: math
> 
> ### ** Examples
> 
> deg2rad(c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90))
 [1] 0.0000000 0.1745329 0.3490659 0.5235988 0.6981317 0.8726646 1.0471976
 [8] 1.2217305 1.3962634 1.5707963
> rad2deg(seq(-pi/2, pi/2, length = 19))
 [1] -90 -80 -70 -60 -50 -40 -30 -20 -10   0  10  20  30  40  50  60  70  80  90
> 
> 
> 
> cleanEx()
> nameEx("detrend")
> ### * detrend
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: detrend
> ### Title: Remove Linear Trends
> ### Aliases: detrend
> ### Keywords: math
> 
> ### ** Examples
> 
> t <- 1:9
> x <- c(0, 2, 0, 4, 4, 4, 0, 2, 0)
> x - detrend(x, 'constant')
          [,1]
 [1,] 1.777778
 [2,] 1.777778
 [3,] 1.777778
 [4,] 1.777778
 [5,] 1.777778
 [6,] 1.777778
 [7,] 1.777778
 [8,] 1.777778
 [9,] 1.777778
> x - detrend(x, 'linear')
          [,1]
 [1,] 1.777778
 [2,] 1.777778
 [3,] 1.777778
 [4,] 1.777778
 [5,] 1.777778
 [6,] 1.777778
 [7,] 1.777778
 [8,] 1.777778
 [9,] 1.777778
> 
> y <- detrend(x, 'linear', 5)
> ## Not run: 
> ##D plot(t, x, col="blue")
> ##D lines(t, x - y, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("deval")
> ### * deval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deval
> ### Title: Evaluate ODE Solution
> ### Aliases: deval
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Free fall:  v' = -g - cw abs(v)^1.1,  cw = 1.6 drag coefficien
> f <- function(t, y) -9.81 + 1.6*abs(y)^1.1
> sol <- rk4(f, 0, 10, 0, 100)
> # speed after 0.5, 1, 1.5, 2 seconds
> cbind(c(0.5,1,1.5,2), -deval(sol$x, sol$y, c(0.5, 1, 1.5, 2)))
     [,1]     [,2]
[1,]  0.5 3.272267
[2,]  1.0 4.507677
[3,]  1.5 4.953259
[4,]  2.0 5.112068
> #  0.5  3.272267  m/s
> #  1.0  4.507677
> #  1.5  4.953259
> #  2.0  5.112068
> # plot(sol$x, -sol$y, type="l", col="blue"); grid()
> 
> 
> 
> cleanEx()
> nameEx("diag")
> ### * diag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Diag
> ### Title: Matrix Diagonal
> ### Aliases: Diag
> ### Keywords: array
> 
> ### ** Examples
> 
> Diag(matrix(1:12,3,4),  1)
[1]  4  8 12
> Diag(matrix(1:12,3,4), -1)
[1] 2 6
> 
> Diag(c(1,5,9), 1)
     [,1] [,2] [,3] [,4]
[1,]    0    1    0    0
[2,]    0    0    5    0
[3,]    0    0    0    9
[4,]    0    0    0    0
> Diag(c(1,5,9), -1)
     [,1] [,2] [,3] [,4]
[1,]    0    0    0    0
[2,]    1    0    0    0
[3,]    0    5    0    0
[4,]    0    0    9    0
> 
> 
> 
> cleanEx()
> nameEx("distmat")
> ### * distmat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distmat
> ### Title: Distance Matrix
> ### Aliases: distmat pdist pdist2
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- c(0.0, 0.0)
> B <- matrix(c(
+         0,0, 1,0, 0,1, 1,1), nrow=4, ncol = 2, byrow = TRUE)
> distmat(A, B)  #=> 0 1 1 sqrt(2)
     [,1] [,2] [,3]     [,4]
[1,]    0    1    1 1.414214
> 
> X <- matrix(rep(0.5, 5), nrow=1, ncol=5)
> Y <- matrix(runif(50), nrow=10, ncol=5)
> distmat(X, Y)
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
[1,] 0.6585844 0.4851493 0.3786591 0.6492663 0.5692546 0.5327267 0.8920051
          [,8]      [,9]     [,10]
[1,] 0.6602172 0.5212961 0.5826777
> 
> # A more vectorized form of distmat:
> distmat2 <- function(x, y) {
+     sqrt(outer(rowSums(x^2), rowSums(y^2), '+') - tcrossprod(x, 2 * y))
+ }
> 
> 
> 
> cleanEx()
> nameEx("dot")
> ### * dot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dot
> ### Title: Scalar Product
> ### Aliases: dot
> ### Keywords: array
> 
> ### ** Examples
> 
>   dot(1:5, 1:5)  #=> 55
[1] 55
>   # Length of space diagonal in 3-dim- cube:
>   sqrt(dot(c(1,1,1), c(1,1,1)))  #=> 1.732051
[1] 1.732051
> 
> 
> 
> cleanEx()
> nameEx("eig")
> ### * eig
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eig
> ### Title: Eigenvalue Function (Matlab Style)
> ### Aliases: eig
> ### Keywords: array
> 
> ### ** Examples
> 
>   eig(matrix(c(1,-1,-1,1), 2, 2))   #=> 2 0
[1] 2 0
>   eig(matrix(c(1,1,-1,1), 2, 2))    # complex values
[1] 1+1i 1-1i
>   eig(matrix(c(0,1i,-1i,0), 2, 2))  # real values
[1]  1 -1
> 
> 
> 
> cleanEx()
> nameEx("eigjacobi")
> ### * eigjacobi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eigjacobi
> ### Title: Jacobi Eigenvalue Method
> ### Aliases: eigjacobi
> ### Keywords: math
> 
> ### ** Examples
> 
> A <- matrix(c( 1.06, -0.73,  0.77, -0.67,
+               -0.73,  2.64,  1.04,  0.72,
+                0.77,  1.04,  3.93, -2.14,
+               -0.67,  0.72, -2.14,  2.04), 4, 4, byrow = TRUE)
> eigjacobi(A)
$V
           [,1]       [,2]       [,3]       [,4]
[1,] 0.87019414 -0.3151209  0.1975473 -0.3231656
[2,] 0.11138094  0.8661855  0.1178032 -0.4726938
[3,] 0.07043799  0.1683401  0.8273261  0.5312548
[4,] 0.47475776  0.3494040 -0.5124734  0.6244140

$D
[1] 0.66335457 3.39813189 5.58753257 0.02098098

> # $V
> #            [,1]       [,2]       [,3]       [,4]
> # [1,] 0.87019414 -0.3151209  0.1975473 -0.3231656
> # [2,] 0.11138094  0.8661855  0.1178032 -0.4726938
> # [3,] 0.07043799  0.1683401  0.8273261  0.5312548
> # [4,] 0.47475776  0.3494040 -0.5124734  0.6244140
> # 
> # $D
> # [1] 0.66335457 3.39813189 5.58753257 0.02098098
> 
> 
> 
> cleanEx()
> nameEx("einsteinF")
> ### * einsteinF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: einsteinF
> ### Title: Einstein Functions
> ### Aliases: einsteinF
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x1 <- seq(-4, 4, length.out = 101)
> ##D y1 <- einsteinF(1, x1)
> ##D plot(x1, y1, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E1(x)")
> ##D grid()
> ##D 
> ##D y2 <- einsteinF(2, x1)
> ##D plot(x1, y2, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E2(x)")
> ##D grid()
> ##D 
> ##D x3 <- seq(0, 5, length.out = 101)
> ##D y3 <- einsteinF(3, x3)
> ##D plot(x3, y3, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E3(x)")
> ##D grid()
> ##D 
> ##D y4 <- einsteinF(4, x3)
> ##D plot(x3, y4, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E4(x)")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ellip")
> ### * ellip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ellipke,ellipj
> ### Title: Elliptic and Jacobi Elliptic Integrals
> ### Aliases: ellipke ellipj
> ### Keywords: specfun
> 
> ### ** Examples
> 
> x <- linspace(0, 1, 20)
> ke <- ellipke(x)
> 
> ## Not run: 
> ##D plot(x, ke$k, type = "l", col ="darkblue", ylim = c(0, 5),
> ##D      main = "Elliptic Integrals")
> ##D lines(x, ke$e, col = "darkgreen")
> ##D legend( 0.01, 4.5,
> ##D         legend = c("Elliptic integral of first kind",
> ##D                    "Elliptic integral of second kind"),
> ##D         col = c("darkblue", "darkgreen"), lty = 1)
> ##D grid()
> ## End(Not run)
> 
> ## ellipse circumference with axes a, b
> ellipse_cf <- function(a, b) {
+     return(4*a*ellipke(1 - (b^2/a^2))$e)
+ }
> print(ellipse_cf(1.0, 0.8), digits = 10)
[1] 5.672333578
> # [1] 5.672333578
> 
> ## Jacobi elliptic integrals
> u <- c(0, 1, 2, 3, 4, 5)
> m <- seq(0.0, 1.0, by = 0.2)
> je <- ellipj(u, m)
> # $sn       0.0000  0.8265  0.9851  0.7433  0.4771  0.9999
> # $cn       1.0000  0.5630 -0.1720 -0.6690 -0.8789  0.0135
> # $dn       1.0000  0.9292  0.7822  0.8176  0.9044  0.0135
> je$sn^2 + je$cn^2       # 1 1 1 1 1 1
[1] 1 1 1 1 1 1
> je$dn^2 + m * je$sn^2   # 1 1 1 1 1 1
[1] 1 1 1 1 1 1
> 
> 
> 
> cleanEx()
> nameEx("entropy")
> ### * entropy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: approx_entropy
> ### Title: Approximate and Sample Entropy
> ### Aliases: approx_entropy sample_entropy
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> ts <- rep(61:65, 10)
> approx_entropy(ts, edim = 2)                      # -0.0004610253
[1] -0.0004610253
> sample_entropy(ts, edim = 2)                      #  0
[1] 0
> 
> set.seed(8237)
> approx_entropy(rnorm(500), edim = 2)              # 1.351439  high, random
[1] 1.351439
> approx_entropy(sin(seq(1,100,by=0.2)), edim = 2)  # 0.171806  low,  deterministic
[1] 0.1718064
> sample_entropy(sin(seq(1,100,by=0.2)), edim = 2)  # 0.2359326
[1] 0.2359326
> 
> ## Not run: 
> ##D (Careful: This will take several minutes.)
> ##D # generate simulated data
> ##D N <- 1000; t <- 0.001*(1:N)
> ##D sint   <- sin(2*pi*10*t);    sd1 <- sd(sint)    # sine curve
> ##D whitet <- rnorm(N);          sd2 <- sd(whitet)  # white noise
> ##D chirpt <- sint + 0.1*whitet; sd3 <- sd(chirpt)  # chirp signal
> ##D 
> ##D # calculate approximate entropy
> ##D rnum <- 30; result <- zeros(3, rnum)
> ##D for (i in 1:rnum) {
> ##D     r <- 0.02 * i
> ##D     result[1, i] <- approx_entropy(sint,   2, r*sd1)
> ##D     result[2, i] <- approx_entropy(chirpt, 2, r*sd2)
> ##D     result[3, i] <- approx_entropy(whitet, 2, r*sd3)
> ##D }
> ##D 
> ##D # plot curves
> ##D r <- 0.02 * (1:rnum)
> ##D plot(c(0, 0.6), c(0, 2), type="n",
> ##D      xlab = "", ylab = "", main = "Approximate Entropy")
> ##D points(r, result[1, ], col="red");    lines(r, result[1, ], col="red")
> ##D points(r, result[2, ], col="green");  lines(r, result[2, ], col="green")
> ##D points(r, result[3, ], col="blue");   lines(r, result[3, ], col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("eps")
> ### * eps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eps
> ### Title: Floating Point Relative Accuracy
> ### Aliases: eps
> ### Keywords: arith
> 
> ### ** Examples
> 
> for (i in -5:5) cat(eps(10^i), "\n")
1.694066e-21 
1.355253e-20 
2.168404e-19 
1.734723e-18 
1.387779e-17 
2.220446e-16 
1.776357e-15 
1.421085e-14 
1.136868e-13 
1.818989e-12 
1.455192e-11 
> # 1.694066e-21 
> # 1.355253e-20 
> # 2.168404e-19 
> # 1.734723e-18 
> # 1.387779e-17 
> # 2.220446e-16 
> # 1.776357e-15 
> # 1.421085e-14 
> # 1.136868e-13 
> # 1.818989e-12 
> # 1.455192e-11 
> 
> 
> 
> cleanEx()
> nameEx("erfz")
> ### * erfz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: erf
> ### Title: Error Functions and Inverses (Matlab Style)
> ### Aliases: erf erfinv erfc erfcinv erfcx erfz erfi
> ### Keywords: stat
> 
> ### ** Examples
> 
>   x <- 1.0
>   erf(x); 2*pnorm(sqrt(2)*x) - 1
[1] 0.8427008
[1] 0.8427008
> # [1] 0.842700792949715
> # [1] 0.842700792949715
>   erfc(x); 1 - erf(x); 2*pnorm(-sqrt(2)*x)
[1] 0.1572992
[1] 0.1572992
[1] 0.1572992
> # [1] 0.157299207050285
> # [1] 0.157299207050285
> # [1] 0.157299207050285
>   erfz(x)
[1] 0.8427008
> # [1] 0.842700792949715
>   erfi(x)
[1] 1.650426
> # [1] 1.650425758797543
> 
> 
> 
> cleanEx()
> nameEx("errorbar")
> ### * errorbar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: errorbar
> ### Title: Plot Error Bars
> ### Aliases: errorbar
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- seq(0, 2*pi, length.out = 20)
> ##D y <- sin(x)
> ##D xe <- 0.1
> ##D ye <- 0.1 * y
> ##D errorbar(x, y, xe, ye, type = "l", with = FALSE)
> ##D 
> ##D cnt <- round(100*randn(20, 3))
> ##D y <- apply(cnt, 1, mean)
> ##D e <- apply(cnt, 1, sd)
> ##D errorbar(1:20, y, yerr = e, bar.col = "blue")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("eta")
> ### * eta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eta
> ### Title: Dirichlet Eta Function
> ### Aliases: eta
> ### Keywords: specfun
> 
> ### ** Examples
> 
> z <- 0.5 + (1:5)*1i
> eta(z)
[1] 0.6398619+0.1935145i 0.7595015+0.3816610i 0.9970914+0.5247927i
[4] 1.3606677+0.5208038i 1.7467035+0.2246479i
> z <- c(0, 0.5+1i, 1, 1i, 2+2i, -1, -2, -1-1i)
> eta(z)
[1] 0.5000000+0.0000000i 0.6398619+0.1935145i 0.6931472+0.0000000i
[4] 0.5325932+0.2293849i 0.9230198+0.1764252i 0.2500000+0.0000000i
[7] 0.0000000+0.0000000i 0.2567153-0.2802308i
> 
> 
> 
> cleanEx()
> nameEx("euler_heun")
> ### * euler_heun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: euler_heun
> ### Title: Euler-Heun ODE Solver
> ### Aliases: euler_heun
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Flame-up process
> f <- function(x, y) y^2 - y^3
> s1 <- cranknic(f, 0, 200, 0.01)
> s2 <- euler_heun(f, 0, 200, 0.01)
> ## Not run: 
> ##D plot(s1$t, s1$y, type="l", col="blue")
> ##D lines(s2$t, s2$y, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expint")
> ### * expint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expint
> ### Title: Exponential and Logarithmic Integral
> ### Aliases: expint expint_E1 expint_Ei li
> ### Keywords: specfun
> 
> ### ** Examples
> 
> expint_E1(1:10)
 [1] 2.193839e-01 4.890051e-02 1.304838e-02 3.779352e-03 1.148296e-03
 [6] 3.600825e-04 1.154817e-04 3.766562e-05 1.244735e-05 4.156969e-06
> #   0.2193839  0.0489005  0.0130484  0.0037794  0.0011483
> #   0.0003601  0.0001155  0.0000377  0.0000124  0.0000042
> expint_Ei(1:10)
 [1]    1.895118    4.954234    9.933833   19.630874   40.185275   85.989762
 [7]  191.504743  440.379900 1037.878291 2492.228976
> 
> ## Not run: 
> ##D estimPi <- function(n) round(Re(li(n) - li(2))) # estimated number of primes
> ##D primesPi <- function(n) length(primes(n))       # true number of primes <= n
> ##D N <- 1e6
> ##D (estimPi(N) - primesPi(N)) / estimPi(N)         # deviation is 0.16 percent!
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expm")
> ### * expm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expm
> ### Title: Matrix Exponential
> ### Aliases: expm logm
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  The Ward test cases described in the help for expm::expm agree up to
> ##  10 digits with the values here and with results from Matlab's expm !
> A <- matrix(c(-49, -64, 24, 31), 2, 2)
> expm(A)
           [,1]      [,2]
[1,] -0.7357588 0.5518191
[2,] -1.4715176 1.1036382
> # -0.7357588 0.5518191
> # -1.4715176 1.1036382
> 
> A1 <- matrix(c(10,  7,  8,  7,
+                 7,  5,  6,  5,
+                 8,  6, 10,  9,
+                 7,  5,  9, 10), nrow = 4, ncol = 4, byrow = TRUE)
> expm(logm(A1))
     [,1] [,2] [,3] [,4]
[1,]   10    7    8    7
[2,]    7    5    6    5
[3,]    8    6   10    9
[4,]    7    5    9   10
> logm(expm(A1))
         [,1]     [,2]      [,3]      [,4]
[1,] 9.999345 7.073906  7.844712  7.111253
[2,] 7.073906 4.784269  6.225867  4.843167
[3,] 7.844712 6.225867 10.042989  8.947139
[4,] 7.111253 4.843167  8.947139 10.057609
> 
> ##  System of linear differential equations: y' = M y  (y = c(y1, y2, y3))
> M <- matrix(c(2,-1,1, 0,3,-1, 2,1,3), 3, 3, byrow=TRUE)
> M
     [,1] [,2] [,3]
[1,]    2   -1    1
[2,]    0    3   -1
[3,]    2    1    3
> C1 <- 0.5; C2 <- 1.0; C3 <- 1.5
> t  <- 2.0; Mt <- expm(t * M)
> yt <- Mt 
> 
> 
> 
> cleanEx()
> nameEx("eye")
> ### * eye
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eye
> ### Title: Some Basic Matrices
> ### Aliases: eye ones zeros
> ### Keywords: array
> 
> ### ** Examples
> 
> eye(3)
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1
> ones(3, 1)
     [,1]
[1,]    1
[2,]    1
[3,]    1
> zeros(1, 3)
     [,1] [,2] [,3]
[1,]    0    0    0
> 
> 
> 
> cleanEx()
> nameEx("ezcontour")
> ### * ezcontour
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ezcontour,ezsurf,ezmesh
> ### Title: Contour, Surface, and Mesh Plotter
> ### Aliases: ezcontour ezsurf ezmesh
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f <- function(xy) {
> ##D     x <- xy[1]; y <- xy[2]
> ##D     3*(1-x)^2 * exp(-(x^2) - (y+1)^2) -
> ##D         10*(x/5 - x^3 - y^5) * exp(-x^2 - y^2) -
> ##D         1/3 * exp(-(x+1)^2 - y^2)
> ##D     }
> ##D ezcontour(f, col = "navy")
> ##D ezcontour(f, filled = TRUE)
> ##D ezmesh(f)
> ##D ezmesh(f, col="lightblue", theta = -15, phi = 30)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ezplot")
> ### * ezplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ezplot
> ### Title: Easy Function Plot
> ### Aliases: ezplot fplot
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fun <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> ##D ezplot(fun, 0, 5, n = 1001, fill = TRUE)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ezpolar")
> ### * ezpolar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ezpolar
> ### Title: Easy Polar Plot
> ### Aliases: ezpolar
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fun <- function(x) 1 + cos(x)
> ##D ezpolar(fun)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fact")
> ### * fact
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fact
> ### Title: Factorial Function
> ### Aliases: fact factorial2
> ### Keywords: math
> 
> ### ** Examples
> 
> fact(c(-1, 0, 1, NA, 171))  #=> NaN   1   1  NA Inf
[1] NaN   1   1  NA Inf
> fact(100)                   #=> 9.332621544394410e+157
[1] 9.332622e+157
> factorial(100)              #=> 9.332621544394225e+157
[1] 9.332622e+157
> # correct value:                9.332621544394415e+157
> # Stirling's approximation:     9.324847625269420e+157
> # n! ~ sqrt(2*pi*n) * (n/e)^n
> 
> factorial2(8);  factorial2(9);  factorial2(10)  # 384   945  3840
[1] 384
[1] 945
[1] 3840
> factorial(10) / factorial2(10)                  # => factorial2(9)
[1] 945
> 
> 
> 
> cleanEx()
> nameEx("factors")
> ### * factors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: factors
> ### Title: Prime Factors
> ### Aliases: factors
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   factors(1002001)       # 7  7  11  11  13  13
> ##D   factors(65537)         # is prime
> ##D   # Euler's calculation
> ##D   factors(2^32 + 1)      # 641  6700417
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fderiv")
> ### * fderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fderiv
> ### Title: Numerical Differentiation
> ### Aliases: fderiv
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f <- sin
> ##D xs <- seq(-pi, pi, length.out = 100)
> ##D ys <- f(xs)
> ##D y1 <- fderiv(f, xs, n = 1, method = "backward")
> ##D y2 <- fderiv(f, xs, n = 2, method = "backward")
> ##D y3 <- fderiv(f, xs, n = 3, method = "backward")
> ##D y4 <- fderiv(f, xs, n = 4, method = "backward")
> ##D plot(xs, ys, type = "l", col = "gray", lwd = 2,
> ##D      xlab = "", ylab = "", main = "Sinus and its Derivatives")
> ##D lines(xs, y1, col=1, lty=2)
> ##D lines(xs, y2, col=2, lty=3)
> ##D lines(xs, y3, col=3, lty=4)
> ##D lines(xs, y4, col=4, lty=5)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fibsearch")
> ### * fibsearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fibsearch
> ### Title: Fibonacci Search
> ### Aliases: fibsearch
> ### Keywords: optimize
> 
> ### ** Examples
> 
> f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> fibsearch(f, 0, 4, tol=10^-10)   # $xmin    = 3.24848329403424
$xmin
[1] 3.248483

$fmin
[1] -2.665089

$niter
[1] 51

$estim.prec
[1] 6.955103e-11

> optimize(f, c(0,4), tol=10^-10)  # $minimum = 3.24848328971188
$minimum
[1] 3.248483

$objective
[1] -2.665089

> 
> 
> 
> cleanEx()
> nameEx("figure")
> ### * figure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: figure
> ### Title: Control Plot Devices (Matlab Style)
> ### Aliases: figure
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D figure()
> ##D figure(-2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("find")
> ### * find
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: finds
> ### Title: find function (Matlab Style)
> ### Aliases: finds
> ### Keywords: logic
> 
> ### ** Examples
> 
> finds(-3:3 >= 0)
[1] 4 5 6 7
> finds(c(0, 1, 0, 2, 3))
[1] 2 4 5
> 
> 
> 
> cleanEx()
> nameEx("findintervals")
> ### * findintervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findintervals
> ### Title: Find Interval Indices
> ### Aliases: findintervals
> ### Keywords: logic
> 
> ### ** Examples
> 
> xs <- zapsmall(sin(seq(0, 10*pi, len=100)))
> findintervals(0, xs)
 [1]   1  10  20  30  40  50  60  70  80  90 100
> #   1  10  20  30  40  50  60  70  80  90 100
> 
> 
> 
> cleanEx()
> nameEx("findmins")
> ### * findmins
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findmins
> ### Title: Find All Minima
> ### Aliases: findmins
> ### Keywords: optimize
> 
> ### ** Examples
> 
> fun <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> ## Not run: ezplot(fun, 0, 5, n = 1001)
> 
> # If n is smaller, the rightmost minimum will not be found.
> findmins(fun, 0, 5, n= 1000)
 [1] 2.537727 3.248481 3.761840 4.023021 4.295831 4.455115 4.641481 4.756263
 [9] 4.897461 4.987802
> #  2.537727 3.248481 3.761840 4.023021 4.295831
> #  4.455115 4.641481 4.756263 4.897461 4.987802
> 
> 
> 
> cleanEx()
> nameEx("findpeaks")
> ### * findpeaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findpeaks
> ### Title: Find Peaks
> ### Aliases: findpeaks
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> x <- seq(0, 1, len = 1024)
> pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
> hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
> wdt <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
> 
> pSignal <- numeric(length(x))
> for (i in seq(along=pos)) {
+ 	pSignal <- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
+ }
> findpeaks(pSignal, npeaks=3, threshold=4, sortstr=TRUE)
         [,1] [,2] [,3] [,4]
[1,] 4.972146  134  118  144
[2,] 4.960051  799  786  817
[3,] 4.590829  257  246  306
> 
> ## Not run: 
> ##D plot(pSignal, type="l", col="navy")
> ##D grid()
> ##D x <- findpeaks(pSignal, npeaks=3, threshold=4, sortstr=TRUE)
> ##D points(x[, 2], x[, 1], pch=20, col="maroon")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("findzeros")
> ### * findzeros
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findzeros
> ### Title: Find All Roots
> ### Aliases: findzeros
> ### Keywords: math
> 
> ### ** Examples
> 
> f1 <- function(x) sin(pi/x)
> findzeros(f1, 1/10, 1)
 [1] 0.1000000 0.1111028 0.1250183 0.1428641 0.1666655 0.2000004 0.2499867
 [8] 0.3333441 0.4999794 1.0000000
> #  0.1000000  0.1111028  0.1250183  0.1428641  0.1666655
> #  0.2000004  0.2499867  0.3333441  0.4999794  1.0000000
> 
> f2 <- function(x) 0.5*(1 + sin(10*pi*x))
> findzeros(f2, 0, 1)
[1] 0.15 0.35 0.55 0.75 0.95
> #  0.15  0.35  0.55  0.75  0.95
> 
> f3 <- function(x) sin(pi/x) + 1
> findzeros(f3, 0.1, 0.5)
[1] 0.1052632 0.1333333 0.1818182 0.2857143
> # 0.1052632 0.1333333 0.1818182 0.2857143
> 
> f4 <- function(x) sin(pi/x) - 1
> findzeros(f4, 0.1, 0.5)
[1] 0.1176471 0.1538462 0.2222222 0.4000000
> # 0.1176471 0.1538462 0.2222222 0.4000000
> 
> ## Not run: 
> ##D # Dini function
> ##D Dini <- function(x) x * besselJ(x, 1) + 3 * besselJ(x, 0)
> ##D findzeros(Dini, 0, 100, n = 128)
> ##D ezplot(Dini, 0, 100, n = 512)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fletcherpowell")
> ### * fletcherpowell
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fletcher_powell
> ### Title: Fletcher-Powell Conjugate Gradient Minimization
> ### Aliases: fletcher_powell
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Rosenbrock function
> rosenbrock <- function(x) {
+     n <- length(x)
+     x1 <- x[2:n]
+     x2 <- x[1:(n-1)]
+     sum(100*(x1-x2^2)^2 + (1-x2)^2)
+ }
> fletcher_powell(c(0, 0), rosenbrock)
$xmin
[1] 1 1

$fmin
[1] 1.553167e-17

$niter
[1] 14

> # $xmin
> # [1] 1 1
> # $fmin
> # [1] 1.774148e-27
> # $niter
> # [1] 14
> 
> 
> 
> cleanEx()
> nameEx("flipdim")
> ### * flipdim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: flipdim
> ### Title: Matrix Flipping (Matlab Style)
> ### Aliases: flipdim flipud fliplr circshift
> ### Keywords: manip
> 
> ### ** Examples
> 
> a <- matrix(1:12, nrow=3, ncol=4, byrow=TRUE)
> flipud(a)
     [,1] [,2] [,3] [,4]
[1,]    9   10   11   12
[2,]    5    6    7    8
[3,]    1    2    3    4
> fliplr(a)
     [,1] [,2] [,3] [,4]
[1,]    4    3    2    1
[2,]    8    7    6    5
[3,]   12   11   10    9
> 
> circshift(a, c(1, -1))
     [,1] [,2] [,3] [,4]
[1,]   10   11   12    9
[2,]    2    3    4    1
[3,]    6    7    8    5
> v <- 1:10
> circshift(v, 5)
 [1]  6  7  8  9 10  1  2  3  4  5
> 
> 
> 
> cleanEx()
> nameEx("fminbnd")
> ### * fminbnd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fminbnd
> ### Title: Finding Function Minimum
> ### Aliases: fminbnd
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  CHEBFUN example by Trefethen
> f <- function(x) exp(x)*sin(3*x)*tanh(5*cos(30*x))
> fminbnd(f, -1, 1)                   # fourth local minimum (from left)
$xmin
[1] -0.2429114

$fmin
[1] -0.517464

$niter
[1] 17

$estim.prec
[1] 2.429114e-08

> g <- function(x) complexstep(f, x)  # complex-step derivative
> xs <- findzeros(g, -1, 1)           # local minima and maxima
> ys <- f(xs); n0 <- which.min(ys)    # index of global minimum
> fminbnd(f, xs[n0-1], xs[n0+1])      # xmin:0.7036632, fmin: -1.727377
$xmin
[1] 0.7036632

$fmin
[1] -1.727377

$niter
[1] 14

$estim.prec
[1] 7.036632e-08

> 
> ## Not run: 
> ##D ezplot(f, -1, 1, n = 1000, col = "darkblue", lwd = 2)
> ##D ezplot(function(x) g(x)/150, -1, 1, n = 1000, col = "darkred", add = TRUE)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fmincon")
> ### * fmincon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fmincon
> ### Title: Minimize Nonlinear Constrained Multivariable Function.
> ### Aliases: fmincon
> ### Keywords: optimize
> 
> ### ** Examples
> 
> # Classical Rosenbrock function
> n <- 10; x0 <- rep(1/n, n)
> fn <- function(x) {n <- length(x)
+     x1 <- x[2:n]; x2 <- x[1:(n - 1)]
+     sum(100 * (x1 - x2^2)^2 + (1 - x2)^2)
+ }
> # Equality and inequality constraints
> heq1 <- function(x) sum(x)-1.0
> hin1 <- function(x) -1 * x
> hin2 <- function(x) x - 0.5
> ub <- rep(0.5, n)
> 
> # Apply constraint minimization
> res <- fmincon(x0, fn, hin = hin1, heq = heq1)
Error in fmincon(x0, fn, hin = hin1, heq = heq1) : 
  Package 'NlcOptim' missing -- install from CRAN.
Execution halted
