
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "latticeExtra"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('latticeExtra')
Loading required package: lattice
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("EastAuClimate")
> ### * EastAuClimate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EastAuClimate
> ### Title: Climate of the East Coast of Australia
> ### Aliases: EastAuClimate
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(EastAuClimate)
> 
> ## Compare the climates of state capital cities
> EastAuClimate[c("Hobart", "Melbourne", "Sydney", "Brisbane"),]
          SummerMaxTemp SummerMinTemp WinterMaxTemp WinterMinTemp SummerRain
Hobart             22.0          12.7          12.2           4.7       28.1
Melbourne          26.5          15.8          13.9           6.8       32.3
Sydney             26.7          19.3          17.0           7.4       80.6
Brisbane           28.8          20.9          20.6           9.5      107.5
          WinterRain MeanAnnRain RainDays ClearDays CloudyDays    ID Latitude
Hobart          44.1       576.4     90.8      41.1      177.1 94029   -42.89
Melbourne       46.8       654.4     99.2      48.9      178.0 86071   -37.81
Sydney          54.5      1129.2     95.8     104.1      126.3 66037   -33.94
Brisbane        40.0      1192.1     89.4     123.5      105.9 40223   -27.42
          Longitude Elevation State
Hobart       147.33        51   TAS
Melbourne    144.97        31   VIC
Sydney       151.17         6   NSW
Brisbane     153.11         4   QLD
> 
> ## A function to plot maps (a Lattice version of maps::map)
> lmap <-
+    function(database = "world", regions = ".", exact = FALSE,
+             boundary = TRUE, interior = TRUE, projection = "",
+             parameters = NULL, orientation = NULL,
+             aspect = "iso", type = "l",
+             par.settings = list(axis.line = list(col = "transparent")),
+             xlab = NULL, ylab = NULL, ...)
+ {
+    theMap <- map(database, regions, exact = exact,
+                  boundary = boundary, interior = interior,
+                  projection = projection, parameters = parameters,
+                  orientation = orientation, plot = FALSE)
+    xyplot(y ~ x, theMap, type = type, aspect = aspect,
+           par.settings = par.settings, xlab = xlab, ylab = ylab,
+           default.scales = list(draw = FALSE), ...)
+ }
> 
> ## Plot the sites on a map of Australia
> if (require("maps")) {
+   lmap(regions = c("Australia", "Australia:Tasmania"),
+        exact = TRUE, projection = "rectangular",
+        parameters = 150, xlim = c(130, 170),
+        panel = function(...) {
+           panel.xyplot(...)
+           with(EastAuClimate, {
+             panel.points(Longitude, Latitude, pch = 16)
+             txt <- row.names(EastAuClimate)
+             i <- c(3, 4)
+             panel.text(Longitude[ i], Latitude[ i], txt[ i], pos = 2)
+             panel.text(Longitude[-i], Latitude[-i], txt[-i], pos = 4)
+           })
+        })
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> ## Average daily maximum temperature in July (Winter).
> xyplot(WinterMaxTemp ~ Latitude, EastAuClimate, aspect = "xy",
+        type = c("p", "a"), ylab = "Temperature (degrees C)")
> 
> ## (Make a factor with levels in order - by coastal location)
> siteNames <- factor(row.names(EastAuClimate),
+            levels = row.names(EastAuClimate))
> ## Plot temperature ranges (as bars), color-coded by RainDays
> segplot(siteNames ~ WinterMinTemp + SummerMaxTemp, EastAuClimate,
+         level = RainDays, sub = "Color scale: number of rainy days per year",
+         xlab = "Temperature (degrees C)",
+         main = paste("Typical temperature range and wetness",
+            "of coastal Australian cities", sep = "\n"))
> 
> ## Show Winter and Summer temperature ranges separately
> segplot(Latitude ~ WinterMinTemp + SummerMaxTemp, EastAuClimate,
+    main = "Average daily temperature ranges \n of coastal Australian sites",
+    ylab = "Latitude", xlab = "Temperature (degrees C)",
+    par.settings = simpleTheme(lwd = 3, alpha = 0.5),
+    key = list(text = list(c("July (Winter)", "February (Summer)")),
+               lines = list(col = c("blue", "red"))),
+    panel = function(x, y, z, ..., col) {
+       with(EastAuClimate, {
+          panel.segplot(WinterMinTemp, WinterMaxTemp, z, ..., col = "blue")
+          panel.segplot(SummerMinTemp, SummerMaxTemp, z, ..., col = "red")
+       })
+    })
> 
> ## Northern sites have Summer-dominated rainfall;
> ## Southern sites have Winter-dominated rainfall.
> xyplot(SummerRain + WinterRain ~ Latitude, EastAuClimate,
+        type = c("p", "a"), auto.key = list(lines = TRUE),
+        ylab = "Rainfall (mm / month)")
> 
> ## Clear days are most frequent in the mid latitudes.
> xyplot(RainDays + CloudyDays + ClearDays ~ Latitude, EastAuClimate,
+        type = c("p", "a"), auto.key = list(lines = TRUE),
+        ylab = "Days per year")
> 
> 
> 
> cleanEx()
> nameEx("USAge")
> ### * USAge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: USAge
> ### Title: US national population estimates
> ### Aliases: USAge USAge.table USAge.df
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(USAge.df)
> head(USAge.df)
  Age  Sex Year Population
1   0 Male 1900      0.919
2   1 Male 1900      0.928
3   2 Male 1900      0.932
4   3 Male 1900      0.932
5   4 Male 1900      0.928
6   5 Male 1900      0.921
> 
> ## Figure 10.7 from Sarkar (2008)
> xyplot(Population ~ Age | factor(Year), USAge.df,
+        groups = Sex, type = c("l", "g"),
+        auto.key = list(points = FALSE, lines = TRUE, columns = 2),
+        aspect = "xy", ylab = "Population (millions)",
+        subset = Year %in% seq(1905, 1975, by = 10))
> 
> 
> 
> cleanEx()
> nameEx("USCancerRates")
> ### * USCancerRates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: USCancerRates
> ### Title: Rate of Death Due to Cancer in US Counties
> ### Aliases: USCancerRates
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(USCancerRates)
> 
> 
> 
> cleanEx()
> nameEx("as.layer")
> ### * as.layer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.layer
> ### Title: Overlay panels of Trellis plots on same or different scales
> ### Aliases: as.layer as.layer.layer as.layer.trellis
> ### Keywords: aplot
> 
> ### ** Examples
> 
> b1 <- barley
> b2 <- barley
> b2$yield <- b2$yield + 10
> 
> ## panels are matched up by packet number
> dotplot(variety ~ yield | site * year, b1) +
+   as.layer(dotplot(variety ~ yield | site * year, b2, col = "red"))
> 
> ## which gives the same result as:
> dotplot(variety ~ yield | site * year, data = b1, subscripts = TRUE) +
+   layer(panel.dotplot(yield[subscripts], variety[subscripts], col = "red"),
+         data = b2)
> 
> 
> ## example with all same scales (the default):
> xyplot(fdeaths ~ mdeaths) +
+   as.layer(xyplot(fdeaths ~ mdeaths, col = 2, subset = ldeaths > 2000))
> 
> ## same x scales, different y scales:
> xyplot(fdeaths ~ mdeaths) +
+   as.layer(bwplot(~ mdeaths, box.ratio = 0.2), y.same = FALSE)
> 
> ## same y scales, different x scales:
> xyplot(fdeaths ~ mdeaths) +
+   as.layer(bwplot(fdeaths ~ factor(mdeaths*0), box.ratio = 0.2), x.same = FALSE)
> 
> ## as.layer() is called automatically if two plots are added:
> histogram(~ ldeaths, type = "density") + densityplot(~ ldeaths, lwd = 3)
> 
> ## applying one panel layer to several panels of another object
> xyplot(Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width | Species,
+        data = iris, scales = "free") +
+    as.layer(levelplot(volcano), x.same = FALSE, y.same = FALSE, under = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("biocAccess")
> ### * biocAccess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: biocAccess
> ### Title: Hourly access attempts to Bioconductor website
> ### Aliases: biocAccess
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(biocAccess)
> xyplot(stl(ts(biocAccess$counts[1:(24 * 30)], frequency = 24), "periodic"))
> 
> 
> 
> cleanEx()
> nameEx("c.trellis")
> ### * c.trellis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c.trellis
> ### Title: Merge trellis objects, using same or different scales
> ### Aliases: c.trellis xyplot.list mergedTrellisLegendGrob
> ### Keywords: aplot
> 
> ### ** Examples
> 
> 
> ## Combine different types of plots.
> c(wireframe(volcano), contourplot(volcano))
> 
> ## Merging levelplot with xyplot
> levObj <- levelplot(prop.table(WorldPhones, 1) * 100)
> xyObj <- xyplot(Phones ~ Year, data.frame(Phones = rowSums(WorldPhones),
+       Year = row.names(WorldPhones)), type="b", ylim = c(0, 150000))
> ## NOTE: prepanel.levelplot (from first object) is used for entire plot.
> cObj <- c(levObj, xyObj, layout = 1:2)
> update(cObj, scales = list(y = list(rot = 0)),
+        ylab = c("proportional distribution", "number of phones"))
> 
> ## Combine two xyplots.
> sepals <- xyplot(Sepal.Length ~ Sepal.Width, iris, groups = Species,
+     xlab = "Width", ylab = "Height")
> petals <- xyplot(Petal.Length ~ Petal.Width, iris, groups = Species)
> c(Sepals = sepals, Petals = petals)
> 
> ## Force same scales (re-calculate panel limits from merged data):
> c(Sepals = sepals, Petals = petals, x.same = TRUE, y.same = TRUE)
> 
> ## Or - create xyplots from a list of formulas
> xyplot.list(list(Sepals = Sepal.Length ~ Sepal.Width,
+                  Petals = Petal.Length ~ Petal.Width),
+              data = iris, groups = Species, x.same = TRUE,
+              xlab = "Width", ylab = "Height")
> 
> ## Create histograms from a list of objects, and merge them.
> xyplot.list(iris, FUN = histogram)
> 
> ## Create cumulative distribution plots from a list of objects
> xyplot.list(iris[1:4], FUN = qqmath, groups = iris$Species,
+             auto.key = TRUE)
> 
> ## Display a table as both frequencies and proportions:
> data(postdoc)
> ## remove last row (containing totals)
> postdoc <- postdoc[1:(nrow(postdoc)-1),]
> pdprops <- barchart(prop.table(postdoc, margin = 1),
+                     auto.key = list(adj = 1))
> pdmargin <- barchart(margin.table(postdoc, 1))
> pdboth <- c(pdprops, pdmargin)
> update(pdboth, xlab = c("Proportion", "Freq"))
> 
> ## Conditioned 'quakes' plot combined with histogram.
> qua <- xyplot(lat ~ long | equal.count(depth, 3), quakes,
+     aspect = "iso", pch = ".", cex = 2, xlab = NULL, ylab = NULL)
> qua <- c(qua, depth = histogram(quakes$depth), layout = c(4, 1))
> ## suppress scales on the first 3 panels
> update(qua, scales = list(at = list(NULL, NULL, NULL, NA),
+                           y = list(draw = FALSE)))
> 
> ## Demonstrate merging of legends and par.settings.
> ## Note that par.settings can conflict, thus need col.line=...
> mypoints <- 
+     xyplot(1:10 ~ 1:10, groups = factor(rep(1:2, each = 5)),
+         par.settings = simpleTheme(pch = 16), auto.key = TRUE)
> mylines <-
+     xyplot(1:10 ~ 1:10, groups = factor(rep(1:5, each = 2)),
+         type = "l", par.settings = simpleTheme(col.line = 1:5),
+         auto.key = list(lines = TRUE, points = FALSE, columns = 5))
> c(mypoints, mylines)
> 
> ## Visualise statistical and spatial distributions
> ## (advanced!). Requires the 'maps' package to be installed
> 
> if (require(maps)) {
+     vars <- as.data.frame(state.x77)
+     StateName <- tolower(state.name)
+     form <- StateName ~ Population + Income + Illiteracy +
+         `Life Exp` + Murder + `HS Grad` + Frost + sqrt(Area)
+     ## construct independent maps of each variable
+     statemap <- map("state", plot = FALSE, fill = TRUE)
+     colkey <- draw.colorkey(list(col = heat.colors(100), at = 0:100,
+                                  labels = list(labels = c("min","max"), at = c(0,100))))
+     panel.mapplot.each <- function(x, breaks, ...)
+         panel.mapplot(x = x, breaks = quantile(x), ...)
+     vmaps <- mapplot(form, vars, map = statemap, colramp = heat.colors,
+                      panel = panel.mapplot.each, colorkey = FALSE,
+                      legend = list(right = list(fun = colkey)), xlab = NULL)
+     ## construct independent densityplots of each variable
+     vdens <- densityplot(form[-2], vars, outer = TRUE, cut = 0, 
+                          scales = list(relation = "free"), ylim = c(0, NA),
+                          cex = 0.5, ref = TRUE) +
+         layer(panel.axis("top", half = FALSE, text.cex = 0.7))
+     ## combine panels from both plots
+     combo <- c(vmaps, vdens)
+     ## rearrange in pairs
+     n <- length(vars)
+     npairs <- rep(1:n, each = 2) + c(0, n)
+     update(combo[npairs], scales = list(draw = FALSE),
+            layout = c(4, 4), between = list(x = c(0, 0.5), y = 0.5))
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> 
> 
> cleanEx()
> nameEx("combineLimits")
> ### * combineLimits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combineLimits
> ### Title: Combine axis limits across margins
> ### Aliases: combineLimits
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> data(Cars93, package = "MASS")
> 
> ## FIXME: log scales don't yet work
> 
> pcars <- 
+     xyplot(Price ~ EngineSize | reorder(AirBags, Price) + Cylinders,
+            data = Cars93, 
+            subset = Cylinders != "rotary" & Cylinders != "5", 
+            scales = list(relation = "free",
+                          y = list(log = FALSE, tick.number = 3, rot = 0)),
+            xlab = "Engine Size (litres)", 
+            ylab = "Average Price (1000 USD)",
+            as.table = TRUE) 
> 
> combineLimits(pcars)
> 
> useOuterStrips(combineLimits(update(pcars, grid = TRUE),
+                              margin.x = c(1, 2), adjust.labels = FALSE))
> 
> useOuterStrips(combineLimits(update(pcars, grid = TRUE)))
> 
> 
> 
> 
> cleanEx()
> nameEx("custom.theme")
> ### * custom.theme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: custom.theme
> ### Title: Create a lattice theme based on specified colors
> ### Aliases: custom.theme custom.theme.2
> ### Keywords: dplot
> 
> ### ** Examples
> 
> set.seed(0)
> 
> ## create a plot to demonstrate graphical settings
> obj <-
+ xyplot(Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width, iris,
+        type = c("p", "r"), jitter.x = TRUE, jitter.y = TRUE, factor = 5,
+        auto.key = list(lines = TRUE, rectangles = TRUE))
> obj <- update(obj, legend = list(right =
+          list(fun = "draw.colorkey", args = list(list(at = 0:100)))))
> 
> ## draw with default theme
> obj
> 
> ## draw with custom.theme()
> update(obj, par.settings = custom.theme())
> 
> ## create a theme with paired colours, filled points, etc
> update(obj, par.settings =
+   custom.theme(symbol = RColorBrewer::brewer.pal(12, "Paired"),
+                fill = RColorBrewer::brewer.pal(12, "Paired"),
+                region = RColorBrewer::brewer.pal(9, "Blues"),
+                bg = "grey90", fg = "grey20", pch = 16))
> 
> ## draw with custom.theme.2()
> update(obj, par.settings = custom.theme.2())
> 
> 
> 
> cleanEx()
> nameEx("dendrogramGrob")
> ### * dendrogramGrob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dendrogramGrob
> ### Title: Create a Grob Representing a Dendrogram
> ### Aliases: dendrogramGrob
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> data(mtcars)
> x  <- t(as.matrix(scale(mtcars)))
> dd.row <- as.dendrogram(hclust(dist(x)))
> row.ord <- order.dendrogram(dd.row)
> 
> dd.col <- as.dendrogram(hclust(dist(t(x))))
> col.ord <- order.dendrogram(dd.col)
> 
> library(lattice)
> 
> levelplot(x[row.ord, col.ord],
+           aspect = "fill",
+           scales = list(x = list(rot = 90)),
+           colorkey = list(space = "left"),
+           legend =
+           list(right =
+                list(fun = dendrogramGrob,
+                     args =
+                     list(x = dd.col, ord = col.ord,
+                          side = "right",
+                          size = 10)),
+                top =
+                list(fun = dendrogramGrob,
+                     args =
+                     list(x = dd.row, 
+                          side = "top",
+                          type = "triangle"))))
> 
> 
> ## Version with unsorted rows.
> 
> ## For illustration, MPG ploted again at foot of dendrogram
> 
> mpg <- x["mpg", col.ord]
> mpg.col <- level.colors(mpg, at = do.breaks(range(mpg), 10),
+                         col.regions = terrain.colors)
> 
> levelplot(x[, col.ord],
+           aspect = "iso",
+           scales = list(x = list(rot = 90)),
+           colorkey = FALSE,
+           legend =
+           list(right =
+                list(fun = dendrogramGrob,
+                     args =
+                     list(x = dd.col, ord = col.ord,
+                          side = "right",
+                          add = list(rect = list(fill = mpg.col)),
+                          size = 10)),
+                top =
+                list(fun = dendrogramGrob,
+                     args =
+                     list(x = dd.row, ord = sort(row.ord),
+                          side = "top", size = 10,
+                          type = "triangle"))))
> 
> 
> 
> 
> cleanEx()
> nameEx("doubleYScale")
> ### * doubleYScale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: doubleYScale
> ### Title: Draw two plot series with different y scales
> ### Aliases: doubleYScale
> ### Keywords: aplot
> 
> ### ** Examples
> 
> set.seed(1)
> foo <- list(x = 1:100, y = cumsum(rnorm(100)))
> ## show original data
> xyplot(y + y^2 ~ x, foo, type = "l")
> ## construct separate plots for each series
> obj1 <- xyplot(y ~ x, foo, type = "l")
> obj2 <- xyplot(y^2 ~ x, foo, type = "l")
> ## simple case: no axis for the overlaid plot
> doubleYScale(obj1, obj2, add.axis = FALSE)
> ## draw second y axis
> doubleYScale(obj1, obj2)
> ## ...with second ylab
> doubleYScale(obj1, obj2, add.ylab2 = TRUE)
> ## ...or with a key
> doubleYScale(obj1, obj2, text = c("obj1", "obj2"))
> ## ...with custom styles
> update(doubleYScale(obj1, obj2, text = c("obj1", "obj2")),
+   par.settings = simpleTheme(col = c('red','black'), lty = 1:2))
> 
> ## different plot types
> x <- rnorm(60)
> doubleYScale(histogram(x), densityplot(x), use.style = FALSE)
> ## (but see ?as.layer for a better way to do this)
> 
> ## multi-panel example
> ## a variant of Figure 5.13 from Sarkar (2008)
> ## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_13
> data(SeatacWeather)
> temp <- xyplot(min.temp + max.temp ~ day | month,
+                data = SeatacWeather, type = "l", layout = c(3, 1))
> rain <- xyplot(precip ~ day | month, data = SeatacWeather, type = "h")
> 
> doubleYScale(temp, rain, style1 = 0, style2 = 3, add.ylab2 = TRUE,
+    text = c("min. T", "max. T", "rain"), columns = 3)
> 
> ## re-plot with different styles
> update(trellis.last.object(),
+    par.settings = simpleTheme(col = c("black", "red", "blue")))
> 
> 
> 
> cleanEx()
> nameEx("ecdfplot")
> ### * ecdfplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ecdfplot
> ### Title: Trellis Displays of Empirical CDF
> ### Aliases: ecdfplot ecdfplot.formula ecdfplot.numeric panel.ecdfplot
> ###   prepanel.ecdfplot
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> data(singer, package = "lattice")
> ecdfplot(~height | voice.part, data = singer)
> 
> 
> 
> 
> cleanEx()
> nameEx("ggplot2like.theme")
> ### * ggplot2like.theme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ggplot2like.theme
> ### Title: A ggplot2-like theme for Lattice
> ### Aliases: ggplot2like.theme ggplot2like.opts ggplot2like axis.grid
> ### Keywords: dplot
> 
> ### ** Examples
> 
> set.seed(0)
> 
> ## basic theme does not include white grid lines
> xyplot(exp(1:10) ~ 1:10, type = "b", 
+     par.settings = ggplot2like())
> 
> ## add lines for axis ticks with custom axis function
> xyplot(exp(1:10) ~ 1:10, type = "b", 
+     par.settings = ggplot2like(), axis = axis.grid)
>     
> ## this can be used together with scale.components
> ## (minor lines only visible on devices supporting translucency)
> xyplot(exp(rnorm(500)) ~ rnorm(500),
+     scales = list(y = list(log = TRUE)),
+     yscale.components = yscale.components.log10ticks,
+     par.settings = ggplot2like(), axis = axis.grid)
> 
> ## ggplotlike.opts() specifies axis = axis.grid as well as
> ## xscale.components.subticks / yscale.components.subticks
> 
> xyg <- make.groups(
+     "group one" = rnorm(80, 1),
+     "group two" = rnorm(80, 5),
+     "group three" = rnorm(80, 2))
> xyg$x <- rev(xyg$data)
> 
> ## group styles: specify number of equi-spaced hues
> xyplot(data ~ x, xyg, groups = which, auto.key = TRUE, 
+     par.settings = ggplot2like(n = 3),
+     lattice.options = ggplot2like.opts()) +
+   glayer(panel.smoother(...))
> 
> ## or set it as the default:
> opar <- trellis.par.get()
> trellis.par.set(ggplot2like(n = 4, h.start = 180))
> oopt <- lattice.options(ggplot2like.opts())
> 
> bwplot(voice.part ~ height, data = singer)
> 
> histogram(rnorm(100))
> 
> barchart(Titanic[,,,"No"], main = "Titanic deaths",
+     layout = c(1, 2), auto.key = list(columns = 2))
> 
> ## reset
> trellis.par.set(opar)
> lattice.options(oopt)
> 
> ## axis.grid and scale.components.subticks can be used alone:
> ## (again, lines for minor ticks need transculency-support to show up)
> xyplot(exp(1:10) ~ 1:10, type = "b", 
+     lattice.options = ggplot2like.opts(),
+     par.settings = list(axis.line = list(col = NA),
+         reference.line = list(col = "grey")),
+     scales = list(tck = c(0,0)))
> 
> 
> 
> cleanEx()
> nameEx("gvhd10")
> ### * gvhd10
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gvhd10
> ### Title: Flow cytometry data from five samples from a patient
> ### Aliases: gvhd10
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Figure 3.4 from Sarkar (2008)
> data(gvhd10)
> histogram(~log2(FSC.H) | Days, gvhd10, xlab = "log Forward Scatter",
+           type = "density", nint = 50, layout = c(2, 4))
> 
> 
> 
> cleanEx()
> nameEx("horizonplot")
> ### * horizonplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: horizonplot
> ### Title: Plot many time series in parallel
> ### Aliases: horizonplot horizonplot.default panel.horizonplot
> ###   prepanel.horizonplot
> ### Keywords: hplot ts
> 
> ### ** Examples
> 
> ## generate a random time series object with 12 columns
> set.seed(1)
> dat <- ts(matrix(cumsum(rnorm(200 * 12)), ncol = 12))
> colnames(dat) <- paste("series", LETTERS[1:12])
> 
> ## show simple line plot first, for reference.
> xyplot(dat, scales = list(y = "same"))
> 
> ## these layers show scale and origin in each panel...
> infolayers <-
+   layer(panel.scaleArrow(x = 0.99, digits = 1, col = "grey",
+                          srt = 90, cex = 0.7)) +
+   layer(lim <- current.panel.limits(),
+     panel.text(lim$x[1], lim$y[1], round(lim$y[1],1), font = 2,
+         cex = 0.7, adj = c(-0.5,-0.5), col = "#9FC8DC"))
> 
> ## Case 1: each panel has a different origin and scale:
> ## ('origin' default is the first data value in each series).
> horizonplot(dat, layout = c(1,12), colorkey = TRUE) +
+   infolayers
>  
> ## Case 2: fixed scale but different origin (baseline):
> ## (similar in concept to scales = "sliced")
> horizonplot(dat, layout = c(1,12), horizonscale = 10, colorkey = TRUE) +
+   infolayers
> 
> ## Case 3: fixed scale and constant origin (all same scales):
> horizonplot(dat, layout = c(1,12), origin = 0, horizonscale = 10, colorkey = TRUE) +
+   infolayers
> 
> ## same effect using ylim (but colorkey does not know limits):
> horizonplot(dat, layout = c(1,12), ylim = c(0, 10), colorkey = TRUE) +
+   infolayers
> 
> ## same scales with full coverage of color scale:
> horizonplot(dat, layout = c(1,12), origin = 0,
+             scales = list(y = list(relation = "same")),
+             colorkey = TRUE, colorkey.digits = 1) +
+   infolayers
> 
> 
> ## use ylab rather than strip.left, for readability.
> ## also shade any times with missing data values.
> horizonplot(dat, horizonscale = 10, colorkey = TRUE,
+             layout = c(1,12), strip.left = FALSE,
+             ylab = list(rev(colnames(dat)), rot = 0, cex = 0.7)) +
+   layer_(panel.fill(col = "gray90"), panel.xblocks(..., col = "white"))
> 
> 
> ## illustration of the cut points used in the following plot
> xyplot(EuStockMarkets, scales = list(y = "same"),
+   panel = function(x, y, ...) {
+     col <-
+     c("#B41414","#E03231","#F7A99C","#9FC8DC","#468CC8","#0165B3")
+     for (i in c(-3:-1, 2:0)) {
+       if (i >= 0)
+         yi <- pmax(4000, pmin(y, 4000 + 1000 * (i+1)))
+       if (i < 0)
+         yi <- pmin(4000, pmax(y, 4000 + 1000 * i))
+       panel.xyarea(x, yi, origin = 4000,
+         col = col[i+4], border = NA)
+     }
+     panel.lines(x, y)
+     panel.abline(h = 4000, lty = 2)
+   })
> 
> ## compare with previous plot
> horizonplot(EuStockMarkets, colorkey = TRUE,
+             origin = 4000, horizonscale = 1000) +
+   infolayers
> 
> ## a cut-and-stack plot; use constant y scales!
> horizonplot(sunspots, cut = list(n = 23, overlap = 0),
+   scales = list(draw = FALSE, y = list(relation = "same")),
+   origin = 100, colorkey = TRUE,
+   strip.left = FALSE, layout = c(1,23)) +
+ layer(grid::grid.text(round(x[1]), x = 0, just = "left"))
> 
> 
> 
> cleanEx()
> nameEx("layer")
> ### * layer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: layer
> ### Title: Add layers to a lattice plot, optionally using a new data source
> ### Aliases: layer layer_ glayer glayer_ +.trellis drawLayer flattenPanel
> ###   [.layer print.layer
> ### Keywords: aplot
> 
> ### ** Examples
> 
> foo <- xyplot(ozone ~ wind, environmental)
> foo
> 
> ## overlay reference lines
> foo <- foo + layer(panel.abline(h = 0)) +
+              layer(panel.lmline(x, y, lty = 2))
> 
> ## underlay a flat color
> foo <- foo + layer(panel.fill(grey(.95)), under = TRUE)
> foo
> 
> ## layers can access the panel function arguments
> foo <- foo + layer({ ok <- (y>100);
+             panel.text(x[ok], y[ok], y[ok], pos = 1) })
> foo
> 
> ## over-ride arguments by name
> foo <- foo +
+   layer(panel.xyplot(y = ave(y, x, FUN = max), type = "a", ...))
> foo
> 
> ## see a sketch of the complete panel function
> flattenPanel(foo)
{
    panel.fill(grey(0.95))
    panel.xyplot(...)
    panel.abline(h = 0)
    panel.lmline(x, y, lty = 2)
    {
        ok <- (y > 100)
        panel.text(x[ok], y[ok], y[ok], pos = 1)
    }
    do.call(panel.xyplot, modifyList(list(...), list(y = ave(y, 
        x, FUN = max), type = "a")))
}
> 
> 
> ## group layers, drawn for each group in each panel
> dotplot(VADeaths, type = "o") +
+   glayer(ltext(x[5], y[5], group.value, srt = 40))
> 
> ## a quick way to print out the panel.groups arguments:
> dotplot(VADeaths, type = "o") + glayer(str(list(...)))
List of 21
 $ x           : num [1:5] 11.7 18.1 26.9 41 66
 $ subscripts  : int [1:5] 1 2 3 4 5
 $ pch         : num 1
 $ cex         : num 0.8
 $ font        : num 1
 $ fontface    : NULL
 $ fontfamily  : NULL
 $ col         : chr "black"
 $ col.line    : chr "#0072B2"
 $ col.symbol  : chr "#0072B2"
 $ fill        : chr "#CCFFFF"
 $ lty         : num 1
 $ lwd         : num 1
 $ alpha       : num 1
 $ type        : chr "o"
 $ group.number: int 1
 $ group.value : chr "Rural Male"
 $ grid        : logi FALSE
 $ box.ratio   : num 1
 $ horizontal  : logi TRUE
 $ y           : num [1:5] 1 2 3 4 5
List of 21
 $ x           : num [1:5] 8.7 11.7 20.3 30.9 54.3
 $ subscripts  : int [1:5] 6 7 8 9 10
 $ pch         : num 1
 $ cex         : num 0.8
 $ font        : num 1
 $ fontface    : NULL
 $ fontfamily  : NULL
 $ col         : chr "black"
 $ col.line    : chr "#E69F00"
 $ col.symbol  : chr "#E69F00"
 $ fill        : chr "#FFCCFF"
 $ lty         : num 1
 $ lwd         : num 1
 $ alpha       : num 1
 $ type        : chr "o"
 $ group.number: int 2
 $ group.value : chr "Rural Female"
 $ grid        : logi FALSE
 $ box.ratio   : num 1
 $ horizontal  : logi TRUE
 $ y           : num [1:5] 1 2 3 4 5
List of 21
 $ x           : num [1:5] 15.4 24.3 37 54.6 71.1
 $ subscripts  : int [1:5] 11 12 13 14 15
 $ pch         : num 1
 $ cex         : num 0.8
 $ font        : num 1
 $ fontface    : NULL
 $ fontfamily  : NULL
 $ col         : chr "black"
 $ col.line    : chr "#009E73"
 $ col.symbol  : chr "#009E73"
 $ fill        : chr "#CCFFCC"
 $ lty         : num 1
 $ lwd         : num 1
 $ alpha       : num 1
 $ type        : chr "o"
 $ group.number: int 3
 $ group.value : chr "Urban Male"
 $ grid        : logi FALSE
 $ box.ratio   : num 1
 $ horizontal  : logi TRUE
 $ y           : num [1:5] 1 2 3 4 5
List of 21
 $ x           : num [1:5] 8.4 13.6 19.3 35.1 50
 $ subscripts  : int [1:5] 16 17 18 19 20
 $ pch         : num 1
 $ cex         : num 0.8
 $ font        : num 1
 $ fontface    : NULL
 $ fontfamily  : NULL
 $ col         : chr "black"
 $ col.line    : chr "#D55E00"
 $ col.symbol  : chr "#D55E00"
 $ fill        : chr "#FFE5CC"
 $ lty         : num 1
 $ lwd         : num 1
 $ alpha       : num 1
 $ type        : chr "o"
 $ group.number: int 4
 $ group.value : chr "Urban Female"
 $ grid        : logi FALSE
 $ box.ratio   : num 1
 $ horizontal  : logi TRUE
 $ y           : num [1:5] 1 2 3 4 5
> 
> 
> ## layers with superposed styles
> xyplot(ozone ~ wind | equal.count(temperature, 2),
+        data = environmental) +
+    layer(panel.loess(x, y, span = 0.5), style = 1) +
+    layer(panel.loess(x, y, span = 1.0), style = 2) +
+    layer(panel.key(c("span = 0.5", "span = 1.0"), corner = c(1,.98),
+                    lines = TRUE, points = FALSE), packets = 1)
> 
> ## note that styles come from the settings in effect in the plot,
> ## which is not always what you want:
> xyplot(1:10 ~ 1:10, type = "b", par.settings = simpleTheme(col = "red")) +
+   layer(panel.lines(x = jitter(x, 2), ...)) +  ## drawn in red
+   layer(panel.lines(x = jitter(x, 2), ...), force = TRUE)  ## reset theme
> 
> 
> ## using other variables from the original `data` object
> ## NOTE: need subscripts = TRUE in original call!
> zoip <- xyplot(wind ~ temperature | equal.count(radiation, 2),
+    data = environmental, subscripts = TRUE)
> zoip + layer(panel.points(..., pch = 19,
+              col = grey(1 - ozone[subscripts] / max(ozone))),
+        data = environmental)
> 
> 
> ## restrict drawing to specified panels
> barchart(yield ~ variety | site, data = barley,
+          groups = year, layout = c(1,6), as.table = TRUE,
+          scales = list(x = list(rot = 45))) +
+ layer(ltext(tapply(y, x, max), lab = abbreviate(levels(x)),
+       pos = 3), rows = 1)
> 
> 
> ## example of a new data source
> qua <- xyplot(lat ~ long | cut(depth, 2), quakes,
+     aspect = "iso", pch = ".", cex = 2)
> qua
> ## add layer showing distance from Auckland
> newdat <- with(quakes, expand.grid(
+             gridlat = seq(min(lat), max(lat), length = 60),
+             gridlon = seq(min(long), max(long), length = 60)))
> newdat$dist <- with(newdat, sqrt((gridlat - -36.87)^2 +
+                                  (gridlon - 174.75)^2))
> qua + layer_(panel.contourplot(x = gridlon, y = gridlat, z = dist,
+    contour = TRUE, subscripts = TRUE), data = newdat)
> 
> 
> 
> cleanEx()
> nameEx("mapplot")
> ### * mapplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mapplot
> ### Title: Trellis displays on Maps a.k.a. Choropleth maps
> ### Aliases: mapplot mapplot.formula panel.mapplot prepanel.mapplot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> 
> ## Requires the 'maps' and 'mapproj' packages:
> 
> if (require(maps) && require(mapproj)) {
+ 
+     ## Note: Alaska, Hawaii and others are not included in county map;
+     ## this generates warnings with both USCancerRates and ancestry.
+ 
+     data(USCancerRates)
+ 
+     suppressWarnings(print(
+         mapplot(rownames(USCancerRates) ~ log(rate.male) + log(rate.female),
+                 data = USCancerRates,
+                 map = map("county", plot = FALSE, fill = TRUE,
+                           projection = "mercator"))
+     ))
+ 
+     suppressWarnings(print(
+         mapplot(rownames(USCancerRates) ~ log(rate.male) + log(rate.female),
+                 data = USCancerRates,
+                 map = map("county", plot = FALSE, fill = TRUE,
+                           projection = "tetra"),
+                 scales = list(draw = FALSE))
+     ))
+ 
+     data(ancestry)
+ 
+     county.map <- 
+         map('county', plot = FALSE, fill = TRUE, 
+             projection = "azequalarea")
+ 
+     ## set a sequential color palette as current theme, and use it
+     opar <- trellis.par.get()
+     trellis.par.set(custom.theme(region = rev(hcl.colors(9, "Purp")),
+                                  alpha.line = 0.5))
+     suppressWarnings(print(
+         mapplot(county ~ log10(population), ancestry, map = county.map,
+                 colramp = NULL, border = "transparent")
+     ))
+     trellis.par.set(opar)
+ }
Loading required package: maps
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘maps’
> 
> ## Not run: 
> ##D 
> ##D ## this may take a while (should get better area records)
> ##D 
> ##D if (require(maps) && require(mapproj)) {
> ##D 
> ##D     county.areas <- 
> ##D         area.map(county.map, regions = county.map$names, sqmi = FALSE)
> ##D     
> ##D     ancestry$density <- 
> ##D         with(ancestry, population / county.areas[as.character(county)])
> ##D 
> ##D     mapplot(county ~ log(density), ancestry,
> ##D             map = county.map, border = NA,
> ##D             colramp = colorRampPalette(c("white", "black")))
> ##D 
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("marginal.plot")
> ### * marginal.plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marginal.plot
> ### Title: Display marginal distributions
> ### Aliases: marginal.plot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> enviro <- environmental
> ## make an ordered factor (so it will not be reordered)
> enviro$smell <- cut(enviro$ozone, breaks = c(0, 30, 50, Inf),
+     labels = c("ok", "hmmm", "yuck"), ordered = TRUE)
> marginal.plot(enviro)
> 
> ## using groups
> enviro$is.windy <- factor(enviro$wind > 10,
+     levels = c(TRUE, FALSE), labels = c("windy", "calm"))
> marginal.plot(enviro[,1:5], data = enviro, groups = is.windy,
+     auto.key = list(lines = TRUE))
> 
> ## support for tables
> marginal.plot(Titanic)
> ## table with groups
> marginal.plot(~ Titanic, data = Titanic, groups = Survived,
+     type = "b", auto.key = list(title = "Survived?"))
> 
> 
> 
> cleanEx()
> nameEx("panel.2dsmoother")
> ### * panel.2dsmoother
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.2dsmoother
> ### Title: Plot a smooth approximation of z over x and y.
> ### Aliases: panel.2dsmoother
> ### Keywords: dplot
> 
> ### ** Examples
> 
> set.seed(1)
> xyz <- data.frame(x = rnorm(100), y = rnorm(100))
> xyz$z <- with(xyz, x * y + rnorm(100, sd = 1))
> 
> levelplot(z ~ x * y, xyz, panel = panel.2dsmoother)
> 
> ## showing data points on the same color scale
> levelplot(z ~ x * y, xyz,
+           panel = panel.levelplot.points, cex = 1.2) +
+   layer_(panel.2dsmoother(..., n = 200))
> 
> ## simple linear regression model
> levelplot(z ~ x * y, xyz,
+           panel = panel.levelplot.points) +
+   layer_(panel.2dsmoother(..., method = "lm"))
> 
> ## GAM smoother with smoothness by cross validation
> if (require("mgcv"))
+   levelplot(z ~ x * y, xyz, panel = panel.2dsmoother,
+             form = z ~ s(x, y), method = "gam")
Loading required package: mgcv
Loading required package: nlme
This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:nlme’

> nameEx("panel.3dmisc")
> ### * panel.3dmisc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.3dmisc
> ### Title: Miscellanous panel utilities for three dimensional Trellis
> ###   Displays
> ### Aliases: panel.3dmisc panel.3dtext panel.3dbars panel.3dpolygon
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> library(lattice)
> 
> cloud(VADeaths, panel.3d.cloud = panel.3dbars,
+       col.facet = "grey", xbase = 0.4, ybase = 0.4,
+       screen = list(z = 40, x = -30))
> 
> cloud(VADeaths, panel.3d.cloud = panel.3dbars,
+       xbase = 0.4, ybase = 0.4, zlim = c(0, max(VADeaths)),
+       scales = list(arrows = FALSE, just = "right"), xlab = NULL, ylab = NULL,
+       col.facet = level.colors(VADeaths, at = do.breaks(range(VADeaths), 20),
+                                col.regions = terrain.colors,
+                                colors = TRUE),
+       colorkey = list(col = terrain.colors, at = do.breaks(range(VADeaths), 20)),
+       screen = list(z = 40, x = -30))
> 
> 
> cloud(as.table(prop.table(Titanic, margin = 1:3)[,,,2]),
+       type = c("p", "h"),
+       zlab = "Proportion\nSurvived",
+       panel.3d.cloud = panel.3dbars,
+       xbase = 0.4, ybase = 0.4,
+       aspect = c(1, 0.3),
+       scales = list(distance = 2),
+       panel.aspect = 0.5)
> 
> 
> 
> 
> cleanEx()
> nameEx("panel.ellipse")
> ### * panel.ellipse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.ellipse
> ### Title: Lattice panel function to fit and draw a confidence ellipsoid
> ###   from bivariate data.
> ### Aliases: panel.ellipse
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> xyplot(Sepal.Length ~ Petal.Length, groups=Species,
+        data = iris, scales = "free",
+        par.settings = list(superpose.symbol = list(pch=c(15:17)),
+                            superpose.line = list(lwd=2, lty=1:3)),
+        panel = function(x, y, ...) {
+            panel.xyplot(x, y, ...)
+            panel.ellipse(x, y, ...)
+        },
+        auto.key = list(x = .1, y = .8, corner = c(0, 0)))
> 
> ## Without groups
> xyplot(Sepal.Length ~ Petal.Length, 
+        data = iris, scales = "free",
+        par.settings = list(plot.symbol = list(cex = 1.1, pch=16)),
+        panel = function(x, y, ...) {
+            panel.xyplot(x, y, ...)
+            panel.ellipse(x, y, lwd = 2, ...)
+        },
+        auto.key = list(x = .1, y = .8, corner = c(0, 0)))
> 
> 
> ## With conditioning
> xyplot(Sepal.Length ~ Petal.Length | Species, 
+        data = iris, scales = "free",
+        par.settings = list(plot.symbol = list(cex = 1.1, pch=16)),
+        layout=c(2,2),
+        panel = function(x, y, ...) {
+            panel.xyplot(x, y, ...)
+            panel.ellipse(x, y, lwd = 2, ...)
+        },
+        auto.key = list(x = .6, y = .8, corner = c(0, 0)))
> 
> 
> ## Compare classical with robust 
> xyplot(Sepal.Length ~ Petal.Length | Species, 
+        data = iris, scales = "free",
+        par.settings = list(plot.symbol = list(cex = 1.1, pch=16)),
+        layout=c(2,2),
+        panel = function(x, y, ...) {
+            panel.xyplot(x, y, ...)
+            panel.ellipse(x, y, lwd = 2, ...)
+            panel.ellipse(x, y, lwd = 2, col="red", robust=TRUE,  ...)
+        })
> 
> 
> 
> 
> cleanEx()
> nameEx("panel.key")
> ### * panel.key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.key
> ### Title: Draw a simple key inside a panel of a lattice plot.
> ### Aliases: panel.key
> ### Keywords: aplot
> 
> ### ** Examples
> 
> xyplot(ozone ~ wind | equal.count(temperature, 2),
+        data = environmental) +
+    layer(panel.loess(x, y, span = 0.5), style = 1) +
+    layer(panel.loess(x, y, span = 1.0), style = 2) +
+    layer(panel.key(c("span = 0.5", "span = 1.0"), corner = c(1,.98),
+                    lines = TRUE, points = FALSE), packets = 1)
> 
> 
> 
> cleanEx()
> nameEx("panel.lmlineq")
> ### * panel.lmlineq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.lmlineq
> ### Title: Draw a line with a label, by default its equation
> ### Aliases: panel.lmlineq panel.ablineq
> ### Keywords: aplot
> 
> ### ** Examples
> 
> set.seed(0)
> xsim <- rnorm(50, mean = 3)
> ysim <- (0 + 2 * xsim) * (1 + rnorm(50, sd = 0.3))
> 
> ## basic use as a panel function
> xyplot(ysim ~ xsim, panel = function(x, y, ...) {
+   panel.xyplot(x, y, ...)
+   panel.ablineq(a = 0, b = 2, adj = c(0,1))
+   panel.lmlineq(x, y, adj = c(1,0), lty = 2,
+                 col.line = "grey", digits = 1)
+ })
> 
> ## using layers:
> xyplot(ysim^2 ~ xsim) +
+   layer(panel.ablineq(lm(y ~ x, subset = x <= 3),
+     varNames = alist(y = y^2, x = x[x <= 3]), pos = 4))
> 
> ## rotated equation (depends on device aspect at plotting time)
> xyplot(ysim ~ xsim) +
+   layer(panel.ablineq(lm(y ~ x), rotate = TRUE, at = 0.8))
> 
> ## horizontal and vertical lines
> xyplot(ysim ~ xsim) +
+   layer(panel.ablineq(v = 3, pos = 4, at = 0.1, lty = 2,
+                       label = "3.0 (critical value)")) +
+   layer(panel.ablineq(h = mean(ysim), pos = 3, at = 0.15, lty = 2,
+                       varNames = alist(y = plain(mean)(y))))
> 
> ## using layer styles, r.squared
> xyplot(ysim ~ xsim) +
+   layer(panel.ablineq(lm(y ~ x), r.sq = TRUE,
+                       at = 0.4, adj=0:1), style = 1) +
+   layer(panel.ablineq(lm(y ~ x + 0), r.sq = TRUE,
+                       at = 0.6, adj=0:1), style = 2)
> 
> ## alternative placement of equations
> xyplot(ysim ~ xsim) +
+   layer(panel.ablineq(lm(y ~ x), r.sq = TRUE, rot = TRUE,
+                       at = 0.8, pos = 3), style = 1) +
+   layer(panel.ablineq(lm(y ~ x + 0), r.sq = TRUE, rot = TRUE,
+                       at = 0.8, pos = 1), style = 2)
> 
> update(trellis.last.object(),
+   auto.key = list(text = c("intercept", "no intercept"),
+                   points = FALSE, lines = TRUE))
> 
> 
> 
> cleanEx()
> nameEx("panel.qqmath.tails")
> ### * panel.qqmath.tails
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.qqmath.tails
> ### Title: Approximate distribution in qqmath but keep points on tails.
> ### Aliases: panel.qqmath.tails
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> ## see ?panel.qqmath
> 
> 
> 
> 
> cleanEx()
> nameEx("panel.quantile")
> ### * panel.quantile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.quantile
> ### Title: Plot a quantile regression line with standard error bounds.
> ### Aliases: panel.quantile
> ### Keywords: dplot
> 
> ### ** Examples
> 
> ## library("quantreg")
> 
> set.seed(1)
> xy <- data.frame(x = runif(100), y = rt(100, df = 5))
> xyplot(y ~ x, xy) +
+     layer(panel.quantile(x, y, tau = c(.95, .5, .05)))
> 
> if (require("splines")) {
+     xyplot(y ~ x, xy) +
+         layer(panel.quantile(y ~ ns(x, 3), tau = 0.9))
+ 
+     xyplot(y ~ x, xy) +
+         layer(panel.quantile(y ~ ns(x, 3), tau = 0.9, ci = TRUE))
+ }
Loading required package: splines
> 
> xyplot(y ~ x, xy) +
+     layer(panel.quantile(x, y, tau = c(.5, .9, .1), superpose = TRUE))
> 
> update(trellis.last.object(),
+        auto.key = list(text = paste(c(50,90,10), "% quantile"),
+                   points = FALSE, lines = TRUE))
> 
> xyplot(y ~ x, xy) +
+     layer(panel.quantile(y ~ qss(x, lambda=1), method = "rqss"))
> 
> 
> 
> 
> cleanEx()

detaching ‘package:splines’

> nameEx("panel.scaleArrow")
> ### * panel.scaleArrow
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.scaleArrow
> ### Title: Draw a scale bar as an arrow, labelled with its length in plot
> ###   units.
> ### Aliases: panel.scaleArrow
> ### Keywords: aplot
> 
> ### ** Examples
> 
> xyplot(EuStockMarkets) +
+   layer(panel.scaleArrow(x = 0.99, append = " units",
+           col = "grey", srt = 90, cex = 0.8))
> 
> 
> 
> cleanEx()
> nameEx("panel.smoother")
> ### * panel.smoother
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.smoother
> ### Title: Plot a smoothing line with standard error bounds.
> ### Aliases: panel.smoother
> ### Keywords: dplot
> 
> ### ** Examples
> 
> set.seed(1)
> xy <- data.frame(x = runif(100),
+                  y = rt(100, df = 5),
+                  y2 = rt(100, df = 5) + 1)
> 
> xyplot(y ~ x, xy, panel = function(...) {
+        panel.xyplot(...)
+        panel.smoother(..., span = 0.9)
+ })
> 
> ## per-group layers with glayer (pass `...` to get styles)
> xyplot(y + y2 ~ x, xy) +
+   glayer(panel.smoother(...))
> 
> ## natural spline with 5 degrees of freedom
> if (require("splines"))
+   xyplot(y ~ x, xy) +
+     layer(panel.smoother(y ~ ns(x,5), method = "lm"))
Loading required package: splines
> 
> ## thin plate regression spline with smoothness
> ## chosen by cross validation (see ?mgcv::gam)
> if (require("mgcv"))
+   xyplot(y ~ x, xy) +
+     layer(panel.smoother(y ~ s(x), method = "gam"))
Loading required package: mgcv
Loading required package: nlme
This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> 
> ## simple linear regression with standard errors:
> xyplot(y ~ x, xy) +
+   layer(panel.smoother(x, y, method = "lm"), style = 2)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:nlme’, ‘package:splines’

> nameEx("panel.tskernel")
> ### * panel.tskernel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.tskernel
> ### Title: Calculate and plot smoothed time series.
> ### Aliases: panel.tskernel simpleSmoothTs simpleSmoothTs.default
> ###   simpleSmoothTs.zoo
> ### Keywords: dplot
> 
> ### ** Examples
> 
> ## a Gaussian-like filter (contrast with c = 1 or c = 2)
> xyplot(sunspot.year) +
+ layer(panel.tskernel(x, y, width = 20, c = 3, col = 1, lwd = 2))
> 
> ## example from ?kernel:
> ## long and short moving averages, backwards in time
> xyplot(EuStockMarkets[,1]) +
+   layer(panel.tskernel(x, y, width = 100, col = 1, sides = 1)) +
+   layer(panel.tskernel(x, y, width = 20, col = 2, sides = 1))
> 
> ## per group, with a triangular filter
> xyplot(EuStockMarkets, superpose = TRUE) +
+   glayer(panel.tskernel(..., width = 100, c = 2),
+          theme = simpleTheme(lwd = 2))
> 
> ## plot the actual kernels used; note adjustment of width
> width = 100
> kdat <- lapply(1:4, function(c) {
+     k <- kernel("daniell", rep(floor(0.5*width / sqrt(c)), c))
+     ## demonstrate that the effective bandwidth stays the same:
+     message("c = ", c, ": effective bandwidth = ", bandwidth.kernel(k))
+     ## represent the kernel as a time series, for plotting
+     ts(k[-k$m:k$m], start = -k$m)
+ })
c = 1: effective bandwidth = 29.1561885940761
c = 2: effective bandwidth = 28.9841910933069
c = 3: effective bandwidth = 28.4970758733828
c = 4: effective bandwidth = 29.440618200031
> names(kdat) <- paste("c =", 1:4)
> xyplot(do.call(ts.union, kdat), type = "h",
+     scales = list(y = list(relation = "same")))
> 
> 
> 
> cleanEx()
> nameEx("panel.voronoi")
> ### * panel.voronoi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.voronoi
> ### Title: Panel functions for level-coded irregular points
> ### Aliases: panel.voronoi panel.levelplot.points
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## a variant of Figure 5.6 from Sarkar (2008)
> ## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_06
> 
> depth.ord <- rev(order(quakes$depth))
> quakes$Magnitude <- equal.count(quakes$mag, 4)
> quakes.ordered <- quakes[depth.ord, ]
> 
> levelplot(depth ~ long + lat | Magnitude, data = quakes.ordered,
+          panel = panel.levelplot.points, type = c("p", "g"),
+          aspect = "iso", prepanel = prepanel.default.xyplot)
> 
> ## a levelplot with jittered cells
> 
> xyz <- expand.grid(x = 0:9, y = 0:9)
> xyz[] <- jitter(as.matrix(xyz))
> xyz$z <- with(xyz, sqrt((x - 5)^2 + (y - 5)^2))
> levelplot(z ~ x * y, xyz, panel = panel.voronoi, points = FALSE)
> 
> ## hexagonal cells
> 
> xyz$y <- xyz$y + c(0, 0.5)
> levelplot(z ~ x * y, xyz, panel = panel.voronoi, points = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("panel.xblocks")
> ### * panel.xblocks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.xblocks
> ### Title: Plot contiguous blocks along x axis.
> ### Aliases: panel.xblocks panel.xblocks.default panel.xblocks.ts
> ###   panel.xblocks.zoo
> ### Keywords: dplot
> 
> ### ** Examples
> 
> ## Example of highlighting peaks in a time series.
> set.seed(0)
> flow <- ts(filter(rlnorm(200, mean = 1), 0.8, method = "r"))
> 
> ## using an explicit panel function
> xyplot(flow, panel = function(x, y, ...) {
+   panel.xblocks(x, y > mean(y), col = "lightgray")
+   panel.xyplot(x, y, ...)
+ })
> ## using layers; this is the `ts` method because `>` keeps it as ts.
> xyplot(flow) +
+   layer_(panel.xblocks(flow > mean(flow), col = "lightgray"))
> 
> ## Example of alternating colors, here showing calendar months
> flowdates <- as.Date("2000-01-01") + as.numeric(time(flow))
> xyplot(flow ~ flowdates, type = "l") +
+   layer_(panel.xblocks(x, months,
+          col = c("lightgray", "#e6e6e6"), border = "darkgray"))
> 
> ## highlight values above and below thresholds.
> ## blue, gray, red colors:
> bgr <- hcl(c(0, 0, 260), c = c(100, 0, 100), l = c(90, 90, 90))
> dflow <- cut(flow, c(0,15,30,Inf), labels = bgr)
> xyplot(flow) + layer_(panel.xblocks(time(flow), dflow))
> 
> ## Example of highlighting gaps (NAs) in time series.
> ## set up example data
> z <- ts(cbind(A = 0:5, B = c(6:7, NA, NA, 10:11), C = c(NA, 13:17)))
> 
> ## show data coverage only (highlighting gaps)
> xyplot(z, panel = panel.xblocks,
+        scales = list(y = list(draw = FALSE)))
> 
> ## draw gaps in darkgray
> xyplot(z, type = c("p","s")) +
+   layer_(panel.xblocks(x, is.na(y), col = "darkgray"))
> 
> ## Example of overlaying blocks from a different series.
> ## Are US presidential approval ratings linked to sunspot activity?
> ## Set block height, default justification is along the bottom.
> xyplot(presidents) + layer(panel.xblocks(sunspot.year > 50, height = 2))
> 
> 
> 
> cleanEx()
> nameEx("panel.xyarea")
> ### * panel.xyarea
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.xyarea
> ### Title: Plot series as filled polygons.
> ### Aliases: panel.xyarea panel.xyarea.default panel.xyarea.ts
> ###   panel.xyarea.zoo panel.qqmath.xyarea
> ### Keywords: dplot
> 
> ### ** Examples
> 
> xyplot(sunspot.year, panel = panel.xyarea, origin = 0,
+   aspect = "xy", cut = list(n = 3, overlap = 0))
> 
> ## two series superposed: one filled, one as a line.
> xyplot(ts.union(data = sunspot.year, lag10 = lag(sunspot.year, 10)),
+   aspect = "xy", cut = list(n = 3, overlap = 0),
+   superpose = TRUE,
+   panel = panel.superpose,
+   panel.groups = function(..., group.number) {
+     if (group.number == 1)
+       panel.xyarea(...) else panel.xyplot(...)
+   }, border = NA, 
+   par.settings = simpleTheme(col = c("grey", "black"), lwd = c(5,2)))
> 
> ## missing values are handled by splitting the series
> tmp <- window(sunspot.year, start = 1900)
> tmp[c(1:2, 50:60)] <- NA
> xyplot(tmp, panel = panel.xyarea, origin = 0)
> 
> set.seed(0)
> qqmath(~ data, make.groups(baseline = rnorm(100),
+                            other = rnorm(100) * 2 - 0.5),
+   groups = which, distribution = qunif,
+   panel = panel.qqmath.xyarea, xlim = 0:1,
+   auto.key = list(points = FALSE, rectangles = TRUE),
+   par.settings = simpleTheme(col = c("blue", "green"),
+                              alpha = 0.5))
> 
> 
> 
> cleanEx()
> nameEx("panel.xyimage")
> ### * panel.xyimage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: panel.xyimage
> ### Title: Scatter plots using emoji-like images
> ### Aliases: panel.xyimage
> ### Keywords: dplot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D alive <- "https://twemoji.maxcdn.com/72x72/1f60a.png"
> ##D dead <- "https://twemoji.maxcdn.com/72x72/1f480.png"
> ##D 
> ##D dotplot(Titanic,
> ##D         scales = list(x = "free"),
> ##D         between = list(x = 1),
> ##D         panel = panel.xyimage,
> ##D         pch = c(dead, alive), grid = "h", 
> ##D         main = "Survival on the Titanic",
> ##D         xlab = "Number of persons")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("postdoc")
> ### * postdoc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: postdoc
> ### Title: Reasons for Taking First Postdoctoral Appointment
> ### Aliases: postdoc
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(postdoc)
> library(lattice)
> barchart(prop.table(postdoc, margin = 1),
+          auto.key = TRUE, xlab = "Proportion")
> 
> 
> 
> cleanEx()
> nameEx("resizePanels")
> ### * resizePanels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: resizePanels
> ### Title: Resize panels to match data scales
> ### Aliases: resizePanels
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> state <- data.frame(state.x77, state.region, state.name)
> state$state.name <-
+     with(state, reorder(reorder(state.name, Frost),
+                         as.numeric(state.region)))
> dpfrost <-
+     dotplot(state.name ~ Frost | reorder(state.region, Frost),
+             data = state, layout = c(1, 4),
+             scales = list(y = list(relation = "free")))
> 
> ## approximate
> resizePanels(dpfrost,
+              h = with(state, table(reorder(state.region, Frost))))
> 
> ## exact (including boundary padding)
> resizePanels()
> 
> 
> 
> 
> cleanEx()
> nameEx("rootogram")
> ### * rootogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rootogram
> ### Title: Trellis Displays of Tukey's Hanging Rootograms
> ### Aliases: rootogram rootogram.formula panel.rootogram prepanel.rootogram
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> library(lattice)
> 
> x <- rpois(1000, lambda = 50)
> 
> p <- rootogram(~x, dfun = function(x) dpois(x, lambda = 50))
> p
> 
> lambdav <- c(30, 40, 50, 60, 70)
> 
> update(p[rep(1, length(lambdav))],
+        aspect = "xy",
+        panel = function(x, ...) {
+            panel.rootogram(x,
+                            dfun = function(x)
+                            dpois(x, lambda = lambdav[panel.number()]))
+        })
> 
> 
> lambdav <- c(46, 48, 50, 52, 54)
> 
> update(p[rep(1, length(lambdav))],
+        aspect = "xy",
+        prepanel = function(x, ...) {
+            tmp <-
+                lapply(lambdav,
+                       function(lambda) {
+                           prepanel.rootogram(x,
+                                              dfun = function(x)
+                                              dpois(x, lambda = lambda))
+                       })
+            list(xlim = range(sapply(tmp, "[[", "xlim")),
+                 ylim = range(sapply(tmp, "[[", "ylim")),
+                 dx = do.call("c", lapply(tmp, "[[", "dx")),
+                 dy = do.call("c", lapply(tmp, "[[", "dy")))
+        },
+        panel = function(x, ...) {
+            panel.rootogram(x,
+                            dfun = function(x)
+                            dpois(x, lambda = lambdav[panel.number()]))
+            grid::grid.text(bquote(Poisson(lambda == .(foo)),
+                                   where = list(foo = lambdav[panel.number()])),
+                            y = 0.15,
+                            gp = grid::gpar(cex = 1.5))
+        },
+        xlab = "",
+        sub = "Random sample from Poisson(50)")
> 
> 
> ## Example using continuous data
> 
> xnorm <- rnorm(1000)
> 
> ## 'discretize' by binning and replacing data by bin midpoints
> 
> h <- hist(xnorm, plot = FALSE)
> 
> ## Option 1: Assume bin probabilities proportional to dnorm()
> 
> norm.factor <- sum(dnorm(h$mids, mean(xnorm), sd(xnorm)))
> 
> rootogram(counts ~ mids, data = h,
+           dfun = function(x) {
+               dnorm(x, mean(xnorm), sd(xnorm)) / norm.factor
+           })
> 
> ## Option 2: Compute probabilities explicitly using pnorm()
> 
> pdisc <- diff(pnorm(h$breaks, mean = mean(xnorm), sd = sd(xnorm)))
> pdisc <- pdisc / sum(pdisc)
> 
> rootogram(counts ~ mids, data = h,
+           dfun = function(x) {
+               f <- factor(x, levels = h$mids)
+               pdisc[f]
+           })
> 
> 
> 
> 
> cleanEx()
> nameEx("scale.components")
> ### * scale.components
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale.components
> ### Title: Custom lattice axis scales
> ### Aliases: scale.components xscale.components.logpower
> ###   yscale.components.logpower xscale.components.fractions
> ###   yscale.components.fractions xscale.components.log10ticks
> ###   yscale.components.log10ticks xscale.components.log
> ###   yscale.components.log xscale.components.log10.3
> ###   yscale.components.log10.3 xscale.components.subticks
> ###   yscale.components.subticks
> ### Keywords: dplot
> 
> ### ** Examples
> 
> xyplot((1:200)/20 ~ (1:200)/20, type = c("p", "g"),
+   scales = list(x = list(log = 2), y = list(log = 10)),
+   xscale.components = xscale.components.fractions,
+   yscale.components = yscale.components.log10ticks)
> 
> xyplot((1:200)/20 ~ (1:200)/20, type = c("p", "g"),
+   scales = list(x = list(log = 2), y = list(log = 10)),
+   xscale.components = xscale.components.logpower,
+   yscale.components = yscale.components.log10.3)
> 
> dd <- as.Date("2000-01-01") + 0:365
> xyplot(0:365 ~ dd, type = c("p", "g"),
+   xscale.components = xscale.components.subticks,
+   yscale.components = yscale.components.subticks)
> 
> 
> 
> cleanEx()
> nameEx("segplot")
> ### * segplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: segplot
> ### Title: Plot segments using the Trellis framework
> ### Aliases: segplot segplot.formula
> ### Keywords: hplot
> 
> ### ** Examples
> 
> 
> segplot(factor(1:10) ~ rnorm(10) + rnorm(10), level = runif(10))
> 
> data(USCancerRates)
> 
> segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
+         data = subset(USCancerRates, state == "Washington"))
> 
> segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
+         data = subset(USCancerRates, state == "Washington"),
+         draw.bands = FALSE, centers = rate.male)
> 
> segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
+         data = subset(USCancerRates, state == "Washington"),
+         level = rate.female, col.regions = terrain.colors)
> 
> segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
+         data = subset(USCancerRates, state == "Washington"),
+         draw.bands = FALSE, centers = rate.male, 
+         segments.fun = panel.arrows, ends = "both", 
+         angle = 90, length = 1, unit = "mm")
> 
> 
> 
> 
> cleanEx()
> nameEx("theEconomist.theme")
> ### * theEconomist.theme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theEconomist.theme
> ### Title: Generate plots with style like The Economist.
> ### Aliases: theEconomist.theme theEconomist.opts theEconomist.axis
> ###   asTheEconomist
> ### Keywords: dplot
> 
> ### ** Examples
> 
> xyplot(window(sunspot.year, start = 1900),
+   main = "Sunspot cycles", sub = "Number per year",
+   par.settings = theEconomist.theme(box = "transparent"),
+   lattice.options = theEconomist.opts())
> 
> asTheEconomist(xyplot(window(sunspot.year, start = 1900),
+   main = "Sunspot cycles", sub = "Number per year"))
> 
> trellis.last.object() +
+   layer_(panel.xblocks(x, x >= 1980, col = "#6CCFF6", alpha = .5)) +
+   layer(panel.text(1988, 180, "Forecast", font = 3, pos = 2))
> 
> ## set as defaults -- remember to set back when finished.
> opar <- trellis.par.get()
> trellis.par.set(theEconomist.theme(box = "transparent"))
> oopt <- lattice.options(theEconomist.opts())
> 
> barchart(Titanic[,,,"No"], main = "Titanic deaths", layout = 1:2,
+     sub = "by sex and class", auto.key = list(columns = 2),
+     scales = list(y = list(alternating = 2)))
> 
> asTheEconomist(
+   dotplot(VADeaths, main = "Death Rates in Virginia (1940)",
+     auto.key = list(corner = c(.9,0.1))),
+   type = "b", with.bg = TRUE)
> 
> dotplot(VADeaths, auto.key = TRUE, type = "b",
+   par.settings = theEconomist.theme(with.bg = TRUE))
> 
> asTheEconomist(
+   densityplot(~ height, groups = voice.part, data = singer,
+     subset = grep("1", voice.part), plot.points = FALSE)) +
+ glayer(d <- density(x), i <- which.max(d$y),
+   ltext(d$x[i], d$y[i], paste("Group", group.number), pos = 3))
> 
> ## reset
> trellis.par.set(opar)
> lattice.options(oopt)
> 
> 
> 
> cleanEx()
> nameEx("tileplot")
> ### * tileplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tileplot
> ### Title: Plot a spatial mosaic from irregular 2D points
> ### Aliases: tileplot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> xyz <- data.frame(x = rnorm(100), y = rnorm(100), z = rnorm(100))
> tileplot(z ~ x * y, xyz)
> 
> ## Alternative backend using 'deldir' package
> ## Not run: 
> ##D tileplot(z ~ x * y, xyz, backend = "deldir")
> ## End(Not run)
> 
> ## showing rectangular window boundary
> tileplot(z ~ x * y, xyz, xlim = c(-2, 4), ylim = c(-2, 4))
> 
> ## insert some missing values
> xyz$z[1:10] <- NA
> ## the default na.rm = FALSE shows missing polygons
> tileplot(z ~ x * y, xyz, border = "black",
+   col.regions = grey.colors(100),
+   pch = ifelse(is.na(xyz$z), 4, 21),
+   panel = function(...) {
+     panel.fill("hotpink")
+     panel.voronoi(...)
+   })
> ## use na.rm = TRUE to ignore points with missing values
> update(trellis.last.object(), na.rm = TRUE)
> 
> ## a quick and dirty approximation to US state boundaries
> tmp <- state.center
> tmp$Income <- state.x77[,"Income"]
> tileplot(Income ~ x * y, tmp, border = "black",
+   panel = function(x, y, ...) {
+     panel.voronoi(x, y, ..., points = FALSE)
+     panel.text(x, y, state.abb, cex = 0.6)
+   })
> 
> 
> 
> cleanEx()
> nameEx("useOuterStrips")
> ### * useOuterStrips
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: useOuterStrips
> ### Title: Put Strips on the Boundary of a Lattice Display
> ### Aliases: useOuterStrips
> ### Keywords: dplot
> 
> ### ** Examples
> 
> 
> library(lattice)
> 
> mtcars$HP <- equal.count(mtcars$hp)
> 
> useOuterStrips(xyplot(mpg ~ disp | HP + factor(cyl), mtcars))
> 
> useOuterStrips(xyplot(mpg ~ disp | factor(cyl) + HP, mtcars),
+                strip.left = FALSE,
+                strip = strip.custom(style = 4))
> 
> 
> 
> 
> cleanEx()
> nameEx("xyplot.stl")
> ### * xyplot.stl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xyplot.stl
> ### Title: Display stl fits with Lattice
> ### Aliases: xyplot.stl
> ### Keywords: hplot ts
> 
> ### ** Examples
> 
> ## example from ?stl
> xyplot(stl(log(co2), s.window=21),
+        main = "STL decomposition of CO2 data")
> 
> ## alternative display
> data(biocAccess)
> xyplot(stl(ts(biocAccess$counts[1:(24 * 30)], frequency = 24), "periodic"),
+        strip.left = "strip.default")
> resizePanels()
> 
> ## two different spans
> xyplot(stl(nottem, s.window = 4)) +
+ as.layer(xyplot(stl(nottem, s.window = "periodic")), style = 2)
> 
> ## components superposed
> xyplot(stl(nottem, s.window = 4), superpose=TRUE,
+   screens = list(data = "trend", trend = "trend", "residuals"),
+   strip.left = TRUE, layout = c(1,2))
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  9.99 1.224 9.988 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
