
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "quantreg"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('quantreg')
Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Bosco")
> ### * Bosco
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Bosco
> ### Title: Boscovich Data
> ### Aliases: Bosco
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(Bosco)
> plot(0:10/10,0:10*100,xlab="sin^2(latitude)",
+         ylab="arc-length of 1 degree of latitude",type="n")
> points(Bosco)
> text(Bosco, pos = 3, rownames(Bosco))
> z <- rq(y ~ x, tau = -1, data = Bosco)
> title("Boscovitch Ellipticity of the Earth Example")
> xb <- c(.85,.9,.6,.6)
> yb <- c(400,600,450,600)
> for(i in 1:4){
+         abline(c(z$sol[4:5,i]))
+         interval <- paste("t=(",format(round(z$sol[1,i],2)),",",
+                 format(round(z$sol[1,i+1],2)),")",delim="")
+         text(xb[i],yb[i],interval)
+         }
> 
> 
> 
> cleanEx()
> nameEx("CobarOre")
> ### * CobarOre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CobarOre
> ### Title: Cobar Ore data
> ### Aliases: CobarOre
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(CobarOre)
> plot(CobarOre)
> 
> 
> 
> cleanEx()
> nameEx("KhmaladzeTest")
> ### * KhmaladzeTest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: KhmaladzeTest
> ### Title: Tests of Location and Location Scale Shift Hypotheses for Linear
> ###   Models
> ### Aliases: KhmaladzeTest
> ### Keywords: htest
> 
> ### ** Examples
> 
> data(barro)
> T = KhmaladzeTest( y.net ~ lgdp2 + fse2 + gedy2 + Iy2 + gcony2, 
+ 		data = barro, taus = seq(.05,.95,by = .01))
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 3 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 3 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 4 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 3 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 5 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 4 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 5 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 4 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 4 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 3 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 3 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 1 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 2 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 9 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 13 non-positive fis
Warning in summary.rq(xi, U = U, ...) : 14 non-positive fis
> plot(T)
> 
> 
> 
> cleanEx()
> nameEx("LassoLambdaHat")
> ### * LassoLambdaHat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LassoLambdaHat
> ### Title: Lambda selection for QR lasso problems
> ### Aliases: LassoLambdaHat
> 
> ### ** Examples
> 
> n <- 200
> p <- 10
> x <- matrix(rnorm(n*p), n, p)
> b <- c(1,1, rep(0, p-2))
> y <- x %*% b + rnorm(n)
> f <- rq(y ~ x, tau = 0.8, method = "lasso")
> # See f$lambda to see the default lambda selection
> 
> 
> 
> cleanEx()
> nameEx("Mammals")
> ### * Mammals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Mammals
> ### Title: Garland(1983) Data on Running Speed of Mammals
> ### Aliases: Mammals
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(Mammals)
> attach(Mammals)
> x <- log(weight)
> y <- log(speed)
> plot(x,y, xlab="Weight in log(Kg)", ylab="Speed in log(Km/hour)",type="n")
> points(x[hoppers],y[hoppers],pch = "h", col="red")
> points(x[specials],y[specials],pch = "s", col="blue")
> others <- (!hoppers & !specials)
> points(x[others],y[others], col="black",cex = .75)
> fit <- rqss(y ~ qss(x, lambda = 1),tau = .9)
> plot(fit)
> 
> 
> 
> cleanEx()

detaching ‘Mammals’

> nameEx("MelTemp")
> ### * MelTemp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MelTemp
> ### Title: Daily maximum temperatures in Melbourne, Australia
> ### Aliases: MelTemp
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(MelTemp)
> demo(Mel)


	demo(Mel)
	---- ~~~

> #Analysis of the QAR(1) Melbourne Temperature Example
> require(splines)
Loading required package: splines

> if(interactive()){ 
+     oldpar <- par(ask = TRUE)
+     data(MelTemp)
+     x <- MelTemp[-3650]
+     y <- MelTemp[-1]
+     s <- (x<40)  #Delete a few (influential, ridiculously hot) days
+     x <- x[s]
+     y <- y[s]
+     z <- seq(10,36,length=100)
+ 
+ 	fit <- rq(y~ bs(x,knots=quantile(x,c(.05,.25,.5,.75,.95))), tau =  1:19/20)
+ 	par(cex=1,pty="s")
+ 	xlab <- "yesterday's max temperature"
+ 	ylab <- "today's max temperature"
+ 	plot(x,y,pch=".",xlab=xlab,ylab=ylab)
+ 	matlines(z,predict(fit, newdata = data.frame(x = z)), lty = 1)
+ 	abline(c(0,1),lty=3)
+ 	title("Melbourne QAR Model")
+ 
+ 	taus <- 1:199/200
+ 	xs <- c(11,16,21,25,30,35)
+ 	fit <- rq(y~ bs(x,knots=quantile(x,c(.05,.25,.5,.75,.95))), tau = taus)
+ 	Qy <- predict(fit,newdata = data.frame(x = xs))
+ 	par(mfrow = c(2,3))
+ 	for(i in 1:length(xs)){
+ 		Qyi <- Qy[i,-1]
+ 		fhat <- akj(Qyi,Qyi,diff(taus), h = 1)$dens
+ 		xlab <- "today's max temperature"
+ 		plot(Qyi,fhat,type="l",xlab=xlab,ylab="density")
+ 		abline(v=xs[i], col="red")
+ 		title(paste("Yesterday's Temp", format(round(xs[i]))))
+ 		}
+ 	par(oldpar)
+ 
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:splines’

> nameEx("Munge")
> ### * Munge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Munge
> ### Title: Munge rqss formula
> ### Aliases: Munge
> ### Keywords: ~manip
> 
> ### ** Examples
> 
> lams <- c(1.3, 3.3)
> f <- y ~ qss(x, lambda = lams[1]) + qss(z, lambda = lams[2]) + s
> ff <- Munge(f, lams = lams)
> 
> 
> 
> cleanEx()
> nameEx("ParetoTest")
> ### * ParetoTest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParetoTest
> ### Title: Estimation and Inference on the Pareto Tail Exponent for Linear
> ###   Models
> ### Aliases: ParetoTest Hill Hill.fit print.Hill summary.Hill
> ###   print.summary.Hill Pickands.fit Pickands print.Pickands
> ###   summary.Pickands print.summary.Pickands Pickands.fit
> ### Keywords: htest
> 
> ### ** Examples
> 
> n = 500
> x = rnorm(n)
> y = x + rt(n,2)
> Z = ParetoTest(y ~ x, .9, flavor = "Pickands")
> 
> 
> 
> cleanEx()
> nameEx("Peirce")
> ### * Peirce
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Peirce
> ### Title: C.S. Peirce's Auditory Response Data
> ### Aliases: Peirce
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> # Make table like Wilson and Hilferty
> 
> data("Peirce")
> set.seed(10) #Dither the counts
> tab <- matrix(0,24,11)
> for(i in 1:24){
+ 	y <- rep(Peirce[[i]]$x, Peirce[[i]]$y) + runif(sum(Peirce[[i]]$y), -.5, .5)
+ 	f1 <- summary(rq(y~1),se="iid")$coef[1:2]
+ 	n <- length(y)
+ 	f0 <- 1/(2 * sum(abs(y-f1[1])/n)) #Laplace proposal
+ 	f0 <- (1/(2 * f0))/ sqrt(n)
+ 	f2 <- summary(lm(y~1))$coef[1:2]
+ 	outm <- sum(y < (f1[1] - 3.1 * sqrt(n) * f2[2]))
+ 	outp <- sum(y > (f1[1] + 3.1 * sqrt(n) * f2[2]))
+ 	outt <- outm + outp
+ 	inm <- y > (f1[1] - 0.25 * sqrt(n) * f2[2])
+ 	inp <- y < (f1[1] + 0.25 * sqrt(n) * f2[2])
+ 	int <- sum(inm * inp)
+ 	Eint <- round(n * (pnorm(.25) - pnorm(-.25)))
+ 	excess <- round(100*(int - Eint)/Eint)
+ 	tab[i,] <- c(f1, f0, f2, outm, outp, outt,int,Eint,excess)
+ 	cnames <- c("med","sdmed1","sdmed0","mean","sdmean","below","above","outliers",
+ 		"inliers","Einliers","ExcessIns")
+ 	dimnames(tab) <- list(paste("Day",1:24),cnames)
+ 	}
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
> 
> 
> 
> cleanEx()
> nameEx("akj")
> ### * akj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: akj
> ### Title: Density Estimation using Adaptive Kernel method
> ### Aliases: akj
> ### Keywords: smooth
> 
> ### ** Examples
> 
>  set.seed(1)
>  x <- c(rnorm(600), 2 + 2*rnorm(400))
>  xx <- seq(-5, 8, length=200)
>  z <- akj(x, xx)
>  plot(xx, z$dens, ylim=range(0,z$dens), type ="l", col=2)
>  abline(h=0, col="gray", lty=3)
>  plot(xx, z$psi, type ="l", col=2, main = expression(hat(psi(x))))
>  plot(xx, z$score, type ="l", col=2,
+       main = expression("score " * hat(psi) * "'" * (x)))
> 
>  if(require("nor1mix")) {
+   m3 <- norMix(mu= c(-4, 0, 3), sig2 = c(1/3^2, 1, 2^2),
+                w = c(.1,.5,.4))
+   plot(m3, p.norm = FALSE)
+   set.seed(11)
+   x <- rnorMix(1000, m3)
+   z2 <- akj(x, xx)
+   lines(xx, z2$dens, col=2)
+   z3 <- akj(x, xx, kappa = 0.5, alpha = 0.88)
+   lines(xx, z3$dens, col=3)
+  }
Loading required package: nor1mix
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘nor1mix’
> 
> 
> 
> cleanEx()
> nameEx("anova.rq")
> ### * anova.rq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.rq
> ### Title: Anova function for quantile regression fits
> ### Aliases: anova.rq anova.rqs anova.rqlist print.anova.rq rq.test.rank
> ###   rq.test.anowar
> ### Keywords: htest regression robust
> 
> ### ** Examples
> 
> data(barro)
> fit0 <- rq(y.net ~  lgdp2 + fse2 + gedy2 , data = barro)
> fit1 <- rq(y.net ~  lgdp2 + fse2 + gedy2 + Iy2 + gcony2, data = barro)
> fit2 <- rq(y.net ~  lgdp2 + fse2 + gedy2 + Iy2 + gcony2, data = barro,tau=.75)
> fit3 <- rq(y.net ~  lgdp2 + fse2 + gedy2 + Iy2 + gcony2, data = barro,tau=.25)
> anova(fit1,fit0)
Quantile Regression Analysis of Deviance Table

Model 1: y.net ~ lgdp2 + fse2 + gedy2 + Iy2 + gcony2
Model 2: y.net ~ lgdp2 + fse2 + gedy2
  Df Resid Df F value    Pr(>F)    
1  2      155  18.879 4.596e-08 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> anova(fit1,fit2,fit3)
Warning in summary.rq(x, se = se, R = R, covariance = TRUE) :
  1 non-positive fis
Quantile Regression Analysis of Deviance Table

Model: y.net ~ lgdp2 + fse2 + gedy2 + Iy2 + gcony2
Joint Test of Equality of Slopes: tau in {  0.5 0.75 0.25  }

  Df Resid Df F value  Pr(>F)  
1 10      473  1.8039 0.05751 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> anova(fit1,fit2,fit3,joint=FALSE)
Warning in summary.rq(x, se = se, R = R, covariance = TRUE) :
  1 non-positive fis
Quantile Regression Analysis of Deviance Table

Model: y.net ~ lgdp2 + fse2 + gedy2 + Iy2 + gcony2
Tests of Equality of Distinct Slopes: tau in {  0.5 0.75 0.25  }

       Df Resid Df F value  Pr(>F)  
lgdp2   2      481  1.0656 0.34535  
fse2    2      481  2.6398 0.07241 .
gedy2   2      481  0.7862 0.45614  
Iy2     2      481  0.0447 0.95632  
gcony2  2      481  0.0653 0.93675  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> # Alternatively fitting can be done in one call:
> fit <- rq(y.net ~  lgdp2 + fse2 + gedy2 + Iy2 + gcony2, 
+ 	  method = "fn", tau = 1:4/5, data = barro)
> 
> 
> 
> cleanEx()
> nameEx("boot.rq")
> ### * boot.rq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boot.rq
> ### Title: Bootstrapping Quantile Regression
> ### Aliases: boot.rq boot.rq.xy boot.rq.wxy boot.rq.pwy boot.rq.spwy
> ###   boot.rq.mcmb
> ### Keywords: regression
> 
> ### ** Examples
> 
> y <- rnorm(50)
> x <- matrix(rnorm(100),50)
> fit <- rq(y~x,tau = .4)
> summary(fit,se = "boot", bsmethod= "xy")

Call: rq(formula = y ~ x, tau = 0.4)

tau: [1] 0.4

Coefficients:
            Value    Std. Error t value  Pr(>|t|)
(Intercept) -0.07369  0.15149   -0.48646  0.62890
x1          -0.18160  0.17069   -1.06393  0.29280
x2           0.09891  0.15172    0.65195  0.51761
> summary(fit,se = "boot", bsmethod= "pwy")

Call: rq(formula = y ~ x, tau = 0.4)

tau: [1] 0.4

Coefficients:
            Value    Std. Error t value  Pr(>|t|)
(Intercept) -0.07369  0.16822   -0.43807  0.66334
x1          -0.18160  0.18956   -0.95800  0.34296
x2           0.09891  0.16222    0.60975  0.54496
> #summary(fit,se = "boot", bsmethod= "mcmb")
> 
> 
> 
> cleanEx()
> nameEx("combos")
> ### * combos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combos
> ### Title: Ordered Combinations
> ### Aliases: combos
> ### Keywords: utilities
> 
> ### ** Examples
> 
> H <- combos(20,3)
> 
> 
> 
> cleanEx()
> nameEx("crq")
> ### * crq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crq
> ### Title: Functions to fit censored quantile regression models
> ### Aliases: crq crq.fit.por crq.fit.por2 crq.fit.pow crq.fit.pen print.crq
> ###   print.crq coef.crq predict.crq predict.crqs Curv
> ### Keywords: survival regression
> 
> ### ** Examples
> 
> # An artificial Powell example
> set.seed(2345)
> x <- sqrt(rnorm(100)^2)
> y <-  -0.5 + x +(.25 + .25*x)*rnorm(100)
> plot(x,y, type="n")
> s <- (y > 0)
> points(x[s],y[s],cex=.9,pch=16)
> points(x[!s],y[!s],cex=.9,pch=1)
> yLatent <- y
> y <- pmax(0,y)
> yc <- rep(0,100)
> for(tau in (1:4)/5){
+         f <- crq(Curv(y,yc) ~ x, tau = tau, method = "Pow")
+         xs <- sort(x)
+         lines(xs,pmax(0,cbind(1,xs)%*%f$coef),col="red")
+         abline(rq(y ~ x, tau = tau), col="blue")
+         abline(rq(yLatent ~ x, tau = tau), col="green")
+         }
Warning in crq.fit.pow(X, y, cen, tau = taus, weights, left = left, ...) :
  Solution may be nonunique
Warning in crq.fit.pow(X, y, cen, tau = taus, weights, left = left, ...) :
  Solution may be nonunique
> legend(.15,2.5,c("Naive QR","Censored QR","Omniscient QR"),
+         lty=rep(1,3),col=c("blue","red","green"))
> 
> # crq example with left censoring
> set.seed(1968)
> n <- 200
> x <-rnorm(n)
> y <- 5 + x + rnorm(n)
> plot(x,y,cex = .5)
> c <- 4 + x + rnorm(n)
> d <- (y > c)
> points(x[!d],y[!d],cex = .5, col = 2)
> f <- crq(survival::Surv(pmax(y,c), d, type = "left") ~ x, method = "Portnoy")
> g <- summary(f)
> for(i in 1:4) abline(coef(g[[i]])[,1])
> 
> 
> 
> cleanEx()
> nameEx("dither")
> ### * dither
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dither
> ### Title: Function to randomly perturb a vector
> ### Aliases: dither
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- rlnorm(40)
> y <- rpois(40, exp(.5 + log(x)))
> f <- rq(dither(y, type = "right", value = 1) ~ x)
> 
> 
> 
> cleanEx()
> nameEx("dynrq")
> ### * dynrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dynrq
> ### Title: Dynamic Linear Quantile Regression
> ### Aliases: dynrq print.dynrq print.dynrqs summary.dynrq summary.dynrqs
> ###   print.summary.dynrq print.summary.dynrqs time.dynrq index.dynrq
> ###   start.dynrq end.dynrq
> ### Keywords: regression
> 
> ### ** Examples
> 
> ###########################
> ## Dynamic Linear Quantile Regression Models ##
> ###########################
> 
> if(require(zoo)){
+ ## multiplicative median SARIMA(1,0,0)(1,0,0)_12 model fitted to UK seatbelt data
+      uk <- log10(UKDriverDeaths)
+      dfm <- dynrq(uk ~ L(uk, 1) + L(uk, 12))
+      dfm
+ 
+      dfm3 <- dynrq(uk ~ L(uk, 1) + L(uk, 12),tau = 1:3/4)
+      summary(dfm3)
+  ## explicitly set start and end
+      dfm1 <- dynrq(uk ~ L(uk, 1) + L(uk, 12), start = c(1975, 1), end = c(1982, 12))
+  ## remove lag 12
+      dfm0 <- update(dfm1, . ~ . - L(uk, 12))
+      tuk1  <- anova(dfm0, dfm1)
+  ## add seasonal term
+      dfm1 <- dynrq(uk ~ 1, start = c(1975, 1), end = c(1982, 12))
+      dfm2 <- dynrq(uk ~ season(uk), start = c(1975, 1), end = c(1982, 12))
+      tuk2 <- anova(dfm1, dfm2)
+  ## regression on multiple lags in a single L() call
+      dfm3 <- dynrq(uk ~ L(uk, c(1, 11, 12)), start = c(1975, 1), end = c(1982, 12))
+      anova(dfm1, dfm3)
+ }
Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Quantile Regression Analysis of Deviance Table

Model 1: uk ~ L(uk, c(1, 11, 12))
Model 2: uk ~ 1
  Df Resid Df F value    Pr(>F)    
1  3       92  18.561 1.691e-09 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> ###############################
> ## Time Series Decomposition ##
> ###############################
> 
> ## airline data
> ## Not run: 
> ##D ap <- log(AirPassengers)
> ##D fm <- dynrq(ap ~ trend(ap) + season(ap), tau = 1:4/5)
> ##D sfm <- summary(fm)
> ##D plot(sfm)
> ## End(Not run)
> 
> ## Alternative time trend specifications:
> ##   time(ap)                  1949 + (0, 1, ..., 143)/12
> ##   trend(ap)                 (1, 2, ..., 144)/12
> ##   trend(ap, scale = FALSE)  (1, 2, ..., 144)
> 
> ###############################
> ## An Edgeworth (1886) Problem##
> ###############################
> # DGP
> ## Not run: 
> ##D fye <- function(n, m = 20){
> ##D     a <- rep(0,n)
> ##D     s <- sample(0:9, m, replace = TRUE)
> ##D     a[1] <- sum(s)
> ##D     for(i in 2:n){
> ##D        s[sample(1:20,1)] <- sample(0:9,1)
> ##D        a[i] <- sum(s)
> ##D     }
> ##D     zoo::zoo(a)
> ##D }
> ##D x <- fye(1000)
> ##D f <- dynrq(x ~ L(x,1))
> ##D plot(x,cex = .5, col = "red")
> ##D lines(fitted(f), col = "blue")
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:zoo’

> nameEx("engel")
> ### * engel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engel
> ### Title: Engel Data
> ### Aliases: engel
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## See also    demo("engel1")
> ##             --------------
> 
> data(engel)
> plot(engel, log = "xy",
+      main = "'engel' data  (log - log scale)")
> plot(log10(foodexp) ~ log10(income), data = engel,
+      main = "'engel' data  (log10 - transformed)")
> taus <- c(.15, .25, .50, .75, .95, .99)
> rqs <- as.list(taus)
> for(i in seq(along = taus)) {
+   rqs[[i]] <- rq(log10(foodexp) ~ log10(income), tau = taus[i], data = engel)
+   lines(log10(engel$income), fitted(rqs[[i]]), col = i+1)
+ }
> legend("bottomright", paste("tau = ", taus), inset = .04,
+        col = 2:(length(taus)+1), lty=1)
> 
> 
> 
> cleanEx()
> nameEx("gasprice")
> ### * gasprice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gasprice
> ### Title: Time Series of US Gasoline Prices
> ### Aliases: gasprice
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(gasprice)
> 
> 
> 
> cleanEx()
> nameEx("kuantile")
> ### * kuantile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kuantile
> ### Title: Quicker Sample Quantiles
> ### Aliases: kuantile kselect kunique
> ### Keywords: univar
> 
> ### ** Examples
> 
>      kuantile(x <- rnorm(1001))# Extremes & Quartiles by default
         0%         25%         50%         75%        100% 
-3.00804860 -0.69731820 -0.03472603  0.68924373  3.81027668 
attr(,"class")
[1] "kuantile"
> 
>      ### Compare different types
>      p <- c(0.1,0.5,1,2,5,10,50)/100
>      res <- matrix(as.numeric(NA), 9, 7)
>      for(type in 1:9) res[type, ] <- y <- kuantile(x,  p, type=type)
>      dimnames(res) <- list(1:9, names(y))
>      ktiles <- res
> 
>      ### Compare different types
>      p <- c(0.1,0.5,1,2,5,10,50)/100
>      res <- matrix(as.numeric(NA), 9, 7)
>      for(type in 1:9) res[type, ] <- y <- quantile(x,  p, type=type)
>      dimnames(res) <- list(1:9, names(y))
>      qtiles <- res
> 
>      max(abs(ktiles - qtiles))
[1] 2.220446e-16
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("lprq")
> ### * lprq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lprq
> ### Title: locally polynomial quantile regression
> ### Aliases: lprq
> ### Keywords: smooth robust
> 
> ### ** Examples
> 
> require(MASS)
Loading required package: MASS
> data(mcycle)
> attach(mcycle)
> plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
> hs <- c(1,2,3,4)
> for(i in hs){
+         h = hs[i]
+         fit <- lprq(times,accel,h=h,tau=.5)
+         lines(fit$xx,fit$fv,lty=i)
+         }
> legend(50,-70,c("h=1","h=2","h=3","h=4"),lty=1:length(hs))
> 
> 
> 
> cleanEx()

detaching ‘mcycle’, ‘package:MASS’

> nameEx("nlrq")
> ### * nlrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nlrq
> ### Title: Function to compute nonlinear quantile regression estimates
> ### Aliases: nlrq nlrqModel print.nlrq summary.nlrq deviance.nlrq
> ###   formula.nlrq coef.nlrq fitted.nlrq logLik.nlrq AIC.nlrq
> ###   extractAIC.nlrq predict.nlrq print.summary.nlrq tau.nlrq
> ### Keywords: models regression nonlinear robust
> 
> ### ** Examples
> 
> # build artificial data with multiplicative error
> Dat <- NULL; Dat$x <- rep(1:25, 20)
> set.seed(1)
> Dat$y <- SSlogis(Dat$x, 10, 12, 2)*rnorm(500, 1, 0.1)
> plot(Dat)
> # fit first a nonlinear least-square regression
> Dat.nls <- nls(y ~ SSlogis(x, Asym, mid, scal), data=Dat); Dat.nls
Nonlinear regression model
  model: y ~ SSlogis(x, Asym, mid, scal)
   data: Dat
  Asym    mid   scal 
 9.968 11.947  1.962 
 residual sum-of-squares: 241.8

Number of iterations to convergence: 0 
Achieved convergence tolerance: 6.914e-07
> lines(1:25, predict(Dat.nls, newdata=list(x=1:25)), col=1)
> # then fit the median using nlrq
> Dat.nlrq <- nlrq(y ~ SSlogis(x, Asym, mid, scal), data=Dat, tau=0.5, trace=TRUE)
109.059 :   9.968027 11.947208  1.962113 
final  value 108.942725 
converged
lambda = 1 
108.9427 :   9.958648 11.943273  1.967144 
final  value 108.490939 
stopped after 2 iterations
lambda = 0.9750984 
108.4909 :   9.949430 11.987472  1.998607 
final  value 108.471416 
converged
lambda = 0.9999299 
108.4714 :   9.94163 11.99077  1.99344 
final  value 108.471243 
converged
lambda = 1 
108.4712 :   9.941008 11.990550  1.992921 
final  value 108.470935 
converged
lambda = 0.8621249 
108.4709 :   9.942734 11.992773  1.993209 
final  value 108.470923 
converged
lambda = 0.9999613 
108.4709 :   9.942629 11.992728  1.993136 
final  value 108.470919 
converged
lambda = 1 
108.4709 :   9.942644 11.992737  1.993144 
final  value 108.470919 
converged
lambda = 1 
108.4709 :   9.942644 11.992737  1.993144 
final  value 108.470919 
converged
lambda = 1 
108.4709 :   9.942644 11.992737  1.993144 
> lines(1:25, predict(Dat.nlrq, newdata=list(x=1:25)), col=2)
> # the 1st and 3rd quartiles regressions
> Dat.nlrq <- nlrq(y ~ SSlogis(x, Asym, mid, scal), data=Dat, tau=0.25, trace=TRUE)
108.6656 :   9.968027 11.947208  1.962113 
final  value 89.108243 
converged
lambda = 1 
89.10824 :   9.432250 11.803924  1.923472 
final  value 85.688895 
converged
lambda = 1 
85.6889 :   9.183598 11.794244  1.929699 
final  value 85.473712 
converged
lambda = 0.6405076 
85.47371 :   9.212527 11.844090  1.938003 
final  value 85.447786 
converged
lambda = 1 
85.44779 :   9.234097 11.863975  1.949241 
final  value 85.446407 
converged
lambda = 1 
85.44641 :   9.242009 11.866644  1.954192 
final  value 85.445691 
converged
lambda = 1 
85.44569 :   9.234247 11.864554  1.952338 
final  value 85.444920 
converged
lambda = 1 
85.44492 :   9.232975 11.863979  1.953587 
final  value 85.443854 
converged
lambda = 0.363237 
85.44385 :   9.233661 11.864280  1.957197 
final  value 85.443668 
converged
lambda = 0.8495473 
85.44367 :   9.233453 11.860020  1.957831 
final  value 85.443667 
converged
lambda = 0.008522584 
85.44367 :   9.233449 11.860007  1.957814 
final  value 85.443584 
converged
lambda = 1 
85.44358 :   9.232996 11.859020  1.955928 
final  value 85.443586 
converged
lambda = 0.9999957 
85.44359 :   9.232995 11.859024  1.955916 
> lines(1:25, predict(Dat.nlrq, newdata=list(x=1:25)), col=3)
> Dat.nlrq <- nlrq(y ~ SSlogis(x, Asym, mid, scal), data=Dat, tau=0.75, trace=TRUE)
109.4525 :   9.968027 11.947208  1.962113 
final  value 89.561436 
converged
lambda = 1 
89.56144 :  10.64021 12.13202  2.02044 
final  value 87.302043 
converged
lambda = 1 
87.30204 :  10.652294 11.966018  1.958371 
final  value 87.200715 
converged
lambda = 1 
87.20072 :  10.666754 11.953497  1.962447 
final  value 87.131462 
converged
lambda = 0.8659451 
87.13146 :  10.639094 11.949236  1.971242 
final  value 87.125795 
converged
lambda = 0.6273926 
87.1258 :  10.647784 11.962635  1.975851 
final  value 87.122717 
converged
lambda = 0.8041119 
87.12272 :  10.647957 11.963190  1.973657 
final  value 87.121592 
converged
lambda = 1 
87.12159 :  10.649877 11.962363  1.973516 
final  value 87.121427 
converged
lambda = 1 
87.12143 :  10.649051 11.961685  1.973086 
final  value 87.121355 
converged
lambda = 0.5468903 
87.12135 :  10.648209 11.961208  1.972643 
final  value 87.121400 
converged
lambda = 0.9999045 
87.1214 :  10.648073 11.961122  1.972568 
> lines(1:25, predict(Dat.nlrq, newdata=list(x=1:25)), col=3)
> # and finally "external envelopes" holding 95 percent of the data
> Dat.nlrq <- nlrq(y ~ SSlogis(x, Asym, mid, scal), data=Dat, tau=0.025, trace=TRUE)
108.3114 :   9.968027 11.947208  1.962113 
final  value 62.166616 
converged
lambda = 1 
62.16662 :   9.432250 11.803924  1.923472 
final  value 16.887325 
converged
lambda = 1 
16.88732 :   8.006640 11.718631  1.979243 
final  value 15.823276 
converged
lambda = 0.7133884 
15.82328 :   8.135460 12.048708  1.987995 
final  value 15.732737 
stopped after 3 iterations
lambda = 0.7726586 
15.73274 :   8.042059 12.019442  1.994386 
final  value 15.732737 
converged
lambda = 0 
15.73274 :   8.042059 12.019442  1.994386 
> lines(1:25, predict(Dat.nlrq, newdata=list(x=1:25)), col=4)
> Dat.nlrq <- nlrq(y ~ SSlogis(x, Asym, mid, scal), data=Dat, tau=0.975, trace=TRUE)
109.8066 :   9.968027 11.947208  1.962113 
final  value 56.575819 
converged
lambda = 1 
56.57582 :  10.672415 12.148657  2.027285 
final  value 20.551829 
converged
lambda = 1 
20.55183 :  11.923558 12.366710  2.121476 
final  value 17.268734 
converged
lambda = 1 
17.26873 :  12.266850 12.051876  2.060768 
final  value 17.194623 
converged
lambda = 0.5512476 
17.19462 :  12.176373 12.020546  2.003537 
final  value 17.175845 
converged
lambda = 0.900139 
17.17585 :  12.180837 12.005129  2.019783 
final  value 17.175761 
converged
lambda = 0.1504766 
17.17576 :  12.177202 12.003960  2.011709 
final  value 17.175612 
converged
lambda = 1 
17.17561 :  12.18154 12.00534  2.01894 
final  value 17.175603 
converged
lambda = 1 
17.1756 :  12.181679 12.005403  2.019175 
final  value 17.175518 
converged
lambda = 1 
17.17552 :  12.17954 12.00469  2.01453 
final  value 17.175518 
converged
lambda = 0 
17.17552 :  12.17954 12.00469  2.01453 
> lines(1:25, predict(Dat.nlrq, newdata=list(x=1:25)), col=4)
> leg <- c("least squares","median (0.5)","quartiles (0.25/0.75)",".95 band (0.025/0.975)")
> legend(1, 12.5, legend=leg, lty=1, col=1:4)
> 
> 
> 
> cleanEx()
> nameEx("plot.rqs")
> ### * plot.rqs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.rqs
> ### Title: Visualizing sequences of quantile regressions
> ### Aliases: plot.rqs
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## fit Engel models (in levels) for tau = 0.1, ..., 0.9
> data("engel")
> fm <- rq(foodexp ~ income, data = engel, tau = 1:9/10)
> 
> ## visualizations
> plot(fm)
> plot(fm, parm = 2, mar = c(5.1, 4.1, 2.1, 2.1), main = "", xlab = "tau", 
+   ylab = "income coefficient", cex = 1, pch = 19)
> 
> 
> 
> cleanEx()
> nameEx("plot.rqss")
> ### * plot.rqss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.rqss
> ### Title: Plot Method for rqss Objects
> ### Aliases: plot.rqss plot.qss1 plot.qts1 plot.qss2 plot.summary.rqss
> ### Keywords: regression smooth iplot
> 
> ### ** Examples
> 
> n <- 200
> x <- sort(rchisq(n,4))
> z <- x + rnorm(n)
> y <- log(x)+ .1*(log(x))^2 + log(x)*rnorm(n)/4 + z
> plot(x,y-z)
> fN <- rqss(y~qss(x,constraint="N")+z)
> plot(fN)
> fI <- rqss(y~qss(x,constraint="I")+z)
> plot(fI,  col="blue")
> fCI <- rqss(y~qss(x,constraint="CI")+z)
> plot(fCI, col="red")
> 
> ## A bivariate example
> if(requireNamespace("interp")){
+ if(requireNamespace("interp")){
+ data(CobarOre)
+ fCO <- rqss(z~qss(cbind(x,y),lambda=.08), data = CobarOre)
+ plot(fCO)
+ }}
Loading required namespace: interp
> 
> 
> 
> cleanEx()
> nameEx("plot.summary.rqs")
> ### * plot.summary.rqs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.summary.rqs
> ### Title: Visualizing sequences of quantile regression summaries
> ### Aliases: plot.summary.rqs plot.summary.rq
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## fit Engel models (in levels) for tau = 0.1, ..., 0.9
> data("engel")
> fm <- rq(foodexp ~ income, data = engel, tau = 1:9/10)
> sfm <- summary(fm)
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
> 
> ## visualizations
> plot(sfm)
> plot(sfm, parm = 2, mar = c(5.1, 4.1, 2.1, 2.1), main = "", xlab = "tau", 
+   ylab = "income coefficient", cex = 1, pch = 19)
> 
> 
> 
> cleanEx()
> nameEx("predict.rq")
> ### * predict.rq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.rq
> ### Title: Quantile Regression Prediction
> ### Aliases: predict.rq predict.rqs predict.rq.process
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(airquality)
> airq <- airquality[143:145,]
> f <- rq(Ozone ~ ., data=airquality)
> predict(f,newdata=airq)
      143       144       145 
48.963525  2.721109 17.638599 
> f <- rq(Ozone ~ ., data=airquality, tau=1:19/20)
> fp <- predict(f, newdata=airq, stepfun = TRUE)
> fpr <- rearrange(fp)
> plot(fp[[2]],main = "Conditional Ozone Quantile Prediction")
> lines(fpr[[2]], col="red")
> legend(.2,20,c("raw","cooked"),lty = c(1,1),col=c("black","red"))
> fp <- predict(f, newdata=airq, type = "Fhat", stepfun = TRUE)
> fpr <- rearrange(fp)
> plot(fp[[2]],main = "Conditional Ozone Distribution Prediction")
> lines(fpr[[2]], col="red")
> legend(20,.4,c("raw","cooked"),lty = c(1,1),col=c("black","red"))
>   
> 
> 
> cleanEx()
> nameEx("predict.rqss")
> ### * predict.rqss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.rqss
> ### Title: Predict from fitted nonparametric quantile regression smoothing
> ###   spline models
> ### Aliases: predict.rqss predict.qss1 predict.qss2
> ### Keywords: regression smooth robust
> 
> ### ** Examples
> 
> n <- 200
> lam <- 2
> x <- sort(rchisq(n,4))
> z <- exp(rnorm(n)) + x
> y <- log(x)+ .1*(log(x))^2 + z/4 +  log(x)*rnorm(n)/4
> plot(x,y - z/4 + mean(z)/4)
> Ifit <- rqss(y ~ qss(x,constraint="I") + z)
> sfit <- rqss(y ~ qss(x,lambda = lam) + z)
> xz <- data.frame(z = mean(z),
+                  x = seq(min(x)+.01,max(x)-.01,by=.25))
> lines(xz[["x"]], predict(Ifit, xz), col=2)
Warning in sparse.model.matrix(object, data = data, contrasts.arg = contrasts.arg,  :
  non-list contrasts argument ignored
> lines(xz[["x"]], predict(sfit, xz), col=3)
Warning in sparse.model.matrix(object, data = data, contrasts.arg = contrasts.arg,  :
  non-list contrasts argument ignored
> legend(10,2,c("Increasing","Smooth"),lty = 1, col = c(2,3))
> title("Predicted Median Response at Mean Value of z")
> 
> ## Bivariate example -- loads pkg "interp"
> if(requireNamespace("interp")){
+ if(requireNamespace("interp")){
+ data(CobarOre)
+ fit <- rqss(z ~ qss(cbind(x,y), lambda=.08),
+             data= CobarOre)
+ plot(fit, col="grey",
+      main = "CobarOre data -- rqss(z ~ qss(cbind(x,y)))")
+ T <- with(CobarOre, interp::tri.mesh(x, y))
+ set.seed(77)
+ ndum <- 100
+ xd <- with(CobarOre, runif(ndum, min(x), max(x)))
+ yd <- with(CobarOre, runif(ndum, min(y), max(y)))
+ table(s <- interp::in.convex.hull(T, xd, yd))
+ pred <- predict(fit, data.frame(x = xd[s], y = yd[s]))
+ contour(interp::interp(xd[s],yd[s], pred),
+         col="red", add = TRUE)
+ }}
> 
> 
> cleanEx()
> nameEx("q489")
> ### * q489
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: q489
> ### Title: Even Quicker Sample Quantiles
> ### Aliases: q489
> ### Keywords: univar
> 
> ### ** Examples
> 
>      medx <- q489(rnorm(1001))
> 
> 
> 
> cleanEx()
> nameEx("qrisk")
> ### * qrisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qrisk
> ### Title: Function to compute Choquet portfolio weights
> ### Aliases: qrisk
> ### Keywords: regression robust
> 
> ### ** Examples
> 
> #Fig 1:  ... of Choquet paper
>         mu1 <- .05; sig1 <- .02; mu2 <- .09; sig2 <- .07
>         x <- -10:40/100
>         u <- seq(min(c(x)),max(c(x)),length=100)
>         f1 <- dnorm(u,mu1,sig1)
>         F1 <- pnorm(u,mu1,sig1)
>         f2 <- dchisq(3-sqrt(6)*(u-mu1)/sig1,3)*(sqrt(6)/sig1)
>         F2 <- pchisq(3-sqrt(6)*(u-mu1)/sig1,3)
>         f3 <- dnorm(u,mu2,sig2)
>         F3 <- pnorm(u,mu2,sig2)
>         f4 <- dchisq(3+sqrt(6)*(u-mu2)/sig2,3)*(sqrt(6)/sig2)
>         F4 <- pchisq(3+sqrt(6)*(u-mu2)/sig2,3)
>         plot(rep(u,4),c(f1,f2,f3,f4),type="n",xlab="return",ylab="density")
>         lines(u,f1,lty=1,col="blue")
>         lines(u,f2,lty=2,col="red")
>         lines(u,f3,lty=3,col="green")
>         lines(u,f4,lty=4,col="brown")
>         legend(.25,25,paste("Asset ",1:4),lty=1:4,col=c("blue","red","green","brown"))
> #Now generate random sample of returns from these four densities.
> n <- 1000
> if(TRUE){ #generate a new returns sample if TRUE
+ 	x1 <- rnorm(n)
+ 	x1 <- (x1-mean(x1))/sqrt(var(x1))
+ 	x1 <- x1*sig1 + mu1
+ 	x2 <- -rchisq(n,3)
+ 	x2 <- (x2-mean(x2))/sqrt(var(x2))
+ 	x2 <- x2*sig1 +mu1
+ 	x3 <- rnorm(n)
+ 	x3 <- (x3-mean(x3))/sqrt(var(x3))
+ 	x3 <- x3*sig2 +mu2
+ 	x4 <- rchisq(n,3)
+ 	x4 <- (x4-mean(x4))/sqrt(var(x4))
+ 	x4 <- x4*sig2 +mu2
+ 	}
> library(quantreg)
> x <- cbind(x1,x2,x3,x4)
> qfit <- qrisk(x)
> sfit <- srisk(x)
> # Try new distortion function
> qfit1 <- qrisk(x,alpha = c(.05,.1), w = c(.9,.1),mu = 0.09)
> # Constrain portfolio weights to be non-negative
> qfit2 <- qrisk(x,alpha = c(.05,.1), w = c(.9,.1),mu = 0.09,
+ 	       R = rbind(rep(-1,3), diag(3)), r = c(-1, rep(0,3)))
> 
> 
> 
> cleanEx()
> nameEx("ranks")
> ### * ranks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranks
> ### Title: Quantile Regression Ranks
> ### Aliases: ranks
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(stackloss)
> ranks(rq(stack.loss ~ stack.x, tau=-1))
$ranks
 [1]  0.18302994 -0.01602686  0.35483163  0.45653019 -0.19694479 -0.34096965
 [7] -0.23121754 -0.01788246 -0.43795303  0.11192103  0.23876556  0.18554420
[13] -0.29336169 -0.17945242  0.36809323  0.02610216 -0.22538240 -0.01259556
[19]  0.16445517  0.29778908 -0.43527579

$A2
[1] 0.08333333

> 
> 
> 
> cleanEx()
> nameEx("rearrange")
> ### * rearrange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rearrange
> ### Title: Rearrangement
> ### Aliases: rearrange
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(engel)
> z <- rq(foodexp ~ income, tau = -1,data =engel)
> zp <- predict(z,newdata=list(income=quantile(engel$income,.03)),stepfun = TRUE)
> plot(zp,do.points = FALSE, xlab = expression(tau),
+         ylab = expression(Q ( tau )), main="Engel Food Expenditure Quantiles")
> plot(rearrange(zp),do.points = FALSE, add=TRUE,col.h="red",col.v="red")
> legend(.6,300,c("Before Rearrangement","After Rearrangement"),lty=1,col=c("black","red"))
> 
> 
> 
> cleanEx()
> nameEx("rq")
> ### * rq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rq
> ### Title: Quantile Regression
> ### Aliases: rq
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(stackloss)
> rq(stack.loss ~ stack.x,.5)  #median (l1) regression  fit for the stackloss data. 
Call:
rq(formula = stack.loss ~ stack.x, tau = 0.5)

Coefficients:
      (Intercept)   stack.xAir.Flow stack.xWater.Temp stack.xAcid.Conc. 
     -39.68985507        0.83188406        0.57391304       -0.06086957 

Degrees of freedom: 21 total; 17 residual
> rq(stack.loss ~ stack.x,.25)  #the 1st quartile, 
Call:
rq(formula = stack.loss ~ stack.x, tau = 0.25)

Coefficients:
      (Intercept)   stack.xAir.Flow stack.xWater.Temp stack.xAcid.Conc. 
     -3.60000e+01       5.00000e-01       1.00000e+00      -4.57967e-16 

Degrees of freedom: 21 total; 17 residual
>         #note that 8 of the 21 points lie exactly on this plane in 4-space! 
> rq(stack.loss ~ stack.x, tau=-1)   #this returns the full rq process
$sol
                          [,1]        [,2]          [,3]          [,4]
tau                 0.00000000   0.1240939  1.300537e-01  1.303646e-01
Qbar               13.45404984  13.9936756  1.530952e+01  1.530952e+01
Obj.Fun             0.00000000  10.6056828  1.104750e+01  1.106196e+01
(Intercept)       -29.01401869 -36.0781250 -3.600000e+01 -3.600000e+01
stack.xAir.Flow     0.31542056   0.3515625  5.000000e-01  5.000000e-01
stack.xWater.Temp   1.22429907   1.7500000  1.000000e+00  1.000000e+00
stack.xAcid.Conc.  -0.02803738  -0.0937500 -1.443290e-15 -4.758099e-16
                           [,5]          [,6]          [,7]          [,8]
tau                1.494253e-01  1.607143e-01  1.945662e-01  2.231167e-01
Qbar               1.530952e+01  1.530952e+01  1.530952e+01  1.530952e+01
Obj.Fun            1.194828e+01  1.247321e+01  1.404733e+01  1.537493e+01
(Intercept)       -3.600000e+01 -3.600000e+01 -3.600000e+01 -3.600000e+01
stack.xAir.Flow    5.000000e-01  5.000000e-01  5.000000e-01  5.000000e-01
stack.xWater.Temp  1.000000e+00  1.000000e+00  1.000000e+00  1.000000e+00
stack.xAcid.Conc. -4.758099e-16 -1.400996e-16 -8.679925e-17 -4.758099e-16
                           [,9]        [,10]       [,11]       [,12]
tau                2.539683e-01   0.27510618   0.3310042   0.3749882
Qbar               1.530952e+01  16.16141457  16.4441422  16.8013416
Obj.Fun            1.680952e+01  17.79243732  19.3916975  20.3889465
(Intercept)       -3.600000e+01 -37.89705882 -38.5266594 -32.6377709
stack.xAir.Flow    5.000000e-01   0.75735294   0.8427639   0.8250774
stack.xWater.Temp  1.000000e+00   0.79411765   0.7257889   0.7399381
stack.xAcid.Conc. -4.758099e-16  -0.09803922  -0.1305767  -0.1857585
                        [,13]        [,14]        [,15]        [,16]
tau                 0.3918757   0.40948814   0.48984468   0.56478766
Qbar               16.9593496  17.42450639  17.43436853  17.44517734
Obj.Fun            20.6451613  20.85393258  21.02150538  21.16226784
(Intercept)       -33.2461197 -39.65188470 -39.68985507 -39.73147023
stack.xAir.Flow     0.8492239   0.83037694   0.83188406   0.83353584
stack.xWater.Temp   0.6274945   0.58093126   0.57391304   0.56622114
stack.xAcid.Conc.  -0.1662971  -0.06208426  -0.06086957  -0.05953827
                        [,17]         [,18]         [,19]       [,20]
tau                 0.5923717   0.604223291   0.619988864   0.6511309
Qbar               17.4565950  19.136255092  19.137513359  19.1484286
Obj.Fun            21.2078167  21.224545264  20.690701559  19.6353667
(Intercept)       -39.6814159 -54.032448378 -54.064837905 -54.0700000
stack.xAir.Flow     0.8362832   0.873156342   0.872817955   0.8710000
stack.xWater.Temp   0.5663717   0.979351032   0.980049875   0.9840000
stack.xAcid.Conc.  -0.0619469  -0.002949853  -0.002493766  -0.0020000
                          [,21]         [,22]        [,23]        [,24]
tau                6.897262e-01  7.621009e-01   0.76843239   0.77392070
Qbar               1.915640e+01  1.919264e+01  19.71524260  19.98904006
Obj.Fun            1.831861e+01  1.583728e+01  15.61539215  15.36281938
(Intercept)       -5.418966e+01 -5.409091e+01 -54.33806147 -56.68253968
stack.xAir.Flow    8.706897e-01  8.636364e-01   0.77659574   0.78571429
stack.xWater.Temp  9.827586e-01  1.000000e+00   1.18912530   1.25396825
stack.xAcid.Conc. -5.698567e-16 -5.843653e-16   0.02364066   0.03174603
                         [,25]       [,26]        [,27]       [,28]       [,29]
tau                 0.77767777   0.8142857   0.83392070   0.9130604   1.0000000
Qbar               20.12133072  20.1607143  20.20634921  21.7007310  21.7007310
Obj.Fun            15.16831683  13.1714286  12.08414097   7.6259394   0.0000000
(Intercept)       -58.54794521 -59.3750000 -58.54331865 -58.4619970 -58.4619970
stack.xAir.Flow     0.80821918   0.8062500   0.79295154   0.5245902   0.5245902
stack.xWater.Temp   1.27397260   1.2562500   1.30543319   1.8584203   1.8584203
stack.xAcid.Conc.   0.03424658   0.0500000   0.03817915   0.1073025   0.1073025

$dsol
      [,1]       [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
 [1,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [2,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [3,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [4,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [5,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [6,]    1 1.00000000 1.0000000 0.9541788 0.6063218 0.4598214 0.0000000
 [7,]    1 1.00000000 0.9598530 1.0000000 1.0000000 1.0000000 1.0000000
 [8,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [9,]    1 0.00000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
[10,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[11,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[12,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[13,]    1 1.00000000 1.0000000 1.0000000 1.0000000 0.9107143 0.6737511
[14,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[15,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[16,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 0.8871604
[17,]    1 0.85416063 0.8306474 0.8609229 0.9589491 1.0000000 1.0000000
[18,]    1 1.00000000 1.0000000 1.0000000 0.2967980 0.2544643 0.3531989
[19,]    1 0.49869527 0.4783715 0.4472410 1.0000000 1.0000000 1.0000000
[20,]    1 1.00000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[21,]    1 0.04117135 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
           [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14]
 [1,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [2,] 1.0000000 1.0000000 1.0000000 1.0000000 0.8253325 0.7371565 0.7253433
 [3,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [4,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [5,] 1.0000000 1.0000000 1.0000000 0.0000000 0.0000000 0.0000000 0.0000000
 [6,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
 [7,] 0.7038528 0.3650794 0.1790656 0.2871626 0.1795718 0.1720430 0.0000000
 [8,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
 [9,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
[10,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 0.8202247
[11,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[12,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[13,] 0.3364002 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
[14,] 1.0000000 1.0000000 0.7003699 0.5080148 0.1203433 0.0000000 0.0000000
[15,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[16,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[17,] 1.0000000 0.8526077 0.3433347 0.2537334 0.0000000 0.0000000 0.0000000
[18,] 0.2742956 0.4489796 1.0000000 1.0000000 1.0000000 0.8614098 0.8551810
[19,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[20,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[21,] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
          [,15]     [,16]        [,17]     [,18]        [,19]     [,20]
 [1,] 1.0000000 1.0000000 1.000000e+00 1.0000000 8.887806e-01 0.6723783
 [2,] 0.6714456 0.1067666 0.000000e+00 0.0000000 0.000000e+00 0.0000000
 [3,] 1.0000000 1.0000000 1.000000e+00 1.0000000 1.000000e+00 1.0000000
 [4,] 1.0000000 1.0000000 1.000000e+00 1.0000000 1.000000e+00 1.0000000
 [5,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
 [6,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
 [7,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
 [8,] 0.2150538 0.2590420 1.254120e-01 0.0000000 0.000000e+00 0.0000000
 [9,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
[10,] 0.0000000 0.0000000 0.000000e+00 0.0000000 3.439617e-10 0.2789582
[11,] 1.0000000 1.0000000 1.000000e+00 1.0000000 1.000000e+00 1.0000000
[12,] 1.0000000 1.0000000 8.457071e-01 0.7093874 6.948775e-01 0.3749143
[13,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
[14,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
[15,] 1.0000000 1.0000000 1.000000e+00 1.0000000 1.000000e+00 1.0000000
[16,] 1.0000000 0.0000000 5.836139e-10 0.1670500 0.000000e+00 0.0000000
[17,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
[18,] 0.8267622 0.7736505 5.890755e-01 0.4348735 3.965757e-01 0.0000000
[19,] 1.0000000 1.0000000 1.000000e+00 1.0000000 1.000000e+00 1.0000000
[20,] 1.0000000 1.0000000 1.000000e+00 1.0000000 1.000000e+00 1.0000000
[21,] 0.0000000 0.0000000 0.000000e+00 0.0000000 0.000000e+00 0.0000000
          [,21]        [,22]      [,23]     [,24]     [,25]     [,26]
 [1,] 0.4395718 5.149331e-02 0.03681582 0.0000000 0.0000000 0.0000000
 [2,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
 [3,] 1.0000000 1.000000e+00 1.00000000 1.0000000 1.0000000 0.8142857
 [4,] 1.0000000 1.000000e+00 1.00000000 1.0000000 1.0000000 1.0000000
 [5,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
 [6,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
 [7,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
 [8,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
 [9,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[10,] 0.4703521 6.178052e-01 0.54665622 0.5090749 0.6273627 0.9000000
[11,] 1.0000000 3.265820e-01 0.00000000 0.0000000 0.0000000 0.0000000
[12,] 0.0000000 1.715086e-09 0.27944776 0.3048458 0.2106211 0.0000000
[13,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[14,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[15,] 1.0000000 1.000000e+00 1.00000000 0.9337445 1.0000000 1.0000000
[16,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[17,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[18,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[19,] 0.6058266 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
[20,] 1.0000000 1.000000e+00 1.00000000 1.0000000 0.8307831 0.1857143
[21,] 0.0000000 0.000000e+00 0.00000000 0.0000000 0.0000000 0.0000000
             [,27]      [,28] [,29]
 [1,] 0.000000e+00 0.00000000     0
 [2,] 0.000000e+00 0.00000000     0
 [3,] 6.850220e-01 0.02552475     0
 [4,] 1.000000e+00 1.00000000     0
 [5,] 0.000000e+00 0.00000000     0
 [6,] 0.000000e+00 0.00000000     0
 [7,] 0.000000e+00 0.00000000     0
 [8,] 0.000000e+00 0.00000000     0
 [9,] 0.000000e+00 0.00000000     0
[10,] 9.057269e-01 0.27260948     0
[11,] 0.000000e+00 0.00000000     0
[12,] 2.573799e-10 0.52759782     0
[13,] 0.000000e+00 0.00000000     0
[14,] 0.000000e+00 0.00000000     0
[15,] 8.969163e-01 0.00000000     0
[16,] 0.000000e+00 0.00000000     0
[17,] 0.000000e+00 0.00000000     0
[18,] 0.000000e+00 0.00000000     0
[19,] 0.000000e+00 0.00000000     0
[20,] 0.000000e+00 0.00000000     0
[21,] 0.000000e+00 0.00000000     0

$fitted.values
numeric(0)

$formula
stack.loss ~ stack.x

$terms
stack.loss ~ stack.x
attr(,"variables")
list(stack.loss, stack.x)
attr(,"factors")
           stack.x
stack.loss       0
stack.x          1
attr(,"term.labels")
[1] "stack.x"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
attr(,"predvars")
list(stack.loss, stack.x)
attr(,"dataClasses")
 stack.loss     stack.x 
  "numeric" "nmatrix.3" 

$xlevels
named list()

$call
rq(formula = stack.loss ~ stack.x, tau = -1)

$tau
[1] -1

$rho
$rho$tau
 [1] 0.0000000 0.1240939 0.1300537 0.1303646 0.1494253 0.1607143 0.1945662
 [8] 0.2231167 0.2539683 0.2751062 0.3310042 0.3749882 0.3918757 0.4094881
[15] 0.4898447 0.5647877 0.5923717 0.6042233 0.6199889 0.6511309 0.6897262
[22] 0.7621009 0.7684324 0.7739207 0.7776778 0.8142857 0.8339207 0.9130604
[29] 1.0000000

$rho$rho
 [1]  0.000000 10.605683 11.047498 11.061955 11.948276 12.473214 14.047327
 [8] 15.374928 16.809524 17.792437 19.391697 20.388947 20.645161 20.853933
[15] 21.021505 21.162268 21.207817 21.224545 20.690702 19.635367 18.318612
[22] 15.837281 15.615392 15.362819 15.168317 13.171429 12.084141  7.625939
[29]  0.000000


$method
[1] "br"

$model
   stack.loss stack.x.Air.Flow stack.x.Water.Temp stack.x.Acid.Conc.
1          42               80                 27                 89
2          37               80                 27                 88
3          37               75                 25                 90
4          28               62                 24                 87
5          18               62                 22                 87
6          18               62                 23                 87
7          19               62                 24                 93
8          20               62                 24                 93
9          15               58                 23                 87
10         14               58                 18                 80
11         14               58                 18                 89
12         13               58                 17                 88
13         11               58                 18                 82
14         12               58                 19                 93
15          8               50                 18                 89
16          7               50                 18                 86
17          8               50                 19                 72
18          8               50                 19                 79
19          9               50                 20                 80
20         15               56                 20                 82
21         15               70                 20                 91

attr(,"class")
[1] "rq.process"
> rq(rnorm(50) ~ 1, ci=FALSE)    #ordinary sample median --no rank inversion ci
Warning in rq.fit.br(x, y, tau = tau, ...) : Solution may be nonunique
Call:
rq(formula = rnorm(50) ~ 1, ci = FALSE)

Coefficients:
(Intercept) 
 0.07456498 

Degrees of freedom: 50 total; 49 residual
> rq(rnorm(50) ~ 1, weights=runif(50),ci=FALSE)  #weighted sample median 
Call:
rq(formula = rnorm(50) ~ 1, weights = runif(50), ci = FALSE)

Coefficients:
(Intercept) 
  0.1532533 

Degrees of freedom: 50 total; 49 residual
> #plot of engel data and some rq lines see KB(1982) for references to data
> data(engel)
> attach(engel)
> plot(income,foodexp,xlab="Household Income",ylab="Food Expenditure",type = "n", cex=.5)
> points(income,foodexp,cex=.5,col="blue")
> taus <- c(.05,.1,.25,.75,.9,.95)
> xx <- seq(min(income),max(income),100)
> f <- coef(rq((foodexp)~(income),tau=taus))
> yy <- cbind(1,xx)%*%f
> for(i in 1:length(taus)){
+         lines(xx,yy[,i],col = "gray")
+         }
> abline(lm(foodexp ~ income),col="red",lty = 2)
> abline(rq(foodexp ~ income), col="blue")
> legend(3000,500,c("mean (LSE) fit", "median (LAE) fit"),
+ 	col = c("red","blue"),lty = c(2,1))
> #Example of plotting of coefficients and their confidence bands
> plot(summary(rq(foodexp~income,tau = 1:49/50,data=engel)))
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
Warning in rq.fit.br(x, y, tau = tau, ci = TRUE, ...) :
  Solution may be nonunique
> #Example to illustrate inequality constrained fitting
> n <- 100
> p <- 5
> X <- matrix(rnorm(n*p),n,p)
> y <- .95*apply(X,1,sum)+rnorm(n)
> #constrain slope coefficients to lie between zero and one
> R <- cbind(0,rbind(diag(p),-diag(p)))
> r <- c(rep(0,p),-rep(1,p))
> rq(y~X,R=R,r=r,method="fnc")
Call:
rq(formula = y ~ X, method = "fnc", R = R, r = r)

Coefficients:
(Intercept)          X1          X2          X3          X4          X5 
 -0.3020107   0.7193971   0.9142408   0.9616210   1.0000000   1.0000000 

Degrees of freedom: 100 total; 94 residual
> 
> 
> 
> cleanEx()

detaching ‘engel’

> nameEx("rq.fit.br")
> ### * rq.fit.br
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rq.fit.br
> ### Title: Quantile Regression Fitting by Exterior Point Methods
> ### Aliases: rq.fit.br
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(stackloss)
> rq.fit.br(stack.x, stack.loss, tau=.73 ,interp=FALSE)
$coefficients
  Air.Flow Water.Temp Acid.Conc. 
 0.9408138  0.8473490 -0.6308261 

$x
      Air.Flow Water.Temp Acid.Conc.
 [1,]       80         27         89
 [2,]       80         27         88
 [3,]       75         25         90
 [4,]       62         24         87
 [5,]       62         22         87
 [6,]       62         23         87
 [7,]       62         24         93
 [8,]       62         24         93
 [9,]       58         23         87
[10,]       58         18         80
[11,]       58         18         89
[12,]       58         17         88
[13,]       58         18         82
[14,]       58         19         93
[15,]       50         18         89
[16,]       50         18         86
[17,]       50         19         72
[18,]       50         19         79
[19,]       50         20         80
[20,]       56         20         82
[21,]       70         20         91

$y
 [1] 42 37 37 28 18 18 19 20 15 14 14 13 11 12  8  7  8  8  9 15 15

$residuals
               [,1]
 [1,] -7.105427e-15
 [2,] -5.630826e+00
 [3,]  2.029593e+00
 [4,]  4.215043e+00
 [5,] -4.090259e+00
 [6,] -4.937608e+00
 [7,] -1.000000e+00
 [8,] -1.421085e-14
 [9,] -4.174353e+00
[10,] -5.353391e+00
[11,]  3.240444e-01
[12,] -4.594328e-01
[13,] -7.091739e+00
[14,] -1.421085e-14
[15,]  1.850555e+00
[16,] -1.041924e+00
[17,] -9.720838e+00
[18,] -5.305055e+00
[19,] -4.521578e+00
[20,] -2.904809e+00
[21,] -1.039877e+01

$dual
 [1] 0.4680234 0.0000000 1.0000000 1.0000000 0.0000000 0.0000000 0.0000000
 [8] 0.6115931 0.0000000 0.0000000 1.0000000 0.0000000 0.0000000 0.3839544
[15] 1.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000

> 
> 
> 
> cleanEx()
> nameEx("rq.fit.lasso")
> ### * rq.fit.lasso
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rq.fit.lasso
> ### Title: Lasso Penalized Quantile Regression
> ### Aliases: rq.fit.lasso
> ### Keywords: regression
> 
> ### ** Examples
> 
> n <- 60
> p <- 7
> rho <- .5
> beta <- c(3,1.5,0,2,0,0,0)
> R <- matrix(0,p,p)
> for(i in 1:p){
+         for(j in 1:p){
+                 R[i,j] <- rho^abs(i-j)
+                 }
+         }
> set.seed(1234)
> x <- matrix(rnorm(n*p),n,p) %*% t(chol(R))
> y <- x %*% beta + rnorm(n)
> 
> f <- rq(y ~ x, method="lasso",lambda = 30)
> g <- rq(y ~ x, method="lasso",lambda = c(rep(0,4),rep(30,4)))
> 
> 
> 
> cleanEx()
> nameEx("rq.fit.scad")
> ### * rq.fit.scad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rq.fit.scad
> ### Title: SCADPenalized Quantile Regression
> ### Aliases: rq.fit.scad
> ### Keywords: regression
> 
> ### ** Examples
> 
> n <- 60
> p <- 7
> rho <- .5
> beta <- c(3,1.5,0,2,0,0,0)
> R <- matrix(0,p,p)
> for(i in 1:p){
+         for(j in 1:p){
+                 R[i,j] <- rho^abs(i-j)
+                 }
+         }
> set.seed(1234)
> x <- matrix(rnorm(n*p),n,p) %*% t(chol(R))
> y <- x %*% beta + rnorm(n)
> 
> f <- rq(y ~ x, method="scad",lambda = 30)
> g <- rq(y ~ x, method="scad", start = "lasso", lambda = 30)
> 
> 
> 
> cleanEx()
> nameEx("rq.fit.sfn")
> ### * rq.fit.sfn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rq.fit.sfn
> ### Title: Sparse Regression Quantile Fitting
> ### Aliases: rq.fit.sfn sfnMessage
> ### Keywords: regression
> 
> ### ** Examples
> 
> ## An artificial example :
> n <- 200
> p <- 50
> set.seed(101)
> X <- rnorm(n*p)
> X[abs(X) < 2.0] <- 0
> X <- cbind(1, matrix(X, n, p))
> y <- 0.5 * apply(X,1,sum) + rnorm(n) ## true beta = (0.5, 0.5, ...)
> 
> sX <- as.matrix.csr(X)
> try(rq.o <- rq.fit.sfn(sX, y)) #-> not enough tmp memory
> (tmpmax <- floor(1e5 + exp(-12.1)*(sX@ia[p+1]-1)^2.35))
[1] 1e+05
> ## now ok:
> rq.o <- rq.fit.sfn(sX, y, control = list(tmpmax= tmpmax))
> 
> 
> 
> cleanEx()
> nameEx("rq.fit.sfnc")
> ### * rq.fit.sfnc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rq.fit.sfnc
> ### Title: Sparse Constrained Regression Quantile Fitting
> ### Aliases: rq.fit.sfnc
> ### Keywords: regression
> 
> ### ** Examples
> 
> ## An artificial example :
> n <- 200
> p <- 50
> set.seed(17)
> X <- rnorm(n*p)
> X[abs(X) < 2.0] <- 0
> X <- cbind(1,matrix(X,n,p))
> y <- 0.5 * apply(X,1,sum) + rnorm(n) ## true beta = (0.5, 0.5, ...)
> R <- rbind(diag(p+1), -diag(p+1))
> r <- c(rep( 0, p+1), rep(-1, p+1))
> 
> sX <- as.matrix.csr(X)
> sR <- as.matrix.csr(R)
> try(rq.o <- rq.fit.sfnc(sX, y, sR, r)) #-> not enough tmp memory
Error in .local(x, ...) : Increase tmpmax
> 
> (tmpmax <- floor(1e5 + exp(-12.1)*(sX@ia[p+1]-1)^2.35))
[1] 1e+05
> ## now ok:
> rq.o <- rq.fit.sfnc(sX, y, sR, r, control = list(tmpmax = tmpmax))
> 
> 
> 
> cleanEx()
> nameEx("rqss")
> ### * rqss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rqss
> ### Title: Additive Quantile Regression Smoothing
> ### Aliases: rqss rqss.fit [.terms untangle.specials
> ### Keywords: regression smooth robust
> 
> ### ** Examples
> 
> n <- 200
> x <- sort(rchisq(n,4))
> z <- x + rnorm(n)
> y <- log(x)+ .1*(log(x))^2 + log(x)*rnorm(n)/4 + z
> plot(x, y-z)
> f.N  <- rqss(y ~ qss(x, constraint= "N") + z)
> f.I  <- rqss(y ~ qss(x, constraint= "I") + z)
> f.CI <- rqss(y ~ qss(x, constraint= "CI") + z)
> 
> lines(x[-1], f.N $coef[1] + f.N $coef[-(1:2)])
> lines(x[-1], f.I $coef[1] + f.I $coef[-(1:2)], col="blue")
> lines(x[-1], f.CI$coef[1] + f.CI$coef[-(1:2)], col="red")
> 
> ## A bivariate example
> if(requireNamespace("interp")){
+ if(requireNamespace("interp")){
+ data(CobarOre)
+ fCO <- rqss(z ~ qss(cbind(x,y), lambda= .08), data=CobarOre)
+ plot(fCO)
+ }}
> 
> 
> cleanEx()
> nameEx("rqss.object")
> ### * rqss.object
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rqss.object
> ### Title: RQSS Objects and Summarization Thereof
> ### Aliases: rqss.object logLik.rqss AIC.rqss fitted.rqss resid.rqss
> ###   print.rqss
> ### Keywords: regression smooth robust
> 
> ### ** Examples
> 
> require(MatrixModels)
Loading required package: MatrixModels
> n <- 200
> x <- sort(rchisq(n,4))
> z <- x + rnorm(n)
> y <- log(x)+ .1*(log(x))^2 + log(x)*rnorm(n)/4 + z
> plot(x, y-z)
> f.N  <- rqss(y ~ qss(x, constraint= "N") + z)
> f.I  <- rqss(y ~ qss(x, constraint= "I") + z)
> f.CI <- rqss(y ~ qss(x, constraint= "CI") + z)
> 
> lines(x[-1], f.N $coef[1] + f.N $coef[-(1:2)])
> lines(x[-1], f.I $coef[1] + f.I $coef[-(1:2)], col="blue")
> lines(x[-1], f.CI$coef[1] + f.CI$coef[-(1:2)], col="red")
> 
> ## A bivariate example
> if(requireNamespace("interp")){
+ if(requireNamespace("interp")){
+ data(CobarOre)
+ fCO <- rqss(z ~ qss(cbind(x,y), lambda= .08), data=CobarOre)
+ plot(fCO)
+ }}
> 
> 
> cleanEx()

detaching ‘package:MatrixModels’

> nameEx("summary.rq")
> ### * summary.rq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.rq
> ### Title: Summary methods for Quantile Regression
> ### Aliases: summary.rq summary.rqs summary.rcrqs
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(stackloss)
> y <- stack.loss
> x <- stack.x
> summary(rq(y ~ x, method="fn")) # Compute se's for fit using "nid" method.

Call: rq(formula = y ~ x, method = "fn")

tau: [1] 0.5

Coefficients:
            coefficients lower bd  upper bd 
(Intercept) -39.68986    -41.61973 -29.67754
xAir.Flow     0.83188      0.51278   1.14117
xWater.Temp   0.57391      0.32182   1.41090
xAcid.Conc.  -0.06087     -0.21348  -0.02891
> summary(rq(y ~ x, ci=FALSE),se="ker")

Call: rq(formula = y ~ x, ci = FALSE)

tau: [1] 0.5

Coefficients:
            Value     Std. Error t value   Pr(>|t|) 
(Intercept) -39.68986  14.05974   -2.82294   0.01172
xAir.Flow     0.83188   0.24350    3.41632   0.00329
xWater.Temp   0.57391   0.57894    0.99131   0.33543
xAcid.Conc.  -0.06087   0.18142   -0.33551   0.74134
> # default "br" alg, and compute kernel method se's
> 
> 
> 
> cleanEx()
> nameEx("summary.rqss")
> ### * summary.rqss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.rqss
> ### Title: Summary of rqss fit
> ### Aliases: summary.rqss print.summary.rqss
> ### Keywords: regression smooth robust
> 
> ### ** Examples
> 
> n <- 200
> x <- sort(rchisq(n,4))
> z <- x + rnorm(n)
> y <- log(x)+ .1*(log(x))^2 + log(x)*rnorm(n)/4 + z
> f  <- rqss(y ~ qss(x) + z)
> summary(f)
Formula:
y ~ qss(x) + z

Parametric coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) -1.01145    0.21286  -4.752    4e-06 ***
z            0.99983    0.02912  34.335   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Approximate significance of qss terms:
  EDF Lambda Penalty F value Pr(>F)    
x   9      1   1.386   34.23 <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

  Quantile Fidelity at tau = 0.5  is      23.7664
  Effective Degrees of Freedom = 12        Sample Size = 200
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.331 1.563 3.207 0 0 
> grDevices::dev.off()
pdf 
  2 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
