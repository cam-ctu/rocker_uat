
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "igraph"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('igraph')

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("E")
> ### * E
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: E
> ### Title: Edges of a graph
> ### Aliases: E
> 
> ### ** Examples
> 
> # Edges of an unnamed graph
> g <- make_ring(10)
> E(g)
+ 10/10 edges from b4b8660:
 [1] 1-- 2 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 9--10 1--10
> 
> # Edges of a named graph
> g2 <- make_ring(10) %>%
+   set_vertex_attr("name", value = letters[1:10])
> E(g2)
+ 10/10 edges from 6782af2 (vertex names):
 [1] a--b b--c c--d d--e e--f f--g g--h h--i i--j a--j
> 
> 
> 
> cleanEx()
> nameEx("V")
> ### * V
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: V
> ### Title: Vertices of a graph
> ### Aliases: V
> 
> ### ** Examples
> 
> # Vertex ids of an unnamed graph
> g <- make_ring(10)
> V(g)
+ 10/10 vertices, from afa083f:
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> # Vertex ids of a named graph
> g2 <- make_ring(10) %>%
+   set_vertex_attr("name", value = letters[1:10])
> V(g2)
+ 10/10 vertices, named, from a254ad6:
 [1] a b c d e f g h i j
> 
> 
> 
> cleanEx()
> nameEx("add_edges")
> ### * add_edges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_edges
> ### Title: Add edges to a graph
> ### Aliases: add_edges
> 
> ### ** Examples
> 
> g <- make_empty_graph(n = 5) %>%
+   add_edges(c(
+     1, 2,
+     2, 3,
+     3, 4,
+     4, 5
+   )) %>%
+   set_edge_attr("color", value = "red") %>%
+   add_edges(c(5, 1), color = "green")
> E(g)[[]]
+ 5/5 edges from 6ab625a:
  tail head tid hid color
1    1    2   1   2   red
2    2    3   2   3   red
3    3    4   3   4   red
4    4    5   4   5   red
5    5    1   5   1 green
> plot(g)
> 
> 
> 
> cleanEx()
> nameEx("add_layout_")
> ### * add_layout_
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_layout_
> ### Title: Add layout to graph
> ### Aliases: add_layout_
> 
> ### ** Examples
> 
> (make_star(11) + make_star(11)) %>%
+   add_layout_(as_star(), component_wise()) %>%
+   plot()
> 
> 
> 
> cleanEx()
> nameEx("add_vertices")
> ### * add_vertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_vertices
> ### Title: Add vertices to a graph
> ### Aliases: add_vertices
> 
> ### ** Examples
> 
> g <- make_empty_graph() %>%
+   add_vertices(3, color = "red") %>%
+   add_vertices(2, color = "green") %>%
+   add_edges(c(
+     1, 2,
+     2, 3,
+     3, 4,
+     4, 5
+   ))
> g
IGRAPH 490ebc1 D--- 5 4 -- 
+ attr: color (v/c)
+ edges from 490ebc1:
[1] 1->2 2->3 3->4 4->5
> V(g)[[]]
+ 5/5 vertices, from 490ebc1:
  color
1   red
2   red
3   red
4 green
5 green
> plot(g)
> 
> 
> 
> cleanEx()
> nameEx("adjacent_vertices")
> ### * adjacent_vertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adjacent_vertices
> ### Title: Adjacent vertices of multiple vertices in a graph
> ### Aliases: adjacent_vertices
> 
> ### ** Examples
> 
> g <- make_graph("Zachary")
> adjacent_vertices(g, c(1, 34))
[[1]]
+ 16/34 vertices, from 02803af:
 [1]  2  3  4  5  6  7  8  9 11 12 13 14 18 20 22 32

[[2]]
+ 17/34 vertices, from 02803af:
 [1]  9 10 14 15 16 19 20 21 23 24 27 28 29 30 31 32 33

> 
> 
> 
> cleanEx()
> nameEx("all_simple_paths")
> ### * all_simple_paths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all_simple_paths
> ### Title: List all simple paths from one source
> ### Aliases: all_simple_paths
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> all_simple_paths(g, 1, 5)
[[1]]
+ 5/10 vertices, from 23b6aa2:
[1] 1 2 3 4 5

[[2]]
+ 7/10 vertices, from 23b6aa2:
[1]  1 10  9  8  7  6  5

> all_simple_paths(g, 1, c(3, 5))
[[1]]
+ 3/10 vertices, from 23b6aa2:
[1] 1 2 3

[[2]]
+ 5/10 vertices, from 23b6aa2:
[1] 1 2 3 4 5

[[3]]
+ 7/10 vertices, from 23b6aa2:
[1]  1 10  9  8  7  6  5

[[4]]
+ 9/10 vertices, from 23b6aa2:
[1]  1 10  9  8  7  6  5  4  3

> 
> 
> 
> 
> cleanEx()
> nameEx("alpha_centrality")
> ### * alpha_centrality
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alpha_centrality
> ### Title: Find Bonacich alpha centrality scores of network positions
> ### Aliases: alpha_centrality
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # The examples from Bonacich's paper
> g.1 <- make_graph(c(1, 3, 2, 3, 3, 4, 4, 5))
> g.2 <- make_graph(c(2, 1, 3, 1, 4, 1, 5, 1))
> g.3 <- make_graph(c(1, 2, 2, 3, 3, 4, 4, 1, 5, 1))
> alpha_centrality(g.1)
[1] 1 1 3 4 5
> alpha_centrality(g.2)
[1] 5 1 1 1 1
> alpha_centrality(g.3, alpha = 0.5)
[1] 2.533333 2.266667 2.133333 2.066667 1.000000
> 
> 
> 
> 
> cleanEx()
> nameEx("are_adjacent")
> ### * are_adjacent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: are_adjacent
> ### Title: Are two vertices adjacent?
> ### Aliases: are_adjacent
> 
> ### ** Examples
> 
> ug <- make_ring(10)
> ug
IGRAPH ef0ad70 U--- 10 10 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from ef0ad70:
 [1] 1-- 2 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 9--10 1--10
> are_adjacent(ug, 1, 2)
[1] TRUE
> are_adjacent(ug, 2, 1)
[1] TRUE
> 
> dg <- make_ring(10, directed = TRUE)
> dg
IGRAPH 116c1cc D--- 10 10 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from 116c1cc:
 [1]  1-> 2  2-> 3  3-> 4  4-> 5  5-> 6  6-> 7  7-> 8  8-> 9  9->10 10-> 1
> are_adjacent(ug, 1, 2)
[1] TRUE
> are_adjacent(ug, 2, 1)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("arpack")
> ### * arpack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arpack_defaults
> ### Title: ARPACK eigenvector calculation
> ### Aliases: arpack_defaults arpack arpack-options arpack.unpack.complex
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # Identity matrix
> f <- function(x, extra = NULL) x
> arpack(f, options = list(n = 10, nev = 2, ncv = 4), sym = TRUE)
$values
[1] 1 1

$vectors
             [,1]        [,2]
 [1,] -0.24403929  0.20548390
 [2,] -0.13308292 -0.01205712
 [3,]  0.07581979 -0.52564302
 [4,]  0.42482908 -0.48916037
 [5,] -0.31046490  0.03860961
 [6,]  0.41461120 -0.13389082
 [7,]  0.46278143  0.56555129
 [8,]  0.16734511 -0.12882603
 [9,]  0.13437127  0.20452422
[10,] -0.45605679 -0.21061937

$options
$options$bmat
[1] "I"

$options$n
[1] 10

$options$which
[1] "XX"

$options$nev
[1] 2

$options$tol
[1] 0

$options$ncv
[1] 4

$options$ldv
[1] 0

$options$ishift
[1] 1

$options$maxiter
[1] 3000

$options$nb
[1] 1

$options$mode
[1] 1

$options$start
[1] 0

$options$sigma
[1] 0

$options$sigmai
[1] 0

$options$info
[1] 0

$options$iter
[1] 1

$options$nconv
[1] 2

$options$numop
[1] 4

$options$numopb
[1] 0

$options$numreo
[1] 4


> 
> # Graph laplacian of a star graph (undirected), n>=2
> # Note that this is a linear operation
> f <- function(x, extra = NULL) {
+   y <- x
+   y[1] <- (length(x) - 1) * x[1] - sum(x[-1])
+   for (i in 2:length(x)) {
+     y[i] <- x[i] - x[1]
+   }
+   y
+ }
> 
> arpack(f, options = list(n = 10, nev = 1, ncv = 3), sym = TRUE)
$values
[1] 10

$vectors
 [1]  0.9486833 -0.1054093 -0.1054093 -0.1054093 -0.1054093 -0.1054093
 [7] -0.1054093 -0.1054093 -0.1054093 -0.1054093

$options
$options$bmat
[1] "I"

$options$n
[1] 10

$options$which
[1] "XX"

$options$nev
[1] 1

$options$tol
[1] 0

$options$ncv
[1] 3

$options$ldv
[1] 0

$options$ishift
[1] 1

$options$maxiter
[1] 3000

$options$nb
[1] 1

$options$mode
[1] 1

$options$start
[1] 0

$options$sigma
[1] 0

$options$sigmai
[1] 0

$options$info
[1] 0

$options$iter
[1] 1

$options$nconv
[1] 1

$options$numop
[1] 3

$options$numopb
[1] 0

$options$numreo
[1] 2


> 
> # double check
> eigen(laplacian_matrix(make_star(10, mode = "undirected")))
eigen() decomposition
$values
 [1] 1.000000e+01 1.000000e+00 1.000000e+00 1.000000e+00 1.000000e+00
 [6] 1.000000e+00 1.000000e+00 1.000000e+00 1.000000e+00 3.552714e-15

$vectors
            [,1]          [,2]         [,3]          [,4]          [,5]
 [1,]  0.9486833  0.000000e+00  0.000000000  0.000000e+00  0.000000e+00
 [2,] -0.1054093  9.251859e-18  0.000000000 -9.251859e-18  1.850372e-17
 [3,] -0.1054093 -9.316303e-02  0.079217213 -5.526928e-02 -5.860537e-02
 [4,] -0.1054093  9.295069e-01  0.020878444 -5.681485e-02  2.420873e-02
 [5,] -0.1054093 -1.772059e-01 -0.072634120 -1.521102e-01  1.990548e-02
 [6,] -0.1054093 -1.772059e-01  0.014765896  3.109043e-01  1.456789e-01
 [7,] -0.1054093 -1.246177e-01  0.008447773  6.043444e-02  8.117572e-01
 [8,] -0.1054093 -6.376015e-02 -0.659513765  4.360577e-01 -3.697494e-01
 [9,] -0.1054093 -1.772059e-01 -0.124196522 -7.876367e-01 -2.016864e-01
[10,] -0.1054093 -1.163484e-01  0.733035080  2.444346e-01 -3.715091e-01
               [,6]        [,7]       [,8]          [,9]      [,10]
 [1,]  0.000000e+00  0.00000000  0.0000000  0.000000e+00 -0.3162278
 [2,]  9.251859e-18  0.00000000  0.9428090  6.476301e-17 -0.3162278
 [3,]  3.877514e-02  0.07938499 -0.1178511  9.196470e-01 -0.3162278
 [4,]  2.633343e-02  0.05841931 -0.1178511 -5.158318e-02 -0.3162278
 [5,]  8.820081e-01 -0.01683834 -0.1178511 -1.912244e-01 -0.3162278
 [6,] -1.516578e-01  0.81604496 -0.1178511 -1.912244e-01 -0.3162278
 [7,] -1.927091e-01 -0.39623153 -0.1178511 -5.158318e-02 -0.3162278
 [8,] -1.420878e-01 -0.29370999 -0.1178511 -5.158318e-02 -0.3162278
 [9,] -3.596255e-01  0.03503021 -0.1178511 -1.912244e-01 -0.3162278
[10,] -1.010365e-01 -0.28209962 -0.1178511 -1.912244e-01 -0.3162278

> 
> ## First three eigenvalues of the adjacency matrix of a graph
> ## We need the 'Matrix' package for this
> if (require(Matrix)) {
+   set.seed(42)
+   g <- sample_gnp(1000, 5 / 1000)
+   M <- as_adj(g, sparse = TRUE)
+   f2 <- function(x, extra = NULL) {
+     cat(".")
+     as.vector(M %*% x)
+   }
+   baev <- arpack(f2, sym = TRUE, options = list(
+     n = vcount(g), nev = 3, ncv = 8,
+     which = "LM", maxiter = 2000
+   ))
+ }
Loading required package: Matrix
.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................> 
> 
> 
> cleanEx()

detaching ‘package:Matrix’

> nameEx("articulation_points")
> ### * articulation_points
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: articulation_points
> ### Title: Articulation points and bridges of a graph
> ### Aliases: articulation_points bridges
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- disjoint_union(make_full_graph(5), make_full_graph(5))
> clu <- components(g)$membership
> g <- add_edges(g, c(match(1, clu), match(2, clu)))
> articulation_points(g)
+ 2/10 vertices, from d9b98d1:
[1] 6 1
> 
> g <- make_graph("krackhardt_kite")
> bridges(g)
+ 2/18 edges from f03b378:
[1] 9--10 8-- 9
> 
> 
> 
> 
> cleanEx()
> nameEx("as.directed")
> ### * as.directed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.directed
> ### Title: Convert between directed and undirected graphs
> ### Aliases: as.directed as.undirected
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> as.directed(g, "mutual")
IGRAPH 3b82f0c D--- 10 20 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from 3b82f0c:
 [1]  1-> 2  2-> 3  3-> 4  4-> 5  5-> 6  6-> 7  7-> 8  8-> 9  9->10  1->10
[11]  2-> 1  3-> 2  4-> 3  5-> 4  6-> 5  7-> 6  8-> 7  9-> 8 10-> 9 10-> 1
> g2 <- make_star(10)
> as.undirected(g)
IGRAPH b218bb2 U--- 10 10 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from b218bb2:
 [1] 1-- 2 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 9--10 1--10
> 
> # Combining edge attributes
> g3 <- make_ring(10, directed = TRUE, mutual = TRUE)
> E(g3)$weight <- seq_len(ecount(g3))
> ug3 <- as.undirected(g3)
> print(ug3, e = TRUE)
IGRAPH 94b0210 U-W- 10 10 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l), weight (e/n)
+ edges from 94b0210:
 [1] 1-- 2 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 1--10 9--10
> ## Don't show: 
> if (rlang::is_interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ x11(width = 10, height = 5)
+ layout(rbind(1:2))
+ plot(g3, layout = layout_in_circle, edge.label = E(g3)$weight)
+ plot(ug3, layout = layout_in_circle, edge.label = E(ug3)$weight)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> g4 <- make_graph(c(
+   1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 4,
+   6, 7, 7, 6, 7, 8, 7, 8, 8, 7, 8, 9, 8, 9,
+   9, 8, 9, 8, 9, 9, 10, 10, 10, 10
+ ))
> E(g4)$weight <- seq_len(ecount(g4))
> ug4 <- as.undirected(g4,
+   mode = "mutual",
+   edge.attr.comb = list(weight = length)
+ )
> print(ug4, e = TRUE)
IGRAPH c8cfc2e U-W- 10 7 -- 
+ attr: weight (e/n)
+ edges from c8cfc2e:
[1]  6-- 7  7-- 8  8-- 9  8-- 9  9-- 9 10--10 10--10
> 
> 
> 
> 
> cleanEx()
> nameEx("as.igraph")
> ### * as.igraph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.igraph
> ### Title: Conversion to igraph
> ### Aliases: as.igraph as.igraph.igraphHRG
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_full_graph(5) + make_full_graph(5)
> hrg <- fit_hrg(g)
> as.igraph(hrg)
IGRAPH 7f6a4f5 DN-- 19 18 -- Fitted HRG
+ attr: name (g/c), name (v/c), prob (v/n)
+ edges from 7f6a4f5 (vertex names):
 [1] g1->g2 g2->g3 g3->g5 g4->3  g5->1  g6->g9 g7->9  g8->7  g9->6  g1->g6
[11] g2->g4 g3->2  g4->5  g5->4  g6->g7 g7->10 g8->8  g9->g8
> 
> 
> 
> 
> cleanEx()
> nameEx("as.matrix.igraph")
> ### * as.matrix.igraph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.matrix.igraph
> ### Title: Convert igraph objects to adjacency or edge list matrices
> ### Aliases: as.matrix.igraph
> 
> ### ** Examples
> 
> 
> g <- make_graph("zachary")
> as.matrix(g, "adjacency")
34 x 34 sparse Matrix of class "dgCMatrix"
                                                                         
 [1,] . 1 1 1 1 1 1 1 1 . 1 1 1 1 . . . 1 . 1 . 1 . . . . . . . . . 1 . .
 [2,] 1 . 1 1 . . . 1 . . . . . 1 . . . 1 . 1 . 1 . . . . . . . . 1 . . .
 [3,] 1 1 . 1 . . . 1 1 1 . . . 1 . . . . . . . . . . . . . 1 1 . . . 1 .
 [4,] 1 1 1 . . . . 1 . . . . 1 1 . . . . . . . . . . . . . . . . . . . .
 [5,] 1 . . . . . 1 . . . 1 . . . . . . . . . . . . . . . . . . . . . . .
 [6,] 1 . . . . . 1 . . . 1 . . . . . 1 . . . . . . . . . . . . . . . . .
 [7,] 1 . . . 1 1 . . . . . . . . . . 1 . . . . . . . . . . . . . . . . .
 [8,] 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 [9,] 1 . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 1
[10,] . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
[11,] 1 . . . 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
[12,] 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
[13,] 1 . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
[14,] 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
[15,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1
[16,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1
[17,] . . . . . 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . .
[18,] 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
[19,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1
[20,] 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
[21,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1
[22,] 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
[23,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1
[24,] . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 . 1 . . 1 1
[25,] . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 . . . 1 . .
[26,] . . . . . . . . . . . . . . . . . . . . . . . 1 1 . . . . . . 1 . .
[27,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . . . 1
[28,] . . 1 . . . . . . . . . . . . . . . . . . . . 1 1 . . . . . . . . 1
[29,] . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1
[30,] . . . . . . . . . . . . . . . . . . . . . . . 1 . . 1 . . . . . 1 1
[31,] . 1 . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . 1 1
[32,] 1 . . . . . . . . . . . . . . . . . . . . . . . 1 1 . . 1 . . . 1 1
[33,] . . 1 . . . . . 1 . . . . . 1 1 . . 1 . 1 . 1 1 . . . . . 1 1 1 . 1
[34,] . . . . . . . . 1 1 . . . 1 1 1 . . 1 1 1 . 1 1 . . 1 1 1 1 1 1 1 .
> as.matrix(g, "edgelist")
      [,1] [,2]
 [1,]    1    2
 [2,]    1    3
 [3,]    1    4
 [4,]    1    5
 [5,]    1    6
 [6,]    1    7
 [7,]    1    8
 [8,]    1    9
 [9,]    1   11
[10,]    1   12
[11,]    1   13
[12,]    1   14
[13,]    1   18
[14,]    1   20
[15,]    1   22
[16,]    1   32
[17,]    2    3
[18,]    2    4
[19,]    2    8
[20,]    2   14
[21,]    2   18
[22,]    2   20
[23,]    2   22
[24,]    2   31
[25,]    3    4
[26,]    3    8
[27,]    3   28
[28,]    3   29
[29,]    3   33
[30,]    3   10
[31,]    3    9
[32,]    3   14
[33,]    4    8
[34,]    4   13
[35,]    4   14
[36,]    5    7
[37,]    5   11
[38,]    6    7
[39,]    6   11
[40,]    6   17
[41,]    7   17
[42,]    9   31
[43,]    9   33
[44,]    9   34
[45,]   10   34
[46,]   14   34
[47,]   15   33
[48,]   15   34
[49,]   16   33
[50,]   16   34
[51,]   19   33
[52,]   19   34
[53,]   20   34
[54,]   21   33
[55,]   21   34
[56,]   23   33
[57,]   23   34
[58,]   24   26
[59,]   24   28
[60,]   24   33
[61,]   24   34
[62,]   24   30
[63,]   25   26
[64,]   25   28
[65,]   25   32
[66,]   26   32
[67,]   27   30
[68,]   27   34
[69,]   28   34
[70,]   29   32
[71,]   29   34
[72,]   30   33
[73,]   30   34
[74,]   31   33
[75,]   31   34
[76,]   32   33
[77,]   32   34
[78,]   33   34
> # use edge attribute "weight"
> E(g)$weight <- rep(1:10, length.out = ecount(g))
> as.matrix(g, "adjacency", sparse = FALSE, attr = "weight")
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]    0    1    2    3    4    5    6    7    8     0     9    10     1
 [2,]    1    0    7    8    0    0    0    9    0     0     0     0     0
 [3,]    2    7    0    5    0    0    0    6    1    10     0     0     0
 [4,]    3    8    5    0    0    0    0    3    0     0     0     0     4
 [5,]    4    0    0    0    0    0    6    0    0     0     7     0     0
 [6,]    5    0    0    0    0    0    8    0    0     0     9     0     0
 [7,]    6    0    0    0    6    8    0    0    0     0     0     0     0
 [8,]    7    9    6    3    0    0    0    0    0     0     0     0     0
 [9,]    8    0    1    0    0    0    0    0    0     0     0     0     0
[10,]    0    0   10    0    0    0    0    0    0     0     0     0     0
[11,]    9    0    0    0    7    9    0    0    0     0     0     0     0
[12,]   10    0    0    0    0    0    0    0    0     0     0     0     0
[13,]    1    0    0    4    0    0    0    0    0     0     0     0     0
[14,]    2   10    2    5    0    0    0    0    0     0     0     0     0
[15,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[16,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[17,]    0    0    0    0    0   10    1    0    0     0     0     0     0
[18,]    3    1    0    0    0    0    0    0    0     0     0     0     0
[19,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[20,]    4    2    0    0    0    0    0    0    0     0     0     0     0
[21,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[22,]    5    3    0    0    0    0    0    0    0     0     0     0     0
[23,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[24,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[25,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[26,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[27,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[28,]    0    0    7    0    0    0    0    0    0     0     0     0     0
[29,]    0    0    8    0    0    0    0    0    0     0     0     0     0
[30,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[31,]    0    4    0    0    0    0    0    0    2     0     0     0     0
[32,]    6    0    0    0    0    0    0    0    0     0     0     0     0
[33,]    0    0    9    0    0    0    0    0    3     0     0     0     0
[34,]    0    0    0    0    0    0    0    0    4     5     0     0     0
      [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25]
 [1,]     2     0     0     0     3     0     4     0     5     0     0     0
 [2,]    10     0     0     0     1     0     2     0     3     0     0     0
 [3,]     2     0     0     0     0     0     0     0     0     0     0     0
 [4,]     5     0     0     0     0     0     0     0     0     0     0     0
 [5,]     0     0     0     0     0     0     0     0     0     0     0     0
 [6,]     0     0     0    10     0     0     0     0     0     0     0     0
 [7,]     0     0     0     1     0     0     0     0     0     0     0     0
 [8,]     0     0     0     0     0     0     0     0     0     0     0     0
 [9,]     0     0     0     0     0     0     0     0     0     0     0     0
[10,]     0     0     0     0     0     0     0     0     0     0     0     0
[11,]     0     0     0     0     0     0     0     0     0     0     0     0
[12,]     0     0     0     0     0     0     0     0     0     0     0     0
[13,]     0     0     0     0     0     0     0     0     0     0     0     0
[14,]     0     0     0     0     0     0     0     0     0     0     0     0
[15,]     0     0     0     0     0     0     0     0     0     0     0     0
[16,]     0     0     0     0     0     0     0     0     0     0     0     0
[17,]     0     0     0     0     0     0     0     0     0     0     0     0
[18,]     0     0     0     0     0     0     0     0     0     0     0     0
[19,]     0     0     0     0     0     0     0     0     0     0     0     0
[20,]     0     0     0     0     0     0     0     0     0     0     0     0
[21,]     0     0     0     0     0     0     0     0     0     0     0     0
[22,]     0     0     0     0     0     0     0     0     0     0     0     0
[23,]     0     0     0     0     0     0     0     0     0     0     0     0
[24,]     0     0     0     0     0     0     0     0     0     0     0     0
[25,]     0     0     0     0     0     0     0     0     0     0     0     0
[26,]     0     0     0     0     0     0     0     0     0     0     8     3
[27,]     0     0     0     0     0     0     0     0     0     0     0     0
[28,]     0     0     0     0     0     0     0     0     0     0     9     4
[29,]     0     0     0     0     0     0     0     0     0     0     0     0
[30,]     0     0     0     0     0     0     0     0     0     0     2     0
[31,]     0     0     0     0     0     0     0     0     0     0     0     0
[32,]     0     0     0     0     0     0     0     0     0     0     0     5
[33,]     0     7     9     0     0     1     0     4     0     6    10     0
[34,]     6     8    10     0     0     2     3     5     0     7     1     0
      [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34]
 [1,]     0     0     0     0     0     0     6     0     0
 [2,]     0     0     0     0     0     4     0     0     0
 [3,]     0     0     7     8     0     0     0     9     0
 [4,]     0     0     0     0     0     0     0     0     0
 [5,]     0     0     0     0     0     0     0     0     0
 [6,]     0     0     0     0     0     0     0     0     0
 [7,]     0     0     0     0     0     0     0     0     0
 [8,]     0     0     0     0     0     0     0     0     0
 [9,]     0     0     0     0     0     2     0     3     4
[10,]     0     0     0     0     0     0     0     0     5
[11,]     0     0     0     0     0     0     0     0     0
[12,]     0     0     0     0     0     0     0     0     0
[13,]     0     0     0     0     0     0     0     0     0
[14,]     0     0     0     0     0     0     0     0     6
[15,]     0     0     0     0     0     0     0     7     8
[16,]     0     0     0     0     0     0     0     9    10
[17,]     0     0     0     0     0     0     0     0     0
[18,]     0     0     0     0     0     0     0     0     0
[19,]     0     0     0     0     0     0     0     1     2
[20,]     0     0     0     0     0     0     0     0     3
[21,]     0     0     0     0     0     0     0     4     5
[22,]     0     0     0     0     0     0     0     0     0
[23,]     0     0     0     0     0     0     0     6     7
[24,]     8     0     9     0     2     0     0    10     1
[25,]     3     0     4     0     0     0     5     0     0
[26,]     0     0     0     0     0     0     6     0     0
[27,]     0     0     0     0     7     0     0     0     8
[28,]     0     0     0     0     0     0     0     0     9
[29,]     0     0     0     0     0     0    10     0     1
[30,]     0     7     0     0     0     0     0     2     3
[31,]     0     0     0     0     0     0     0     4     5
[32,]     6     0     0    10     0     0     0     6     7
[33,]     0     0     0     0     2     4     6     0     8
[34,]     0     8     9     1     3     5     7     8     0
> 
> 
> 
> 
> cleanEx()
> nameEx("as_adj_list")
> ### * as_adj_list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_adj_list
> ### Title: Adjacency lists
> ### Aliases: as_adj_list as_adj_edge_list
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> as_adj_list(g)
[[1]]
+ 2/10 vertices, from c17b8a4:
[1]  2 10

[[2]]
+ 2/10 vertices, from c17b8a4:
[1] 1 3

[[3]]
+ 2/10 vertices, from c17b8a4:
[1] 2 4

[[4]]
+ 2/10 vertices, from c17b8a4:
[1] 3 5

[[5]]
+ 2/10 vertices, from c17b8a4:
[1] 4 6

[[6]]
+ 2/10 vertices, from c17b8a4:
[1] 5 7

[[7]]
+ 2/10 vertices, from c17b8a4:
[1] 6 8

[[8]]
+ 2/10 vertices, from c17b8a4:
[1] 7 9

[[9]]
+ 2/10 vertices, from c17b8a4:
[1]  8 10

[[10]]
+ 2/10 vertices, from c17b8a4:
[1] 1 9

> as_adj_edge_list(g)
[[1]]
+ 2/10 edges from c17b8a4:
[1] 1-- 2 1--10

[[2]]
+ 2/10 edges from c17b8a4:
[1] 1--2 2--3

[[3]]
+ 2/10 edges from c17b8a4:
[1] 2--3 3--4

[[4]]
+ 2/10 edges from c17b8a4:
[1] 3--4 4--5

[[5]]
+ 2/10 edges from c17b8a4:
[1] 4--5 5--6

[[6]]
+ 2/10 edges from c17b8a4:
[1] 5--6 6--7

[[7]]
+ 2/10 edges from c17b8a4:
[1] 6--7 7--8

[[8]]
+ 2/10 edges from c17b8a4:
[1] 7--8 8--9

[[9]]
+ 2/10 edges from c17b8a4:
[1] 8-- 9 9--10

[[10]]
+ 2/10 edges from c17b8a4:
[1] 1--10 9--10

> 
> 
> 
> 
> cleanEx()
> nameEx("as_adjacency_matrix")
> ### * as_adjacency_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_adjacency_matrix
> ### Title: Convert a graph to an adjacency matrix
> ### Aliases: as_adjacency_matrix as_adj
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(10, 2 / 10)
> as_adjacency_matrix(g)
10 x 10 sparse Matrix of class "dgCMatrix"
                         
 [1,] . . . . . . . . . .
 [2,] . . 1 . . . . . . 1
 [3,] . 1 . 1 . . . . 1 .
 [4,] . . 1 . . . 1 . . .
 [5,] . . . . . . 1 1 . .
 [6,] . . . . . . . . . .
 [7,] . . . 1 1 . . 1 . .
 [8,] . . . . 1 . 1 . . .
 [9,] . . 1 . . . . . . 1
[10,] . 1 . . . . . . 1 .
> V(g)$name <- letters[1:vcount(g)]
> as_adjacency_matrix(g)
10 x 10 sparse Matrix of class "dgCMatrix"
  [[ suppressing 10 column names ‘a’, ‘b’, ‘c’ ... ]]
                     
a . . . . . . . . . .
b . . 1 . . . . . . 1
c . 1 . 1 . . . . 1 .
d . . 1 . . . 1 . . .
e . . . . . . 1 1 . .
f . . . . . . . . . .
g . . . 1 1 . . 1 . .
h . . . . 1 . 1 . . .
i . . 1 . . . . . . 1
j . 1 . . . . . . 1 .
> E(g)$weight <- runif(ecount(g))
> as_adjacency_matrix(g, attr = "weight")
10 x 10 sparse Matrix of class "dgCMatrix"
  [[ suppressing 10 column names ‘a’, ‘b’, ‘c’ ... ]]
                                                                             
a . .         .         .          .         . .          .         .        
b . .         0.2672207 .          .         . .          .         .        
c . 0.2672207 .         0.38611409 .         . .          .         0.4820801
d . .         0.3861141 .          .         . 0.01339033 .         .        
e . .         .         .          .         . 0.38238796 0.8696908 .        
f . .         .         .          .         . .          .         .        
g . .         .         0.01339033 0.3823880 . .          0.3403490 .        
h . .         .         .          0.8696908 . 0.34034900 .         .        
i . .         0.4820801 .          .         . .          .         .        
j . 0.5995658 .         .          .         . .          .         0.4935413
           
a .        
b 0.5995658
c .        
d .        
e .        
f .        
g .        
h .        
i 0.4935413
j .        
> 
> 
> 
> cleanEx()
> nameEx("as_biadjacency_matrix")
> ### * as_biadjacency_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_biadjacency_matrix
> ### Title: Bipartite adjacency matrix of a bipartite graph
> ### Aliases: as_biadjacency_matrix
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_bipartite_graph(c(0, 1, 0, 1, 0, 0), c(1, 2, 2, 3, 3, 4))
> as_biadjacency_matrix(g)
  2 4
1 1 0
3 1 1
5 0 0
6 0 0
> 
> 
> 
> 
> cleanEx()
> nameEx("as_edgelist")
> ### * as_edgelist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_edgelist
> ### Title: Convert a graph to an edge list
> ### Aliases: as_edgelist
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(10, 2 / 10)
> as_edgelist(g)
      [,1] [,2]
 [1,]    2    3
 [2,]    3    4
 [3,]    4    7
 [4,]    5    7
 [5,]    5    8
 [6,]    7    8
 [7,]    3    9
 [8,]    2   10
 [9,]    9   10
> 
> V(g)$name <- LETTERS[seq_len(gorder(g))]
> as_edgelist(g)
      [,1] [,2]
 [1,] "B"  "C" 
 [2,] "C"  "D" 
 [3,] "D"  "G" 
 [4,] "E"  "G" 
 [5,] "E"  "H" 
 [6,] "G"  "H" 
 [7,] "C"  "I" 
 [8,] "B"  "J" 
 [9,] "I"  "J" 
> 
> 
> 
> 
> cleanEx()
> nameEx("as_graphnel")
> ### * as_graphnel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_graphnel
> ### Title: Convert igraph graphs to graphNEL objects from the graph package
> ### Aliases: as_graphnel
> 
> ### ** Examples
> 
> ## Undirected
> ## Not run: 
> ##D g <- make_ring(10)
> ##D V(g)$name <- letters[1:10]
> ##D GNEL <- as_graphnel(g)
> ##D g2 <- graph_from_graphnel(GNEL)
> ##D g2
> ##D 
> ##D ## Directed
> ##D g3 <- make_star(10, mode = "in")
> ##D V(g3)$name <- letters[1:10]
> ##D GNEL2 <- as_graphnel(g3)
> ##D g4 <- graph_from_graphnel(GNEL2)
> ##D g4
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("as_ids")
> ### * as_ids
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_ids
> ### Title: Convert a vertex or edge sequence to an ordinary vector
> ### Aliases: as_ids as_ids.igraph.vs as_ids.igraph.es
> 
> ### ** Examples
> 
> g <- make_ring(10)
> as_ids(V(g))
 [1]  1  2  3  4  5  6  7  8  9 10
> as_ids(E(g))
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> V(g)$name <- letters[1:10]
> as_ids(V(g))
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
> as_ids(E(g))
 [1] "a|b" "b|c" "c|d" "d|e" "e|f" "f|g" "g|h" "h|i" "i|j" "a|j"
> 
> 
> 
> cleanEx()
> nameEx("as_long_data_frame")
> ### * as_long_data_frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_long_data_frame
> ### Title: Convert a graph to a long data frame
> ### Aliases: as_long_data_frame
> 
> ### ** Examples
> 
> g <- make_(
+   ring(10),
+   with_vertex_(name = letters[1:10], color = "red"),
+   with_edge_(weight = 1:10, color = "green")
+ )
> as_long_data_frame(g)
   from to weight color from_name from_color to_name to_color
1     1  2      1 green         a        red       b      red
2     2  3      2 green         b        red       c      red
3     3  4      3 green         c        red       d      red
4     4  5      4 green         d        red       e      red
5     5  6      5 green         e        red       f      red
6     6  7      6 green         f        red       g      red
7     7  8      7 green         g        red       h      red
8     8  9      8 green         h        red       i      red
9     9 10      9 green         i        red       j      red
10    1 10     10 green         a        red       j      red
> 
> 
> 
> cleanEx()
> nameEx("as_membership")
> ### * as_membership
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_membership
> ### Title: Declare a numeric vector as a membership vector
> ### Aliases: as_membership
> 
> ### ** Examples
> 
> ## Compare to the correct clustering
> g <- (make_full_graph(10) + make_full_graph(10)) %>%
+   rewire(each_edge(p = 0.2))
> correct <- rep(1:2, each = 10) %>% as_membership()
> fc <- cluster_fast_greedy(g)
> compare(correct, fc)
[1] 0.3300913
> compare(correct, membership(fc))
[1] 0.3300913
> 
> 
> 
> cleanEx()
> nameEx("assortativity")
> ### * assortativity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assortativity
> ### Title: Assortativity coefficient
> ### Aliases: assortativity assortativity_nominal assortativity_degree
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # random network, close to zero
> assortativity_degree(sample_gnp(10000, 3 / 10000))
[1] -0.001301647
> 
> # BA model, tends to be dissortative
> assortativity_degree(sample_pa(10000, m = 4))
[1] -0.02495471
> 
> 
> 
> cleanEx()
> nameEx("automorphism_group")
> ### * automorphism_group
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: automorphism_group
> ### Title: Generating set of the automorphism group of a graph
> ### Aliases: automorphism_group
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## A ring has n*2 automorphisms, and a possible generating set is one that
> ## "turns" the ring by one vertex to the left or right
> g <- make_ring(10)
> automorphism_group(g)
[[1]]
+ 10/10 vertices, from f247af5:
 [1]  1 10  9  8  7  6  5  4  3  2

[[2]]
+ 10/10 vertices, from f247af5:
 [1]  2  3  4  5  6  7  8  9 10  1

> 
> 
> 
> cleanEx()
> nameEx("betweenness")
> ### * betweenness
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: betweenness
> ### Title: Vertex and edge betweenness centrality
> ### Aliases: betweenness betweenness.estimate edge.betweenness.estimate
> ###   edge_betweenness
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(10, 3 / 10)
> betweenness(g)
 [1]  6.0000000  3.2500000 13.2500000  2.5833333  0.9166667  0.9166667
 [7] 13.2500000  2.5833333  3.2500000  6.0000000
> edge_betweenness(g)
 [1] 12.500000  8.500000  4.250000  6.583333  7.166667  9.250000  6.583333
 [8]  5.666667  4.083333  7.166667  4.250000 12.500000  8.500000
> 
> 
> 
> 
> cleanEx()
> nameEx("bfs")
> ### * bfs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bfs
> ### Title: Breadth-first search
> ### Aliases: bfs
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Two rings
> bfs(make_ring(10) %du% make_ring(10),
+   root = 1, "out",
+   order = TRUE, rank = TRUE, father = TRUE, pred = TRUE,
+   succ = TRUE, dist = TRUE
+ )
$root
[1] 1

$mode
[1] "out"

$order
+ 20/20 vertices, from 40ca37c:
 [1]  1  2 10  3  9  4  8  5  7  6 11 12 20 13 19 14 18 15 17 16

$rank
 [1]  1  2  4  6  8 10  9  7  5  3 11 12 14 16 18 20 19 17 15 13

$father
+ 20/20 vertices, from 40ca37c:
 [1] NA  1  2  3  4  5  8  9 10  1 NA 11 12 13 14 15 18 19 20 11

$pred
+ 20/20 vertices, from 40ca37c:
 [1] NA  1 10  9  8  7  5  4  3  2 NA 11 20 19 18 17 15 14 13 12

$succ
+ 20/20 vertices, from 40ca37c:
 [1]  2 10  9  8  7 NA  6  5  4  3 12 20 19 18 17 NA 16 15 14 13

$dist
 [1] 0 1 2 3 4 5 4 3 2 1 0 1 2 3 4 5 4 3 2 1

$neimode
[1] "out"

> 
> ## How to use a callback
> f <- function(graph, data, extra) {
+   print(data)
+   FALSE
+ }
> tmp <- bfs(make_ring(10) %du% make_ring(10),
+   root = 1, "out",
+   callback = f
+ )
 vid pred succ rank dist 
   1    0    2    1    0 
 vid pred succ rank dist 
   2    1   10    2    1 
 vid pred succ rank dist 
  10    2    3    3    1 
 vid pred succ rank dist 
   3   10    9    4    2 
 vid pred succ rank dist 
   9    3    4    5    2 
 vid pred succ rank dist 
   4    9    8    6    3 
 vid pred succ rank dist 
   8    4    5    7    3 
 vid pred succ rank dist 
   5    8    7    8    4 
 vid pred succ rank dist 
   7    5    6    9    4 
 vid pred succ rank dist 
   6    7    0   10    5 
 vid pred succ rank dist 
  11    0   12   11    0 
 vid pred succ rank dist 
  12   11   20   12    1 
 vid pred succ rank dist 
  20   12   13   13    1 
 vid pred succ rank dist 
  13   20   19   14    2 
 vid pred succ rank dist 
  19   13   14   15    2 
 vid pred succ rank dist 
  14   19   18   16    3 
 vid pred succ rank dist 
  18   14   15   17    3 
 vid pred succ rank dist 
  15   18   17   18    4 
 vid pred succ rank dist 
  17   15   16   19    4 
 vid pred succ rank dist 
  16   17    0   20    5 
> 
> ## How to use a callback to stop the search
> ## We stop after visiting all vertices in the initial component
> f <- function(graph, data, extra) {
+   data["succ"] == -1
+ }
> bfs(make_ring(10) %du% make_ring(10), root = 1, callback = f)
$root
[1] 1

$mode
[1] "out"

$order
+ 20/20 vertices, from 8f3036e:
 [1]  1  2 10  3  9  4  8  5  7  6 11 12 20 13 19 14 18 15 17 16

$rank
NULL

$father
NULL

$pred
NULL

$succ
NULL

$dist
NULL

$neimode
[1] "out"

> 
> 
> 
> 
> cleanEx()
> nameEx("biconnected_components")
> ### * biconnected_components
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: biconnected_components
> ### Title: Biconnected components
> ### Aliases: biconnected_components
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- disjoint_union(make_full_graph(5), make_full_graph(5))
> clu <- components(g)$membership
> g <- add_edges(g, c(which(clu == 1), which(clu == 2)))
> bc <- biconnected_components(g)
> 
> 
> 
> cleanEx()
> nameEx("bipartite_mapping")
> ### * bipartite_mapping
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bipartite_mapping
> ### Title: Decide whether a graph is bipartite
> ### Aliases: bipartite_mapping
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Rings with an even number of vertices are bipartite
> g <- make_ring(10)
> bipartite_mapping(g)
$res
[1] TRUE

$type
 [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE

> 
> ## All star graphs are bipartite
> g2 <- make_star(10)
> bipartite_mapping(g2)
$res
[1] TRUE

$type
 [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE

> 
> ## A graph containing a triangle is not bipartite
> g3 <- make_ring(10)
> g3 <- add_edges(g3, c(1, 3))
> bipartite_mapping(g3)
$res
[1] FALSE

$type
logical(0)

> 
> 
> 
> cleanEx()
> nameEx("bipartite_projection")
> ### * bipartite_projection
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bipartite_projection
> ### Title: Project a bipartite graph
> ### Aliases: bipartite_projection bipartite_projection_size
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Projection of a full bipartite graph is a full graph
> g <- make_full_bipartite_graph(10, 5)
> proj <- bipartite_projection(g)
> graph.isomorphic(proj[[1]], make_full_graph(10))
[1] TRUE
> graph.isomorphic(proj[[2]], make_full_graph(5))
[1] TRUE
> 
> ## The projection keeps the vertex attributes
> M <- matrix(0, nrow = 5, ncol = 3)
> rownames(M) <- c("Alice", "Bob", "Cecil", "Dan", "Ethel")
> colnames(M) <- c("Party", "Skiing", "Badminton")
> M[] <- sample(0:1, length(M), replace = TRUE)
> M
      Party Skiing Badminton
Alice     0      0         0
Bob       1      0         0
Cecil     0      0         0
Dan       0      1         0
Ethel     1      1         0
> g2 <- graph_from_biadjacency_matrix(M)
> g2$name <- "Event network"
> proj2 <- bipartite_projection(g2)
> print(proj2[[1]], g = TRUE, e = TRUE)
IGRAPH f035f32 UNW- 5 2 -- Event network
+ attr: name (g/c), name (v/c), weight (e/n)
+ edges from f035f32 (vertex names):
[1] Bob--Ethel Dan--Ethel
> print(proj2[[2]], g = TRUE, e = TRUE)
IGRAPH 6e268de UNW- 3 1 -- Event network
+ attr: name (g/c), name (v/c), weight (e/n)
+ edge from 6e268de (vertex names):
[1] Party--Skiing
> 
> 
> 
> 
> cleanEx()
> nameEx("c.igraph.es")
> ### * c.igraph.es
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c.igraph.es
> ### Title: Concatenate edge sequences
> ### Aliases: c.igraph.es
> 
> ### ** Examples
> 
> g <- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
> c(E(g)[1], E(g)["A|B"], E(g)[1:4])
+ 6/10 edges from f76a753 (vertex names):
[1] A--B A--B A--B B--C C--D D--E
> 
> 
> 
> cleanEx()
> nameEx("c.igraph.vs")
> ### * c.igraph.vs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c.igraph.vs
> ### Title: Concatenate vertex sequences
> ### Aliases: c.igraph.vs
> 
> ### ** Examples
> 
> g <- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
> c(V(g)[1], V(g)["A"], V(g)[1:4])
+ 6/10 vertices, named, from 3f3fa1b:
[1] A A A B C D
> 
> 
> 
> cleanEx()
> nameEx("canonical_permutation")
> ### * canonical_permutation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: canonical_permutation
> ### Title: Canonical permutation of a graph
> ### Aliases: canonical_permutation
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Calculate the canonical form of a random graph
> g1 <- sample_gnm(10, 20)
> cp1 <- canonical_permutation(g1)
> cf1 <- permute(g1, cp1$labeling)
> 
> ## Do the same with a random permutation of it
> g2 <- permute(g1, sample(vcount(g1)))
> cp2 <- canonical_permutation(g2)
> cf2 <- permute(g2, cp2$labeling)
> 
> ## Check that they are the same
> el1 <- as_edgelist(cf1)
> el2 <- as_edgelist(cf2)
> el1 <- el1[order(el1[, 1], el1[, 2]), ]
> el2 <- el2[order(el2[, 1], el2[, 2]), ]
> all(el1 == el2)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("centr_betw")
> ### * centr_betw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_betw
> ### Title: Centralize a graph according to the betweenness of vertices
> ### Aliases: centr_betw
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_degree(g)$centralization
[1] 0.1718535
> centr_clo(g, mode = "all")$centralization
[1] 0.4291303
> centr_betw(g, directed = FALSE)$centralization
[1] 0.2488561
> centr_eigen(g, directed = FALSE)$centralization
[1] 0.9429209
> 
> 
> 
> cleanEx()
> nameEx("centr_betw_tmax")
> ### * centr_betw_tmax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_betw_tmax
> ### Title: Theoretical maximum for betweenness centralization
> ### Aliases: centr_betw_tmax
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_betw(g, normalized = FALSE)$centralization %>%
+   `/`(centr_betw_tmax(g))
[1] 0.0006668531
> centr_betw(g, normalized = TRUE)$centralization
[1] 0.0006668531
> 
> 
> 
> cleanEx()
> nameEx("centr_clo")
> ### * centr_clo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_clo
> ### Title: Centralize a graph according to the closeness of vertices
> ### Aliases: centr_clo
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_degree(g)$centralization
[1] 0.1718535
> centr_clo(g, mode = "all")$centralization
[1] 0.4291303
> centr_betw(g, directed = FALSE)$centralization
[1] 0.2488561
> centr_eigen(g, directed = FALSE)$centralization
[1] 0.9429209
> 
> 
> 
> cleanEx()
> nameEx("centr_clo_tmax")
> ### * centr_clo_tmax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_clo_tmax
> ### Title: Theoretical maximum for closeness centralization
> ### Aliases: centr_clo_tmax
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_clo(g, normalized = FALSE)$centralization %>%
+   `/`(centr_clo_tmax(g))
[1] NaN
> centr_clo(g, normalized = TRUE)$centralization
[1] NaN
> 
> 
> 
> cleanEx()
> nameEx("centr_degree")
> ### * centr_degree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_degree
> ### Title: Centralize a graph according to the degrees of vertices
> ### Aliases: centr_degree
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_degree(g)$centralization
[1] 0.1718535
> centr_clo(g, mode = "all")$centralization
[1] 0.4291303
> centr_betw(g, directed = FALSE)$centralization
[1] 0.2488561
> centr_eigen(g, directed = FALSE)$centralization
[1] 0.9429209
> 
> 
> 
> cleanEx()
> nameEx("centr_degree_tmax")
> ### * centr_degree_tmax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_degree_tmax
> ### Title: Theoretical maximum for degree centralization
> ### Aliases: centr_degree_tmax
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_degree(g, normalized = FALSE)$centralization %>%
+   `/`(centr_degree_tmax(g, loops = FALSE))
[1] 0.1720257
> centr_degree(g, normalized = TRUE)$centralization
[1] 0.1718535
> 
> 
> 
> cleanEx()
> nameEx("centr_eigen")
> ### * centr_eigen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_eigen
> ### Title: Centralize a graph according to the eigenvector centrality of
> ###   vertices
> ### Aliases: centr_eigen
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_degree(g)$centralization
[1] 0.1718535
> centr_clo(g, mode = "all")$centralization
[1] 0.4291303
> centr_betw(g, directed = FALSE)$centralization
[1] 0.2488561
> centr_eigen(g, directed = FALSE)$centralization
[1] 0.9429209
> 
> # The most centralized graph according to eigenvector centrality
> g0 <- make_graph(c(2, 1), n = 10, dir = FALSE)
> g1 <- make_star(10, mode = "undirected")
> centr_eigen(g0)$centralization
[1] 1
> centr_eigen(g1)$centralization
[1] 0.75
> 
> 
> 
> cleanEx()
> nameEx("centr_eigen_tmax")
> ### * centr_eigen_tmax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centr_eigen_tmax
> ### Title: Theoretical maximum for betweenness centralization
> ### Aliases: centr_eigen_tmax
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_eigen(g, normalized = FALSE)$centralization %>%
+   `/`(centr_eigen_tmax(g))
[1] 0.9429209
> centr_eigen(g, normalized = TRUE)$centralization
[1] 0.9429209
> 
> 
> 
> cleanEx()
> nameEx("centralize")
> ### * centralize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: centralize
> ### Title: Centralization of a graph
> ### Aliases: centralize centralization
> 
> ### ** Examples
> 
> # A BA graph is quite centralized
> g <- sample_pa(1000, m = 4)
> centr_degree(g)$centralization
[1] 0.1718535
> centr_clo(g, mode = "all")$centralization
[1] 0.4291303
> centr_eigen(g, directed = FALSE)$centralization
[1] 0.9429209
> 
> # Calculate centralization from pre-computed scores
> deg <- degree(g)
> tmax <- centr_degree_tmax(g, loops = FALSE)
> centralize(deg, tmax)
[1] 0.1720257
> 
> # The most centralized graph according to eigenvector centrality
> g0 <- make_graph(c(2, 1), n = 10, dir = FALSE)
> g1 <- make_star(10, mode = "undirected")
> centr_eigen(g0)$centralization
[1] 1
> centr_eigen(g1)$centralization
[1] 0.75
> 
> 
> 
> cleanEx()
> nameEx("cliques")
> ### * cliques
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cliques
> ### Title: Functions to find cliques, i.e. complete subgraphs in a graph
> ### Aliases: cliques largest_cliques max_cliques count_max_cliques
> ###   clique_num largest_weighted_cliques weighted_clique_num
> ###   clique_size_counts
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # this usually contains cliques of size six
> g <- sample_gnp(100, 0.3)
> clique_num(g)
[1] 6
> cliques(g, min = 6)
[[1]]
+ 6/100 vertices, from 11fa303:
[1]  3 13 62 78 88 91

[[2]]
+ 6/100 vertices, from 11fa303:
[1]  3 13 19 49 78 80

[[3]]
+ 6/100 vertices, from 11fa303:
[1] 11 42 51 70 84 92

[[4]]
+ 6/100 vertices, from 11fa303:
[1]  1 36 51 56 62 93

[[5]]
+ 6/100 vertices, from 11fa303:
[1] 45 75 79 81 82 99

[[6]]
+ 6/100 vertices, from 11fa303:
[1] 19 36 80 93 94 98

[[7]]
+ 6/100 vertices, from 11fa303:
[1] 19 20 21 80 94 98

[[8]]
+ 6/100 vertices, from 11fa303:
[1]  3 13 19 49 80 98

[[9]]
+ 6/100 vertices, from 11fa303:
[1] 13 31 35 51 78 90

[[10]]
+ 6/100 vertices, from 11fa303:
[1] 31 35 41 51 78 90

[[11]]
+ 6/100 vertices, from 11fa303:
[1] 13 31 35 51 78 80

[[12]]
+ 6/100 vertices, from 11fa303:
[1] 31 35 41 51 78 80

[[13]]
+ 6/100 vertices, from 11fa303:
[1] 13 19 20 31 78 80

[[14]]
+ 6/100 vertices, from 11fa303:
[1] 11 30 42 70 84 92

> largest_cliques(g)
[[1]]
+ 6/100 vertices, from 11fa303:
[1] 13 91 88 78 62  3

[[2]]
+ 6/100 vertices, from 11fa303:
[1] 13 90 78 51 31 35

[[3]]
+ 6/100 vertices, from 11fa303:
[1] 13 51 31 80 78 35

[[4]]
+ 6/100 vertices, from 11fa303:
[1] 13 19 78 49  3 80

[[5]]
+ 6/100 vertices, from 11fa303:
[1] 13 19 78 20 31 80

[[6]]
+ 6/100 vertices, from 11fa303:
[1] 13 19 98 80  3 49

[[7]]
+ 6/100 vertices, from 11fa303:
[1] 19 94 98 80 20 21

[[8]]
+ 6/100 vertices, from 11fa303:
[1] 19 94 98 80 93 36

[[9]]
+ 6/100 vertices, from 11fa303:
[1] 30 92 84 70 42 11

[[10]]
+ 6/100 vertices, from 11fa303:
[1] 31 51 78 41 35 80

[[11]]
+ 6/100 vertices, from 11fa303:
[1] 31 51 78 41 35 90

[[12]]
+ 6/100 vertices, from 11fa303:
[1] 36 93 51 56 62  1

[[13]]
+ 6/100 vertices, from 11fa303:
[1] 42 70 92 11 51 84

[[14]]
+ 6/100 vertices, from 11fa303:
[1] 45 81 99 79 82 75

> 
> # To have a bit less maximal cliques, about 100-200 usually
> g <- sample_gnp(100, 0.03)
> max_cliques(g)
[[1]]
+ 1/100 vertex, from 9c162f8:
[1] 96

[[2]]
+ 1/100 vertex, from 9c162f8:
[1] 31

[[3]]
+ 1/100 vertex, from 9c162f8:
[1] 27

[[4]]
+ 1/100 vertex, from 9c162f8:
[1] 29

[[5]]
+ 1/100 vertex, from 9c162f8:
[1] 23

[[6]]
+ 2/100 vertices, from 9c162f8:
[1] 72 54

[[7]]
+ 2/100 vertices, from 9c162f8:
[1]  5 40

[[8]]
+ 2/100 vertices, from 9c162f8:
[1] 22 24

[[9]]
+ 2/100 vertices, from 9c162f8:
[1] 76 71

[[10]]
+ 2/100 vertices, from 9c162f8:
[1] 94 65

[[11]]
+ 2/100 vertices, from 9c162f8:
[1] 94 52

[[12]]
+ 2/100 vertices, from 9c162f8:
[1] 78 66

[[13]]
+ 2/100 vertices, from 9c162f8:
[1] 97 66

[[14]]
+ 2/100 vertices, from 9c162f8:
[1] 97 58

[[15]]
+ 2/100 vertices, from 9c162f8:
[1] 98 64

[[16]]
+ 2/100 vertices, from 9c162f8:
[1] 35 73

[[17]]
+ 2/100 vertices, from 9c162f8:
[1] 44 49

[[18]]
+ 2/100 vertices, from 9c162f8:
[1] 47 30

[[19]]
+ 2/100 vertices, from 9c162f8:
[1] 85 24

[[20]]
+ 2/100 vertices, from 9c162f8:
[1] 16 56

[[21]]
+ 2/100 vertices, from 9c162f8:
[1] 25 79

[[22]]
+ 2/100 vertices, from 9c162f8:
[1] 25 75

[[23]]
+ 2/100 vertices, from 9c162f8:
[1] 26 91

[[24]]
+ 2/100 vertices, from 9c162f8:
[1] 26 89

[[25]]
+ 2/100 vertices, from 9c162f8:
[1] 26 28

[[26]]
+ 2/100 vertices, from 9c162f8:
[1]  28 100

[[27]]
+ 2/100 vertices, from 9c162f8:
[1] 28 60

[[28]]
+ 2/100 vertices, from 9c162f8:
[1] 30 93

[[29]]
+ 2/100 vertices, from 9c162f8:
[1] 30 83

[[30]]
+ 2/100 vertices, from 9c162f8:
[1] 30  3

[[31]]
+ 2/100 vertices, from 9c162f8:
[1] 30  1

[[32]]
+ 2/100 vertices, from 9c162f8:
[1] 32 59

[[33]]
+ 2/100 vertices, from 9c162f8:
[1] 32 39

[[34]]
+ 2/100 vertices, from 9c162f8:
[1] 33 42

[[35]]
+ 2/100 vertices, from 9c162f8:
[1] 33 14

[[36]]
+ 2/100 vertices, from 9c162f8:
[1] 34 91

[[37]]
+ 2/100 vertices, from 9c162f8:
[1] 34 66

[[38]]
+ 2/100 vertices, from 9c162f8:
[1] 36 95

[[39]]
+ 2/100 vertices, from 9c162f8:
[1] 36 81

[[40]]
+ 2/100 vertices, from 9c162f8:
[1] 36 45

[[41]]
+ 2/100 vertices, from 9c162f8:
[1] 36 20

[[42]]
+ 3/100 vertices, from 9c162f8:
[1] 37 54 68

[[43]]
+ 2/100 vertices, from 9c162f8:
[1] 38 61

[[44]]
+ 2/100 vertices, from 9c162f8:
[1] 38  7

[[45]]
+ 2/100 vertices, from 9c162f8:
[1] 39 62

[[46]]
+ 2/100 vertices, from 9c162f8:
[1] 40 75

[[47]]
+ 2/100 vertices, from 9c162f8:
[1] 40 24

[[48]]
+ 2/100 vertices, from 9c162f8:
[1] 40  4

[[49]]
+ 2/100 vertices, from 9c162f8:
[1] 41 82

[[50]]
+ 2/100 vertices, from 9c162f8:
[1] 41 52

[[51]]
+ 2/100 vertices, from 9c162f8:
[1] 41 24

[[52]]
+ 2/100 vertices, from 9c162f8:
[1] 42 92

[[53]]
+ 2/100 vertices, from 9c162f8:
[1] 42 13

[[54]]
+ 2/100 vertices, from 9c162f8:
[1] 43 62

[[55]]
+ 2/100 vertices, from 9c162f8:
[1] 43 12

[[56]]
+ 2/100 vertices, from 9c162f8:
[1] 45 80

[[57]]
+ 2/100 vertices, from 9c162f8:
[1] 45 68

[[58]]
+ 2/100 vertices, from 9c162f8:
[1] 45 67

[[59]]
+ 2/100 vertices, from 9c162f8:
[1] 46 84

[[60]]
+ 2/100 vertices, from 9c162f8:
[1] 46 13

[[61]]
+ 2/100 vertices, from 9c162f8:
[1] 48 89

[[62]]
+ 2/100 vertices, from 9c162f8:
[1] 48 51

[[63]]
+ 2/100 vertices, from 9c162f8:
[1] 49 20

[[64]]
+ 2/100 vertices, from 9c162f8:
[1] 49 11

[[65]]
+ 2/100 vertices, from 9c162f8:
[1]  50 100

[[66]]
+ 2/100 vertices, from 9c162f8:
[1] 50 74

[[67]]
+ 2/100 vertices, from 9c162f8:
[1] 51  7

[[68]]
+ 2/100 vertices, from 9c162f8:
[1] 52 53

[[69]]
+ 2/100 vertices, from 9c162f8:
[1] 52 21

[[70]]
+ 2/100 vertices, from 9c162f8:
[1] 53 11

[[71]]
+ 2/100 vertices, from 9c162f8:
[1] 53  3

[[72]]
+ 2/100 vertices, from 9c162f8:
[1] 54 83

[[73]]
+ 2/100 vertices, from 9c162f8:
[1] 55 80

[[74]]
+ 2/100 vertices, from 9c162f8:
[1] 55 62

[[75]]
+ 2/100 vertices, from 9c162f8:
[1] 55  9

[[76]]
+ 2/100 vertices, from 9c162f8:
[1] 56 86

[[77]]
+ 2/100 vertices, from 9c162f8:
[1] 56 82

[[78]]
+ 2/100 vertices, from 9c162f8:
[1] 56 68

[[79]]
+ 2/100 vertices, from 9c162f8:
[1] 56  2

[[80]]
+ 2/100 vertices, from 9c162f8:
[1] 57 19

[[81]]
+ 2/100 vertices, from 9c162f8:
[1] 57 15

[[82]]
+ 2/100 vertices, from 9c162f8:
[1] 59  6

[[83]]
+ 2/100 vertices, from 9c162f8:
[1] 60 11

[[84]]
+ 2/100 vertices, from 9c162f8:
[1] 60  1

[[85]]
+ 2/100 vertices, from 9c162f8:
[1] 61 14

[[86]]
+ 2/100 vertices, from 9c162f8:
[1] 61 11

[[87]]
+ 2/100 vertices, from 9c162f8:
[1] 62 75

[[88]]
+ 2/100 vertices, from 9c162f8:
[1] 63 17

[[89]]
+ 2/100 vertices, from 9c162f8:
[1] 63  2

[[90]]
+ 2/100 vertices, from 9c162f8:
[1] 64 77

[[91]]
+ 2/100 vertices, from 9c162f8:
[1] 64 19

[[92]]
+ 2/100 vertices, from 9c162f8:
[1] 64 17

[[93]]
+ 2/100 vertices, from 9c162f8:
[1] 66 73

[[94]]
+ 2/100 vertices, from 9c162f8:
[1] 66 18

[[95]]
+ 2/100 vertices, from 9c162f8:
[1] 67 89

[[96]]
+ 2/100 vertices, from 9c162f8:
[1] 67 84

[[97]]
+ 2/100 vertices, from 9c162f8:
[1] 67 70

[[98]]
+ 2/100 vertices, from 9c162f8:
[1] 67 10

[[99]]
+ 2/100 vertices, from 9c162f8:
[1] 69 93

[[100]]
+ 2/100 vertices, from 9c162f8:
[1] 69 84

[[101]]
+ 2/100 vertices, from 9c162f8:
[1] 69 18

[[102]]
+ 2/100 vertices, from 9c162f8:
[1] 70 88

[[103]]
+ 2/100 vertices, from 9c162f8:
[1] 70 19

[[104]]
+ 2/100 vertices, from 9c162f8:
[1] 71 73

[[105]]
+ 2/100 vertices, from 9c162f8:
[1] 71  9

[[106]]
+ 2/100 vertices, from 9c162f8:
[1] 73 14

[[107]]
+ 2/100 vertices, from 9c162f8:
[1] 73 12

[[108]]
+ 2/100 vertices, from 9c162f8:
[1] 74 20

[[109]]
+ 2/100 vertices, from 9c162f8:
[1] 74 18

[[110]]
+ 2/100 vertices, from 9c162f8:
[1] 75 14

[[111]]
+ 2/100 vertices, from 9c162f8:
[1] 77  4

[[112]]
+ 2/100 vertices, from 9c162f8:
[1] 79 21

[[113]]
+ 2/100 vertices, from 9c162f8:
[1] 79 18

[[114]]
+ 2/100 vertices, from 9c162f8:
[1] 79 10

[[115]]
+ 2/100 vertices, from 9c162f8:
[1] 81 14

[[116]]
+ 2/100 vertices, from 9c162f8:
[1] 81 11

[[117]]
+ 2/100 vertices, from 9c162f8:
[1] 82 95

[[118]]
+ 2/100 vertices, from 9c162f8:
[1] 82 93

[[119]]
+ 2/100 vertices, from 9c162f8:
[1] 82 90

[[120]]
+ 2/100 vertices, from 9c162f8:
[1] 82 87

[[121]]
+ 2/100 vertices, from 9c162f8:
[1] 84 21

[[122]]
+ 2/100 vertices, from 9c162f8:
[1] 84 15

[[123]]
+ 2/100 vertices, from 9c162f8:
[1]  86 100

[[124]]
+ 2/100 vertices, from 9c162f8:
[1] 86 10

[[125]]
+ 2/100 vertices, from 9c162f8:
[1] 87  9

[[126]]
+ 2/100 vertices, from 9c162f8:
[1] 88 99

[[127]]
+ 2/100 vertices, from 9c162f8:
[1] 88  7

[[128]]
+ 2/100 vertices, from 9c162f8:
[1] 90 11

[[129]]
+ 2/100 vertices, from 9c162f8:
[1]  91 100

[[130]]
+ 2/100 vertices, from 9c162f8:
[1] 92 99

[[131]]
+ 2/100 vertices, from 9c162f8:
[1] 92  4

[[132]]
+ 2/100 vertices, from 9c162f8:
[1] 93 10

[[133]]
+ 2/100 vertices, from 9c162f8:
[1] 93  8

[[134]]
+ 2/100 vertices, from 9c162f8:
[1]  1 10

[[135]]
+ 2/100 vertices, from 9c162f8:
[1] 100   8

[[136]]
+ 2/100 vertices, from 9c162f8:
[1] 3 6

[[137]]
+ 2/100 vertices, from 9c162f8:
[1] 11 12

> 
> 
> 
> cleanEx()
> nameEx("closeness")
> ### * closeness
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closeness
> ### Title: Closeness centrality of vertices
> ### Aliases: closeness closeness.estimate
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> g2 <- make_star(10)
> closeness(g)
 [1] 0.04 0.04 0.04 0.04 0.04 0.04 0.04 0.04 0.04 0.04
> closeness(g2, mode = "in")
 [1] 0.1111111       NaN       NaN       NaN       NaN       NaN       NaN
 [8]       NaN       NaN       NaN
> closeness(g2, mode = "out")
 [1] NaN   1   1   1   1   1   1   1   1   1
> closeness(g2, mode = "all")
 [1] 0.11111111 0.05882353 0.05882353 0.05882353 0.05882353 0.05882353
 [7] 0.05882353 0.05882353 0.05882353 0.05882353
> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_edge_betweenness")
> ### * cluster_edge_betweenness
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_edge_betweenness
> ### Title: Community structure detection based on edge betweenness
> ### Aliases: cluster_edge_betweenness
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_pa(100, m = 2, directed = FALSE)
> eb <- cluster_edge_betweenness(g)
> 
> g <- make_full_graph(10) %du% make_full_graph(10)
> g <- add_edges(g, c(1, 11))
> eb <- cluster_edge_betweenness(g)
> eb
IGRAPH clustering edge betweenness, groups: 2, mod: 0.49
+ groups:
  $`1`
   [1]  1  2  3  4  5  6  7  8  9 10
  
  $`2`
   [1] 11 12 13 14 15 16 17 18 19 20
  
> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_fast_greedy")
> ### * cluster_fast_greedy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_fast_greedy
> ### Title: Community structure via greedy optimization of modularity
> ### Aliases: cluster_fast_greedy
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
> g <- add_edges(g, c(1, 6, 1, 11, 6, 11))
> fc <- cluster_fast_greedy(g)
> membership(fc)
 [1] 3 3 3 3 3 1 1 1 1 1 2 2 2 2 2
> sizes(fc)
Community sizes
1 2 3 
5 5 5 
> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_fluid_communities")
> ### * cluster_fluid_communities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_fluid_communities
> ### Title: Community detection algorithm based on interacting fluids
> ### Aliases: cluster_fluid_communities
> ### Keywords: graphs
> 
> ### ** Examples
> 
> g <- make_graph("Zachary")
> comms <- cluster_fluid_communities(g, 2)
> 
> 
> 
> cleanEx()
> nameEx("cluster_infomap")
> ### * cluster_infomap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_infomap
> ### Title: Infomap community finding
> ### Aliases: cluster_infomap
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Zachary's karate club
> g <- make_graph("Zachary")
> 
> imc <- cluster_infomap(g)
> membership(imc)
 [1] 1 1 1 1 2 2 2 1 3 1 2 1 1 1 3 3 2 1 3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3
> communities(imc)
$`1`
 [1]  1  2  3  4  8 10 12 13 14 18 20 22

$`2`
[1]  5  6  7 11 17

$`3`
 [1]  9 15 16 19 21 23 24 25 26 27 28 29 30 31 32 33 34

> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_label_prop")
> ### * cluster_label_prop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_label_prop
> ### Title: Finding communities based on propagating labels
> ### Aliases: cluster_label_prop
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(10, 5 / 10) %du% sample_gnp(9, 5 / 9)
> g <- add_edges(g, c(1, 12))
> cluster_label_prop(g)
IGRAPH clustering label propagation, groups: 2, mod: 0.48
+ groups:
  $`1`
   [1]  1  2  3  4  5  6  7  8  9 10
  
  $`2`
  [1] 11 12 13 14 15 16 17 18 19
  
> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_leading_eigen")
> ### * cluster_leading_eigen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_leading_eigen
> ### Title: Community structure detecting based on the leading eigenvector
> ###   of the community matrix
> ### Aliases: cluster_leading_eigen
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
> g <- add_edges(g, c(1, 6, 1, 11, 6, 11))
> lec <- cluster_leading_eigen(g)
> lec
IGRAPH clustering leading eigenvector, groups: 3, mod: 0.58
+ groups:
  $`1`
  [1] 1 2 3 4 5
  
  $`2`
  [1] 11 12 13 14 15
  
  $`3`
  [1]  6  7  8  9 10
  
> 
> cluster_leading_eigen(g, start = membership(lec))
IGRAPH clustering leading eigenvector, groups: 3, mod: 0.58
+ groups:
  $`1`
  [1] 1 2 3 4 5
  
  $`2`
  [1] 11 12 13 14 15
  
  $`3`
  [1]  6  7  8  9 10
  
> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_leiden")
> ### * cluster_leiden
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_leiden
> ### Title: Finding community structure of a graph using the Leiden
> ###   algorithm of Traag, van Eck & Waltman.
> ### Aliases: cluster_leiden
> ### Keywords: graphs
> 
> ### ** Examples
> 
> g <- make_graph("Zachary")
> # By default CPM is used
> r <- quantile(strength(g))[2] / (gorder(g) - 1)
> # Set seed for sake of reproducibility
> set.seed(1)
> ldc <- cluster_leiden(g, resolution_parameter = r)
> print(ldc)
IGRAPH clustering leiden, groups: 2, mod: NA
+ groups:
  $`1`
   [1]  1  2  3  4  5  6  7  8 10 11 12 13 14 17 18 20 22
  
  $`2`
   [1]  9 15 16 19 21 23 24 25 26 27 28 29 30 31 32 33 34
  
> plot(ldc, g)
> 
> 
> 
> cleanEx()
> nameEx("cluster_louvain")
> ### * cluster_louvain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_louvain
> ### Title: Finding community structure by multi-level optimization of
> ###   modularity
> ### Aliases: cluster_louvain
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # This is so simple that we will have only one level
> g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
> g <- add_edges(g, c(1, 6, 1, 11, 6, 11))
> cluster_louvain(g)
IGRAPH clustering multi level, groups: 3, mod: 0.58
+ groups:
  $`1`
  [1] 1 2 3 4 5
  
  $`2`
  [1]  6  7  8  9 10
  
  $`3`
  [1] 11 12 13 14 15
  
> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_spinglass")
> ### * cluster_spinglass
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_spinglass
> ### Title: Finding communities in graphs based on statistical meachanics
> ### Aliases: cluster_spinglass
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(10, 5 / 10) %du% sample_gnp(9, 5 / 9)
> g <- add_edges(g, c(1, 12))
> g <- induced_subgraph(g, subcomponent(g, 1))
> cluster_spinglass(g, spins = 2)
IGRAPH clustering spinglass, groups: 2, mod: 0.48
+ groups:
  $`1`
  [1] 11 12 13 14 15 16 17 18 19
  
  $`2`
   [1]  1  2  3  4  5  6  7  8  9 10
  
> cluster_spinglass(g, vertex = 1)
$community
 [1]  1  2  6  8  9  3  5  7 10  4

$cohesion
[1] 11.25

$adhesion
[1] -22.5

$inner.links
[1] 23

$outer.links
[1] 1

> 
> 
> 
> 
> cleanEx()
> nameEx("cluster_walktrap")
> ### * cluster_walktrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster_walktrap
> ### Title: Community structure via short random walks
> ### Aliases: cluster_walktrap
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
> g <- add_edges(g, c(1, 6, 1, 11, 6, 11))
> cluster_walktrap(g)
IGRAPH clustering walktrap, groups: 3, mod: 0.58
+ groups:
  $`1`
  [1] 11 12 13 14 15
  
  $`2`
  [1]  6  7  8  9 10
  
  $`3`
  [1] 1 2 3 4 5
  
> 
> 
> 
> 
> cleanEx()
> nameEx("cocitation")
> ### * cocitation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cocitation
> ### Title: Cocitation coupling
> ### Aliases: cocitation bibcoupling
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_kautz_graph(2, 3)
> cocitation(g)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]    0    2    0    0    0    0    0    0    0     0     0     0     0
 [2,]    2    0    0    0    0    0    0    0    0     0     0     0     0
 [3,]    0    0    0    2    0    0    0    0    0     0     0     0     0
 [4,]    0    0    2    0    0    0    0    0    0     0     0     0     0
 [5,]    0    0    0    0    0    2    0    0    0     0     0     0     0
 [6,]    0    0    0    0    2    0    0    0    0     0     0     0     0
 [7,]    0    0    0    0    0    0    0    2    0     0     0     0     0
 [8,]    0    0    0    0    0    0    2    0    0     0     0     0     0
 [9,]    0    0    0    0    0    0    0    0    0     2     0     0     0
[10,]    0    0    0    0    0    0    0    0    2     0     0     0     0
[11,]    0    0    0    0    0    0    0    0    0     0     0     2     0
[12,]    0    0    0    0    0    0    0    0    0     0     2     0     0
[13,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[14,]    0    0    0    0    0    0    0    0    0     0     0     0     2
[15,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[16,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[17,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[18,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[19,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[20,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[21,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[22,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[23,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[24,]    0    0    0    0    0    0    0    0    0     0     0     0     0
      [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24]
 [1,]     0     0     0     0     0     0     0     0     0     0     0
 [2,]     0     0     0     0     0     0     0     0     0     0     0
 [3,]     0     0     0     0     0     0     0     0     0     0     0
 [4,]     0     0     0     0     0     0     0     0     0     0     0
 [5,]     0     0     0     0     0     0     0     0     0     0     0
 [6,]     0     0     0     0     0     0     0     0     0     0     0
 [7,]     0     0     0     0     0     0     0     0     0     0     0
 [8,]     0     0     0     0     0     0     0     0     0     0     0
 [9,]     0     0     0     0     0     0     0     0     0     0     0
[10,]     0     0     0     0     0     0     0     0     0     0     0
[11,]     0     0     0     0     0     0     0     0     0     0     0
[12,]     0     0     0     0     0     0     0     0     0     0     0
[13,]     2     0     0     0     0     0     0     0     0     0     0
[14,]     0     0     0     0     0     0     0     0     0     0     0
[15,]     0     0     2     0     0     0     0     0     0     0     0
[16,]     0     2     0     0     0     0     0     0     0     0     0
[17,]     0     0     0     0     2     0     0     0     0     0     0
[18,]     0     0     0     2     0     0     0     0     0     0     0
[19,]     0     0     0     0     0     0     2     0     0     0     0
[20,]     0     0     0     0     0     2     0     0     0     0     0
[21,]     0     0     0     0     0     0     0     0     2     0     0
[22,]     0     0     0     0     0     0     0     2     0     0     0
[23,]     0     0     0     0     0     0     0     0     0     0     2
[24,]     0     0     0     0     0     0     0     0     0     2     0
> bibcoupling(g)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [2,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [3,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [4,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [5,]    0    0    0    0    0    0    0    0    0     0     0     0     2
 [6,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [7,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [8,]    0    0    0    0    0    0    0    0    0     0     0     0     0
 [9,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[10,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[11,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[12,]    0    0    0    0    0    0    0    0    0     0     0     0     0
[13,]    0    0    0    0    2    0    0    0    0     0     0     0     0
[14,]    0    0    0    0    0    2    0    0    0     0     0     0     0
[15,]    0    0    0    0    0    0    2    0    0     0     0     0     0
[16,]    0    0    0    0    0    0    0    2    0     0     0     0     0
[17,]    0    0    0    0    0    0    0    0    2     0     0     0     0
[18,]    0    0    0    0    0    0    0    0    0     2     0     0     0
[19,]    0    0    0    0    0    0    0    0    0     0     2     0     0
[20,]    0    0    0    0    0    0    0    0    0     0     0     2     0
[21,]    2    0    0    0    0    0    0    0    0     0     0     0     0
[22,]    0    2    0    0    0    0    0    0    0     0     0     0     0
[23,]    0    0    2    0    0    0    0    0    0     0     0     0     0
[24,]    0    0    0    2    0    0    0    0    0     0     0     0     0
      [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24]
 [1,]     0     0     0     0     0     0     0     2     0     0     0
 [2,]     0     0     0     0     0     0     0     0     2     0     0
 [3,]     0     0     0     0     0     0     0     0     0     2     0
 [4,]     0     0     0     0     0     0     0     0     0     0     2
 [5,]     0     0     0     0     0     0     0     0     0     0     0
 [6,]     2     0     0     0     0     0     0     0     0     0     0
 [7,]     0     2     0     0     0     0     0     0     0     0     0
 [8,]     0     0     2     0     0     0     0     0     0     0     0
 [9,]     0     0     0     2     0     0     0     0     0     0     0
[10,]     0     0     0     0     2     0     0     0     0     0     0
[11,]     0     0     0     0     0     2     0     0     0     0     0
[12,]     0     0     0     0     0     0     2     0     0     0     0
[13,]     0     0     0     0     0     0     0     0     0     0     0
[14,]     0     0     0     0     0     0     0     0     0     0     0
[15,]     0     0     0     0     0     0     0     0     0     0     0
[16,]     0     0     0     0     0     0     0     0     0     0     0
[17,]     0     0     0     0     0     0     0     0     0     0     0
[18,]     0     0     0     0     0     0     0     0     0     0     0
[19,]     0     0     0     0     0     0     0     0     0     0     0
[20,]     0     0     0     0     0     0     0     0     0     0     0
[21,]     0     0     0     0     0     0     0     0     0     0     0
[22,]     0     0     0     0     0     0     0     0     0     0     0
[23,]     0     0     0     0     0     0     0     0     0     0     0
[24,]     0     0     0     0     0     0     0     0     0     0     0
> 
> 
> 
> 
> cleanEx()
> nameEx("cohesive_blocks")
> ### * cohesive_blocks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cohesive_blocks
> ### Title: Calculate Cohesive Blocks
> ### Aliases: cohesive_blocks cohesiveBlocks blocks hierarchy parent
> ###   export_pajek plot.cohesiveBlocks summary.cohesiveBlocks
> ###   length.cohesiveBlocks print.cohesiveBlocks
> ###   graphs_from_cohesive_blocks cohesion.cohesiveBlocks plot_hierarchy
> ###   max_cohesion
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## The graph from the Moody-White paper
> mw <- graph_from_literal(
+   1 - 2:3:4:5:6, 2 - 3:4:5:7, 3 - 4:6:7, 4 - 5:6:7,
+   5 - 6:7:21, 6 - 7, 7 - 8:11:14:19, 8 - 9:11:14, 9 - 10,
+   10 - 12:13, 11 - 12:14, 12 - 16, 13 - 16, 14 - 15, 15 - 16,
+   17 - 18:19:20, 18 - 20:21, 19 - 20:22:23, 20 - 21,
+   21 - 22:23, 22 - 23
+ )
> 
> mwBlocks <- cohesive_blocks(mw)
> 
> # Inspect block membership and cohesion
> mwBlocks
Cohesive block structure:
B-1         c 1, n 23
'- B-2      c 2, n 14   oooooooo.. .o......oo ooo 
   '- B-4   c 5, n  7   ooooooo... .......... ... 
'- B-3      c 2, n 10   ......o.oo o.oooooo.. ... 
   '- B-5   c 3, n  4   ......o.oo o......... ... 
> blocks(mwBlocks)
[[1]]
+ 23/23 vertices, named, from 2bfc7c4:
 [1] 1  2  3  4  5  6  7  21 8  11 14 19 9  10 12 13 16 15 17 18 20 22 23

[[2]]
+ 14/23 vertices, named, from 2bfc7c4:
 [1] 1  2  3  4  5  6  7  21 19 17 18 20 22 23

[[3]]
+ 10/23 vertices, named, from 2bfc7c4:
 [1] 7  8  11 14 9  10 12 13 16 15

[[4]]
+ 7/23 vertices, named, from 2bfc7c4:
[1] 1 2 3 4 5 6 7

[[5]]
+ 4/23 vertices, named, from 2bfc7c4:
[1] 7  8  11 14

> cohesion(mwBlocks)
[1] 1 2 2 5 3
> 
> # Save results in a Pajek file
> file <- tempfile(fileext = ".paj")
> export_pajek(mwBlocks, mw, file = file)
> if (!interactive()) {
+   unlink(file)
+ }
> 
> # Plot the results
> plot(mwBlocks, mw)
> 
> ## The science camp network
> camp <- graph_from_literal(
+   Harry:Steve:Don:Bert - Harry:Steve:Don:Bert,
+   Pam:Brazey:Carol:Pat - Pam:Brazey:Carol:Pat,
+   Holly - Carol:Pat:Pam:Jennie:Bill,
+   Bill - Pauline:Michael:Lee:Holly,
+   Pauline - Bill:Jennie:Ann,
+   Jennie - Holly:Michael:Lee:Ann:Pauline,
+   Michael - Bill:Jennie:Ann:Lee:John,
+   Ann - Michael:Jennie:Pauline,
+   Lee - Michael:Bill:Jennie,
+   Gery - Pat:Steve:Russ:John,
+   Russ - Steve:Bert:Gery:John,
+   John - Gery:Russ:Michael
+ )
> campBlocks <- cohesive_blocks(camp)
> campBlocks
Cohesive block structure:
B-1      c 2, n 18
'- B-2   c 3, n  4   oooo...... ........ 
'- B-3   c 3, n  5   ....ooooo. ........ 
'- B-4   c 3, n  6   .........o ooooo... 
> 
> plot(campBlocks, camp,
+   vertex.label = V(camp)$name, margin = -0.2,
+   vertex.shape = "rectangle", vertex.size = 24, vertex.size2 = 8,
+   mark.border = 1, colbar = c(NA, NA, "cyan", "orange")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("communities")
> ### * communities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: membership
> ### Title: Functions to deal with the result of network community detection
> ### Aliases: membership print.communities modularity.communities
> ###   length.communities sizes algorithm merges crossing code_len
> ###   is_hierarchical as.dendrogram.communities as.hclust.communities
> ###   cut_at show_trace plot.communities communities
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> karate <- make_graph("Zachary")
> wc <- cluster_walktrap(karate)
> modularity(wc)
[1] 0.3532216
> membership(wc)
 [1] 1 1 2 1 5 5 5 1 2 2 5 1 1 2 3 3 5 1 3 1 3 1 3 4 4 4 3 4 2 3 2 2 3 3
> plot(wc, karate)
> 
> 
> 
> 
> cleanEx()
> nameEx("compare")
> ### * compare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare
> ### Title: Compares community structures using various metrics
> ### Aliases: compare compare.communities compare.membership
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_graph("Zachary")
> sg <- cluster_spinglass(g)
> le <- cluster_leading_eigen(g)
> compare(sg, le, method = "rand")
[1] 0.9500891
> compare(membership(sg), membership(le))
[1] 0.2765712
> 
> 
> 
> 
> cleanEx()
> nameEx("complementer")
> ### * complementer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complementer
> ### Title: Complementer of a graph
> ### Aliases: complementer
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Complementer of a ring
> g <- make_ring(10)
> complementer(g)
IGRAPH c1a0e76 U--- 10 35 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from c1a0e76:
 [1] 1-- 9 1-- 8 1-- 7 1-- 6 1-- 5 1-- 4 1-- 3 2--10 2-- 9 2-- 8 2-- 7 2-- 6
[13] 2-- 5 2-- 4 3--10 3-- 9 3-- 8 3-- 7 3-- 6 3-- 5 4--10 4-- 9 4-- 8 4-- 7
[25] 4-- 6 5--10 5-- 9 5-- 8 5-- 7 6--10 6-- 9 6-- 8 7--10 7-- 9 8--10
> 
> ## A graph and its complementer give together the full graph
> g <- make_ring(10)
> gc <- complementer(g)
> gu <- union(g, gc)
> gu
IGRAPH ff18f70 U--- 10 45 -- 
+ attr: name_1 (g/c), name_2 (g/c), mutual_1 (g/l), mutual_2 (g/l),
| circular_1 (g/l), circular_2 (g/l)
+ edges from ff18f70:
 [1] 9--10 8--10 8-- 9 7--10 7-- 9 7-- 8 6--10 6-- 9 6-- 8 6-- 7 5--10 5-- 9
[13] 5-- 8 5-- 7 5-- 6 4--10 4-- 9 4-- 8 4-- 7 4-- 6 4-- 5 3--10 3-- 9 3-- 8
[25] 3-- 7 3-- 6 3-- 5 3-- 4 2--10 2-- 9 2-- 8 2-- 7 2-- 6 2-- 5 2-- 4 2-- 3
[37] 1--10 1-- 9 1-- 8 1-- 7 1-- 6 1-- 5 1-- 4 1-- 3 1-- 2
> graph.isomorphic(gu, make_full_graph(vcount(g)))
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("component_wise")
> ### * component_wise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: component_wise
> ### Title: Component-wise layout
> ### Aliases: component_wise
> 
> ### ** Examples
> 
> g <- make_ring(10) + make_ring(10)
> g %>%
+   add_layout_(in_circle(), component_wise()) %>%
+   plot()
> 
> 
> 
> cleanEx()
> nameEx("components")
> ### * components
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: component_distribution
> ### Title: Connected components of a graph
> ### Aliases: component_distribution largest_component components
> ###   is_connected count_components
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(20, 1 / 20)
> clu <- components(g)
> groups(clu)
$`1`
[1] 1

$`2`
[1] 2

$`3`
[1]  3 14 18

$`4`
[1] 4 6

$`5`
[1]  5  7  8 15 17 20

$`6`
[1] 9

$`7`
[1] 10

$`8`
[1] 11

$`9`
[1] 12

$`10`
[1] 13

$`11`
[1] 16

$`12`
[1] 19

> largest_component(g)
IGRAPH 6776861 U--- 6 5 -- Erdos-Renyi (gnp) graph
+ attr: name (g/c), type (g/c), loops (g/l), p (g/n)
+ edges from 6776861:
[1] 1--2 2--3 2--4 1--5 3--6
> 
> 
> 
> cleanEx()
> nameEx("compose")
> ### * compose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compose
> ### Title: Compose two graphs as binary relations
> ### Aliases: compose %c%
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g1 <- make_ring(10)
> g2 <- make_star(10, mode = "undirected")
> gc <- compose(g1, g2)
> print_all(gc)
IGRAPH 9f9acfa U--- 10 36 -- 
+ attr: name_1 (g/c), name_2 (g/c), mutual (g/l), circular (g/l), mode
| (g/c), center (g/n)
+ edges:
 1 --  1  1  1  1  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10
 2 --  1  2  2  3  4  5  6  7  8  9 10 10
 3 --  1  1  2 10
 4 --  1  1  2 10
 5 --  1  1  2 10
 6 --  1  1  2 10
 7 --  1  1  2 10
 8 --  1  1  2 10
 9 --  1  1  2 10
10 --  1  2  2  3  4  5  6  7  8  9 10 10
> print_all(simplify(gc))
IGRAPH bf73c57 U--- 10 24 -- 
+ attr: name_1 (g/c), name_2 (g/c), mutual (g/l), circular (g/l), mode
| (g/c), center (g/n)
+ edges:
 1 --  2  3  4  5  6  7  8  9 10    2 --  1  3  4  5  6  7  8  9 10
 3 --  1  2 10                      4 --  1  2 10                  
 5 --  1  2 10                      6 --  1  2 10                  
 7 --  1  2 10                      8 --  1  2 10                  
 9 --  1  2 10                     10 --  1  2  3  4  5  6  7  8  9
> 
> 
> 
> 
> cleanEx()
> nameEx("constraint")
> ### * constraint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: constraint
> ### Title: Burt's constraint
> ### Aliases: constraint
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- sample_gnp(20, 5 / 20)
> constraint(g)
 [1] 0.2455556 0.3232019 0.2655633 0.4329698 0.2951389 0.3568993 0.4253472
 [8] 0.2752149 0.2401000 0.2867635 0.6351726 0.4117361 0.2097653 0.4223457
[15] 0.3240195 0.2232584 0.2401000 0.3592889 0.1913659 0.2706011
> 
> 
> 
> 
> cleanEx()
> nameEx("contract")
> ### * contract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contract
> ### Title: Contract several vertices into a single one
> ### Aliases: contract
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> g$name <- "Ring"
> V(g)$name <- letters[1:vcount(g)]
> E(g)$weight <- runif(ecount(g))
> 
> g2 <- contract(g, rep(1:5, each = 2),
+   vertex.attr.comb = toString
+ )
> 
> ## graph and edge attributes are kept, vertex attributes are
> ## combined using the 'toString' function.
> print(g2, g = TRUE, v = TRUE, e = TRUE)
IGRAPH c8b7ea6 UNW- 5 10 -- Ring
+ attr: name (g/c), mutual (g/l), circular (g/l), name (v/c), weight
| (e/n)
+ edges from c8b7ea6 (vertex names):
 [1] a, b--a, b a, b--c, d c, d--c, d c, d--e, f e, f--e, f e, f--g, h
 [7] g, h--g, h g, h--i, j i, j--i, j a, b--i, j
> 
> 
> 
> 
> cleanEx()
> nameEx("convex_hull")
> ### * convex_hull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convex_hull
> ### Title: Convex hull of a set of vertices
> ### Aliases: convex_hull
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> M <- cbind(runif(100), runif(100))
> convex_hull(M)
$resverts
[1] 16 47 27 69 11  4 21 80 18

$rescoords
            [,1]       [,2]
 [1,] 0.49769924 0.01307758
 [2,] 0.02333120 0.17512677
 [3,] 0.01339033 0.51116978
 [4,] 0.08424691 0.72372595
 [5,] 0.20597457 0.97617069
 [6,] 0.90820779 0.99268406
 [7,] 0.93470523 0.99183862
 [8,] 0.96061800 0.90308161
 [9,] 0.99190609 0.10318424

> 
> 
> 
> cleanEx()
> nameEx("coreness")
> ### * coreness
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coreness
> ### Title: K-core decomposition of graphs
> ### Aliases: coreness
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> g <- add_edges(g, c(1, 2, 2, 3, 1, 3))
> coreness(g) # small core triangle in a ring
 [1] 3 3 3 2 2 2 2 2 2 2
> 
> 
> 
> 
> cleanEx()
> nameEx("count_automorphisms")
> ### * count_automorphisms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count_automorphisms
> ### Title: Number of automorphisms
> ### Aliases: count_automorphisms
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## A ring has n*2 automorphisms, you can "turn" it by 0-9 vertices
> ## and each of these graphs can be "flipped"
> g <- make_ring(10)
> count_automorphisms(g)
$nof_nodes
[1] 6

$nof_leaf_nodes
[1] 4

$nof_bad_nodes
[1] 0

$nof_canupdates
[1] 1

$max_level
[1] 2

$group_size
[1] "20"

> 
> ## A full graph has n! automorphisms; however, we restrict the vertex
> ## matching by colors, leading to only 4 automorphisms
> g <- make_full_graph(4)
> count_automorphisms(g, colors = c(1, 2, 1, 2))
$nof_nodes
[1] 5

$nof_leaf_nodes
[1] 3

$nof_bad_nodes
[1] 0

$nof_canupdates
[1] 1

$max_level
[1] 2

$group_size
[1] "4"

> 
> 
> 
> cleanEx()
> nameEx("count_isomorphisms")
> ### * count_isomorphisms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count_isomorphisms
> ### Title: Count the number of isomorphic mappings between two graphs
> ### Aliases: count_isomorphisms graph.count.isomorphisms.vf2
> 
> ### ** Examples
> 
> # colored graph isomorphism
> g1 <- make_ring(10)
> g2 <- make_ring(10)
> isomorphic(g1, g2)
[1] TRUE
> 
> V(g1)$color <- rep(1:2, length = vcount(g1))
> V(g2)$color <- rep(2:1, length = vcount(g2))
> # consider colors by default
> count_isomorphisms(g1, g2)
[1] 10
> # ignore colors
> count_isomorphisms(g1, g2,
+   vertex.color1 = NULL,
+   vertex.color2 = NULL
+ )
[1] 20
> 
> 
> 
> cleanEx()
> nameEx("count_motifs")
> ### * count_motifs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count_motifs
> ### Title: Graph motifs
> ### Aliases: count_motifs
> 
> ### ** Examples
> 
> g <- sample_pa(100)
> motifs(g, 3)
 [1]  NA  NA 218  NA  84   0   0   0   0   0   0   0   0   0   0   0
> count_motifs(g, 3)
[1] 302
> sample_motifs(g, 3)
[1] 1630
> 
> 
> 
> cleanEx()
> nameEx("count_triangles")
> ### * count_triangles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: triangles
> ### Title: Find triangles in graphs
> ### Aliases: triangles count_triangles
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## A small graph
> kite <- make_graph("Krackhardt_Kite")
> plot(kite)
> matrix(triangles(kite), nrow = 3)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
[1,]    4    4    4    4    4    4    4    4    6     6     7
[2,]    1    1    2    6    6    6    7    7    1     7     2
[3,]    2    3    5    1    3    7    2    5    3     8     5
> 
> ## Adjacenct triangles
> atri <- count_triangles(kite)
> plot(kite, vertex.label = atri)
> 
> ## Always true
> sum(count_triangles(kite)) == length(triangles(kite))
[1] TRUE
> 
> ## Should match, local transitivity is the
> ## number of adjacent triangles divided by the number
> ## of adjacency triples
> transitivity(kite, type = "local")
 [1] 0.6666667 0.6666667 1.0000000 0.5333333 1.0000000 0.5000000 0.5000000
 [8] 0.3333333 0.0000000       NaN
> count_triangles(kite) / (degree(kite) * (degree(kite) - 1) / 2)
 [1] 0.6666667 0.6666667 1.0000000 0.5333333 1.0000000 0.5000000 0.5000000
 [8] 0.3333333 0.0000000       NaN
> 
> 
> 
> cleanEx()
> nameEx("curve_multiple")
> ### * curve_multiple
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curve_multiple
> ### Title: Optimal edge curvature when plotting graphs
> ### Aliases: curve_multiple
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_graph(c(
+   0, 1, 1, 0, 1, 2, 1, 3, 1, 3, 1, 3,
+   2, 3, 2, 3, 2, 3, 2, 3, 0, 1
+ ) + 1)
> 
> curve_multiple(g)
 [1] -0.5000000  0.0000000  0.0000000 -0.5000000  0.0000000  0.5000000
 [7] -0.5000000 -0.1666667  0.1666667  0.5000000  0.5000000
> 
> set.seed(42)
> plot(g)
> 
> 
> 
> 
> cleanEx()
> nameEx("decompose")
> ### * decompose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: decompose
> ### Title: Decompose a graph into components
> ### Aliases: decompose
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # the diameter of each component in a random graph
> g <- sample_gnp(1000, 1 / 1000)
> components <- decompose(g, min.vertices = 2)
> sapply(components, diameter)
  [1] 10  8  2  5  4 13  3 19  1 15  5  2  6  2  2  7  2  1  4  6  1  3  3  1  6
 [26]  1  3  5  2  1  1  1  1  4  1  8  4  4  2  2  1  3  2  2  2  3  2  1  1  2
 [51]  3  3  1  2  2  3  1  9  3  6  8  6  2  1  2  5  1  1  2  4  3  1  2  1  2
 [76]  1  2  1  1  1  1  1  1  1  1  1  1  2  2  2  1  2  1  1  1  2  1  1  2  1
[101]  1  3  1  1  1  1  2  1  1  1  1  2  2  1  2  1  1  1  1  1  2  1  2  1  2
[126]  1  1  2  1  1  3  1
> 
> 
> 
> 
> cleanEx()
> nameEx("degree")
> ### * degree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: degree
> ### Title: Degree and degree distribution of the vertices
> ### Aliases: degree degree_distribution
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> degree(g)
 [1] 2 2 2 2 2 2 2 2 2 2
> g2 <- sample_gnp(1000, 10 / 1000)
> degree_distribution(g2)
 [1] 0.000 0.000 0.005 0.006 0.017 0.051 0.044 0.090 0.102 0.130 0.142 0.115
[13] 0.079 0.068 0.054 0.038 0.029 0.014 0.008 0.003 0.002 0.001 0.002
> 
> 
> 
> 
> cleanEx()
> nameEx("delete_edge_attr")
> ### * delete_edge_attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delete_edge_attr
> ### Title: Delete an edge attribute
> ### Aliases: delete_edge_attr
> 
> ### ** Examples
> 
> g <- make_ring(10) %>%
+   set_edge_attr("name", value = LETTERS[1:10])
> edge_attr_names(g)
[1] "name"
> g2 <- delete_edge_attr(g, "name")
> edge_attr_names(g2)
character(0)
> 
> 
> 
> cleanEx()
> nameEx("delete_edges")
> ### * delete_edges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delete_edges
> ### Title: Delete edges from a graph
> ### Aliases: delete_edges
> 
> ### ** Examples
> 
> g <- make_ring(10) %>%
+   delete_edges(seq(1, 9, by = 2))
> g
IGRAPH 667553f U--- 10 5 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from 667553f:
[1] 2-- 3 4-- 5 6-- 7 8-- 9 1--10
> 
> g <- make_ring(10) %>%
+   delete_edges("10|1")
> g
IGRAPH 00b0722 U--- 10 9 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from 00b0722:
[1] 1-- 2 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 9--10
> 
> g <- make_ring(5)
> g <- delete_edges(g, get.edge.ids(g, c(1, 5, 4, 5)))
> g
IGRAPH cd5045a U--- 5 3 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l)
+ edges from cd5045a:
[1] 1--2 2--3 3--4
> 
> 
> 
> cleanEx()
> nameEx("delete_graph_attr")
> ### * delete_graph_attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delete_graph_attr
> ### Title: Delete a graph attribute
> ### Aliases: delete_graph_attr
> 
> ### ** Examples
> 
> g <- make_ring(10)
> graph_attr_names(g)
[1] "name"     "mutual"   "circular"
> g2 <- delete_graph_attr(g, "name")
> graph_attr_names(g2)
[1] "mutual"   "circular"
> 
> 
> 
> cleanEx()
> nameEx("delete_vertex_attr")
> ### * delete_vertex_attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delete_vertex_attr
> ### Title: Delete a vertex attribute
> ### Aliases: delete_vertex_attr
> 
> ### ** Examples
> 
> g <- make_ring(10) %>%
+   set_vertex_attr("name", value = LETTERS[1:10])
> vertex_attr_names(g)
[1] "name"
> g2 <- delete_vertex_attr(g, "name")
> vertex_attr_names(g2)
character(0)
> 
> 
> 
> cleanEx()
> nameEx("delete_vertices")
> ### * delete_vertices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delete_vertices
> ### Title: Delete vertices from a graph
> ### Aliases: delete_vertices
> 
> ### ** Examples
> 
> g <- make_ring(10) %>%
+   set_vertex_attr("name", value = LETTERS[1:10])
> g
IGRAPH d0cd800 UN-- 10 10 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l), name (v/c)
+ edges from d0cd800 (vertex names):
 [1] A--B B--C C--D D--E E--F F--G G--H H--I I--J A--J
> V(g)
+ 10/10 vertices, named, from d0cd800:
 [1] A B C D E F G H I J
> 
> g2 <- delete_vertices(g, c(1, 5)) %>%
+   delete_vertices("B")
> g2
IGRAPH af16fe9 UN-- 7 5 -- Ring graph
+ attr: name (g/c), mutual (g/l), circular (g/l), name (v/c)
+ edges from af16fe9 (vertex names):
[1] C--D F--G G--H H--I I--J
> V(g2)
+ 7/7 vertices, named, from af16fe9:
[1] C D F G H I J
> 
> 
> 
> cleanEx()
> nameEx("dfs")
> ### * dfs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dfs
> ### Title: Depth-first search
> ### Aliases: dfs
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## A graph with two separate trees
> dfs(make_tree(10) %du% make_tree(10),
+   root = 1, "out",
+   TRUE, TRUE, TRUE, TRUE
+ )
$root
[1] 1

$mode
[1] "out"

$order
+ 20/20 vertices, from 2bccab0:
 [1]  1  2  4  8  9  5 10  3  6  7 11 12 14 18 19 15 20 13 16 17

$order.out
+ 20/20 vertices, from 2bccab0:
 [1]  8  9  4 10  5  2  6  7  3  1 18 19 14 20 15 12 16 17 13 11

$father
+ 20/20 vertices, from 2bccab0:
 [1] NA  1  1  2  2  3  3  4  4  5 NA 11 11 12 12 13 13 14 14 15

$dist
NULL

$neimode
[1] "out"

> 
> ## How to use a callback
> f.in <- function(graph, data, extra) {
+   cat("in:", paste(collapse = ", ", data), "\n")
+   FALSE
+ }
> f.out <- function(graph, data, extra) {
+   cat("out:", paste(collapse = ", ", data), "\n")
+   FALSE
+ }
> tmp <- dfs(make_tree(10),
+   root = 1, "out",
+   in.callback = f.in, out.callback = f.out
+ )
in: 1, 0 
in: 2, 1 
in: 4, 2 
in: 8, 3 
out: 8, 2 
in: 9, 3 
out: 9, 2 
out: 4, 1 
in: 5, 2 
in: 10, 3 
out: 10, 2 
out: 5, 1 
out: 2, 0 
in: 3, 1 
in: 6, 2 
out: 6, 1 
in: 7, 2 
out: 7, 1 
out: 3, 0 
out: 1, -1 
> 
> ## Terminate after the first component, using a callback
> f.out <- function(graph, data, extra) {
+   data["vid"] == 1
+ }
> tmp <- dfs(make_tree(10) %du% make_tree(10),
+   root = 1,
+   out.callback = f.out
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("diameter")
> ### * diameter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diameter
> ### Title: Diameter of a graph
> ### Aliases: diameter get_diameter farthest_vertices
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> g2 <- delete_edges(g, c(1, 2, 1, 10))
> diameter(g2, unconnected = TRUE)
[1] 7
> diameter(g2, unconnected = FALSE)
[1] Inf
> 
> ## Weighted diameter
> set.seed(1)
> g <- make_ring(10)
> E(g)$weight <- sample(seq_len(ecount(g)))
> diameter(g)
[1] 27
> get_diameter(g)
+ 5/10 vertices, from c114268:
[1]  1 10  9  8  7
> diameter(g, weights = NA)
[1] 5
> get_diameter(g, weights = NA)
+ 6/10 vertices, from c114268:
[1] 1 2 3 4 5 6
> 
> 
> 
> 
> cleanEx()
> nameEx("difference.igraph")
> ### * difference.igraph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difference.igraph
> ### Title: Difference of graphs
> ### Aliases: difference.igraph %m%
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## Create a wheel graph
> wheel <- union(
+   make_ring(10),
+   make_star(11, center = 11, mode = "undirected")
+ )
> V(wheel)$name <- letters[seq_len(vcount(wheel))]
> 
> ## Subtract a star graph from it
> sstar <- make_star(6, center = 6, mode = "undirected")
> V(sstar)$name <- letters[c(1, 3, 5, 7, 9, 11)]
> G <- wheel %m% sstar
> print_all(G)
IGRAPH 7c1775e UN-- 11 15 -- 
+ attr: name_1 (g/c), name_2 (g/c), mutual (g/l), circular (g/l), mode
| (g/c), center (g/n), name (v/c)
+ edges (vertex names):
a -- b, j
b -- a, c, k
c -- b, d
d -- c, e, k
e -- d, f
f -- e, g, k
g -- f, h
h -- g, i, k
i -- h, j
j -- a, i, k
k -- b, d, f, h, j
> plot(G, layout = layout_nicely(wheel))
> 
> 
> 
> cleanEx()
> nameEx("difference.igraph.es")
> ### * difference.igraph.es
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difference.igraph.es
> ### Title: Difference of edge sequences
> ### Aliases: difference.igraph.es
> 
> ### ** Examples
> 
> g <- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
> difference(V(g), V(g)[6:10])
+ 5/10 vertices, named, from f2cff3d:
[1] A B C D E
> 
> 
> 
> cleanEx()
> nameEx("difference.igraph.vs")
> ### * difference.igraph.vs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difference.igraph.vs
> ### Title: Difference of vertex sequences
> ### Aliases: difference.igraph.vs
> 
> ### ** Examples
> 
> g <- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
> difference(V(g), V(g)[6:10])
+ 5/10 vertices, named, from b875f87:
[1] A B C D E
> 
> 
> 
> cleanEx()
> nameEx("dim_select")
> ### * dim_select
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dim_select
> ### Title: Dimensionality selection for singular values using profile
> ###   likelihood.
> ### Aliases: dim_select
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> # Generate the two groups of singular values with
> # Gaussian mixture of two components that have different means
> sing.vals <- c(rnorm(10, mean = 1, sd = 1), rnorm(10, mean = 3, sd = 1))
> dim.chosen <- dim_select(sing.vals)
> dim.chosen
[1] 10
> 
> # Sample random vectors with multivariate normal distribution
> # and normalize to unit length
> lpvs <- matrix(rnorm(200), 10, 20)
> lpvs <- apply(lpvs, 2, function(x) {
+   (abs(x) / sqrt(sum(x^2)))
+ })
> RDP.graph <- sample_dot_product(lpvs)
> dim_select(embed_adjacency_matrix(RDP.graph, 10)$D)
[1] 1
> 
> # Sample random vectors with the Dirichlet distribution
> lpvs.dir <- sample_dirichlet(n = 20, rep(1, 10))
> RDP.graph.2 <- sample_dot_product(lpvs.dir)
> dim_select(embed_adjacency_matrix(RDP.graph.2, 10)$D)
[1] 1
> 
> # Sample random vectors from hypersphere with radius 1.
> lpvs.sph <- sample_sphere_surface(dim = 10, n = 20, radius = 1)
> RDP.graph.3 <- sample_dot_product(lpvs.sph)
> dim_select(embed_adjacency_matrix(RDP.graph.3, 10)$D)
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("disjoint_union")
> ### * disjoint_union
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: disjoint_union
> ### Title: Disjoint union of graphs
> ### Aliases: disjoint_union %du%
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> ## A star and a ring
> g1 <- make_star(10, mode = "undirected")
> V(g1)$name <- letters[1:10]
> g2 <- make_ring(10)
> V(g2)$name <- letters[11:20]
> print_all(g1 %du% g2)
IGRAPH bdfe92e UN-- 20 19 -- 
+ attr: name_1 (g/c), name_2 (g/c), mode (g/c), center (g/n), mutual
| (g/l), circular (g/l), name (v/c)
+ edges from bdfe92e (vertex names):
 [1] a--b a--c a--d a--e a--f a--g a--h a--i a--j k--l l--m m--n n--o o--p p--q
[16] q--r r--s s--t k--t
> 
> 
> 
> cleanEx()
> nameEx("distances")
> ### * distances
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distance_table
> ### Title: Shortest (directed or undirected) paths between vertices
> ### Aliases: distance_table mean_distance distances shortest_paths
> ###   all_shortest_paths
> ### Keywords: graphs
> 
> ### ** Examples
> 
> 
> g <- make_ring(10)
> distances(g)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    1    2    3    4    5    4    3    2     1
 [2,]    1    0    1    2    3    4    5    4    3     2
 [3,]    2    1    0    1    2    3    4    5    4     3
 [4,]    3    2    1    0    1    2    3    4    5     4
 [5,]    4    3    2    1    0    1    2    3    4     5
 [6,]    5    4    3    2    1    0    1    2    3     4
 [7,]    4    5    4    3    2    1    0    1    2     3
 [8,]    3    4    5    4    3    2    1    0    1     2
 [9,]    2    3    4    5    4    3    2    1    0     1
[10,]    1    2    3    4    5    4    3    2    1     0
> shortest_paths(g, 5)
$vpath
$vpath[[1]]
+ 5/10 vertices, from 097be27:
[1] 5 4 3 2 1

$vpath[[2]]
+ 4/10 vertices, from 097be27:
[1] 5 4 3 2

$vpath[[3]]
+ 3/10 vertices, from 097be27:
[1] 5 4 3

$vpath[[4]]
+ 2/10 vertices, from 097be27:
[1] 5 4

$vpath[[5]]
+ 1/10 vertex, from 097be27:
[1] 5

$vpath[[6]]
+ 2/10 vertices, from 097be27:
[1] 5 6

$vpath[[7]]
+ 3/10 vertices, from 097be27:
[1] 5 6 7

$vpath[[8]]
+ 4/10 vertices, from 097be27:
[1] 5 6 7 8

$vpath[[9]]
+ 5/10 vertices, from 097be27:
[1] 5 6 7 8 9

$vpath[[10]]
+ 6/10 vertices, from 097be27:
[1]  5  4  3  2  1 10


$epath
NULL

$predecessors
NULL

$inbound_edges
NULL

> all_shortest_paths(g, 1, 6:8)
$vpaths
$vpaths[[1]]
+ 6/10 vertices, from 097be27:
[1]  1 10  9  8  7  6

$vpaths[[2]]
+ 6/10 vertices, from 097be27:
[1] 1 2 3 4 5 6

$vpaths[[3]]
+ 5/10 vertices, from 097be27:
[1]  1 10  9  8  7

$vpaths[[4]]
+ 4/10 vertices, from 097be27:
[1]  1 10  9  8


$epaths
$epaths[[1]]
[1] 10  9  8  7  6

$epaths[[2]]
[1] 1 2 3 4 5

$epaths[[3]]
[1] 10  9  8  7

$epaths[[4]]
[1] 10  9  8


$nrgeo
 [1] 1 1 1 1 1 2 1 1 1 1

$res
$res[[1]]
+ 6/10 vertices, from 097be27:
[1]  1 10  9  8  7  6

$res[[2]]
+ 6/10 vertices, from 097be27:
[1] 1 2 3 4 5 6

$res[[3]]
+ 5/10 vertices, from 097be27:
[1]  1 10  9  8  7

$res[[4]]
+ 4/10 vertices, from 097be27:
[1]  1 10  9  8


> mean_distance(g)
[1] 2.777778
> ## Weighted shortest paths
> el <- matrix(
+   ncol = 3, byrow = TRUE,
+   c(
+     1, 2, 0,
+     1, 3, 2,
+     1, 4, 1,
+     2, 3, 0,
+     2, 5, 5,
+     2, 6, 2,
+     3, 2, 1,
+     3, 4, 1,
+     3, 7, 1,
+     4, 3, 0,
+     4, 7, 2,
+     5, 6, 2,
+     5, 8, 8,
+     6, 3, 2,
+     6, 7, 1,
+     6, 9, 1,
+     6, 10, 3,
+     8, 6, 1,
+     8, 9, 1,
+     9, 10, 4
+   )
+ )
> g2 <- add_edges(make_empty_graph(10), t(el[, 1:2]), weight = el[, 3])
> distances(g2, mode = "out")
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    0    0    1    5    2    1   13    3     5
 [2,]  Inf    0    0    1    5    2    1   13    3     5
 [3,]  Inf    1    0    1    6    3    1   14    4     6
 [4,]  Inf    1    0    0    6    3    1   14    4     6
 [5,]  Inf    5    4    5    0    2    3    8    3     5
 [6,]  Inf    3    2    3    8    0    1   16    1     3
 [7,]  Inf  Inf  Inf  Inf  Inf  Inf    0  Inf  Inf   Inf
 [8,]  Inf    4    3    4    9    1    2    0    1     4
 [9,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf    0     4
[10,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf     0
> 
> 
> 
> 
> cleanEx()
> nameEx("diverging_pal")
> ### * diverging_pal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diverging_pal
> ### Title: Diverging palette
> ### Aliases: diverging_pal
> 
> ### ** Examples
> 
> library(igraphdata)
Error in library(igraphdata) : there is no package called ‘igraphdata’
Execution halted
