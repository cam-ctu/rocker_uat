
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:02:50.755] plan(): Setting new future strategy stack:
[17:02:50.756] List of future strategies:
[17:02:50.756] 1. sequential:
[17:02:50.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.756]    - tweaked: FALSE
[17:02:50.756]    - call: future::plan("sequential")
[17:02:50.767] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[17:02:50.864] plan(): Setting new future strategy stack:
[17:02:50.864] List of future strategies:
[17:02:50.864] 1. sequential:
[17:02:50.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.864]    - tweaked: FALSE
[17:02:50.864]    - call: plan(strategy)
[17:02:50.877] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.879] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.879] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.885] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:02:50.885] Searching for globals ... DONE
[17:02:50.885] Resolving globals: TRUE
[17:02:50.885] Resolving any globals that are futures ...
[17:02:50.886] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:02:50.886] Resolving any globals that are futures ... DONE
[17:02:50.886] 
[17:02:50.886] 
[17:02:50.886] getGlobalsAndPackages() ... DONE
[17:02:50.887] run() for ‘Future’ ...
[17:02:50.887] - state: ‘created’
[17:02:50.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:50.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:50.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:50.888]   - Field: ‘label’
[17:02:50.888]   - Field: ‘local’
[17:02:50.888]   - Field: ‘owner’
[17:02:50.888]   - Field: ‘envir’
[17:02:50.888]   - Field: ‘packages’
[17:02:50.888]   - Field: ‘gc’
[17:02:50.888]   - Field: ‘conditions’
[17:02:50.889]   - Field: ‘expr’
[17:02:50.889]   - Field: ‘uuid’
[17:02:50.889]   - Field: ‘seed’
[17:02:50.889]   - Field: ‘version’
[17:02:50.889]   - Field: ‘result’
[17:02:50.889]   - Field: ‘asynchronous’
[17:02:50.889]   - Field: ‘calls’
[17:02:50.889]   - Field: ‘globals’
[17:02:50.889]   - Field: ‘stdout’
[17:02:50.889]   - Field: ‘earlySignal’
[17:02:50.889]   - Field: ‘lazy’
[17:02:50.890]   - Field: ‘state’
[17:02:50.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:50.890] - Launch lazy future ...
[17:02:50.890] Packages needed by the future expression (n = 0): <none>
[17:02:50.891] Packages needed by future strategies (n = 0): <none>
[17:02:50.892] {
[17:02:50.892]     {
[17:02:50.892]         {
[17:02:50.892]             ...future.startTime <- base::Sys.time()
[17:02:50.892]             {
[17:02:50.892]                 {
[17:02:50.892]                   {
[17:02:50.892]                     base::local({
[17:02:50.892]                       has_future <- base::requireNamespace("future", 
[17:02:50.892]                         quietly = TRUE)
[17:02:50.892]                       if (has_future) {
[17:02:50.892]                         ns <- base::getNamespace("future")
[17:02:50.892]                         version <- ns[[".package"]][["version"]]
[17:02:50.892]                         if (is.null(version)) 
[17:02:50.892]                           version <- utils::packageVersion("future")
[17:02:50.892]                       }
[17:02:50.892]                       else {
[17:02:50.892]                         version <- NULL
[17:02:50.892]                       }
[17:02:50.892]                       if (!has_future || version < "1.8.0") {
[17:02:50.892]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:50.892]                           "", base::R.version$version.string), 
[17:02:50.892]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:50.892]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:50.892]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:50.892]                             "release", "version")], collapse = " "), 
[17:02:50.892]                           hostname = base::Sys.info()[["nodename"]])
[17:02:50.892]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:50.892]                           info)
[17:02:50.892]                         info <- base::paste(info, collapse = "; ")
[17:02:50.892]                         if (!has_future) {
[17:02:50.892]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:50.892]                             info)
[17:02:50.892]                         }
[17:02:50.892]                         else {
[17:02:50.892]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:50.892]                             info, version)
[17:02:50.892]                         }
[17:02:50.892]                         base::stop(msg)
[17:02:50.892]                       }
[17:02:50.892]                     })
[17:02:50.892]                   }
[17:02:50.892]                   ...future.strategy.old <- future::plan("list")
[17:02:50.892]                   options(future.plan = NULL)
[17:02:50.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:50.892]                 }
[17:02:50.892]                 ...future.workdir <- getwd()
[17:02:50.892]             }
[17:02:50.892]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:50.892]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:50.892]         }
[17:02:50.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:50.892]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:50.892]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:50.892]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:50.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:50.892]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:50.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:50.892]             base::names(...future.oldOptions))
[17:02:50.892]     }
[17:02:50.892]     if (FALSE) {
[17:02:50.892]     }
[17:02:50.892]     else {
[17:02:50.892]         if (TRUE) {
[17:02:50.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:50.892]                 open = "w")
[17:02:50.892]         }
[17:02:50.892]         else {
[17:02:50.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:50.892]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:50.892]         }
[17:02:50.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:50.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:50.892]             base::sink(type = "output", split = FALSE)
[17:02:50.892]             base::close(...future.stdout)
[17:02:50.892]         }, add = TRUE)
[17:02:50.892]     }
[17:02:50.892]     ...future.frame <- base::sys.nframe()
[17:02:50.892]     ...future.conditions <- base::list()
[17:02:50.892]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:50.892]     if (FALSE) {
[17:02:50.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:50.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:50.892]     }
[17:02:50.892]     ...future.result <- base::tryCatch({
[17:02:50.892]         base::withCallingHandlers({
[17:02:50.892]             ...future.value <- base::withVisible(base::local({
[17:02:50.892]                 b <- a
[17:02:50.892]                 a <- 2
[17:02:50.892]                 a * b
[17:02:50.892]             }))
[17:02:50.892]             future::FutureResult(value = ...future.value$value, 
[17:02:50.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.892]                   ...future.rng), globalenv = if (FALSE) 
[17:02:50.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:50.892]                     ...future.globalenv.names))
[17:02:50.892]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:50.892]         }, condition = base::local({
[17:02:50.892]             c <- base::c
[17:02:50.892]             inherits <- base::inherits
[17:02:50.892]             invokeRestart <- base::invokeRestart
[17:02:50.892]             length <- base::length
[17:02:50.892]             list <- base::list
[17:02:50.892]             seq.int <- base::seq.int
[17:02:50.892]             signalCondition <- base::signalCondition
[17:02:50.892]             sys.calls <- base::sys.calls
[17:02:50.892]             `[[` <- base::`[[`
[17:02:50.892]             `+` <- base::`+`
[17:02:50.892]             `<<-` <- base::`<<-`
[17:02:50.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:50.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:50.892]                   3L)]
[17:02:50.892]             }
[17:02:50.892]             function(cond) {
[17:02:50.892]                 is_error <- inherits(cond, "error")
[17:02:50.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:50.892]                   NULL)
[17:02:50.892]                 if (is_error) {
[17:02:50.892]                   sessionInformation <- function() {
[17:02:50.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:50.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:50.892]                       search = base::search(), system = base::Sys.info())
[17:02:50.892]                   }
[17:02:50.892]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:50.892]                     cond$call), session = sessionInformation(), 
[17:02:50.892]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:50.892]                   signalCondition(cond)
[17:02:50.892]                 }
[17:02:50.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:50.892]                 "immediateCondition"))) {
[17:02:50.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:50.892]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:50.892]                   if (TRUE && !signal) {
[17:02:50.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.892]                     {
[17:02:50.892]                       inherits <- base::inherits
[17:02:50.892]                       invokeRestart <- base::invokeRestart
[17:02:50.892]                       is.null <- base::is.null
[17:02:50.892]                       muffled <- FALSE
[17:02:50.892]                       if (inherits(cond, "message")) {
[17:02:50.892]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.892]                         if (muffled) 
[17:02:50.892]                           invokeRestart("muffleMessage")
[17:02:50.892]                       }
[17:02:50.892]                       else if (inherits(cond, "warning")) {
[17:02:50.892]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.892]                         if (muffled) 
[17:02:50.892]                           invokeRestart("muffleWarning")
[17:02:50.892]                       }
[17:02:50.892]                       else if (inherits(cond, "condition")) {
[17:02:50.892]                         if (!is.null(pattern)) {
[17:02:50.892]                           computeRestarts <- base::computeRestarts
[17:02:50.892]                           grepl <- base::grepl
[17:02:50.892]                           restarts <- computeRestarts(cond)
[17:02:50.892]                           for (restart in restarts) {
[17:02:50.892]                             name <- restart$name
[17:02:50.892]                             if (is.null(name)) 
[17:02:50.892]                               next
[17:02:50.892]                             if (!grepl(pattern, name)) 
[17:02:50.892]                               next
[17:02:50.892]                             invokeRestart(restart)
[17:02:50.892]                             muffled <- TRUE
[17:02:50.892]                             break
[17:02:50.892]                           }
[17:02:50.892]                         }
[17:02:50.892]                       }
[17:02:50.892]                       invisible(muffled)
[17:02:50.892]                     }
[17:02:50.892]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.892]                   }
[17:02:50.892]                 }
[17:02:50.892]                 else {
[17:02:50.892]                   if (TRUE) {
[17:02:50.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.892]                     {
[17:02:50.892]                       inherits <- base::inherits
[17:02:50.892]                       invokeRestart <- base::invokeRestart
[17:02:50.892]                       is.null <- base::is.null
[17:02:50.892]                       muffled <- FALSE
[17:02:50.892]                       if (inherits(cond, "message")) {
[17:02:50.892]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.892]                         if (muffled) 
[17:02:50.892]                           invokeRestart("muffleMessage")
[17:02:50.892]                       }
[17:02:50.892]                       else if (inherits(cond, "warning")) {
[17:02:50.892]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.892]                         if (muffled) 
[17:02:50.892]                           invokeRestart("muffleWarning")
[17:02:50.892]                       }
[17:02:50.892]                       else if (inherits(cond, "condition")) {
[17:02:50.892]                         if (!is.null(pattern)) {
[17:02:50.892]                           computeRestarts <- base::computeRestarts
[17:02:50.892]                           grepl <- base::grepl
[17:02:50.892]                           restarts <- computeRestarts(cond)
[17:02:50.892]                           for (restart in restarts) {
[17:02:50.892]                             name <- restart$name
[17:02:50.892]                             if (is.null(name)) 
[17:02:50.892]                               next
[17:02:50.892]                             if (!grepl(pattern, name)) 
[17:02:50.892]                               next
[17:02:50.892]                             invokeRestart(restart)
[17:02:50.892]                             muffled <- TRUE
[17:02:50.892]                             break
[17:02:50.892]                           }
[17:02:50.892]                         }
[17:02:50.892]                       }
[17:02:50.892]                       invisible(muffled)
[17:02:50.892]                     }
[17:02:50.892]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.892]                   }
[17:02:50.892]                 }
[17:02:50.892]             }
[17:02:50.892]         }))
[17:02:50.892]     }, error = function(ex) {
[17:02:50.892]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:50.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.892]                 ...future.rng), started = ...future.startTime, 
[17:02:50.892]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:50.892]             version = "1.8"), class = "FutureResult")
[17:02:50.892]     }, finally = {
[17:02:50.892]         if (!identical(...future.workdir, getwd())) 
[17:02:50.892]             setwd(...future.workdir)
[17:02:50.892]         {
[17:02:50.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:50.892]                 ...future.oldOptions$nwarnings <- NULL
[17:02:50.892]             }
[17:02:50.892]             base::options(...future.oldOptions)
[17:02:50.892]             if (.Platform$OS.type == "windows") {
[17:02:50.892]                 old_names <- names(...future.oldEnvVars)
[17:02:50.892]                 envs <- base::Sys.getenv()
[17:02:50.892]                 names <- names(envs)
[17:02:50.892]                 common <- intersect(names, old_names)
[17:02:50.892]                 added <- setdiff(names, old_names)
[17:02:50.892]                 removed <- setdiff(old_names, names)
[17:02:50.892]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:50.892]                   envs[common]]
[17:02:50.892]                 NAMES <- toupper(changed)
[17:02:50.892]                 args <- list()
[17:02:50.892]                 for (kk in seq_along(NAMES)) {
[17:02:50.892]                   name <- changed[[kk]]
[17:02:50.892]                   NAME <- NAMES[[kk]]
[17:02:50.892]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.892]                     next
[17:02:50.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.892]                 }
[17:02:50.892]                 NAMES <- toupper(added)
[17:02:50.892]                 for (kk in seq_along(NAMES)) {
[17:02:50.892]                   name <- added[[kk]]
[17:02:50.892]                   NAME <- NAMES[[kk]]
[17:02:50.892]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.892]                     next
[17:02:50.892]                   args[[name]] <- ""
[17:02:50.892]                 }
[17:02:50.892]                 NAMES <- toupper(removed)
[17:02:50.892]                 for (kk in seq_along(NAMES)) {
[17:02:50.892]                   name <- removed[[kk]]
[17:02:50.892]                   NAME <- NAMES[[kk]]
[17:02:50.892]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.892]                     next
[17:02:50.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.892]                 }
[17:02:50.892]                 if (length(args) > 0) 
[17:02:50.892]                   base::do.call(base::Sys.setenv, args = args)
[17:02:50.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:50.892]             }
[17:02:50.892]             else {
[17:02:50.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:50.892]             }
[17:02:50.892]             {
[17:02:50.892]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:50.892]                   0L) {
[17:02:50.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:50.892]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:50.892]                   base::options(opts)
[17:02:50.892]                 }
[17:02:50.892]                 {
[17:02:50.892]                   {
[17:02:50.892]                     NULL
[17:02:50.892]                     RNGkind("Mersenne-Twister")
[17:02:50.892]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:50.892]                       inherits = FALSE)
[17:02:50.892]                   }
[17:02:50.892]                   options(future.plan = NULL)
[17:02:50.892]                   if (is.na(NA_character_)) 
[17:02:50.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:50.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:50.892]                     .init = FALSE)
[17:02:50.892]                 }
[17:02:50.892]             }
[17:02:50.892]         }
[17:02:50.892]     })
[17:02:50.892]     if (TRUE) {
[17:02:50.892]         base::sink(type = "output", split = FALSE)
[17:02:50.892]         if (TRUE) {
[17:02:50.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:50.892]         }
[17:02:50.892]         else {
[17:02:50.892]             ...future.result["stdout"] <- base::list(NULL)
[17:02:50.892]         }
[17:02:50.892]         base::close(...future.stdout)
[17:02:50.892]         ...future.stdout <- NULL
[17:02:50.892]     }
[17:02:50.892]     ...future.result$conditions <- ...future.conditions
[17:02:50.892]     ...future.result$finished <- base::Sys.time()
[17:02:50.892]     ...future.result
[17:02:50.892] }
[17:02:50.895] plan(): Setting new future strategy stack:
[17:02:50.895] List of future strategies:
[17:02:50.895] 1. sequential:
[17:02:50.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.895]    - tweaked: FALSE
[17:02:50.895]    - call: NULL
[17:02:50.896] plan(): nbrOfWorkers() = 1
[17:02:50.897] plan(): Setting new future strategy stack:
[17:02:50.897] List of future strategies:
[17:02:50.897] 1. sequential:
[17:02:50.897]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.897]    - tweaked: FALSE
[17:02:50.897]    - call: plan(strategy)
[17:02:50.898] plan(): nbrOfWorkers() = 1
[17:02:50.898] SequentialFuture started (and completed)
[17:02:50.899] - Launch lazy future ... done
[17:02:50.899] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.900] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.901] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.902] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:02:50.902] Searching for globals ... DONE
[17:02:50.902] Resolving globals: TRUE
[17:02:50.902] Resolving any globals that are futures ...
[17:02:50.902] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:02:50.902] Resolving any globals that are futures ... DONE
[17:02:50.903] 
[17:02:50.903] 
[17:02:50.903] getGlobalsAndPackages() ... DONE
[17:02:50.903] run() for ‘Future’ ...
[17:02:50.903] - state: ‘created’
[17:02:50.903] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:50.904] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:50.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:50.904]   - Field: ‘label’
[17:02:50.904]   - Field: ‘local’
[17:02:50.904]   - Field: ‘owner’
[17:02:50.904]   - Field: ‘envir’
[17:02:50.904]   - Field: ‘packages’
[17:02:50.904]   - Field: ‘gc’
[17:02:50.904]   - Field: ‘conditions’
[17:02:50.904]   - Field: ‘expr’
[17:02:50.905]   - Field: ‘uuid’
[17:02:50.905]   - Field: ‘seed’
[17:02:50.905]   - Field: ‘version’
[17:02:50.905]   - Field: ‘result’
[17:02:50.905]   - Field: ‘asynchronous’
[17:02:50.905]   - Field: ‘calls’
[17:02:50.905]   - Field: ‘globals’
[17:02:50.905]   - Field: ‘stdout’
[17:02:50.906]   - Field: ‘earlySignal’
[17:02:50.906]   - Field: ‘lazy’
[17:02:50.906]   - Field: ‘state’
[17:02:50.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:50.906] - Launch lazy future ...
[17:02:50.906] Packages needed by the future expression (n = 0): <none>
[17:02:50.906] Packages needed by future strategies (n = 0): <none>
[17:02:50.907] {
[17:02:50.907]     {
[17:02:50.907]         {
[17:02:50.907]             ...future.startTime <- base::Sys.time()
[17:02:50.907]             {
[17:02:50.907]                 {
[17:02:50.907]                   {
[17:02:50.907]                     base::local({
[17:02:50.907]                       has_future <- base::requireNamespace("future", 
[17:02:50.907]                         quietly = TRUE)
[17:02:50.907]                       if (has_future) {
[17:02:50.907]                         ns <- base::getNamespace("future")
[17:02:50.907]                         version <- ns[[".package"]][["version"]]
[17:02:50.907]                         if (is.null(version)) 
[17:02:50.907]                           version <- utils::packageVersion("future")
[17:02:50.907]                       }
[17:02:50.907]                       else {
[17:02:50.907]                         version <- NULL
[17:02:50.907]                       }
[17:02:50.907]                       if (!has_future || version < "1.8.0") {
[17:02:50.907]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:50.907]                           "", base::R.version$version.string), 
[17:02:50.907]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:50.907]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:50.907]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:50.907]                             "release", "version")], collapse = " "), 
[17:02:50.907]                           hostname = base::Sys.info()[["nodename"]])
[17:02:50.907]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:50.907]                           info)
[17:02:50.907]                         info <- base::paste(info, collapse = "; ")
[17:02:50.907]                         if (!has_future) {
[17:02:50.907]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:50.907]                             info)
[17:02:50.907]                         }
[17:02:50.907]                         else {
[17:02:50.907]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:50.907]                             info, version)
[17:02:50.907]                         }
[17:02:50.907]                         base::stop(msg)
[17:02:50.907]                       }
[17:02:50.907]                     })
[17:02:50.907]                   }
[17:02:50.907]                   ...future.strategy.old <- future::plan("list")
[17:02:50.907]                   options(future.plan = NULL)
[17:02:50.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:50.907]                 }
[17:02:50.907]                 ...future.workdir <- getwd()
[17:02:50.907]             }
[17:02:50.907]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:50.907]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:50.907]         }
[17:02:50.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:50.907]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:50.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:50.907]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:50.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:50.907]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:50.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:50.907]             base::names(...future.oldOptions))
[17:02:50.907]     }
[17:02:50.907]     if (FALSE) {
[17:02:50.907]     }
[17:02:50.907]     else {
[17:02:50.907]         if (TRUE) {
[17:02:50.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:50.907]                 open = "w")
[17:02:50.907]         }
[17:02:50.907]         else {
[17:02:50.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:50.907]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:50.907]         }
[17:02:50.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:50.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:50.907]             base::sink(type = "output", split = FALSE)
[17:02:50.907]             base::close(...future.stdout)
[17:02:50.907]         }, add = TRUE)
[17:02:50.907]     }
[17:02:50.907]     ...future.frame <- base::sys.nframe()
[17:02:50.907]     ...future.conditions <- base::list()
[17:02:50.907]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:50.907]     if (FALSE) {
[17:02:50.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:50.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:50.907]     }
[17:02:50.907]     ...future.result <- base::tryCatch({
[17:02:50.907]         base::withCallingHandlers({
[17:02:50.907]             ...future.value <- base::withVisible(base::local({
[17:02:50.907]                 b <- a
[17:02:50.907]                 a <- 2
[17:02:50.907]                 a * b
[17:02:50.907]             }))
[17:02:50.907]             future::FutureResult(value = ...future.value$value, 
[17:02:50.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.907]                   ...future.rng), globalenv = if (FALSE) 
[17:02:50.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:50.907]                     ...future.globalenv.names))
[17:02:50.907]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:50.907]         }, condition = base::local({
[17:02:50.907]             c <- base::c
[17:02:50.907]             inherits <- base::inherits
[17:02:50.907]             invokeRestart <- base::invokeRestart
[17:02:50.907]             length <- base::length
[17:02:50.907]             list <- base::list
[17:02:50.907]             seq.int <- base::seq.int
[17:02:50.907]             signalCondition <- base::signalCondition
[17:02:50.907]             sys.calls <- base::sys.calls
[17:02:50.907]             `[[` <- base::`[[`
[17:02:50.907]             `+` <- base::`+`
[17:02:50.907]             `<<-` <- base::`<<-`
[17:02:50.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:50.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:50.907]                   3L)]
[17:02:50.907]             }
[17:02:50.907]             function(cond) {
[17:02:50.907]                 is_error <- inherits(cond, "error")
[17:02:50.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:50.907]                   NULL)
[17:02:50.907]                 if (is_error) {
[17:02:50.907]                   sessionInformation <- function() {
[17:02:50.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:50.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:50.907]                       search = base::search(), system = base::Sys.info())
[17:02:50.907]                   }
[17:02:50.907]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:50.907]                     cond$call), session = sessionInformation(), 
[17:02:50.907]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:50.907]                   signalCondition(cond)
[17:02:50.907]                 }
[17:02:50.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:50.907]                 "immediateCondition"))) {
[17:02:50.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:50.907]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:50.907]                   if (TRUE && !signal) {
[17:02:50.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.907]                     {
[17:02:50.907]                       inherits <- base::inherits
[17:02:50.907]                       invokeRestart <- base::invokeRestart
[17:02:50.907]                       is.null <- base::is.null
[17:02:50.907]                       muffled <- FALSE
[17:02:50.907]                       if (inherits(cond, "message")) {
[17:02:50.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.907]                         if (muffled) 
[17:02:50.907]                           invokeRestart("muffleMessage")
[17:02:50.907]                       }
[17:02:50.907]                       else if (inherits(cond, "warning")) {
[17:02:50.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.907]                         if (muffled) 
[17:02:50.907]                           invokeRestart("muffleWarning")
[17:02:50.907]                       }
[17:02:50.907]                       else if (inherits(cond, "condition")) {
[17:02:50.907]                         if (!is.null(pattern)) {
[17:02:50.907]                           computeRestarts <- base::computeRestarts
[17:02:50.907]                           grepl <- base::grepl
[17:02:50.907]                           restarts <- computeRestarts(cond)
[17:02:50.907]                           for (restart in restarts) {
[17:02:50.907]                             name <- restart$name
[17:02:50.907]                             if (is.null(name)) 
[17:02:50.907]                               next
[17:02:50.907]                             if (!grepl(pattern, name)) 
[17:02:50.907]                               next
[17:02:50.907]                             invokeRestart(restart)
[17:02:50.907]                             muffled <- TRUE
[17:02:50.907]                             break
[17:02:50.907]                           }
[17:02:50.907]                         }
[17:02:50.907]                       }
[17:02:50.907]                       invisible(muffled)
[17:02:50.907]                     }
[17:02:50.907]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.907]                   }
[17:02:50.907]                 }
[17:02:50.907]                 else {
[17:02:50.907]                   if (TRUE) {
[17:02:50.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.907]                     {
[17:02:50.907]                       inherits <- base::inherits
[17:02:50.907]                       invokeRestart <- base::invokeRestart
[17:02:50.907]                       is.null <- base::is.null
[17:02:50.907]                       muffled <- FALSE
[17:02:50.907]                       if (inherits(cond, "message")) {
[17:02:50.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.907]                         if (muffled) 
[17:02:50.907]                           invokeRestart("muffleMessage")
[17:02:50.907]                       }
[17:02:50.907]                       else if (inherits(cond, "warning")) {
[17:02:50.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.907]                         if (muffled) 
[17:02:50.907]                           invokeRestart("muffleWarning")
[17:02:50.907]                       }
[17:02:50.907]                       else if (inherits(cond, "condition")) {
[17:02:50.907]                         if (!is.null(pattern)) {
[17:02:50.907]                           computeRestarts <- base::computeRestarts
[17:02:50.907]                           grepl <- base::grepl
[17:02:50.907]                           restarts <- computeRestarts(cond)
[17:02:50.907]                           for (restart in restarts) {
[17:02:50.907]                             name <- restart$name
[17:02:50.907]                             if (is.null(name)) 
[17:02:50.907]                               next
[17:02:50.907]                             if (!grepl(pattern, name)) 
[17:02:50.907]                               next
[17:02:50.907]                             invokeRestart(restart)
[17:02:50.907]                             muffled <- TRUE
[17:02:50.907]                             break
[17:02:50.907]                           }
[17:02:50.907]                         }
[17:02:50.907]                       }
[17:02:50.907]                       invisible(muffled)
[17:02:50.907]                     }
[17:02:50.907]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.907]                   }
[17:02:50.907]                 }
[17:02:50.907]             }
[17:02:50.907]         }))
[17:02:50.907]     }, error = function(ex) {
[17:02:50.907]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:50.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.907]                 ...future.rng), started = ...future.startTime, 
[17:02:50.907]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:50.907]             version = "1.8"), class = "FutureResult")
[17:02:50.907]     }, finally = {
[17:02:50.907]         if (!identical(...future.workdir, getwd())) 
[17:02:50.907]             setwd(...future.workdir)
[17:02:50.907]         {
[17:02:50.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:50.907]                 ...future.oldOptions$nwarnings <- NULL
[17:02:50.907]             }
[17:02:50.907]             base::options(...future.oldOptions)
[17:02:50.907]             if (.Platform$OS.type == "windows") {
[17:02:50.907]                 old_names <- names(...future.oldEnvVars)
[17:02:50.907]                 envs <- base::Sys.getenv()
[17:02:50.907]                 names <- names(envs)
[17:02:50.907]                 common <- intersect(names, old_names)
[17:02:50.907]                 added <- setdiff(names, old_names)
[17:02:50.907]                 removed <- setdiff(old_names, names)
[17:02:50.907]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:50.907]                   envs[common]]
[17:02:50.907]                 NAMES <- toupper(changed)
[17:02:50.907]                 args <- list()
[17:02:50.907]                 for (kk in seq_along(NAMES)) {
[17:02:50.907]                   name <- changed[[kk]]
[17:02:50.907]                   NAME <- NAMES[[kk]]
[17:02:50.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.907]                     next
[17:02:50.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.907]                 }
[17:02:50.907]                 NAMES <- toupper(added)
[17:02:50.907]                 for (kk in seq_along(NAMES)) {
[17:02:50.907]                   name <- added[[kk]]
[17:02:50.907]                   NAME <- NAMES[[kk]]
[17:02:50.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.907]                     next
[17:02:50.907]                   args[[name]] <- ""
[17:02:50.907]                 }
[17:02:50.907]                 NAMES <- toupper(removed)
[17:02:50.907]                 for (kk in seq_along(NAMES)) {
[17:02:50.907]                   name <- removed[[kk]]
[17:02:50.907]                   NAME <- NAMES[[kk]]
[17:02:50.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.907]                     next
[17:02:50.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.907]                 }
[17:02:50.907]                 if (length(args) > 0) 
[17:02:50.907]                   base::do.call(base::Sys.setenv, args = args)
[17:02:50.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:50.907]             }
[17:02:50.907]             else {
[17:02:50.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:50.907]             }
[17:02:50.907]             {
[17:02:50.907]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:50.907]                   0L) {
[17:02:50.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:50.907]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:50.907]                   base::options(opts)
[17:02:50.907]                 }
[17:02:50.907]                 {
[17:02:50.907]                   {
[17:02:50.907]                     NULL
[17:02:50.907]                     RNGkind("Mersenne-Twister")
[17:02:50.907]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:50.907]                       inherits = FALSE)
[17:02:50.907]                   }
[17:02:50.907]                   options(future.plan = NULL)
[17:02:50.907]                   if (is.na(NA_character_)) 
[17:02:50.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:50.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:50.907]                     .init = FALSE)
[17:02:50.907]                 }
[17:02:50.907]             }
[17:02:50.907]         }
[17:02:50.907]     })
[17:02:50.907]     if (TRUE) {
[17:02:50.907]         base::sink(type = "output", split = FALSE)
[17:02:50.907]         if (TRUE) {
[17:02:50.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:50.907]         }
[17:02:50.907]         else {
[17:02:50.907]             ...future.result["stdout"] <- base::list(NULL)
[17:02:50.907]         }
[17:02:50.907]         base::close(...future.stdout)
[17:02:50.907]         ...future.stdout <- NULL
[17:02:50.907]     }
[17:02:50.907]     ...future.result$conditions <- ...future.conditions
[17:02:50.907]     ...future.result$finished <- base::Sys.time()
[17:02:50.907]     ...future.result
[17:02:50.907] }
[17:02:50.908] plan(): Setting new future strategy stack:
[17:02:50.908] List of future strategies:
[17:02:50.908] 1. sequential:
[17:02:50.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.908]    - tweaked: FALSE
[17:02:50.908]    - call: NULL
[17:02:50.909] plan(): nbrOfWorkers() = 1
[17:02:50.910] plan(): Setting new future strategy stack:
[17:02:50.910] List of future strategies:
[17:02:50.910] 1. sequential:
[17:02:50.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.910]    - tweaked: FALSE
[17:02:50.910]    - call: plan(strategy)
[17:02:50.910] plan(): nbrOfWorkers() = 1
[17:02:50.911] SequentialFuture started (and completed)
[17:02:50.911] signalConditions() ...
[17:02:50.911]  - include = ‘immediateCondition’
[17:02:50.911]  - exclude = 
[17:02:50.911]  - resignal = FALSE
[17:02:50.911]  - Number of conditions: 1
[17:02:50.911] signalConditions() ... done
[17:02:50.911] - Launch lazy future ... done
[17:02:50.911] run() for ‘SequentialFuture’ ... done
[17:02:50.911] signalConditions() ...
[17:02:50.912]  - include = ‘immediateCondition’
[17:02:50.912]  - exclude = 
[17:02:50.912]  - resignal = FALSE
[17:02:50.912]  - Number of conditions: 1
[17:02:50.912] signalConditions() ... done
[17:02:50.912] Future state: ‘finished’
[17:02:50.912] signalConditions() ...
[17:02:50.912]  - include = ‘condition’
[17:02:50.915]  - exclude = ‘immediateCondition’
[17:02:50.915]  - resignal = TRUE
[17:02:50.915]  - Number of conditions: 1
[17:02:50.915]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:50.915] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:50"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.931] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.931] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.932] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.933] Searching for globals ... DONE
[17:02:50.933] Resolving globals: TRUE
[17:02:50.933] Resolving any globals that are futures ...
[17:02:50.933] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.933] Resolving any globals that are futures ... DONE
[17:02:50.933] Resolving futures part of globals (recursively) ...
[17:02:50.934] resolve() on list ...
[17:02:50.934]  recursive: 99
[17:02:50.934]  length: 1
[17:02:50.934]  elements: ‘ii’
[17:02:50.935]  length: 0 (resolved future 1)
[17:02:50.935] resolve() on list ... DONE
[17:02:50.935] - globals: [1] ‘ii’
[17:02:50.935] Resolving futures part of globals (recursively) ... DONE
[17:02:50.935] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:50.936] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:50.936] - globals: [1] ‘ii’
[17:02:50.936] 
[17:02:50.936] getGlobalsAndPackages() ... DONE
[17:02:50.936] run() for ‘Future’ ...
[17:02:50.936] - state: ‘created’
[17:02:50.936] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:50.937] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:50.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:50.937]   - Field: ‘label’
[17:02:50.937]   - Field: ‘local’
[17:02:50.937]   - Field: ‘owner’
[17:02:50.937]   - Field: ‘envir’
[17:02:50.937]   - Field: ‘packages’
[17:02:50.937]   - Field: ‘gc’
[17:02:50.938]   - Field: ‘conditions’
[17:02:50.938]   - Field: ‘expr’
[17:02:50.938]   - Field: ‘uuid’
[17:02:50.938]   - Field: ‘seed’
[17:02:50.938]   - Field: ‘version’
[17:02:50.938]   - Field: ‘result’
[17:02:50.938]   - Field: ‘asynchronous’
[17:02:50.938]   - Field: ‘calls’
[17:02:50.938]   - Field: ‘globals’
[17:02:50.938]   - Field: ‘stdout’
[17:02:50.938]   - Field: ‘earlySignal’
[17:02:50.938]   - Field: ‘lazy’
[17:02:50.939]   - Field: ‘state’
[17:02:50.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:50.939] - Launch lazy future ...
[17:02:50.939] Packages needed by the future expression (n = 0): <none>
[17:02:50.939] Packages needed by future strategies (n = 0): <none>
[17:02:50.939] {
[17:02:50.939]     {
[17:02:50.939]         {
[17:02:50.939]             ...future.startTime <- base::Sys.time()
[17:02:50.939]             {
[17:02:50.939]                 {
[17:02:50.939]                   {
[17:02:50.939]                     base::local({
[17:02:50.939]                       has_future <- base::requireNamespace("future", 
[17:02:50.939]                         quietly = TRUE)
[17:02:50.939]                       if (has_future) {
[17:02:50.939]                         ns <- base::getNamespace("future")
[17:02:50.939]                         version <- ns[[".package"]][["version"]]
[17:02:50.939]                         if (is.null(version)) 
[17:02:50.939]                           version <- utils::packageVersion("future")
[17:02:50.939]                       }
[17:02:50.939]                       else {
[17:02:50.939]                         version <- NULL
[17:02:50.939]                       }
[17:02:50.939]                       if (!has_future || version < "1.8.0") {
[17:02:50.939]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:50.939]                           "", base::R.version$version.string), 
[17:02:50.939]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:50.939]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:50.939]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:50.939]                             "release", "version")], collapse = " "), 
[17:02:50.939]                           hostname = base::Sys.info()[["nodename"]])
[17:02:50.939]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:50.939]                           info)
[17:02:50.939]                         info <- base::paste(info, collapse = "; ")
[17:02:50.939]                         if (!has_future) {
[17:02:50.939]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:50.939]                             info)
[17:02:50.939]                         }
[17:02:50.939]                         else {
[17:02:50.939]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:50.939]                             info, version)
[17:02:50.939]                         }
[17:02:50.939]                         base::stop(msg)
[17:02:50.939]                       }
[17:02:50.939]                     })
[17:02:50.939]                   }
[17:02:50.939]                   ...future.strategy.old <- future::plan("list")
[17:02:50.939]                   options(future.plan = NULL)
[17:02:50.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:50.939]                 }
[17:02:50.939]                 ...future.workdir <- getwd()
[17:02:50.939]             }
[17:02:50.939]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:50.939]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:50.939]         }
[17:02:50.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:50.939]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:50.939]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:50.939]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:50.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:50.939]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:50.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:50.939]             base::names(...future.oldOptions))
[17:02:50.939]     }
[17:02:50.939]     if (FALSE) {
[17:02:50.939]     }
[17:02:50.939]     else {
[17:02:50.939]         if (TRUE) {
[17:02:50.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:50.939]                 open = "w")
[17:02:50.939]         }
[17:02:50.939]         else {
[17:02:50.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:50.939]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:50.939]         }
[17:02:50.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:50.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:50.939]             base::sink(type = "output", split = FALSE)
[17:02:50.939]             base::close(...future.stdout)
[17:02:50.939]         }, add = TRUE)
[17:02:50.939]     }
[17:02:50.939]     ...future.frame <- base::sys.nframe()
[17:02:50.939]     ...future.conditions <- base::list()
[17:02:50.939]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:50.939]     if (FALSE) {
[17:02:50.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:50.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:50.939]     }
[17:02:50.939]     ...future.result <- base::tryCatch({
[17:02:50.939]         base::withCallingHandlers({
[17:02:50.939]             ...future.value <- base::withVisible(base::local({
[17:02:50.939]                 b <- a * ii
[17:02:50.939]                 a <- 0
[17:02:50.939]                 b
[17:02:50.939]             }))
[17:02:50.939]             future::FutureResult(value = ...future.value$value, 
[17:02:50.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.939]                   ...future.rng), globalenv = if (FALSE) 
[17:02:50.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:50.939]                     ...future.globalenv.names))
[17:02:50.939]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:50.939]         }, condition = base::local({
[17:02:50.939]             c <- base::c
[17:02:50.939]             inherits <- base::inherits
[17:02:50.939]             invokeRestart <- base::invokeRestart
[17:02:50.939]             length <- base::length
[17:02:50.939]             list <- base::list
[17:02:50.939]             seq.int <- base::seq.int
[17:02:50.939]             signalCondition <- base::signalCondition
[17:02:50.939]             sys.calls <- base::sys.calls
[17:02:50.939]             `[[` <- base::`[[`
[17:02:50.939]             `+` <- base::`+`
[17:02:50.939]             `<<-` <- base::`<<-`
[17:02:50.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:50.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:50.939]                   3L)]
[17:02:50.939]             }
[17:02:50.939]             function(cond) {
[17:02:50.939]                 is_error <- inherits(cond, "error")
[17:02:50.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:50.939]                   NULL)
[17:02:50.939]                 if (is_error) {
[17:02:50.939]                   sessionInformation <- function() {
[17:02:50.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:50.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:50.939]                       search = base::search(), system = base::Sys.info())
[17:02:50.939]                   }
[17:02:50.939]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:50.939]                     cond$call), session = sessionInformation(), 
[17:02:50.939]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:50.939]                   signalCondition(cond)
[17:02:50.939]                 }
[17:02:50.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:50.939]                 "immediateCondition"))) {
[17:02:50.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:50.939]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:50.939]                   if (TRUE && !signal) {
[17:02:50.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.939]                     {
[17:02:50.939]                       inherits <- base::inherits
[17:02:50.939]                       invokeRestart <- base::invokeRestart
[17:02:50.939]                       is.null <- base::is.null
[17:02:50.939]                       muffled <- FALSE
[17:02:50.939]                       if (inherits(cond, "message")) {
[17:02:50.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.939]                         if (muffled) 
[17:02:50.939]                           invokeRestart("muffleMessage")
[17:02:50.939]                       }
[17:02:50.939]                       else if (inherits(cond, "warning")) {
[17:02:50.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.939]                         if (muffled) 
[17:02:50.939]                           invokeRestart("muffleWarning")
[17:02:50.939]                       }
[17:02:50.939]                       else if (inherits(cond, "condition")) {
[17:02:50.939]                         if (!is.null(pattern)) {
[17:02:50.939]                           computeRestarts <- base::computeRestarts
[17:02:50.939]                           grepl <- base::grepl
[17:02:50.939]                           restarts <- computeRestarts(cond)
[17:02:50.939]                           for (restart in restarts) {
[17:02:50.939]                             name <- restart$name
[17:02:50.939]                             if (is.null(name)) 
[17:02:50.939]                               next
[17:02:50.939]                             if (!grepl(pattern, name)) 
[17:02:50.939]                               next
[17:02:50.939]                             invokeRestart(restart)
[17:02:50.939]                             muffled <- TRUE
[17:02:50.939]                             break
[17:02:50.939]                           }
[17:02:50.939]                         }
[17:02:50.939]                       }
[17:02:50.939]                       invisible(muffled)
[17:02:50.939]                     }
[17:02:50.939]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.939]                   }
[17:02:50.939]                 }
[17:02:50.939]                 else {
[17:02:50.939]                   if (TRUE) {
[17:02:50.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.939]                     {
[17:02:50.939]                       inherits <- base::inherits
[17:02:50.939]                       invokeRestart <- base::invokeRestart
[17:02:50.939]                       is.null <- base::is.null
[17:02:50.939]                       muffled <- FALSE
[17:02:50.939]                       if (inherits(cond, "message")) {
[17:02:50.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.939]                         if (muffled) 
[17:02:50.939]                           invokeRestart("muffleMessage")
[17:02:50.939]                       }
[17:02:50.939]                       else if (inherits(cond, "warning")) {
[17:02:50.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.939]                         if (muffled) 
[17:02:50.939]                           invokeRestart("muffleWarning")
[17:02:50.939]                       }
[17:02:50.939]                       else if (inherits(cond, "condition")) {
[17:02:50.939]                         if (!is.null(pattern)) {
[17:02:50.939]                           computeRestarts <- base::computeRestarts
[17:02:50.939]                           grepl <- base::grepl
[17:02:50.939]                           restarts <- computeRestarts(cond)
[17:02:50.939]                           for (restart in restarts) {
[17:02:50.939]                             name <- restart$name
[17:02:50.939]                             if (is.null(name)) 
[17:02:50.939]                               next
[17:02:50.939]                             if (!grepl(pattern, name)) 
[17:02:50.939]                               next
[17:02:50.939]                             invokeRestart(restart)
[17:02:50.939]                             muffled <- TRUE
[17:02:50.939]                             break
[17:02:50.939]                           }
[17:02:50.939]                         }
[17:02:50.939]                       }
[17:02:50.939]                       invisible(muffled)
[17:02:50.939]                     }
[17:02:50.939]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.939]                   }
[17:02:50.939]                 }
[17:02:50.939]             }
[17:02:50.939]         }))
[17:02:50.939]     }, error = function(ex) {
[17:02:50.939]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:50.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.939]                 ...future.rng), started = ...future.startTime, 
[17:02:50.939]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:50.939]             version = "1.8"), class = "FutureResult")
[17:02:50.939]     }, finally = {
[17:02:50.939]         if (!identical(...future.workdir, getwd())) 
[17:02:50.939]             setwd(...future.workdir)
[17:02:50.939]         {
[17:02:50.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:50.939]                 ...future.oldOptions$nwarnings <- NULL
[17:02:50.939]             }
[17:02:50.939]             base::options(...future.oldOptions)
[17:02:50.939]             if (.Platform$OS.type == "windows") {
[17:02:50.939]                 old_names <- names(...future.oldEnvVars)
[17:02:50.939]                 envs <- base::Sys.getenv()
[17:02:50.939]                 names <- names(envs)
[17:02:50.939]                 common <- intersect(names, old_names)
[17:02:50.939]                 added <- setdiff(names, old_names)
[17:02:50.939]                 removed <- setdiff(old_names, names)
[17:02:50.939]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:50.939]                   envs[common]]
[17:02:50.939]                 NAMES <- toupper(changed)
[17:02:50.939]                 args <- list()
[17:02:50.939]                 for (kk in seq_along(NAMES)) {
[17:02:50.939]                   name <- changed[[kk]]
[17:02:50.939]                   NAME <- NAMES[[kk]]
[17:02:50.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.939]                     next
[17:02:50.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.939]                 }
[17:02:50.939]                 NAMES <- toupper(added)
[17:02:50.939]                 for (kk in seq_along(NAMES)) {
[17:02:50.939]                   name <- added[[kk]]
[17:02:50.939]                   NAME <- NAMES[[kk]]
[17:02:50.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.939]                     next
[17:02:50.939]                   args[[name]] <- ""
[17:02:50.939]                 }
[17:02:50.939]                 NAMES <- toupper(removed)
[17:02:50.939]                 for (kk in seq_along(NAMES)) {
[17:02:50.939]                   name <- removed[[kk]]
[17:02:50.939]                   NAME <- NAMES[[kk]]
[17:02:50.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.939]                     next
[17:02:50.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.939]                 }
[17:02:50.939]                 if (length(args) > 0) 
[17:02:50.939]                   base::do.call(base::Sys.setenv, args = args)
[17:02:50.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:50.939]             }
[17:02:50.939]             else {
[17:02:50.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:50.939]             }
[17:02:50.939]             {
[17:02:50.939]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:50.939]                   0L) {
[17:02:50.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:50.939]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:50.939]                   base::options(opts)
[17:02:50.939]                 }
[17:02:50.939]                 {
[17:02:50.939]                   {
[17:02:50.939]                     NULL
[17:02:50.939]                     RNGkind("Mersenne-Twister")
[17:02:50.939]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:50.939]                       inherits = FALSE)
[17:02:50.939]                   }
[17:02:50.939]                   options(future.plan = NULL)
[17:02:50.939]                   if (is.na(NA_character_)) 
[17:02:50.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:50.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:50.939]                     .init = FALSE)
[17:02:50.939]                 }
[17:02:50.939]             }
[17:02:50.939]         }
[17:02:50.939]     })
[17:02:50.939]     if (TRUE) {
[17:02:50.939]         base::sink(type = "output", split = FALSE)
[17:02:50.939]         if (TRUE) {
[17:02:50.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:50.939]         }
[17:02:50.939]         else {
[17:02:50.939]             ...future.result["stdout"] <- base::list(NULL)
[17:02:50.939]         }
[17:02:50.939]         base::close(...future.stdout)
[17:02:50.939]         ...future.stdout <- NULL
[17:02:50.939]     }
[17:02:50.939]     ...future.result$conditions <- ...future.conditions
[17:02:50.939]     ...future.result$finished <- base::Sys.time()
[17:02:50.939]     ...future.result
[17:02:50.939] }
[17:02:50.941] assign_globals() ...
[17:02:50.941] List of 1
[17:02:50.941]  $ ii: int 1
[17:02:50.941]  - attr(*, "where")=List of 1
[17:02:50.941]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:50.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:50.941]  - attr(*, "resolved")= logi TRUE
[17:02:50.941]  - attr(*, "total_size")= num 56
[17:02:50.941]  - attr(*, "already-done")= logi TRUE
[17:02:50.944] - copied ‘ii’ to environment
[17:02:50.944] assign_globals() ... done
[17:02:50.944] plan(): Setting new future strategy stack:
[17:02:50.944] List of future strategies:
[17:02:50.944] 1. sequential:
[17:02:50.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.944]    - tweaked: FALSE
[17:02:50.944]    - call: NULL
[17:02:50.947] plan(): nbrOfWorkers() = 1
[17:02:50.947] plan(): Setting new future strategy stack:
[17:02:50.947] List of future strategies:
[17:02:50.947] 1. sequential:
[17:02:50.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.947]    - tweaked: FALSE
[17:02:50.947]    - call: plan(strategy)
[17:02:50.948] plan(): nbrOfWorkers() = 1
[17:02:50.948] SequentialFuture started (and completed)
[17:02:50.948] - Launch lazy future ... done
[17:02:50.948] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.949] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.949] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.950] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.950] Searching for globals ... DONE
[17:02:50.950] Resolving globals: TRUE
[17:02:50.951] Resolving any globals that are futures ...
[17:02:50.951] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.951] Resolving any globals that are futures ... DONE
[17:02:50.951] Resolving futures part of globals (recursively) ...
[17:02:50.951] resolve() on list ...
[17:02:50.951]  recursive: 99
[17:02:50.951]  length: 1
[17:02:50.952]  elements: ‘ii’
[17:02:50.952]  length: 0 (resolved future 1)
[17:02:50.952] resolve() on list ... DONE
[17:02:50.952] - globals: [1] ‘ii’
[17:02:50.952] Resolving futures part of globals (recursively) ... DONE
[17:02:50.952] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:50.952] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:50.952] - globals: [1] ‘ii’
[17:02:50.953] 
[17:02:50.953] getGlobalsAndPackages() ... DONE
[17:02:50.953] run() for ‘Future’ ...
[17:02:50.953] - state: ‘created’
[17:02:50.953] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:50.953] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:50.953] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:50.954]   - Field: ‘label’
[17:02:50.954]   - Field: ‘local’
[17:02:50.954]   - Field: ‘owner’
[17:02:50.954]   - Field: ‘envir’
[17:02:50.954]   - Field: ‘packages’
[17:02:50.954]   - Field: ‘gc’
[17:02:50.954]   - Field: ‘conditions’
[17:02:50.954]   - Field: ‘expr’
[17:02:50.954]   - Field: ‘uuid’
[17:02:50.954]   - Field: ‘seed’
[17:02:50.954]   - Field: ‘version’
[17:02:50.955]   - Field: ‘result’
[17:02:50.955]   - Field: ‘asynchronous’
[17:02:50.955]   - Field: ‘calls’
[17:02:50.955]   - Field: ‘globals’
[17:02:50.955]   - Field: ‘stdout’
[17:02:50.955]   - Field: ‘earlySignal’
[17:02:50.955]   - Field: ‘lazy’
[17:02:50.955]   - Field: ‘state’
[17:02:50.955] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:50.955] - Launch lazy future ...
[17:02:50.956] Packages needed by the future expression (n = 0): <none>
[17:02:50.956] Packages needed by future strategies (n = 0): <none>
[17:02:50.956] {
[17:02:50.956]     {
[17:02:50.956]         {
[17:02:50.956]             ...future.startTime <- base::Sys.time()
[17:02:50.956]             {
[17:02:50.956]                 {
[17:02:50.956]                   {
[17:02:50.956]                     base::local({
[17:02:50.956]                       has_future <- base::requireNamespace("future", 
[17:02:50.956]                         quietly = TRUE)
[17:02:50.956]                       if (has_future) {
[17:02:50.956]                         ns <- base::getNamespace("future")
[17:02:50.956]                         version <- ns[[".package"]][["version"]]
[17:02:50.956]                         if (is.null(version)) 
[17:02:50.956]                           version <- utils::packageVersion("future")
[17:02:50.956]                       }
[17:02:50.956]                       else {
[17:02:50.956]                         version <- NULL
[17:02:50.956]                       }
[17:02:50.956]                       if (!has_future || version < "1.8.0") {
[17:02:50.956]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:50.956]                           "", base::R.version$version.string), 
[17:02:50.956]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:50.956]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:50.956]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:50.956]                             "release", "version")], collapse = " "), 
[17:02:50.956]                           hostname = base::Sys.info()[["nodename"]])
[17:02:50.956]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:50.956]                           info)
[17:02:50.956]                         info <- base::paste(info, collapse = "; ")
[17:02:50.956]                         if (!has_future) {
[17:02:50.956]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:50.956]                             info)
[17:02:50.956]                         }
[17:02:50.956]                         else {
[17:02:50.956]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:50.956]                             info, version)
[17:02:50.956]                         }
[17:02:50.956]                         base::stop(msg)
[17:02:50.956]                       }
[17:02:50.956]                     })
[17:02:50.956]                   }
[17:02:50.956]                   ...future.strategy.old <- future::plan("list")
[17:02:50.956]                   options(future.plan = NULL)
[17:02:50.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:50.956]                 }
[17:02:50.956]                 ...future.workdir <- getwd()
[17:02:50.956]             }
[17:02:50.956]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:50.956]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:50.956]         }
[17:02:50.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:50.956]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:50.956]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:50.956]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:50.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:50.956]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:50.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:50.956]             base::names(...future.oldOptions))
[17:02:50.956]     }
[17:02:50.956]     if (FALSE) {
[17:02:50.956]     }
[17:02:50.956]     else {
[17:02:50.956]         if (TRUE) {
[17:02:50.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:50.956]                 open = "w")
[17:02:50.956]         }
[17:02:50.956]         else {
[17:02:50.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:50.956]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:50.956]         }
[17:02:50.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:50.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:50.956]             base::sink(type = "output", split = FALSE)
[17:02:50.956]             base::close(...future.stdout)
[17:02:50.956]         }, add = TRUE)
[17:02:50.956]     }
[17:02:50.956]     ...future.frame <- base::sys.nframe()
[17:02:50.956]     ...future.conditions <- base::list()
[17:02:50.956]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:50.956]     if (FALSE) {
[17:02:50.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:50.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:50.956]     }
[17:02:50.956]     ...future.result <- base::tryCatch({
[17:02:50.956]         base::withCallingHandlers({
[17:02:50.956]             ...future.value <- base::withVisible(base::local({
[17:02:50.956]                 b <- a * ii
[17:02:50.956]                 a <- 0
[17:02:50.956]                 b
[17:02:50.956]             }))
[17:02:50.956]             future::FutureResult(value = ...future.value$value, 
[17:02:50.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.956]                   ...future.rng), globalenv = if (FALSE) 
[17:02:50.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:50.956]                     ...future.globalenv.names))
[17:02:50.956]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:50.956]         }, condition = base::local({
[17:02:50.956]             c <- base::c
[17:02:50.956]             inherits <- base::inherits
[17:02:50.956]             invokeRestart <- base::invokeRestart
[17:02:50.956]             length <- base::length
[17:02:50.956]             list <- base::list
[17:02:50.956]             seq.int <- base::seq.int
[17:02:50.956]             signalCondition <- base::signalCondition
[17:02:50.956]             sys.calls <- base::sys.calls
[17:02:50.956]             `[[` <- base::`[[`
[17:02:50.956]             `+` <- base::`+`
[17:02:50.956]             `<<-` <- base::`<<-`
[17:02:50.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:50.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:50.956]                   3L)]
[17:02:50.956]             }
[17:02:50.956]             function(cond) {
[17:02:50.956]                 is_error <- inherits(cond, "error")
[17:02:50.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:50.956]                   NULL)
[17:02:50.956]                 if (is_error) {
[17:02:50.956]                   sessionInformation <- function() {
[17:02:50.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:50.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:50.956]                       search = base::search(), system = base::Sys.info())
[17:02:50.956]                   }
[17:02:50.956]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:50.956]                     cond$call), session = sessionInformation(), 
[17:02:50.956]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:50.956]                   signalCondition(cond)
[17:02:50.956]                 }
[17:02:50.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:50.956]                 "immediateCondition"))) {
[17:02:50.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:50.956]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:50.956]                   if (TRUE && !signal) {
[17:02:50.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.956]                     {
[17:02:50.956]                       inherits <- base::inherits
[17:02:50.956]                       invokeRestart <- base::invokeRestart
[17:02:50.956]                       is.null <- base::is.null
[17:02:50.956]                       muffled <- FALSE
[17:02:50.956]                       if (inherits(cond, "message")) {
[17:02:50.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.956]                         if (muffled) 
[17:02:50.956]                           invokeRestart("muffleMessage")
[17:02:50.956]                       }
[17:02:50.956]                       else if (inherits(cond, "warning")) {
[17:02:50.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.956]                         if (muffled) 
[17:02:50.956]                           invokeRestart("muffleWarning")
[17:02:50.956]                       }
[17:02:50.956]                       else if (inherits(cond, "condition")) {
[17:02:50.956]                         if (!is.null(pattern)) {
[17:02:50.956]                           computeRestarts <- base::computeRestarts
[17:02:50.956]                           grepl <- base::grepl
[17:02:50.956]                           restarts <- computeRestarts(cond)
[17:02:50.956]                           for (restart in restarts) {
[17:02:50.956]                             name <- restart$name
[17:02:50.956]                             if (is.null(name)) 
[17:02:50.956]                               next
[17:02:50.956]                             if (!grepl(pattern, name)) 
[17:02:50.956]                               next
[17:02:50.956]                             invokeRestart(restart)
[17:02:50.956]                             muffled <- TRUE
[17:02:50.956]                             break
[17:02:50.956]                           }
[17:02:50.956]                         }
[17:02:50.956]                       }
[17:02:50.956]                       invisible(muffled)
[17:02:50.956]                     }
[17:02:50.956]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.956]                   }
[17:02:50.956]                 }
[17:02:50.956]                 else {
[17:02:50.956]                   if (TRUE) {
[17:02:50.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.956]                     {
[17:02:50.956]                       inherits <- base::inherits
[17:02:50.956]                       invokeRestart <- base::invokeRestart
[17:02:50.956]                       is.null <- base::is.null
[17:02:50.956]                       muffled <- FALSE
[17:02:50.956]                       if (inherits(cond, "message")) {
[17:02:50.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.956]                         if (muffled) 
[17:02:50.956]                           invokeRestart("muffleMessage")
[17:02:50.956]                       }
[17:02:50.956]                       else if (inherits(cond, "warning")) {
[17:02:50.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.956]                         if (muffled) 
[17:02:50.956]                           invokeRestart("muffleWarning")
[17:02:50.956]                       }
[17:02:50.956]                       else if (inherits(cond, "condition")) {
[17:02:50.956]                         if (!is.null(pattern)) {
[17:02:50.956]                           computeRestarts <- base::computeRestarts
[17:02:50.956]                           grepl <- base::grepl
[17:02:50.956]                           restarts <- computeRestarts(cond)
[17:02:50.956]                           for (restart in restarts) {
[17:02:50.956]                             name <- restart$name
[17:02:50.956]                             if (is.null(name)) 
[17:02:50.956]                               next
[17:02:50.956]                             if (!grepl(pattern, name)) 
[17:02:50.956]                               next
[17:02:50.956]                             invokeRestart(restart)
[17:02:50.956]                             muffled <- TRUE
[17:02:50.956]                             break
[17:02:50.956]                           }
[17:02:50.956]                         }
[17:02:50.956]                       }
[17:02:50.956]                       invisible(muffled)
[17:02:50.956]                     }
[17:02:50.956]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.956]                   }
[17:02:50.956]                 }
[17:02:50.956]             }
[17:02:50.956]         }))
[17:02:50.956]     }, error = function(ex) {
[17:02:50.956]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:50.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.956]                 ...future.rng), started = ...future.startTime, 
[17:02:50.956]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:50.956]             version = "1.8"), class = "FutureResult")
[17:02:50.956]     }, finally = {
[17:02:50.956]         if (!identical(...future.workdir, getwd())) 
[17:02:50.956]             setwd(...future.workdir)
[17:02:50.956]         {
[17:02:50.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:50.956]                 ...future.oldOptions$nwarnings <- NULL
[17:02:50.956]             }
[17:02:50.956]             base::options(...future.oldOptions)
[17:02:50.956]             if (.Platform$OS.type == "windows") {
[17:02:50.956]                 old_names <- names(...future.oldEnvVars)
[17:02:50.956]                 envs <- base::Sys.getenv()
[17:02:50.956]                 names <- names(envs)
[17:02:50.956]                 common <- intersect(names, old_names)
[17:02:50.956]                 added <- setdiff(names, old_names)
[17:02:50.956]                 removed <- setdiff(old_names, names)
[17:02:50.956]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:50.956]                   envs[common]]
[17:02:50.956]                 NAMES <- toupper(changed)
[17:02:50.956]                 args <- list()
[17:02:50.956]                 for (kk in seq_along(NAMES)) {
[17:02:50.956]                   name <- changed[[kk]]
[17:02:50.956]                   NAME <- NAMES[[kk]]
[17:02:50.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.956]                     next
[17:02:50.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.956]                 }
[17:02:50.956]                 NAMES <- toupper(added)
[17:02:50.956]                 for (kk in seq_along(NAMES)) {
[17:02:50.956]                   name <- added[[kk]]
[17:02:50.956]                   NAME <- NAMES[[kk]]
[17:02:50.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.956]                     next
[17:02:50.956]                   args[[name]] <- ""
[17:02:50.956]                 }
[17:02:50.956]                 NAMES <- toupper(removed)
[17:02:50.956]                 for (kk in seq_along(NAMES)) {
[17:02:50.956]                   name <- removed[[kk]]
[17:02:50.956]                   NAME <- NAMES[[kk]]
[17:02:50.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.956]                     next
[17:02:50.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.956]                 }
[17:02:50.956]                 if (length(args) > 0) 
[17:02:50.956]                   base::do.call(base::Sys.setenv, args = args)
[17:02:50.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:50.956]             }
[17:02:50.956]             else {
[17:02:50.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:50.956]             }
[17:02:50.956]             {
[17:02:50.956]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:50.956]                   0L) {
[17:02:50.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:50.956]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:50.956]                   base::options(opts)
[17:02:50.956]                 }
[17:02:50.956]                 {
[17:02:50.956]                   {
[17:02:50.956]                     NULL
[17:02:50.956]                     RNGkind("Mersenne-Twister")
[17:02:50.956]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:50.956]                       inherits = FALSE)
[17:02:50.956]                   }
[17:02:50.956]                   options(future.plan = NULL)
[17:02:50.956]                   if (is.na(NA_character_)) 
[17:02:50.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:50.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:50.956]                     .init = FALSE)
[17:02:50.956]                 }
[17:02:50.956]             }
[17:02:50.956]         }
[17:02:50.956]     })
[17:02:50.956]     if (TRUE) {
[17:02:50.956]         base::sink(type = "output", split = FALSE)
[17:02:50.956]         if (TRUE) {
[17:02:50.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:50.956]         }
[17:02:50.956]         else {
[17:02:50.956]             ...future.result["stdout"] <- base::list(NULL)
[17:02:50.956]         }
[17:02:50.956]         base::close(...future.stdout)
[17:02:50.956]         ...future.stdout <- NULL
[17:02:50.956]     }
[17:02:50.956]     ...future.result$conditions <- ...future.conditions
[17:02:50.956]     ...future.result$finished <- base::Sys.time()
[17:02:50.956]     ...future.result
[17:02:50.956] }
[17:02:50.958] assign_globals() ...
[17:02:50.958] List of 1
[17:02:50.958]  $ ii: int 2
[17:02:50.958]  - attr(*, "where")=List of 1
[17:02:50.958]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:50.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:50.958]  - attr(*, "resolved")= logi TRUE
[17:02:50.958]  - attr(*, "total_size")= num 56
[17:02:50.958]  - attr(*, "already-done")= logi TRUE
[17:02:50.960] - copied ‘ii’ to environment
[17:02:50.960] assign_globals() ... done
[17:02:50.960] plan(): Setting new future strategy stack:
[17:02:50.961] List of future strategies:
[17:02:50.961] 1. sequential:
[17:02:50.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.961]    - tweaked: FALSE
[17:02:50.961]    - call: NULL
[17:02:50.961] plan(): nbrOfWorkers() = 1
[17:02:50.962] plan(): Setting new future strategy stack:
[17:02:50.962] List of future strategies:
[17:02:50.962] 1. sequential:
[17:02:50.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.962]    - tweaked: FALSE
[17:02:50.962]    - call: plan(strategy)
[17:02:50.962] plan(): nbrOfWorkers() = 1
[17:02:50.962] SequentialFuture started (and completed)
[17:02:50.963] - Launch lazy future ... done
[17:02:50.963] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.963] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.963] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.965] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.965] Searching for globals ... DONE
[17:02:50.965] Resolving globals: TRUE
[17:02:50.965] Resolving any globals that are futures ...
[17:02:50.965] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.965] Resolving any globals that are futures ... DONE
[17:02:50.965] Resolving futures part of globals (recursively) ...
[17:02:50.966] resolve() on list ...
[17:02:50.966]  recursive: 99
[17:02:50.966]  length: 1
[17:02:50.966]  elements: ‘ii’
[17:02:50.966]  length: 0 (resolved future 1)
[17:02:50.966] resolve() on list ... DONE
[17:02:50.966] - globals: [1] ‘ii’
[17:02:50.966] Resolving futures part of globals (recursively) ... DONE
[17:02:50.966] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:50.967] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:50.967] - globals: [1] ‘ii’
[17:02:50.967] 
[17:02:50.967] getGlobalsAndPackages() ... DONE
[17:02:50.967] run() for ‘Future’ ...
[17:02:50.967] - state: ‘created’
[17:02:50.968] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:50.968] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:50.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:50.968]   - Field: ‘label’
[17:02:50.968]   - Field: ‘local’
[17:02:50.968]   - Field: ‘owner’
[17:02:50.968]   - Field: ‘envir’
[17:02:50.968]   - Field: ‘packages’
[17:02:50.968]   - Field: ‘gc’
[17:02:50.969]   - Field: ‘conditions’
[17:02:50.969]   - Field: ‘expr’
[17:02:50.969]   - Field: ‘uuid’
[17:02:50.969]   - Field: ‘seed’
[17:02:50.969]   - Field: ‘version’
[17:02:50.969]   - Field: ‘result’
[17:02:50.969]   - Field: ‘asynchronous’
[17:02:50.969]   - Field: ‘calls’
[17:02:50.969]   - Field: ‘globals’
[17:02:50.969]   - Field: ‘stdout’
[17:02:50.969]   - Field: ‘earlySignal’
[17:02:50.970]   - Field: ‘lazy’
[17:02:50.970]   - Field: ‘state’
[17:02:50.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:50.970] - Launch lazy future ...
[17:02:50.970] Packages needed by the future expression (n = 0): <none>
[17:02:50.970] Packages needed by future strategies (n = 0): <none>
[17:02:50.971] {
[17:02:50.971]     {
[17:02:50.971]         {
[17:02:50.971]             ...future.startTime <- base::Sys.time()
[17:02:50.971]             {
[17:02:50.971]                 {
[17:02:50.971]                   {
[17:02:50.971]                     base::local({
[17:02:50.971]                       has_future <- base::requireNamespace("future", 
[17:02:50.971]                         quietly = TRUE)
[17:02:50.971]                       if (has_future) {
[17:02:50.971]                         ns <- base::getNamespace("future")
[17:02:50.971]                         version <- ns[[".package"]][["version"]]
[17:02:50.971]                         if (is.null(version)) 
[17:02:50.971]                           version <- utils::packageVersion("future")
[17:02:50.971]                       }
[17:02:50.971]                       else {
[17:02:50.971]                         version <- NULL
[17:02:50.971]                       }
[17:02:50.971]                       if (!has_future || version < "1.8.0") {
[17:02:50.971]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:50.971]                           "", base::R.version$version.string), 
[17:02:50.971]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:50.971]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:50.971]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:50.971]                             "release", "version")], collapse = " "), 
[17:02:50.971]                           hostname = base::Sys.info()[["nodename"]])
[17:02:50.971]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:50.971]                           info)
[17:02:50.971]                         info <- base::paste(info, collapse = "; ")
[17:02:50.971]                         if (!has_future) {
[17:02:50.971]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:50.971]                             info)
[17:02:50.971]                         }
[17:02:50.971]                         else {
[17:02:50.971]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:50.971]                             info, version)
[17:02:50.971]                         }
[17:02:50.971]                         base::stop(msg)
[17:02:50.971]                       }
[17:02:50.971]                     })
[17:02:50.971]                   }
[17:02:50.971]                   ...future.strategy.old <- future::plan("list")
[17:02:50.971]                   options(future.plan = NULL)
[17:02:50.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:50.971]                 }
[17:02:50.971]                 ...future.workdir <- getwd()
[17:02:50.971]             }
[17:02:50.971]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:50.971]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:50.971]         }
[17:02:50.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:50.971]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:50.971]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:50.971]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:50.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:50.971]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:50.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:50.971]             base::names(...future.oldOptions))
[17:02:50.971]     }
[17:02:50.971]     if (FALSE) {
[17:02:50.971]     }
[17:02:50.971]     else {
[17:02:50.971]         if (TRUE) {
[17:02:50.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:50.971]                 open = "w")
[17:02:50.971]         }
[17:02:50.971]         else {
[17:02:50.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:50.971]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:50.971]         }
[17:02:50.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:50.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:50.971]             base::sink(type = "output", split = FALSE)
[17:02:50.971]             base::close(...future.stdout)
[17:02:50.971]         }, add = TRUE)
[17:02:50.971]     }
[17:02:50.971]     ...future.frame <- base::sys.nframe()
[17:02:50.971]     ...future.conditions <- base::list()
[17:02:50.971]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:50.971]     if (FALSE) {
[17:02:50.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:50.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:50.971]     }
[17:02:50.971]     ...future.result <- base::tryCatch({
[17:02:50.971]         base::withCallingHandlers({
[17:02:50.971]             ...future.value <- base::withVisible(base::local({
[17:02:50.971]                 b <- a * ii
[17:02:50.971]                 a <- 0
[17:02:50.971]                 b
[17:02:50.971]             }))
[17:02:50.971]             future::FutureResult(value = ...future.value$value, 
[17:02:50.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.971]                   ...future.rng), globalenv = if (FALSE) 
[17:02:50.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:50.971]                     ...future.globalenv.names))
[17:02:50.971]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:50.971]         }, condition = base::local({
[17:02:50.971]             c <- base::c
[17:02:50.971]             inherits <- base::inherits
[17:02:50.971]             invokeRestart <- base::invokeRestart
[17:02:50.971]             length <- base::length
[17:02:50.971]             list <- base::list
[17:02:50.971]             seq.int <- base::seq.int
[17:02:50.971]             signalCondition <- base::signalCondition
[17:02:50.971]             sys.calls <- base::sys.calls
[17:02:50.971]             `[[` <- base::`[[`
[17:02:50.971]             `+` <- base::`+`
[17:02:50.971]             `<<-` <- base::`<<-`
[17:02:50.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:50.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:50.971]                   3L)]
[17:02:50.971]             }
[17:02:50.971]             function(cond) {
[17:02:50.971]                 is_error <- inherits(cond, "error")
[17:02:50.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:50.971]                   NULL)
[17:02:50.971]                 if (is_error) {
[17:02:50.971]                   sessionInformation <- function() {
[17:02:50.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:50.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:50.971]                       search = base::search(), system = base::Sys.info())
[17:02:50.971]                   }
[17:02:50.971]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:50.971]                     cond$call), session = sessionInformation(), 
[17:02:50.971]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:50.971]                   signalCondition(cond)
[17:02:50.971]                 }
[17:02:50.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:50.971]                 "immediateCondition"))) {
[17:02:50.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:50.971]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:50.971]                   if (TRUE && !signal) {
[17:02:50.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.971]                     {
[17:02:50.971]                       inherits <- base::inherits
[17:02:50.971]                       invokeRestart <- base::invokeRestart
[17:02:50.971]                       is.null <- base::is.null
[17:02:50.971]                       muffled <- FALSE
[17:02:50.971]                       if (inherits(cond, "message")) {
[17:02:50.971]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.971]                         if (muffled) 
[17:02:50.971]                           invokeRestart("muffleMessage")
[17:02:50.971]                       }
[17:02:50.971]                       else if (inherits(cond, "warning")) {
[17:02:50.971]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.971]                         if (muffled) 
[17:02:50.971]                           invokeRestart("muffleWarning")
[17:02:50.971]                       }
[17:02:50.971]                       else if (inherits(cond, "condition")) {
[17:02:50.971]                         if (!is.null(pattern)) {
[17:02:50.971]                           computeRestarts <- base::computeRestarts
[17:02:50.971]                           grepl <- base::grepl
[17:02:50.971]                           restarts <- computeRestarts(cond)
[17:02:50.971]                           for (restart in restarts) {
[17:02:50.971]                             name <- restart$name
[17:02:50.971]                             if (is.null(name)) 
[17:02:50.971]                               next
[17:02:50.971]                             if (!grepl(pattern, name)) 
[17:02:50.971]                               next
[17:02:50.971]                             invokeRestart(restart)
[17:02:50.971]                             muffled <- TRUE
[17:02:50.971]                             break
[17:02:50.971]                           }
[17:02:50.971]                         }
[17:02:50.971]                       }
[17:02:50.971]                       invisible(muffled)
[17:02:50.971]                     }
[17:02:50.971]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.971]                   }
[17:02:50.971]                 }
[17:02:50.971]                 else {
[17:02:50.971]                   if (TRUE) {
[17:02:50.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.971]                     {
[17:02:50.971]                       inherits <- base::inherits
[17:02:50.971]                       invokeRestart <- base::invokeRestart
[17:02:50.971]                       is.null <- base::is.null
[17:02:50.971]                       muffled <- FALSE
[17:02:50.971]                       if (inherits(cond, "message")) {
[17:02:50.971]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.971]                         if (muffled) 
[17:02:50.971]                           invokeRestart("muffleMessage")
[17:02:50.971]                       }
[17:02:50.971]                       else if (inherits(cond, "warning")) {
[17:02:50.971]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.971]                         if (muffled) 
[17:02:50.971]                           invokeRestart("muffleWarning")
[17:02:50.971]                       }
[17:02:50.971]                       else if (inherits(cond, "condition")) {
[17:02:50.971]                         if (!is.null(pattern)) {
[17:02:50.971]                           computeRestarts <- base::computeRestarts
[17:02:50.971]                           grepl <- base::grepl
[17:02:50.971]                           restarts <- computeRestarts(cond)
[17:02:50.971]                           for (restart in restarts) {
[17:02:50.971]                             name <- restart$name
[17:02:50.971]                             if (is.null(name)) 
[17:02:50.971]                               next
[17:02:50.971]                             if (!grepl(pattern, name)) 
[17:02:50.971]                               next
[17:02:50.971]                             invokeRestart(restart)
[17:02:50.971]                             muffled <- TRUE
[17:02:50.971]                             break
[17:02:50.971]                           }
[17:02:50.971]                         }
[17:02:50.971]                       }
[17:02:50.971]                       invisible(muffled)
[17:02:50.971]                     }
[17:02:50.971]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.971]                   }
[17:02:50.971]                 }
[17:02:50.971]             }
[17:02:50.971]         }))
[17:02:50.971]     }, error = function(ex) {
[17:02:50.971]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:50.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.971]                 ...future.rng), started = ...future.startTime, 
[17:02:50.971]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:50.971]             version = "1.8"), class = "FutureResult")
[17:02:50.971]     }, finally = {
[17:02:50.971]         if (!identical(...future.workdir, getwd())) 
[17:02:50.971]             setwd(...future.workdir)
[17:02:50.971]         {
[17:02:50.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:50.971]                 ...future.oldOptions$nwarnings <- NULL
[17:02:50.971]             }
[17:02:50.971]             base::options(...future.oldOptions)
[17:02:50.971]             if (.Platform$OS.type == "windows") {
[17:02:50.971]                 old_names <- names(...future.oldEnvVars)
[17:02:50.971]                 envs <- base::Sys.getenv()
[17:02:50.971]                 names <- names(envs)
[17:02:50.971]                 common <- intersect(names, old_names)
[17:02:50.971]                 added <- setdiff(names, old_names)
[17:02:50.971]                 removed <- setdiff(old_names, names)
[17:02:50.971]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:50.971]                   envs[common]]
[17:02:50.971]                 NAMES <- toupper(changed)
[17:02:50.971]                 args <- list()
[17:02:50.971]                 for (kk in seq_along(NAMES)) {
[17:02:50.971]                   name <- changed[[kk]]
[17:02:50.971]                   NAME <- NAMES[[kk]]
[17:02:50.971]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.971]                     next
[17:02:50.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.971]                 }
[17:02:50.971]                 NAMES <- toupper(added)
[17:02:50.971]                 for (kk in seq_along(NAMES)) {
[17:02:50.971]                   name <- added[[kk]]
[17:02:50.971]                   NAME <- NAMES[[kk]]
[17:02:50.971]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.971]                     next
[17:02:50.971]                   args[[name]] <- ""
[17:02:50.971]                 }
[17:02:50.971]                 NAMES <- toupper(removed)
[17:02:50.971]                 for (kk in seq_along(NAMES)) {
[17:02:50.971]                   name <- removed[[kk]]
[17:02:50.971]                   NAME <- NAMES[[kk]]
[17:02:50.971]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.971]                     next
[17:02:50.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.971]                 }
[17:02:50.971]                 if (length(args) > 0) 
[17:02:50.971]                   base::do.call(base::Sys.setenv, args = args)
[17:02:50.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:50.971]             }
[17:02:50.971]             else {
[17:02:50.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:50.971]             }
[17:02:50.971]             {
[17:02:50.971]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:50.971]                   0L) {
[17:02:50.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:50.971]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:50.971]                   base::options(opts)
[17:02:50.971]                 }
[17:02:50.971]                 {
[17:02:50.971]                   {
[17:02:50.971]                     NULL
[17:02:50.971]                     RNGkind("Mersenne-Twister")
[17:02:50.971]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:50.971]                       inherits = FALSE)
[17:02:50.971]                   }
[17:02:50.971]                   options(future.plan = NULL)
[17:02:50.971]                   if (is.na(NA_character_)) 
[17:02:50.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:50.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:50.971]                     .init = FALSE)
[17:02:50.971]                 }
[17:02:50.971]             }
[17:02:50.971]         }
[17:02:50.971]     })
[17:02:50.971]     if (TRUE) {
[17:02:50.971]         base::sink(type = "output", split = FALSE)
[17:02:50.971]         if (TRUE) {
[17:02:50.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:50.971]         }
[17:02:50.971]         else {
[17:02:50.971]             ...future.result["stdout"] <- base::list(NULL)
[17:02:50.971]         }
[17:02:50.971]         base::close(...future.stdout)
[17:02:50.971]         ...future.stdout <- NULL
[17:02:50.971]     }
[17:02:50.971]     ...future.result$conditions <- ...future.conditions
[17:02:50.971]     ...future.result$finished <- base::Sys.time()
[17:02:50.971]     ...future.result
[17:02:50.971] }
[17:02:50.972] assign_globals() ...
[17:02:50.972] List of 1
[17:02:50.972]  $ ii: int 3
[17:02:50.972]  - attr(*, "where")=List of 1
[17:02:50.972]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:50.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:50.972]  - attr(*, "resolved")= logi TRUE
[17:02:50.972]  - attr(*, "total_size")= num 56
[17:02:50.972]  - attr(*, "already-done")= logi TRUE
[17:02:50.976] - copied ‘ii’ to environment
[17:02:50.976] assign_globals() ... done
[17:02:50.976] plan(): Setting new future strategy stack:
[17:02:50.977] List of future strategies:
[17:02:50.977] 1. sequential:
[17:02:50.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.977]    - tweaked: FALSE
[17:02:50.977]    - call: NULL
[17:02:50.977] plan(): nbrOfWorkers() = 1
[17:02:50.978] plan(): Setting new future strategy stack:
[17:02:50.978] List of future strategies:
[17:02:50.978] 1. sequential:
[17:02:50.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:50.978]    - tweaked: FALSE
[17:02:50.978]    - call: plan(strategy)
[17:02:50.978] plan(): nbrOfWorkers() = 1
[17:02:50.978] SequentialFuture started (and completed)
[17:02:50.979] - Launch lazy future ... done
[17:02:50.979] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.980] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.980] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.981] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.981] Searching for globals ... DONE
[17:02:50.981] Resolving globals: TRUE
[17:02:50.981] Resolving any globals that are futures ...
[17:02:50.982] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.982] Resolving any globals that are futures ... DONE
[17:02:50.982] Resolving futures part of globals (recursively) ...
[17:02:50.982] resolve() on list ...
[17:02:50.982]  recursive: 99
[17:02:50.982]  length: 1
[17:02:50.982]  elements: ‘ii’
[17:02:50.983]  length: 0 (resolved future 1)
[17:02:50.983] resolve() on list ... DONE
[17:02:50.983] - globals: [1] ‘ii’
[17:02:50.983] Resolving futures part of globals (recursively) ... DONE
[17:02:50.983] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:50.983] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:50.983] - globals: [1] ‘ii’
[17:02:50.984] 
[17:02:50.984] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.984] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.984] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.986] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.986] Searching for globals ... DONE
[17:02:50.986] Resolving globals: TRUE
[17:02:50.986] Resolving any globals that are futures ...
[17:02:50.986] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.986] Resolving any globals that are futures ... DONE
[17:02:50.986] Resolving futures part of globals (recursively) ...
[17:02:50.987] resolve() on list ...
[17:02:50.987]  recursive: 99
[17:02:50.987]  length: 1
[17:02:50.987]  elements: ‘ii’
[17:02:50.987]  length: 0 (resolved future 1)
[17:02:50.987] resolve() on list ... DONE
[17:02:50.987] - globals: [1] ‘ii’
[17:02:50.987] Resolving futures part of globals (recursively) ... DONE
[17:02:50.988] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:50.988] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:50.988] - globals: [1] ‘ii’
[17:02:50.988] 
[17:02:50.988] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:50.989] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:50.989] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:50.990] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.990] Searching for globals ... DONE
[17:02:50.990] Resolving globals: TRUE
[17:02:50.990] Resolving any globals that are futures ...
[17:02:50.991] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:50.991] Resolving any globals that are futures ... DONE
[17:02:50.991] Resolving futures part of globals (recursively) ...
[17:02:50.991] resolve() on list ...
[17:02:50.991]  recursive: 99
[17:02:50.991]  length: 1
[17:02:50.991]  elements: ‘ii’
[17:02:50.992]  length: 0 (resolved future 1)
[17:02:50.992] resolve() on list ... DONE
[17:02:50.992] - globals: [1] ‘ii’
[17:02:50.992] Resolving futures part of globals (recursively) ... DONE
[17:02:50.992] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:50.992] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:50.992] - globals: [1] ‘ii’
[17:02:50.992] 
[17:02:50.993] getGlobalsAndPackages() ... DONE
[17:02:50.993] run() for ‘Future’ ...
[17:02:50.993] - state: ‘created’
[17:02:50.993] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:50.993] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:50.993] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:50.994]   - Field: ‘label’
[17:02:50.994]   - Field: ‘local’
[17:02:50.994]   - Field: ‘owner’
[17:02:50.994]   - Field: ‘envir’
[17:02:50.994]   - Field: ‘packages’
[17:02:50.994]   - Field: ‘gc’
[17:02:50.994]   - Field: ‘conditions’
[17:02:50.994]   - Field: ‘expr’
[17:02:50.994]   - Field: ‘uuid’
[17:02:50.994]   - Field: ‘seed’
[17:02:50.994]   - Field: ‘version’
[17:02:50.995]   - Field: ‘result’
[17:02:50.995]   - Field: ‘asynchronous’
[17:02:50.995]   - Field: ‘calls’
[17:02:50.995]   - Field: ‘globals’
[17:02:50.995]   - Field: ‘stdout’
[17:02:50.995]   - Field: ‘earlySignal’
[17:02:50.995]   - Field: ‘lazy’
[17:02:50.995]   - Field: ‘state’
[17:02:50.995] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:50.995] - Launch lazy future ...
[17:02:50.996] Packages needed by the future expression (n = 0): <none>
[17:02:50.996] Packages needed by future strategies (n = 0): <none>
[17:02:50.996] {
[17:02:50.996]     {
[17:02:50.996]         {
[17:02:50.996]             ...future.startTime <- base::Sys.time()
[17:02:50.996]             {
[17:02:50.996]                 {
[17:02:50.996]                   {
[17:02:50.996]                     base::local({
[17:02:50.996]                       has_future <- base::requireNamespace("future", 
[17:02:50.996]                         quietly = TRUE)
[17:02:50.996]                       if (has_future) {
[17:02:50.996]                         ns <- base::getNamespace("future")
[17:02:50.996]                         version <- ns[[".package"]][["version"]]
[17:02:50.996]                         if (is.null(version)) 
[17:02:50.996]                           version <- utils::packageVersion("future")
[17:02:50.996]                       }
[17:02:50.996]                       else {
[17:02:50.996]                         version <- NULL
[17:02:50.996]                       }
[17:02:50.996]                       if (!has_future || version < "1.8.0") {
[17:02:50.996]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:50.996]                           "", base::R.version$version.string), 
[17:02:50.996]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:50.996]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:50.996]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:50.996]                             "release", "version")], collapse = " "), 
[17:02:50.996]                           hostname = base::Sys.info()[["nodename"]])
[17:02:50.996]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:50.996]                           info)
[17:02:50.996]                         info <- base::paste(info, collapse = "; ")
[17:02:50.996]                         if (!has_future) {
[17:02:50.996]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:50.996]                             info)
[17:02:50.996]                         }
[17:02:50.996]                         else {
[17:02:50.996]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:50.996]                             info, version)
[17:02:50.996]                         }
[17:02:50.996]                         base::stop(msg)
[17:02:50.996]                       }
[17:02:50.996]                     })
[17:02:50.996]                   }
[17:02:50.996]                   ...future.strategy.old <- future::plan("list")
[17:02:50.996]                   options(future.plan = NULL)
[17:02:50.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:50.996]                 }
[17:02:50.996]                 ...future.workdir <- getwd()
[17:02:50.996]             }
[17:02:50.996]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:50.996]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:50.996]         }
[17:02:50.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:50.996]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:50.996]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:50.996]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:50.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:50.996]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:50.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:50.996]             base::names(...future.oldOptions))
[17:02:50.996]     }
[17:02:50.996]     if (FALSE) {
[17:02:50.996]     }
[17:02:50.996]     else {
[17:02:50.996]         if (TRUE) {
[17:02:50.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:50.996]                 open = "w")
[17:02:50.996]         }
[17:02:50.996]         else {
[17:02:50.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:50.996]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:50.996]         }
[17:02:50.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:50.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:50.996]             base::sink(type = "output", split = FALSE)
[17:02:50.996]             base::close(...future.stdout)
[17:02:50.996]         }, add = TRUE)
[17:02:50.996]     }
[17:02:50.996]     ...future.frame <- base::sys.nframe()
[17:02:50.996]     ...future.conditions <- base::list()
[17:02:50.996]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:50.996]     if (FALSE) {
[17:02:50.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:50.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:50.996]     }
[17:02:50.996]     ...future.result <- base::tryCatch({
[17:02:50.996]         base::withCallingHandlers({
[17:02:50.996]             ...future.value <- base::withVisible(base::local({
[17:02:50.996]                 b <- a * ii
[17:02:50.996]                 a <- 0
[17:02:50.996]                 b
[17:02:50.996]             }))
[17:02:50.996]             future::FutureResult(value = ...future.value$value, 
[17:02:50.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.996]                   ...future.rng), globalenv = if (FALSE) 
[17:02:50.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:50.996]                     ...future.globalenv.names))
[17:02:50.996]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:50.996]         }, condition = base::local({
[17:02:50.996]             c <- base::c
[17:02:50.996]             inherits <- base::inherits
[17:02:50.996]             invokeRestart <- base::invokeRestart
[17:02:50.996]             length <- base::length
[17:02:50.996]             list <- base::list
[17:02:50.996]             seq.int <- base::seq.int
[17:02:50.996]             signalCondition <- base::signalCondition
[17:02:50.996]             sys.calls <- base::sys.calls
[17:02:50.996]             `[[` <- base::`[[`
[17:02:50.996]             `+` <- base::`+`
[17:02:50.996]             `<<-` <- base::`<<-`
[17:02:50.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:50.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:50.996]                   3L)]
[17:02:50.996]             }
[17:02:50.996]             function(cond) {
[17:02:50.996]                 is_error <- inherits(cond, "error")
[17:02:50.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:50.996]                   NULL)
[17:02:50.996]                 if (is_error) {
[17:02:50.996]                   sessionInformation <- function() {
[17:02:50.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:50.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:50.996]                       search = base::search(), system = base::Sys.info())
[17:02:50.996]                   }
[17:02:50.996]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:50.996]                     cond$call), session = sessionInformation(), 
[17:02:50.996]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:50.996]                   signalCondition(cond)
[17:02:50.996]                 }
[17:02:50.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:50.996]                 "immediateCondition"))) {
[17:02:50.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:50.996]                   ...future.conditions[[length(...future.conditions) + 
[17:02:50.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:50.996]                   if (TRUE && !signal) {
[17:02:50.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.996]                     {
[17:02:50.996]                       inherits <- base::inherits
[17:02:50.996]                       invokeRestart <- base::invokeRestart
[17:02:50.996]                       is.null <- base::is.null
[17:02:50.996]                       muffled <- FALSE
[17:02:50.996]                       if (inherits(cond, "message")) {
[17:02:50.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.996]                         if (muffled) 
[17:02:50.996]                           invokeRestart("muffleMessage")
[17:02:50.996]                       }
[17:02:50.996]                       else if (inherits(cond, "warning")) {
[17:02:50.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.996]                         if (muffled) 
[17:02:50.996]                           invokeRestart("muffleWarning")
[17:02:50.996]                       }
[17:02:50.996]                       else if (inherits(cond, "condition")) {
[17:02:50.996]                         if (!is.null(pattern)) {
[17:02:50.996]                           computeRestarts <- base::computeRestarts
[17:02:50.996]                           grepl <- base::grepl
[17:02:50.996]                           restarts <- computeRestarts(cond)
[17:02:50.996]                           for (restart in restarts) {
[17:02:50.996]                             name <- restart$name
[17:02:50.996]                             if (is.null(name)) 
[17:02:50.996]                               next
[17:02:50.996]                             if (!grepl(pattern, name)) 
[17:02:50.996]                               next
[17:02:50.996]                             invokeRestart(restart)
[17:02:50.996]                             muffled <- TRUE
[17:02:50.996]                             break
[17:02:50.996]                           }
[17:02:50.996]                         }
[17:02:50.996]                       }
[17:02:50.996]                       invisible(muffled)
[17:02:50.996]                     }
[17:02:50.996]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.996]                   }
[17:02:50.996]                 }
[17:02:50.996]                 else {
[17:02:50.996]                   if (TRUE) {
[17:02:50.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:50.996]                     {
[17:02:50.996]                       inherits <- base::inherits
[17:02:50.996]                       invokeRestart <- base::invokeRestart
[17:02:50.996]                       is.null <- base::is.null
[17:02:50.996]                       muffled <- FALSE
[17:02:50.996]                       if (inherits(cond, "message")) {
[17:02:50.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:50.996]                         if (muffled) 
[17:02:50.996]                           invokeRestart("muffleMessage")
[17:02:50.996]                       }
[17:02:50.996]                       else if (inherits(cond, "warning")) {
[17:02:50.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:50.996]                         if (muffled) 
[17:02:50.996]                           invokeRestart("muffleWarning")
[17:02:50.996]                       }
[17:02:50.996]                       else if (inherits(cond, "condition")) {
[17:02:50.996]                         if (!is.null(pattern)) {
[17:02:50.996]                           computeRestarts <- base::computeRestarts
[17:02:50.996]                           grepl <- base::grepl
[17:02:50.996]                           restarts <- computeRestarts(cond)
[17:02:50.996]                           for (restart in restarts) {
[17:02:50.996]                             name <- restart$name
[17:02:50.996]                             if (is.null(name)) 
[17:02:50.996]                               next
[17:02:50.996]                             if (!grepl(pattern, name)) 
[17:02:50.996]                               next
[17:02:50.996]                             invokeRestart(restart)
[17:02:50.996]                             muffled <- TRUE
[17:02:50.996]                             break
[17:02:50.996]                           }
[17:02:50.996]                         }
[17:02:50.996]                       }
[17:02:50.996]                       invisible(muffled)
[17:02:50.996]                     }
[17:02:50.996]                     muffleCondition(cond, pattern = "^muffle")
[17:02:50.996]                   }
[17:02:50.996]                 }
[17:02:50.996]             }
[17:02:50.996]         }))
[17:02:50.996]     }, error = function(ex) {
[17:02:50.996]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:50.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:50.996]                 ...future.rng), started = ...future.startTime, 
[17:02:50.996]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:50.996]             version = "1.8"), class = "FutureResult")
[17:02:50.996]     }, finally = {
[17:02:50.996]         if (!identical(...future.workdir, getwd())) 
[17:02:50.996]             setwd(...future.workdir)
[17:02:50.996]         {
[17:02:50.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:50.996]                 ...future.oldOptions$nwarnings <- NULL
[17:02:50.996]             }
[17:02:50.996]             base::options(...future.oldOptions)
[17:02:50.996]             if (.Platform$OS.type == "windows") {
[17:02:50.996]                 old_names <- names(...future.oldEnvVars)
[17:02:50.996]                 envs <- base::Sys.getenv()
[17:02:50.996]                 names <- names(envs)
[17:02:50.996]                 common <- intersect(names, old_names)
[17:02:50.996]                 added <- setdiff(names, old_names)
[17:02:50.996]                 removed <- setdiff(old_names, names)
[17:02:50.996]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:50.996]                   envs[common]]
[17:02:50.996]                 NAMES <- toupper(changed)
[17:02:50.996]                 args <- list()
[17:02:50.996]                 for (kk in seq_along(NAMES)) {
[17:02:50.996]                   name <- changed[[kk]]
[17:02:50.996]                   NAME <- NAMES[[kk]]
[17:02:50.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.996]                     next
[17:02:50.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.996]                 }
[17:02:50.996]                 NAMES <- toupper(added)
[17:02:50.996]                 for (kk in seq_along(NAMES)) {
[17:02:50.996]                   name <- added[[kk]]
[17:02:50.996]                   NAME <- NAMES[[kk]]
[17:02:50.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.996]                     next
[17:02:50.996]                   args[[name]] <- ""
[17:02:50.996]                 }
[17:02:50.996]                 NAMES <- toupper(removed)
[17:02:50.996]                 for (kk in seq_along(NAMES)) {
[17:02:50.996]                   name <- removed[[kk]]
[17:02:50.996]                   NAME <- NAMES[[kk]]
[17:02:50.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:50.996]                     next
[17:02:50.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:50.996]                 }
[17:02:50.996]                 if (length(args) > 0) 
[17:02:50.996]                   base::do.call(base::Sys.setenv, args = args)
[17:02:50.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:50.996]             }
[17:02:50.996]             else {
[17:02:50.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:50.996]             }
[17:02:50.996]             {
[17:02:50.996]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:50.996]                   0L) {
[17:02:50.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:50.996]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:50.996]                   base::options(opts)
[17:02:50.996]                 }
[17:02:50.996]                 {
[17:02:50.996]                   {
[17:02:50.996]                     NULL
[17:02:50.996]                     RNGkind("Mersenne-Twister")
[17:02:50.996]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:50.996]                       inherits = FALSE)
[17:02:50.996]                   }
[17:02:50.996]                   options(future.plan = NULL)
[17:02:50.996]                   if (is.na(NA_character_)) 
[17:02:50.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:50.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:50.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:50.996]                     .init = FALSE)
[17:02:50.996]                 }
[17:02:50.996]             }
[17:02:50.996]         }
[17:02:50.996]     })
[17:02:50.996]     if (TRUE) {
[17:02:50.996]         base::sink(type = "output", split = FALSE)
[17:02:50.996]         if (TRUE) {
[17:02:50.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:50.996]         }
[17:02:50.996]         else {
[17:02:50.996]             ...future.result["stdout"] <- base::list(NULL)
[17:02:50.996]         }
[17:02:50.996]         base::close(...future.stdout)
[17:02:50.996]         ...future.stdout <- NULL
[17:02:50.996]     }
[17:02:50.996]     ...future.result$conditions <- ...future.conditions
[17:02:50.996]     ...future.result$finished <- base::Sys.time()
[17:02:50.996]     ...future.result
[17:02:50.996] }
[17:02:50.998] assign_globals() ...
[17:02:50.998] List of 1
[17:02:50.998]  $ ii: int 1
[17:02:50.998]  - attr(*, "where")=List of 1
[17:02:50.998]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:50.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:50.998]  - attr(*, "resolved")= logi TRUE
[17:02:50.998]  - attr(*, "total_size")= num 56
[17:02:50.998]  - attr(*, "already-done")= logi TRUE
[17:02:51.000] - copied ‘ii’ to environment
[17:02:51.000] assign_globals() ... done
[17:02:51.001] plan(): Setting new future strategy stack:
[17:02:51.001] List of future strategies:
[17:02:51.001] 1. sequential:
[17:02:51.001]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.001]    - tweaked: FALSE
[17:02:51.001]    - call: NULL
[17:02:51.001] plan(): nbrOfWorkers() = 1
[17:02:51.004] plan(): Setting new future strategy stack:
[17:02:51.004] List of future strategies:
[17:02:51.004] 1. sequential:
[17:02:51.004]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.004]    - tweaked: FALSE
[17:02:51.004]    - call: plan(strategy)
[17:02:51.004] plan(): nbrOfWorkers() = 1
[17:02:51.004] SequentialFuture started (and completed)
[17:02:51.005] signalConditions() ...
[17:02:51.005]  - include = ‘immediateCondition’
[17:02:51.005]  - exclude = 
[17:02:51.005]  - resignal = FALSE
[17:02:51.005]  - Number of conditions: 1
[17:02:51.005] signalConditions() ... done
[17:02:51.005] - Launch lazy future ... done
[17:02:51.005] run() for ‘SequentialFuture’ ... done
[17:02:51.005] signalConditions() ...
[17:02:51.005]  - include = ‘immediateCondition’
[17:02:51.005]  - exclude = 
[17:02:51.006]  - resignal = FALSE
[17:02:51.006]  - Number of conditions: 1
[17:02:51.006] signalConditions() ... done
[17:02:51.006] Future state: ‘finished’
[17:02:51.006] signalConditions() ...
[17:02:51.006]  - include = ‘condition’
[17:02:51.006]  - exclude = ‘immediateCondition’
[17:02:51.006]  - resignal = TRUE
[17:02:51.006]  - Number of conditions: 1
[17:02:51.006]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:51.007] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.019] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.020] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.020] 
[17:02:51.020] Searching for globals ... DONE
[17:02:51.020] - globals: [0] <none>
[17:02:51.021] getGlobalsAndPackages() ... DONE
[17:02:51.021] run() for ‘Future’ ...
[17:02:51.021] - state: ‘created’
[17:02:51.021] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.021] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.022]   - Field: ‘label’
[17:02:51.022]   - Field: ‘local’
[17:02:51.022]   - Field: ‘owner’
[17:02:51.022]   - Field: ‘envir’
[17:02:51.022]   - Field: ‘packages’
[17:02:51.022]   - Field: ‘gc’
[17:02:51.022]   - Field: ‘conditions’
[17:02:51.022]   - Field: ‘expr’
[17:02:51.022]   - Field: ‘uuid’
[17:02:51.022]   - Field: ‘seed’
[17:02:51.022]   - Field: ‘version’
[17:02:51.022]   - Field: ‘result’
[17:02:51.023]   - Field: ‘asynchronous’
[17:02:51.023]   - Field: ‘calls’
[17:02:51.023]   - Field: ‘globals’
[17:02:51.023]   - Field: ‘stdout’
[17:02:51.023]   - Field: ‘earlySignal’
[17:02:51.023]   - Field: ‘lazy’
[17:02:51.023]   - Field: ‘state’
[17:02:51.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.023] - Launch lazy future ...
[17:02:51.024] Packages needed by the future expression (n = 0): <none>
[17:02:51.024] Packages needed by future strategies (n = 0): <none>
[17:02:51.024] {
[17:02:51.024]     {
[17:02:51.024]         {
[17:02:51.024]             ...future.startTime <- base::Sys.time()
[17:02:51.024]             {
[17:02:51.024]                 {
[17:02:51.024]                   {
[17:02:51.024]                     base::local({
[17:02:51.024]                       has_future <- base::requireNamespace("future", 
[17:02:51.024]                         quietly = TRUE)
[17:02:51.024]                       if (has_future) {
[17:02:51.024]                         ns <- base::getNamespace("future")
[17:02:51.024]                         version <- ns[[".package"]][["version"]]
[17:02:51.024]                         if (is.null(version)) 
[17:02:51.024]                           version <- utils::packageVersion("future")
[17:02:51.024]                       }
[17:02:51.024]                       else {
[17:02:51.024]                         version <- NULL
[17:02:51.024]                       }
[17:02:51.024]                       if (!has_future || version < "1.8.0") {
[17:02:51.024]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.024]                           "", base::R.version$version.string), 
[17:02:51.024]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.024]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.024]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.024]                             "release", "version")], collapse = " "), 
[17:02:51.024]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.024]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.024]                           info)
[17:02:51.024]                         info <- base::paste(info, collapse = "; ")
[17:02:51.024]                         if (!has_future) {
[17:02:51.024]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.024]                             info)
[17:02:51.024]                         }
[17:02:51.024]                         else {
[17:02:51.024]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.024]                             info, version)
[17:02:51.024]                         }
[17:02:51.024]                         base::stop(msg)
[17:02:51.024]                       }
[17:02:51.024]                     })
[17:02:51.024]                   }
[17:02:51.024]                   ...future.strategy.old <- future::plan("list")
[17:02:51.024]                   options(future.plan = NULL)
[17:02:51.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.024]                 }
[17:02:51.024]                 ...future.workdir <- getwd()
[17:02:51.024]             }
[17:02:51.024]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.024]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.024]         }
[17:02:51.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.024]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.024]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.024]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.024]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.024]             base::names(...future.oldOptions))
[17:02:51.024]     }
[17:02:51.024]     if (FALSE) {
[17:02:51.024]     }
[17:02:51.024]     else {
[17:02:51.024]         if (TRUE) {
[17:02:51.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.024]                 open = "w")
[17:02:51.024]         }
[17:02:51.024]         else {
[17:02:51.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.024]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.024]         }
[17:02:51.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.024]             base::sink(type = "output", split = FALSE)
[17:02:51.024]             base::close(...future.stdout)
[17:02:51.024]         }, add = TRUE)
[17:02:51.024]     }
[17:02:51.024]     ...future.frame <- base::sys.nframe()
[17:02:51.024]     ...future.conditions <- base::list()
[17:02:51.024]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.024]     if (FALSE) {
[17:02:51.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.024]     }
[17:02:51.024]     ...future.result <- base::tryCatch({
[17:02:51.024]         base::withCallingHandlers({
[17:02:51.024]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.024]             future::FutureResult(value = ...future.value$value, 
[17:02:51.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.024]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.024]                     ...future.globalenv.names))
[17:02:51.024]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.024]         }, condition = base::local({
[17:02:51.024]             c <- base::c
[17:02:51.024]             inherits <- base::inherits
[17:02:51.024]             invokeRestart <- base::invokeRestart
[17:02:51.024]             length <- base::length
[17:02:51.024]             list <- base::list
[17:02:51.024]             seq.int <- base::seq.int
[17:02:51.024]             signalCondition <- base::signalCondition
[17:02:51.024]             sys.calls <- base::sys.calls
[17:02:51.024]             `[[` <- base::`[[`
[17:02:51.024]             `+` <- base::`+`
[17:02:51.024]             `<<-` <- base::`<<-`
[17:02:51.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.024]                   3L)]
[17:02:51.024]             }
[17:02:51.024]             function(cond) {
[17:02:51.024]                 is_error <- inherits(cond, "error")
[17:02:51.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.024]                   NULL)
[17:02:51.024]                 if (is_error) {
[17:02:51.024]                   sessionInformation <- function() {
[17:02:51.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.024]                       search = base::search(), system = base::Sys.info())
[17:02:51.024]                   }
[17:02:51.024]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.024]                     cond$call), session = sessionInformation(), 
[17:02:51.024]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.024]                   signalCondition(cond)
[17:02:51.024]                 }
[17:02:51.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.024]                 "immediateCondition"))) {
[17:02:51.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.024]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.024]                   if (TRUE && !signal) {
[17:02:51.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.024]                     {
[17:02:51.024]                       inherits <- base::inherits
[17:02:51.024]                       invokeRestart <- base::invokeRestart
[17:02:51.024]                       is.null <- base::is.null
[17:02:51.024]                       muffled <- FALSE
[17:02:51.024]                       if (inherits(cond, "message")) {
[17:02:51.024]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.024]                         if (muffled) 
[17:02:51.024]                           invokeRestart("muffleMessage")
[17:02:51.024]                       }
[17:02:51.024]                       else if (inherits(cond, "warning")) {
[17:02:51.024]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.024]                         if (muffled) 
[17:02:51.024]                           invokeRestart("muffleWarning")
[17:02:51.024]                       }
[17:02:51.024]                       else if (inherits(cond, "condition")) {
[17:02:51.024]                         if (!is.null(pattern)) {
[17:02:51.024]                           computeRestarts <- base::computeRestarts
[17:02:51.024]                           grepl <- base::grepl
[17:02:51.024]                           restarts <- computeRestarts(cond)
[17:02:51.024]                           for (restart in restarts) {
[17:02:51.024]                             name <- restart$name
[17:02:51.024]                             if (is.null(name)) 
[17:02:51.024]                               next
[17:02:51.024]                             if (!grepl(pattern, name)) 
[17:02:51.024]                               next
[17:02:51.024]                             invokeRestart(restart)
[17:02:51.024]                             muffled <- TRUE
[17:02:51.024]                             break
[17:02:51.024]                           }
[17:02:51.024]                         }
[17:02:51.024]                       }
[17:02:51.024]                       invisible(muffled)
[17:02:51.024]                     }
[17:02:51.024]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.024]                   }
[17:02:51.024]                 }
[17:02:51.024]                 else {
[17:02:51.024]                   if (TRUE) {
[17:02:51.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.024]                     {
[17:02:51.024]                       inherits <- base::inherits
[17:02:51.024]                       invokeRestart <- base::invokeRestart
[17:02:51.024]                       is.null <- base::is.null
[17:02:51.024]                       muffled <- FALSE
[17:02:51.024]                       if (inherits(cond, "message")) {
[17:02:51.024]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.024]                         if (muffled) 
[17:02:51.024]                           invokeRestart("muffleMessage")
[17:02:51.024]                       }
[17:02:51.024]                       else if (inherits(cond, "warning")) {
[17:02:51.024]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.024]                         if (muffled) 
[17:02:51.024]                           invokeRestart("muffleWarning")
[17:02:51.024]                       }
[17:02:51.024]                       else if (inherits(cond, "condition")) {
[17:02:51.024]                         if (!is.null(pattern)) {
[17:02:51.024]                           computeRestarts <- base::computeRestarts
[17:02:51.024]                           grepl <- base::grepl
[17:02:51.024]                           restarts <- computeRestarts(cond)
[17:02:51.024]                           for (restart in restarts) {
[17:02:51.024]                             name <- restart$name
[17:02:51.024]                             if (is.null(name)) 
[17:02:51.024]                               next
[17:02:51.024]                             if (!grepl(pattern, name)) 
[17:02:51.024]                               next
[17:02:51.024]                             invokeRestart(restart)
[17:02:51.024]                             muffled <- TRUE
[17:02:51.024]                             break
[17:02:51.024]                           }
[17:02:51.024]                         }
[17:02:51.024]                       }
[17:02:51.024]                       invisible(muffled)
[17:02:51.024]                     }
[17:02:51.024]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.024]                   }
[17:02:51.024]                 }
[17:02:51.024]             }
[17:02:51.024]         }))
[17:02:51.024]     }, error = function(ex) {
[17:02:51.024]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.024]                 ...future.rng), started = ...future.startTime, 
[17:02:51.024]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.024]             version = "1.8"), class = "FutureResult")
[17:02:51.024]     }, finally = {
[17:02:51.024]         if (!identical(...future.workdir, getwd())) 
[17:02:51.024]             setwd(...future.workdir)
[17:02:51.024]         {
[17:02:51.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.024]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.024]             }
[17:02:51.024]             base::options(...future.oldOptions)
[17:02:51.024]             if (.Platform$OS.type == "windows") {
[17:02:51.024]                 old_names <- names(...future.oldEnvVars)
[17:02:51.024]                 envs <- base::Sys.getenv()
[17:02:51.024]                 names <- names(envs)
[17:02:51.024]                 common <- intersect(names, old_names)
[17:02:51.024]                 added <- setdiff(names, old_names)
[17:02:51.024]                 removed <- setdiff(old_names, names)
[17:02:51.024]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.024]                   envs[common]]
[17:02:51.024]                 NAMES <- toupper(changed)
[17:02:51.024]                 args <- list()
[17:02:51.024]                 for (kk in seq_along(NAMES)) {
[17:02:51.024]                   name <- changed[[kk]]
[17:02:51.024]                   NAME <- NAMES[[kk]]
[17:02:51.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.024]                     next
[17:02:51.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.024]                 }
[17:02:51.024]                 NAMES <- toupper(added)
[17:02:51.024]                 for (kk in seq_along(NAMES)) {
[17:02:51.024]                   name <- added[[kk]]
[17:02:51.024]                   NAME <- NAMES[[kk]]
[17:02:51.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.024]                     next
[17:02:51.024]                   args[[name]] <- ""
[17:02:51.024]                 }
[17:02:51.024]                 NAMES <- toupper(removed)
[17:02:51.024]                 for (kk in seq_along(NAMES)) {
[17:02:51.024]                   name <- removed[[kk]]
[17:02:51.024]                   NAME <- NAMES[[kk]]
[17:02:51.024]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.024]                     next
[17:02:51.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.024]                 }
[17:02:51.024]                 if (length(args) > 0) 
[17:02:51.024]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.024]             }
[17:02:51.024]             else {
[17:02:51.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.024]             }
[17:02:51.024]             {
[17:02:51.024]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.024]                   0L) {
[17:02:51.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.024]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.024]                   base::options(opts)
[17:02:51.024]                 }
[17:02:51.024]                 {
[17:02:51.024]                   {
[17:02:51.024]                     NULL
[17:02:51.024]                     RNGkind("Mersenne-Twister")
[17:02:51.024]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.024]                       inherits = FALSE)
[17:02:51.024]                   }
[17:02:51.024]                   options(future.plan = NULL)
[17:02:51.024]                   if (is.na(NA_character_)) 
[17:02:51.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.024]                     .init = FALSE)
[17:02:51.024]                 }
[17:02:51.024]             }
[17:02:51.024]         }
[17:02:51.024]     })
[17:02:51.024]     if (TRUE) {
[17:02:51.024]         base::sink(type = "output", split = FALSE)
[17:02:51.024]         if (TRUE) {
[17:02:51.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.024]         }
[17:02:51.024]         else {
[17:02:51.024]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.024]         }
[17:02:51.024]         base::close(...future.stdout)
[17:02:51.024]         ...future.stdout <- NULL
[17:02:51.024]     }
[17:02:51.024]     ...future.result$conditions <- ...future.conditions
[17:02:51.024]     ...future.result$finished <- base::Sys.time()
[17:02:51.024]     ...future.result
[17:02:51.024] }
[17:02:51.026] plan(): Setting new future strategy stack:
[17:02:51.026] List of future strategies:
[17:02:51.026] 1. sequential:
[17:02:51.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.026]    - tweaked: FALSE
[17:02:51.026]    - call: NULL
[17:02:51.026] plan(): nbrOfWorkers() = 1
[17:02:51.027] plan(): Setting new future strategy stack:
[17:02:51.027] List of future strategies:
[17:02:51.027] 1. sequential:
[17:02:51.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.027]    - tweaked: FALSE
[17:02:51.027]    - call: plan(strategy)
[17:02:51.028] plan(): nbrOfWorkers() = 1
[17:02:51.028] SequentialFuture started (and completed)
[17:02:51.028] - Launch lazy future ... done
[17:02:51.028] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.028] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.028] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.031] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.031] Searching for globals ... DONE
[17:02:51.031] Resolving globals: TRUE
[17:02:51.031] Resolving any globals that are futures ...
[17:02:51.031] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.031] Resolving any globals that are futures ... DONE
[17:02:51.032] Resolving futures part of globals (recursively) ...
[17:02:51.032] resolve() on list ...
[17:02:51.032]  recursive: 99
[17:02:51.032]  length: 1
[17:02:51.032]  elements: ‘a’
[17:02:51.032] resolved() for ‘SequentialFuture’ ...
[17:02:51.032] - state: ‘finished’
[17:02:51.033] - run: TRUE
[17:02:51.033] - result: ‘FutureResult’
[17:02:51.033] resolved() for ‘SequentialFuture’ ... done
[17:02:51.033] Future #1
[17:02:51.033] resolved() for ‘SequentialFuture’ ...
[17:02:51.033] - state: ‘finished’
[17:02:51.033] - run: TRUE
[17:02:51.033] - result: ‘FutureResult’
[17:02:51.033] resolved() for ‘SequentialFuture’ ... done
[17:02:51.034] A SequentialFuture was resolved
[17:02:51.034]  length: 0 (resolved future 1)
[17:02:51.034] resolve() on list ... DONE
[17:02:51.034] - globals: [1] ‘a’
[17:02:51.034] Resolving futures part of globals (recursively) ... DONE
[17:02:51.035] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:02:51.035] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:02:51.035] - globals: [1] ‘a’
[17:02:51.035] - packages: [1] ‘future’
[17:02:51.035] getGlobalsAndPackages() ... DONE
[17:02:51.036] run() for ‘Future’ ...
[17:02:51.036] - state: ‘created’
[17:02:51.036] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.036] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.036] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.036]   - Field: ‘label’
[17:02:51.036]   - Field: ‘local’
[17:02:51.037]   - Field: ‘owner’
[17:02:51.037]   - Field: ‘envir’
[17:02:51.037]   - Field: ‘packages’
[17:02:51.037]   - Field: ‘gc’
[17:02:51.037]   - Field: ‘conditions’
[17:02:51.037]   - Field: ‘expr’
[17:02:51.037]   - Field: ‘uuid’
[17:02:51.037]   - Field: ‘seed’
[17:02:51.037]   - Field: ‘version’
[17:02:51.037]   - Field: ‘result’
[17:02:51.037]   - Field: ‘asynchronous’
[17:02:51.038]   - Field: ‘calls’
[17:02:51.038]   - Field: ‘globals’
[17:02:51.038]   - Field: ‘stdout’
[17:02:51.038]   - Field: ‘earlySignal’
[17:02:51.038]   - Field: ‘lazy’
[17:02:51.038]   - Field: ‘state’
[17:02:51.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.038] - Launch lazy future ...
[17:02:51.038] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.038] Packages needed by future strategies (n = 0): <none>
[17:02:51.039] {
[17:02:51.039]     {
[17:02:51.039]         {
[17:02:51.039]             ...future.startTime <- base::Sys.time()
[17:02:51.039]             {
[17:02:51.039]                 {
[17:02:51.039]                   {
[17:02:51.039]                     {
[17:02:51.039]                       base::local({
[17:02:51.039]                         has_future <- base::requireNamespace("future", 
[17:02:51.039]                           quietly = TRUE)
[17:02:51.039]                         if (has_future) {
[17:02:51.039]                           ns <- base::getNamespace("future")
[17:02:51.039]                           version <- ns[[".package"]][["version"]]
[17:02:51.039]                           if (is.null(version)) 
[17:02:51.039]                             version <- utils::packageVersion("future")
[17:02:51.039]                         }
[17:02:51.039]                         else {
[17:02:51.039]                           version <- NULL
[17:02:51.039]                         }
[17:02:51.039]                         if (!has_future || version < "1.8.0") {
[17:02:51.039]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.039]                             "", base::R.version$version.string), 
[17:02:51.039]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.039]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.039]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.039]                               "release", "version")], collapse = " "), 
[17:02:51.039]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.039]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.039]                             info)
[17:02:51.039]                           info <- base::paste(info, collapse = "; ")
[17:02:51.039]                           if (!has_future) {
[17:02:51.039]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.039]                               info)
[17:02:51.039]                           }
[17:02:51.039]                           else {
[17:02:51.039]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.039]                               info, version)
[17:02:51.039]                           }
[17:02:51.039]                           base::stop(msg)
[17:02:51.039]                         }
[17:02:51.039]                       })
[17:02:51.039]                     }
[17:02:51.039]                     base::local({
[17:02:51.039]                       for (pkg in "future") {
[17:02:51.039]                         base::loadNamespace(pkg)
[17:02:51.039]                         base::library(pkg, character.only = TRUE)
[17:02:51.039]                       }
[17:02:51.039]                     })
[17:02:51.039]                   }
[17:02:51.039]                   ...future.strategy.old <- future::plan("list")
[17:02:51.039]                   options(future.plan = NULL)
[17:02:51.039]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.039]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.039]                 }
[17:02:51.039]                 ...future.workdir <- getwd()
[17:02:51.039]             }
[17:02:51.039]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.039]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.039]         }
[17:02:51.039]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.039]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.039]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.039]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.039]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.039]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.039]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.039]             base::names(...future.oldOptions))
[17:02:51.039]     }
[17:02:51.039]     if (FALSE) {
[17:02:51.039]     }
[17:02:51.039]     else {
[17:02:51.039]         if (TRUE) {
[17:02:51.039]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.039]                 open = "w")
[17:02:51.039]         }
[17:02:51.039]         else {
[17:02:51.039]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.039]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.039]         }
[17:02:51.039]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.039]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.039]             base::sink(type = "output", split = FALSE)
[17:02:51.039]             base::close(...future.stdout)
[17:02:51.039]         }, add = TRUE)
[17:02:51.039]     }
[17:02:51.039]     ...future.frame <- base::sys.nframe()
[17:02:51.039]     ...future.conditions <- base::list()
[17:02:51.039]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.039]     if (FALSE) {
[17:02:51.039]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.039]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.039]     }
[17:02:51.039]     ...future.result <- base::tryCatch({
[17:02:51.039]         base::withCallingHandlers({
[17:02:51.039]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.039]                 1))
[17:02:51.039]             future::FutureResult(value = ...future.value$value, 
[17:02:51.039]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.039]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.039]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.039]                     ...future.globalenv.names))
[17:02:51.039]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.039]         }, condition = base::local({
[17:02:51.039]             c <- base::c
[17:02:51.039]             inherits <- base::inherits
[17:02:51.039]             invokeRestart <- base::invokeRestart
[17:02:51.039]             length <- base::length
[17:02:51.039]             list <- base::list
[17:02:51.039]             seq.int <- base::seq.int
[17:02:51.039]             signalCondition <- base::signalCondition
[17:02:51.039]             sys.calls <- base::sys.calls
[17:02:51.039]             `[[` <- base::`[[`
[17:02:51.039]             `+` <- base::`+`
[17:02:51.039]             `<<-` <- base::`<<-`
[17:02:51.039]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.039]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.039]                   3L)]
[17:02:51.039]             }
[17:02:51.039]             function(cond) {
[17:02:51.039]                 is_error <- inherits(cond, "error")
[17:02:51.039]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.039]                   NULL)
[17:02:51.039]                 if (is_error) {
[17:02:51.039]                   sessionInformation <- function() {
[17:02:51.039]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.039]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.039]                       search = base::search(), system = base::Sys.info())
[17:02:51.039]                   }
[17:02:51.039]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.039]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.039]                     cond$call), session = sessionInformation(), 
[17:02:51.039]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.039]                   signalCondition(cond)
[17:02:51.039]                 }
[17:02:51.039]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.039]                 "immediateCondition"))) {
[17:02:51.039]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.039]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.039]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.039]                   if (TRUE && !signal) {
[17:02:51.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.039]                     {
[17:02:51.039]                       inherits <- base::inherits
[17:02:51.039]                       invokeRestart <- base::invokeRestart
[17:02:51.039]                       is.null <- base::is.null
[17:02:51.039]                       muffled <- FALSE
[17:02:51.039]                       if (inherits(cond, "message")) {
[17:02:51.039]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.039]                         if (muffled) 
[17:02:51.039]                           invokeRestart("muffleMessage")
[17:02:51.039]                       }
[17:02:51.039]                       else if (inherits(cond, "warning")) {
[17:02:51.039]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.039]                         if (muffled) 
[17:02:51.039]                           invokeRestart("muffleWarning")
[17:02:51.039]                       }
[17:02:51.039]                       else if (inherits(cond, "condition")) {
[17:02:51.039]                         if (!is.null(pattern)) {
[17:02:51.039]                           computeRestarts <- base::computeRestarts
[17:02:51.039]                           grepl <- base::grepl
[17:02:51.039]                           restarts <- computeRestarts(cond)
[17:02:51.039]                           for (restart in restarts) {
[17:02:51.039]                             name <- restart$name
[17:02:51.039]                             if (is.null(name)) 
[17:02:51.039]                               next
[17:02:51.039]                             if (!grepl(pattern, name)) 
[17:02:51.039]                               next
[17:02:51.039]                             invokeRestart(restart)
[17:02:51.039]                             muffled <- TRUE
[17:02:51.039]                             break
[17:02:51.039]                           }
[17:02:51.039]                         }
[17:02:51.039]                       }
[17:02:51.039]                       invisible(muffled)
[17:02:51.039]                     }
[17:02:51.039]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.039]                   }
[17:02:51.039]                 }
[17:02:51.039]                 else {
[17:02:51.039]                   if (TRUE) {
[17:02:51.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.039]                     {
[17:02:51.039]                       inherits <- base::inherits
[17:02:51.039]                       invokeRestart <- base::invokeRestart
[17:02:51.039]                       is.null <- base::is.null
[17:02:51.039]                       muffled <- FALSE
[17:02:51.039]                       if (inherits(cond, "message")) {
[17:02:51.039]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.039]                         if (muffled) 
[17:02:51.039]                           invokeRestart("muffleMessage")
[17:02:51.039]                       }
[17:02:51.039]                       else if (inherits(cond, "warning")) {
[17:02:51.039]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.039]                         if (muffled) 
[17:02:51.039]                           invokeRestart("muffleWarning")
[17:02:51.039]                       }
[17:02:51.039]                       else if (inherits(cond, "condition")) {
[17:02:51.039]                         if (!is.null(pattern)) {
[17:02:51.039]                           computeRestarts <- base::computeRestarts
[17:02:51.039]                           grepl <- base::grepl
[17:02:51.039]                           restarts <- computeRestarts(cond)
[17:02:51.039]                           for (restart in restarts) {
[17:02:51.039]                             name <- restart$name
[17:02:51.039]                             if (is.null(name)) 
[17:02:51.039]                               next
[17:02:51.039]                             if (!grepl(pattern, name)) 
[17:02:51.039]                               next
[17:02:51.039]                             invokeRestart(restart)
[17:02:51.039]                             muffled <- TRUE
[17:02:51.039]                             break
[17:02:51.039]                           }
[17:02:51.039]                         }
[17:02:51.039]                       }
[17:02:51.039]                       invisible(muffled)
[17:02:51.039]                     }
[17:02:51.039]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.039]                   }
[17:02:51.039]                 }
[17:02:51.039]             }
[17:02:51.039]         }))
[17:02:51.039]     }, error = function(ex) {
[17:02:51.039]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.039]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.039]                 ...future.rng), started = ...future.startTime, 
[17:02:51.039]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.039]             version = "1.8"), class = "FutureResult")
[17:02:51.039]     }, finally = {
[17:02:51.039]         if (!identical(...future.workdir, getwd())) 
[17:02:51.039]             setwd(...future.workdir)
[17:02:51.039]         {
[17:02:51.039]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.039]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.039]             }
[17:02:51.039]             base::options(...future.oldOptions)
[17:02:51.039]             if (.Platform$OS.type == "windows") {
[17:02:51.039]                 old_names <- names(...future.oldEnvVars)
[17:02:51.039]                 envs <- base::Sys.getenv()
[17:02:51.039]                 names <- names(envs)
[17:02:51.039]                 common <- intersect(names, old_names)
[17:02:51.039]                 added <- setdiff(names, old_names)
[17:02:51.039]                 removed <- setdiff(old_names, names)
[17:02:51.039]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.039]                   envs[common]]
[17:02:51.039]                 NAMES <- toupper(changed)
[17:02:51.039]                 args <- list()
[17:02:51.039]                 for (kk in seq_along(NAMES)) {
[17:02:51.039]                   name <- changed[[kk]]
[17:02:51.039]                   NAME <- NAMES[[kk]]
[17:02:51.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.039]                     next
[17:02:51.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.039]                 }
[17:02:51.039]                 NAMES <- toupper(added)
[17:02:51.039]                 for (kk in seq_along(NAMES)) {
[17:02:51.039]                   name <- added[[kk]]
[17:02:51.039]                   NAME <- NAMES[[kk]]
[17:02:51.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.039]                     next
[17:02:51.039]                   args[[name]] <- ""
[17:02:51.039]                 }
[17:02:51.039]                 NAMES <- toupper(removed)
[17:02:51.039]                 for (kk in seq_along(NAMES)) {
[17:02:51.039]                   name <- removed[[kk]]
[17:02:51.039]                   NAME <- NAMES[[kk]]
[17:02:51.039]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.039]                     next
[17:02:51.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.039]                 }
[17:02:51.039]                 if (length(args) > 0) 
[17:02:51.039]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.039]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.039]             }
[17:02:51.039]             else {
[17:02:51.039]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.039]             }
[17:02:51.039]             {
[17:02:51.039]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.039]                   0L) {
[17:02:51.039]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.039]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.039]                   base::options(opts)
[17:02:51.039]                 }
[17:02:51.039]                 {
[17:02:51.039]                   {
[17:02:51.039]                     NULL
[17:02:51.039]                     RNGkind("Mersenne-Twister")
[17:02:51.039]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.039]                       inherits = FALSE)
[17:02:51.039]                   }
[17:02:51.039]                   options(future.plan = NULL)
[17:02:51.039]                   if (is.na(NA_character_)) 
[17:02:51.039]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.039]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.039]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.039]                     .init = FALSE)
[17:02:51.039]                 }
[17:02:51.039]             }
[17:02:51.039]         }
[17:02:51.039]     })
[17:02:51.039]     if (TRUE) {
[17:02:51.039]         base::sink(type = "output", split = FALSE)
[17:02:51.039]         if (TRUE) {
[17:02:51.039]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.039]         }
[17:02:51.039]         else {
[17:02:51.039]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.039]         }
[17:02:51.039]         base::close(...future.stdout)
[17:02:51.039]         ...future.stdout <- NULL
[17:02:51.039]     }
[17:02:51.039]     ...future.result$conditions <- ...future.conditions
[17:02:51.039]     ...future.result$finished <- base::Sys.time()
[17:02:51.039]     ...future.result
[17:02:51.039] }
[17:02:51.041] assign_globals() ...
[17:02:51.041] List of 1
[17:02:51.041]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f6950520> 
[17:02:51.041]  - attr(*, "where")=List of 1
[17:02:51.041]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.041]  - attr(*, "resolved")= logi TRUE
[17:02:51.041]  - attr(*, "total_size")= num 10424
[17:02:51.041]  - attr(*, "already-done")= logi TRUE
[17:02:51.043] - copied ‘a’ to environment
[17:02:51.043] assign_globals() ... done
[17:02:51.043] plan(): Setting new future strategy stack:
[17:02:51.044] List of future strategies:
[17:02:51.044] 1. sequential:
[17:02:51.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.044]    - tweaked: FALSE
[17:02:51.044]    - call: NULL
[17:02:51.044] plan(): nbrOfWorkers() = 1
[17:02:51.045] plan(): Setting new future strategy stack:
[17:02:51.045] List of future strategies:
[17:02:51.045] 1. sequential:
[17:02:51.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.045]    - tweaked: FALSE
[17:02:51.045]    - call: plan(strategy)
[17:02:51.045] plan(): nbrOfWorkers() = 1
[17:02:51.045] SequentialFuture started (and completed)
[17:02:51.046] - Launch lazy future ... done
[17:02:51.046] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.046] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.046] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.047] 
[17:02:51.047] Searching for globals ... DONE
[17:02:51.047] - globals: [0] <none>
[17:02:51.047] getGlobalsAndPackages() ... DONE
[17:02:51.047] run() for ‘Future’ ...
[17:02:51.047] - state: ‘created’
[17:02:51.048] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.048] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.048]   - Field: ‘label’
[17:02:51.048]   - Field: ‘local’
[17:02:51.048]   - Field: ‘owner’
[17:02:51.048]   - Field: ‘envir’
[17:02:51.048]   - Field: ‘packages’
[17:02:51.048]   - Field: ‘gc’
[17:02:51.049]   - Field: ‘conditions’
[17:02:51.049]   - Field: ‘expr’
[17:02:51.049]   - Field: ‘uuid’
[17:02:51.049]   - Field: ‘seed’
[17:02:51.049]   - Field: ‘version’
[17:02:51.049]   - Field: ‘result’
[17:02:51.049]   - Field: ‘asynchronous’
[17:02:51.049]   - Field: ‘calls’
[17:02:51.049]   - Field: ‘globals’
[17:02:51.049]   - Field: ‘stdout’
[17:02:51.049]   - Field: ‘earlySignal’
[17:02:51.050]   - Field: ‘lazy’
[17:02:51.050]   - Field: ‘state’
[17:02:51.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.050] - Launch lazy future ...
[17:02:51.050] Packages needed by the future expression (n = 0): <none>
[17:02:51.050] Packages needed by future strategies (n = 0): <none>
[17:02:51.050] {
[17:02:51.050]     {
[17:02:51.050]         {
[17:02:51.050]             ...future.startTime <- base::Sys.time()
[17:02:51.050]             {
[17:02:51.050]                 {
[17:02:51.050]                   {
[17:02:51.050]                     base::local({
[17:02:51.050]                       has_future <- base::requireNamespace("future", 
[17:02:51.050]                         quietly = TRUE)
[17:02:51.050]                       if (has_future) {
[17:02:51.050]                         ns <- base::getNamespace("future")
[17:02:51.050]                         version <- ns[[".package"]][["version"]]
[17:02:51.050]                         if (is.null(version)) 
[17:02:51.050]                           version <- utils::packageVersion("future")
[17:02:51.050]                       }
[17:02:51.050]                       else {
[17:02:51.050]                         version <- NULL
[17:02:51.050]                       }
[17:02:51.050]                       if (!has_future || version < "1.8.0") {
[17:02:51.050]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.050]                           "", base::R.version$version.string), 
[17:02:51.050]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.050]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.050]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.050]                             "release", "version")], collapse = " "), 
[17:02:51.050]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.050]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.050]                           info)
[17:02:51.050]                         info <- base::paste(info, collapse = "; ")
[17:02:51.050]                         if (!has_future) {
[17:02:51.050]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.050]                             info)
[17:02:51.050]                         }
[17:02:51.050]                         else {
[17:02:51.050]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.050]                             info, version)
[17:02:51.050]                         }
[17:02:51.050]                         base::stop(msg)
[17:02:51.050]                       }
[17:02:51.050]                     })
[17:02:51.050]                   }
[17:02:51.050]                   ...future.strategy.old <- future::plan("list")
[17:02:51.050]                   options(future.plan = NULL)
[17:02:51.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.050]                 }
[17:02:51.050]                 ...future.workdir <- getwd()
[17:02:51.050]             }
[17:02:51.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.050]         }
[17:02:51.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.050]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.050]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.050]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.050]             base::names(...future.oldOptions))
[17:02:51.050]     }
[17:02:51.050]     if (FALSE) {
[17:02:51.050]     }
[17:02:51.050]     else {
[17:02:51.050]         if (TRUE) {
[17:02:51.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.050]                 open = "w")
[17:02:51.050]         }
[17:02:51.050]         else {
[17:02:51.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.050]         }
[17:02:51.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.050]             base::sink(type = "output", split = FALSE)
[17:02:51.050]             base::close(...future.stdout)
[17:02:51.050]         }, add = TRUE)
[17:02:51.050]     }
[17:02:51.050]     ...future.frame <- base::sys.nframe()
[17:02:51.050]     ...future.conditions <- base::list()
[17:02:51.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.050]     if (FALSE) {
[17:02:51.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.050]     }
[17:02:51.050]     ...future.result <- base::tryCatch({
[17:02:51.050]         base::withCallingHandlers({
[17:02:51.050]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.050]             future::FutureResult(value = ...future.value$value, 
[17:02:51.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.050]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.050]                     ...future.globalenv.names))
[17:02:51.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.050]         }, condition = base::local({
[17:02:51.050]             c <- base::c
[17:02:51.050]             inherits <- base::inherits
[17:02:51.050]             invokeRestart <- base::invokeRestart
[17:02:51.050]             length <- base::length
[17:02:51.050]             list <- base::list
[17:02:51.050]             seq.int <- base::seq.int
[17:02:51.050]             signalCondition <- base::signalCondition
[17:02:51.050]             sys.calls <- base::sys.calls
[17:02:51.050]             `[[` <- base::`[[`
[17:02:51.050]             `+` <- base::`+`
[17:02:51.050]             `<<-` <- base::`<<-`
[17:02:51.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.050]                   3L)]
[17:02:51.050]             }
[17:02:51.050]             function(cond) {
[17:02:51.050]                 is_error <- inherits(cond, "error")
[17:02:51.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.050]                   NULL)
[17:02:51.050]                 if (is_error) {
[17:02:51.050]                   sessionInformation <- function() {
[17:02:51.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.050]                       search = base::search(), system = base::Sys.info())
[17:02:51.050]                   }
[17:02:51.050]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.050]                     cond$call), session = sessionInformation(), 
[17:02:51.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.050]                   signalCondition(cond)
[17:02:51.050]                 }
[17:02:51.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.050]                 "immediateCondition"))) {
[17:02:51.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.050]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.050]                   if (TRUE && !signal) {
[17:02:51.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.050]                     {
[17:02:51.050]                       inherits <- base::inherits
[17:02:51.050]                       invokeRestart <- base::invokeRestart
[17:02:51.050]                       is.null <- base::is.null
[17:02:51.050]                       muffled <- FALSE
[17:02:51.050]                       if (inherits(cond, "message")) {
[17:02:51.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.050]                         if (muffled) 
[17:02:51.050]                           invokeRestart("muffleMessage")
[17:02:51.050]                       }
[17:02:51.050]                       else if (inherits(cond, "warning")) {
[17:02:51.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.050]                         if (muffled) 
[17:02:51.050]                           invokeRestart("muffleWarning")
[17:02:51.050]                       }
[17:02:51.050]                       else if (inherits(cond, "condition")) {
[17:02:51.050]                         if (!is.null(pattern)) {
[17:02:51.050]                           computeRestarts <- base::computeRestarts
[17:02:51.050]                           grepl <- base::grepl
[17:02:51.050]                           restarts <- computeRestarts(cond)
[17:02:51.050]                           for (restart in restarts) {
[17:02:51.050]                             name <- restart$name
[17:02:51.050]                             if (is.null(name)) 
[17:02:51.050]                               next
[17:02:51.050]                             if (!grepl(pattern, name)) 
[17:02:51.050]                               next
[17:02:51.050]                             invokeRestart(restart)
[17:02:51.050]                             muffled <- TRUE
[17:02:51.050]                             break
[17:02:51.050]                           }
[17:02:51.050]                         }
[17:02:51.050]                       }
[17:02:51.050]                       invisible(muffled)
[17:02:51.050]                     }
[17:02:51.050]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.050]                   }
[17:02:51.050]                 }
[17:02:51.050]                 else {
[17:02:51.050]                   if (TRUE) {
[17:02:51.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.050]                     {
[17:02:51.050]                       inherits <- base::inherits
[17:02:51.050]                       invokeRestart <- base::invokeRestart
[17:02:51.050]                       is.null <- base::is.null
[17:02:51.050]                       muffled <- FALSE
[17:02:51.050]                       if (inherits(cond, "message")) {
[17:02:51.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.050]                         if (muffled) 
[17:02:51.050]                           invokeRestart("muffleMessage")
[17:02:51.050]                       }
[17:02:51.050]                       else if (inherits(cond, "warning")) {
[17:02:51.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.050]                         if (muffled) 
[17:02:51.050]                           invokeRestart("muffleWarning")
[17:02:51.050]                       }
[17:02:51.050]                       else if (inherits(cond, "condition")) {
[17:02:51.050]                         if (!is.null(pattern)) {
[17:02:51.050]                           computeRestarts <- base::computeRestarts
[17:02:51.050]                           grepl <- base::grepl
[17:02:51.050]                           restarts <- computeRestarts(cond)
[17:02:51.050]                           for (restart in restarts) {
[17:02:51.050]                             name <- restart$name
[17:02:51.050]                             if (is.null(name)) 
[17:02:51.050]                               next
[17:02:51.050]                             if (!grepl(pattern, name)) 
[17:02:51.050]                               next
[17:02:51.050]                             invokeRestart(restart)
[17:02:51.050]                             muffled <- TRUE
[17:02:51.050]                             break
[17:02:51.050]                           }
[17:02:51.050]                         }
[17:02:51.050]                       }
[17:02:51.050]                       invisible(muffled)
[17:02:51.050]                     }
[17:02:51.050]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.050]                   }
[17:02:51.050]                 }
[17:02:51.050]             }
[17:02:51.050]         }))
[17:02:51.050]     }, error = function(ex) {
[17:02:51.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.050]                 ...future.rng), started = ...future.startTime, 
[17:02:51.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.050]             version = "1.8"), class = "FutureResult")
[17:02:51.050]     }, finally = {
[17:02:51.050]         if (!identical(...future.workdir, getwd())) 
[17:02:51.050]             setwd(...future.workdir)
[17:02:51.050]         {
[17:02:51.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.050]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.050]             }
[17:02:51.050]             base::options(...future.oldOptions)
[17:02:51.050]             if (.Platform$OS.type == "windows") {
[17:02:51.050]                 old_names <- names(...future.oldEnvVars)
[17:02:51.050]                 envs <- base::Sys.getenv()
[17:02:51.050]                 names <- names(envs)
[17:02:51.050]                 common <- intersect(names, old_names)
[17:02:51.050]                 added <- setdiff(names, old_names)
[17:02:51.050]                 removed <- setdiff(old_names, names)
[17:02:51.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.050]                   envs[common]]
[17:02:51.050]                 NAMES <- toupper(changed)
[17:02:51.050]                 args <- list()
[17:02:51.050]                 for (kk in seq_along(NAMES)) {
[17:02:51.050]                   name <- changed[[kk]]
[17:02:51.050]                   NAME <- NAMES[[kk]]
[17:02:51.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.050]                     next
[17:02:51.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.050]                 }
[17:02:51.050]                 NAMES <- toupper(added)
[17:02:51.050]                 for (kk in seq_along(NAMES)) {
[17:02:51.050]                   name <- added[[kk]]
[17:02:51.050]                   NAME <- NAMES[[kk]]
[17:02:51.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.050]                     next
[17:02:51.050]                   args[[name]] <- ""
[17:02:51.050]                 }
[17:02:51.050]                 NAMES <- toupper(removed)
[17:02:51.050]                 for (kk in seq_along(NAMES)) {
[17:02:51.050]                   name <- removed[[kk]]
[17:02:51.050]                   NAME <- NAMES[[kk]]
[17:02:51.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.050]                     next
[17:02:51.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.050]                 }
[17:02:51.050]                 if (length(args) > 0) 
[17:02:51.050]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.050]             }
[17:02:51.050]             else {
[17:02:51.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.050]             }
[17:02:51.050]             {
[17:02:51.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.050]                   0L) {
[17:02:51.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.050]                   base::options(opts)
[17:02:51.050]                 }
[17:02:51.050]                 {
[17:02:51.050]                   {
[17:02:51.050]                     NULL
[17:02:51.050]                     RNGkind("Mersenne-Twister")
[17:02:51.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.050]                       inherits = FALSE)
[17:02:51.050]                   }
[17:02:51.050]                   options(future.plan = NULL)
[17:02:51.050]                   if (is.na(NA_character_)) 
[17:02:51.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.050]                     .init = FALSE)
[17:02:51.050]                 }
[17:02:51.050]             }
[17:02:51.050]         }
[17:02:51.050]     })
[17:02:51.050]     if (TRUE) {
[17:02:51.050]         base::sink(type = "output", split = FALSE)
[17:02:51.050]         if (TRUE) {
[17:02:51.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.050]         }
[17:02:51.050]         else {
[17:02:51.050]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.050]         }
[17:02:51.050]         base::close(...future.stdout)
[17:02:51.050]         ...future.stdout <- NULL
[17:02:51.050]     }
[17:02:51.050]     ...future.result$conditions <- ...future.conditions
[17:02:51.050]     ...future.result$finished <- base::Sys.time()
[17:02:51.050]     ...future.result
[17:02:51.050] }
[17:02:51.052] plan(): Setting new future strategy stack:
[17:02:51.052] List of future strategies:
[17:02:51.052] 1. sequential:
[17:02:51.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.052]    - tweaked: FALSE
[17:02:51.052]    - call: NULL
[17:02:51.053] plan(): nbrOfWorkers() = 1
[17:02:51.053] plan(): Setting new future strategy stack:
[17:02:51.053] List of future strategies:
[17:02:51.053] 1. sequential:
[17:02:51.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.053]    - tweaked: FALSE
[17:02:51.053]    - call: plan(strategy)
[17:02:51.054] plan(): nbrOfWorkers() = 1
[17:02:51.054] SequentialFuture started (and completed)
[17:02:51.054] - Launch lazy future ... done
[17:02:51.054] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.054] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.055] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.056] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.056] Searching for globals ... DONE
[17:02:51.056] Resolving globals: TRUE
[17:02:51.056] Resolving any globals that are futures ...
[17:02:51.056] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.056] Resolving any globals that are futures ... DONE
[17:02:51.056] Resolving futures part of globals (recursively) ...
[17:02:51.057] resolve() on list ...
[17:02:51.057]  recursive: 99
[17:02:51.057]  length: 1
[17:02:51.057]  elements: ‘a’
[17:02:51.057] resolved() for ‘SequentialFuture’ ...
[17:02:51.057] - state: ‘finished’
[17:02:51.057] - run: TRUE
[17:02:51.057] - result: ‘FutureResult’
[17:02:51.057] resolved() for ‘SequentialFuture’ ... done
[17:02:51.058] Future #1
[17:02:51.058] resolved() for ‘SequentialFuture’ ...
[17:02:51.058] - state: ‘finished’
[17:02:51.058] - run: TRUE
[17:02:51.058] - result: ‘FutureResult’
[17:02:51.058] resolved() for ‘SequentialFuture’ ... done
[17:02:51.058] A SequentialFuture was resolved
[17:02:51.060]  length: 0 (resolved future 1)
[17:02:51.060] resolve() on list ... DONE
[17:02:51.060] - globals: [1] ‘a’
[17:02:51.060] Resolving futures part of globals (recursively) ... DONE
[17:02:51.061] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:02:51.061] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:02:51.061] - globals: [1] ‘a’
[17:02:51.062] - packages: [1] ‘future’
[17:02:51.062] getGlobalsAndPackages() ... DONE
[17:02:51.062] run() for ‘Future’ ...
[17:02:51.062] - state: ‘created’
[17:02:51.062] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.062] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.063]   - Field: ‘label’
[17:02:51.063]   - Field: ‘local’
[17:02:51.063]   - Field: ‘owner’
[17:02:51.063]   - Field: ‘envir’
[17:02:51.063]   - Field: ‘packages’
[17:02:51.063]   - Field: ‘gc’
[17:02:51.063]   - Field: ‘conditions’
[17:02:51.063]   - Field: ‘expr’
[17:02:51.063]   - Field: ‘uuid’
[17:02:51.063]   - Field: ‘seed’
[17:02:51.064]   - Field: ‘version’
[17:02:51.064]   - Field: ‘result’
[17:02:51.064]   - Field: ‘asynchronous’
[17:02:51.064]   - Field: ‘calls’
[17:02:51.064]   - Field: ‘globals’
[17:02:51.064]   - Field: ‘stdout’
[17:02:51.064]   - Field: ‘earlySignal’
[17:02:51.064]   - Field: ‘lazy’
[17:02:51.064]   - Field: ‘state’
[17:02:51.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.064] - Launch lazy future ...
[17:02:51.065] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.065] Packages needed by future strategies (n = 0): <none>
[17:02:51.065] {
[17:02:51.065]     {
[17:02:51.065]         {
[17:02:51.065]             ...future.startTime <- base::Sys.time()
[17:02:51.065]             {
[17:02:51.065]                 {
[17:02:51.065]                   {
[17:02:51.065]                     {
[17:02:51.065]                       base::local({
[17:02:51.065]                         has_future <- base::requireNamespace("future", 
[17:02:51.065]                           quietly = TRUE)
[17:02:51.065]                         if (has_future) {
[17:02:51.065]                           ns <- base::getNamespace("future")
[17:02:51.065]                           version <- ns[[".package"]][["version"]]
[17:02:51.065]                           if (is.null(version)) 
[17:02:51.065]                             version <- utils::packageVersion("future")
[17:02:51.065]                         }
[17:02:51.065]                         else {
[17:02:51.065]                           version <- NULL
[17:02:51.065]                         }
[17:02:51.065]                         if (!has_future || version < "1.8.0") {
[17:02:51.065]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.065]                             "", base::R.version$version.string), 
[17:02:51.065]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.065]                               "release", "version")], collapse = " "), 
[17:02:51.065]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.065]                             info)
[17:02:51.065]                           info <- base::paste(info, collapse = "; ")
[17:02:51.065]                           if (!has_future) {
[17:02:51.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.065]                               info)
[17:02:51.065]                           }
[17:02:51.065]                           else {
[17:02:51.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.065]                               info, version)
[17:02:51.065]                           }
[17:02:51.065]                           base::stop(msg)
[17:02:51.065]                         }
[17:02:51.065]                       })
[17:02:51.065]                     }
[17:02:51.065]                     base::local({
[17:02:51.065]                       for (pkg in "future") {
[17:02:51.065]                         base::loadNamespace(pkg)
[17:02:51.065]                         base::library(pkg, character.only = TRUE)
[17:02:51.065]                       }
[17:02:51.065]                     })
[17:02:51.065]                   }
[17:02:51.065]                   ...future.strategy.old <- future::plan("list")
[17:02:51.065]                   options(future.plan = NULL)
[17:02:51.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.065]                 }
[17:02:51.065]                 ...future.workdir <- getwd()
[17:02:51.065]             }
[17:02:51.065]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.065]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.065]         }
[17:02:51.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.065]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.065]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.065]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.065]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.065]             base::names(...future.oldOptions))
[17:02:51.065]     }
[17:02:51.065]     if (FALSE) {
[17:02:51.065]     }
[17:02:51.065]     else {
[17:02:51.065]         if (TRUE) {
[17:02:51.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.065]                 open = "w")
[17:02:51.065]         }
[17:02:51.065]         else {
[17:02:51.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.065]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.065]         }
[17:02:51.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.065]             base::sink(type = "output", split = FALSE)
[17:02:51.065]             base::close(...future.stdout)
[17:02:51.065]         }, add = TRUE)
[17:02:51.065]     }
[17:02:51.065]     ...future.frame <- base::sys.nframe()
[17:02:51.065]     ...future.conditions <- base::list()
[17:02:51.065]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.065]     if (FALSE) {
[17:02:51.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.065]     }
[17:02:51.065]     ...future.result <- base::tryCatch({
[17:02:51.065]         base::withCallingHandlers({
[17:02:51.065]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.065]                 1))
[17:02:51.065]             future::FutureResult(value = ...future.value$value, 
[17:02:51.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.065]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.065]                     ...future.globalenv.names))
[17:02:51.065]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.065]         }, condition = base::local({
[17:02:51.065]             c <- base::c
[17:02:51.065]             inherits <- base::inherits
[17:02:51.065]             invokeRestart <- base::invokeRestart
[17:02:51.065]             length <- base::length
[17:02:51.065]             list <- base::list
[17:02:51.065]             seq.int <- base::seq.int
[17:02:51.065]             signalCondition <- base::signalCondition
[17:02:51.065]             sys.calls <- base::sys.calls
[17:02:51.065]             `[[` <- base::`[[`
[17:02:51.065]             `+` <- base::`+`
[17:02:51.065]             `<<-` <- base::`<<-`
[17:02:51.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.065]                   3L)]
[17:02:51.065]             }
[17:02:51.065]             function(cond) {
[17:02:51.065]                 is_error <- inherits(cond, "error")
[17:02:51.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.065]                   NULL)
[17:02:51.065]                 if (is_error) {
[17:02:51.065]                   sessionInformation <- function() {
[17:02:51.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.065]                       search = base::search(), system = base::Sys.info())
[17:02:51.065]                   }
[17:02:51.065]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.065]                     cond$call), session = sessionInformation(), 
[17:02:51.065]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.065]                   signalCondition(cond)
[17:02:51.065]                 }
[17:02:51.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.065]                 "immediateCondition"))) {
[17:02:51.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.065]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.065]                   if (TRUE && !signal) {
[17:02:51.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.065]                     {
[17:02:51.065]                       inherits <- base::inherits
[17:02:51.065]                       invokeRestart <- base::invokeRestart
[17:02:51.065]                       is.null <- base::is.null
[17:02:51.065]                       muffled <- FALSE
[17:02:51.065]                       if (inherits(cond, "message")) {
[17:02:51.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.065]                         if (muffled) 
[17:02:51.065]                           invokeRestart("muffleMessage")
[17:02:51.065]                       }
[17:02:51.065]                       else if (inherits(cond, "warning")) {
[17:02:51.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.065]                         if (muffled) 
[17:02:51.065]                           invokeRestart("muffleWarning")
[17:02:51.065]                       }
[17:02:51.065]                       else if (inherits(cond, "condition")) {
[17:02:51.065]                         if (!is.null(pattern)) {
[17:02:51.065]                           computeRestarts <- base::computeRestarts
[17:02:51.065]                           grepl <- base::grepl
[17:02:51.065]                           restarts <- computeRestarts(cond)
[17:02:51.065]                           for (restart in restarts) {
[17:02:51.065]                             name <- restart$name
[17:02:51.065]                             if (is.null(name)) 
[17:02:51.065]                               next
[17:02:51.065]                             if (!grepl(pattern, name)) 
[17:02:51.065]                               next
[17:02:51.065]                             invokeRestart(restart)
[17:02:51.065]                             muffled <- TRUE
[17:02:51.065]                             break
[17:02:51.065]                           }
[17:02:51.065]                         }
[17:02:51.065]                       }
[17:02:51.065]                       invisible(muffled)
[17:02:51.065]                     }
[17:02:51.065]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.065]                   }
[17:02:51.065]                 }
[17:02:51.065]                 else {
[17:02:51.065]                   if (TRUE) {
[17:02:51.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.065]                     {
[17:02:51.065]                       inherits <- base::inherits
[17:02:51.065]                       invokeRestart <- base::invokeRestart
[17:02:51.065]                       is.null <- base::is.null
[17:02:51.065]                       muffled <- FALSE
[17:02:51.065]                       if (inherits(cond, "message")) {
[17:02:51.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.065]                         if (muffled) 
[17:02:51.065]                           invokeRestart("muffleMessage")
[17:02:51.065]                       }
[17:02:51.065]                       else if (inherits(cond, "warning")) {
[17:02:51.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.065]                         if (muffled) 
[17:02:51.065]                           invokeRestart("muffleWarning")
[17:02:51.065]                       }
[17:02:51.065]                       else if (inherits(cond, "condition")) {
[17:02:51.065]                         if (!is.null(pattern)) {
[17:02:51.065]                           computeRestarts <- base::computeRestarts
[17:02:51.065]                           grepl <- base::grepl
[17:02:51.065]                           restarts <- computeRestarts(cond)
[17:02:51.065]                           for (restart in restarts) {
[17:02:51.065]                             name <- restart$name
[17:02:51.065]                             if (is.null(name)) 
[17:02:51.065]                               next
[17:02:51.065]                             if (!grepl(pattern, name)) 
[17:02:51.065]                               next
[17:02:51.065]                             invokeRestart(restart)
[17:02:51.065]                             muffled <- TRUE
[17:02:51.065]                             break
[17:02:51.065]                           }
[17:02:51.065]                         }
[17:02:51.065]                       }
[17:02:51.065]                       invisible(muffled)
[17:02:51.065]                     }
[17:02:51.065]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.065]                   }
[17:02:51.065]                 }
[17:02:51.065]             }
[17:02:51.065]         }))
[17:02:51.065]     }, error = function(ex) {
[17:02:51.065]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.065]                 ...future.rng), started = ...future.startTime, 
[17:02:51.065]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.065]             version = "1.8"), class = "FutureResult")
[17:02:51.065]     }, finally = {
[17:02:51.065]         if (!identical(...future.workdir, getwd())) 
[17:02:51.065]             setwd(...future.workdir)
[17:02:51.065]         {
[17:02:51.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.065]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.065]             }
[17:02:51.065]             base::options(...future.oldOptions)
[17:02:51.065]             if (.Platform$OS.type == "windows") {
[17:02:51.065]                 old_names <- names(...future.oldEnvVars)
[17:02:51.065]                 envs <- base::Sys.getenv()
[17:02:51.065]                 names <- names(envs)
[17:02:51.065]                 common <- intersect(names, old_names)
[17:02:51.065]                 added <- setdiff(names, old_names)
[17:02:51.065]                 removed <- setdiff(old_names, names)
[17:02:51.065]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.065]                   envs[common]]
[17:02:51.065]                 NAMES <- toupper(changed)
[17:02:51.065]                 args <- list()
[17:02:51.065]                 for (kk in seq_along(NAMES)) {
[17:02:51.065]                   name <- changed[[kk]]
[17:02:51.065]                   NAME <- NAMES[[kk]]
[17:02:51.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.065]                     next
[17:02:51.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.065]                 }
[17:02:51.065]                 NAMES <- toupper(added)
[17:02:51.065]                 for (kk in seq_along(NAMES)) {
[17:02:51.065]                   name <- added[[kk]]
[17:02:51.065]                   NAME <- NAMES[[kk]]
[17:02:51.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.065]                     next
[17:02:51.065]                   args[[name]] <- ""
[17:02:51.065]                 }
[17:02:51.065]                 NAMES <- toupper(removed)
[17:02:51.065]                 for (kk in seq_along(NAMES)) {
[17:02:51.065]                   name <- removed[[kk]]
[17:02:51.065]                   NAME <- NAMES[[kk]]
[17:02:51.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.065]                     next
[17:02:51.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.065]                 }
[17:02:51.065]                 if (length(args) > 0) 
[17:02:51.065]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.065]             }
[17:02:51.065]             else {
[17:02:51.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.065]             }
[17:02:51.065]             {
[17:02:51.065]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.065]                   0L) {
[17:02:51.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.065]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.065]                   base::options(opts)
[17:02:51.065]                 }
[17:02:51.065]                 {
[17:02:51.065]                   {
[17:02:51.065]                     NULL
[17:02:51.065]                     RNGkind("Mersenne-Twister")
[17:02:51.065]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.065]                       inherits = FALSE)
[17:02:51.065]                   }
[17:02:51.065]                   options(future.plan = NULL)
[17:02:51.065]                   if (is.na(NA_character_)) 
[17:02:51.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.065]                     .init = FALSE)
[17:02:51.065]                 }
[17:02:51.065]             }
[17:02:51.065]         }
[17:02:51.065]     })
[17:02:51.065]     if (TRUE) {
[17:02:51.065]         base::sink(type = "output", split = FALSE)
[17:02:51.065]         if (TRUE) {
[17:02:51.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.065]         }
[17:02:51.065]         else {
[17:02:51.065]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.065]         }
[17:02:51.065]         base::close(...future.stdout)
[17:02:51.065]         ...future.stdout <- NULL
[17:02:51.065]     }
[17:02:51.065]     ...future.result$conditions <- ...future.conditions
[17:02:51.065]     ...future.result$finished <- base::Sys.time()
[17:02:51.065]     ...future.result
[17:02:51.065] }
[17:02:51.067] assign_globals() ...
[17:02:51.067] List of 1
[17:02:51.067]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f66e1aa8> 
[17:02:51.067]  - attr(*, "where")=List of 1
[17:02:51.067]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.067]  - attr(*, "resolved")= logi TRUE
[17:02:51.067]  - attr(*, "total_size")= num 10424
[17:02:51.067]  - attr(*, "already-done")= logi TRUE
[17:02:51.069] - copied ‘a’ to environment
[17:02:51.069] assign_globals() ... done
[17:02:51.070] plan(): Setting new future strategy stack:
[17:02:51.070] List of future strategies:
[17:02:51.070] 1. sequential:
[17:02:51.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.070]    - tweaked: FALSE
[17:02:51.070]    - call: NULL
[17:02:51.070] plan(): nbrOfWorkers() = 1
[17:02:51.071] plan(): Setting new future strategy stack:
[17:02:51.071] List of future strategies:
[17:02:51.071] 1. sequential:
[17:02:51.071]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.071]    - tweaked: FALSE
[17:02:51.071]    - call: plan(strategy)
[17:02:51.072] plan(): nbrOfWorkers() = 1
[17:02:51.072] SequentialFuture started (and completed)
[17:02:51.072] - Launch lazy future ... done
[17:02:51.072] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.073] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.073] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.073] 
[17:02:51.073] Searching for globals ... DONE
[17:02:51.073] - globals: [0] <none>
[17:02:51.074] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.074] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.074] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.075] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.075] Searching for globals ... DONE
[17:02:51.075] Resolving globals: TRUE
[17:02:51.075] Resolving any globals that are futures ...
[17:02:51.075] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.075] Resolving any globals that are futures ... DONE
[17:02:51.076] Resolving futures part of globals (recursively) ...
[17:02:51.076] resolve() on list ...
[17:02:51.076]  recursive: 99
[17:02:51.076]  length: 1
[17:02:51.076]  elements: ‘a’
[17:02:51.076] run() for ‘Future’ ...
[17:02:51.076] - state: ‘created’
[17:02:51.077] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.077] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.077] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.077]   - Field: ‘label’
[17:02:51.077]   - Field: ‘local’
[17:02:51.077]   - Field: ‘owner’
[17:02:51.077]   - Field: ‘envir’
[17:02:51.077]   - Field: ‘packages’
[17:02:51.078]   - Field: ‘gc’
[17:02:51.078]   - Field: ‘conditions’
[17:02:51.078]   - Field: ‘expr’
[17:02:51.078]   - Field: ‘uuid’
[17:02:51.078]   - Field: ‘seed’
[17:02:51.078]   - Field: ‘version’
[17:02:51.078]   - Field: ‘result’
[17:02:51.078]   - Field: ‘asynchronous’
[17:02:51.078]   - Field: ‘calls’
[17:02:51.078]   - Field: ‘globals’
[17:02:51.078]   - Field: ‘stdout’
[17:02:51.079]   - Field: ‘earlySignal’
[17:02:51.079]   - Field: ‘lazy’
[17:02:51.079]   - Field: ‘state’
[17:02:51.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.079] - Launch lazy future ...
[17:02:51.079] Packages needed by the future expression (n = 0): <none>
[17:02:51.079] Packages needed by future strategies (n = 0): <none>
[17:02:51.080] {
[17:02:51.080]     {
[17:02:51.080]         {
[17:02:51.080]             ...future.startTime <- base::Sys.time()
[17:02:51.080]             {
[17:02:51.080]                 {
[17:02:51.080]                   {
[17:02:51.080]                     base::local({
[17:02:51.080]                       has_future <- base::requireNamespace("future", 
[17:02:51.080]                         quietly = TRUE)
[17:02:51.080]                       if (has_future) {
[17:02:51.080]                         ns <- base::getNamespace("future")
[17:02:51.080]                         version <- ns[[".package"]][["version"]]
[17:02:51.080]                         if (is.null(version)) 
[17:02:51.080]                           version <- utils::packageVersion("future")
[17:02:51.080]                       }
[17:02:51.080]                       else {
[17:02:51.080]                         version <- NULL
[17:02:51.080]                       }
[17:02:51.080]                       if (!has_future || version < "1.8.0") {
[17:02:51.080]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.080]                           "", base::R.version$version.string), 
[17:02:51.080]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.080]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.080]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.080]                             "release", "version")], collapse = " "), 
[17:02:51.080]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.080]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.080]                           info)
[17:02:51.080]                         info <- base::paste(info, collapse = "; ")
[17:02:51.080]                         if (!has_future) {
[17:02:51.080]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.080]                             info)
[17:02:51.080]                         }
[17:02:51.080]                         else {
[17:02:51.080]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.080]                             info, version)
[17:02:51.080]                         }
[17:02:51.080]                         base::stop(msg)
[17:02:51.080]                       }
[17:02:51.080]                     })
[17:02:51.080]                   }
[17:02:51.080]                   ...future.strategy.old <- future::plan("list")
[17:02:51.080]                   options(future.plan = NULL)
[17:02:51.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.080]                 }
[17:02:51.080]                 ...future.workdir <- getwd()
[17:02:51.080]             }
[17:02:51.080]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.080]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.080]         }
[17:02:51.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.080]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.080]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.080]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.080]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.080]             base::names(...future.oldOptions))
[17:02:51.080]     }
[17:02:51.080]     if (FALSE) {
[17:02:51.080]     }
[17:02:51.080]     else {
[17:02:51.080]         if (TRUE) {
[17:02:51.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.080]                 open = "w")
[17:02:51.080]         }
[17:02:51.080]         else {
[17:02:51.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.080]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.080]         }
[17:02:51.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.080]             base::sink(type = "output", split = FALSE)
[17:02:51.080]             base::close(...future.stdout)
[17:02:51.080]         }, add = TRUE)
[17:02:51.080]     }
[17:02:51.080]     ...future.frame <- base::sys.nframe()
[17:02:51.080]     ...future.conditions <- base::list()
[17:02:51.080]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.080]     if (FALSE) {
[17:02:51.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.080]     }
[17:02:51.080]     ...future.result <- base::tryCatch({
[17:02:51.080]         base::withCallingHandlers({
[17:02:51.080]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.080]             future::FutureResult(value = ...future.value$value, 
[17:02:51.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.080]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.080]                     ...future.globalenv.names))
[17:02:51.080]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.080]         }, condition = base::local({
[17:02:51.080]             c <- base::c
[17:02:51.080]             inherits <- base::inherits
[17:02:51.080]             invokeRestart <- base::invokeRestart
[17:02:51.080]             length <- base::length
[17:02:51.080]             list <- base::list
[17:02:51.080]             seq.int <- base::seq.int
[17:02:51.080]             signalCondition <- base::signalCondition
[17:02:51.080]             sys.calls <- base::sys.calls
[17:02:51.080]             `[[` <- base::`[[`
[17:02:51.080]             `+` <- base::`+`
[17:02:51.080]             `<<-` <- base::`<<-`
[17:02:51.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.080]                   3L)]
[17:02:51.080]             }
[17:02:51.080]             function(cond) {
[17:02:51.080]                 is_error <- inherits(cond, "error")
[17:02:51.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.080]                   NULL)
[17:02:51.080]                 if (is_error) {
[17:02:51.080]                   sessionInformation <- function() {
[17:02:51.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.080]                       search = base::search(), system = base::Sys.info())
[17:02:51.080]                   }
[17:02:51.080]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.080]                     cond$call), session = sessionInformation(), 
[17:02:51.080]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.080]                   signalCondition(cond)
[17:02:51.080]                 }
[17:02:51.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.080]                 "immediateCondition"))) {
[17:02:51.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.080]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.080]                   if (TRUE && !signal) {
[17:02:51.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.080]                     {
[17:02:51.080]                       inherits <- base::inherits
[17:02:51.080]                       invokeRestart <- base::invokeRestart
[17:02:51.080]                       is.null <- base::is.null
[17:02:51.080]                       muffled <- FALSE
[17:02:51.080]                       if (inherits(cond, "message")) {
[17:02:51.080]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.080]                         if (muffled) 
[17:02:51.080]                           invokeRestart("muffleMessage")
[17:02:51.080]                       }
[17:02:51.080]                       else if (inherits(cond, "warning")) {
[17:02:51.080]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.080]                         if (muffled) 
[17:02:51.080]                           invokeRestart("muffleWarning")
[17:02:51.080]                       }
[17:02:51.080]                       else if (inherits(cond, "condition")) {
[17:02:51.080]                         if (!is.null(pattern)) {
[17:02:51.080]                           computeRestarts <- base::computeRestarts
[17:02:51.080]                           grepl <- base::grepl
[17:02:51.080]                           restarts <- computeRestarts(cond)
[17:02:51.080]                           for (restart in restarts) {
[17:02:51.080]                             name <- restart$name
[17:02:51.080]                             if (is.null(name)) 
[17:02:51.080]                               next
[17:02:51.080]                             if (!grepl(pattern, name)) 
[17:02:51.080]                               next
[17:02:51.080]                             invokeRestart(restart)
[17:02:51.080]                             muffled <- TRUE
[17:02:51.080]                             break
[17:02:51.080]                           }
[17:02:51.080]                         }
[17:02:51.080]                       }
[17:02:51.080]                       invisible(muffled)
[17:02:51.080]                     }
[17:02:51.080]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.080]                   }
[17:02:51.080]                 }
[17:02:51.080]                 else {
[17:02:51.080]                   if (TRUE) {
[17:02:51.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.080]                     {
[17:02:51.080]                       inherits <- base::inherits
[17:02:51.080]                       invokeRestart <- base::invokeRestart
[17:02:51.080]                       is.null <- base::is.null
[17:02:51.080]                       muffled <- FALSE
[17:02:51.080]                       if (inherits(cond, "message")) {
[17:02:51.080]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.080]                         if (muffled) 
[17:02:51.080]                           invokeRestart("muffleMessage")
[17:02:51.080]                       }
[17:02:51.080]                       else if (inherits(cond, "warning")) {
[17:02:51.080]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.080]                         if (muffled) 
[17:02:51.080]                           invokeRestart("muffleWarning")
[17:02:51.080]                       }
[17:02:51.080]                       else if (inherits(cond, "condition")) {
[17:02:51.080]                         if (!is.null(pattern)) {
[17:02:51.080]                           computeRestarts <- base::computeRestarts
[17:02:51.080]                           grepl <- base::grepl
[17:02:51.080]                           restarts <- computeRestarts(cond)
[17:02:51.080]                           for (restart in restarts) {
[17:02:51.080]                             name <- restart$name
[17:02:51.080]                             if (is.null(name)) 
[17:02:51.080]                               next
[17:02:51.080]                             if (!grepl(pattern, name)) 
[17:02:51.080]                               next
[17:02:51.080]                             invokeRestart(restart)
[17:02:51.080]                             muffled <- TRUE
[17:02:51.080]                             break
[17:02:51.080]                           }
[17:02:51.080]                         }
[17:02:51.080]                       }
[17:02:51.080]                       invisible(muffled)
[17:02:51.080]                     }
[17:02:51.080]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.080]                   }
[17:02:51.080]                 }
[17:02:51.080]             }
[17:02:51.080]         }))
[17:02:51.080]     }, error = function(ex) {
[17:02:51.080]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.080]                 ...future.rng), started = ...future.startTime, 
[17:02:51.080]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.080]             version = "1.8"), class = "FutureResult")
[17:02:51.080]     }, finally = {
[17:02:51.080]         if (!identical(...future.workdir, getwd())) 
[17:02:51.080]             setwd(...future.workdir)
[17:02:51.080]         {
[17:02:51.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.080]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.080]             }
[17:02:51.080]             base::options(...future.oldOptions)
[17:02:51.080]             if (.Platform$OS.type == "windows") {
[17:02:51.080]                 old_names <- names(...future.oldEnvVars)
[17:02:51.080]                 envs <- base::Sys.getenv()
[17:02:51.080]                 names <- names(envs)
[17:02:51.080]                 common <- intersect(names, old_names)
[17:02:51.080]                 added <- setdiff(names, old_names)
[17:02:51.080]                 removed <- setdiff(old_names, names)
[17:02:51.080]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.080]                   envs[common]]
[17:02:51.080]                 NAMES <- toupper(changed)
[17:02:51.080]                 args <- list()
[17:02:51.080]                 for (kk in seq_along(NAMES)) {
[17:02:51.080]                   name <- changed[[kk]]
[17:02:51.080]                   NAME <- NAMES[[kk]]
[17:02:51.080]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.080]                     next
[17:02:51.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.080]                 }
[17:02:51.080]                 NAMES <- toupper(added)
[17:02:51.080]                 for (kk in seq_along(NAMES)) {
[17:02:51.080]                   name <- added[[kk]]
[17:02:51.080]                   NAME <- NAMES[[kk]]
[17:02:51.080]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.080]                     next
[17:02:51.080]                   args[[name]] <- ""
[17:02:51.080]                 }
[17:02:51.080]                 NAMES <- toupper(removed)
[17:02:51.080]                 for (kk in seq_along(NAMES)) {
[17:02:51.080]                   name <- removed[[kk]]
[17:02:51.080]                   NAME <- NAMES[[kk]]
[17:02:51.080]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.080]                     next
[17:02:51.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.080]                 }
[17:02:51.080]                 if (length(args) > 0) 
[17:02:51.080]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.080]             }
[17:02:51.080]             else {
[17:02:51.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.080]             }
[17:02:51.080]             {
[17:02:51.080]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.080]                   0L) {
[17:02:51.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.080]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.080]                   base::options(opts)
[17:02:51.080]                 }
[17:02:51.080]                 {
[17:02:51.080]                   {
[17:02:51.080]                     NULL
[17:02:51.080]                     RNGkind("Mersenne-Twister")
[17:02:51.080]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.080]                       inherits = FALSE)
[17:02:51.080]                   }
[17:02:51.080]                   options(future.plan = NULL)
[17:02:51.080]                   if (is.na(NA_character_)) 
[17:02:51.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.080]                     .init = FALSE)
[17:02:51.080]                 }
[17:02:51.080]             }
[17:02:51.080]         }
[17:02:51.080]     })
[17:02:51.080]     if (TRUE) {
[17:02:51.080]         base::sink(type = "output", split = FALSE)
[17:02:51.080]         if (TRUE) {
[17:02:51.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.080]         }
[17:02:51.080]         else {
[17:02:51.080]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.080]         }
[17:02:51.080]         base::close(...future.stdout)
[17:02:51.080]         ...future.stdout <- NULL
[17:02:51.080]     }
[17:02:51.080]     ...future.result$conditions <- ...future.conditions
[17:02:51.080]     ...future.result$finished <- base::Sys.time()
[17:02:51.080]     ...future.result
[17:02:51.080] }
[17:02:51.081] plan(): Setting new future strategy stack:
[17:02:51.081] List of future strategies:
[17:02:51.081] 1. sequential:
[17:02:51.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.081]    - tweaked: FALSE
[17:02:51.081]    - call: NULL
[17:02:51.082] plan(): nbrOfWorkers() = 1
[17:02:51.083] plan(): Setting new future strategy stack:
[17:02:51.083] List of future strategies:
[17:02:51.083] 1. sequential:
[17:02:51.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.083]    - tweaked: FALSE
[17:02:51.083]    - call: plan(strategy)
[17:02:51.083] plan(): nbrOfWorkers() = 1
[17:02:51.083] SequentialFuture started (and completed)
[17:02:51.083] - Launch lazy future ... done
[17:02:51.083] run() for ‘SequentialFuture’ ... done
[17:02:51.084] resolved() for ‘SequentialFuture’ ...
[17:02:51.084] - state: ‘finished’
[17:02:51.084] - run: TRUE
[17:02:51.084] - result: ‘FutureResult’
[17:02:51.084] resolved() for ‘SequentialFuture’ ... done
[17:02:51.084] Future #1
[17:02:51.084] resolved() for ‘SequentialFuture’ ...
[17:02:51.084] - state: ‘finished’
[17:02:51.084] - run: TRUE
[17:02:51.084] - result: ‘FutureResult’
[17:02:51.085] resolved() for ‘SequentialFuture’ ... done
[17:02:51.085] A SequentialFuture was resolved
[17:02:51.085]  length: 0 (resolved future 1)
[17:02:51.085] resolve() on list ... DONE
[17:02:51.085] - globals: [1] ‘a’
[17:02:51.085] Resolving futures part of globals (recursively) ... DONE
[17:02:51.086] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:02:51.086] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:02:51.086] - globals: [1] ‘a’
[17:02:51.086] - packages: [1] ‘future’
[17:02:51.086] getGlobalsAndPackages() ... DONE
[17:02:51.087] run() for ‘Future’ ...
[17:02:51.087] - state: ‘created’
[17:02:51.087] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.087] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.087] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.087]   - Field: ‘label’
[17:02:51.087]   - Field: ‘local’
[17:02:51.089]   - Field: ‘owner’
[17:02:51.089]   - Field: ‘envir’
[17:02:51.089]   - Field: ‘packages’
[17:02:51.089]   - Field: ‘gc’
[17:02:51.090]   - Field: ‘conditions’
[17:02:51.090]   - Field: ‘expr’
[17:02:51.090]   - Field: ‘uuid’
[17:02:51.090]   - Field: ‘seed’
[17:02:51.090]   - Field: ‘version’
[17:02:51.090]   - Field: ‘result’
[17:02:51.090]   - Field: ‘asynchronous’
[17:02:51.090]   - Field: ‘calls’
[17:02:51.090]   - Field: ‘globals’
[17:02:51.090]   - Field: ‘stdout’
[17:02:51.090]   - Field: ‘earlySignal’
[17:02:51.091]   - Field: ‘lazy’
[17:02:51.091]   - Field: ‘state’
[17:02:51.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.091] - Launch lazy future ...
[17:02:51.091] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.091] Packages needed by future strategies (n = 0): <none>
[17:02:51.092] {
[17:02:51.092]     {
[17:02:51.092]         {
[17:02:51.092]             ...future.startTime <- base::Sys.time()
[17:02:51.092]             {
[17:02:51.092]                 {
[17:02:51.092]                   {
[17:02:51.092]                     {
[17:02:51.092]                       base::local({
[17:02:51.092]                         has_future <- base::requireNamespace("future", 
[17:02:51.092]                           quietly = TRUE)
[17:02:51.092]                         if (has_future) {
[17:02:51.092]                           ns <- base::getNamespace("future")
[17:02:51.092]                           version <- ns[[".package"]][["version"]]
[17:02:51.092]                           if (is.null(version)) 
[17:02:51.092]                             version <- utils::packageVersion("future")
[17:02:51.092]                         }
[17:02:51.092]                         else {
[17:02:51.092]                           version <- NULL
[17:02:51.092]                         }
[17:02:51.092]                         if (!has_future || version < "1.8.0") {
[17:02:51.092]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.092]                             "", base::R.version$version.string), 
[17:02:51.092]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.092]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.092]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.092]                               "release", "version")], collapse = " "), 
[17:02:51.092]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.092]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.092]                             info)
[17:02:51.092]                           info <- base::paste(info, collapse = "; ")
[17:02:51.092]                           if (!has_future) {
[17:02:51.092]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.092]                               info)
[17:02:51.092]                           }
[17:02:51.092]                           else {
[17:02:51.092]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.092]                               info, version)
[17:02:51.092]                           }
[17:02:51.092]                           base::stop(msg)
[17:02:51.092]                         }
[17:02:51.092]                       })
[17:02:51.092]                     }
[17:02:51.092]                     base::local({
[17:02:51.092]                       for (pkg in "future") {
[17:02:51.092]                         base::loadNamespace(pkg)
[17:02:51.092]                         base::library(pkg, character.only = TRUE)
[17:02:51.092]                       }
[17:02:51.092]                     })
[17:02:51.092]                   }
[17:02:51.092]                   ...future.strategy.old <- future::plan("list")
[17:02:51.092]                   options(future.plan = NULL)
[17:02:51.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.092]                 }
[17:02:51.092]                 ...future.workdir <- getwd()
[17:02:51.092]             }
[17:02:51.092]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.092]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.092]         }
[17:02:51.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.092]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.092]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.092]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.092]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.092]             base::names(...future.oldOptions))
[17:02:51.092]     }
[17:02:51.092]     if (FALSE) {
[17:02:51.092]     }
[17:02:51.092]     else {
[17:02:51.092]         if (TRUE) {
[17:02:51.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.092]                 open = "w")
[17:02:51.092]         }
[17:02:51.092]         else {
[17:02:51.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.092]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.092]         }
[17:02:51.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.092]             base::sink(type = "output", split = FALSE)
[17:02:51.092]             base::close(...future.stdout)
[17:02:51.092]         }, add = TRUE)
[17:02:51.092]     }
[17:02:51.092]     ...future.frame <- base::sys.nframe()
[17:02:51.092]     ...future.conditions <- base::list()
[17:02:51.092]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.092]     if (FALSE) {
[17:02:51.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.092]     }
[17:02:51.092]     ...future.result <- base::tryCatch({
[17:02:51.092]         base::withCallingHandlers({
[17:02:51.092]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.092]                 1))
[17:02:51.092]             future::FutureResult(value = ...future.value$value, 
[17:02:51.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.092]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.092]                     ...future.globalenv.names))
[17:02:51.092]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.092]         }, condition = base::local({
[17:02:51.092]             c <- base::c
[17:02:51.092]             inherits <- base::inherits
[17:02:51.092]             invokeRestart <- base::invokeRestart
[17:02:51.092]             length <- base::length
[17:02:51.092]             list <- base::list
[17:02:51.092]             seq.int <- base::seq.int
[17:02:51.092]             signalCondition <- base::signalCondition
[17:02:51.092]             sys.calls <- base::sys.calls
[17:02:51.092]             `[[` <- base::`[[`
[17:02:51.092]             `+` <- base::`+`
[17:02:51.092]             `<<-` <- base::`<<-`
[17:02:51.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.092]                   3L)]
[17:02:51.092]             }
[17:02:51.092]             function(cond) {
[17:02:51.092]                 is_error <- inherits(cond, "error")
[17:02:51.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.092]                   NULL)
[17:02:51.092]                 if (is_error) {
[17:02:51.092]                   sessionInformation <- function() {
[17:02:51.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.092]                       search = base::search(), system = base::Sys.info())
[17:02:51.092]                   }
[17:02:51.092]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.092]                     cond$call), session = sessionInformation(), 
[17:02:51.092]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.092]                   signalCondition(cond)
[17:02:51.092]                 }
[17:02:51.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.092]                 "immediateCondition"))) {
[17:02:51.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.092]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.092]                   if (TRUE && !signal) {
[17:02:51.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.092]                     {
[17:02:51.092]                       inherits <- base::inherits
[17:02:51.092]                       invokeRestart <- base::invokeRestart
[17:02:51.092]                       is.null <- base::is.null
[17:02:51.092]                       muffled <- FALSE
[17:02:51.092]                       if (inherits(cond, "message")) {
[17:02:51.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.092]                         if (muffled) 
[17:02:51.092]                           invokeRestart("muffleMessage")
[17:02:51.092]                       }
[17:02:51.092]                       else if (inherits(cond, "warning")) {
[17:02:51.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.092]                         if (muffled) 
[17:02:51.092]                           invokeRestart("muffleWarning")
[17:02:51.092]                       }
[17:02:51.092]                       else if (inherits(cond, "condition")) {
[17:02:51.092]                         if (!is.null(pattern)) {
[17:02:51.092]                           computeRestarts <- base::computeRestarts
[17:02:51.092]                           grepl <- base::grepl
[17:02:51.092]                           restarts <- computeRestarts(cond)
[17:02:51.092]                           for (restart in restarts) {
[17:02:51.092]                             name <- restart$name
[17:02:51.092]                             if (is.null(name)) 
[17:02:51.092]                               next
[17:02:51.092]                             if (!grepl(pattern, name)) 
[17:02:51.092]                               next
[17:02:51.092]                             invokeRestart(restart)
[17:02:51.092]                             muffled <- TRUE
[17:02:51.092]                             break
[17:02:51.092]                           }
[17:02:51.092]                         }
[17:02:51.092]                       }
[17:02:51.092]                       invisible(muffled)
[17:02:51.092]                     }
[17:02:51.092]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.092]                   }
[17:02:51.092]                 }
[17:02:51.092]                 else {
[17:02:51.092]                   if (TRUE) {
[17:02:51.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.092]                     {
[17:02:51.092]                       inherits <- base::inherits
[17:02:51.092]                       invokeRestart <- base::invokeRestart
[17:02:51.092]                       is.null <- base::is.null
[17:02:51.092]                       muffled <- FALSE
[17:02:51.092]                       if (inherits(cond, "message")) {
[17:02:51.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.092]                         if (muffled) 
[17:02:51.092]                           invokeRestart("muffleMessage")
[17:02:51.092]                       }
[17:02:51.092]                       else if (inherits(cond, "warning")) {
[17:02:51.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.092]                         if (muffled) 
[17:02:51.092]                           invokeRestart("muffleWarning")
[17:02:51.092]                       }
[17:02:51.092]                       else if (inherits(cond, "condition")) {
[17:02:51.092]                         if (!is.null(pattern)) {
[17:02:51.092]                           computeRestarts <- base::computeRestarts
[17:02:51.092]                           grepl <- base::grepl
[17:02:51.092]                           restarts <- computeRestarts(cond)
[17:02:51.092]                           for (restart in restarts) {
[17:02:51.092]                             name <- restart$name
[17:02:51.092]                             if (is.null(name)) 
[17:02:51.092]                               next
[17:02:51.092]                             if (!grepl(pattern, name)) 
[17:02:51.092]                               next
[17:02:51.092]                             invokeRestart(restart)
[17:02:51.092]                             muffled <- TRUE
[17:02:51.092]                             break
[17:02:51.092]                           }
[17:02:51.092]                         }
[17:02:51.092]                       }
[17:02:51.092]                       invisible(muffled)
[17:02:51.092]                     }
[17:02:51.092]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.092]                   }
[17:02:51.092]                 }
[17:02:51.092]             }
[17:02:51.092]         }))
[17:02:51.092]     }, error = function(ex) {
[17:02:51.092]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.092]                 ...future.rng), started = ...future.startTime, 
[17:02:51.092]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.092]             version = "1.8"), class = "FutureResult")
[17:02:51.092]     }, finally = {
[17:02:51.092]         if (!identical(...future.workdir, getwd())) 
[17:02:51.092]             setwd(...future.workdir)
[17:02:51.092]         {
[17:02:51.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.092]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.092]             }
[17:02:51.092]             base::options(...future.oldOptions)
[17:02:51.092]             if (.Platform$OS.type == "windows") {
[17:02:51.092]                 old_names <- names(...future.oldEnvVars)
[17:02:51.092]                 envs <- base::Sys.getenv()
[17:02:51.092]                 names <- names(envs)
[17:02:51.092]                 common <- intersect(names, old_names)
[17:02:51.092]                 added <- setdiff(names, old_names)
[17:02:51.092]                 removed <- setdiff(old_names, names)
[17:02:51.092]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.092]                   envs[common]]
[17:02:51.092]                 NAMES <- toupper(changed)
[17:02:51.092]                 args <- list()
[17:02:51.092]                 for (kk in seq_along(NAMES)) {
[17:02:51.092]                   name <- changed[[kk]]
[17:02:51.092]                   NAME <- NAMES[[kk]]
[17:02:51.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.092]                     next
[17:02:51.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.092]                 }
[17:02:51.092]                 NAMES <- toupper(added)
[17:02:51.092]                 for (kk in seq_along(NAMES)) {
[17:02:51.092]                   name <- added[[kk]]
[17:02:51.092]                   NAME <- NAMES[[kk]]
[17:02:51.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.092]                     next
[17:02:51.092]                   args[[name]] <- ""
[17:02:51.092]                 }
[17:02:51.092]                 NAMES <- toupper(removed)
[17:02:51.092]                 for (kk in seq_along(NAMES)) {
[17:02:51.092]                   name <- removed[[kk]]
[17:02:51.092]                   NAME <- NAMES[[kk]]
[17:02:51.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.092]                     next
[17:02:51.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.092]                 }
[17:02:51.092]                 if (length(args) > 0) 
[17:02:51.092]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.092]             }
[17:02:51.092]             else {
[17:02:51.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.092]             }
[17:02:51.092]             {
[17:02:51.092]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.092]                   0L) {
[17:02:51.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.092]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.092]                   base::options(opts)
[17:02:51.092]                 }
[17:02:51.092]                 {
[17:02:51.092]                   {
[17:02:51.092]                     NULL
[17:02:51.092]                     RNGkind("Mersenne-Twister")
[17:02:51.092]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.092]                       inherits = FALSE)
[17:02:51.092]                   }
[17:02:51.092]                   options(future.plan = NULL)
[17:02:51.092]                   if (is.na(NA_character_)) 
[17:02:51.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.092]                     .init = FALSE)
[17:02:51.092]                 }
[17:02:51.092]             }
[17:02:51.092]         }
[17:02:51.092]     })
[17:02:51.092]     if (TRUE) {
[17:02:51.092]         base::sink(type = "output", split = FALSE)
[17:02:51.092]         if (TRUE) {
[17:02:51.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.092]         }
[17:02:51.092]         else {
[17:02:51.092]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.092]         }
[17:02:51.092]         base::close(...future.stdout)
[17:02:51.092]         ...future.stdout <- NULL
[17:02:51.092]     }
[17:02:51.092]     ...future.result$conditions <- ...future.conditions
[17:02:51.092]     ...future.result$finished <- base::Sys.time()
[17:02:51.092]     ...future.result
[17:02:51.092] }
[17:02:51.093] assign_globals() ...
[17:02:51.093] List of 1
[17:02:51.093]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f64aa920> 
[17:02:51.093]  - attr(*, "where")=List of 1
[17:02:51.093]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.093]  - attr(*, "resolved")= logi TRUE
[17:02:51.093]  - attr(*, "total_size")= num 10592
[17:02:51.093]  - attr(*, "already-done")= logi TRUE
[17:02:51.096] - copied ‘a’ to environment
[17:02:51.096] assign_globals() ... done
[17:02:51.096] plan(): Setting new future strategy stack:
[17:02:51.096] List of future strategies:
[17:02:51.096] 1. sequential:
[17:02:51.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.096]    - tweaked: FALSE
[17:02:51.096]    - call: NULL
[17:02:51.097] plan(): nbrOfWorkers() = 1
[17:02:51.098] plan(): Setting new future strategy stack:
[17:02:51.098] List of future strategies:
[17:02:51.098] 1. sequential:
[17:02:51.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.098]    - tweaked: FALSE
[17:02:51.098]    - call: plan(strategy)
[17:02:51.098] plan(): nbrOfWorkers() = 1
[17:02:51.098] SequentialFuture started (and completed)
[17:02:51.098] - Launch lazy future ... done
[17:02:51.098] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.099] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.099] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.100] 
[17:02:51.100] Searching for globals ... DONE
[17:02:51.100] - globals: [0] <none>
[17:02:51.100] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.100] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.100] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.101] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.101] Searching for globals ... DONE
[17:02:51.101] Resolving globals: TRUE
[17:02:51.102] Resolving any globals that are futures ...
[17:02:51.102] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.102] Resolving any globals that are futures ... DONE
[17:02:51.102] Resolving futures part of globals (recursively) ...
[17:02:51.102] resolve() on list ...
[17:02:51.102]  recursive: 99
[17:02:51.102]  length: 1
[17:02:51.103]  elements: ‘a’
[17:02:51.103] run() for ‘Future’ ...
[17:02:51.103] - state: ‘created’
[17:02:51.103] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.103] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.103]   - Field: ‘label’
[17:02:51.104]   - Field: ‘local’
[17:02:51.104]   - Field: ‘owner’
[17:02:51.104]   - Field: ‘envir’
[17:02:51.104]   - Field: ‘packages’
[17:02:51.104]   - Field: ‘gc’
[17:02:51.104]   - Field: ‘conditions’
[17:02:51.104]   - Field: ‘expr’
[17:02:51.104]   - Field: ‘uuid’
[17:02:51.104]   - Field: ‘seed’
[17:02:51.104]   - Field: ‘version’
[17:02:51.104]   - Field: ‘result’
[17:02:51.105]   - Field: ‘asynchronous’
[17:02:51.105]   - Field: ‘calls’
[17:02:51.105]   - Field: ‘globals’
[17:02:51.105]   - Field: ‘stdout’
[17:02:51.105]   - Field: ‘earlySignal’
[17:02:51.105]   - Field: ‘lazy’
[17:02:51.105]   - Field: ‘state’
[17:02:51.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.105] - Launch lazy future ...
[17:02:51.105] Packages needed by the future expression (n = 0): <none>
[17:02:51.106] Packages needed by future strategies (n = 0): <none>
[17:02:51.106] {
[17:02:51.106]     {
[17:02:51.106]         {
[17:02:51.106]             ...future.startTime <- base::Sys.time()
[17:02:51.106]             {
[17:02:51.106]                 {
[17:02:51.106]                   {
[17:02:51.106]                     base::local({
[17:02:51.106]                       has_future <- base::requireNamespace("future", 
[17:02:51.106]                         quietly = TRUE)
[17:02:51.106]                       if (has_future) {
[17:02:51.106]                         ns <- base::getNamespace("future")
[17:02:51.106]                         version <- ns[[".package"]][["version"]]
[17:02:51.106]                         if (is.null(version)) 
[17:02:51.106]                           version <- utils::packageVersion("future")
[17:02:51.106]                       }
[17:02:51.106]                       else {
[17:02:51.106]                         version <- NULL
[17:02:51.106]                       }
[17:02:51.106]                       if (!has_future || version < "1.8.0") {
[17:02:51.106]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.106]                           "", base::R.version$version.string), 
[17:02:51.106]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.106]                             "release", "version")], collapse = " "), 
[17:02:51.106]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.106]                           info)
[17:02:51.106]                         info <- base::paste(info, collapse = "; ")
[17:02:51.106]                         if (!has_future) {
[17:02:51.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.106]                             info)
[17:02:51.106]                         }
[17:02:51.106]                         else {
[17:02:51.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.106]                             info, version)
[17:02:51.106]                         }
[17:02:51.106]                         base::stop(msg)
[17:02:51.106]                       }
[17:02:51.106]                     })
[17:02:51.106]                   }
[17:02:51.106]                   ...future.strategy.old <- future::plan("list")
[17:02:51.106]                   options(future.plan = NULL)
[17:02:51.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.106]                 }
[17:02:51.106]                 ...future.workdir <- getwd()
[17:02:51.106]             }
[17:02:51.106]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.106]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.106]         }
[17:02:51.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.106]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.106]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.106]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.106]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.106]             base::names(...future.oldOptions))
[17:02:51.106]     }
[17:02:51.106]     if (FALSE) {
[17:02:51.106]     }
[17:02:51.106]     else {
[17:02:51.106]         if (TRUE) {
[17:02:51.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.106]                 open = "w")
[17:02:51.106]         }
[17:02:51.106]         else {
[17:02:51.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.106]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.106]         }
[17:02:51.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.106]             base::sink(type = "output", split = FALSE)
[17:02:51.106]             base::close(...future.stdout)
[17:02:51.106]         }, add = TRUE)
[17:02:51.106]     }
[17:02:51.106]     ...future.frame <- base::sys.nframe()
[17:02:51.106]     ...future.conditions <- base::list()
[17:02:51.106]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.106]     if (FALSE) {
[17:02:51.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.106]     }
[17:02:51.106]     ...future.result <- base::tryCatch({
[17:02:51.106]         base::withCallingHandlers({
[17:02:51.106]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.106]             future::FutureResult(value = ...future.value$value, 
[17:02:51.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.106]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.106]                     ...future.globalenv.names))
[17:02:51.106]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.106]         }, condition = base::local({
[17:02:51.106]             c <- base::c
[17:02:51.106]             inherits <- base::inherits
[17:02:51.106]             invokeRestart <- base::invokeRestart
[17:02:51.106]             length <- base::length
[17:02:51.106]             list <- base::list
[17:02:51.106]             seq.int <- base::seq.int
[17:02:51.106]             signalCondition <- base::signalCondition
[17:02:51.106]             sys.calls <- base::sys.calls
[17:02:51.106]             `[[` <- base::`[[`
[17:02:51.106]             `+` <- base::`+`
[17:02:51.106]             `<<-` <- base::`<<-`
[17:02:51.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.106]                   3L)]
[17:02:51.106]             }
[17:02:51.106]             function(cond) {
[17:02:51.106]                 is_error <- inherits(cond, "error")
[17:02:51.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.106]                   NULL)
[17:02:51.106]                 if (is_error) {
[17:02:51.106]                   sessionInformation <- function() {
[17:02:51.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.106]                       search = base::search(), system = base::Sys.info())
[17:02:51.106]                   }
[17:02:51.106]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.106]                     cond$call), session = sessionInformation(), 
[17:02:51.106]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.106]                   signalCondition(cond)
[17:02:51.106]                 }
[17:02:51.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.106]                 "immediateCondition"))) {
[17:02:51.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.106]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.106]                   if (TRUE && !signal) {
[17:02:51.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.106]                     {
[17:02:51.106]                       inherits <- base::inherits
[17:02:51.106]                       invokeRestart <- base::invokeRestart
[17:02:51.106]                       is.null <- base::is.null
[17:02:51.106]                       muffled <- FALSE
[17:02:51.106]                       if (inherits(cond, "message")) {
[17:02:51.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.106]                         if (muffled) 
[17:02:51.106]                           invokeRestart("muffleMessage")
[17:02:51.106]                       }
[17:02:51.106]                       else if (inherits(cond, "warning")) {
[17:02:51.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.106]                         if (muffled) 
[17:02:51.106]                           invokeRestart("muffleWarning")
[17:02:51.106]                       }
[17:02:51.106]                       else if (inherits(cond, "condition")) {
[17:02:51.106]                         if (!is.null(pattern)) {
[17:02:51.106]                           computeRestarts <- base::computeRestarts
[17:02:51.106]                           grepl <- base::grepl
[17:02:51.106]                           restarts <- computeRestarts(cond)
[17:02:51.106]                           for (restart in restarts) {
[17:02:51.106]                             name <- restart$name
[17:02:51.106]                             if (is.null(name)) 
[17:02:51.106]                               next
[17:02:51.106]                             if (!grepl(pattern, name)) 
[17:02:51.106]                               next
[17:02:51.106]                             invokeRestart(restart)
[17:02:51.106]                             muffled <- TRUE
[17:02:51.106]                             break
[17:02:51.106]                           }
[17:02:51.106]                         }
[17:02:51.106]                       }
[17:02:51.106]                       invisible(muffled)
[17:02:51.106]                     }
[17:02:51.106]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.106]                   }
[17:02:51.106]                 }
[17:02:51.106]                 else {
[17:02:51.106]                   if (TRUE) {
[17:02:51.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.106]                     {
[17:02:51.106]                       inherits <- base::inherits
[17:02:51.106]                       invokeRestart <- base::invokeRestart
[17:02:51.106]                       is.null <- base::is.null
[17:02:51.106]                       muffled <- FALSE
[17:02:51.106]                       if (inherits(cond, "message")) {
[17:02:51.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.106]                         if (muffled) 
[17:02:51.106]                           invokeRestart("muffleMessage")
[17:02:51.106]                       }
[17:02:51.106]                       else if (inherits(cond, "warning")) {
[17:02:51.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.106]                         if (muffled) 
[17:02:51.106]                           invokeRestart("muffleWarning")
[17:02:51.106]                       }
[17:02:51.106]                       else if (inherits(cond, "condition")) {
[17:02:51.106]                         if (!is.null(pattern)) {
[17:02:51.106]                           computeRestarts <- base::computeRestarts
[17:02:51.106]                           grepl <- base::grepl
[17:02:51.106]                           restarts <- computeRestarts(cond)
[17:02:51.106]                           for (restart in restarts) {
[17:02:51.106]                             name <- restart$name
[17:02:51.106]                             if (is.null(name)) 
[17:02:51.106]                               next
[17:02:51.106]                             if (!grepl(pattern, name)) 
[17:02:51.106]                               next
[17:02:51.106]                             invokeRestart(restart)
[17:02:51.106]                             muffled <- TRUE
[17:02:51.106]                             break
[17:02:51.106]                           }
[17:02:51.106]                         }
[17:02:51.106]                       }
[17:02:51.106]                       invisible(muffled)
[17:02:51.106]                     }
[17:02:51.106]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.106]                   }
[17:02:51.106]                 }
[17:02:51.106]             }
[17:02:51.106]         }))
[17:02:51.106]     }, error = function(ex) {
[17:02:51.106]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.106]                 ...future.rng), started = ...future.startTime, 
[17:02:51.106]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.106]             version = "1.8"), class = "FutureResult")
[17:02:51.106]     }, finally = {
[17:02:51.106]         if (!identical(...future.workdir, getwd())) 
[17:02:51.106]             setwd(...future.workdir)
[17:02:51.106]         {
[17:02:51.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.106]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.106]             }
[17:02:51.106]             base::options(...future.oldOptions)
[17:02:51.106]             if (.Platform$OS.type == "windows") {
[17:02:51.106]                 old_names <- names(...future.oldEnvVars)
[17:02:51.106]                 envs <- base::Sys.getenv()
[17:02:51.106]                 names <- names(envs)
[17:02:51.106]                 common <- intersect(names, old_names)
[17:02:51.106]                 added <- setdiff(names, old_names)
[17:02:51.106]                 removed <- setdiff(old_names, names)
[17:02:51.106]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.106]                   envs[common]]
[17:02:51.106]                 NAMES <- toupper(changed)
[17:02:51.106]                 args <- list()
[17:02:51.106]                 for (kk in seq_along(NAMES)) {
[17:02:51.106]                   name <- changed[[kk]]
[17:02:51.106]                   NAME <- NAMES[[kk]]
[17:02:51.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.106]                     next
[17:02:51.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.106]                 }
[17:02:51.106]                 NAMES <- toupper(added)
[17:02:51.106]                 for (kk in seq_along(NAMES)) {
[17:02:51.106]                   name <- added[[kk]]
[17:02:51.106]                   NAME <- NAMES[[kk]]
[17:02:51.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.106]                     next
[17:02:51.106]                   args[[name]] <- ""
[17:02:51.106]                 }
[17:02:51.106]                 NAMES <- toupper(removed)
[17:02:51.106]                 for (kk in seq_along(NAMES)) {
[17:02:51.106]                   name <- removed[[kk]]
[17:02:51.106]                   NAME <- NAMES[[kk]]
[17:02:51.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.106]                     next
[17:02:51.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.106]                 }
[17:02:51.106]                 if (length(args) > 0) 
[17:02:51.106]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.106]             }
[17:02:51.106]             else {
[17:02:51.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.106]             }
[17:02:51.106]             {
[17:02:51.106]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.106]                   0L) {
[17:02:51.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.106]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.106]                   base::options(opts)
[17:02:51.106]                 }
[17:02:51.106]                 {
[17:02:51.106]                   {
[17:02:51.106]                     NULL
[17:02:51.106]                     RNGkind("Mersenne-Twister")
[17:02:51.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.106]                       inherits = FALSE)
[17:02:51.106]                   }
[17:02:51.106]                   options(future.plan = NULL)
[17:02:51.106]                   if (is.na(NA_character_)) 
[17:02:51.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.106]                     .init = FALSE)
[17:02:51.106]                 }
[17:02:51.106]             }
[17:02:51.106]         }
[17:02:51.106]     })
[17:02:51.106]     if (TRUE) {
[17:02:51.106]         base::sink(type = "output", split = FALSE)
[17:02:51.106]         if (TRUE) {
[17:02:51.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.106]         }
[17:02:51.106]         else {
[17:02:51.106]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.106]         }
[17:02:51.106]         base::close(...future.stdout)
[17:02:51.106]         ...future.stdout <- NULL
[17:02:51.106]     }
[17:02:51.106]     ...future.result$conditions <- ...future.conditions
[17:02:51.106]     ...future.result$finished <- base::Sys.time()
[17:02:51.106]     ...future.result
[17:02:51.106] }
[17:02:51.108] plan(): Setting new future strategy stack:
[17:02:51.108] List of future strategies:
[17:02:51.108] 1. sequential:
[17:02:51.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.108]    - tweaked: FALSE
[17:02:51.108]    - call: NULL
[17:02:51.108] plan(): nbrOfWorkers() = 1
[17:02:51.109] plan(): Setting new future strategy stack:
[17:02:51.109] List of future strategies:
[17:02:51.109] 1. sequential:
[17:02:51.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.109]    - tweaked: FALSE
[17:02:51.109]    - call: plan(strategy)
[17:02:51.109] plan(): nbrOfWorkers() = 1
[17:02:51.110] SequentialFuture started (and completed)
[17:02:51.110] - Launch lazy future ... done
[17:02:51.110] run() for ‘SequentialFuture’ ... done
[17:02:51.110] resolved() for ‘SequentialFuture’ ...
[17:02:51.110] - state: ‘finished’
[17:02:51.110] - run: TRUE
[17:02:51.110] - result: ‘FutureResult’
[17:02:51.110] resolved() for ‘SequentialFuture’ ... done
[17:02:51.110] Future #1
[17:02:51.111] resolved() for ‘SequentialFuture’ ...
[17:02:51.111] - state: ‘finished’
[17:02:51.111] - run: TRUE
[17:02:51.111] - result: ‘FutureResult’
[17:02:51.111] resolved() for ‘SequentialFuture’ ... done
[17:02:51.111] A SequentialFuture was resolved
[17:02:51.111]  length: 0 (resolved future 1)
[17:02:51.111] resolve() on list ... DONE
[17:02:51.111] - globals: [1] ‘a’
[17:02:51.111] Resolving futures part of globals (recursively) ... DONE
[17:02:51.112] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:02:51.112] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:02:51.113] - globals: [1] ‘a’
[17:02:51.113] - packages: [1] ‘future’
[17:02:51.113] getGlobalsAndPackages() ... DONE
[17:02:51.113] run() for ‘Future’ ...
[17:02:51.113] - state: ‘created’
[17:02:51.113] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.114] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.114]   - Field: ‘label’
[17:02:51.114]   - Field: ‘local’
[17:02:51.114]   - Field: ‘owner’
[17:02:51.114]   - Field: ‘envir’
[17:02:51.114]   - Field: ‘packages’
[17:02:51.114]   - Field: ‘gc’
[17:02:51.114]   - Field: ‘conditions’
[17:02:51.114]   - Field: ‘expr’
[17:02:51.115]   - Field: ‘uuid’
[17:02:51.115]   - Field: ‘seed’
[17:02:51.115]   - Field: ‘version’
[17:02:51.115]   - Field: ‘result’
[17:02:51.115]   - Field: ‘asynchronous’
[17:02:51.115]   - Field: ‘calls’
[17:02:51.115]   - Field: ‘globals’
[17:02:51.115]   - Field: ‘stdout’
[17:02:51.115]   - Field: ‘earlySignal’
[17:02:51.115]   - Field: ‘lazy’
[17:02:51.115]   - Field: ‘state’
[17:02:51.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.116] - Launch lazy future ...
[17:02:51.116] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.116] Packages needed by future strategies (n = 0): <none>
[17:02:51.118] {
[17:02:51.118]     {
[17:02:51.118]         {
[17:02:51.118]             ...future.startTime <- base::Sys.time()
[17:02:51.118]             {
[17:02:51.118]                 {
[17:02:51.118]                   {
[17:02:51.118]                     {
[17:02:51.118]                       base::local({
[17:02:51.118]                         has_future <- base::requireNamespace("future", 
[17:02:51.118]                           quietly = TRUE)
[17:02:51.118]                         if (has_future) {
[17:02:51.118]                           ns <- base::getNamespace("future")
[17:02:51.118]                           version <- ns[[".package"]][["version"]]
[17:02:51.118]                           if (is.null(version)) 
[17:02:51.118]                             version <- utils::packageVersion("future")
[17:02:51.118]                         }
[17:02:51.118]                         else {
[17:02:51.118]                           version <- NULL
[17:02:51.118]                         }
[17:02:51.118]                         if (!has_future || version < "1.8.0") {
[17:02:51.118]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.118]                             "", base::R.version$version.string), 
[17:02:51.118]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.118]                               "release", "version")], collapse = " "), 
[17:02:51.118]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.118]                             info)
[17:02:51.118]                           info <- base::paste(info, collapse = "; ")
[17:02:51.118]                           if (!has_future) {
[17:02:51.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.118]                               info)
[17:02:51.118]                           }
[17:02:51.118]                           else {
[17:02:51.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.118]                               info, version)
[17:02:51.118]                           }
[17:02:51.118]                           base::stop(msg)
[17:02:51.118]                         }
[17:02:51.118]                       })
[17:02:51.118]                     }
[17:02:51.118]                     base::local({
[17:02:51.118]                       for (pkg in "future") {
[17:02:51.118]                         base::loadNamespace(pkg)
[17:02:51.118]                         base::library(pkg, character.only = TRUE)
[17:02:51.118]                       }
[17:02:51.118]                     })
[17:02:51.118]                   }
[17:02:51.118]                   ...future.strategy.old <- future::plan("list")
[17:02:51.118]                   options(future.plan = NULL)
[17:02:51.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.118]                 }
[17:02:51.118]                 ...future.workdir <- getwd()
[17:02:51.118]             }
[17:02:51.118]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.118]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.118]         }
[17:02:51.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.118]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.118]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.118]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.118]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.118]             base::names(...future.oldOptions))
[17:02:51.118]     }
[17:02:51.118]     if (FALSE) {
[17:02:51.118]     }
[17:02:51.118]     else {
[17:02:51.118]         if (TRUE) {
[17:02:51.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.118]                 open = "w")
[17:02:51.118]         }
[17:02:51.118]         else {
[17:02:51.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.118]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.118]         }
[17:02:51.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.118]             base::sink(type = "output", split = FALSE)
[17:02:51.118]             base::close(...future.stdout)
[17:02:51.118]         }, add = TRUE)
[17:02:51.118]     }
[17:02:51.118]     ...future.frame <- base::sys.nframe()
[17:02:51.118]     ...future.conditions <- base::list()
[17:02:51.118]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.118]     if (FALSE) {
[17:02:51.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.118]     }
[17:02:51.118]     ...future.result <- base::tryCatch({
[17:02:51.118]         base::withCallingHandlers({
[17:02:51.118]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.118]                 1))
[17:02:51.118]             future::FutureResult(value = ...future.value$value, 
[17:02:51.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.118]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.118]                     ...future.globalenv.names))
[17:02:51.118]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.118]         }, condition = base::local({
[17:02:51.118]             c <- base::c
[17:02:51.118]             inherits <- base::inherits
[17:02:51.118]             invokeRestart <- base::invokeRestart
[17:02:51.118]             length <- base::length
[17:02:51.118]             list <- base::list
[17:02:51.118]             seq.int <- base::seq.int
[17:02:51.118]             signalCondition <- base::signalCondition
[17:02:51.118]             sys.calls <- base::sys.calls
[17:02:51.118]             `[[` <- base::`[[`
[17:02:51.118]             `+` <- base::`+`
[17:02:51.118]             `<<-` <- base::`<<-`
[17:02:51.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.118]                   3L)]
[17:02:51.118]             }
[17:02:51.118]             function(cond) {
[17:02:51.118]                 is_error <- inherits(cond, "error")
[17:02:51.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.118]                   NULL)
[17:02:51.118]                 if (is_error) {
[17:02:51.118]                   sessionInformation <- function() {
[17:02:51.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.118]                       search = base::search(), system = base::Sys.info())
[17:02:51.118]                   }
[17:02:51.118]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.118]                     cond$call), session = sessionInformation(), 
[17:02:51.118]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.118]                   signalCondition(cond)
[17:02:51.118]                 }
[17:02:51.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.118]                 "immediateCondition"))) {
[17:02:51.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.118]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.118]                   if (TRUE && !signal) {
[17:02:51.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.118]                     {
[17:02:51.118]                       inherits <- base::inherits
[17:02:51.118]                       invokeRestart <- base::invokeRestart
[17:02:51.118]                       is.null <- base::is.null
[17:02:51.118]                       muffled <- FALSE
[17:02:51.118]                       if (inherits(cond, "message")) {
[17:02:51.118]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.118]                         if (muffled) 
[17:02:51.118]                           invokeRestart("muffleMessage")
[17:02:51.118]                       }
[17:02:51.118]                       else if (inherits(cond, "warning")) {
[17:02:51.118]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.118]                         if (muffled) 
[17:02:51.118]                           invokeRestart("muffleWarning")
[17:02:51.118]                       }
[17:02:51.118]                       else if (inherits(cond, "condition")) {
[17:02:51.118]                         if (!is.null(pattern)) {
[17:02:51.118]                           computeRestarts <- base::computeRestarts
[17:02:51.118]                           grepl <- base::grepl
[17:02:51.118]                           restarts <- computeRestarts(cond)
[17:02:51.118]                           for (restart in restarts) {
[17:02:51.118]                             name <- restart$name
[17:02:51.118]                             if (is.null(name)) 
[17:02:51.118]                               next
[17:02:51.118]                             if (!grepl(pattern, name)) 
[17:02:51.118]                               next
[17:02:51.118]                             invokeRestart(restart)
[17:02:51.118]                             muffled <- TRUE
[17:02:51.118]                             break
[17:02:51.118]                           }
[17:02:51.118]                         }
[17:02:51.118]                       }
[17:02:51.118]                       invisible(muffled)
[17:02:51.118]                     }
[17:02:51.118]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.118]                   }
[17:02:51.118]                 }
[17:02:51.118]                 else {
[17:02:51.118]                   if (TRUE) {
[17:02:51.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.118]                     {
[17:02:51.118]                       inherits <- base::inherits
[17:02:51.118]                       invokeRestart <- base::invokeRestart
[17:02:51.118]                       is.null <- base::is.null
[17:02:51.118]                       muffled <- FALSE
[17:02:51.118]                       if (inherits(cond, "message")) {
[17:02:51.118]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.118]                         if (muffled) 
[17:02:51.118]                           invokeRestart("muffleMessage")
[17:02:51.118]                       }
[17:02:51.118]                       else if (inherits(cond, "warning")) {
[17:02:51.118]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.118]                         if (muffled) 
[17:02:51.118]                           invokeRestart("muffleWarning")
[17:02:51.118]                       }
[17:02:51.118]                       else if (inherits(cond, "condition")) {
[17:02:51.118]                         if (!is.null(pattern)) {
[17:02:51.118]                           computeRestarts <- base::computeRestarts
[17:02:51.118]                           grepl <- base::grepl
[17:02:51.118]                           restarts <- computeRestarts(cond)
[17:02:51.118]                           for (restart in restarts) {
[17:02:51.118]                             name <- restart$name
[17:02:51.118]                             if (is.null(name)) 
[17:02:51.118]                               next
[17:02:51.118]                             if (!grepl(pattern, name)) 
[17:02:51.118]                               next
[17:02:51.118]                             invokeRestart(restart)
[17:02:51.118]                             muffled <- TRUE
[17:02:51.118]                             break
[17:02:51.118]                           }
[17:02:51.118]                         }
[17:02:51.118]                       }
[17:02:51.118]                       invisible(muffled)
[17:02:51.118]                     }
[17:02:51.118]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.118]                   }
[17:02:51.118]                 }
[17:02:51.118]             }
[17:02:51.118]         }))
[17:02:51.118]     }, error = function(ex) {
[17:02:51.118]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.118]                 ...future.rng), started = ...future.startTime, 
[17:02:51.118]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.118]             version = "1.8"), class = "FutureResult")
[17:02:51.118]     }, finally = {
[17:02:51.118]         if (!identical(...future.workdir, getwd())) 
[17:02:51.118]             setwd(...future.workdir)
[17:02:51.118]         {
[17:02:51.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.118]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.118]             }
[17:02:51.118]             base::options(...future.oldOptions)
[17:02:51.118]             if (.Platform$OS.type == "windows") {
[17:02:51.118]                 old_names <- names(...future.oldEnvVars)
[17:02:51.118]                 envs <- base::Sys.getenv()
[17:02:51.118]                 names <- names(envs)
[17:02:51.118]                 common <- intersect(names, old_names)
[17:02:51.118]                 added <- setdiff(names, old_names)
[17:02:51.118]                 removed <- setdiff(old_names, names)
[17:02:51.118]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.118]                   envs[common]]
[17:02:51.118]                 NAMES <- toupper(changed)
[17:02:51.118]                 args <- list()
[17:02:51.118]                 for (kk in seq_along(NAMES)) {
[17:02:51.118]                   name <- changed[[kk]]
[17:02:51.118]                   NAME <- NAMES[[kk]]
[17:02:51.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.118]                     next
[17:02:51.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.118]                 }
[17:02:51.118]                 NAMES <- toupper(added)
[17:02:51.118]                 for (kk in seq_along(NAMES)) {
[17:02:51.118]                   name <- added[[kk]]
[17:02:51.118]                   NAME <- NAMES[[kk]]
[17:02:51.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.118]                     next
[17:02:51.118]                   args[[name]] <- ""
[17:02:51.118]                 }
[17:02:51.118]                 NAMES <- toupper(removed)
[17:02:51.118]                 for (kk in seq_along(NAMES)) {
[17:02:51.118]                   name <- removed[[kk]]
[17:02:51.118]                   NAME <- NAMES[[kk]]
[17:02:51.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.118]                     next
[17:02:51.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.118]                 }
[17:02:51.118]                 if (length(args) > 0) 
[17:02:51.118]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.118]             }
[17:02:51.118]             else {
[17:02:51.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.118]             }
[17:02:51.118]             {
[17:02:51.118]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.118]                   0L) {
[17:02:51.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.118]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.118]                   base::options(opts)
[17:02:51.118]                 }
[17:02:51.118]                 {
[17:02:51.118]                   {
[17:02:51.118]                     NULL
[17:02:51.118]                     RNGkind("Mersenne-Twister")
[17:02:51.118]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.118]                       inherits = FALSE)
[17:02:51.118]                   }
[17:02:51.118]                   options(future.plan = NULL)
[17:02:51.118]                   if (is.na(NA_character_)) 
[17:02:51.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.118]                     .init = FALSE)
[17:02:51.118]                 }
[17:02:51.118]             }
[17:02:51.118]         }
[17:02:51.118]     })
[17:02:51.118]     if (TRUE) {
[17:02:51.118]         base::sink(type = "output", split = FALSE)
[17:02:51.118]         if (TRUE) {
[17:02:51.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.118]         }
[17:02:51.118]         else {
[17:02:51.118]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.118]         }
[17:02:51.118]         base::close(...future.stdout)
[17:02:51.118]         ...future.stdout <- NULL
[17:02:51.118]     }
[17:02:51.118]     ...future.result$conditions <- ...future.conditions
[17:02:51.118]     ...future.result$finished <- base::Sys.time()
[17:02:51.118]     ...future.result
[17:02:51.118] }
[17:02:51.120] assign_globals() ...
[17:02:51.120] List of 1
[17:02:51.120]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f61cb1d8> 
[17:02:51.120]  - attr(*, "where")=List of 1
[17:02:51.120]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.120]  - attr(*, "resolved")= logi TRUE
[17:02:51.120]  - attr(*, "total_size")= num 10592
[17:02:51.120]  - attr(*, "already-done")= logi TRUE
[17:02:51.122] - copied ‘a’ to environment
[17:02:51.122] assign_globals() ... done
[17:02:51.123] plan(): Setting new future strategy stack:
[17:02:51.123] List of future strategies:
[17:02:51.123] 1. sequential:
[17:02:51.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.123]    - tweaked: FALSE
[17:02:51.123]    - call: NULL
[17:02:51.123] plan(): nbrOfWorkers() = 1
[17:02:51.124] plan(): Setting new future strategy stack:
[17:02:51.124] List of future strategies:
[17:02:51.124] 1. sequential:
[17:02:51.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.124]    - tweaked: FALSE
[17:02:51.124]    - call: plan(strategy)
[17:02:51.125] plan(): nbrOfWorkers() = 1
[17:02:51.125] SequentialFuture started (and completed)
[17:02:51.125] - Launch lazy future ... done
[17:02:51.125] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.125] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.126] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.126] - globals found: [2] ‘{’, ‘pkg’
[17:02:51.126] Searching for globals ... DONE
[17:02:51.127] Resolving globals: TRUE
[17:02:51.127] Resolving any globals that are futures ...
[17:02:51.127] - globals: [2] ‘{’, ‘pkg’
[17:02:51.127] Resolving any globals that are futures ... DONE
[17:02:51.127] Resolving futures part of globals (recursively) ...
[17:02:51.127] resolve() on list ...
[17:02:51.127]  recursive: 99
[17:02:51.128]  length: 1
[17:02:51.128]  elements: ‘pkg’
[17:02:51.128]  length: 0 (resolved future 1)
[17:02:51.128] resolve() on list ... DONE
[17:02:51.128] - globals: [1] ‘pkg’
[17:02:51.128] Resolving futures part of globals (recursively) ... DONE
[17:02:51.128] The total size of the 1 globals is 112 bytes (112 bytes)
[17:02:51.129] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:02:51.129] - globals: [1] ‘pkg’
[17:02:51.129] 
[17:02:51.129] getGlobalsAndPackages() ... DONE
[17:02:51.129] Packages needed by the future expression (n = 0): <none>
[17:02:51.129] Packages needed by future strategies (n = 0): <none>
[17:02:51.130] {
[17:02:51.130]     {
[17:02:51.130]         {
[17:02:51.130]             ...future.startTime <- base::Sys.time()
[17:02:51.130]             {
[17:02:51.130]                 {
[17:02:51.130]                   {
[17:02:51.130]                     base::local({
[17:02:51.130]                       has_future <- base::requireNamespace("future", 
[17:02:51.130]                         quietly = TRUE)
[17:02:51.130]                       if (has_future) {
[17:02:51.130]                         ns <- base::getNamespace("future")
[17:02:51.130]                         version <- ns[[".package"]][["version"]]
[17:02:51.130]                         if (is.null(version)) 
[17:02:51.130]                           version <- utils::packageVersion("future")
[17:02:51.130]                       }
[17:02:51.130]                       else {
[17:02:51.130]                         version <- NULL
[17:02:51.130]                       }
[17:02:51.130]                       if (!has_future || version < "1.8.0") {
[17:02:51.130]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.130]                           "", base::R.version$version.string), 
[17:02:51.130]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.130]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.130]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.130]                             "release", "version")], collapse = " "), 
[17:02:51.130]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.130]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.130]                           info)
[17:02:51.130]                         info <- base::paste(info, collapse = "; ")
[17:02:51.130]                         if (!has_future) {
[17:02:51.130]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.130]                             info)
[17:02:51.130]                         }
[17:02:51.130]                         else {
[17:02:51.130]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.130]                             info, version)
[17:02:51.130]                         }
[17:02:51.130]                         base::stop(msg)
[17:02:51.130]                       }
[17:02:51.130]                     })
[17:02:51.130]                   }
[17:02:51.130]                   ...future.strategy.old <- future::plan("list")
[17:02:51.130]                   options(future.plan = NULL)
[17:02:51.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.130]                 }
[17:02:51.130]                 ...future.workdir <- getwd()
[17:02:51.130]             }
[17:02:51.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.130]         }
[17:02:51.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.130]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.130]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.130]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.130]             base::names(...future.oldOptions))
[17:02:51.130]     }
[17:02:51.130]     if (FALSE) {
[17:02:51.130]     }
[17:02:51.130]     else {
[17:02:51.130]         if (TRUE) {
[17:02:51.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.130]                 open = "w")
[17:02:51.130]         }
[17:02:51.130]         else {
[17:02:51.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.130]         }
[17:02:51.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.130]             base::sink(type = "output", split = FALSE)
[17:02:51.130]             base::close(...future.stdout)
[17:02:51.130]         }, add = TRUE)
[17:02:51.130]     }
[17:02:51.130]     ...future.frame <- base::sys.nframe()
[17:02:51.130]     ...future.conditions <- base::list()
[17:02:51.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.130]     if (FALSE) {
[17:02:51.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.130]     }
[17:02:51.130]     ...future.result <- base::tryCatch({
[17:02:51.130]         base::withCallingHandlers({
[17:02:51.130]             ...future.value <- base::withVisible(base::local({
[17:02:51.130]                 pkg
[17:02:51.130]             }))
[17:02:51.130]             future::FutureResult(value = ...future.value$value, 
[17:02:51.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.130]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.130]                     ...future.globalenv.names))
[17:02:51.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.130]         }, condition = base::local({
[17:02:51.130]             c <- base::c
[17:02:51.130]             inherits <- base::inherits
[17:02:51.130]             invokeRestart <- base::invokeRestart
[17:02:51.130]             length <- base::length
[17:02:51.130]             list <- base::list
[17:02:51.130]             seq.int <- base::seq.int
[17:02:51.130]             signalCondition <- base::signalCondition
[17:02:51.130]             sys.calls <- base::sys.calls
[17:02:51.130]             `[[` <- base::`[[`
[17:02:51.130]             `+` <- base::`+`
[17:02:51.130]             `<<-` <- base::`<<-`
[17:02:51.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.130]                   3L)]
[17:02:51.130]             }
[17:02:51.130]             function(cond) {
[17:02:51.130]                 is_error <- inherits(cond, "error")
[17:02:51.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.130]                   NULL)
[17:02:51.130]                 if (is_error) {
[17:02:51.130]                   sessionInformation <- function() {
[17:02:51.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.130]                       search = base::search(), system = base::Sys.info())
[17:02:51.130]                   }
[17:02:51.130]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.130]                     cond$call), session = sessionInformation(), 
[17:02:51.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.130]                   signalCondition(cond)
[17:02:51.130]                 }
[17:02:51.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.130]                 "immediateCondition"))) {
[17:02:51.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.130]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.130]                   if (TRUE && !signal) {
[17:02:51.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.130]                     {
[17:02:51.130]                       inherits <- base::inherits
[17:02:51.130]                       invokeRestart <- base::invokeRestart
[17:02:51.130]                       is.null <- base::is.null
[17:02:51.130]                       muffled <- FALSE
[17:02:51.130]                       if (inherits(cond, "message")) {
[17:02:51.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.130]                         if (muffled) 
[17:02:51.130]                           invokeRestart("muffleMessage")
[17:02:51.130]                       }
[17:02:51.130]                       else if (inherits(cond, "warning")) {
[17:02:51.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.130]                         if (muffled) 
[17:02:51.130]                           invokeRestart("muffleWarning")
[17:02:51.130]                       }
[17:02:51.130]                       else if (inherits(cond, "condition")) {
[17:02:51.130]                         if (!is.null(pattern)) {
[17:02:51.130]                           computeRestarts <- base::computeRestarts
[17:02:51.130]                           grepl <- base::grepl
[17:02:51.130]                           restarts <- computeRestarts(cond)
[17:02:51.130]                           for (restart in restarts) {
[17:02:51.130]                             name <- restart$name
[17:02:51.130]                             if (is.null(name)) 
[17:02:51.130]                               next
[17:02:51.130]                             if (!grepl(pattern, name)) 
[17:02:51.130]                               next
[17:02:51.130]                             invokeRestart(restart)
[17:02:51.130]                             muffled <- TRUE
[17:02:51.130]                             break
[17:02:51.130]                           }
[17:02:51.130]                         }
[17:02:51.130]                       }
[17:02:51.130]                       invisible(muffled)
[17:02:51.130]                     }
[17:02:51.130]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.130]                   }
[17:02:51.130]                 }
[17:02:51.130]                 else {
[17:02:51.130]                   if (TRUE) {
[17:02:51.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.130]                     {
[17:02:51.130]                       inherits <- base::inherits
[17:02:51.130]                       invokeRestart <- base::invokeRestart
[17:02:51.130]                       is.null <- base::is.null
[17:02:51.130]                       muffled <- FALSE
[17:02:51.130]                       if (inherits(cond, "message")) {
[17:02:51.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.130]                         if (muffled) 
[17:02:51.130]                           invokeRestart("muffleMessage")
[17:02:51.130]                       }
[17:02:51.130]                       else if (inherits(cond, "warning")) {
[17:02:51.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.130]                         if (muffled) 
[17:02:51.130]                           invokeRestart("muffleWarning")
[17:02:51.130]                       }
[17:02:51.130]                       else if (inherits(cond, "condition")) {
[17:02:51.130]                         if (!is.null(pattern)) {
[17:02:51.130]                           computeRestarts <- base::computeRestarts
[17:02:51.130]                           grepl <- base::grepl
[17:02:51.130]                           restarts <- computeRestarts(cond)
[17:02:51.130]                           for (restart in restarts) {
[17:02:51.130]                             name <- restart$name
[17:02:51.130]                             if (is.null(name)) 
[17:02:51.130]                               next
[17:02:51.130]                             if (!grepl(pattern, name)) 
[17:02:51.130]                               next
[17:02:51.130]                             invokeRestart(restart)
[17:02:51.130]                             muffled <- TRUE
[17:02:51.130]                             break
[17:02:51.130]                           }
[17:02:51.130]                         }
[17:02:51.130]                       }
[17:02:51.130]                       invisible(muffled)
[17:02:51.130]                     }
[17:02:51.130]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.130]                   }
[17:02:51.130]                 }
[17:02:51.130]             }
[17:02:51.130]         }))
[17:02:51.130]     }, error = function(ex) {
[17:02:51.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.130]                 ...future.rng), started = ...future.startTime, 
[17:02:51.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.130]             version = "1.8"), class = "FutureResult")
[17:02:51.130]     }, finally = {
[17:02:51.130]         if (!identical(...future.workdir, getwd())) 
[17:02:51.130]             setwd(...future.workdir)
[17:02:51.130]         {
[17:02:51.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.130]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.130]             }
[17:02:51.130]             base::options(...future.oldOptions)
[17:02:51.130]             if (.Platform$OS.type == "windows") {
[17:02:51.130]                 old_names <- names(...future.oldEnvVars)
[17:02:51.130]                 envs <- base::Sys.getenv()
[17:02:51.130]                 names <- names(envs)
[17:02:51.130]                 common <- intersect(names, old_names)
[17:02:51.130]                 added <- setdiff(names, old_names)
[17:02:51.130]                 removed <- setdiff(old_names, names)
[17:02:51.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.130]                   envs[common]]
[17:02:51.130]                 NAMES <- toupper(changed)
[17:02:51.130]                 args <- list()
[17:02:51.130]                 for (kk in seq_along(NAMES)) {
[17:02:51.130]                   name <- changed[[kk]]
[17:02:51.130]                   NAME <- NAMES[[kk]]
[17:02:51.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.130]                     next
[17:02:51.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.130]                 }
[17:02:51.130]                 NAMES <- toupper(added)
[17:02:51.130]                 for (kk in seq_along(NAMES)) {
[17:02:51.130]                   name <- added[[kk]]
[17:02:51.130]                   NAME <- NAMES[[kk]]
[17:02:51.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.130]                     next
[17:02:51.130]                   args[[name]] <- ""
[17:02:51.130]                 }
[17:02:51.130]                 NAMES <- toupper(removed)
[17:02:51.130]                 for (kk in seq_along(NAMES)) {
[17:02:51.130]                   name <- removed[[kk]]
[17:02:51.130]                   NAME <- NAMES[[kk]]
[17:02:51.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.130]                     next
[17:02:51.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.130]                 }
[17:02:51.130]                 if (length(args) > 0) 
[17:02:51.130]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.130]             }
[17:02:51.130]             else {
[17:02:51.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.130]             }
[17:02:51.130]             {
[17:02:51.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.130]                   0L) {
[17:02:51.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.130]                   base::options(opts)
[17:02:51.130]                 }
[17:02:51.130]                 {
[17:02:51.130]                   {
[17:02:51.130]                     NULL
[17:02:51.130]                     RNGkind("Mersenne-Twister")
[17:02:51.130]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.130]                       inherits = FALSE)
[17:02:51.130]                   }
[17:02:51.130]                   options(future.plan = NULL)
[17:02:51.130]                   if (is.na(NA_character_)) 
[17:02:51.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.130]                     .init = FALSE)
[17:02:51.130]                 }
[17:02:51.130]             }
[17:02:51.130]         }
[17:02:51.130]     })
[17:02:51.130]     if (TRUE) {
[17:02:51.130]         base::sink(type = "output", split = FALSE)
[17:02:51.130]         if (TRUE) {
[17:02:51.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.130]         }
[17:02:51.130]         else {
[17:02:51.130]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.130]         }
[17:02:51.130]         base::close(...future.stdout)
[17:02:51.130]         ...future.stdout <- NULL
[17:02:51.130]     }
[17:02:51.130]     ...future.result$conditions <- ...future.conditions
[17:02:51.130]     ...future.result$finished <- base::Sys.time()
[17:02:51.130]     ...future.result
[17:02:51.130] }
[17:02:51.131] assign_globals() ...
[17:02:51.131] List of 1
[17:02:51.131]  $ pkg: chr "foo"
[17:02:51.131]  - attr(*, "where")=List of 1
[17:02:51.131]   ..$ pkg:<environment: R_EmptyEnv> 
[17:02:51.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.131]  - attr(*, "resolved")= logi TRUE
[17:02:51.131]  - attr(*, "total_size")= num 112
[17:02:51.133] - copied ‘pkg’ to environment
[17:02:51.133] assign_globals() ... done
[17:02:51.134] plan(): Setting new future strategy stack:
[17:02:51.134] List of future strategies:
[17:02:51.134] 1. sequential:
[17:02:51.134]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.134]    - tweaked: FALSE
[17:02:51.134]    - call: NULL
[17:02:51.134] plan(): nbrOfWorkers() = 1
[17:02:51.135] plan(): Setting new future strategy stack:
[17:02:51.135] List of future strategies:
[17:02:51.135] 1. sequential:
[17:02:51.135]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.135]    - tweaked: FALSE
[17:02:51.135]    - call: plan(strategy)
[17:02:51.135] plan(): nbrOfWorkers() = 1
[17:02:51.136] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.136] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.137] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.139] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:51.139] Searching for globals ... DONE
[17:02:51.139] Resolving globals: TRUE
[17:02:51.139] Resolving any globals that are futures ...
[17:02:51.139] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:51.139] Resolving any globals that are futures ... DONE
[17:02:51.140] Resolving futures part of globals (recursively) ...
[17:02:51.140] resolve() on list ...
[17:02:51.140]  recursive: 99
[17:02:51.140]  length: 1
[17:02:51.140]  elements: ‘a’
[17:02:51.140]  length: 0 (resolved future 1)
[17:02:51.140] resolve() on list ... DONE
[17:02:51.140] - globals: [1] ‘a’
[17:02:51.140] Resolving futures part of globals (recursively) ... DONE
[17:02:51.141] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.141] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:02:51.141] - globals: [1] ‘a’
[17:02:51.141] 
[17:02:51.141] getGlobalsAndPackages() ... DONE
[17:02:51.141] run() for ‘Future’ ...
[17:02:51.142] - state: ‘created’
[17:02:51.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.142] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.142] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.142]   - Field: ‘label’
[17:02:51.142]   - Field: ‘local’
[17:02:51.142]   - Field: ‘owner’
[17:02:51.142]   - Field: ‘envir’
[17:02:51.143]   - Field: ‘packages’
[17:02:51.143]   - Field: ‘gc’
[17:02:51.143]   - Field: ‘conditions’
[17:02:51.143]   - Field: ‘expr’
[17:02:51.143]   - Field: ‘uuid’
[17:02:51.143]   - Field: ‘seed’
[17:02:51.143]   - Field: ‘version’
[17:02:51.143]   - Field: ‘result’
[17:02:51.143]   - Field: ‘asynchronous’
[17:02:51.143]   - Field: ‘calls’
[17:02:51.144]   - Field: ‘globals’
[17:02:51.144]   - Field: ‘stdout’
[17:02:51.144]   - Field: ‘earlySignal’
[17:02:51.144]   - Field: ‘lazy’
[17:02:51.144]   - Field: ‘state’
[17:02:51.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.144] - Launch lazy future ...
[17:02:51.144] Packages needed by the future expression (n = 0): <none>
[17:02:51.144] Packages needed by future strategies (n = 0): <none>
[17:02:51.145] {
[17:02:51.145]     {
[17:02:51.145]         {
[17:02:51.145]             ...future.startTime <- base::Sys.time()
[17:02:51.145]             {
[17:02:51.145]                 {
[17:02:51.145]                   {
[17:02:51.145]                     base::local({
[17:02:51.145]                       has_future <- base::requireNamespace("future", 
[17:02:51.145]                         quietly = TRUE)
[17:02:51.145]                       if (has_future) {
[17:02:51.145]                         ns <- base::getNamespace("future")
[17:02:51.145]                         version <- ns[[".package"]][["version"]]
[17:02:51.145]                         if (is.null(version)) 
[17:02:51.145]                           version <- utils::packageVersion("future")
[17:02:51.145]                       }
[17:02:51.145]                       else {
[17:02:51.145]                         version <- NULL
[17:02:51.145]                       }
[17:02:51.145]                       if (!has_future || version < "1.8.0") {
[17:02:51.145]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.145]                           "", base::R.version$version.string), 
[17:02:51.145]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.145]                             "release", "version")], collapse = " "), 
[17:02:51.145]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.145]                           info)
[17:02:51.145]                         info <- base::paste(info, collapse = "; ")
[17:02:51.145]                         if (!has_future) {
[17:02:51.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.145]                             info)
[17:02:51.145]                         }
[17:02:51.145]                         else {
[17:02:51.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.145]                             info, version)
[17:02:51.145]                         }
[17:02:51.145]                         base::stop(msg)
[17:02:51.145]                       }
[17:02:51.145]                     })
[17:02:51.145]                   }
[17:02:51.145]                   ...future.strategy.old <- future::plan("list")
[17:02:51.145]                   options(future.plan = NULL)
[17:02:51.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.145]                 }
[17:02:51.145]                 ...future.workdir <- getwd()
[17:02:51.145]             }
[17:02:51.145]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.145]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.145]         }
[17:02:51.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.145]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.145]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.145]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.145]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.145]             base::names(...future.oldOptions))
[17:02:51.145]     }
[17:02:51.145]     if (FALSE) {
[17:02:51.145]     }
[17:02:51.145]     else {
[17:02:51.145]         if (TRUE) {
[17:02:51.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.145]                 open = "w")
[17:02:51.145]         }
[17:02:51.145]         else {
[17:02:51.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.145]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.145]         }
[17:02:51.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.145]             base::sink(type = "output", split = FALSE)
[17:02:51.145]             base::close(...future.stdout)
[17:02:51.145]         }, add = TRUE)
[17:02:51.145]     }
[17:02:51.145]     ...future.frame <- base::sys.nframe()
[17:02:51.145]     ...future.conditions <- base::list()
[17:02:51.145]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.145]     if (FALSE) {
[17:02:51.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.145]     }
[17:02:51.145]     ...future.result <- base::tryCatch({
[17:02:51.145]         base::withCallingHandlers({
[17:02:51.145]             ...future.value <- base::withVisible(base::local({
[17:02:51.145]                 b <- a
[17:02:51.145]                 a <- 2
[17:02:51.145]                 a * b
[17:02:51.145]             }))
[17:02:51.145]             future::FutureResult(value = ...future.value$value, 
[17:02:51.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.145]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.145]                     ...future.globalenv.names))
[17:02:51.145]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.145]         }, condition = base::local({
[17:02:51.145]             c <- base::c
[17:02:51.145]             inherits <- base::inherits
[17:02:51.145]             invokeRestart <- base::invokeRestart
[17:02:51.145]             length <- base::length
[17:02:51.145]             list <- base::list
[17:02:51.145]             seq.int <- base::seq.int
[17:02:51.145]             signalCondition <- base::signalCondition
[17:02:51.145]             sys.calls <- base::sys.calls
[17:02:51.145]             `[[` <- base::`[[`
[17:02:51.145]             `+` <- base::`+`
[17:02:51.145]             `<<-` <- base::`<<-`
[17:02:51.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.145]                   3L)]
[17:02:51.145]             }
[17:02:51.145]             function(cond) {
[17:02:51.145]                 is_error <- inherits(cond, "error")
[17:02:51.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.145]                   NULL)
[17:02:51.145]                 if (is_error) {
[17:02:51.145]                   sessionInformation <- function() {
[17:02:51.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.145]                       search = base::search(), system = base::Sys.info())
[17:02:51.145]                   }
[17:02:51.145]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.145]                     cond$call), session = sessionInformation(), 
[17:02:51.145]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.145]                   signalCondition(cond)
[17:02:51.145]                 }
[17:02:51.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.145]                 "immediateCondition"))) {
[17:02:51.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.145]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.145]                   if (TRUE && !signal) {
[17:02:51.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.145]                     {
[17:02:51.145]                       inherits <- base::inherits
[17:02:51.145]                       invokeRestart <- base::invokeRestart
[17:02:51.145]                       is.null <- base::is.null
[17:02:51.145]                       muffled <- FALSE
[17:02:51.145]                       if (inherits(cond, "message")) {
[17:02:51.145]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.145]                         if (muffled) 
[17:02:51.145]                           invokeRestart("muffleMessage")
[17:02:51.145]                       }
[17:02:51.145]                       else if (inherits(cond, "warning")) {
[17:02:51.145]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.145]                         if (muffled) 
[17:02:51.145]                           invokeRestart("muffleWarning")
[17:02:51.145]                       }
[17:02:51.145]                       else if (inherits(cond, "condition")) {
[17:02:51.145]                         if (!is.null(pattern)) {
[17:02:51.145]                           computeRestarts <- base::computeRestarts
[17:02:51.145]                           grepl <- base::grepl
[17:02:51.145]                           restarts <- computeRestarts(cond)
[17:02:51.145]                           for (restart in restarts) {
[17:02:51.145]                             name <- restart$name
[17:02:51.145]                             if (is.null(name)) 
[17:02:51.145]                               next
[17:02:51.145]                             if (!grepl(pattern, name)) 
[17:02:51.145]                               next
[17:02:51.145]                             invokeRestart(restart)
[17:02:51.145]                             muffled <- TRUE
[17:02:51.145]                             break
[17:02:51.145]                           }
[17:02:51.145]                         }
[17:02:51.145]                       }
[17:02:51.145]                       invisible(muffled)
[17:02:51.145]                     }
[17:02:51.145]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.145]                   }
[17:02:51.145]                 }
[17:02:51.145]                 else {
[17:02:51.145]                   if (TRUE) {
[17:02:51.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.145]                     {
[17:02:51.145]                       inherits <- base::inherits
[17:02:51.145]                       invokeRestart <- base::invokeRestart
[17:02:51.145]                       is.null <- base::is.null
[17:02:51.145]                       muffled <- FALSE
[17:02:51.145]                       if (inherits(cond, "message")) {
[17:02:51.145]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.145]                         if (muffled) 
[17:02:51.145]                           invokeRestart("muffleMessage")
[17:02:51.145]                       }
[17:02:51.145]                       else if (inherits(cond, "warning")) {
[17:02:51.145]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.145]                         if (muffled) 
[17:02:51.145]                           invokeRestart("muffleWarning")
[17:02:51.145]                       }
[17:02:51.145]                       else if (inherits(cond, "condition")) {
[17:02:51.145]                         if (!is.null(pattern)) {
[17:02:51.145]                           computeRestarts <- base::computeRestarts
[17:02:51.145]                           grepl <- base::grepl
[17:02:51.145]                           restarts <- computeRestarts(cond)
[17:02:51.145]                           for (restart in restarts) {
[17:02:51.145]                             name <- restart$name
[17:02:51.145]                             if (is.null(name)) 
[17:02:51.145]                               next
[17:02:51.145]                             if (!grepl(pattern, name)) 
[17:02:51.145]                               next
[17:02:51.145]                             invokeRestart(restart)
[17:02:51.145]                             muffled <- TRUE
[17:02:51.145]                             break
[17:02:51.145]                           }
[17:02:51.145]                         }
[17:02:51.145]                       }
[17:02:51.145]                       invisible(muffled)
[17:02:51.145]                     }
[17:02:51.145]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.145]                   }
[17:02:51.145]                 }
[17:02:51.145]             }
[17:02:51.145]         }))
[17:02:51.145]     }, error = function(ex) {
[17:02:51.145]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.145]                 ...future.rng), started = ...future.startTime, 
[17:02:51.145]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.145]             version = "1.8"), class = "FutureResult")
[17:02:51.145]     }, finally = {
[17:02:51.145]         if (!identical(...future.workdir, getwd())) 
[17:02:51.145]             setwd(...future.workdir)
[17:02:51.145]         {
[17:02:51.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.145]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.145]             }
[17:02:51.145]             base::options(...future.oldOptions)
[17:02:51.145]             if (.Platform$OS.type == "windows") {
[17:02:51.145]                 old_names <- names(...future.oldEnvVars)
[17:02:51.145]                 envs <- base::Sys.getenv()
[17:02:51.145]                 names <- names(envs)
[17:02:51.145]                 common <- intersect(names, old_names)
[17:02:51.145]                 added <- setdiff(names, old_names)
[17:02:51.145]                 removed <- setdiff(old_names, names)
[17:02:51.145]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.145]                   envs[common]]
[17:02:51.145]                 NAMES <- toupper(changed)
[17:02:51.145]                 args <- list()
[17:02:51.145]                 for (kk in seq_along(NAMES)) {
[17:02:51.145]                   name <- changed[[kk]]
[17:02:51.145]                   NAME <- NAMES[[kk]]
[17:02:51.145]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.145]                     next
[17:02:51.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.145]                 }
[17:02:51.145]                 NAMES <- toupper(added)
[17:02:51.145]                 for (kk in seq_along(NAMES)) {
[17:02:51.145]                   name <- added[[kk]]
[17:02:51.145]                   NAME <- NAMES[[kk]]
[17:02:51.145]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.145]                     next
[17:02:51.145]                   args[[name]] <- ""
[17:02:51.145]                 }
[17:02:51.145]                 NAMES <- toupper(removed)
[17:02:51.145]                 for (kk in seq_along(NAMES)) {
[17:02:51.145]                   name <- removed[[kk]]
[17:02:51.145]                   NAME <- NAMES[[kk]]
[17:02:51.145]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.145]                     next
[17:02:51.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.145]                 }
[17:02:51.145]                 if (length(args) > 0) 
[17:02:51.145]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.145]             }
[17:02:51.145]             else {
[17:02:51.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.145]             }
[17:02:51.145]             {
[17:02:51.145]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.145]                   0L) {
[17:02:51.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.145]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.145]                   base::options(opts)
[17:02:51.145]                 }
[17:02:51.145]                 {
[17:02:51.145]                   {
[17:02:51.145]                     NULL
[17:02:51.145]                     RNGkind("Mersenne-Twister")
[17:02:51.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.145]                       inherits = FALSE)
[17:02:51.145]                   }
[17:02:51.145]                   options(future.plan = NULL)
[17:02:51.145]                   if (is.na(NA_character_)) 
[17:02:51.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.145]                     .init = FALSE)
[17:02:51.145]                 }
[17:02:51.145]             }
[17:02:51.145]         }
[17:02:51.145]     })
[17:02:51.145]     if (TRUE) {
[17:02:51.145]         base::sink(type = "output", split = FALSE)
[17:02:51.145]         if (TRUE) {
[17:02:51.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.145]         }
[17:02:51.145]         else {
[17:02:51.145]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.145]         }
[17:02:51.145]         base::close(...future.stdout)
[17:02:51.145]         ...future.stdout <- NULL
[17:02:51.145]     }
[17:02:51.145]     ...future.result$conditions <- ...future.conditions
[17:02:51.145]     ...future.result$finished <- base::Sys.time()
[17:02:51.145]     ...future.result
[17:02:51.145] }
[17:02:51.146] assign_globals() ...
[17:02:51.146] List of 1
[17:02:51.146]  $ a: num 3
[17:02:51.146]  - attr(*, "where")=List of 1
[17:02:51.146]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.146]  - attr(*, "resolved")= logi TRUE
[17:02:51.146]  - attr(*, "total_size")= num 56
[17:02:51.146]  - attr(*, "already-done")= logi TRUE
[17:02:51.151] - copied ‘a’ to environment
[17:02:51.151] assign_globals() ... done
[17:02:51.151] plan(): Setting new future strategy stack:
[17:02:51.151] List of future strategies:
[17:02:51.151] 1. sequential:
[17:02:51.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.151]    - tweaked: FALSE
[17:02:51.151]    - call: NULL
[17:02:51.152] plan(): nbrOfWorkers() = 1
[17:02:51.153] plan(): Setting new future strategy stack:
[17:02:51.153] List of future strategies:
[17:02:51.153] 1. sequential:
[17:02:51.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.153]    - tweaked: FALSE
[17:02:51.153]    - call: plan(strategy)
[17:02:51.153] plan(): nbrOfWorkers() = 1
[17:02:51.153] SequentialFuture started (and completed)
[17:02:51.153] - Launch lazy future ... done
[17:02:51.154] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.154] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.154] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.156] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:51.156] Searching for globals ... DONE
[17:02:51.156] Resolving globals: TRUE
[17:02:51.156] Resolving any globals that are futures ...
[17:02:51.157] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:51.157] Resolving any globals that are futures ... DONE
[17:02:51.157] Resolving futures part of globals (recursively) ...
[17:02:51.157] resolve() on list ...
[17:02:51.157]  recursive: 99
[17:02:51.157]  length: 1
[17:02:51.157]  elements: ‘a’
[17:02:51.158]  length: 0 (resolved future 1)
[17:02:51.158] resolve() on list ... DONE
[17:02:51.158] - globals: [1] ‘a’
[17:02:51.158] Resolving futures part of globals (recursively) ... DONE
[17:02:51.158] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.158] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:02:51.158] - globals: [1] ‘a’
[17:02:51.159] 
[17:02:51.159] getGlobalsAndPackages() ... DONE
[17:02:51.159] run() for ‘Future’ ...
[17:02:51.159] - state: ‘created’
[17:02:51.159] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.160] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.160] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.160]   - Field: ‘label’
[17:02:51.160]   - Field: ‘local’
[17:02:51.160]   - Field: ‘owner’
[17:02:51.160]   - Field: ‘envir’
[17:02:51.160]   - Field: ‘packages’
[17:02:51.160]   - Field: ‘gc’
[17:02:51.160]   - Field: ‘conditions’
[17:02:51.160]   - Field: ‘expr’
[17:02:51.161]   - Field: ‘uuid’
[17:02:51.161]   - Field: ‘seed’
[17:02:51.161]   - Field: ‘version’
[17:02:51.161]   - Field: ‘result’
[17:02:51.161]   - Field: ‘asynchronous’
[17:02:51.161]   - Field: ‘calls’
[17:02:51.161]   - Field: ‘globals’
[17:02:51.161]   - Field: ‘stdout’
[17:02:51.161]   - Field: ‘earlySignal’
[17:02:51.161]   - Field: ‘lazy’
[17:02:51.161]   - Field: ‘state’
[17:02:51.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.162] - Launch lazy future ...
[17:02:51.162] Packages needed by the future expression (n = 0): <none>
[17:02:51.162] Packages needed by future strategies (n = 0): <none>
[17:02:51.162] {
[17:02:51.162]     {
[17:02:51.162]         {
[17:02:51.162]             ...future.startTime <- base::Sys.time()
[17:02:51.162]             {
[17:02:51.162]                 {
[17:02:51.162]                   {
[17:02:51.162]                     base::local({
[17:02:51.162]                       has_future <- base::requireNamespace("future", 
[17:02:51.162]                         quietly = TRUE)
[17:02:51.162]                       if (has_future) {
[17:02:51.162]                         ns <- base::getNamespace("future")
[17:02:51.162]                         version <- ns[[".package"]][["version"]]
[17:02:51.162]                         if (is.null(version)) 
[17:02:51.162]                           version <- utils::packageVersion("future")
[17:02:51.162]                       }
[17:02:51.162]                       else {
[17:02:51.162]                         version <- NULL
[17:02:51.162]                       }
[17:02:51.162]                       if (!has_future || version < "1.8.0") {
[17:02:51.162]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.162]                           "", base::R.version$version.string), 
[17:02:51.162]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.162]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.162]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.162]                             "release", "version")], collapse = " "), 
[17:02:51.162]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.162]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.162]                           info)
[17:02:51.162]                         info <- base::paste(info, collapse = "; ")
[17:02:51.162]                         if (!has_future) {
[17:02:51.162]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.162]                             info)
[17:02:51.162]                         }
[17:02:51.162]                         else {
[17:02:51.162]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.162]                             info, version)
[17:02:51.162]                         }
[17:02:51.162]                         base::stop(msg)
[17:02:51.162]                       }
[17:02:51.162]                     })
[17:02:51.162]                   }
[17:02:51.162]                   ...future.strategy.old <- future::plan("list")
[17:02:51.162]                   options(future.plan = NULL)
[17:02:51.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.162]                 }
[17:02:51.162]                 ...future.workdir <- getwd()
[17:02:51.162]             }
[17:02:51.162]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.162]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.162]         }
[17:02:51.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.162]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.162]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.162]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.162]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.162]             base::names(...future.oldOptions))
[17:02:51.162]     }
[17:02:51.162]     if (FALSE) {
[17:02:51.162]     }
[17:02:51.162]     else {
[17:02:51.162]         if (TRUE) {
[17:02:51.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.162]                 open = "w")
[17:02:51.162]         }
[17:02:51.162]         else {
[17:02:51.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.162]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.162]         }
[17:02:51.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.162]             base::sink(type = "output", split = FALSE)
[17:02:51.162]             base::close(...future.stdout)
[17:02:51.162]         }, add = TRUE)
[17:02:51.162]     }
[17:02:51.162]     ...future.frame <- base::sys.nframe()
[17:02:51.162]     ...future.conditions <- base::list()
[17:02:51.162]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.162]     if (FALSE) {
[17:02:51.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.162]     }
[17:02:51.162]     ...future.result <- base::tryCatch({
[17:02:51.162]         base::withCallingHandlers({
[17:02:51.162]             ...future.value <- base::withVisible(base::local({
[17:02:51.162]                 b <- a
[17:02:51.162]                 a <- 2
[17:02:51.162]                 a * b
[17:02:51.162]             }))
[17:02:51.162]             future::FutureResult(value = ...future.value$value, 
[17:02:51.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.162]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.162]                     ...future.globalenv.names))
[17:02:51.162]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.162]         }, condition = base::local({
[17:02:51.162]             c <- base::c
[17:02:51.162]             inherits <- base::inherits
[17:02:51.162]             invokeRestart <- base::invokeRestart
[17:02:51.162]             length <- base::length
[17:02:51.162]             list <- base::list
[17:02:51.162]             seq.int <- base::seq.int
[17:02:51.162]             signalCondition <- base::signalCondition
[17:02:51.162]             sys.calls <- base::sys.calls
[17:02:51.162]             `[[` <- base::`[[`
[17:02:51.162]             `+` <- base::`+`
[17:02:51.162]             `<<-` <- base::`<<-`
[17:02:51.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.162]                   3L)]
[17:02:51.162]             }
[17:02:51.162]             function(cond) {
[17:02:51.162]                 is_error <- inherits(cond, "error")
[17:02:51.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.162]                   NULL)
[17:02:51.162]                 if (is_error) {
[17:02:51.162]                   sessionInformation <- function() {
[17:02:51.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.162]                       search = base::search(), system = base::Sys.info())
[17:02:51.162]                   }
[17:02:51.162]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.162]                     cond$call), session = sessionInformation(), 
[17:02:51.162]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.162]                   signalCondition(cond)
[17:02:51.162]                 }
[17:02:51.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.162]                 "immediateCondition"))) {
[17:02:51.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.162]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.162]                   if (TRUE && !signal) {
[17:02:51.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.162]                     {
[17:02:51.162]                       inherits <- base::inherits
[17:02:51.162]                       invokeRestart <- base::invokeRestart
[17:02:51.162]                       is.null <- base::is.null
[17:02:51.162]                       muffled <- FALSE
[17:02:51.162]                       if (inherits(cond, "message")) {
[17:02:51.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.162]                         if (muffled) 
[17:02:51.162]                           invokeRestart("muffleMessage")
[17:02:51.162]                       }
[17:02:51.162]                       else if (inherits(cond, "warning")) {
[17:02:51.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.162]                         if (muffled) 
[17:02:51.162]                           invokeRestart("muffleWarning")
[17:02:51.162]                       }
[17:02:51.162]                       else if (inherits(cond, "condition")) {
[17:02:51.162]                         if (!is.null(pattern)) {
[17:02:51.162]                           computeRestarts <- base::computeRestarts
[17:02:51.162]                           grepl <- base::grepl
[17:02:51.162]                           restarts <- computeRestarts(cond)
[17:02:51.162]                           for (restart in restarts) {
[17:02:51.162]                             name <- restart$name
[17:02:51.162]                             if (is.null(name)) 
[17:02:51.162]                               next
[17:02:51.162]                             if (!grepl(pattern, name)) 
[17:02:51.162]                               next
[17:02:51.162]                             invokeRestart(restart)
[17:02:51.162]                             muffled <- TRUE
[17:02:51.162]                             break
[17:02:51.162]                           }
[17:02:51.162]                         }
[17:02:51.162]                       }
[17:02:51.162]                       invisible(muffled)
[17:02:51.162]                     }
[17:02:51.162]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.162]                   }
[17:02:51.162]                 }
[17:02:51.162]                 else {
[17:02:51.162]                   if (TRUE) {
[17:02:51.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.162]                     {
[17:02:51.162]                       inherits <- base::inherits
[17:02:51.162]                       invokeRestart <- base::invokeRestart
[17:02:51.162]                       is.null <- base::is.null
[17:02:51.162]                       muffled <- FALSE
[17:02:51.162]                       if (inherits(cond, "message")) {
[17:02:51.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.162]                         if (muffled) 
[17:02:51.162]                           invokeRestart("muffleMessage")
[17:02:51.162]                       }
[17:02:51.162]                       else if (inherits(cond, "warning")) {
[17:02:51.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.162]                         if (muffled) 
[17:02:51.162]                           invokeRestart("muffleWarning")
[17:02:51.162]                       }
[17:02:51.162]                       else if (inherits(cond, "condition")) {
[17:02:51.162]                         if (!is.null(pattern)) {
[17:02:51.162]                           computeRestarts <- base::computeRestarts
[17:02:51.162]                           grepl <- base::grepl
[17:02:51.162]                           restarts <- computeRestarts(cond)
[17:02:51.162]                           for (restart in restarts) {
[17:02:51.162]                             name <- restart$name
[17:02:51.162]                             if (is.null(name)) 
[17:02:51.162]                               next
[17:02:51.162]                             if (!grepl(pattern, name)) 
[17:02:51.162]                               next
[17:02:51.162]                             invokeRestart(restart)
[17:02:51.162]                             muffled <- TRUE
[17:02:51.162]                             break
[17:02:51.162]                           }
[17:02:51.162]                         }
[17:02:51.162]                       }
[17:02:51.162]                       invisible(muffled)
[17:02:51.162]                     }
[17:02:51.162]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.162]                   }
[17:02:51.162]                 }
[17:02:51.162]             }
[17:02:51.162]         }))
[17:02:51.162]     }, error = function(ex) {
[17:02:51.162]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.162]                 ...future.rng), started = ...future.startTime, 
[17:02:51.162]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.162]             version = "1.8"), class = "FutureResult")
[17:02:51.162]     }, finally = {
[17:02:51.162]         if (!identical(...future.workdir, getwd())) 
[17:02:51.162]             setwd(...future.workdir)
[17:02:51.162]         {
[17:02:51.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.162]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.162]             }
[17:02:51.162]             base::options(...future.oldOptions)
[17:02:51.162]             if (.Platform$OS.type == "windows") {
[17:02:51.162]                 old_names <- names(...future.oldEnvVars)
[17:02:51.162]                 envs <- base::Sys.getenv()
[17:02:51.162]                 names <- names(envs)
[17:02:51.162]                 common <- intersect(names, old_names)
[17:02:51.162]                 added <- setdiff(names, old_names)
[17:02:51.162]                 removed <- setdiff(old_names, names)
[17:02:51.162]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.162]                   envs[common]]
[17:02:51.162]                 NAMES <- toupper(changed)
[17:02:51.162]                 args <- list()
[17:02:51.162]                 for (kk in seq_along(NAMES)) {
[17:02:51.162]                   name <- changed[[kk]]
[17:02:51.162]                   NAME <- NAMES[[kk]]
[17:02:51.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.162]                     next
[17:02:51.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.162]                 }
[17:02:51.162]                 NAMES <- toupper(added)
[17:02:51.162]                 for (kk in seq_along(NAMES)) {
[17:02:51.162]                   name <- added[[kk]]
[17:02:51.162]                   NAME <- NAMES[[kk]]
[17:02:51.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.162]                     next
[17:02:51.162]                   args[[name]] <- ""
[17:02:51.162]                 }
[17:02:51.162]                 NAMES <- toupper(removed)
[17:02:51.162]                 for (kk in seq_along(NAMES)) {
[17:02:51.162]                   name <- removed[[kk]]
[17:02:51.162]                   NAME <- NAMES[[kk]]
[17:02:51.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.162]                     next
[17:02:51.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.162]                 }
[17:02:51.162]                 if (length(args) > 0) 
[17:02:51.162]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.162]             }
[17:02:51.162]             else {
[17:02:51.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.162]             }
[17:02:51.162]             {
[17:02:51.162]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.162]                   0L) {
[17:02:51.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.162]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.162]                   base::options(opts)
[17:02:51.162]                 }
[17:02:51.162]                 {
[17:02:51.162]                   {
[17:02:51.162]                     NULL
[17:02:51.162]                     RNGkind("Mersenne-Twister")
[17:02:51.162]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.162]                       inherits = FALSE)
[17:02:51.162]                   }
[17:02:51.162]                   options(future.plan = NULL)
[17:02:51.162]                   if (is.na(NA_character_)) 
[17:02:51.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.162]                     .init = FALSE)
[17:02:51.162]                 }
[17:02:51.162]             }
[17:02:51.162]         }
[17:02:51.162]     })
[17:02:51.162]     if (TRUE) {
[17:02:51.162]         base::sink(type = "output", split = FALSE)
[17:02:51.162]         if (TRUE) {
[17:02:51.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.162]         }
[17:02:51.162]         else {
[17:02:51.162]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.162]         }
[17:02:51.162]         base::close(...future.stdout)
[17:02:51.162]         ...future.stdout <- NULL
[17:02:51.162]     }
[17:02:51.162]     ...future.result$conditions <- ...future.conditions
[17:02:51.162]     ...future.result$finished <- base::Sys.time()
[17:02:51.162]     ...future.result
[17:02:51.162] }
[17:02:51.164] assign_globals() ...
[17:02:51.164] List of 1
[17:02:51.164]  $ a: num 3
[17:02:51.164]  - attr(*, "where")=List of 1
[17:02:51.164]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.164]  - attr(*, "resolved")= logi TRUE
[17:02:51.164]  - attr(*, "total_size")= num 56
[17:02:51.164]  - attr(*, "already-done")= logi TRUE
[17:02:51.166] - copied ‘a’ to environment
[17:02:51.167] assign_globals() ... done
[17:02:51.167] plan(): Setting new future strategy stack:
[17:02:51.167] List of future strategies:
[17:02:51.167] 1. sequential:
[17:02:51.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.167]    - tweaked: FALSE
[17:02:51.167]    - call: NULL
[17:02:51.167] plan(): nbrOfWorkers() = 1
[17:02:51.168] plan(): Setting new future strategy stack:
[17:02:51.168] List of future strategies:
[17:02:51.168] 1. sequential:
[17:02:51.168]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.168]    - tweaked: FALSE
[17:02:51.168]    - call: plan(strategy)
[17:02:51.169] plan(): nbrOfWorkers() = 1
[17:02:51.169] SequentialFuture started (and completed)
[17:02:51.169] - Launch lazy future ... done
[17:02:51.169] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.170] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.170] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.172] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.172] Searching for globals ... DONE
[17:02:51.172] Resolving globals: TRUE
[17:02:51.172] Resolving any globals that are futures ...
[17:02:51.172] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.172] Resolving any globals that are futures ... DONE
[17:02:51.172] Resolving futures part of globals (recursively) ...
[17:02:51.173] resolve() on list ...
[17:02:51.173]  recursive: 99
[17:02:51.173]  length: 2
[17:02:51.173]  elements: ‘a’, ‘ii’
[17:02:51.173]  length: 1 (resolved future 1)
[17:02:51.173]  length: 0 (resolved future 2)
[17:02:51.173] resolve() on list ... DONE
[17:02:51.173] - globals: [2] ‘a’, ‘ii’
[17:02:51.174] Resolving futures part of globals (recursively) ... DONE
[17:02:51.175] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:51.176] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.176] - globals: [2] ‘a’, ‘ii’
[17:02:51.176] 
[17:02:51.176] getGlobalsAndPackages() ... DONE
[17:02:51.176] run() for ‘Future’ ...
[17:02:51.177] - state: ‘created’
[17:02:51.177] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.177] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.177]   - Field: ‘label’
[17:02:51.177]   - Field: ‘local’
[17:02:51.177]   - Field: ‘owner’
[17:02:51.177]   - Field: ‘envir’
[17:02:51.178]   - Field: ‘packages’
[17:02:51.178]   - Field: ‘gc’
[17:02:51.178]   - Field: ‘conditions’
[17:02:51.178]   - Field: ‘expr’
[17:02:51.178]   - Field: ‘uuid’
[17:02:51.178]   - Field: ‘seed’
[17:02:51.178]   - Field: ‘version’
[17:02:51.178]   - Field: ‘result’
[17:02:51.178]   - Field: ‘asynchronous’
[17:02:51.178]   - Field: ‘calls’
[17:02:51.178]   - Field: ‘globals’
[17:02:51.179]   - Field: ‘stdout’
[17:02:51.179]   - Field: ‘earlySignal’
[17:02:51.179]   - Field: ‘lazy’
[17:02:51.179]   - Field: ‘state’
[17:02:51.179] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.179] - Launch lazy future ...
[17:02:51.179] Packages needed by the future expression (n = 0): <none>
[17:02:51.179] Packages needed by future strategies (n = 0): <none>
[17:02:51.180] {
[17:02:51.180]     {
[17:02:51.180]         {
[17:02:51.180]             ...future.startTime <- base::Sys.time()
[17:02:51.180]             {
[17:02:51.180]                 {
[17:02:51.180]                   {
[17:02:51.180]                     base::local({
[17:02:51.180]                       has_future <- base::requireNamespace("future", 
[17:02:51.180]                         quietly = TRUE)
[17:02:51.180]                       if (has_future) {
[17:02:51.180]                         ns <- base::getNamespace("future")
[17:02:51.180]                         version <- ns[[".package"]][["version"]]
[17:02:51.180]                         if (is.null(version)) 
[17:02:51.180]                           version <- utils::packageVersion("future")
[17:02:51.180]                       }
[17:02:51.180]                       else {
[17:02:51.180]                         version <- NULL
[17:02:51.180]                       }
[17:02:51.180]                       if (!has_future || version < "1.8.0") {
[17:02:51.180]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.180]                           "", base::R.version$version.string), 
[17:02:51.180]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.180]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.180]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.180]                             "release", "version")], collapse = " "), 
[17:02:51.180]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.180]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.180]                           info)
[17:02:51.180]                         info <- base::paste(info, collapse = "; ")
[17:02:51.180]                         if (!has_future) {
[17:02:51.180]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.180]                             info)
[17:02:51.180]                         }
[17:02:51.180]                         else {
[17:02:51.180]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.180]                             info, version)
[17:02:51.180]                         }
[17:02:51.180]                         base::stop(msg)
[17:02:51.180]                       }
[17:02:51.180]                     })
[17:02:51.180]                   }
[17:02:51.180]                   ...future.strategy.old <- future::plan("list")
[17:02:51.180]                   options(future.plan = NULL)
[17:02:51.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.180]                 }
[17:02:51.180]                 ...future.workdir <- getwd()
[17:02:51.180]             }
[17:02:51.180]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.180]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.180]         }
[17:02:51.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.180]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.180]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.180]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.180]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.180]             base::names(...future.oldOptions))
[17:02:51.180]     }
[17:02:51.180]     if (FALSE) {
[17:02:51.180]     }
[17:02:51.180]     else {
[17:02:51.180]         if (TRUE) {
[17:02:51.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.180]                 open = "w")
[17:02:51.180]         }
[17:02:51.180]         else {
[17:02:51.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.180]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.180]         }
[17:02:51.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.180]             base::sink(type = "output", split = FALSE)
[17:02:51.180]             base::close(...future.stdout)
[17:02:51.180]         }, add = TRUE)
[17:02:51.180]     }
[17:02:51.180]     ...future.frame <- base::sys.nframe()
[17:02:51.180]     ...future.conditions <- base::list()
[17:02:51.180]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.180]     if (FALSE) {
[17:02:51.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.180]     }
[17:02:51.180]     ...future.result <- base::tryCatch({
[17:02:51.180]         base::withCallingHandlers({
[17:02:51.180]             ...future.value <- base::withVisible(base::local({
[17:02:51.180]                 b <- a * ii
[17:02:51.180]                 a <- 0
[17:02:51.180]                 b
[17:02:51.180]             }))
[17:02:51.180]             future::FutureResult(value = ...future.value$value, 
[17:02:51.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.180]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.180]                     ...future.globalenv.names))
[17:02:51.180]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.180]         }, condition = base::local({
[17:02:51.180]             c <- base::c
[17:02:51.180]             inherits <- base::inherits
[17:02:51.180]             invokeRestart <- base::invokeRestart
[17:02:51.180]             length <- base::length
[17:02:51.180]             list <- base::list
[17:02:51.180]             seq.int <- base::seq.int
[17:02:51.180]             signalCondition <- base::signalCondition
[17:02:51.180]             sys.calls <- base::sys.calls
[17:02:51.180]             `[[` <- base::`[[`
[17:02:51.180]             `+` <- base::`+`
[17:02:51.180]             `<<-` <- base::`<<-`
[17:02:51.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.180]                   3L)]
[17:02:51.180]             }
[17:02:51.180]             function(cond) {
[17:02:51.180]                 is_error <- inherits(cond, "error")
[17:02:51.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.180]                   NULL)
[17:02:51.180]                 if (is_error) {
[17:02:51.180]                   sessionInformation <- function() {
[17:02:51.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.180]                       search = base::search(), system = base::Sys.info())
[17:02:51.180]                   }
[17:02:51.180]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.180]                     cond$call), session = sessionInformation(), 
[17:02:51.180]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.180]                   signalCondition(cond)
[17:02:51.180]                 }
[17:02:51.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.180]                 "immediateCondition"))) {
[17:02:51.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.180]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.180]                   if (TRUE && !signal) {
[17:02:51.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.180]                     {
[17:02:51.180]                       inherits <- base::inherits
[17:02:51.180]                       invokeRestart <- base::invokeRestart
[17:02:51.180]                       is.null <- base::is.null
[17:02:51.180]                       muffled <- FALSE
[17:02:51.180]                       if (inherits(cond, "message")) {
[17:02:51.180]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.180]                         if (muffled) 
[17:02:51.180]                           invokeRestart("muffleMessage")
[17:02:51.180]                       }
[17:02:51.180]                       else if (inherits(cond, "warning")) {
[17:02:51.180]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.180]                         if (muffled) 
[17:02:51.180]                           invokeRestart("muffleWarning")
[17:02:51.180]                       }
[17:02:51.180]                       else if (inherits(cond, "condition")) {
[17:02:51.180]                         if (!is.null(pattern)) {
[17:02:51.180]                           computeRestarts <- base::computeRestarts
[17:02:51.180]                           grepl <- base::grepl
[17:02:51.180]                           restarts <- computeRestarts(cond)
[17:02:51.180]                           for (restart in restarts) {
[17:02:51.180]                             name <- restart$name
[17:02:51.180]                             if (is.null(name)) 
[17:02:51.180]                               next
[17:02:51.180]                             if (!grepl(pattern, name)) 
[17:02:51.180]                               next
[17:02:51.180]                             invokeRestart(restart)
[17:02:51.180]                             muffled <- TRUE
[17:02:51.180]                             break
[17:02:51.180]                           }
[17:02:51.180]                         }
[17:02:51.180]                       }
[17:02:51.180]                       invisible(muffled)
[17:02:51.180]                     }
[17:02:51.180]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.180]                   }
[17:02:51.180]                 }
[17:02:51.180]                 else {
[17:02:51.180]                   if (TRUE) {
[17:02:51.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.180]                     {
[17:02:51.180]                       inherits <- base::inherits
[17:02:51.180]                       invokeRestart <- base::invokeRestart
[17:02:51.180]                       is.null <- base::is.null
[17:02:51.180]                       muffled <- FALSE
[17:02:51.180]                       if (inherits(cond, "message")) {
[17:02:51.180]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.180]                         if (muffled) 
[17:02:51.180]                           invokeRestart("muffleMessage")
[17:02:51.180]                       }
[17:02:51.180]                       else if (inherits(cond, "warning")) {
[17:02:51.180]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.180]                         if (muffled) 
[17:02:51.180]                           invokeRestart("muffleWarning")
[17:02:51.180]                       }
[17:02:51.180]                       else if (inherits(cond, "condition")) {
[17:02:51.180]                         if (!is.null(pattern)) {
[17:02:51.180]                           computeRestarts <- base::computeRestarts
[17:02:51.180]                           grepl <- base::grepl
[17:02:51.180]                           restarts <- computeRestarts(cond)
[17:02:51.180]                           for (restart in restarts) {
[17:02:51.180]                             name <- restart$name
[17:02:51.180]                             if (is.null(name)) 
[17:02:51.180]                               next
[17:02:51.180]                             if (!grepl(pattern, name)) 
[17:02:51.180]                               next
[17:02:51.180]                             invokeRestart(restart)
[17:02:51.180]                             muffled <- TRUE
[17:02:51.180]                             break
[17:02:51.180]                           }
[17:02:51.180]                         }
[17:02:51.180]                       }
[17:02:51.180]                       invisible(muffled)
[17:02:51.180]                     }
[17:02:51.180]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.180]                   }
[17:02:51.180]                 }
[17:02:51.180]             }
[17:02:51.180]         }))
[17:02:51.180]     }, error = function(ex) {
[17:02:51.180]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.180]                 ...future.rng), started = ...future.startTime, 
[17:02:51.180]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.180]             version = "1.8"), class = "FutureResult")
[17:02:51.180]     }, finally = {
[17:02:51.180]         if (!identical(...future.workdir, getwd())) 
[17:02:51.180]             setwd(...future.workdir)
[17:02:51.180]         {
[17:02:51.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.180]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.180]             }
[17:02:51.180]             base::options(...future.oldOptions)
[17:02:51.180]             if (.Platform$OS.type == "windows") {
[17:02:51.180]                 old_names <- names(...future.oldEnvVars)
[17:02:51.180]                 envs <- base::Sys.getenv()
[17:02:51.180]                 names <- names(envs)
[17:02:51.180]                 common <- intersect(names, old_names)
[17:02:51.180]                 added <- setdiff(names, old_names)
[17:02:51.180]                 removed <- setdiff(old_names, names)
[17:02:51.180]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.180]                   envs[common]]
[17:02:51.180]                 NAMES <- toupper(changed)
[17:02:51.180]                 args <- list()
[17:02:51.180]                 for (kk in seq_along(NAMES)) {
[17:02:51.180]                   name <- changed[[kk]]
[17:02:51.180]                   NAME <- NAMES[[kk]]
[17:02:51.180]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.180]                     next
[17:02:51.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.180]                 }
[17:02:51.180]                 NAMES <- toupper(added)
[17:02:51.180]                 for (kk in seq_along(NAMES)) {
[17:02:51.180]                   name <- added[[kk]]
[17:02:51.180]                   NAME <- NAMES[[kk]]
[17:02:51.180]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.180]                     next
[17:02:51.180]                   args[[name]] <- ""
[17:02:51.180]                 }
[17:02:51.180]                 NAMES <- toupper(removed)
[17:02:51.180]                 for (kk in seq_along(NAMES)) {
[17:02:51.180]                   name <- removed[[kk]]
[17:02:51.180]                   NAME <- NAMES[[kk]]
[17:02:51.180]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.180]                     next
[17:02:51.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.180]                 }
[17:02:51.180]                 if (length(args) > 0) 
[17:02:51.180]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.180]             }
[17:02:51.180]             else {
[17:02:51.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.180]             }
[17:02:51.180]             {
[17:02:51.180]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.180]                   0L) {
[17:02:51.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.180]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.180]                   base::options(opts)
[17:02:51.180]                 }
[17:02:51.180]                 {
[17:02:51.180]                   {
[17:02:51.180]                     NULL
[17:02:51.180]                     RNGkind("Mersenne-Twister")
[17:02:51.180]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.180]                       inherits = FALSE)
[17:02:51.180]                   }
[17:02:51.180]                   options(future.plan = NULL)
[17:02:51.180]                   if (is.na(NA_character_)) 
[17:02:51.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.180]                     .init = FALSE)
[17:02:51.180]                 }
[17:02:51.180]             }
[17:02:51.180]         }
[17:02:51.180]     })
[17:02:51.180]     if (TRUE) {
[17:02:51.180]         base::sink(type = "output", split = FALSE)
[17:02:51.180]         if (TRUE) {
[17:02:51.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.180]         }
[17:02:51.180]         else {
[17:02:51.180]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.180]         }
[17:02:51.180]         base::close(...future.stdout)
[17:02:51.180]         ...future.stdout <- NULL
[17:02:51.180]     }
[17:02:51.180]     ...future.result$conditions <- ...future.conditions
[17:02:51.180]     ...future.result$finished <- base::Sys.time()
[17:02:51.180]     ...future.result
[17:02:51.180] }
[17:02:51.181] assign_globals() ...
[17:02:51.181] List of 2
[17:02:51.181]  $ a : num 1
[17:02:51.181]  $ ii: int 1
[17:02:51.181]  - attr(*, "where")=List of 2
[17:02:51.181]   ..$ a :<environment: R_EmptyEnv> 
[17:02:51.181]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.181]  - attr(*, "resolved")= logi TRUE
[17:02:51.181]  - attr(*, "total_size")= num 112
[17:02:51.181]  - attr(*, "already-done")= logi TRUE
[17:02:51.184] - copied ‘a’ to environment
[17:02:51.184] - copied ‘ii’ to environment
[17:02:51.185] assign_globals() ... done
[17:02:51.185] plan(): Setting new future strategy stack:
[17:02:51.185] List of future strategies:
[17:02:51.185] 1. sequential:
[17:02:51.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.185]    - tweaked: FALSE
[17:02:51.185]    - call: NULL
[17:02:51.185] plan(): nbrOfWorkers() = 1
[17:02:51.186] plan(): Setting new future strategy stack:
[17:02:51.186] List of future strategies:
[17:02:51.186] 1. sequential:
[17:02:51.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.186]    - tweaked: FALSE
[17:02:51.186]    - call: plan(strategy)
[17:02:51.187] plan(): nbrOfWorkers() = 1
[17:02:51.187] SequentialFuture started (and completed)
[17:02:51.187] - Launch lazy future ... done
[17:02:51.187] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.187] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.188] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.189] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.190] Searching for globals ... DONE
[17:02:51.190] Resolving globals: TRUE
[17:02:51.190] Resolving any globals that are futures ...
[17:02:51.190] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.190] Resolving any globals that are futures ... DONE
[17:02:51.190] Resolving futures part of globals (recursively) ...
[17:02:51.191] resolve() on list ...
[17:02:51.191]  recursive: 99
[17:02:51.191]  length: 2
[17:02:51.191]  elements: ‘a’, ‘ii’
[17:02:51.191]  length: 1 (resolved future 1)
[17:02:51.191]  length: 0 (resolved future 2)
[17:02:51.191] resolve() on list ... DONE
[17:02:51.191] - globals: [2] ‘a’, ‘ii’
[17:02:51.191] Resolving futures part of globals (recursively) ... DONE
[17:02:51.192] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:51.192] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.192] - globals: [2] ‘a’, ‘ii’
[17:02:51.192] 
[17:02:51.192] getGlobalsAndPackages() ... DONE
[17:02:51.192] run() for ‘Future’ ...
[17:02:51.193] - state: ‘created’
[17:02:51.193] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.193] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.193]   - Field: ‘label’
[17:02:51.193]   - Field: ‘local’
[17:02:51.193]   - Field: ‘owner’
[17:02:51.193]   - Field: ‘envir’
[17:02:51.194]   - Field: ‘packages’
[17:02:51.194]   - Field: ‘gc’
[17:02:51.194]   - Field: ‘conditions’
[17:02:51.194]   - Field: ‘expr’
[17:02:51.194]   - Field: ‘uuid’
[17:02:51.194]   - Field: ‘seed’
[17:02:51.194]   - Field: ‘version’
[17:02:51.194]   - Field: ‘result’
[17:02:51.194]   - Field: ‘asynchronous’
[17:02:51.194]   - Field: ‘calls’
[17:02:51.194]   - Field: ‘globals’
[17:02:51.195]   - Field: ‘stdout’
[17:02:51.195]   - Field: ‘earlySignal’
[17:02:51.195]   - Field: ‘lazy’
[17:02:51.195]   - Field: ‘state’
[17:02:51.195] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.195] - Launch lazy future ...
[17:02:51.195] Packages needed by the future expression (n = 0): <none>
[17:02:51.195] Packages needed by future strategies (n = 0): <none>
[17:02:51.196] {
[17:02:51.196]     {
[17:02:51.196]         {
[17:02:51.196]             ...future.startTime <- base::Sys.time()
[17:02:51.196]             {
[17:02:51.196]                 {
[17:02:51.196]                   {
[17:02:51.196]                     base::local({
[17:02:51.196]                       has_future <- base::requireNamespace("future", 
[17:02:51.196]                         quietly = TRUE)
[17:02:51.196]                       if (has_future) {
[17:02:51.196]                         ns <- base::getNamespace("future")
[17:02:51.196]                         version <- ns[[".package"]][["version"]]
[17:02:51.196]                         if (is.null(version)) 
[17:02:51.196]                           version <- utils::packageVersion("future")
[17:02:51.196]                       }
[17:02:51.196]                       else {
[17:02:51.196]                         version <- NULL
[17:02:51.196]                       }
[17:02:51.196]                       if (!has_future || version < "1.8.0") {
[17:02:51.196]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.196]                           "", base::R.version$version.string), 
[17:02:51.196]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.196]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.196]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.196]                             "release", "version")], collapse = " "), 
[17:02:51.196]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.196]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.196]                           info)
[17:02:51.196]                         info <- base::paste(info, collapse = "; ")
[17:02:51.196]                         if (!has_future) {
[17:02:51.196]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.196]                             info)
[17:02:51.196]                         }
[17:02:51.196]                         else {
[17:02:51.196]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.196]                             info, version)
[17:02:51.196]                         }
[17:02:51.196]                         base::stop(msg)
[17:02:51.196]                       }
[17:02:51.196]                     })
[17:02:51.196]                   }
[17:02:51.196]                   ...future.strategy.old <- future::plan("list")
[17:02:51.196]                   options(future.plan = NULL)
[17:02:51.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.196]                 }
[17:02:51.196]                 ...future.workdir <- getwd()
[17:02:51.196]             }
[17:02:51.196]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.196]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.196]         }
[17:02:51.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.196]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.196]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.196]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.196]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.196]             base::names(...future.oldOptions))
[17:02:51.196]     }
[17:02:51.196]     if (FALSE) {
[17:02:51.196]     }
[17:02:51.196]     else {
[17:02:51.196]         if (TRUE) {
[17:02:51.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.196]                 open = "w")
[17:02:51.196]         }
[17:02:51.196]         else {
[17:02:51.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.196]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.196]         }
[17:02:51.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.196]             base::sink(type = "output", split = FALSE)
[17:02:51.196]             base::close(...future.stdout)
[17:02:51.196]         }, add = TRUE)
[17:02:51.196]     }
[17:02:51.196]     ...future.frame <- base::sys.nframe()
[17:02:51.196]     ...future.conditions <- base::list()
[17:02:51.196]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.196]     if (FALSE) {
[17:02:51.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.196]     }
[17:02:51.196]     ...future.result <- base::tryCatch({
[17:02:51.196]         base::withCallingHandlers({
[17:02:51.196]             ...future.value <- base::withVisible(base::local({
[17:02:51.196]                 b <- a * ii
[17:02:51.196]                 a <- 0
[17:02:51.196]                 b
[17:02:51.196]             }))
[17:02:51.196]             future::FutureResult(value = ...future.value$value, 
[17:02:51.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.196]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.196]                     ...future.globalenv.names))
[17:02:51.196]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.196]         }, condition = base::local({
[17:02:51.196]             c <- base::c
[17:02:51.196]             inherits <- base::inherits
[17:02:51.196]             invokeRestart <- base::invokeRestart
[17:02:51.196]             length <- base::length
[17:02:51.196]             list <- base::list
[17:02:51.196]             seq.int <- base::seq.int
[17:02:51.196]             signalCondition <- base::signalCondition
[17:02:51.196]             sys.calls <- base::sys.calls
[17:02:51.196]             `[[` <- base::`[[`
[17:02:51.196]             `+` <- base::`+`
[17:02:51.196]             `<<-` <- base::`<<-`
[17:02:51.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.196]                   3L)]
[17:02:51.196]             }
[17:02:51.196]             function(cond) {
[17:02:51.196]                 is_error <- inherits(cond, "error")
[17:02:51.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.196]                   NULL)
[17:02:51.196]                 if (is_error) {
[17:02:51.196]                   sessionInformation <- function() {
[17:02:51.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.196]                       search = base::search(), system = base::Sys.info())
[17:02:51.196]                   }
[17:02:51.196]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.196]                     cond$call), session = sessionInformation(), 
[17:02:51.196]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.196]                   signalCondition(cond)
[17:02:51.196]                 }
[17:02:51.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.196]                 "immediateCondition"))) {
[17:02:51.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.196]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.196]                   if (TRUE && !signal) {
[17:02:51.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.196]                     {
[17:02:51.196]                       inherits <- base::inherits
[17:02:51.196]                       invokeRestart <- base::invokeRestart
[17:02:51.196]                       is.null <- base::is.null
[17:02:51.196]                       muffled <- FALSE
[17:02:51.196]                       if (inherits(cond, "message")) {
[17:02:51.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.196]                         if (muffled) 
[17:02:51.196]                           invokeRestart("muffleMessage")
[17:02:51.196]                       }
[17:02:51.196]                       else if (inherits(cond, "warning")) {
[17:02:51.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.196]                         if (muffled) 
[17:02:51.196]                           invokeRestart("muffleWarning")
[17:02:51.196]                       }
[17:02:51.196]                       else if (inherits(cond, "condition")) {
[17:02:51.196]                         if (!is.null(pattern)) {
[17:02:51.196]                           computeRestarts <- base::computeRestarts
[17:02:51.196]                           grepl <- base::grepl
[17:02:51.196]                           restarts <- computeRestarts(cond)
[17:02:51.196]                           for (restart in restarts) {
[17:02:51.196]                             name <- restart$name
[17:02:51.196]                             if (is.null(name)) 
[17:02:51.196]                               next
[17:02:51.196]                             if (!grepl(pattern, name)) 
[17:02:51.196]                               next
[17:02:51.196]                             invokeRestart(restart)
[17:02:51.196]                             muffled <- TRUE
[17:02:51.196]                             break
[17:02:51.196]                           }
[17:02:51.196]                         }
[17:02:51.196]                       }
[17:02:51.196]                       invisible(muffled)
[17:02:51.196]                     }
[17:02:51.196]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.196]                   }
[17:02:51.196]                 }
[17:02:51.196]                 else {
[17:02:51.196]                   if (TRUE) {
[17:02:51.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.196]                     {
[17:02:51.196]                       inherits <- base::inherits
[17:02:51.196]                       invokeRestart <- base::invokeRestart
[17:02:51.196]                       is.null <- base::is.null
[17:02:51.196]                       muffled <- FALSE
[17:02:51.196]                       if (inherits(cond, "message")) {
[17:02:51.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.196]                         if (muffled) 
[17:02:51.196]                           invokeRestart("muffleMessage")
[17:02:51.196]                       }
[17:02:51.196]                       else if (inherits(cond, "warning")) {
[17:02:51.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.196]                         if (muffled) 
[17:02:51.196]                           invokeRestart("muffleWarning")
[17:02:51.196]                       }
[17:02:51.196]                       else if (inherits(cond, "condition")) {
[17:02:51.196]                         if (!is.null(pattern)) {
[17:02:51.196]                           computeRestarts <- base::computeRestarts
[17:02:51.196]                           grepl <- base::grepl
[17:02:51.196]                           restarts <- computeRestarts(cond)
[17:02:51.196]                           for (restart in restarts) {
[17:02:51.196]                             name <- restart$name
[17:02:51.196]                             if (is.null(name)) 
[17:02:51.196]                               next
[17:02:51.196]                             if (!grepl(pattern, name)) 
[17:02:51.196]                               next
[17:02:51.196]                             invokeRestart(restart)
[17:02:51.196]                             muffled <- TRUE
[17:02:51.196]                             break
[17:02:51.196]                           }
[17:02:51.196]                         }
[17:02:51.196]                       }
[17:02:51.196]                       invisible(muffled)
[17:02:51.196]                     }
[17:02:51.196]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.196]                   }
[17:02:51.196]                 }
[17:02:51.196]             }
[17:02:51.196]         }))
[17:02:51.196]     }, error = function(ex) {
[17:02:51.196]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.196]                 ...future.rng), started = ...future.startTime, 
[17:02:51.196]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.196]             version = "1.8"), class = "FutureResult")
[17:02:51.196]     }, finally = {
[17:02:51.196]         if (!identical(...future.workdir, getwd())) 
[17:02:51.196]             setwd(...future.workdir)
[17:02:51.196]         {
[17:02:51.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.196]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.196]             }
[17:02:51.196]             base::options(...future.oldOptions)
[17:02:51.196]             if (.Platform$OS.type == "windows") {
[17:02:51.196]                 old_names <- names(...future.oldEnvVars)
[17:02:51.196]                 envs <- base::Sys.getenv()
[17:02:51.196]                 names <- names(envs)
[17:02:51.196]                 common <- intersect(names, old_names)
[17:02:51.196]                 added <- setdiff(names, old_names)
[17:02:51.196]                 removed <- setdiff(old_names, names)
[17:02:51.196]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.196]                   envs[common]]
[17:02:51.196]                 NAMES <- toupper(changed)
[17:02:51.196]                 args <- list()
[17:02:51.196]                 for (kk in seq_along(NAMES)) {
[17:02:51.196]                   name <- changed[[kk]]
[17:02:51.196]                   NAME <- NAMES[[kk]]
[17:02:51.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.196]                     next
[17:02:51.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.196]                 }
[17:02:51.196]                 NAMES <- toupper(added)
[17:02:51.196]                 for (kk in seq_along(NAMES)) {
[17:02:51.196]                   name <- added[[kk]]
[17:02:51.196]                   NAME <- NAMES[[kk]]
[17:02:51.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.196]                     next
[17:02:51.196]                   args[[name]] <- ""
[17:02:51.196]                 }
[17:02:51.196]                 NAMES <- toupper(removed)
[17:02:51.196]                 for (kk in seq_along(NAMES)) {
[17:02:51.196]                   name <- removed[[kk]]
[17:02:51.196]                   NAME <- NAMES[[kk]]
[17:02:51.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.196]                     next
[17:02:51.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.196]                 }
[17:02:51.196]                 if (length(args) > 0) 
[17:02:51.196]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.196]             }
[17:02:51.196]             else {
[17:02:51.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.196]             }
[17:02:51.196]             {
[17:02:51.196]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.196]                   0L) {
[17:02:51.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.196]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.196]                   base::options(opts)
[17:02:51.196]                 }
[17:02:51.196]                 {
[17:02:51.196]                   {
[17:02:51.196]                     NULL
[17:02:51.196]                     RNGkind("Mersenne-Twister")
[17:02:51.196]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.196]                       inherits = FALSE)
[17:02:51.196]                   }
[17:02:51.196]                   options(future.plan = NULL)
[17:02:51.196]                   if (is.na(NA_character_)) 
[17:02:51.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.196]                     .init = FALSE)
[17:02:51.196]                 }
[17:02:51.196]             }
[17:02:51.196]         }
[17:02:51.196]     })
[17:02:51.196]     if (TRUE) {
[17:02:51.196]         base::sink(type = "output", split = FALSE)
[17:02:51.196]         if (TRUE) {
[17:02:51.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.196]         }
[17:02:51.196]         else {
[17:02:51.196]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.196]         }
[17:02:51.196]         base::close(...future.stdout)
[17:02:51.196]         ...future.stdout <- NULL
[17:02:51.196]     }
[17:02:51.196]     ...future.result$conditions <- ...future.conditions
[17:02:51.196]     ...future.result$finished <- base::Sys.time()
[17:02:51.196]     ...future.result
[17:02:51.196] }
[17:02:51.197] assign_globals() ...
[17:02:51.198] List of 2
[17:02:51.198]  $ a : num 1
[17:02:51.198]  $ ii: int 2
[17:02:51.198]  - attr(*, "where")=List of 2
[17:02:51.198]   ..$ a :<environment: R_EmptyEnv> 
[17:02:51.198]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.198]  - attr(*, "resolved")= logi TRUE
[17:02:51.198]  - attr(*, "total_size")= num 112
[17:02:51.198]  - attr(*, "already-done")= logi TRUE
[17:02:51.201] - copied ‘a’ to environment
[17:02:51.201] - copied ‘ii’ to environment
[17:02:51.201] assign_globals() ... done
[17:02:51.201] plan(): Setting new future strategy stack:
[17:02:51.201] List of future strategies:
[17:02:51.201] 1. sequential:
[17:02:51.201]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.201]    - tweaked: FALSE
[17:02:51.201]    - call: NULL
[17:02:51.203] plan(): nbrOfWorkers() = 1
[17:02:51.204] plan(): Setting new future strategy stack:
[17:02:51.204] List of future strategies:
[17:02:51.204] 1. sequential:
[17:02:51.204]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.204]    - tweaked: FALSE
[17:02:51.204]    - call: plan(strategy)
[17:02:51.205] plan(): nbrOfWorkers() = 1
[17:02:51.205] SequentialFuture started (and completed)
[17:02:51.205] - Launch lazy future ... done
[17:02:51.205] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.206] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.206] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.208] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.208] Searching for globals ... DONE
[17:02:51.208] Resolving globals: TRUE
[17:02:51.208] Resolving any globals that are futures ...
[17:02:51.208] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.208] Resolving any globals that are futures ... DONE
[17:02:51.209] Resolving futures part of globals (recursively) ...
[17:02:51.209] resolve() on list ...
[17:02:51.209]  recursive: 99
[17:02:51.209]  length: 2
[17:02:51.209]  elements: ‘a’, ‘ii’
[17:02:51.209]  length: 1 (resolved future 1)
[17:02:51.209]  length: 0 (resolved future 2)
[17:02:51.209] resolve() on list ... DONE
[17:02:51.209] - globals: [2] ‘a’, ‘ii’
[17:02:51.210] Resolving futures part of globals (recursively) ... DONE
[17:02:51.210] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:51.210] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.210] - globals: [2] ‘a’, ‘ii’
[17:02:51.210] 
[17:02:51.210] getGlobalsAndPackages() ... DONE
[17:02:51.211] run() for ‘Future’ ...
[17:02:51.211] - state: ‘created’
[17:02:51.211] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.211] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.211] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.211]   - Field: ‘label’
[17:02:51.211]   - Field: ‘local’
[17:02:51.212]   - Field: ‘owner’
[17:02:51.212]   - Field: ‘envir’
[17:02:51.212]   - Field: ‘packages’
[17:02:51.212]   - Field: ‘gc’
[17:02:51.212]   - Field: ‘conditions’
[17:02:51.212]   - Field: ‘expr’
[17:02:51.212]   - Field: ‘uuid’
[17:02:51.212]   - Field: ‘seed’
[17:02:51.212]   - Field: ‘version’
[17:02:51.212]   - Field: ‘result’
[17:02:51.212]   - Field: ‘asynchronous’
[17:02:51.213]   - Field: ‘calls’
[17:02:51.213]   - Field: ‘globals’
[17:02:51.213]   - Field: ‘stdout’
[17:02:51.213]   - Field: ‘earlySignal’
[17:02:51.213]   - Field: ‘lazy’
[17:02:51.213]   - Field: ‘state’
[17:02:51.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.213] - Launch lazy future ...
[17:02:51.213] Packages needed by the future expression (n = 0): <none>
[17:02:51.213] Packages needed by future strategies (n = 0): <none>
[17:02:51.214] {
[17:02:51.214]     {
[17:02:51.214]         {
[17:02:51.214]             ...future.startTime <- base::Sys.time()
[17:02:51.214]             {
[17:02:51.214]                 {
[17:02:51.214]                   {
[17:02:51.214]                     base::local({
[17:02:51.214]                       has_future <- base::requireNamespace("future", 
[17:02:51.214]                         quietly = TRUE)
[17:02:51.214]                       if (has_future) {
[17:02:51.214]                         ns <- base::getNamespace("future")
[17:02:51.214]                         version <- ns[[".package"]][["version"]]
[17:02:51.214]                         if (is.null(version)) 
[17:02:51.214]                           version <- utils::packageVersion("future")
[17:02:51.214]                       }
[17:02:51.214]                       else {
[17:02:51.214]                         version <- NULL
[17:02:51.214]                       }
[17:02:51.214]                       if (!has_future || version < "1.8.0") {
[17:02:51.214]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.214]                           "", base::R.version$version.string), 
[17:02:51.214]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.214]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.214]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.214]                             "release", "version")], collapse = " "), 
[17:02:51.214]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.214]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.214]                           info)
[17:02:51.214]                         info <- base::paste(info, collapse = "; ")
[17:02:51.214]                         if (!has_future) {
[17:02:51.214]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.214]                             info)
[17:02:51.214]                         }
[17:02:51.214]                         else {
[17:02:51.214]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.214]                             info, version)
[17:02:51.214]                         }
[17:02:51.214]                         base::stop(msg)
[17:02:51.214]                       }
[17:02:51.214]                     })
[17:02:51.214]                   }
[17:02:51.214]                   ...future.strategy.old <- future::plan("list")
[17:02:51.214]                   options(future.plan = NULL)
[17:02:51.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.214]                 }
[17:02:51.214]                 ...future.workdir <- getwd()
[17:02:51.214]             }
[17:02:51.214]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.214]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.214]         }
[17:02:51.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.214]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.214]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.214]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.214]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.214]             base::names(...future.oldOptions))
[17:02:51.214]     }
[17:02:51.214]     if (FALSE) {
[17:02:51.214]     }
[17:02:51.214]     else {
[17:02:51.214]         if (TRUE) {
[17:02:51.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.214]                 open = "w")
[17:02:51.214]         }
[17:02:51.214]         else {
[17:02:51.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.214]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.214]         }
[17:02:51.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.214]             base::sink(type = "output", split = FALSE)
[17:02:51.214]             base::close(...future.stdout)
[17:02:51.214]         }, add = TRUE)
[17:02:51.214]     }
[17:02:51.214]     ...future.frame <- base::sys.nframe()
[17:02:51.214]     ...future.conditions <- base::list()
[17:02:51.214]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.214]     if (FALSE) {
[17:02:51.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.214]     }
[17:02:51.214]     ...future.result <- base::tryCatch({
[17:02:51.214]         base::withCallingHandlers({
[17:02:51.214]             ...future.value <- base::withVisible(base::local({
[17:02:51.214]                 b <- a * ii
[17:02:51.214]                 a <- 0
[17:02:51.214]                 b
[17:02:51.214]             }))
[17:02:51.214]             future::FutureResult(value = ...future.value$value, 
[17:02:51.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.214]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.214]                     ...future.globalenv.names))
[17:02:51.214]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.214]         }, condition = base::local({
[17:02:51.214]             c <- base::c
[17:02:51.214]             inherits <- base::inherits
[17:02:51.214]             invokeRestart <- base::invokeRestart
[17:02:51.214]             length <- base::length
[17:02:51.214]             list <- base::list
[17:02:51.214]             seq.int <- base::seq.int
[17:02:51.214]             signalCondition <- base::signalCondition
[17:02:51.214]             sys.calls <- base::sys.calls
[17:02:51.214]             `[[` <- base::`[[`
[17:02:51.214]             `+` <- base::`+`
[17:02:51.214]             `<<-` <- base::`<<-`
[17:02:51.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.214]                   3L)]
[17:02:51.214]             }
[17:02:51.214]             function(cond) {
[17:02:51.214]                 is_error <- inherits(cond, "error")
[17:02:51.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.214]                   NULL)
[17:02:51.214]                 if (is_error) {
[17:02:51.214]                   sessionInformation <- function() {
[17:02:51.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.214]                       search = base::search(), system = base::Sys.info())
[17:02:51.214]                   }
[17:02:51.214]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.214]                     cond$call), session = sessionInformation(), 
[17:02:51.214]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.214]                   signalCondition(cond)
[17:02:51.214]                 }
[17:02:51.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.214]                 "immediateCondition"))) {
[17:02:51.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.214]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.214]                   if (TRUE && !signal) {
[17:02:51.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.214]                     {
[17:02:51.214]                       inherits <- base::inherits
[17:02:51.214]                       invokeRestart <- base::invokeRestart
[17:02:51.214]                       is.null <- base::is.null
[17:02:51.214]                       muffled <- FALSE
[17:02:51.214]                       if (inherits(cond, "message")) {
[17:02:51.214]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.214]                         if (muffled) 
[17:02:51.214]                           invokeRestart("muffleMessage")
[17:02:51.214]                       }
[17:02:51.214]                       else if (inherits(cond, "warning")) {
[17:02:51.214]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.214]                         if (muffled) 
[17:02:51.214]                           invokeRestart("muffleWarning")
[17:02:51.214]                       }
[17:02:51.214]                       else if (inherits(cond, "condition")) {
[17:02:51.214]                         if (!is.null(pattern)) {
[17:02:51.214]                           computeRestarts <- base::computeRestarts
[17:02:51.214]                           grepl <- base::grepl
[17:02:51.214]                           restarts <- computeRestarts(cond)
[17:02:51.214]                           for (restart in restarts) {
[17:02:51.214]                             name <- restart$name
[17:02:51.214]                             if (is.null(name)) 
[17:02:51.214]                               next
[17:02:51.214]                             if (!grepl(pattern, name)) 
[17:02:51.214]                               next
[17:02:51.214]                             invokeRestart(restart)
[17:02:51.214]                             muffled <- TRUE
[17:02:51.214]                             break
[17:02:51.214]                           }
[17:02:51.214]                         }
[17:02:51.214]                       }
[17:02:51.214]                       invisible(muffled)
[17:02:51.214]                     }
[17:02:51.214]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.214]                   }
[17:02:51.214]                 }
[17:02:51.214]                 else {
[17:02:51.214]                   if (TRUE) {
[17:02:51.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.214]                     {
[17:02:51.214]                       inherits <- base::inherits
[17:02:51.214]                       invokeRestart <- base::invokeRestart
[17:02:51.214]                       is.null <- base::is.null
[17:02:51.214]                       muffled <- FALSE
[17:02:51.214]                       if (inherits(cond, "message")) {
[17:02:51.214]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.214]                         if (muffled) 
[17:02:51.214]                           invokeRestart("muffleMessage")
[17:02:51.214]                       }
[17:02:51.214]                       else if (inherits(cond, "warning")) {
[17:02:51.214]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.214]                         if (muffled) 
[17:02:51.214]                           invokeRestart("muffleWarning")
[17:02:51.214]                       }
[17:02:51.214]                       else if (inherits(cond, "condition")) {
[17:02:51.214]                         if (!is.null(pattern)) {
[17:02:51.214]                           computeRestarts <- base::computeRestarts
[17:02:51.214]                           grepl <- base::grepl
[17:02:51.214]                           restarts <- computeRestarts(cond)
[17:02:51.214]                           for (restart in restarts) {
[17:02:51.214]                             name <- restart$name
[17:02:51.214]                             if (is.null(name)) 
[17:02:51.214]                               next
[17:02:51.214]                             if (!grepl(pattern, name)) 
[17:02:51.214]                               next
[17:02:51.214]                             invokeRestart(restart)
[17:02:51.214]                             muffled <- TRUE
[17:02:51.214]                             break
[17:02:51.214]                           }
[17:02:51.214]                         }
[17:02:51.214]                       }
[17:02:51.214]                       invisible(muffled)
[17:02:51.214]                     }
[17:02:51.214]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.214]                   }
[17:02:51.214]                 }
[17:02:51.214]             }
[17:02:51.214]         }))
[17:02:51.214]     }, error = function(ex) {
[17:02:51.214]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.214]                 ...future.rng), started = ...future.startTime, 
[17:02:51.214]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.214]             version = "1.8"), class = "FutureResult")
[17:02:51.214]     }, finally = {
[17:02:51.214]         if (!identical(...future.workdir, getwd())) 
[17:02:51.214]             setwd(...future.workdir)
[17:02:51.214]         {
[17:02:51.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.214]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.214]             }
[17:02:51.214]             base::options(...future.oldOptions)
[17:02:51.214]             if (.Platform$OS.type == "windows") {
[17:02:51.214]                 old_names <- names(...future.oldEnvVars)
[17:02:51.214]                 envs <- base::Sys.getenv()
[17:02:51.214]                 names <- names(envs)
[17:02:51.214]                 common <- intersect(names, old_names)
[17:02:51.214]                 added <- setdiff(names, old_names)
[17:02:51.214]                 removed <- setdiff(old_names, names)
[17:02:51.214]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.214]                   envs[common]]
[17:02:51.214]                 NAMES <- toupper(changed)
[17:02:51.214]                 args <- list()
[17:02:51.214]                 for (kk in seq_along(NAMES)) {
[17:02:51.214]                   name <- changed[[kk]]
[17:02:51.214]                   NAME <- NAMES[[kk]]
[17:02:51.214]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.214]                     next
[17:02:51.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.214]                 }
[17:02:51.214]                 NAMES <- toupper(added)
[17:02:51.214]                 for (kk in seq_along(NAMES)) {
[17:02:51.214]                   name <- added[[kk]]
[17:02:51.214]                   NAME <- NAMES[[kk]]
[17:02:51.214]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.214]                     next
[17:02:51.214]                   args[[name]] <- ""
[17:02:51.214]                 }
[17:02:51.214]                 NAMES <- toupper(removed)
[17:02:51.214]                 for (kk in seq_along(NAMES)) {
[17:02:51.214]                   name <- removed[[kk]]
[17:02:51.214]                   NAME <- NAMES[[kk]]
[17:02:51.214]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.214]                     next
[17:02:51.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.214]                 }
[17:02:51.214]                 if (length(args) > 0) 
[17:02:51.214]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.214]             }
[17:02:51.214]             else {
[17:02:51.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.214]             }
[17:02:51.214]             {
[17:02:51.214]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.214]                   0L) {
[17:02:51.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.214]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.214]                   base::options(opts)
[17:02:51.214]                 }
[17:02:51.214]                 {
[17:02:51.214]                   {
[17:02:51.214]                     NULL
[17:02:51.214]                     RNGkind("Mersenne-Twister")
[17:02:51.214]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.214]                       inherits = FALSE)
[17:02:51.214]                   }
[17:02:51.214]                   options(future.plan = NULL)
[17:02:51.214]                   if (is.na(NA_character_)) 
[17:02:51.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.214]                     .init = FALSE)
[17:02:51.214]                 }
[17:02:51.214]             }
[17:02:51.214]         }
[17:02:51.214]     })
[17:02:51.214]     if (TRUE) {
[17:02:51.214]         base::sink(type = "output", split = FALSE)
[17:02:51.214]         if (TRUE) {
[17:02:51.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.214]         }
[17:02:51.214]         else {
[17:02:51.214]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.214]         }
[17:02:51.214]         base::close(...future.stdout)
[17:02:51.214]         ...future.stdout <- NULL
[17:02:51.214]     }
[17:02:51.214]     ...future.result$conditions <- ...future.conditions
[17:02:51.214]     ...future.result$finished <- base::Sys.time()
[17:02:51.214]     ...future.result
[17:02:51.214] }
[17:02:51.216] assign_globals() ...
[17:02:51.216] List of 2
[17:02:51.216]  $ a : num 1
[17:02:51.216]  $ ii: int 3
[17:02:51.216]  - attr(*, "where")=List of 2
[17:02:51.216]   ..$ a :<environment: R_EmptyEnv> 
[17:02:51.216]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.216]  - attr(*, "resolved")= logi TRUE
[17:02:51.216]  - attr(*, "total_size")= num 112
[17:02:51.216]  - attr(*, "already-done")= logi TRUE
[17:02:51.219] - copied ‘a’ to environment
[17:02:51.219] - copied ‘ii’ to environment
[17:02:51.219] assign_globals() ... done
[17:02:51.219] plan(): Setting new future strategy stack:
[17:02:51.219] List of future strategies:
[17:02:51.219] 1. sequential:
[17:02:51.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.219]    - tweaked: FALSE
[17:02:51.219]    - call: NULL
[17:02:51.220] plan(): nbrOfWorkers() = 1
[17:02:51.220] plan(): Setting new future strategy stack:
[17:02:51.221] List of future strategies:
[17:02:51.221] 1. sequential:
[17:02:51.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.221]    - tweaked: FALSE
[17:02:51.221]    - call: plan(strategy)
[17:02:51.221] plan(): nbrOfWorkers() = 1
[17:02:51.221] SequentialFuture started (and completed)
[17:02:51.221] - Launch lazy future ... done
[17:02:51.221] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.222] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.222] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.224] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.224] Searching for globals ... DONE
[17:02:51.225] Resolving globals: TRUE
[17:02:51.225] Resolving any globals that are futures ...
[17:02:51.225] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.225] Resolving any globals that are futures ... DONE
[17:02:51.225] Resolving futures part of globals (recursively) ...
[17:02:51.225] resolve() on list ...
[17:02:51.226]  recursive: 99
[17:02:51.226]  length: 2
[17:02:51.226]  elements: ‘a’, ‘ii’
[17:02:51.226]  length: 1 (resolved future 1)
[17:02:51.226]  length: 0 (resolved future 2)
[17:02:51.226] resolve() on list ... DONE
[17:02:51.226] - globals: [2] ‘a’, ‘ii’
[17:02:51.226] Resolving futures part of globals (recursively) ... DONE
[17:02:51.226] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:51.227] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.227] - globals: [2] ‘a’, ‘ii’
[17:02:51.227] 
[17:02:51.227] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.228] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.228] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.232] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.232] Searching for globals ... DONE
[17:02:51.232] Resolving globals: TRUE
[17:02:51.232] Resolving any globals that are futures ...
[17:02:51.232] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.232] Resolving any globals that are futures ... DONE
[17:02:51.232] Resolving futures part of globals (recursively) ...
[17:02:51.233] resolve() on list ...
[17:02:51.233]  recursive: 99
[17:02:51.233]  length: 2
[17:02:51.233]  elements: ‘a’, ‘ii’
[17:02:51.233]  length: 1 (resolved future 1)
[17:02:51.233]  length: 0 (resolved future 2)
[17:02:51.233] resolve() on list ... DONE
[17:02:51.233] - globals: [2] ‘a’, ‘ii’
[17:02:51.233] Resolving futures part of globals (recursively) ... DONE
[17:02:51.234] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:51.234] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.234] - globals: [2] ‘a’, ‘ii’
[17:02:51.234] 
[17:02:51.234] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.235] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.235] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.237] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.237] Searching for globals ... DONE
[17:02:51.237] Resolving globals: TRUE
[17:02:51.238] Resolving any globals that are futures ...
[17:02:51.238] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:51.238] Resolving any globals that are futures ... DONE
[17:02:51.238] Resolving futures part of globals (recursively) ...
[17:02:51.239] resolve() on list ...
[17:02:51.239]  recursive: 99
[17:02:51.239]  length: 2
[17:02:51.239]  elements: ‘a’, ‘ii’
[17:02:51.239]  length: 1 (resolved future 1)
[17:02:51.239]  length: 0 (resolved future 2)
[17:02:51.239] resolve() on list ... DONE
[17:02:51.239] - globals: [2] ‘a’, ‘ii’
[17:02:51.239] Resolving futures part of globals (recursively) ... DONE
[17:02:51.240] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:51.240] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.240] - globals: [2] ‘a’, ‘ii’
[17:02:51.240] 
[17:02:51.240] getGlobalsAndPackages() ... DONE
[17:02:51.241] run() for ‘Future’ ...
[17:02:51.241] - state: ‘created’
[17:02:51.241] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.241] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.241]   - Field: ‘label’
[17:02:51.241]   - Field: ‘local’
[17:02:51.242]   - Field: ‘owner’
[17:02:51.242]   - Field: ‘envir’
[17:02:51.242]   - Field: ‘packages’
[17:02:51.242]   - Field: ‘gc’
[17:02:51.242]   - Field: ‘conditions’
[17:02:51.242]   - Field: ‘expr’
[17:02:51.242]   - Field: ‘uuid’
[17:02:51.242]   - Field: ‘seed’
[17:02:51.242]   - Field: ‘version’
[17:02:51.242]   - Field: ‘result’
[17:02:51.243]   - Field: ‘asynchronous’
[17:02:51.243]   - Field: ‘calls’
[17:02:51.243]   - Field: ‘globals’
[17:02:51.243]   - Field: ‘stdout’
[17:02:51.243]   - Field: ‘earlySignal’
[17:02:51.243]   - Field: ‘lazy’
[17:02:51.243]   - Field: ‘state’
[17:02:51.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.243] - Launch lazy future ...
[17:02:51.243] Packages needed by the future expression (n = 0): <none>
[17:02:51.244] Packages needed by future strategies (n = 0): <none>
[17:02:51.244] {
[17:02:51.244]     {
[17:02:51.244]         {
[17:02:51.244]             ...future.startTime <- base::Sys.time()
[17:02:51.244]             {
[17:02:51.244]                 {
[17:02:51.244]                   {
[17:02:51.244]                     base::local({
[17:02:51.244]                       has_future <- base::requireNamespace("future", 
[17:02:51.244]                         quietly = TRUE)
[17:02:51.244]                       if (has_future) {
[17:02:51.244]                         ns <- base::getNamespace("future")
[17:02:51.244]                         version <- ns[[".package"]][["version"]]
[17:02:51.244]                         if (is.null(version)) 
[17:02:51.244]                           version <- utils::packageVersion("future")
[17:02:51.244]                       }
[17:02:51.244]                       else {
[17:02:51.244]                         version <- NULL
[17:02:51.244]                       }
[17:02:51.244]                       if (!has_future || version < "1.8.0") {
[17:02:51.244]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.244]                           "", base::R.version$version.string), 
[17:02:51.244]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.244]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.244]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.244]                             "release", "version")], collapse = " "), 
[17:02:51.244]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.244]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.244]                           info)
[17:02:51.244]                         info <- base::paste(info, collapse = "; ")
[17:02:51.244]                         if (!has_future) {
[17:02:51.244]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.244]                             info)
[17:02:51.244]                         }
[17:02:51.244]                         else {
[17:02:51.244]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.244]                             info, version)
[17:02:51.244]                         }
[17:02:51.244]                         base::stop(msg)
[17:02:51.244]                       }
[17:02:51.244]                     })
[17:02:51.244]                   }
[17:02:51.244]                   ...future.strategy.old <- future::plan("list")
[17:02:51.244]                   options(future.plan = NULL)
[17:02:51.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.244]                 }
[17:02:51.244]                 ...future.workdir <- getwd()
[17:02:51.244]             }
[17:02:51.244]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.244]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.244]         }
[17:02:51.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.244]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.244]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.244]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.244]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.244]             base::names(...future.oldOptions))
[17:02:51.244]     }
[17:02:51.244]     if (FALSE) {
[17:02:51.244]     }
[17:02:51.244]     else {
[17:02:51.244]         if (TRUE) {
[17:02:51.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.244]                 open = "w")
[17:02:51.244]         }
[17:02:51.244]         else {
[17:02:51.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.244]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.244]         }
[17:02:51.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.244]             base::sink(type = "output", split = FALSE)
[17:02:51.244]             base::close(...future.stdout)
[17:02:51.244]         }, add = TRUE)
[17:02:51.244]     }
[17:02:51.244]     ...future.frame <- base::sys.nframe()
[17:02:51.244]     ...future.conditions <- base::list()
[17:02:51.244]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.244]     if (FALSE) {
[17:02:51.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.244]     }
[17:02:51.244]     ...future.result <- base::tryCatch({
[17:02:51.244]         base::withCallingHandlers({
[17:02:51.244]             ...future.value <- base::withVisible(base::local({
[17:02:51.244]                 b <- a * ii
[17:02:51.244]                 a <- 0
[17:02:51.244]                 b
[17:02:51.244]             }))
[17:02:51.244]             future::FutureResult(value = ...future.value$value, 
[17:02:51.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.244]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.244]                     ...future.globalenv.names))
[17:02:51.244]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.244]         }, condition = base::local({
[17:02:51.244]             c <- base::c
[17:02:51.244]             inherits <- base::inherits
[17:02:51.244]             invokeRestart <- base::invokeRestart
[17:02:51.244]             length <- base::length
[17:02:51.244]             list <- base::list
[17:02:51.244]             seq.int <- base::seq.int
[17:02:51.244]             signalCondition <- base::signalCondition
[17:02:51.244]             sys.calls <- base::sys.calls
[17:02:51.244]             `[[` <- base::`[[`
[17:02:51.244]             `+` <- base::`+`
[17:02:51.244]             `<<-` <- base::`<<-`
[17:02:51.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.244]                   3L)]
[17:02:51.244]             }
[17:02:51.244]             function(cond) {
[17:02:51.244]                 is_error <- inherits(cond, "error")
[17:02:51.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.244]                   NULL)
[17:02:51.244]                 if (is_error) {
[17:02:51.244]                   sessionInformation <- function() {
[17:02:51.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.244]                       search = base::search(), system = base::Sys.info())
[17:02:51.244]                   }
[17:02:51.244]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.244]                     cond$call), session = sessionInformation(), 
[17:02:51.244]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.244]                   signalCondition(cond)
[17:02:51.244]                 }
[17:02:51.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.244]                 "immediateCondition"))) {
[17:02:51.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.244]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.244]                   if (TRUE && !signal) {
[17:02:51.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.244]                     {
[17:02:51.244]                       inherits <- base::inherits
[17:02:51.244]                       invokeRestart <- base::invokeRestart
[17:02:51.244]                       is.null <- base::is.null
[17:02:51.244]                       muffled <- FALSE
[17:02:51.244]                       if (inherits(cond, "message")) {
[17:02:51.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.244]                         if (muffled) 
[17:02:51.244]                           invokeRestart("muffleMessage")
[17:02:51.244]                       }
[17:02:51.244]                       else if (inherits(cond, "warning")) {
[17:02:51.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.244]                         if (muffled) 
[17:02:51.244]                           invokeRestart("muffleWarning")
[17:02:51.244]                       }
[17:02:51.244]                       else if (inherits(cond, "condition")) {
[17:02:51.244]                         if (!is.null(pattern)) {
[17:02:51.244]                           computeRestarts <- base::computeRestarts
[17:02:51.244]                           grepl <- base::grepl
[17:02:51.244]                           restarts <- computeRestarts(cond)
[17:02:51.244]                           for (restart in restarts) {
[17:02:51.244]                             name <- restart$name
[17:02:51.244]                             if (is.null(name)) 
[17:02:51.244]                               next
[17:02:51.244]                             if (!grepl(pattern, name)) 
[17:02:51.244]                               next
[17:02:51.244]                             invokeRestart(restart)
[17:02:51.244]                             muffled <- TRUE
[17:02:51.244]                             break
[17:02:51.244]                           }
[17:02:51.244]                         }
[17:02:51.244]                       }
[17:02:51.244]                       invisible(muffled)
[17:02:51.244]                     }
[17:02:51.244]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.244]                   }
[17:02:51.244]                 }
[17:02:51.244]                 else {
[17:02:51.244]                   if (TRUE) {
[17:02:51.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.244]                     {
[17:02:51.244]                       inherits <- base::inherits
[17:02:51.244]                       invokeRestart <- base::invokeRestart
[17:02:51.244]                       is.null <- base::is.null
[17:02:51.244]                       muffled <- FALSE
[17:02:51.244]                       if (inherits(cond, "message")) {
[17:02:51.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.244]                         if (muffled) 
[17:02:51.244]                           invokeRestart("muffleMessage")
[17:02:51.244]                       }
[17:02:51.244]                       else if (inherits(cond, "warning")) {
[17:02:51.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.244]                         if (muffled) 
[17:02:51.244]                           invokeRestart("muffleWarning")
[17:02:51.244]                       }
[17:02:51.244]                       else if (inherits(cond, "condition")) {
[17:02:51.244]                         if (!is.null(pattern)) {
[17:02:51.244]                           computeRestarts <- base::computeRestarts
[17:02:51.244]                           grepl <- base::grepl
[17:02:51.244]                           restarts <- computeRestarts(cond)
[17:02:51.244]                           for (restart in restarts) {
[17:02:51.244]                             name <- restart$name
[17:02:51.244]                             if (is.null(name)) 
[17:02:51.244]                               next
[17:02:51.244]                             if (!grepl(pattern, name)) 
[17:02:51.244]                               next
[17:02:51.244]                             invokeRestart(restart)
[17:02:51.244]                             muffled <- TRUE
[17:02:51.244]                             break
[17:02:51.244]                           }
[17:02:51.244]                         }
[17:02:51.244]                       }
[17:02:51.244]                       invisible(muffled)
[17:02:51.244]                     }
[17:02:51.244]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.244]                   }
[17:02:51.244]                 }
[17:02:51.244]             }
[17:02:51.244]         }))
[17:02:51.244]     }, error = function(ex) {
[17:02:51.244]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.244]                 ...future.rng), started = ...future.startTime, 
[17:02:51.244]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.244]             version = "1.8"), class = "FutureResult")
[17:02:51.244]     }, finally = {
[17:02:51.244]         if (!identical(...future.workdir, getwd())) 
[17:02:51.244]             setwd(...future.workdir)
[17:02:51.244]         {
[17:02:51.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.244]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.244]             }
[17:02:51.244]             base::options(...future.oldOptions)
[17:02:51.244]             if (.Platform$OS.type == "windows") {
[17:02:51.244]                 old_names <- names(...future.oldEnvVars)
[17:02:51.244]                 envs <- base::Sys.getenv()
[17:02:51.244]                 names <- names(envs)
[17:02:51.244]                 common <- intersect(names, old_names)
[17:02:51.244]                 added <- setdiff(names, old_names)
[17:02:51.244]                 removed <- setdiff(old_names, names)
[17:02:51.244]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.244]                   envs[common]]
[17:02:51.244]                 NAMES <- toupper(changed)
[17:02:51.244]                 args <- list()
[17:02:51.244]                 for (kk in seq_along(NAMES)) {
[17:02:51.244]                   name <- changed[[kk]]
[17:02:51.244]                   NAME <- NAMES[[kk]]
[17:02:51.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.244]                     next
[17:02:51.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.244]                 }
[17:02:51.244]                 NAMES <- toupper(added)
[17:02:51.244]                 for (kk in seq_along(NAMES)) {
[17:02:51.244]                   name <- added[[kk]]
[17:02:51.244]                   NAME <- NAMES[[kk]]
[17:02:51.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.244]                     next
[17:02:51.244]                   args[[name]] <- ""
[17:02:51.244]                 }
[17:02:51.244]                 NAMES <- toupper(removed)
[17:02:51.244]                 for (kk in seq_along(NAMES)) {
[17:02:51.244]                   name <- removed[[kk]]
[17:02:51.244]                   NAME <- NAMES[[kk]]
[17:02:51.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.244]                     next
[17:02:51.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.244]                 }
[17:02:51.244]                 if (length(args) > 0) 
[17:02:51.244]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.244]             }
[17:02:51.244]             else {
[17:02:51.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.244]             }
[17:02:51.244]             {
[17:02:51.244]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.244]                   0L) {
[17:02:51.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.244]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.244]                   base::options(opts)
[17:02:51.244]                 }
[17:02:51.244]                 {
[17:02:51.244]                   {
[17:02:51.244]                     NULL
[17:02:51.244]                     RNGkind("Mersenne-Twister")
[17:02:51.244]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.244]                       inherits = FALSE)
[17:02:51.244]                   }
[17:02:51.244]                   options(future.plan = NULL)
[17:02:51.244]                   if (is.na(NA_character_)) 
[17:02:51.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.244]                     .init = FALSE)
[17:02:51.244]                 }
[17:02:51.244]             }
[17:02:51.244]         }
[17:02:51.244]     })
[17:02:51.244]     if (TRUE) {
[17:02:51.244]         base::sink(type = "output", split = FALSE)
[17:02:51.244]         if (TRUE) {
[17:02:51.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.244]         }
[17:02:51.244]         else {
[17:02:51.244]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.244]         }
[17:02:51.244]         base::close(...future.stdout)
[17:02:51.244]         ...future.stdout <- NULL
[17:02:51.244]     }
[17:02:51.244]     ...future.result$conditions <- ...future.conditions
[17:02:51.244]     ...future.result$finished <- base::Sys.time()
[17:02:51.244]     ...future.result
[17:02:51.244] }
[17:02:51.246] assign_globals() ...
[17:02:51.246] List of 2
[17:02:51.246]  $ a : num 1
[17:02:51.246]  $ ii: int 1
[17:02:51.246]  - attr(*, "where")=List of 2
[17:02:51.246]   ..$ a :<environment: R_EmptyEnv> 
[17:02:51.246]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.246]  - attr(*, "resolved")= logi TRUE
[17:02:51.246]  - attr(*, "total_size")= num 112
[17:02:51.246]  - attr(*, "already-done")= logi TRUE
[17:02:51.249] - copied ‘a’ to environment
[17:02:51.249] - copied ‘ii’ to environment
[17:02:51.249] assign_globals() ... done
[17:02:51.249] plan(): Setting new future strategy stack:
[17:02:51.249] List of future strategies:
[17:02:51.249] 1. sequential:
[17:02:51.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.249]    - tweaked: FALSE
[17:02:51.249]    - call: NULL
[17:02:51.250] plan(): nbrOfWorkers() = 1
[17:02:51.251] plan(): Setting new future strategy stack:
[17:02:51.251] List of future strategies:
[17:02:51.251] 1. sequential:
[17:02:51.251]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.251]    - tweaked: FALSE
[17:02:51.251]    - call: plan(strategy)
[17:02:51.251] plan(): nbrOfWorkers() = 1
[17:02:51.251] SequentialFuture started (and completed)
[17:02:51.251] - Launch lazy future ... done
[17:02:51.252] run() for ‘SequentialFuture’ ... done
[17:02:51.252] run() for ‘Future’ ...
[17:02:51.252] - state: ‘created’
[17:02:51.252] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.252] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.252]   - Field: ‘label’
[17:02:51.253]   - Field: ‘local’
[17:02:51.253]   - Field: ‘owner’
[17:02:51.253]   - Field: ‘envir’
[17:02:51.253]   - Field: ‘packages’
[17:02:51.253]   - Field: ‘gc’
[17:02:51.253]   - Field: ‘conditions’
[17:02:51.253]   - Field: ‘expr’
[17:02:51.253]   - Field: ‘uuid’
[17:02:51.253]   - Field: ‘seed’
[17:02:51.253]   - Field: ‘version’
[17:02:51.253]   - Field: ‘result’
[17:02:51.254]   - Field: ‘asynchronous’
[17:02:51.254]   - Field: ‘calls’
[17:02:51.254]   - Field: ‘globals’
[17:02:51.254]   - Field: ‘stdout’
[17:02:51.254]   - Field: ‘earlySignal’
[17:02:51.254]   - Field: ‘lazy’
[17:02:51.254]   - Field: ‘state’
[17:02:51.254] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.254] - Launch lazy future ...
[17:02:51.254] Packages needed by the future expression (n = 0): <none>
[17:02:51.255] Packages needed by future strategies (n = 0): <none>
[17:02:51.257] {
[17:02:51.257]     {
[17:02:51.257]         {
[17:02:51.257]             ...future.startTime <- base::Sys.time()
[17:02:51.257]             {
[17:02:51.257]                 {
[17:02:51.257]                   {
[17:02:51.257]                     base::local({
[17:02:51.257]                       has_future <- base::requireNamespace("future", 
[17:02:51.257]                         quietly = TRUE)
[17:02:51.257]                       if (has_future) {
[17:02:51.257]                         ns <- base::getNamespace("future")
[17:02:51.257]                         version <- ns[[".package"]][["version"]]
[17:02:51.257]                         if (is.null(version)) 
[17:02:51.257]                           version <- utils::packageVersion("future")
[17:02:51.257]                       }
[17:02:51.257]                       else {
[17:02:51.257]                         version <- NULL
[17:02:51.257]                       }
[17:02:51.257]                       if (!has_future || version < "1.8.0") {
[17:02:51.257]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.257]                           "", base::R.version$version.string), 
[17:02:51.257]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.257]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.257]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.257]                             "release", "version")], collapse = " "), 
[17:02:51.257]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.257]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.257]                           info)
[17:02:51.257]                         info <- base::paste(info, collapse = "; ")
[17:02:51.257]                         if (!has_future) {
[17:02:51.257]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.257]                             info)
[17:02:51.257]                         }
[17:02:51.257]                         else {
[17:02:51.257]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.257]                             info, version)
[17:02:51.257]                         }
[17:02:51.257]                         base::stop(msg)
[17:02:51.257]                       }
[17:02:51.257]                     })
[17:02:51.257]                   }
[17:02:51.257]                   ...future.strategy.old <- future::plan("list")
[17:02:51.257]                   options(future.plan = NULL)
[17:02:51.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.257]                 }
[17:02:51.257]                 ...future.workdir <- getwd()
[17:02:51.257]             }
[17:02:51.257]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.257]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.257]         }
[17:02:51.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.257]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.257]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.257]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.257]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.257]             base::names(...future.oldOptions))
[17:02:51.257]     }
[17:02:51.257]     if (FALSE) {
[17:02:51.257]     }
[17:02:51.257]     else {
[17:02:51.257]         if (TRUE) {
[17:02:51.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.257]                 open = "w")
[17:02:51.257]         }
[17:02:51.257]         else {
[17:02:51.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.257]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.257]         }
[17:02:51.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.257]             base::sink(type = "output", split = FALSE)
[17:02:51.257]             base::close(...future.stdout)
[17:02:51.257]         }, add = TRUE)
[17:02:51.257]     }
[17:02:51.257]     ...future.frame <- base::sys.nframe()
[17:02:51.257]     ...future.conditions <- base::list()
[17:02:51.257]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.257]     if (FALSE) {
[17:02:51.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.257]     }
[17:02:51.257]     ...future.result <- base::tryCatch({
[17:02:51.257]         base::withCallingHandlers({
[17:02:51.257]             ...future.value <- base::withVisible(base::local({
[17:02:51.257]                 b <- a * ii
[17:02:51.257]                 a <- 0
[17:02:51.257]                 b
[17:02:51.257]             }))
[17:02:51.257]             future::FutureResult(value = ...future.value$value, 
[17:02:51.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.257]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.257]                     ...future.globalenv.names))
[17:02:51.257]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.257]         }, condition = base::local({
[17:02:51.257]             c <- base::c
[17:02:51.257]             inherits <- base::inherits
[17:02:51.257]             invokeRestart <- base::invokeRestart
[17:02:51.257]             length <- base::length
[17:02:51.257]             list <- base::list
[17:02:51.257]             seq.int <- base::seq.int
[17:02:51.257]             signalCondition <- base::signalCondition
[17:02:51.257]             sys.calls <- base::sys.calls
[17:02:51.257]             `[[` <- base::`[[`
[17:02:51.257]             `+` <- base::`+`
[17:02:51.257]             `<<-` <- base::`<<-`
[17:02:51.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.257]                   3L)]
[17:02:51.257]             }
[17:02:51.257]             function(cond) {
[17:02:51.257]                 is_error <- inherits(cond, "error")
[17:02:51.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.257]                   NULL)
[17:02:51.257]                 if (is_error) {
[17:02:51.257]                   sessionInformation <- function() {
[17:02:51.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.257]                       search = base::search(), system = base::Sys.info())
[17:02:51.257]                   }
[17:02:51.257]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.257]                     cond$call), session = sessionInformation(), 
[17:02:51.257]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.257]                   signalCondition(cond)
[17:02:51.257]                 }
[17:02:51.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.257]                 "immediateCondition"))) {
[17:02:51.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.257]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.257]                   if (TRUE && !signal) {
[17:02:51.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.257]                     {
[17:02:51.257]                       inherits <- base::inherits
[17:02:51.257]                       invokeRestart <- base::invokeRestart
[17:02:51.257]                       is.null <- base::is.null
[17:02:51.257]                       muffled <- FALSE
[17:02:51.257]                       if (inherits(cond, "message")) {
[17:02:51.257]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.257]                         if (muffled) 
[17:02:51.257]                           invokeRestart("muffleMessage")
[17:02:51.257]                       }
[17:02:51.257]                       else if (inherits(cond, "warning")) {
[17:02:51.257]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.257]                         if (muffled) 
[17:02:51.257]                           invokeRestart("muffleWarning")
[17:02:51.257]                       }
[17:02:51.257]                       else if (inherits(cond, "condition")) {
[17:02:51.257]                         if (!is.null(pattern)) {
[17:02:51.257]                           computeRestarts <- base::computeRestarts
[17:02:51.257]                           grepl <- base::grepl
[17:02:51.257]                           restarts <- computeRestarts(cond)
[17:02:51.257]                           for (restart in restarts) {
[17:02:51.257]                             name <- restart$name
[17:02:51.257]                             if (is.null(name)) 
[17:02:51.257]                               next
[17:02:51.257]                             if (!grepl(pattern, name)) 
[17:02:51.257]                               next
[17:02:51.257]                             invokeRestart(restart)
[17:02:51.257]                             muffled <- TRUE
[17:02:51.257]                             break
[17:02:51.257]                           }
[17:02:51.257]                         }
[17:02:51.257]                       }
[17:02:51.257]                       invisible(muffled)
[17:02:51.257]                     }
[17:02:51.257]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.257]                   }
[17:02:51.257]                 }
[17:02:51.257]                 else {
[17:02:51.257]                   if (TRUE) {
[17:02:51.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.257]                     {
[17:02:51.257]                       inherits <- base::inherits
[17:02:51.257]                       invokeRestart <- base::invokeRestart
[17:02:51.257]                       is.null <- base::is.null
[17:02:51.257]                       muffled <- FALSE
[17:02:51.257]                       if (inherits(cond, "message")) {
[17:02:51.257]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.257]                         if (muffled) 
[17:02:51.257]                           invokeRestart("muffleMessage")
[17:02:51.257]                       }
[17:02:51.257]                       else if (inherits(cond, "warning")) {
[17:02:51.257]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.257]                         if (muffled) 
[17:02:51.257]                           invokeRestart("muffleWarning")
[17:02:51.257]                       }
[17:02:51.257]                       else if (inherits(cond, "condition")) {
[17:02:51.257]                         if (!is.null(pattern)) {
[17:02:51.257]                           computeRestarts <- base::computeRestarts
[17:02:51.257]                           grepl <- base::grepl
[17:02:51.257]                           restarts <- computeRestarts(cond)
[17:02:51.257]                           for (restart in restarts) {
[17:02:51.257]                             name <- restart$name
[17:02:51.257]                             if (is.null(name)) 
[17:02:51.257]                               next
[17:02:51.257]                             if (!grepl(pattern, name)) 
[17:02:51.257]                               next
[17:02:51.257]                             invokeRestart(restart)
[17:02:51.257]                             muffled <- TRUE
[17:02:51.257]                             break
[17:02:51.257]                           }
[17:02:51.257]                         }
[17:02:51.257]                       }
[17:02:51.257]                       invisible(muffled)
[17:02:51.257]                     }
[17:02:51.257]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.257]                   }
[17:02:51.257]                 }
[17:02:51.257]             }
[17:02:51.257]         }))
[17:02:51.257]     }, error = function(ex) {
[17:02:51.257]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.257]                 ...future.rng), started = ...future.startTime, 
[17:02:51.257]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.257]             version = "1.8"), class = "FutureResult")
[17:02:51.257]     }, finally = {
[17:02:51.257]         if (!identical(...future.workdir, getwd())) 
[17:02:51.257]             setwd(...future.workdir)
[17:02:51.257]         {
[17:02:51.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.257]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.257]             }
[17:02:51.257]             base::options(...future.oldOptions)
[17:02:51.257]             if (.Platform$OS.type == "windows") {
[17:02:51.257]                 old_names <- names(...future.oldEnvVars)
[17:02:51.257]                 envs <- base::Sys.getenv()
[17:02:51.257]                 names <- names(envs)
[17:02:51.257]                 common <- intersect(names, old_names)
[17:02:51.257]                 added <- setdiff(names, old_names)
[17:02:51.257]                 removed <- setdiff(old_names, names)
[17:02:51.257]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.257]                   envs[common]]
[17:02:51.257]                 NAMES <- toupper(changed)
[17:02:51.257]                 args <- list()
[17:02:51.257]                 for (kk in seq_along(NAMES)) {
[17:02:51.257]                   name <- changed[[kk]]
[17:02:51.257]                   NAME <- NAMES[[kk]]
[17:02:51.257]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.257]                     next
[17:02:51.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.257]                 }
[17:02:51.257]                 NAMES <- toupper(added)
[17:02:51.257]                 for (kk in seq_along(NAMES)) {
[17:02:51.257]                   name <- added[[kk]]
[17:02:51.257]                   NAME <- NAMES[[kk]]
[17:02:51.257]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.257]                     next
[17:02:51.257]                   args[[name]] <- ""
[17:02:51.257]                 }
[17:02:51.257]                 NAMES <- toupper(removed)
[17:02:51.257]                 for (kk in seq_along(NAMES)) {
[17:02:51.257]                   name <- removed[[kk]]
[17:02:51.257]                   NAME <- NAMES[[kk]]
[17:02:51.257]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.257]                     next
[17:02:51.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.257]                 }
[17:02:51.257]                 if (length(args) > 0) 
[17:02:51.257]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.257]             }
[17:02:51.257]             else {
[17:02:51.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.257]             }
[17:02:51.257]             {
[17:02:51.257]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.257]                   0L) {
[17:02:51.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.257]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.257]                   base::options(opts)
[17:02:51.257]                 }
[17:02:51.257]                 {
[17:02:51.257]                   {
[17:02:51.257]                     NULL
[17:02:51.257]                     RNGkind("Mersenne-Twister")
[17:02:51.257]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.257]                       inherits = FALSE)
[17:02:51.257]                   }
[17:02:51.257]                   options(future.plan = NULL)
[17:02:51.257]                   if (is.na(NA_character_)) 
[17:02:51.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.257]                     .init = FALSE)
[17:02:51.257]                 }
[17:02:51.257]             }
[17:02:51.257]         }
[17:02:51.257]     })
[17:02:51.257]     if (TRUE) {
[17:02:51.257]         base::sink(type = "output", split = FALSE)
[17:02:51.257]         if (TRUE) {
[17:02:51.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.257]         }
[17:02:51.257]         else {
[17:02:51.257]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.257]         }
[17:02:51.257]         base::close(...future.stdout)
[17:02:51.257]         ...future.stdout <- NULL
[17:02:51.257]     }
[17:02:51.257]     ...future.result$conditions <- ...future.conditions
[17:02:51.257]     ...future.result$finished <- base::Sys.time()
[17:02:51.257]     ...future.result
[17:02:51.257] }
[17:02:51.258] assign_globals() ...
[17:02:51.259] List of 2
[17:02:51.259]  $ a : num 1
[17:02:51.259]  $ ii: int 2
[17:02:51.259]  - attr(*, "where")=List of 2
[17:02:51.259]   ..$ a :<environment: R_EmptyEnv> 
[17:02:51.259]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.259]  - attr(*, "resolved")= logi TRUE
[17:02:51.259]  - attr(*, "total_size")= num 112
[17:02:51.259]  - attr(*, "already-done")= logi TRUE
[17:02:51.262] - copied ‘a’ to environment
[17:02:51.262] - copied ‘ii’ to environment
[17:02:51.262] assign_globals() ... done
[17:02:51.262] plan(): Setting new future strategy stack:
[17:02:51.262] List of future strategies:
[17:02:51.262] 1. sequential:
[17:02:51.262]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.262]    - tweaked: FALSE
[17:02:51.262]    - call: NULL
[17:02:51.263] plan(): nbrOfWorkers() = 1
[17:02:51.263] plan(): Setting new future strategy stack:
[17:02:51.263] List of future strategies:
[17:02:51.263] 1. sequential:
[17:02:51.263]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.263]    - tweaked: FALSE
[17:02:51.263]    - call: plan(strategy)
[17:02:51.264] plan(): nbrOfWorkers() = 1
[17:02:51.264] SequentialFuture started (and completed)
[17:02:51.264] - Launch lazy future ... done
[17:02:51.264] run() for ‘SequentialFuture’ ... done
[17:02:51.264] run() for ‘Future’ ...
[17:02:51.264] - state: ‘created’
[17:02:51.265] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.265] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.265]   - Field: ‘label’
[17:02:51.265]   - Field: ‘local’
[17:02:51.265]   - Field: ‘owner’
[17:02:51.265]   - Field: ‘envir’
[17:02:51.265]   - Field: ‘packages’
[17:02:51.266]   - Field: ‘gc’
[17:02:51.266]   - Field: ‘conditions’
[17:02:51.266]   - Field: ‘expr’
[17:02:51.266]   - Field: ‘uuid’
[17:02:51.266]   - Field: ‘seed’
[17:02:51.266]   - Field: ‘version’
[17:02:51.266]   - Field: ‘result’
[17:02:51.266]   - Field: ‘asynchronous’
[17:02:51.266]   - Field: ‘calls’
[17:02:51.266]   - Field: ‘globals’
[17:02:51.266]   - Field: ‘stdout’
[17:02:51.267]   - Field: ‘earlySignal’
[17:02:51.267]   - Field: ‘lazy’
[17:02:51.267]   - Field: ‘state’
[17:02:51.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.267] - Launch lazy future ...
[17:02:51.267] Packages needed by the future expression (n = 0): <none>
[17:02:51.267] Packages needed by future strategies (n = 0): <none>
[17:02:51.268] {
[17:02:51.268]     {
[17:02:51.268]         {
[17:02:51.268]             ...future.startTime <- base::Sys.time()
[17:02:51.268]             {
[17:02:51.268]                 {
[17:02:51.268]                   {
[17:02:51.268]                     base::local({
[17:02:51.268]                       has_future <- base::requireNamespace("future", 
[17:02:51.268]                         quietly = TRUE)
[17:02:51.268]                       if (has_future) {
[17:02:51.268]                         ns <- base::getNamespace("future")
[17:02:51.268]                         version <- ns[[".package"]][["version"]]
[17:02:51.268]                         if (is.null(version)) 
[17:02:51.268]                           version <- utils::packageVersion("future")
[17:02:51.268]                       }
[17:02:51.268]                       else {
[17:02:51.268]                         version <- NULL
[17:02:51.268]                       }
[17:02:51.268]                       if (!has_future || version < "1.8.0") {
[17:02:51.268]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.268]                           "", base::R.version$version.string), 
[17:02:51.268]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.268]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.268]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.268]                             "release", "version")], collapse = " "), 
[17:02:51.268]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.268]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.268]                           info)
[17:02:51.268]                         info <- base::paste(info, collapse = "; ")
[17:02:51.268]                         if (!has_future) {
[17:02:51.268]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.268]                             info)
[17:02:51.268]                         }
[17:02:51.268]                         else {
[17:02:51.268]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.268]                             info, version)
[17:02:51.268]                         }
[17:02:51.268]                         base::stop(msg)
[17:02:51.268]                       }
[17:02:51.268]                     })
[17:02:51.268]                   }
[17:02:51.268]                   ...future.strategy.old <- future::plan("list")
[17:02:51.268]                   options(future.plan = NULL)
[17:02:51.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.268]                 }
[17:02:51.268]                 ...future.workdir <- getwd()
[17:02:51.268]             }
[17:02:51.268]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.268]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.268]         }
[17:02:51.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.268]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.268]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.268]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.268]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.268]             base::names(...future.oldOptions))
[17:02:51.268]     }
[17:02:51.268]     if (FALSE) {
[17:02:51.268]     }
[17:02:51.268]     else {
[17:02:51.268]         if (TRUE) {
[17:02:51.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.268]                 open = "w")
[17:02:51.268]         }
[17:02:51.268]         else {
[17:02:51.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.268]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.268]         }
[17:02:51.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.268]             base::sink(type = "output", split = FALSE)
[17:02:51.268]             base::close(...future.stdout)
[17:02:51.268]         }, add = TRUE)
[17:02:51.268]     }
[17:02:51.268]     ...future.frame <- base::sys.nframe()
[17:02:51.268]     ...future.conditions <- base::list()
[17:02:51.268]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.268]     if (FALSE) {
[17:02:51.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.268]     }
[17:02:51.268]     ...future.result <- base::tryCatch({
[17:02:51.268]         base::withCallingHandlers({
[17:02:51.268]             ...future.value <- base::withVisible(base::local({
[17:02:51.268]                 b <- a * ii
[17:02:51.268]                 a <- 0
[17:02:51.268]                 b
[17:02:51.268]             }))
[17:02:51.268]             future::FutureResult(value = ...future.value$value, 
[17:02:51.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.268]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.268]                     ...future.globalenv.names))
[17:02:51.268]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.268]         }, condition = base::local({
[17:02:51.268]             c <- base::c
[17:02:51.268]             inherits <- base::inherits
[17:02:51.268]             invokeRestart <- base::invokeRestart
[17:02:51.268]             length <- base::length
[17:02:51.268]             list <- base::list
[17:02:51.268]             seq.int <- base::seq.int
[17:02:51.268]             signalCondition <- base::signalCondition
[17:02:51.268]             sys.calls <- base::sys.calls
[17:02:51.268]             `[[` <- base::`[[`
[17:02:51.268]             `+` <- base::`+`
[17:02:51.268]             `<<-` <- base::`<<-`
[17:02:51.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.268]                   3L)]
[17:02:51.268]             }
[17:02:51.268]             function(cond) {
[17:02:51.268]                 is_error <- inherits(cond, "error")
[17:02:51.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.268]                   NULL)
[17:02:51.268]                 if (is_error) {
[17:02:51.268]                   sessionInformation <- function() {
[17:02:51.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.268]                       search = base::search(), system = base::Sys.info())
[17:02:51.268]                   }
[17:02:51.268]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.268]                     cond$call), session = sessionInformation(), 
[17:02:51.268]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.268]                   signalCondition(cond)
[17:02:51.268]                 }
[17:02:51.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.268]                 "immediateCondition"))) {
[17:02:51.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.268]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.268]                   if (TRUE && !signal) {
[17:02:51.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.268]                     {
[17:02:51.268]                       inherits <- base::inherits
[17:02:51.268]                       invokeRestart <- base::invokeRestart
[17:02:51.268]                       is.null <- base::is.null
[17:02:51.268]                       muffled <- FALSE
[17:02:51.268]                       if (inherits(cond, "message")) {
[17:02:51.268]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.268]                         if (muffled) 
[17:02:51.268]                           invokeRestart("muffleMessage")
[17:02:51.268]                       }
[17:02:51.268]                       else if (inherits(cond, "warning")) {
[17:02:51.268]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.268]                         if (muffled) 
[17:02:51.268]                           invokeRestart("muffleWarning")
[17:02:51.268]                       }
[17:02:51.268]                       else if (inherits(cond, "condition")) {
[17:02:51.268]                         if (!is.null(pattern)) {
[17:02:51.268]                           computeRestarts <- base::computeRestarts
[17:02:51.268]                           grepl <- base::grepl
[17:02:51.268]                           restarts <- computeRestarts(cond)
[17:02:51.268]                           for (restart in restarts) {
[17:02:51.268]                             name <- restart$name
[17:02:51.268]                             if (is.null(name)) 
[17:02:51.268]                               next
[17:02:51.268]                             if (!grepl(pattern, name)) 
[17:02:51.268]                               next
[17:02:51.268]                             invokeRestart(restart)
[17:02:51.268]                             muffled <- TRUE
[17:02:51.268]                             break
[17:02:51.268]                           }
[17:02:51.268]                         }
[17:02:51.268]                       }
[17:02:51.268]                       invisible(muffled)
[17:02:51.268]                     }
[17:02:51.268]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.268]                   }
[17:02:51.268]                 }
[17:02:51.268]                 else {
[17:02:51.268]                   if (TRUE) {
[17:02:51.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.268]                     {
[17:02:51.268]                       inherits <- base::inherits
[17:02:51.268]                       invokeRestart <- base::invokeRestart
[17:02:51.268]                       is.null <- base::is.null
[17:02:51.268]                       muffled <- FALSE
[17:02:51.268]                       if (inherits(cond, "message")) {
[17:02:51.268]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.268]                         if (muffled) 
[17:02:51.268]                           invokeRestart("muffleMessage")
[17:02:51.268]                       }
[17:02:51.268]                       else if (inherits(cond, "warning")) {
[17:02:51.268]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.268]                         if (muffled) 
[17:02:51.268]                           invokeRestart("muffleWarning")
[17:02:51.268]                       }
[17:02:51.268]                       else if (inherits(cond, "condition")) {
[17:02:51.268]                         if (!is.null(pattern)) {
[17:02:51.268]                           computeRestarts <- base::computeRestarts
[17:02:51.268]                           grepl <- base::grepl
[17:02:51.268]                           restarts <- computeRestarts(cond)
[17:02:51.268]                           for (restart in restarts) {
[17:02:51.268]                             name <- restart$name
[17:02:51.268]                             if (is.null(name)) 
[17:02:51.268]                               next
[17:02:51.268]                             if (!grepl(pattern, name)) 
[17:02:51.268]                               next
[17:02:51.268]                             invokeRestart(restart)
[17:02:51.268]                             muffled <- TRUE
[17:02:51.268]                             break
[17:02:51.268]                           }
[17:02:51.268]                         }
[17:02:51.268]                       }
[17:02:51.268]                       invisible(muffled)
[17:02:51.268]                     }
[17:02:51.268]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.268]                   }
[17:02:51.268]                 }
[17:02:51.268]             }
[17:02:51.268]         }))
[17:02:51.268]     }, error = function(ex) {
[17:02:51.268]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.268]                 ...future.rng), started = ...future.startTime, 
[17:02:51.268]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.268]             version = "1.8"), class = "FutureResult")
[17:02:51.268]     }, finally = {
[17:02:51.268]         if (!identical(...future.workdir, getwd())) 
[17:02:51.268]             setwd(...future.workdir)
[17:02:51.268]         {
[17:02:51.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.268]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.268]             }
[17:02:51.268]             base::options(...future.oldOptions)
[17:02:51.268]             if (.Platform$OS.type == "windows") {
[17:02:51.268]                 old_names <- names(...future.oldEnvVars)
[17:02:51.268]                 envs <- base::Sys.getenv()
[17:02:51.268]                 names <- names(envs)
[17:02:51.268]                 common <- intersect(names, old_names)
[17:02:51.268]                 added <- setdiff(names, old_names)
[17:02:51.268]                 removed <- setdiff(old_names, names)
[17:02:51.268]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.268]                   envs[common]]
[17:02:51.268]                 NAMES <- toupper(changed)
[17:02:51.268]                 args <- list()
[17:02:51.268]                 for (kk in seq_along(NAMES)) {
[17:02:51.268]                   name <- changed[[kk]]
[17:02:51.268]                   NAME <- NAMES[[kk]]
[17:02:51.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.268]                     next
[17:02:51.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.268]                 }
[17:02:51.268]                 NAMES <- toupper(added)
[17:02:51.268]                 for (kk in seq_along(NAMES)) {
[17:02:51.268]                   name <- added[[kk]]
[17:02:51.268]                   NAME <- NAMES[[kk]]
[17:02:51.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.268]                     next
[17:02:51.268]                   args[[name]] <- ""
[17:02:51.268]                 }
[17:02:51.268]                 NAMES <- toupper(removed)
[17:02:51.268]                 for (kk in seq_along(NAMES)) {
[17:02:51.268]                   name <- removed[[kk]]
[17:02:51.268]                   NAME <- NAMES[[kk]]
[17:02:51.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.268]                     next
[17:02:51.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.268]                 }
[17:02:51.268]                 if (length(args) > 0) 
[17:02:51.268]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.268]             }
[17:02:51.268]             else {
[17:02:51.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.268]             }
[17:02:51.268]             {
[17:02:51.268]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.268]                   0L) {
[17:02:51.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.268]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.268]                   base::options(opts)
[17:02:51.268]                 }
[17:02:51.268]                 {
[17:02:51.268]                   {
[17:02:51.268]                     NULL
[17:02:51.268]                     RNGkind("Mersenne-Twister")
[17:02:51.268]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.268]                       inherits = FALSE)
[17:02:51.268]                   }
[17:02:51.268]                   options(future.plan = NULL)
[17:02:51.268]                   if (is.na(NA_character_)) 
[17:02:51.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.268]                     .init = FALSE)
[17:02:51.268]                 }
[17:02:51.268]             }
[17:02:51.268]         }
[17:02:51.268]     })
[17:02:51.268]     if (TRUE) {
[17:02:51.268]         base::sink(type = "output", split = FALSE)
[17:02:51.268]         if (TRUE) {
[17:02:51.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.268]         }
[17:02:51.268]         else {
[17:02:51.268]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.268]         }
[17:02:51.268]         base::close(...future.stdout)
[17:02:51.268]         ...future.stdout <- NULL
[17:02:51.268]     }
[17:02:51.268]     ...future.result$conditions <- ...future.conditions
[17:02:51.268]     ...future.result$finished <- base::Sys.time()
[17:02:51.268]     ...future.result
[17:02:51.268] }
[17:02:51.269] assign_globals() ...
[17:02:51.269] List of 2
[17:02:51.269]  $ a : num 1
[17:02:51.269]  $ ii: int 3
[17:02:51.269]  - attr(*, "where")=List of 2
[17:02:51.269]   ..$ a :<environment: R_EmptyEnv> 
[17:02:51.269]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.269]  - attr(*, "resolved")= logi TRUE
[17:02:51.269]  - attr(*, "total_size")= num 112
[17:02:51.269]  - attr(*, "already-done")= logi TRUE
[17:02:51.272] - copied ‘a’ to environment
[17:02:51.272] - copied ‘ii’ to environment
[17:02:51.273] assign_globals() ... done
[17:02:51.273] plan(): Setting new future strategy stack:
[17:02:51.273] List of future strategies:
[17:02:51.273] 1. sequential:
[17:02:51.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.273]    - tweaked: FALSE
[17:02:51.273]    - call: NULL
[17:02:51.273] plan(): nbrOfWorkers() = 1
[17:02:51.274] plan(): Setting new future strategy stack:
[17:02:51.274] List of future strategies:
[17:02:51.274] 1. sequential:
[17:02:51.274]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.274]    - tweaked: FALSE
[17:02:51.274]    - call: plan(strategy)
[17:02:51.275] plan(): nbrOfWorkers() = 1
[17:02:51.275] SequentialFuture started (and completed)
[17:02:51.275] - Launch lazy future ... done
[17:02:51.275] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.275] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.275] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.276] 
[17:02:51.276] Searching for globals ... DONE
[17:02:51.276] - globals: [0] <none>
[17:02:51.276] getGlobalsAndPackages() ... DONE
[17:02:51.276] run() for ‘Future’ ...
[17:02:51.277] - state: ‘created’
[17:02:51.277] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.277]   - Field: ‘label’
[17:02:51.277]   - Field: ‘local’
[17:02:51.277]   - Field: ‘owner’
[17:02:51.277]   - Field: ‘envir’
[17:02:51.278]   - Field: ‘packages’
[17:02:51.278]   - Field: ‘gc’
[17:02:51.278]   - Field: ‘conditions’
[17:02:51.278]   - Field: ‘expr’
[17:02:51.278]   - Field: ‘uuid’
[17:02:51.278]   - Field: ‘seed’
[17:02:51.278]   - Field: ‘version’
[17:02:51.278]   - Field: ‘result’
[17:02:51.278]   - Field: ‘asynchronous’
[17:02:51.278]   - Field: ‘calls’
[17:02:51.278]   - Field: ‘globals’
[17:02:51.279]   - Field: ‘stdout’
[17:02:51.279]   - Field: ‘earlySignal’
[17:02:51.279]   - Field: ‘lazy’
[17:02:51.279]   - Field: ‘state’
[17:02:51.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.279] - Launch lazy future ...
[17:02:51.279] Packages needed by the future expression (n = 0): <none>
[17:02:51.279] Packages needed by future strategies (n = 0): <none>
[17:02:51.280] {
[17:02:51.280]     {
[17:02:51.280]         {
[17:02:51.280]             ...future.startTime <- base::Sys.time()
[17:02:51.280]             {
[17:02:51.280]                 {
[17:02:51.280]                   {
[17:02:51.280]                     base::local({
[17:02:51.280]                       has_future <- base::requireNamespace("future", 
[17:02:51.280]                         quietly = TRUE)
[17:02:51.280]                       if (has_future) {
[17:02:51.280]                         ns <- base::getNamespace("future")
[17:02:51.280]                         version <- ns[[".package"]][["version"]]
[17:02:51.280]                         if (is.null(version)) 
[17:02:51.280]                           version <- utils::packageVersion("future")
[17:02:51.280]                       }
[17:02:51.280]                       else {
[17:02:51.280]                         version <- NULL
[17:02:51.280]                       }
[17:02:51.280]                       if (!has_future || version < "1.8.0") {
[17:02:51.280]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.280]                           "", base::R.version$version.string), 
[17:02:51.280]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.280]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.280]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.280]                             "release", "version")], collapse = " "), 
[17:02:51.280]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.280]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.280]                           info)
[17:02:51.280]                         info <- base::paste(info, collapse = "; ")
[17:02:51.280]                         if (!has_future) {
[17:02:51.280]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.280]                             info)
[17:02:51.280]                         }
[17:02:51.280]                         else {
[17:02:51.280]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.280]                             info, version)
[17:02:51.280]                         }
[17:02:51.280]                         base::stop(msg)
[17:02:51.280]                       }
[17:02:51.280]                     })
[17:02:51.280]                   }
[17:02:51.280]                   ...future.strategy.old <- future::plan("list")
[17:02:51.280]                   options(future.plan = NULL)
[17:02:51.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.280]                 }
[17:02:51.280]                 ...future.workdir <- getwd()
[17:02:51.280]             }
[17:02:51.280]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.280]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.280]         }
[17:02:51.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.280]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.280]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.280]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.280]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.280]             base::names(...future.oldOptions))
[17:02:51.280]     }
[17:02:51.280]     if (FALSE) {
[17:02:51.280]     }
[17:02:51.280]     else {
[17:02:51.280]         if (TRUE) {
[17:02:51.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.280]                 open = "w")
[17:02:51.280]         }
[17:02:51.280]         else {
[17:02:51.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.280]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.280]         }
[17:02:51.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.280]             base::sink(type = "output", split = FALSE)
[17:02:51.280]             base::close(...future.stdout)
[17:02:51.280]         }, add = TRUE)
[17:02:51.280]     }
[17:02:51.280]     ...future.frame <- base::sys.nframe()
[17:02:51.280]     ...future.conditions <- base::list()
[17:02:51.280]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.280]     if (FALSE) {
[17:02:51.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.280]     }
[17:02:51.280]     ...future.result <- base::tryCatch({
[17:02:51.280]         base::withCallingHandlers({
[17:02:51.280]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.280]             future::FutureResult(value = ...future.value$value, 
[17:02:51.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.280]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.280]                     ...future.globalenv.names))
[17:02:51.280]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.280]         }, condition = base::local({
[17:02:51.280]             c <- base::c
[17:02:51.280]             inherits <- base::inherits
[17:02:51.280]             invokeRestart <- base::invokeRestart
[17:02:51.280]             length <- base::length
[17:02:51.280]             list <- base::list
[17:02:51.280]             seq.int <- base::seq.int
[17:02:51.280]             signalCondition <- base::signalCondition
[17:02:51.280]             sys.calls <- base::sys.calls
[17:02:51.280]             `[[` <- base::`[[`
[17:02:51.280]             `+` <- base::`+`
[17:02:51.280]             `<<-` <- base::`<<-`
[17:02:51.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.280]                   3L)]
[17:02:51.280]             }
[17:02:51.280]             function(cond) {
[17:02:51.280]                 is_error <- inherits(cond, "error")
[17:02:51.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.280]                   NULL)
[17:02:51.280]                 if (is_error) {
[17:02:51.280]                   sessionInformation <- function() {
[17:02:51.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.280]                       search = base::search(), system = base::Sys.info())
[17:02:51.280]                   }
[17:02:51.280]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.280]                     cond$call), session = sessionInformation(), 
[17:02:51.280]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.280]                   signalCondition(cond)
[17:02:51.280]                 }
[17:02:51.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.280]                 "immediateCondition"))) {
[17:02:51.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.280]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.280]                   if (TRUE && !signal) {
[17:02:51.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.280]                     {
[17:02:51.280]                       inherits <- base::inherits
[17:02:51.280]                       invokeRestart <- base::invokeRestart
[17:02:51.280]                       is.null <- base::is.null
[17:02:51.280]                       muffled <- FALSE
[17:02:51.280]                       if (inherits(cond, "message")) {
[17:02:51.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.280]                         if (muffled) 
[17:02:51.280]                           invokeRestart("muffleMessage")
[17:02:51.280]                       }
[17:02:51.280]                       else if (inherits(cond, "warning")) {
[17:02:51.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.280]                         if (muffled) 
[17:02:51.280]                           invokeRestart("muffleWarning")
[17:02:51.280]                       }
[17:02:51.280]                       else if (inherits(cond, "condition")) {
[17:02:51.280]                         if (!is.null(pattern)) {
[17:02:51.280]                           computeRestarts <- base::computeRestarts
[17:02:51.280]                           grepl <- base::grepl
[17:02:51.280]                           restarts <- computeRestarts(cond)
[17:02:51.280]                           for (restart in restarts) {
[17:02:51.280]                             name <- restart$name
[17:02:51.280]                             if (is.null(name)) 
[17:02:51.280]                               next
[17:02:51.280]                             if (!grepl(pattern, name)) 
[17:02:51.280]                               next
[17:02:51.280]                             invokeRestart(restart)
[17:02:51.280]                             muffled <- TRUE
[17:02:51.280]                             break
[17:02:51.280]                           }
[17:02:51.280]                         }
[17:02:51.280]                       }
[17:02:51.280]                       invisible(muffled)
[17:02:51.280]                     }
[17:02:51.280]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.280]                   }
[17:02:51.280]                 }
[17:02:51.280]                 else {
[17:02:51.280]                   if (TRUE) {
[17:02:51.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.280]                     {
[17:02:51.280]                       inherits <- base::inherits
[17:02:51.280]                       invokeRestart <- base::invokeRestart
[17:02:51.280]                       is.null <- base::is.null
[17:02:51.280]                       muffled <- FALSE
[17:02:51.280]                       if (inherits(cond, "message")) {
[17:02:51.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.280]                         if (muffled) 
[17:02:51.280]                           invokeRestart("muffleMessage")
[17:02:51.280]                       }
[17:02:51.280]                       else if (inherits(cond, "warning")) {
[17:02:51.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.280]                         if (muffled) 
[17:02:51.280]                           invokeRestart("muffleWarning")
[17:02:51.280]                       }
[17:02:51.280]                       else if (inherits(cond, "condition")) {
[17:02:51.280]                         if (!is.null(pattern)) {
[17:02:51.280]                           computeRestarts <- base::computeRestarts
[17:02:51.280]                           grepl <- base::grepl
[17:02:51.280]                           restarts <- computeRestarts(cond)
[17:02:51.280]                           for (restart in restarts) {
[17:02:51.280]                             name <- restart$name
[17:02:51.280]                             if (is.null(name)) 
[17:02:51.280]                               next
[17:02:51.280]                             if (!grepl(pattern, name)) 
[17:02:51.280]                               next
[17:02:51.280]                             invokeRestart(restart)
[17:02:51.280]                             muffled <- TRUE
[17:02:51.280]                             break
[17:02:51.280]                           }
[17:02:51.280]                         }
[17:02:51.280]                       }
[17:02:51.280]                       invisible(muffled)
[17:02:51.280]                     }
[17:02:51.280]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.280]                   }
[17:02:51.280]                 }
[17:02:51.280]             }
[17:02:51.280]         }))
[17:02:51.280]     }, error = function(ex) {
[17:02:51.280]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.280]                 ...future.rng), started = ...future.startTime, 
[17:02:51.280]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.280]             version = "1.8"), class = "FutureResult")
[17:02:51.280]     }, finally = {
[17:02:51.280]         if (!identical(...future.workdir, getwd())) 
[17:02:51.280]             setwd(...future.workdir)
[17:02:51.280]         {
[17:02:51.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.280]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.280]             }
[17:02:51.280]             base::options(...future.oldOptions)
[17:02:51.280]             if (.Platform$OS.type == "windows") {
[17:02:51.280]                 old_names <- names(...future.oldEnvVars)
[17:02:51.280]                 envs <- base::Sys.getenv()
[17:02:51.280]                 names <- names(envs)
[17:02:51.280]                 common <- intersect(names, old_names)
[17:02:51.280]                 added <- setdiff(names, old_names)
[17:02:51.280]                 removed <- setdiff(old_names, names)
[17:02:51.280]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.280]                   envs[common]]
[17:02:51.280]                 NAMES <- toupper(changed)
[17:02:51.280]                 args <- list()
[17:02:51.280]                 for (kk in seq_along(NAMES)) {
[17:02:51.280]                   name <- changed[[kk]]
[17:02:51.280]                   NAME <- NAMES[[kk]]
[17:02:51.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.280]                     next
[17:02:51.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.280]                 }
[17:02:51.280]                 NAMES <- toupper(added)
[17:02:51.280]                 for (kk in seq_along(NAMES)) {
[17:02:51.280]                   name <- added[[kk]]
[17:02:51.280]                   NAME <- NAMES[[kk]]
[17:02:51.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.280]                     next
[17:02:51.280]                   args[[name]] <- ""
[17:02:51.280]                 }
[17:02:51.280]                 NAMES <- toupper(removed)
[17:02:51.280]                 for (kk in seq_along(NAMES)) {
[17:02:51.280]                   name <- removed[[kk]]
[17:02:51.280]                   NAME <- NAMES[[kk]]
[17:02:51.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.280]                     next
[17:02:51.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.280]                 }
[17:02:51.280]                 if (length(args) > 0) 
[17:02:51.280]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.280]             }
[17:02:51.280]             else {
[17:02:51.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.280]             }
[17:02:51.280]             {
[17:02:51.280]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.280]                   0L) {
[17:02:51.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.280]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.280]                   base::options(opts)
[17:02:51.280]                 }
[17:02:51.280]                 {
[17:02:51.280]                   {
[17:02:51.280]                     NULL
[17:02:51.280]                     RNGkind("Mersenne-Twister")
[17:02:51.280]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.280]                       inherits = FALSE)
[17:02:51.280]                   }
[17:02:51.280]                   options(future.plan = NULL)
[17:02:51.280]                   if (is.na(NA_character_)) 
[17:02:51.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.280]                     .init = FALSE)
[17:02:51.280]                 }
[17:02:51.280]             }
[17:02:51.280]         }
[17:02:51.280]     })
[17:02:51.280]     if (TRUE) {
[17:02:51.280]         base::sink(type = "output", split = FALSE)
[17:02:51.280]         if (TRUE) {
[17:02:51.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.280]         }
[17:02:51.280]         else {
[17:02:51.280]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.280]         }
[17:02:51.280]         base::close(...future.stdout)
[17:02:51.280]         ...future.stdout <- NULL
[17:02:51.280]     }
[17:02:51.280]     ...future.result$conditions <- ...future.conditions
[17:02:51.280]     ...future.result$finished <- base::Sys.time()
[17:02:51.280]     ...future.result
[17:02:51.280] }
[17:02:51.281] plan(): Setting new future strategy stack:
[17:02:51.281] List of future strategies:
[17:02:51.281] 1. sequential:
[17:02:51.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.281]    - tweaked: FALSE
[17:02:51.281]    - call: NULL
[17:02:51.282] plan(): nbrOfWorkers() = 1
[17:02:51.283] plan(): Setting new future strategy stack:
[17:02:51.283] List of future strategies:
[17:02:51.283] 1. sequential:
[17:02:51.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.283]    - tweaked: FALSE
[17:02:51.283]    - call: plan(strategy)
[17:02:51.283] plan(): nbrOfWorkers() = 1
[17:02:51.283] SequentialFuture started (and completed)
[17:02:51.283] - Launch lazy future ... done
[17:02:51.284] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.284] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.284] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.287] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.287] Searching for globals ... DONE
[17:02:51.287] Resolving globals: TRUE
[17:02:51.287] Resolving any globals that are futures ...
[17:02:51.287] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.287] Resolving any globals that are futures ... DONE
[17:02:51.287] Resolving futures part of globals (recursively) ...
[17:02:51.288] resolve() on list ...
[17:02:51.288]  recursive: 99
[17:02:51.288]  length: 1
[17:02:51.288]  elements: ‘a’
[17:02:51.288] resolved() for ‘SequentialFuture’ ...
[17:02:51.288] - state: ‘finished’
[17:02:51.288] - run: TRUE
[17:02:51.288] - result: ‘FutureResult’
[17:02:51.289] resolved() for ‘SequentialFuture’ ... done
[17:02:51.289] Future #1
[17:02:51.289] resolved() for ‘SequentialFuture’ ...
[17:02:51.289] - state: ‘finished’
[17:02:51.289] - run: TRUE
[17:02:51.289] - result: ‘FutureResult’
[17:02:51.289] resolved() for ‘SequentialFuture’ ... done
[17:02:51.289] A SequentialFuture was resolved
[17:02:51.289]  length: 0 (resolved future 1)
[17:02:51.289] resolve() on list ... DONE
[17:02:51.290] - globals: [1] ‘a’
[17:02:51.290] Resolving futures part of globals (recursively) ... DONE
[17:02:51.291] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[17:02:51.292] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:02:51.292] - globals: [1] ‘a’
[17:02:51.292] - packages: [1] ‘future’
[17:02:51.292] getGlobalsAndPackages() ... DONE
[17:02:51.292] run() for ‘Future’ ...
[17:02:51.292] - state: ‘created’
[17:02:51.293] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.293] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.293]   - Field: ‘label’
[17:02:51.293]   - Field: ‘local’
[17:02:51.293]   - Field: ‘owner’
[17:02:51.293]   - Field: ‘envir’
[17:02:51.293]   - Field: ‘packages’
[17:02:51.293]   - Field: ‘gc’
[17:02:51.294]   - Field: ‘conditions’
[17:02:51.294]   - Field: ‘expr’
[17:02:51.294]   - Field: ‘uuid’
[17:02:51.294]   - Field: ‘seed’
[17:02:51.294]   - Field: ‘version’
[17:02:51.294]   - Field: ‘result’
[17:02:51.294]   - Field: ‘asynchronous’
[17:02:51.294]   - Field: ‘calls’
[17:02:51.294]   - Field: ‘globals’
[17:02:51.294]   - Field: ‘stdout’
[17:02:51.294]   - Field: ‘earlySignal’
[17:02:51.295]   - Field: ‘lazy’
[17:02:51.295]   - Field: ‘state’
[17:02:51.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.295] - Launch lazy future ...
[17:02:51.295] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.295] Packages needed by future strategies (n = 0): <none>
[17:02:51.296] {
[17:02:51.296]     {
[17:02:51.296]         {
[17:02:51.296]             ...future.startTime <- base::Sys.time()
[17:02:51.296]             {
[17:02:51.296]                 {
[17:02:51.296]                   {
[17:02:51.296]                     {
[17:02:51.296]                       base::local({
[17:02:51.296]                         has_future <- base::requireNamespace("future", 
[17:02:51.296]                           quietly = TRUE)
[17:02:51.296]                         if (has_future) {
[17:02:51.296]                           ns <- base::getNamespace("future")
[17:02:51.296]                           version <- ns[[".package"]][["version"]]
[17:02:51.296]                           if (is.null(version)) 
[17:02:51.296]                             version <- utils::packageVersion("future")
[17:02:51.296]                         }
[17:02:51.296]                         else {
[17:02:51.296]                           version <- NULL
[17:02:51.296]                         }
[17:02:51.296]                         if (!has_future || version < "1.8.0") {
[17:02:51.296]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.296]                             "", base::R.version$version.string), 
[17:02:51.296]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.296]                               "release", "version")], collapse = " "), 
[17:02:51.296]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.296]                             info)
[17:02:51.296]                           info <- base::paste(info, collapse = "; ")
[17:02:51.296]                           if (!has_future) {
[17:02:51.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.296]                               info)
[17:02:51.296]                           }
[17:02:51.296]                           else {
[17:02:51.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.296]                               info, version)
[17:02:51.296]                           }
[17:02:51.296]                           base::stop(msg)
[17:02:51.296]                         }
[17:02:51.296]                       })
[17:02:51.296]                     }
[17:02:51.296]                     base::local({
[17:02:51.296]                       for (pkg in "future") {
[17:02:51.296]                         base::loadNamespace(pkg)
[17:02:51.296]                         base::library(pkg, character.only = TRUE)
[17:02:51.296]                       }
[17:02:51.296]                     })
[17:02:51.296]                   }
[17:02:51.296]                   ...future.strategy.old <- future::plan("list")
[17:02:51.296]                   options(future.plan = NULL)
[17:02:51.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.296]                 }
[17:02:51.296]                 ...future.workdir <- getwd()
[17:02:51.296]             }
[17:02:51.296]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.296]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.296]         }
[17:02:51.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.296]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.296]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.296]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.296]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.296]             base::names(...future.oldOptions))
[17:02:51.296]     }
[17:02:51.296]     if (FALSE) {
[17:02:51.296]     }
[17:02:51.296]     else {
[17:02:51.296]         if (TRUE) {
[17:02:51.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.296]                 open = "w")
[17:02:51.296]         }
[17:02:51.296]         else {
[17:02:51.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.296]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.296]         }
[17:02:51.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.296]             base::sink(type = "output", split = FALSE)
[17:02:51.296]             base::close(...future.stdout)
[17:02:51.296]         }, add = TRUE)
[17:02:51.296]     }
[17:02:51.296]     ...future.frame <- base::sys.nframe()
[17:02:51.296]     ...future.conditions <- base::list()
[17:02:51.296]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.296]     if (FALSE) {
[17:02:51.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.296]     }
[17:02:51.296]     ...future.result <- base::tryCatch({
[17:02:51.296]         base::withCallingHandlers({
[17:02:51.296]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.296]                 1))
[17:02:51.296]             future::FutureResult(value = ...future.value$value, 
[17:02:51.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.296]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.296]                     ...future.globalenv.names))
[17:02:51.296]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.296]         }, condition = base::local({
[17:02:51.296]             c <- base::c
[17:02:51.296]             inherits <- base::inherits
[17:02:51.296]             invokeRestart <- base::invokeRestart
[17:02:51.296]             length <- base::length
[17:02:51.296]             list <- base::list
[17:02:51.296]             seq.int <- base::seq.int
[17:02:51.296]             signalCondition <- base::signalCondition
[17:02:51.296]             sys.calls <- base::sys.calls
[17:02:51.296]             `[[` <- base::`[[`
[17:02:51.296]             `+` <- base::`+`
[17:02:51.296]             `<<-` <- base::`<<-`
[17:02:51.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.296]                   3L)]
[17:02:51.296]             }
[17:02:51.296]             function(cond) {
[17:02:51.296]                 is_error <- inherits(cond, "error")
[17:02:51.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.296]                   NULL)
[17:02:51.296]                 if (is_error) {
[17:02:51.296]                   sessionInformation <- function() {
[17:02:51.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.296]                       search = base::search(), system = base::Sys.info())
[17:02:51.296]                   }
[17:02:51.296]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.296]                     cond$call), session = sessionInformation(), 
[17:02:51.296]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.296]                   signalCondition(cond)
[17:02:51.296]                 }
[17:02:51.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.296]                 "immediateCondition"))) {
[17:02:51.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.296]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.296]                   if (TRUE && !signal) {
[17:02:51.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.296]                     {
[17:02:51.296]                       inherits <- base::inherits
[17:02:51.296]                       invokeRestart <- base::invokeRestart
[17:02:51.296]                       is.null <- base::is.null
[17:02:51.296]                       muffled <- FALSE
[17:02:51.296]                       if (inherits(cond, "message")) {
[17:02:51.296]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.296]                         if (muffled) 
[17:02:51.296]                           invokeRestart("muffleMessage")
[17:02:51.296]                       }
[17:02:51.296]                       else if (inherits(cond, "warning")) {
[17:02:51.296]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.296]                         if (muffled) 
[17:02:51.296]                           invokeRestart("muffleWarning")
[17:02:51.296]                       }
[17:02:51.296]                       else if (inherits(cond, "condition")) {
[17:02:51.296]                         if (!is.null(pattern)) {
[17:02:51.296]                           computeRestarts <- base::computeRestarts
[17:02:51.296]                           grepl <- base::grepl
[17:02:51.296]                           restarts <- computeRestarts(cond)
[17:02:51.296]                           for (restart in restarts) {
[17:02:51.296]                             name <- restart$name
[17:02:51.296]                             if (is.null(name)) 
[17:02:51.296]                               next
[17:02:51.296]                             if (!grepl(pattern, name)) 
[17:02:51.296]                               next
[17:02:51.296]                             invokeRestart(restart)
[17:02:51.296]                             muffled <- TRUE
[17:02:51.296]                             break
[17:02:51.296]                           }
[17:02:51.296]                         }
[17:02:51.296]                       }
[17:02:51.296]                       invisible(muffled)
[17:02:51.296]                     }
[17:02:51.296]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.296]                   }
[17:02:51.296]                 }
[17:02:51.296]                 else {
[17:02:51.296]                   if (TRUE) {
[17:02:51.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.296]                     {
[17:02:51.296]                       inherits <- base::inherits
[17:02:51.296]                       invokeRestart <- base::invokeRestart
[17:02:51.296]                       is.null <- base::is.null
[17:02:51.296]                       muffled <- FALSE
[17:02:51.296]                       if (inherits(cond, "message")) {
[17:02:51.296]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.296]                         if (muffled) 
[17:02:51.296]                           invokeRestart("muffleMessage")
[17:02:51.296]                       }
[17:02:51.296]                       else if (inherits(cond, "warning")) {
[17:02:51.296]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.296]                         if (muffled) 
[17:02:51.296]                           invokeRestart("muffleWarning")
[17:02:51.296]                       }
[17:02:51.296]                       else if (inherits(cond, "condition")) {
[17:02:51.296]                         if (!is.null(pattern)) {
[17:02:51.296]                           computeRestarts <- base::computeRestarts
[17:02:51.296]                           grepl <- base::grepl
[17:02:51.296]                           restarts <- computeRestarts(cond)
[17:02:51.296]                           for (restart in restarts) {
[17:02:51.296]                             name <- restart$name
[17:02:51.296]                             if (is.null(name)) 
[17:02:51.296]                               next
[17:02:51.296]                             if (!grepl(pattern, name)) 
[17:02:51.296]                               next
[17:02:51.296]                             invokeRestart(restart)
[17:02:51.296]                             muffled <- TRUE
[17:02:51.296]                             break
[17:02:51.296]                           }
[17:02:51.296]                         }
[17:02:51.296]                       }
[17:02:51.296]                       invisible(muffled)
[17:02:51.296]                     }
[17:02:51.296]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.296]                   }
[17:02:51.296]                 }
[17:02:51.296]             }
[17:02:51.296]         }))
[17:02:51.296]     }, error = function(ex) {
[17:02:51.296]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.296]                 ...future.rng), started = ...future.startTime, 
[17:02:51.296]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.296]             version = "1.8"), class = "FutureResult")
[17:02:51.296]     }, finally = {
[17:02:51.296]         if (!identical(...future.workdir, getwd())) 
[17:02:51.296]             setwd(...future.workdir)
[17:02:51.296]         {
[17:02:51.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.296]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.296]             }
[17:02:51.296]             base::options(...future.oldOptions)
[17:02:51.296]             if (.Platform$OS.type == "windows") {
[17:02:51.296]                 old_names <- names(...future.oldEnvVars)
[17:02:51.296]                 envs <- base::Sys.getenv()
[17:02:51.296]                 names <- names(envs)
[17:02:51.296]                 common <- intersect(names, old_names)
[17:02:51.296]                 added <- setdiff(names, old_names)
[17:02:51.296]                 removed <- setdiff(old_names, names)
[17:02:51.296]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.296]                   envs[common]]
[17:02:51.296]                 NAMES <- toupper(changed)
[17:02:51.296]                 args <- list()
[17:02:51.296]                 for (kk in seq_along(NAMES)) {
[17:02:51.296]                   name <- changed[[kk]]
[17:02:51.296]                   NAME <- NAMES[[kk]]
[17:02:51.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.296]                     next
[17:02:51.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.296]                 }
[17:02:51.296]                 NAMES <- toupper(added)
[17:02:51.296]                 for (kk in seq_along(NAMES)) {
[17:02:51.296]                   name <- added[[kk]]
[17:02:51.296]                   NAME <- NAMES[[kk]]
[17:02:51.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.296]                     next
[17:02:51.296]                   args[[name]] <- ""
[17:02:51.296]                 }
[17:02:51.296]                 NAMES <- toupper(removed)
[17:02:51.296]                 for (kk in seq_along(NAMES)) {
[17:02:51.296]                   name <- removed[[kk]]
[17:02:51.296]                   NAME <- NAMES[[kk]]
[17:02:51.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.296]                     next
[17:02:51.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.296]                 }
[17:02:51.296]                 if (length(args) > 0) 
[17:02:51.296]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.296]             }
[17:02:51.296]             else {
[17:02:51.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.296]             }
[17:02:51.296]             {
[17:02:51.296]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.296]                   0L) {
[17:02:51.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.296]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.296]                   base::options(opts)
[17:02:51.296]                 }
[17:02:51.296]                 {
[17:02:51.296]                   {
[17:02:51.296]                     NULL
[17:02:51.296]                     RNGkind("Mersenne-Twister")
[17:02:51.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.296]                       inherits = FALSE)
[17:02:51.296]                   }
[17:02:51.296]                   options(future.plan = NULL)
[17:02:51.296]                   if (is.na(NA_character_)) 
[17:02:51.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.296]                     .init = FALSE)
[17:02:51.296]                 }
[17:02:51.296]             }
[17:02:51.296]         }
[17:02:51.296]     })
[17:02:51.296]     if (TRUE) {
[17:02:51.296]         base::sink(type = "output", split = FALSE)
[17:02:51.296]         if (TRUE) {
[17:02:51.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.296]         }
[17:02:51.296]         else {
[17:02:51.296]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.296]         }
[17:02:51.296]         base::close(...future.stdout)
[17:02:51.296]         ...future.stdout <- NULL
[17:02:51.296]     }
[17:02:51.296]     ...future.result$conditions <- ...future.conditions
[17:02:51.296]     ...future.result$finished <- base::Sys.time()
[17:02:51.296]     ...future.result
[17:02:51.296] }
[17:02:51.297] assign_globals() ...
[17:02:51.297] List of 1
[17:02:51.297]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f685c9e0> 
[17:02:51.297]  - attr(*, "where")=List of 1
[17:02:51.297]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.297]  - attr(*, "resolved")= logi TRUE
[17:02:51.297]  - attr(*, "total_size")= num 1622272
[17:02:51.297]  - attr(*, "already-done")= logi TRUE
[17:02:51.300] - copied ‘a’ to environment
[17:02:51.300] assign_globals() ... done
[17:02:51.300] plan(): Setting new future strategy stack:
[17:02:51.300] List of future strategies:
[17:02:51.300] 1. sequential:
[17:02:51.300]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.300]    - tweaked: FALSE
[17:02:51.300]    - call: NULL
[17:02:51.301] plan(): nbrOfWorkers() = 1
[17:02:51.302] plan(): Setting new future strategy stack:
[17:02:51.302] List of future strategies:
[17:02:51.302] 1. sequential:
[17:02:51.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.302]    - tweaked: FALSE
[17:02:51.302]    - call: plan(strategy)
[17:02:51.302] plan(): nbrOfWorkers() = 1
[17:02:51.302] SequentialFuture started (and completed)
[17:02:51.302] - Launch lazy future ... done
[17:02:51.302] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.303] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.303] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.304] 
[17:02:51.304] Searching for globals ... DONE
[17:02:51.304] - globals: [0] <none>
[17:02:51.304] getGlobalsAndPackages() ... DONE
[17:02:51.304] run() for ‘Future’ ...
[17:02:51.304] - state: ‘created’
[17:02:51.304] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.304] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.305]   - Field: ‘label’
[17:02:51.305]   - Field: ‘local’
[17:02:51.305]   - Field: ‘owner’
[17:02:51.305]   - Field: ‘envir’
[17:02:51.305]   - Field: ‘packages’
[17:02:51.305]   - Field: ‘gc’
[17:02:51.305]   - Field: ‘conditions’
[17:02:51.305]   - Field: ‘expr’
[17:02:51.305]   - Field: ‘uuid’
[17:02:51.306]   - Field: ‘seed’
[17:02:51.306]   - Field: ‘version’
[17:02:51.306]   - Field: ‘result’
[17:02:51.306]   - Field: ‘asynchronous’
[17:02:51.306]   - Field: ‘calls’
[17:02:51.306]   - Field: ‘globals’
[17:02:51.306]   - Field: ‘stdout’
[17:02:51.306]   - Field: ‘earlySignal’
[17:02:51.306]   - Field: ‘lazy’
[17:02:51.306]   - Field: ‘state’
[17:02:51.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.307] - Launch lazy future ...
[17:02:51.307] Packages needed by the future expression (n = 0): <none>
[17:02:51.307] Packages needed by future strategies (n = 0): <none>
[17:02:51.307] {
[17:02:51.307]     {
[17:02:51.307]         {
[17:02:51.307]             ...future.startTime <- base::Sys.time()
[17:02:51.307]             {
[17:02:51.307]                 {
[17:02:51.307]                   {
[17:02:51.307]                     base::local({
[17:02:51.307]                       has_future <- base::requireNamespace("future", 
[17:02:51.307]                         quietly = TRUE)
[17:02:51.307]                       if (has_future) {
[17:02:51.307]                         ns <- base::getNamespace("future")
[17:02:51.307]                         version <- ns[[".package"]][["version"]]
[17:02:51.307]                         if (is.null(version)) 
[17:02:51.307]                           version <- utils::packageVersion("future")
[17:02:51.307]                       }
[17:02:51.307]                       else {
[17:02:51.307]                         version <- NULL
[17:02:51.307]                       }
[17:02:51.307]                       if (!has_future || version < "1.8.0") {
[17:02:51.307]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.307]                           "", base::R.version$version.string), 
[17:02:51.307]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.307]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.307]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.307]                             "release", "version")], collapse = " "), 
[17:02:51.307]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.307]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.307]                           info)
[17:02:51.307]                         info <- base::paste(info, collapse = "; ")
[17:02:51.307]                         if (!has_future) {
[17:02:51.307]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.307]                             info)
[17:02:51.307]                         }
[17:02:51.307]                         else {
[17:02:51.307]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.307]                             info, version)
[17:02:51.307]                         }
[17:02:51.307]                         base::stop(msg)
[17:02:51.307]                       }
[17:02:51.307]                     })
[17:02:51.307]                   }
[17:02:51.307]                   ...future.strategy.old <- future::plan("list")
[17:02:51.307]                   options(future.plan = NULL)
[17:02:51.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.307]                 }
[17:02:51.307]                 ...future.workdir <- getwd()
[17:02:51.307]             }
[17:02:51.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.307]         }
[17:02:51.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.307]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.307]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.307]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.307]             base::names(...future.oldOptions))
[17:02:51.307]     }
[17:02:51.307]     if (FALSE) {
[17:02:51.307]     }
[17:02:51.307]     else {
[17:02:51.307]         if (TRUE) {
[17:02:51.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.307]                 open = "w")
[17:02:51.307]         }
[17:02:51.307]         else {
[17:02:51.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.307]         }
[17:02:51.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.307]             base::sink(type = "output", split = FALSE)
[17:02:51.307]             base::close(...future.stdout)
[17:02:51.307]         }, add = TRUE)
[17:02:51.307]     }
[17:02:51.307]     ...future.frame <- base::sys.nframe()
[17:02:51.307]     ...future.conditions <- base::list()
[17:02:51.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.307]     if (FALSE) {
[17:02:51.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.307]     }
[17:02:51.307]     ...future.result <- base::tryCatch({
[17:02:51.307]         base::withCallingHandlers({
[17:02:51.307]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.307]             future::FutureResult(value = ...future.value$value, 
[17:02:51.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.307]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.307]                     ...future.globalenv.names))
[17:02:51.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.307]         }, condition = base::local({
[17:02:51.307]             c <- base::c
[17:02:51.307]             inherits <- base::inherits
[17:02:51.307]             invokeRestart <- base::invokeRestart
[17:02:51.307]             length <- base::length
[17:02:51.307]             list <- base::list
[17:02:51.307]             seq.int <- base::seq.int
[17:02:51.307]             signalCondition <- base::signalCondition
[17:02:51.307]             sys.calls <- base::sys.calls
[17:02:51.307]             `[[` <- base::`[[`
[17:02:51.307]             `+` <- base::`+`
[17:02:51.307]             `<<-` <- base::`<<-`
[17:02:51.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.307]                   3L)]
[17:02:51.307]             }
[17:02:51.307]             function(cond) {
[17:02:51.307]                 is_error <- inherits(cond, "error")
[17:02:51.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.307]                   NULL)
[17:02:51.307]                 if (is_error) {
[17:02:51.307]                   sessionInformation <- function() {
[17:02:51.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.307]                       search = base::search(), system = base::Sys.info())
[17:02:51.307]                   }
[17:02:51.307]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.307]                     cond$call), session = sessionInformation(), 
[17:02:51.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.307]                   signalCondition(cond)
[17:02:51.307]                 }
[17:02:51.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.307]                 "immediateCondition"))) {
[17:02:51.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.307]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.307]                   if (TRUE && !signal) {
[17:02:51.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.307]                     {
[17:02:51.307]                       inherits <- base::inherits
[17:02:51.307]                       invokeRestart <- base::invokeRestart
[17:02:51.307]                       is.null <- base::is.null
[17:02:51.307]                       muffled <- FALSE
[17:02:51.307]                       if (inherits(cond, "message")) {
[17:02:51.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.307]                         if (muffled) 
[17:02:51.307]                           invokeRestart("muffleMessage")
[17:02:51.307]                       }
[17:02:51.307]                       else if (inherits(cond, "warning")) {
[17:02:51.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.307]                         if (muffled) 
[17:02:51.307]                           invokeRestart("muffleWarning")
[17:02:51.307]                       }
[17:02:51.307]                       else if (inherits(cond, "condition")) {
[17:02:51.307]                         if (!is.null(pattern)) {
[17:02:51.307]                           computeRestarts <- base::computeRestarts
[17:02:51.307]                           grepl <- base::grepl
[17:02:51.307]                           restarts <- computeRestarts(cond)
[17:02:51.307]                           for (restart in restarts) {
[17:02:51.307]                             name <- restart$name
[17:02:51.307]                             if (is.null(name)) 
[17:02:51.307]                               next
[17:02:51.307]                             if (!grepl(pattern, name)) 
[17:02:51.307]                               next
[17:02:51.307]                             invokeRestart(restart)
[17:02:51.307]                             muffled <- TRUE
[17:02:51.307]                             break
[17:02:51.307]                           }
[17:02:51.307]                         }
[17:02:51.307]                       }
[17:02:51.307]                       invisible(muffled)
[17:02:51.307]                     }
[17:02:51.307]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.307]                   }
[17:02:51.307]                 }
[17:02:51.307]                 else {
[17:02:51.307]                   if (TRUE) {
[17:02:51.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.307]                     {
[17:02:51.307]                       inherits <- base::inherits
[17:02:51.307]                       invokeRestart <- base::invokeRestart
[17:02:51.307]                       is.null <- base::is.null
[17:02:51.307]                       muffled <- FALSE
[17:02:51.307]                       if (inherits(cond, "message")) {
[17:02:51.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.307]                         if (muffled) 
[17:02:51.307]                           invokeRestart("muffleMessage")
[17:02:51.307]                       }
[17:02:51.307]                       else if (inherits(cond, "warning")) {
[17:02:51.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.307]                         if (muffled) 
[17:02:51.307]                           invokeRestart("muffleWarning")
[17:02:51.307]                       }
[17:02:51.307]                       else if (inherits(cond, "condition")) {
[17:02:51.307]                         if (!is.null(pattern)) {
[17:02:51.307]                           computeRestarts <- base::computeRestarts
[17:02:51.307]                           grepl <- base::grepl
[17:02:51.307]                           restarts <- computeRestarts(cond)
[17:02:51.307]                           for (restart in restarts) {
[17:02:51.307]                             name <- restart$name
[17:02:51.307]                             if (is.null(name)) 
[17:02:51.307]                               next
[17:02:51.307]                             if (!grepl(pattern, name)) 
[17:02:51.307]                               next
[17:02:51.307]                             invokeRestart(restart)
[17:02:51.307]                             muffled <- TRUE
[17:02:51.307]                             break
[17:02:51.307]                           }
[17:02:51.307]                         }
[17:02:51.307]                       }
[17:02:51.307]                       invisible(muffled)
[17:02:51.307]                     }
[17:02:51.307]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.307]                   }
[17:02:51.307]                 }
[17:02:51.307]             }
[17:02:51.307]         }))
[17:02:51.307]     }, error = function(ex) {
[17:02:51.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.307]                 ...future.rng), started = ...future.startTime, 
[17:02:51.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.307]             version = "1.8"), class = "FutureResult")
[17:02:51.307]     }, finally = {
[17:02:51.307]         if (!identical(...future.workdir, getwd())) 
[17:02:51.307]             setwd(...future.workdir)
[17:02:51.307]         {
[17:02:51.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.307]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.307]             }
[17:02:51.307]             base::options(...future.oldOptions)
[17:02:51.307]             if (.Platform$OS.type == "windows") {
[17:02:51.307]                 old_names <- names(...future.oldEnvVars)
[17:02:51.307]                 envs <- base::Sys.getenv()
[17:02:51.307]                 names <- names(envs)
[17:02:51.307]                 common <- intersect(names, old_names)
[17:02:51.307]                 added <- setdiff(names, old_names)
[17:02:51.307]                 removed <- setdiff(old_names, names)
[17:02:51.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.307]                   envs[common]]
[17:02:51.307]                 NAMES <- toupper(changed)
[17:02:51.307]                 args <- list()
[17:02:51.307]                 for (kk in seq_along(NAMES)) {
[17:02:51.307]                   name <- changed[[kk]]
[17:02:51.307]                   NAME <- NAMES[[kk]]
[17:02:51.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.307]                     next
[17:02:51.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.307]                 }
[17:02:51.307]                 NAMES <- toupper(added)
[17:02:51.307]                 for (kk in seq_along(NAMES)) {
[17:02:51.307]                   name <- added[[kk]]
[17:02:51.307]                   NAME <- NAMES[[kk]]
[17:02:51.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.307]                     next
[17:02:51.307]                   args[[name]] <- ""
[17:02:51.307]                 }
[17:02:51.307]                 NAMES <- toupper(removed)
[17:02:51.307]                 for (kk in seq_along(NAMES)) {
[17:02:51.307]                   name <- removed[[kk]]
[17:02:51.307]                   NAME <- NAMES[[kk]]
[17:02:51.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.307]                     next
[17:02:51.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.307]                 }
[17:02:51.307]                 if (length(args) > 0) 
[17:02:51.307]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.307]             }
[17:02:51.307]             else {
[17:02:51.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.307]             }
[17:02:51.307]             {
[17:02:51.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.307]                   0L) {
[17:02:51.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.307]                   base::options(opts)
[17:02:51.307]                 }
[17:02:51.307]                 {
[17:02:51.307]                   {
[17:02:51.307]                     NULL
[17:02:51.307]                     RNGkind("Mersenne-Twister")
[17:02:51.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.307]                       inherits = FALSE)
[17:02:51.307]                   }
[17:02:51.307]                   options(future.plan = NULL)
[17:02:51.307]                   if (is.na(NA_character_)) 
[17:02:51.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.307]                     .init = FALSE)
[17:02:51.307]                 }
[17:02:51.307]             }
[17:02:51.307]         }
[17:02:51.307]     })
[17:02:51.307]     if (TRUE) {
[17:02:51.307]         base::sink(type = "output", split = FALSE)
[17:02:51.307]         if (TRUE) {
[17:02:51.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.307]         }
[17:02:51.307]         else {
[17:02:51.307]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.307]         }
[17:02:51.307]         base::close(...future.stdout)
[17:02:51.307]         ...future.stdout <- NULL
[17:02:51.307]     }
[17:02:51.307]     ...future.result$conditions <- ...future.conditions
[17:02:51.307]     ...future.result$finished <- base::Sys.time()
[17:02:51.307]     ...future.result
[17:02:51.307] }
[17:02:51.309] plan(): Setting new future strategy stack:
[17:02:51.309] List of future strategies:
[17:02:51.309] 1. sequential:
[17:02:51.309]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.309]    - tweaked: FALSE
[17:02:51.309]    - call: NULL
[17:02:51.309] plan(): nbrOfWorkers() = 1
[17:02:51.310] plan(): Setting new future strategy stack:
[17:02:51.310] List of future strategies:
[17:02:51.310] 1. sequential:
[17:02:51.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.310]    - tweaked: FALSE
[17:02:51.310]    - call: plan(strategy)
[17:02:51.311] plan(): nbrOfWorkers() = 1
[17:02:51.311] SequentialFuture started (and completed)
[17:02:51.311] - Launch lazy future ... done
[17:02:51.311] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.311] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.311] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.314] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.314] Searching for globals ... DONE
[17:02:51.314] Resolving globals: TRUE
[17:02:51.314] Resolving any globals that are futures ...
[17:02:51.314] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.315] Resolving any globals that are futures ... DONE
[17:02:51.315] Resolving futures part of globals (recursively) ...
[17:02:51.315] resolve() on list ...
[17:02:51.315]  recursive: 99
[17:02:51.315]  length: 1
[17:02:51.315]  elements: ‘a’
[17:02:51.316] resolved() for ‘SequentialFuture’ ...
[17:02:51.316] - state: ‘finished’
[17:02:51.316] - run: TRUE
[17:02:51.316] - result: ‘FutureResult’
[17:02:51.316] resolved() for ‘SequentialFuture’ ... done
[17:02:51.316] Future #1
[17:02:51.316] resolved() for ‘SequentialFuture’ ...
[17:02:51.316] - state: ‘finished’
[17:02:51.316] - run: TRUE
[17:02:51.316] - result: ‘FutureResult’
[17:02:51.317] resolved() for ‘SequentialFuture’ ... done
[17:02:51.317] A SequentialFuture was resolved
[17:02:51.317]  length: 0 (resolved future 1)
[17:02:51.317] resolve() on list ... DONE
[17:02:51.317] - globals: [1] ‘a’
[17:02:51.317] Resolving futures part of globals (recursively) ... DONE
[17:02:51.319] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[17:02:51.319] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:02:51.319] - globals: [1] ‘a’
[17:02:51.319] - packages: [1] ‘future’
[17:02:51.319] getGlobalsAndPackages() ... DONE
[17:02:51.320] run() for ‘Future’ ...
[17:02:51.320] - state: ‘created’
[17:02:51.320] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.320]   - Field: ‘label’
[17:02:51.321]   - Field: ‘local’
[17:02:51.321]   - Field: ‘owner’
[17:02:51.321]   - Field: ‘envir’
[17:02:51.321]   - Field: ‘packages’
[17:02:51.321]   - Field: ‘gc’
[17:02:51.321]   - Field: ‘conditions’
[17:02:51.321]   - Field: ‘expr’
[17:02:51.321]   - Field: ‘uuid’
[17:02:51.321]   - Field: ‘seed’
[17:02:51.321]   - Field: ‘version’
[17:02:51.321]   - Field: ‘result’
[17:02:51.322]   - Field: ‘asynchronous’
[17:02:51.322]   - Field: ‘calls’
[17:02:51.322]   - Field: ‘globals’
[17:02:51.322]   - Field: ‘stdout’
[17:02:51.322]   - Field: ‘earlySignal’
[17:02:51.322]   - Field: ‘lazy’
[17:02:51.322]   - Field: ‘state’
[17:02:51.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.322] - Launch lazy future ...
[17:02:51.322] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.323] Packages needed by future strategies (n = 0): <none>
[17:02:51.323] {
[17:02:51.323]     {
[17:02:51.323]         {
[17:02:51.323]             ...future.startTime <- base::Sys.time()
[17:02:51.323]             {
[17:02:51.323]                 {
[17:02:51.323]                   {
[17:02:51.323]                     {
[17:02:51.323]                       base::local({
[17:02:51.323]                         has_future <- base::requireNamespace("future", 
[17:02:51.323]                           quietly = TRUE)
[17:02:51.323]                         if (has_future) {
[17:02:51.323]                           ns <- base::getNamespace("future")
[17:02:51.323]                           version <- ns[[".package"]][["version"]]
[17:02:51.323]                           if (is.null(version)) 
[17:02:51.323]                             version <- utils::packageVersion("future")
[17:02:51.323]                         }
[17:02:51.323]                         else {
[17:02:51.323]                           version <- NULL
[17:02:51.323]                         }
[17:02:51.323]                         if (!has_future || version < "1.8.0") {
[17:02:51.323]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.323]                             "", base::R.version$version.string), 
[17:02:51.323]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.323]                               "release", "version")], collapse = " "), 
[17:02:51.323]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.323]                             info)
[17:02:51.323]                           info <- base::paste(info, collapse = "; ")
[17:02:51.323]                           if (!has_future) {
[17:02:51.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.323]                               info)
[17:02:51.323]                           }
[17:02:51.323]                           else {
[17:02:51.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.323]                               info, version)
[17:02:51.323]                           }
[17:02:51.323]                           base::stop(msg)
[17:02:51.323]                         }
[17:02:51.323]                       })
[17:02:51.323]                     }
[17:02:51.323]                     base::local({
[17:02:51.323]                       for (pkg in "future") {
[17:02:51.323]                         base::loadNamespace(pkg)
[17:02:51.323]                         base::library(pkg, character.only = TRUE)
[17:02:51.323]                       }
[17:02:51.323]                     })
[17:02:51.323]                   }
[17:02:51.323]                   ...future.strategy.old <- future::plan("list")
[17:02:51.323]                   options(future.plan = NULL)
[17:02:51.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.323]                 }
[17:02:51.323]                 ...future.workdir <- getwd()
[17:02:51.323]             }
[17:02:51.323]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.323]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.323]         }
[17:02:51.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.323]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.323]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.323]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.323]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.323]             base::names(...future.oldOptions))
[17:02:51.323]     }
[17:02:51.323]     if (FALSE) {
[17:02:51.323]     }
[17:02:51.323]     else {
[17:02:51.323]         if (TRUE) {
[17:02:51.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.323]                 open = "w")
[17:02:51.323]         }
[17:02:51.323]         else {
[17:02:51.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.323]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.323]         }
[17:02:51.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.323]             base::sink(type = "output", split = FALSE)
[17:02:51.323]             base::close(...future.stdout)
[17:02:51.323]         }, add = TRUE)
[17:02:51.323]     }
[17:02:51.323]     ...future.frame <- base::sys.nframe()
[17:02:51.323]     ...future.conditions <- base::list()
[17:02:51.323]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.323]     if (FALSE) {
[17:02:51.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.323]     }
[17:02:51.323]     ...future.result <- base::tryCatch({
[17:02:51.323]         base::withCallingHandlers({
[17:02:51.323]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.323]                 1))
[17:02:51.323]             future::FutureResult(value = ...future.value$value, 
[17:02:51.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.323]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.323]                     ...future.globalenv.names))
[17:02:51.323]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.323]         }, condition = base::local({
[17:02:51.323]             c <- base::c
[17:02:51.323]             inherits <- base::inherits
[17:02:51.323]             invokeRestart <- base::invokeRestart
[17:02:51.323]             length <- base::length
[17:02:51.323]             list <- base::list
[17:02:51.323]             seq.int <- base::seq.int
[17:02:51.323]             signalCondition <- base::signalCondition
[17:02:51.323]             sys.calls <- base::sys.calls
[17:02:51.323]             `[[` <- base::`[[`
[17:02:51.323]             `+` <- base::`+`
[17:02:51.323]             `<<-` <- base::`<<-`
[17:02:51.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.323]                   3L)]
[17:02:51.323]             }
[17:02:51.323]             function(cond) {
[17:02:51.323]                 is_error <- inherits(cond, "error")
[17:02:51.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.323]                   NULL)
[17:02:51.323]                 if (is_error) {
[17:02:51.323]                   sessionInformation <- function() {
[17:02:51.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.323]                       search = base::search(), system = base::Sys.info())
[17:02:51.323]                   }
[17:02:51.323]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.323]                     cond$call), session = sessionInformation(), 
[17:02:51.323]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.323]                   signalCondition(cond)
[17:02:51.323]                 }
[17:02:51.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.323]                 "immediateCondition"))) {
[17:02:51.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.323]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.323]                   if (TRUE && !signal) {
[17:02:51.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.323]                     {
[17:02:51.323]                       inherits <- base::inherits
[17:02:51.323]                       invokeRestart <- base::invokeRestart
[17:02:51.323]                       is.null <- base::is.null
[17:02:51.323]                       muffled <- FALSE
[17:02:51.323]                       if (inherits(cond, "message")) {
[17:02:51.323]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.323]                         if (muffled) 
[17:02:51.323]                           invokeRestart("muffleMessage")
[17:02:51.323]                       }
[17:02:51.323]                       else if (inherits(cond, "warning")) {
[17:02:51.323]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.323]                         if (muffled) 
[17:02:51.323]                           invokeRestart("muffleWarning")
[17:02:51.323]                       }
[17:02:51.323]                       else if (inherits(cond, "condition")) {
[17:02:51.323]                         if (!is.null(pattern)) {
[17:02:51.323]                           computeRestarts <- base::computeRestarts
[17:02:51.323]                           grepl <- base::grepl
[17:02:51.323]                           restarts <- computeRestarts(cond)
[17:02:51.323]                           for (restart in restarts) {
[17:02:51.323]                             name <- restart$name
[17:02:51.323]                             if (is.null(name)) 
[17:02:51.323]                               next
[17:02:51.323]                             if (!grepl(pattern, name)) 
[17:02:51.323]                               next
[17:02:51.323]                             invokeRestart(restart)
[17:02:51.323]                             muffled <- TRUE
[17:02:51.323]                             break
[17:02:51.323]                           }
[17:02:51.323]                         }
[17:02:51.323]                       }
[17:02:51.323]                       invisible(muffled)
[17:02:51.323]                     }
[17:02:51.323]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.323]                   }
[17:02:51.323]                 }
[17:02:51.323]                 else {
[17:02:51.323]                   if (TRUE) {
[17:02:51.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.323]                     {
[17:02:51.323]                       inherits <- base::inherits
[17:02:51.323]                       invokeRestart <- base::invokeRestart
[17:02:51.323]                       is.null <- base::is.null
[17:02:51.323]                       muffled <- FALSE
[17:02:51.323]                       if (inherits(cond, "message")) {
[17:02:51.323]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.323]                         if (muffled) 
[17:02:51.323]                           invokeRestart("muffleMessage")
[17:02:51.323]                       }
[17:02:51.323]                       else if (inherits(cond, "warning")) {
[17:02:51.323]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.323]                         if (muffled) 
[17:02:51.323]                           invokeRestart("muffleWarning")
[17:02:51.323]                       }
[17:02:51.323]                       else if (inherits(cond, "condition")) {
[17:02:51.323]                         if (!is.null(pattern)) {
[17:02:51.323]                           computeRestarts <- base::computeRestarts
[17:02:51.323]                           grepl <- base::grepl
[17:02:51.323]                           restarts <- computeRestarts(cond)
[17:02:51.323]                           for (restart in restarts) {
[17:02:51.323]                             name <- restart$name
[17:02:51.323]                             if (is.null(name)) 
[17:02:51.323]                               next
[17:02:51.323]                             if (!grepl(pattern, name)) 
[17:02:51.323]                               next
[17:02:51.323]                             invokeRestart(restart)
[17:02:51.323]                             muffled <- TRUE
[17:02:51.323]                             break
[17:02:51.323]                           }
[17:02:51.323]                         }
[17:02:51.323]                       }
[17:02:51.323]                       invisible(muffled)
[17:02:51.323]                     }
[17:02:51.323]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.323]                   }
[17:02:51.323]                 }
[17:02:51.323]             }
[17:02:51.323]         }))
[17:02:51.323]     }, error = function(ex) {
[17:02:51.323]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.323]                 ...future.rng), started = ...future.startTime, 
[17:02:51.323]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.323]             version = "1.8"), class = "FutureResult")
[17:02:51.323]     }, finally = {
[17:02:51.323]         if (!identical(...future.workdir, getwd())) 
[17:02:51.323]             setwd(...future.workdir)
[17:02:51.323]         {
[17:02:51.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.323]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.323]             }
[17:02:51.323]             base::options(...future.oldOptions)
[17:02:51.323]             if (.Platform$OS.type == "windows") {
[17:02:51.323]                 old_names <- names(...future.oldEnvVars)
[17:02:51.323]                 envs <- base::Sys.getenv()
[17:02:51.323]                 names <- names(envs)
[17:02:51.323]                 common <- intersect(names, old_names)
[17:02:51.323]                 added <- setdiff(names, old_names)
[17:02:51.323]                 removed <- setdiff(old_names, names)
[17:02:51.323]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.323]                   envs[common]]
[17:02:51.323]                 NAMES <- toupper(changed)
[17:02:51.323]                 args <- list()
[17:02:51.323]                 for (kk in seq_along(NAMES)) {
[17:02:51.323]                   name <- changed[[kk]]
[17:02:51.323]                   NAME <- NAMES[[kk]]
[17:02:51.323]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.323]                     next
[17:02:51.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.323]                 }
[17:02:51.323]                 NAMES <- toupper(added)
[17:02:51.323]                 for (kk in seq_along(NAMES)) {
[17:02:51.323]                   name <- added[[kk]]
[17:02:51.323]                   NAME <- NAMES[[kk]]
[17:02:51.323]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.323]                     next
[17:02:51.323]                   args[[name]] <- ""
[17:02:51.323]                 }
[17:02:51.323]                 NAMES <- toupper(removed)
[17:02:51.323]                 for (kk in seq_along(NAMES)) {
[17:02:51.323]                   name <- removed[[kk]]
[17:02:51.323]                   NAME <- NAMES[[kk]]
[17:02:51.323]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.323]                     next
[17:02:51.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.323]                 }
[17:02:51.323]                 if (length(args) > 0) 
[17:02:51.323]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.323]             }
[17:02:51.323]             else {
[17:02:51.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.323]             }
[17:02:51.323]             {
[17:02:51.323]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.323]                   0L) {
[17:02:51.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.323]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.323]                   base::options(opts)
[17:02:51.323]                 }
[17:02:51.323]                 {
[17:02:51.323]                   {
[17:02:51.323]                     NULL
[17:02:51.323]                     RNGkind("Mersenne-Twister")
[17:02:51.323]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.323]                       inherits = FALSE)
[17:02:51.323]                   }
[17:02:51.323]                   options(future.plan = NULL)
[17:02:51.323]                   if (is.na(NA_character_)) 
[17:02:51.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.323]                     .init = FALSE)
[17:02:51.323]                 }
[17:02:51.323]             }
[17:02:51.323]         }
[17:02:51.323]     })
[17:02:51.323]     if (TRUE) {
[17:02:51.323]         base::sink(type = "output", split = FALSE)
[17:02:51.323]         if (TRUE) {
[17:02:51.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.323]         }
[17:02:51.323]         else {
[17:02:51.323]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.323]         }
[17:02:51.323]         base::close(...future.stdout)
[17:02:51.323]         ...future.stdout <- NULL
[17:02:51.323]     }
[17:02:51.323]     ...future.result$conditions <- ...future.conditions
[17:02:51.323]     ...future.result$finished <- base::Sys.time()
[17:02:51.323]     ...future.result
[17:02:51.323] }
[17:02:51.325] assign_globals() ...
[17:02:51.325] List of 1
[17:02:51.325]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f6833070> 
[17:02:51.325]  - attr(*, "where")=List of 1
[17:02:51.325]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.325]  - attr(*, "resolved")= logi TRUE
[17:02:51.325]  - attr(*, "total_size")= num 1622272
[17:02:51.325]  - attr(*, "already-done")= logi TRUE
[17:02:51.327] - copied ‘a’ to environment
[17:02:51.327] assign_globals() ... done
[17:02:51.328] plan(): Setting new future strategy stack:
[17:02:51.328] List of future strategies:
[17:02:51.328] 1. sequential:
[17:02:51.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.328]    - tweaked: FALSE
[17:02:51.328]    - call: NULL
[17:02:51.328] plan(): nbrOfWorkers() = 1
[17:02:51.329] plan(): Setting new future strategy stack:
[17:02:51.329] List of future strategies:
[17:02:51.329] 1. sequential:
[17:02:51.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.329]    - tweaked: FALSE
[17:02:51.329]    - call: plan(strategy)
[17:02:51.330] plan(): nbrOfWorkers() = 1
[17:02:51.330] SequentialFuture started (and completed)
[17:02:51.330] - Launch lazy future ... done
[17:02:51.330] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.330] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.331] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.331] 
[17:02:51.331] Searching for globals ... DONE
[17:02:51.331] - globals: [0] <none>
[17:02:51.331] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.332] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.332] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.332] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.333] Searching for globals ... DONE
[17:02:51.333] Resolving globals: TRUE
[17:02:51.333] Resolving any globals that are futures ...
[17:02:51.333] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.333] Resolving any globals that are futures ... DONE
[17:02:51.333] Resolving futures part of globals (recursively) ...
[17:02:51.333] resolve() on list ...
[17:02:51.334]  recursive: 99
[17:02:51.334]  length: 1
[17:02:51.334]  elements: ‘a’
[17:02:51.334] run() for ‘Future’ ...
[17:02:51.334] - state: ‘created’
[17:02:51.334] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.334] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.335]   - Field: ‘label’
[17:02:51.335]   - Field: ‘local’
[17:02:51.335]   - Field: ‘owner’
[17:02:51.335]   - Field: ‘envir’
[17:02:51.335]   - Field: ‘packages’
[17:02:51.335]   - Field: ‘gc’
[17:02:51.335]   - Field: ‘conditions’
[17:02:51.335]   - Field: ‘expr’
[17:02:51.335]   - Field: ‘uuid’
[17:02:51.335]   - Field: ‘seed’
[17:02:51.336]   - Field: ‘version’
[17:02:51.336]   - Field: ‘result’
[17:02:51.336]   - Field: ‘asynchronous’
[17:02:51.336]   - Field: ‘calls’
[17:02:51.336]   - Field: ‘globals’
[17:02:51.336]   - Field: ‘stdout’
[17:02:51.336]   - Field: ‘earlySignal’
[17:02:51.336]   - Field: ‘lazy’
[17:02:51.336]   - Field: ‘state’
[17:02:51.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.336] - Launch lazy future ...
[17:02:51.337] Packages needed by the future expression (n = 0): <none>
[17:02:51.337] Packages needed by future strategies (n = 0): <none>
[17:02:51.337] {
[17:02:51.337]     {
[17:02:51.337]         {
[17:02:51.337]             ...future.startTime <- base::Sys.time()
[17:02:51.337]             {
[17:02:51.337]                 {
[17:02:51.337]                   {
[17:02:51.337]                     base::local({
[17:02:51.337]                       has_future <- base::requireNamespace("future", 
[17:02:51.337]                         quietly = TRUE)
[17:02:51.337]                       if (has_future) {
[17:02:51.337]                         ns <- base::getNamespace("future")
[17:02:51.337]                         version <- ns[[".package"]][["version"]]
[17:02:51.337]                         if (is.null(version)) 
[17:02:51.337]                           version <- utils::packageVersion("future")
[17:02:51.337]                       }
[17:02:51.337]                       else {
[17:02:51.337]                         version <- NULL
[17:02:51.337]                       }
[17:02:51.337]                       if (!has_future || version < "1.8.0") {
[17:02:51.337]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.337]                           "", base::R.version$version.string), 
[17:02:51.337]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.337]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.337]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.337]                             "release", "version")], collapse = " "), 
[17:02:51.337]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.337]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.337]                           info)
[17:02:51.337]                         info <- base::paste(info, collapse = "; ")
[17:02:51.337]                         if (!has_future) {
[17:02:51.337]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.337]                             info)
[17:02:51.337]                         }
[17:02:51.337]                         else {
[17:02:51.337]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.337]                             info, version)
[17:02:51.337]                         }
[17:02:51.337]                         base::stop(msg)
[17:02:51.337]                       }
[17:02:51.337]                     })
[17:02:51.337]                   }
[17:02:51.337]                   ...future.strategy.old <- future::plan("list")
[17:02:51.337]                   options(future.plan = NULL)
[17:02:51.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.337]                 }
[17:02:51.337]                 ...future.workdir <- getwd()
[17:02:51.337]             }
[17:02:51.337]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.337]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.337]         }
[17:02:51.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.337]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.337]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.337]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.337]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.337]             base::names(...future.oldOptions))
[17:02:51.337]     }
[17:02:51.337]     if (FALSE) {
[17:02:51.337]     }
[17:02:51.337]     else {
[17:02:51.337]         if (TRUE) {
[17:02:51.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.337]                 open = "w")
[17:02:51.337]         }
[17:02:51.337]         else {
[17:02:51.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.337]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.337]         }
[17:02:51.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.337]             base::sink(type = "output", split = FALSE)
[17:02:51.337]             base::close(...future.stdout)
[17:02:51.337]         }, add = TRUE)
[17:02:51.337]     }
[17:02:51.337]     ...future.frame <- base::sys.nframe()
[17:02:51.337]     ...future.conditions <- base::list()
[17:02:51.337]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.337]     if (FALSE) {
[17:02:51.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.337]     }
[17:02:51.337]     ...future.result <- base::tryCatch({
[17:02:51.337]         base::withCallingHandlers({
[17:02:51.337]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.337]             future::FutureResult(value = ...future.value$value, 
[17:02:51.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.337]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.337]                     ...future.globalenv.names))
[17:02:51.337]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.337]         }, condition = base::local({
[17:02:51.337]             c <- base::c
[17:02:51.337]             inherits <- base::inherits
[17:02:51.337]             invokeRestart <- base::invokeRestart
[17:02:51.337]             length <- base::length
[17:02:51.337]             list <- base::list
[17:02:51.337]             seq.int <- base::seq.int
[17:02:51.337]             signalCondition <- base::signalCondition
[17:02:51.337]             sys.calls <- base::sys.calls
[17:02:51.337]             `[[` <- base::`[[`
[17:02:51.337]             `+` <- base::`+`
[17:02:51.337]             `<<-` <- base::`<<-`
[17:02:51.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.337]                   3L)]
[17:02:51.337]             }
[17:02:51.337]             function(cond) {
[17:02:51.337]                 is_error <- inherits(cond, "error")
[17:02:51.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.337]                   NULL)
[17:02:51.337]                 if (is_error) {
[17:02:51.337]                   sessionInformation <- function() {
[17:02:51.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.337]                       search = base::search(), system = base::Sys.info())
[17:02:51.337]                   }
[17:02:51.337]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.337]                     cond$call), session = sessionInformation(), 
[17:02:51.337]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.337]                   signalCondition(cond)
[17:02:51.337]                 }
[17:02:51.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.337]                 "immediateCondition"))) {
[17:02:51.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.337]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.337]                   if (TRUE && !signal) {
[17:02:51.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.337]                     {
[17:02:51.337]                       inherits <- base::inherits
[17:02:51.337]                       invokeRestart <- base::invokeRestart
[17:02:51.337]                       is.null <- base::is.null
[17:02:51.337]                       muffled <- FALSE
[17:02:51.337]                       if (inherits(cond, "message")) {
[17:02:51.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.337]                         if (muffled) 
[17:02:51.337]                           invokeRestart("muffleMessage")
[17:02:51.337]                       }
[17:02:51.337]                       else if (inherits(cond, "warning")) {
[17:02:51.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.337]                         if (muffled) 
[17:02:51.337]                           invokeRestart("muffleWarning")
[17:02:51.337]                       }
[17:02:51.337]                       else if (inherits(cond, "condition")) {
[17:02:51.337]                         if (!is.null(pattern)) {
[17:02:51.337]                           computeRestarts <- base::computeRestarts
[17:02:51.337]                           grepl <- base::grepl
[17:02:51.337]                           restarts <- computeRestarts(cond)
[17:02:51.337]                           for (restart in restarts) {
[17:02:51.337]                             name <- restart$name
[17:02:51.337]                             if (is.null(name)) 
[17:02:51.337]                               next
[17:02:51.337]                             if (!grepl(pattern, name)) 
[17:02:51.337]                               next
[17:02:51.337]                             invokeRestart(restart)
[17:02:51.337]                             muffled <- TRUE
[17:02:51.337]                             break
[17:02:51.337]                           }
[17:02:51.337]                         }
[17:02:51.337]                       }
[17:02:51.337]                       invisible(muffled)
[17:02:51.337]                     }
[17:02:51.337]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.337]                   }
[17:02:51.337]                 }
[17:02:51.337]                 else {
[17:02:51.337]                   if (TRUE) {
[17:02:51.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.337]                     {
[17:02:51.337]                       inherits <- base::inherits
[17:02:51.337]                       invokeRestart <- base::invokeRestart
[17:02:51.337]                       is.null <- base::is.null
[17:02:51.337]                       muffled <- FALSE
[17:02:51.337]                       if (inherits(cond, "message")) {
[17:02:51.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.337]                         if (muffled) 
[17:02:51.337]                           invokeRestart("muffleMessage")
[17:02:51.337]                       }
[17:02:51.337]                       else if (inherits(cond, "warning")) {
[17:02:51.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.337]                         if (muffled) 
[17:02:51.337]                           invokeRestart("muffleWarning")
[17:02:51.337]                       }
[17:02:51.337]                       else if (inherits(cond, "condition")) {
[17:02:51.337]                         if (!is.null(pattern)) {
[17:02:51.337]                           computeRestarts <- base::computeRestarts
[17:02:51.337]                           grepl <- base::grepl
[17:02:51.337]                           restarts <- computeRestarts(cond)
[17:02:51.337]                           for (restart in restarts) {
[17:02:51.337]                             name <- restart$name
[17:02:51.337]                             if (is.null(name)) 
[17:02:51.337]                               next
[17:02:51.337]                             if (!grepl(pattern, name)) 
[17:02:51.337]                               next
[17:02:51.337]                             invokeRestart(restart)
[17:02:51.337]                             muffled <- TRUE
[17:02:51.337]                             break
[17:02:51.337]                           }
[17:02:51.337]                         }
[17:02:51.337]                       }
[17:02:51.337]                       invisible(muffled)
[17:02:51.337]                     }
[17:02:51.337]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.337]                   }
[17:02:51.337]                 }
[17:02:51.337]             }
[17:02:51.337]         }))
[17:02:51.337]     }, error = function(ex) {
[17:02:51.337]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.337]                 ...future.rng), started = ...future.startTime, 
[17:02:51.337]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.337]             version = "1.8"), class = "FutureResult")
[17:02:51.337]     }, finally = {
[17:02:51.337]         if (!identical(...future.workdir, getwd())) 
[17:02:51.337]             setwd(...future.workdir)
[17:02:51.337]         {
[17:02:51.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.337]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.337]             }
[17:02:51.337]             base::options(...future.oldOptions)
[17:02:51.337]             if (.Platform$OS.type == "windows") {
[17:02:51.337]                 old_names <- names(...future.oldEnvVars)
[17:02:51.337]                 envs <- base::Sys.getenv()
[17:02:51.337]                 names <- names(envs)
[17:02:51.337]                 common <- intersect(names, old_names)
[17:02:51.337]                 added <- setdiff(names, old_names)
[17:02:51.337]                 removed <- setdiff(old_names, names)
[17:02:51.337]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.337]                   envs[common]]
[17:02:51.337]                 NAMES <- toupper(changed)
[17:02:51.337]                 args <- list()
[17:02:51.337]                 for (kk in seq_along(NAMES)) {
[17:02:51.337]                   name <- changed[[kk]]
[17:02:51.337]                   NAME <- NAMES[[kk]]
[17:02:51.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.337]                     next
[17:02:51.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.337]                 }
[17:02:51.337]                 NAMES <- toupper(added)
[17:02:51.337]                 for (kk in seq_along(NAMES)) {
[17:02:51.337]                   name <- added[[kk]]
[17:02:51.337]                   NAME <- NAMES[[kk]]
[17:02:51.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.337]                     next
[17:02:51.337]                   args[[name]] <- ""
[17:02:51.337]                 }
[17:02:51.337]                 NAMES <- toupper(removed)
[17:02:51.337]                 for (kk in seq_along(NAMES)) {
[17:02:51.337]                   name <- removed[[kk]]
[17:02:51.337]                   NAME <- NAMES[[kk]]
[17:02:51.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.337]                     next
[17:02:51.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.337]                 }
[17:02:51.337]                 if (length(args) > 0) 
[17:02:51.337]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.337]             }
[17:02:51.337]             else {
[17:02:51.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.337]             }
[17:02:51.337]             {
[17:02:51.337]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.337]                   0L) {
[17:02:51.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.337]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.337]                   base::options(opts)
[17:02:51.337]                 }
[17:02:51.337]                 {
[17:02:51.337]                   {
[17:02:51.337]                     NULL
[17:02:51.337]                     RNGkind("Mersenne-Twister")
[17:02:51.337]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.337]                       inherits = FALSE)
[17:02:51.337]                   }
[17:02:51.337]                   options(future.plan = NULL)
[17:02:51.337]                   if (is.na(NA_character_)) 
[17:02:51.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.337]                     .init = FALSE)
[17:02:51.337]                 }
[17:02:51.337]             }
[17:02:51.337]         }
[17:02:51.337]     })
[17:02:51.337]     if (TRUE) {
[17:02:51.337]         base::sink(type = "output", split = FALSE)
[17:02:51.337]         if (TRUE) {
[17:02:51.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.337]         }
[17:02:51.337]         else {
[17:02:51.337]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.337]         }
[17:02:51.337]         base::close(...future.stdout)
[17:02:51.337]         ...future.stdout <- NULL
[17:02:51.337]     }
[17:02:51.337]     ...future.result$conditions <- ...future.conditions
[17:02:51.337]     ...future.result$finished <- base::Sys.time()
[17:02:51.337]     ...future.result
[17:02:51.337] }
[17:02:51.368] plan(): Setting new future strategy stack:
[17:02:51.368] List of future strategies:
[17:02:51.368] 1. sequential:
[17:02:51.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.368]    - tweaked: FALSE
[17:02:51.368]    - call: NULL
[17:02:51.368] plan(): nbrOfWorkers() = 1
[17:02:51.369] plan(): Setting new future strategy stack:
[17:02:51.369] List of future strategies:
[17:02:51.369] 1. sequential:
[17:02:51.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.369]    - tweaked: FALSE
[17:02:51.369]    - call: plan(strategy)
[17:02:51.370] plan(): nbrOfWorkers() = 1
[17:02:51.370] SequentialFuture started (and completed)
[17:02:51.370] - Launch lazy future ... done
[17:02:51.370] run() for ‘SequentialFuture’ ... done
[17:02:51.370] resolved() for ‘SequentialFuture’ ...
[17:02:51.370] - state: ‘finished’
[17:02:51.371] - run: TRUE
[17:02:51.371] - result: ‘FutureResult’
[17:02:51.371] resolved() for ‘SequentialFuture’ ... done
[17:02:51.371] Future #1
[17:02:51.371] resolved() for ‘SequentialFuture’ ...
[17:02:51.371] - state: ‘finished’
[17:02:51.371] - run: TRUE
[17:02:51.371] - result: ‘FutureResult’
[17:02:51.371] resolved() for ‘SequentialFuture’ ... done
[17:02:51.371] A SequentialFuture was resolved
[17:02:51.372]  length: 0 (resolved future 1)
[17:02:51.372] resolve() on list ... DONE
[17:02:51.372] - globals: [1] ‘a’
[17:02:51.372] Resolving futures part of globals (recursively) ... DONE
[17:02:51.374] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[17:02:51.374] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:02:51.374] - globals: [1] ‘a’
[17:02:51.374] - packages: [1] ‘future’
[17:02:51.374] getGlobalsAndPackages() ... DONE
[17:02:51.375] run() for ‘Future’ ...
[17:02:51.375] - state: ‘created’
[17:02:51.375] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.375] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.375]   - Field: ‘label’
[17:02:51.375]   - Field: ‘local’
[17:02:51.376]   - Field: ‘owner’
[17:02:51.376]   - Field: ‘envir’
[17:02:51.376]   - Field: ‘packages’
[17:02:51.376]   - Field: ‘gc’
[17:02:51.376]   - Field: ‘conditions’
[17:02:51.376]   - Field: ‘expr’
[17:02:51.376]   - Field: ‘uuid’
[17:02:51.376]   - Field: ‘seed’
[17:02:51.376]   - Field: ‘version’
[17:02:51.376]   - Field: ‘result’
[17:02:51.377]   - Field: ‘asynchronous’
[17:02:51.377]   - Field: ‘calls’
[17:02:51.377]   - Field: ‘globals’
[17:02:51.377]   - Field: ‘stdout’
[17:02:51.377]   - Field: ‘earlySignal’
[17:02:51.377]   - Field: ‘lazy’
[17:02:51.377]   - Field: ‘state’
[17:02:51.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.377] - Launch lazy future ...
[17:02:51.377] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.378] Packages needed by future strategies (n = 0): <none>
[17:02:51.378] {
[17:02:51.378]     {
[17:02:51.378]         {
[17:02:51.378]             ...future.startTime <- base::Sys.time()
[17:02:51.378]             {
[17:02:51.378]                 {
[17:02:51.378]                   {
[17:02:51.378]                     {
[17:02:51.378]                       base::local({
[17:02:51.378]                         has_future <- base::requireNamespace("future", 
[17:02:51.378]                           quietly = TRUE)
[17:02:51.378]                         if (has_future) {
[17:02:51.378]                           ns <- base::getNamespace("future")
[17:02:51.378]                           version <- ns[[".package"]][["version"]]
[17:02:51.378]                           if (is.null(version)) 
[17:02:51.378]                             version <- utils::packageVersion("future")
[17:02:51.378]                         }
[17:02:51.378]                         else {
[17:02:51.378]                           version <- NULL
[17:02:51.378]                         }
[17:02:51.378]                         if (!has_future || version < "1.8.0") {
[17:02:51.378]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.378]                             "", base::R.version$version.string), 
[17:02:51.378]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.378]                               "release", "version")], collapse = " "), 
[17:02:51.378]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.378]                             info)
[17:02:51.378]                           info <- base::paste(info, collapse = "; ")
[17:02:51.378]                           if (!has_future) {
[17:02:51.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.378]                               info)
[17:02:51.378]                           }
[17:02:51.378]                           else {
[17:02:51.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.378]                               info, version)
[17:02:51.378]                           }
[17:02:51.378]                           base::stop(msg)
[17:02:51.378]                         }
[17:02:51.378]                       })
[17:02:51.378]                     }
[17:02:51.378]                     base::local({
[17:02:51.378]                       for (pkg in "future") {
[17:02:51.378]                         base::loadNamespace(pkg)
[17:02:51.378]                         base::library(pkg, character.only = TRUE)
[17:02:51.378]                       }
[17:02:51.378]                     })
[17:02:51.378]                   }
[17:02:51.378]                   ...future.strategy.old <- future::plan("list")
[17:02:51.378]                   options(future.plan = NULL)
[17:02:51.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.378]                 }
[17:02:51.378]                 ...future.workdir <- getwd()
[17:02:51.378]             }
[17:02:51.378]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.378]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.378]         }
[17:02:51.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.378]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.378]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.378]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.378]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.378]             base::names(...future.oldOptions))
[17:02:51.378]     }
[17:02:51.378]     if (FALSE) {
[17:02:51.378]     }
[17:02:51.378]     else {
[17:02:51.378]         if (TRUE) {
[17:02:51.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.378]                 open = "w")
[17:02:51.378]         }
[17:02:51.378]         else {
[17:02:51.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.378]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.378]         }
[17:02:51.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.378]             base::sink(type = "output", split = FALSE)
[17:02:51.378]             base::close(...future.stdout)
[17:02:51.378]         }, add = TRUE)
[17:02:51.378]     }
[17:02:51.378]     ...future.frame <- base::sys.nframe()
[17:02:51.378]     ...future.conditions <- base::list()
[17:02:51.378]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.378]     if (FALSE) {
[17:02:51.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.378]     }
[17:02:51.378]     ...future.result <- base::tryCatch({
[17:02:51.378]         base::withCallingHandlers({
[17:02:51.378]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.378]                 1))
[17:02:51.378]             future::FutureResult(value = ...future.value$value, 
[17:02:51.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.378]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.378]                     ...future.globalenv.names))
[17:02:51.378]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.378]         }, condition = base::local({
[17:02:51.378]             c <- base::c
[17:02:51.378]             inherits <- base::inherits
[17:02:51.378]             invokeRestart <- base::invokeRestart
[17:02:51.378]             length <- base::length
[17:02:51.378]             list <- base::list
[17:02:51.378]             seq.int <- base::seq.int
[17:02:51.378]             signalCondition <- base::signalCondition
[17:02:51.378]             sys.calls <- base::sys.calls
[17:02:51.378]             `[[` <- base::`[[`
[17:02:51.378]             `+` <- base::`+`
[17:02:51.378]             `<<-` <- base::`<<-`
[17:02:51.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.378]                   3L)]
[17:02:51.378]             }
[17:02:51.378]             function(cond) {
[17:02:51.378]                 is_error <- inherits(cond, "error")
[17:02:51.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.378]                   NULL)
[17:02:51.378]                 if (is_error) {
[17:02:51.378]                   sessionInformation <- function() {
[17:02:51.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.378]                       search = base::search(), system = base::Sys.info())
[17:02:51.378]                   }
[17:02:51.378]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.378]                     cond$call), session = sessionInformation(), 
[17:02:51.378]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.378]                   signalCondition(cond)
[17:02:51.378]                 }
[17:02:51.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.378]                 "immediateCondition"))) {
[17:02:51.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.378]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.378]                   if (TRUE && !signal) {
[17:02:51.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.378]                     {
[17:02:51.378]                       inherits <- base::inherits
[17:02:51.378]                       invokeRestart <- base::invokeRestart
[17:02:51.378]                       is.null <- base::is.null
[17:02:51.378]                       muffled <- FALSE
[17:02:51.378]                       if (inherits(cond, "message")) {
[17:02:51.378]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.378]                         if (muffled) 
[17:02:51.378]                           invokeRestart("muffleMessage")
[17:02:51.378]                       }
[17:02:51.378]                       else if (inherits(cond, "warning")) {
[17:02:51.378]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.378]                         if (muffled) 
[17:02:51.378]                           invokeRestart("muffleWarning")
[17:02:51.378]                       }
[17:02:51.378]                       else if (inherits(cond, "condition")) {
[17:02:51.378]                         if (!is.null(pattern)) {
[17:02:51.378]                           computeRestarts <- base::computeRestarts
[17:02:51.378]                           grepl <- base::grepl
[17:02:51.378]                           restarts <- computeRestarts(cond)
[17:02:51.378]                           for (restart in restarts) {
[17:02:51.378]                             name <- restart$name
[17:02:51.378]                             if (is.null(name)) 
[17:02:51.378]                               next
[17:02:51.378]                             if (!grepl(pattern, name)) 
[17:02:51.378]                               next
[17:02:51.378]                             invokeRestart(restart)
[17:02:51.378]                             muffled <- TRUE
[17:02:51.378]                             break
[17:02:51.378]                           }
[17:02:51.378]                         }
[17:02:51.378]                       }
[17:02:51.378]                       invisible(muffled)
[17:02:51.378]                     }
[17:02:51.378]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.378]                   }
[17:02:51.378]                 }
[17:02:51.378]                 else {
[17:02:51.378]                   if (TRUE) {
[17:02:51.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.378]                     {
[17:02:51.378]                       inherits <- base::inherits
[17:02:51.378]                       invokeRestart <- base::invokeRestart
[17:02:51.378]                       is.null <- base::is.null
[17:02:51.378]                       muffled <- FALSE
[17:02:51.378]                       if (inherits(cond, "message")) {
[17:02:51.378]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.378]                         if (muffled) 
[17:02:51.378]                           invokeRestart("muffleMessage")
[17:02:51.378]                       }
[17:02:51.378]                       else if (inherits(cond, "warning")) {
[17:02:51.378]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.378]                         if (muffled) 
[17:02:51.378]                           invokeRestart("muffleWarning")
[17:02:51.378]                       }
[17:02:51.378]                       else if (inherits(cond, "condition")) {
[17:02:51.378]                         if (!is.null(pattern)) {
[17:02:51.378]                           computeRestarts <- base::computeRestarts
[17:02:51.378]                           grepl <- base::grepl
[17:02:51.378]                           restarts <- computeRestarts(cond)
[17:02:51.378]                           for (restart in restarts) {
[17:02:51.378]                             name <- restart$name
[17:02:51.378]                             if (is.null(name)) 
[17:02:51.378]                               next
[17:02:51.378]                             if (!grepl(pattern, name)) 
[17:02:51.378]                               next
[17:02:51.378]                             invokeRestart(restart)
[17:02:51.378]                             muffled <- TRUE
[17:02:51.378]                             break
[17:02:51.378]                           }
[17:02:51.378]                         }
[17:02:51.378]                       }
[17:02:51.378]                       invisible(muffled)
[17:02:51.378]                     }
[17:02:51.378]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.378]                   }
[17:02:51.378]                 }
[17:02:51.378]             }
[17:02:51.378]         }))
[17:02:51.378]     }, error = function(ex) {
[17:02:51.378]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.378]                 ...future.rng), started = ...future.startTime, 
[17:02:51.378]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.378]             version = "1.8"), class = "FutureResult")
[17:02:51.378]     }, finally = {
[17:02:51.378]         if (!identical(...future.workdir, getwd())) 
[17:02:51.378]             setwd(...future.workdir)
[17:02:51.378]         {
[17:02:51.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.378]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.378]             }
[17:02:51.378]             base::options(...future.oldOptions)
[17:02:51.378]             if (.Platform$OS.type == "windows") {
[17:02:51.378]                 old_names <- names(...future.oldEnvVars)
[17:02:51.378]                 envs <- base::Sys.getenv()
[17:02:51.378]                 names <- names(envs)
[17:02:51.378]                 common <- intersect(names, old_names)
[17:02:51.378]                 added <- setdiff(names, old_names)
[17:02:51.378]                 removed <- setdiff(old_names, names)
[17:02:51.378]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.378]                   envs[common]]
[17:02:51.378]                 NAMES <- toupper(changed)
[17:02:51.378]                 args <- list()
[17:02:51.378]                 for (kk in seq_along(NAMES)) {
[17:02:51.378]                   name <- changed[[kk]]
[17:02:51.378]                   NAME <- NAMES[[kk]]
[17:02:51.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.378]                     next
[17:02:51.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.378]                 }
[17:02:51.378]                 NAMES <- toupper(added)
[17:02:51.378]                 for (kk in seq_along(NAMES)) {
[17:02:51.378]                   name <- added[[kk]]
[17:02:51.378]                   NAME <- NAMES[[kk]]
[17:02:51.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.378]                     next
[17:02:51.378]                   args[[name]] <- ""
[17:02:51.378]                 }
[17:02:51.378]                 NAMES <- toupper(removed)
[17:02:51.378]                 for (kk in seq_along(NAMES)) {
[17:02:51.378]                   name <- removed[[kk]]
[17:02:51.378]                   NAME <- NAMES[[kk]]
[17:02:51.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.378]                     next
[17:02:51.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.378]                 }
[17:02:51.378]                 if (length(args) > 0) 
[17:02:51.378]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.378]             }
[17:02:51.378]             else {
[17:02:51.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.378]             }
[17:02:51.378]             {
[17:02:51.378]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.378]                   0L) {
[17:02:51.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.378]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.378]                   base::options(opts)
[17:02:51.378]                 }
[17:02:51.378]                 {
[17:02:51.378]                   {
[17:02:51.378]                     NULL
[17:02:51.378]                     RNGkind("Mersenne-Twister")
[17:02:51.378]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.378]                       inherits = FALSE)
[17:02:51.378]                   }
[17:02:51.378]                   options(future.plan = NULL)
[17:02:51.378]                   if (is.na(NA_character_)) 
[17:02:51.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.378]                     .init = FALSE)
[17:02:51.378]                 }
[17:02:51.378]             }
[17:02:51.378]         }
[17:02:51.378]     })
[17:02:51.378]     if (TRUE) {
[17:02:51.378]         base::sink(type = "output", split = FALSE)
[17:02:51.378]         if (TRUE) {
[17:02:51.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.378]         }
[17:02:51.378]         else {
[17:02:51.378]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.378]         }
[17:02:51.378]         base::close(...future.stdout)
[17:02:51.378]         ...future.stdout <- NULL
[17:02:51.378]     }
[17:02:51.378]     ...future.result$conditions <- ...future.conditions
[17:02:51.378]     ...future.result$finished <- base::Sys.time()
[17:02:51.378]     ...future.result
[17:02:51.378] }
[17:02:51.380] assign_globals() ...
[17:02:51.380] List of 1
[17:02:51.380]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f6842c10> 
[17:02:51.380]  - attr(*, "where")=List of 1
[17:02:51.380]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.380]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.380]  - attr(*, "resolved")= logi TRUE
[17:02:51.380]  - attr(*, "total_size")= num 1622440
[17:02:51.380]  - attr(*, "already-done")= logi TRUE
[17:02:51.382] - copied ‘a’ to environment
[17:02:51.382] assign_globals() ... done
[17:02:51.383] plan(): Setting new future strategy stack:
[17:02:51.383] List of future strategies:
[17:02:51.383] 1. sequential:
[17:02:51.383]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.383]    - tweaked: FALSE
[17:02:51.383]    - call: NULL
[17:02:51.383] plan(): nbrOfWorkers() = 1
[17:02:51.384] plan(): Setting new future strategy stack:
[17:02:51.384] List of future strategies:
[17:02:51.384] 1. sequential:
[17:02:51.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.384]    - tweaked: FALSE
[17:02:51.384]    - call: plan(strategy)
[17:02:51.384] plan(): nbrOfWorkers() = 1
[17:02:51.385] SequentialFuture started (and completed)
[17:02:51.385] - Launch lazy future ... done
[17:02:51.385] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.385] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.385] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.386] 
[17:02:51.386] Searching for globals ... DONE
[17:02:51.386] - globals: [0] <none>
[17:02:51.386] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.386] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.387] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.387] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.388] Searching for globals ... DONE
[17:02:51.388] Resolving globals: TRUE
[17:02:51.388] Resolving any globals that are futures ...
[17:02:51.388] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.388] Resolving any globals that are futures ... DONE
[17:02:51.388] Resolving futures part of globals (recursively) ...
[17:02:51.388] resolve() on list ...
[17:02:51.389]  recursive: 99
[17:02:51.389]  length: 1
[17:02:51.389]  elements: ‘a’
[17:02:51.389] run() for ‘Future’ ...
[17:02:51.389] - state: ‘created’
[17:02:51.389] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.390]   - Field: ‘label’
[17:02:51.390]   - Field: ‘local’
[17:02:51.390]   - Field: ‘owner’
[17:02:51.390]   - Field: ‘envir’
[17:02:51.390]   - Field: ‘packages’
[17:02:51.390]   - Field: ‘gc’
[17:02:51.390]   - Field: ‘conditions’
[17:02:51.390]   - Field: ‘expr’
[17:02:51.390]   - Field: ‘uuid’
[17:02:51.390]   - Field: ‘seed’
[17:02:51.390]   - Field: ‘version’
[17:02:51.391]   - Field: ‘result’
[17:02:51.391]   - Field: ‘asynchronous’
[17:02:51.391]   - Field: ‘calls’
[17:02:51.391]   - Field: ‘globals’
[17:02:51.391]   - Field: ‘stdout’
[17:02:51.391]   - Field: ‘earlySignal’
[17:02:51.391]   - Field: ‘lazy’
[17:02:51.391]   - Field: ‘state’
[17:02:51.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.391] - Launch lazy future ...
[17:02:51.392] Packages needed by the future expression (n = 0): <none>
[17:02:51.392] Packages needed by future strategies (n = 0): <none>
[17:02:51.392] {
[17:02:51.392]     {
[17:02:51.392]         {
[17:02:51.392]             ...future.startTime <- base::Sys.time()
[17:02:51.392]             {
[17:02:51.392]                 {
[17:02:51.392]                   {
[17:02:51.392]                     base::local({
[17:02:51.392]                       has_future <- base::requireNamespace("future", 
[17:02:51.392]                         quietly = TRUE)
[17:02:51.392]                       if (has_future) {
[17:02:51.392]                         ns <- base::getNamespace("future")
[17:02:51.392]                         version <- ns[[".package"]][["version"]]
[17:02:51.392]                         if (is.null(version)) 
[17:02:51.392]                           version <- utils::packageVersion("future")
[17:02:51.392]                       }
[17:02:51.392]                       else {
[17:02:51.392]                         version <- NULL
[17:02:51.392]                       }
[17:02:51.392]                       if (!has_future || version < "1.8.0") {
[17:02:51.392]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.392]                           "", base::R.version$version.string), 
[17:02:51.392]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.392]                             "release", "version")], collapse = " "), 
[17:02:51.392]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.392]                           info)
[17:02:51.392]                         info <- base::paste(info, collapse = "; ")
[17:02:51.392]                         if (!has_future) {
[17:02:51.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.392]                             info)
[17:02:51.392]                         }
[17:02:51.392]                         else {
[17:02:51.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.392]                             info, version)
[17:02:51.392]                         }
[17:02:51.392]                         base::stop(msg)
[17:02:51.392]                       }
[17:02:51.392]                     })
[17:02:51.392]                   }
[17:02:51.392]                   ...future.strategy.old <- future::plan("list")
[17:02:51.392]                   options(future.plan = NULL)
[17:02:51.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.392]                 }
[17:02:51.392]                 ...future.workdir <- getwd()
[17:02:51.392]             }
[17:02:51.392]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.392]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.392]         }
[17:02:51.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.392]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.392]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.392]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.392]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.392]             base::names(...future.oldOptions))
[17:02:51.392]     }
[17:02:51.392]     if (FALSE) {
[17:02:51.392]     }
[17:02:51.392]     else {
[17:02:51.392]         if (TRUE) {
[17:02:51.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.392]                 open = "w")
[17:02:51.392]         }
[17:02:51.392]         else {
[17:02:51.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.392]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.392]         }
[17:02:51.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.392]             base::sink(type = "output", split = FALSE)
[17:02:51.392]             base::close(...future.stdout)
[17:02:51.392]         }, add = TRUE)
[17:02:51.392]     }
[17:02:51.392]     ...future.frame <- base::sys.nframe()
[17:02:51.392]     ...future.conditions <- base::list()
[17:02:51.392]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.392]     if (FALSE) {
[17:02:51.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.392]     }
[17:02:51.392]     ...future.result <- base::tryCatch({
[17:02:51.392]         base::withCallingHandlers({
[17:02:51.392]             ...future.value <- base::withVisible(base::local(1))
[17:02:51.392]             future::FutureResult(value = ...future.value$value, 
[17:02:51.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.392]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.392]                     ...future.globalenv.names))
[17:02:51.392]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.392]         }, condition = base::local({
[17:02:51.392]             c <- base::c
[17:02:51.392]             inherits <- base::inherits
[17:02:51.392]             invokeRestart <- base::invokeRestart
[17:02:51.392]             length <- base::length
[17:02:51.392]             list <- base::list
[17:02:51.392]             seq.int <- base::seq.int
[17:02:51.392]             signalCondition <- base::signalCondition
[17:02:51.392]             sys.calls <- base::sys.calls
[17:02:51.392]             `[[` <- base::`[[`
[17:02:51.392]             `+` <- base::`+`
[17:02:51.392]             `<<-` <- base::`<<-`
[17:02:51.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.392]                   3L)]
[17:02:51.392]             }
[17:02:51.392]             function(cond) {
[17:02:51.392]                 is_error <- inherits(cond, "error")
[17:02:51.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.392]                   NULL)
[17:02:51.392]                 if (is_error) {
[17:02:51.392]                   sessionInformation <- function() {
[17:02:51.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.392]                       search = base::search(), system = base::Sys.info())
[17:02:51.392]                   }
[17:02:51.392]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.392]                     cond$call), session = sessionInformation(), 
[17:02:51.392]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.392]                   signalCondition(cond)
[17:02:51.392]                 }
[17:02:51.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.392]                 "immediateCondition"))) {
[17:02:51.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.392]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.392]                   if (TRUE && !signal) {
[17:02:51.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.392]                     {
[17:02:51.392]                       inherits <- base::inherits
[17:02:51.392]                       invokeRestart <- base::invokeRestart
[17:02:51.392]                       is.null <- base::is.null
[17:02:51.392]                       muffled <- FALSE
[17:02:51.392]                       if (inherits(cond, "message")) {
[17:02:51.392]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.392]                         if (muffled) 
[17:02:51.392]                           invokeRestart("muffleMessage")
[17:02:51.392]                       }
[17:02:51.392]                       else if (inherits(cond, "warning")) {
[17:02:51.392]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.392]                         if (muffled) 
[17:02:51.392]                           invokeRestart("muffleWarning")
[17:02:51.392]                       }
[17:02:51.392]                       else if (inherits(cond, "condition")) {
[17:02:51.392]                         if (!is.null(pattern)) {
[17:02:51.392]                           computeRestarts <- base::computeRestarts
[17:02:51.392]                           grepl <- base::grepl
[17:02:51.392]                           restarts <- computeRestarts(cond)
[17:02:51.392]                           for (restart in restarts) {
[17:02:51.392]                             name <- restart$name
[17:02:51.392]                             if (is.null(name)) 
[17:02:51.392]                               next
[17:02:51.392]                             if (!grepl(pattern, name)) 
[17:02:51.392]                               next
[17:02:51.392]                             invokeRestart(restart)
[17:02:51.392]                             muffled <- TRUE
[17:02:51.392]                             break
[17:02:51.392]                           }
[17:02:51.392]                         }
[17:02:51.392]                       }
[17:02:51.392]                       invisible(muffled)
[17:02:51.392]                     }
[17:02:51.392]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.392]                   }
[17:02:51.392]                 }
[17:02:51.392]                 else {
[17:02:51.392]                   if (TRUE) {
[17:02:51.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.392]                     {
[17:02:51.392]                       inherits <- base::inherits
[17:02:51.392]                       invokeRestart <- base::invokeRestart
[17:02:51.392]                       is.null <- base::is.null
[17:02:51.392]                       muffled <- FALSE
[17:02:51.392]                       if (inherits(cond, "message")) {
[17:02:51.392]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.392]                         if (muffled) 
[17:02:51.392]                           invokeRestart("muffleMessage")
[17:02:51.392]                       }
[17:02:51.392]                       else if (inherits(cond, "warning")) {
[17:02:51.392]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.392]                         if (muffled) 
[17:02:51.392]                           invokeRestart("muffleWarning")
[17:02:51.392]                       }
[17:02:51.392]                       else if (inherits(cond, "condition")) {
[17:02:51.392]                         if (!is.null(pattern)) {
[17:02:51.392]                           computeRestarts <- base::computeRestarts
[17:02:51.392]                           grepl <- base::grepl
[17:02:51.392]                           restarts <- computeRestarts(cond)
[17:02:51.392]                           for (restart in restarts) {
[17:02:51.392]                             name <- restart$name
[17:02:51.392]                             if (is.null(name)) 
[17:02:51.392]                               next
[17:02:51.392]                             if (!grepl(pattern, name)) 
[17:02:51.392]                               next
[17:02:51.392]                             invokeRestart(restart)
[17:02:51.392]                             muffled <- TRUE
[17:02:51.392]                             break
[17:02:51.392]                           }
[17:02:51.392]                         }
[17:02:51.392]                       }
[17:02:51.392]                       invisible(muffled)
[17:02:51.392]                     }
[17:02:51.392]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.392]                   }
[17:02:51.392]                 }
[17:02:51.392]             }
[17:02:51.392]         }))
[17:02:51.392]     }, error = function(ex) {
[17:02:51.392]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.392]                 ...future.rng), started = ...future.startTime, 
[17:02:51.392]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.392]             version = "1.8"), class = "FutureResult")
[17:02:51.392]     }, finally = {
[17:02:51.392]         if (!identical(...future.workdir, getwd())) 
[17:02:51.392]             setwd(...future.workdir)
[17:02:51.392]         {
[17:02:51.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.392]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.392]             }
[17:02:51.392]             base::options(...future.oldOptions)
[17:02:51.392]             if (.Platform$OS.type == "windows") {
[17:02:51.392]                 old_names <- names(...future.oldEnvVars)
[17:02:51.392]                 envs <- base::Sys.getenv()
[17:02:51.392]                 names <- names(envs)
[17:02:51.392]                 common <- intersect(names, old_names)
[17:02:51.392]                 added <- setdiff(names, old_names)
[17:02:51.392]                 removed <- setdiff(old_names, names)
[17:02:51.392]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.392]                   envs[common]]
[17:02:51.392]                 NAMES <- toupper(changed)
[17:02:51.392]                 args <- list()
[17:02:51.392]                 for (kk in seq_along(NAMES)) {
[17:02:51.392]                   name <- changed[[kk]]
[17:02:51.392]                   NAME <- NAMES[[kk]]
[17:02:51.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.392]                     next
[17:02:51.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.392]                 }
[17:02:51.392]                 NAMES <- toupper(added)
[17:02:51.392]                 for (kk in seq_along(NAMES)) {
[17:02:51.392]                   name <- added[[kk]]
[17:02:51.392]                   NAME <- NAMES[[kk]]
[17:02:51.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.392]                     next
[17:02:51.392]                   args[[name]] <- ""
[17:02:51.392]                 }
[17:02:51.392]                 NAMES <- toupper(removed)
[17:02:51.392]                 for (kk in seq_along(NAMES)) {
[17:02:51.392]                   name <- removed[[kk]]
[17:02:51.392]                   NAME <- NAMES[[kk]]
[17:02:51.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.392]                     next
[17:02:51.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.392]                 }
[17:02:51.392]                 if (length(args) > 0) 
[17:02:51.392]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.392]             }
[17:02:51.392]             else {
[17:02:51.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.392]             }
[17:02:51.392]             {
[17:02:51.392]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.392]                   0L) {
[17:02:51.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.392]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.392]                   base::options(opts)
[17:02:51.392]                 }
[17:02:51.392]                 {
[17:02:51.392]                   {
[17:02:51.392]                     NULL
[17:02:51.392]                     RNGkind("Mersenne-Twister")
[17:02:51.392]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.392]                       inherits = FALSE)
[17:02:51.392]                   }
[17:02:51.392]                   options(future.plan = NULL)
[17:02:51.392]                   if (is.na(NA_character_)) 
[17:02:51.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.392]                     .init = FALSE)
[17:02:51.392]                 }
[17:02:51.392]             }
[17:02:51.392]         }
[17:02:51.392]     })
[17:02:51.392]     if (TRUE) {
[17:02:51.392]         base::sink(type = "output", split = FALSE)
[17:02:51.392]         if (TRUE) {
[17:02:51.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.392]         }
[17:02:51.392]         else {
[17:02:51.392]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.392]         }
[17:02:51.392]         base::close(...future.stdout)
[17:02:51.392]         ...future.stdout <- NULL
[17:02:51.392]     }
[17:02:51.392]     ...future.result$conditions <- ...future.conditions
[17:02:51.392]     ...future.result$finished <- base::Sys.time()
[17:02:51.392]     ...future.result
[17:02:51.392] }
[17:02:51.394] plan(): Setting new future strategy stack:
[17:02:51.394] List of future strategies:
[17:02:51.394] 1. sequential:
[17:02:51.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.394]    - tweaked: FALSE
[17:02:51.394]    - call: NULL
[17:02:51.394] plan(): nbrOfWorkers() = 1
[17:02:51.395] plan(): Setting new future strategy stack:
[17:02:51.395] List of future strategies:
[17:02:51.395] 1. sequential:
[17:02:51.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.395]    - tweaked: FALSE
[17:02:51.395]    - call: plan(strategy)
[17:02:51.396] plan(): nbrOfWorkers() = 1
[17:02:51.396] SequentialFuture started (and completed)
[17:02:51.396] - Launch lazy future ... done
[17:02:51.396] run() for ‘SequentialFuture’ ... done
[17:02:51.396] resolved() for ‘SequentialFuture’ ...
[17:02:51.396] - state: ‘finished’
[17:02:51.396] - run: TRUE
[17:02:51.396] - result: ‘FutureResult’
[17:02:51.397] resolved() for ‘SequentialFuture’ ... done
[17:02:51.397] Future #1
[17:02:51.397] resolved() for ‘SequentialFuture’ ...
[17:02:51.397] - state: ‘finished’
[17:02:51.398] - run: TRUE
[17:02:51.399] - result: ‘FutureResult’
[17:02:51.399] resolved() for ‘SequentialFuture’ ... done
[17:02:51.399] A SequentialFuture was resolved
[17:02:51.399]  length: 0 (resolved future 1)
[17:02:51.399] resolve() on list ... DONE
[17:02:51.399] - globals: [1] ‘a’
[17:02:51.399] Resolving futures part of globals (recursively) ... DONE
[17:02:51.401] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[17:02:51.402] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:02:51.402] - globals: [1] ‘a’
[17:02:51.402] - packages: [1] ‘future’
[17:02:51.402] getGlobalsAndPackages() ... DONE
[17:02:51.402] run() for ‘Future’ ...
[17:02:51.403] - state: ‘created’
[17:02:51.403] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.403] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.403]   - Field: ‘label’
[17:02:51.403]   - Field: ‘local’
[17:02:51.403]   - Field: ‘owner’
[17:02:51.403]   - Field: ‘envir’
[17:02:51.404]   - Field: ‘packages’
[17:02:51.404]   - Field: ‘gc’
[17:02:51.404]   - Field: ‘conditions’
[17:02:51.404]   - Field: ‘expr’
[17:02:51.404]   - Field: ‘uuid’
[17:02:51.404]   - Field: ‘seed’
[17:02:51.404]   - Field: ‘version’
[17:02:51.404]   - Field: ‘result’
[17:02:51.404]   - Field: ‘asynchronous’
[17:02:51.404]   - Field: ‘calls’
[17:02:51.404]   - Field: ‘globals’
[17:02:51.405]   - Field: ‘stdout’
[17:02:51.405]   - Field: ‘earlySignal’
[17:02:51.405]   - Field: ‘lazy’
[17:02:51.405]   - Field: ‘state’
[17:02:51.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.405] - Launch lazy future ...
[17:02:51.405] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.405] Packages needed by future strategies (n = 0): <none>
[17:02:51.406] {
[17:02:51.406]     {
[17:02:51.406]         {
[17:02:51.406]             ...future.startTime <- base::Sys.time()
[17:02:51.406]             {
[17:02:51.406]                 {
[17:02:51.406]                   {
[17:02:51.406]                     {
[17:02:51.406]                       base::local({
[17:02:51.406]                         has_future <- base::requireNamespace("future", 
[17:02:51.406]                           quietly = TRUE)
[17:02:51.406]                         if (has_future) {
[17:02:51.406]                           ns <- base::getNamespace("future")
[17:02:51.406]                           version <- ns[[".package"]][["version"]]
[17:02:51.406]                           if (is.null(version)) 
[17:02:51.406]                             version <- utils::packageVersion("future")
[17:02:51.406]                         }
[17:02:51.406]                         else {
[17:02:51.406]                           version <- NULL
[17:02:51.406]                         }
[17:02:51.406]                         if (!has_future || version < "1.8.0") {
[17:02:51.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.406]                             "", base::R.version$version.string), 
[17:02:51.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.406]                               "release", "version")], collapse = " "), 
[17:02:51.406]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.406]                             info)
[17:02:51.406]                           info <- base::paste(info, collapse = "; ")
[17:02:51.406]                           if (!has_future) {
[17:02:51.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.406]                               info)
[17:02:51.406]                           }
[17:02:51.406]                           else {
[17:02:51.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.406]                               info, version)
[17:02:51.406]                           }
[17:02:51.406]                           base::stop(msg)
[17:02:51.406]                         }
[17:02:51.406]                       })
[17:02:51.406]                     }
[17:02:51.406]                     base::local({
[17:02:51.406]                       for (pkg in "future") {
[17:02:51.406]                         base::loadNamespace(pkg)
[17:02:51.406]                         base::library(pkg, character.only = TRUE)
[17:02:51.406]                       }
[17:02:51.406]                     })
[17:02:51.406]                   }
[17:02:51.406]                   ...future.strategy.old <- future::plan("list")
[17:02:51.406]                   options(future.plan = NULL)
[17:02:51.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.406]                 }
[17:02:51.406]                 ...future.workdir <- getwd()
[17:02:51.406]             }
[17:02:51.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.406]         }
[17:02:51.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.406]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.406]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.406]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.406]             base::names(...future.oldOptions))
[17:02:51.406]     }
[17:02:51.406]     if (FALSE) {
[17:02:51.406]     }
[17:02:51.406]     else {
[17:02:51.406]         if (TRUE) {
[17:02:51.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.406]                 open = "w")
[17:02:51.406]         }
[17:02:51.406]         else {
[17:02:51.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.406]         }
[17:02:51.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.406]             base::sink(type = "output", split = FALSE)
[17:02:51.406]             base::close(...future.stdout)
[17:02:51.406]         }, add = TRUE)
[17:02:51.406]     }
[17:02:51.406]     ...future.frame <- base::sys.nframe()
[17:02:51.406]     ...future.conditions <- base::list()
[17:02:51.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.406]     if (FALSE) {
[17:02:51.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.406]     }
[17:02:51.406]     ...future.result <- base::tryCatch({
[17:02:51.406]         base::withCallingHandlers({
[17:02:51.406]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:02:51.406]                 1))
[17:02:51.406]             future::FutureResult(value = ...future.value$value, 
[17:02:51.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.406]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.406]                     ...future.globalenv.names))
[17:02:51.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.406]         }, condition = base::local({
[17:02:51.406]             c <- base::c
[17:02:51.406]             inherits <- base::inherits
[17:02:51.406]             invokeRestart <- base::invokeRestart
[17:02:51.406]             length <- base::length
[17:02:51.406]             list <- base::list
[17:02:51.406]             seq.int <- base::seq.int
[17:02:51.406]             signalCondition <- base::signalCondition
[17:02:51.406]             sys.calls <- base::sys.calls
[17:02:51.406]             `[[` <- base::`[[`
[17:02:51.406]             `+` <- base::`+`
[17:02:51.406]             `<<-` <- base::`<<-`
[17:02:51.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.406]                   3L)]
[17:02:51.406]             }
[17:02:51.406]             function(cond) {
[17:02:51.406]                 is_error <- inherits(cond, "error")
[17:02:51.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.406]                   NULL)
[17:02:51.406]                 if (is_error) {
[17:02:51.406]                   sessionInformation <- function() {
[17:02:51.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.406]                       search = base::search(), system = base::Sys.info())
[17:02:51.406]                   }
[17:02:51.406]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.406]                     cond$call), session = sessionInformation(), 
[17:02:51.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.406]                   signalCondition(cond)
[17:02:51.406]                 }
[17:02:51.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.406]                 "immediateCondition"))) {
[17:02:51.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.406]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.406]                   if (TRUE && !signal) {
[17:02:51.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.406]                     {
[17:02:51.406]                       inherits <- base::inherits
[17:02:51.406]                       invokeRestart <- base::invokeRestart
[17:02:51.406]                       is.null <- base::is.null
[17:02:51.406]                       muffled <- FALSE
[17:02:51.406]                       if (inherits(cond, "message")) {
[17:02:51.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.406]                         if (muffled) 
[17:02:51.406]                           invokeRestart("muffleMessage")
[17:02:51.406]                       }
[17:02:51.406]                       else if (inherits(cond, "warning")) {
[17:02:51.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.406]                         if (muffled) 
[17:02:51.406]                           invokeRestart("muffleWarning")
[17:02:51.406]                       }
[17:02:51.406]                       else if (inherits(cond, "condition")) {
[17:02:51.406]                         if (!is.null(pattern)) {
[17:02:51.406]                           computeRestarts <- base::computeRestarts
[17:02:51.406]                           grepl <- base::grepl
[17:02:51.406]                           restarts <- computeRestarts(cond)
[17:02:51.406]                           for (restart in restarts) {
[17:02:51.406]                             name <- restart$name
[17:02:51.406]                             if (is.null(name)) 
[17:02:51.406]                               next
[17:02:51.406]                             if (!grepl(pattern, name)) 
[17:02:51.406]                               next
[17:02:51.406]                             invokeRestart(restart)
[17:02:51.406]                             muffled <- TRUE
[17:02:51.406]                             break
[17:02:51.406]                           }
[17:02:51.406]                         }
[17:02:51.406]                       }
[17:02:51.406]                       invisible(muffled)
[17:02:51.406]                     }
[17:02:51.406]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.406]                   }
[17:02:51.406]                 }
[17:02:51.406]                 else {
[17:02:51.406]                   if (TRUE) {
[17:02:51.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.406]                     {
[17:02:51.406]                       inherits <- base::inherits
[17:02:51.406]                       invokeRestart <- base::invokeRestart
[17:02:51.406]                       is.null <- base::is.null
[17:02:51.406]                       muffled <- FALSE
[17:02:51.406]                       if (inherits(cond, "message")) {
[17:02:51.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.406]                         if (muffled) 
[17:02:51.406]                           invokeRestart("muffleMessage")
[17:02:51.406]                       }
[17:02:51.406]                       else if (inherits(cond, "warning")) {
[17:02:51.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.406]                         if (muffled) 
[17:02:51.406]                           invokeRestart("muffleWarning")
[17:02:51.406]                       }
[17:02:51.406]                       else if (inherits(cond, "condition")) {
[17:02:51.406]                         if (!is.null(pattern)) {
[17:02:51.406]                           computeRestarts <- base::computeRestarts
[17:02:51.406]                           grepl <- base::grepl
[17:02:51.406]                           restarts <- computeRestarts(cond)
[17:02:51.406]                           for (restart in restarts) {
[17:02:51.406]                             name <- restart$name
[17:02:51.406]                             if (is.null(name)) 
[17:02:51.406]                               next
[17:02:51.406]                             if (!grepl(pattern, name)) 
[17:02:51.406]                               next
[17:02:51.406]                             invokeRestart(restart)
[17:02:51.406]                             muffled <- TRUE
[17:02:51.406]                             break
[17:02:51.406]                           }
[17:02:51.406]                         }
[17:02:51.406]                       }
[17:02:51.406]                       invisible(muffled)
[17:02:51.406]                     }
[17:02:51.406]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.406]                   }
[17:02:51.406]                 }
[17:02:51.406]             }
[17:02:51.406]         }))
[17:02:51.406]     }, error = function(ex) {
[17:02:51.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.406]                 ...future.rng), started = ...future.startTime, 
[17:02:51.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.406]             version = "1.8"), class = "FutureResult")
[17:02:51.406]     }, finally = {
[17:02:51.406]         if (!identical(...future.workdir, getwd())) 
[17:02:51.406]             setwd(...future.workdir)
[17:02:51.406]         {
[17:02:51.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.406]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.406]             }
[17:02:51.406]             base::options(...future.oldOptions)
[17:02:51.406]             if (.Platform$OS.type == "windows") {
[17:02:51.406]                 old_names <- names(...future.oldEnvVars)
[17:02:51.406]                 envs <- base::Sys.getenv()
[17:02:51.406]                 names <- names(envs)
[17:02:51.406]                 common <- intersect(names, old_names)
[17:02:51.406]                 added <- setdiff(names, old_names)
[17:02:51.406]                 removed <- setdiff(old_names, names)
[17:02:51.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.406]                   envs[common]]
[17:02:51.406]                 NAMES <- toupper(changed)
[17:02:51.406]                 args <- list()
[17:02:51.406]                 for (kk in seq_along(NAMES)) {
[17:02:51.406]                   name <- changed[[kk]]
[17:02:51.406]                   NAME <- NAMES[[kk]]
[17:02:51.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.406]                     next
[17:02:51.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.406]                 }
[17:02:51.406]                 NAMES <- toupper(added)
[17:02:51.406]                 for (kk in seq_along(NAMES)) {
[17:02:51.406]                   name <- added[[kk]]
[17:02:51.406]                   NAME <- NAMES[[kk]]
[17:02:51.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.406]                     next
[17:02:51.406]                   args[[name]] <- ""
[17:02:51.406]                 }
[17:02:51.406]                 NAMES <- toupper(removed)
[17:02:51.406]                 for (kk in seq_along(NAMES)) {
[17:02:51.406]                   name <- removed[[kk]]
[17:02:51.406]                   NAME <- NAMES[[kk]]
[17:02:51.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.406]                     next
[17:02:51.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.406]                 }
[17:02:51.406]                 if (length(args) > 0) 
[17:02:51.406]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.406]             }
[17:02:51.406]             else {
[17:02:51.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.406]             }
[17:02:51.406]             {
[17:02:51.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.406]                   0L) {
[17:02:51.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.406]                   base::options(opts)
[17:02:51.406]                 }
[17:02:51.406]                 {
[17:02:51.406]                   {
[17:02:51.406]                     NULL
[17:02:51.406]                     RNGkind("Mersenne-Twister")
[17:02:51.406]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.406]                       inherits = FALSE)
[17:02:51.406]                   }
[17:02:51.406]                   options(future.plan = NULL)
[17:02:51.406]                   if (is.na(NA_character_)) 
[17:02:51.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.406]                     .init = FALSE)
[17:02:51.406]                 }
[17:02:51.406]             }
[17:02:51.406]         }
[17:02:51.406]     })
[17:02:51.406]     if (TRUE) {
[17:02:51.406]         base::sink(type = "output", split = FALSE)
[17:02:51.406]         if (TRUE) {
[17:02:51.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.406]         }
[17:02:51.406]         else {
[17:02:51.406]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.406]         }
[17:02:51.406]         base::close(...future.stdout)
[17:02:51.406]         ...future.stdout <- NULL
[17:02:51.406]     }
[17:02:51.406]     ...future.result$conditions <- ...future.conditions
[17:02:51.406]     ...future.result$finished <- base::Sys.time()
[17:02:51.406]     ...future.result
[17:02:51.406] }
[17:02:51.407] assign_globals() ...
[17:02:51.407] List of 1
[17:02:51.407]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c8f66d1418> 
[17:02:51.407]  - attr(*, "where")=List of 1
[17:02:51.407]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.407]  - attr(*, "resolved")= logi TRUE
[17:02:51.407]  - attr(*, "total_size")= num 1622440
[17:02:51.407]  - attr(*, "already-done")= logi TRUE
[17:02:51.410] - copied ‘a’ to environment
[17:02:51.410] assign_globals() ... done
[17:02:51.410] plan(): Setting new future strategy stack:
[17:02:51.411] List of future strategies:
[17:02:51.411] 1. sequential:
[17:02:51.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.411]    - tweaked: FALSE
[17:02:51.411]    - call: NULL
[17:02:51.411] plan(): nbrOfWorkers() = 1
[17:02:51.412] plan(): Setting new future strategy stack:
[17:02:51.412] List of future strategies:
[17:02:51.412] 1. sequential:
[17:02:51.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.412]    - tweaked: FALSE
[17:02:51.412]    - call: plan(strategy)
[17:02:51.412] plan(): nbrOfWorkers() = 1
[17:02:51.412] SequentialFuture started (and completed)
[17:02:51.413] - Launch lazy future ... done
[17:02:51.413] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.413] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.413] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.414] - globals found: [2] ‘{’, ‘pkg’
[17:02:51.414] Searching for globals ... DONE
[17:02:51.414] Resolving globals: TRUE
[17:02:51.414] Resolving any globals that are futures ...
[17:02:51.415] - globals: [2] ‘{’, ‘pkg’
[17:02:51.415] Resolving any globals that are futures ... DONE
[17:02:51.415] Resolving futures part of globals (recursively) ...
[17:02:51.415] resolve() on list ...
[17:02:51.415]  recursive: 99
[17:02:51.415]  length: 1
[17:02:51.415]  elements: ‘pkg’
[17:02:51.416]  length: 0 (resolved future 1)
[17:02:51.416] resolve() on list ... DONE
[17:02:51.416] - globals: [1] ‘pkg’
[17:02:51.416] Resolving futures part of globals (recursively) ... DONE
[17:02:51.416] The total size of the 1 globals is 112 bytes (112 bytes)
[17:02:51.416] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:02:51.416] - globals: [1] ‘pkg’
[17:02:51.416] 
[17:02:51.417] getGlobalsAndPackages() ... DONE
[17:02:51.417] Packages needed by the future expression (n = 0): <none>
[17:02:51.417] Packages needed by future strategies (n = 0): <none>
[17:02:51.417] {
[17:02:51.417]     {
[17:02:51.417]         {
[17:02:51.417]             ...future.startTime <- base::Sys.time()
[17:02:51.417]             {
[17:02:51.417]                 {
[17:02:51.417]                   {
[17:02:51.417]                     base::local({
[17:02:51.417]                       has_future <- base::requireNamespace("future", 
[17:02:51.417]                         quietly = TRUE)
[17:02:51.417]                       if (has_future) {
[17:02:51.417]                         ns <- base::getNamespace("future")
[17:02:51.417]                         version <- ns[[".package"]][["version"]]
[17:02:51.417]                         if (is.null(version)) 
[17:02:51.417]                           version <- utils::packageVersion("future")
[17:02:51.417]                       }
[17:02:51.417]                       else {
[17:02:51.417]                         version <- NULL
[17:02:51.417]                       }
[17:02:51.417]                       if (!has_future || version < "1.8.0") {
[17:02:51.417]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.417]                           "", base::R.version$version.string), 
[17:02:51.417]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.417]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.417]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.417]                             "release", "version")], collapse = " "), 
[17:02:51.417]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.417]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.417]                           info)
[17:02:51.417]                         info <- base::paste(info, collapse = "; ")
[17:02:51.417]                         if (!has_future) {
[17:02:51.417]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.417]                             info)
[17:02:51.417]                         }
[17:02:51.417]                         else {
[17:02:51.417]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.417]                             info, version)
[17:02:51.417]                         }
[17:02:51.417]                         base::stop(msg)
[17:02:51.417]                       }
[17:02:51.417]                     })
[17:02:51.417]                   }
[17:02:51.417]                   ...future.strategy.old <- future::plan("list")
[17:02:51.417]                   options(future.plan = NULL)
[17:02:51.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.417]                 }
[17:02:51.417]                 ...future.workdir <- getwd()
[17:02:51.417]             }
[17:02:51.417]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.417]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.417]         }
[17:02:51.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.417]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.417]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.417]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.417]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.417]             base::names(...future.oldOptions))
[17:02:51.417]     }
[17:02:51.417]     if (FALSE) {
[17:02:51.417]     }
[17:02:51.417]     else {
[17:02:51.417]         if (TRUE) {
[17:02:51.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.417]                 open = "w")
[17:02:51.417]         }
[17:02:51.417]         else {
[17:02:51.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.417]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.417]         }
[17:02:51.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.417]             base::sink(type = "output", split = FALSE)
[17:02:51.417]             base::close(...future.stdout)
[17:02:51.417]         }, add = TRUE)
[17:02:51.417]     }
[17:02:51.417]     ...future.frame <- base::sys.nframe()
[17:02:51.417]     ...future.conditions <- base::list()
[17:02:51.417]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.417]     if (FALSE) {
[17:02:51.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.417]     }
[17:02:51.417]     ...future.result <- base::tryCatch({
[17:02:51.417]         base::withCallingHandlers({
[17:02:51.417]             ...future.value <- base::withVisible(base::local({
[17:02:51.417]                 pkg
[17:02:51.417]             }))
[17:02:51.417]             future::FutureResult(value = ...future.value$value, 
[17:02:51.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.417]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.417]                     ...future.globalenv.names))
[17:02:51.417]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.417]         }, condition = base::local({
[17:02:51.417]             c <- base::c
[17:02:51.417]             inherits <- base::inherits
[17:02:51.417]             invokeRestart <- base::invokeRestart
[17:02:51.417]             length <- base::length
[17:02:51.417]             list <- base::list
[17:02:51.417]             seq.int <- base::seq.int
[17:02:51.417]             signalCondition <- base::signalCondition
[17:02:51.417]             sys.calls <- base::sys.calls
[17:02:51.417]             `[[` <- base::`[[`
[17:02:51.417]             `+` <- base::`+`
[17:02:51.417]             `<<-` <- base::`<<-`
[17:02:51.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.417]                   3L)]
[17:02:51.417]             }
[17:02:51.417]             function(cond) {
[17:02:51.417]                 is_error <- inherits(cond, "error")
[17:02:51.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.417]                   NULL)
[17:02:51.417]                 if (is_error) {
[17:02:51.417]                   sessionInformation <- function() {
[17:02:51.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.417]                       search = base::search(), system = base::Sys.info())
[17:02:51.417]                   }
[17:02:51.417]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.417]                     cond$call), session = sessionInformation(), 
[17:02:51.417]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.417]                   signalCondition(cond)
[17:02:51.417]                 }
[17:02:51.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.417]                 "immediateCondition"))) {
[17:02:51.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.417]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.417]                   if (TRUE && !signal) {
[17:02:51.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.417]                     {
[17:02:51.417]                       inherits <- base::inherits
[17:02:51.417]                       invokeRestart <- base::invokeRestart
[17:02:51.417]                       is.null <- base::is.null
[17:02:51.417]                       muffled <- FALSE
[17:02:51.417]                       if (inherits(cond, "message")) {
[17:02:51.417]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.417]                         if (muffled) 
[17:02:51.417]                           invokeRestart("muffleMessage")
[17:02:51.417]                       }
[17:02:51.417]                       else if (inherits(cond, "warning")) {
[17:02:51.417]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.417]                         if (muffled) 
[17:02:51.417]                           invokeRestart("muffleWarning")
[17:02:51.417]                       }
[17:02:51.417]                       else if (inherits(cond, "condition")) {
[17:02:51.417]                         if (!is.null(pattern)) {
[17:02:51.417]                           computeRestarts <- base::computeRestarts
[17:02:51.417]                           grepl <- base::grepl
[17:02:51.417]                           restarts <- computeRestarts(cond)
[17:02:51.417]                           for (restart in restarts) {
[17:02:51.417]                             name <- restart$name
[17:02:51.417]                             if (is.null(name)) 
[17:02:51.417]                               next
[17:02:51.417]                             if (!grepl(pattern, name)) 
[17:02:51.417]                               next
[17:02:51.417]                             invokeRestart(restart)
[17:02:51.417]                             muffled <- TRUE
[17:02:51.417]                             break
[17:02:51.417]                           }
[17:02:51.417]                         }
[17:02:51.417]                       }
[17:02:51.417]                       invisible(muffled)
[17:02:51.417]                     }
[17:02:51.417]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.417]                   }
[17:02:51.417]                 }
[17:02:51.417]                 else {
[17:02:51.417]                   if (TRUE) {
[17:02:51.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.417]                     {
[17:02:51.417]                       inherits <- base::inherits
[17:02:51.417]                       invokeRestart <- base::invokeRestart
[17:02:51.417]                       is.null <- base::is.null
[17:02:51.417]                       muffled <- FALSE
[17:02:51.417]                       if (inherits(cond, "message")) {
[17:02:51.417]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.417]                         if (muffled) 
[17:02:51.417]                           invokeRestart("muffleMessage")
[17:02:51.417]                       }
[17:02:51.417]                       else if (inherits(cond, "warning")) {
[17:02:51.417]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.417]                         if (muffled) 
[17:02:51.417]                           invokeRestart("muffleWarning")
[17:02:51.417]                       }
[17:02:51.417]                       else if (inherits(cond, "condition")) {
[17:02:51.417]                         if (!is.null(pattern)) {
[17:02:51.417]                           computeRestarts <- base::computeRestarts
[17:02:51.417]                           grepl <- base::grepl
[17:02:51.417]                           restarts <- computeRestarts(cond)
[17:02:51.417]                           for (restart in restarts) {
[17:02:51.417]                             name <- restart$name
[17:02:51.417]                             if (is.null(name)) 
[17:02:51.417]                               next
[17:02:51.417]                             if (!grepl(pattern, name)) 
[17:02:51.417]                               next
[17:02:51.417]                             invokeRestart(restart)
[17:02:51.417]                             muffled <- TRUE
[17:02:51.417]                             break
[17:02:51.417]                           }
[17:02:51.417]                         }
[17:02:51.417]                       }
[17:02:51.417]                       invisible(muffled)
[17:02:51.417]                     }
[17:02:51.417]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.417]                   }
[17:02:51.417]                 }
[17:02:51.417]             }
[17:02:51.417]         }))
[17:02:51.417]     }, error = function(ex) {
[17:02:51.417]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.417]                 ...future.rng), started = ...future.startTime, 
[17:02:51.417]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.417]             version = "1.8"), class = "FutureResult")
[17:02:51.417]     }, finally = {
[17:02:51.417]         if (!identical(...future.workdir, getwd())) 
[17:02:51.417]             setwd(...future.workdir)
[17:02:51.417]         {
[17:02:51.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.417]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.417]             }
[17:02:51.417]             base::options(...future.oldOptions)
[17:02:51.417]             if (.Platform$OS.type == "windows") {
[17:02:51.417]                 old_names <- names(...future.oldEnvVars)
[17:02:51.417]                 envs <- base::Sys.getenv()
[17:02:51.417]                 names <- names(envs)
[17:02:51.417]                 common <- intersect(names, old_names)
[17:02:51.417]                 added <- setdiff(names, old_names)
[17:02:51.417]                 removed <- setdiff(old_names, names)
[17:02:51.417]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.417]                   envs[common]]
[17:02:51.417]                 NAMES <- toupper(changed)
[17:02:51.417]                 args <- list()
[17:02:51.417]                 for (kk in seq_along(NAMES)) {
[17:02:51.417]                   name <- changed[[kk]]
[17:02:51.417]                   NAME <- NAMES[[kk]]
[17:02:51.417]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.417]                     next
[17:02:51.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.417]                 }
[17:02:51.417]                 NAMES <- toupper(added)
[17:02:51.417]                 for (kk in seq_along(NAMES)) {
[17:02:51.417]                   name <- added[[kk]]
[17:02:51.417]                   NAME <- NAMES[[kk]]
[17:02:51.417]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.417]                     next
[17:02:51.417]                   args[[name]] <- ""
[17:02:51.417]                 }
[17:02:51.417]                 NAMES <- toupper(removed)
[17:02:51.417]                 for (kk in seq_along(NAMES)) {
[17:02:51.417]                   name <- removed[[kk]]
[17:02:51.417]                   NAME <- NAMES[[kk]]
[17:02:51.417]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.417]                     next
[17:02:51.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.417]                 }
[17:02:51.417]                 if (length(args) > 0) 
[17:02:51.417]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.417]             }
[17:02:51.417]             else {
[17:02:51.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.417]             }
[17:02:51.417]             {
[17:02:51.417]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.417]                   0L) {
[17:02:51.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.417]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.417]                   base::options(opts)
[17:02:51.417]                 }
[17:02:51.417]                 {
[17:02:51.417]                   {
[17:02:51.417]                     NULL
[17:02:51.417]                     RNGkind("Mersenne-Twister")
[17:02:51.417]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.417]                       inherits = FALSE)
[17:02:51.417]                   }
[17:02:51.417]                   options(future.plan = NULL)
[17:02:51.417]                   if (is.na(NA_character_)) 
[17:02:51.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.417]                     .init = FALSE)
[17:02:51.417]                 }
[17:02:51.417]             }
[17:02:51.417]         }
[17:02:51.417]     })
[17:02:51.417]     if (TRUE) {
[17:02:51.417]         base::sink(type = "output", split = FALSE)
[17:02:51.417]         if (TRUE) {
[17:02:51.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.417]         }
[17:02:51.417]         else {
[17:02:51.417]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.417]         }
[17:02:51.417]         base::close(...future.stdout)
[17:02:51.417]         ...future.stdout <- NULL
[17:02:51.417]     }
[17:02:51.417]     ...future.result$conditions <- ...future.conditions
[17:02:51.417]     ...future.result$finished <- base::Sys.time()
[17:02:51.417]     ...future.result
[17:02:51.417] }
[17:02:51.419] assign_globals() ...
[17:02:51.419] List of 1
[17:02:51.419]  $ pkg: chr "foo"
[17:02:51.419]  - attr(*, "where")=List of 1
[17:02:51.419]   ..$ pkg:<environment: R_EmptyEnv> 
[17:02:51.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.419]  - attr(*, "resolved")= logi TRUE
[17:02:51.419]  - attr(*, "total_size")= num 112
[17:02:51.421] - copied ‘pkg’ to environment
[17:02:51.421] assign_globals() ... done
[17:02:51.421] plan(): Setting new future strategy stack:
[17:02:51.421] List of future strategies:
[17:02:51.421] 1. sequential:
[17:02:51.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.421]    - tweaked: FALSE
[17:02:51.421]    - call: NULL
[17:02:51.422] plan(): nbrOfWorkers() = 1
[17:02:51.423] plan(): Setting new future strategy stack:
[17:02:51.423] List of future strategies:
[17:02:51.423] 1. sequential:
[17:02:51.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.423]    - tweaked: FALSE
[17:02:51.423]    - call: plan(strategy)
[17:02:51.423] plan(): nbrOfWorkers() = 1
[17:02:51.423] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.424] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.424] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.426] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:02:51.426] Searching for globals ... DONE
[17:02:51.426] Resolving globals: TRUE
[17:02:51.426] Resolving any globals that are futures ...
[17:02:51.426] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:02:51.426] Resolving any globals that are futures ... DONE
[17:02:51.427] 
[17:02:51.427] 
[17:02:51.427] getGlobalsAndPackages() ... DONE
[17:02:51.427] run() for ‘Future’ ...
[17:02:51.427] - state: ‘created’
[17:02:51.427] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.429] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.429]   - Field: ‘label’
[17:02:51.429]   - Field: ‘local’
[17:02:51.429]   - Field: ‘owner’
[17:02:51.430]   - Field: ‘envir’
[17:02:51.430]   - Field: ‘packages’
[17:02:51.430]   - Field: ‘gc’
[17:02:51.430]   - Field: ‘conditions’
[17:02:51.430]   - Field: ‘expr’
[17:02:51.430]   - Field: ‘uuid’
[17:02:51.430]   - Field: ‘seed’
[17:02:51.430]   - Field: ‘version’
[17:02:51.430]   - Field: ‘result’
[17:02:51.431]   - Field: ‘asynchronous’
[17:02:51.431]   - Field: ‘calls’
[17:02:51.431]   - Field: ‘globals’
[17:02:51.431]   - Field: ‘stdout’
[17:02:51.431]   - Field: ‘earlySignal’
[17:02:51.431]   - Field: ‘lazy’
[17:02:51.431]   - Field: ‘state’
[17:02:51.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.431] - Launch lazy future ...
[17:02:51.432] Packages needed by the future expression (n = 0): <none>
[17:02:51.432] Packages needed by future strategies (n = 0): <none>
[17:02:51.432] {
[17:02:51.432]     {
[17:02:51.432]         {
[17:02:51.432]             ...future.startTime <- base::Sys.time()
[17:02:51.432]             {
[17:02:51.432]                 {
[17:02:51.432]                   {
[17:02:51.432]                     base::local({
[17:02:51.432]                       has_future <- base::requireNamespace("future", 
[17:02:51.432]                         quietly = TRUE)
[17:02:51.432]                       if (has_future) {
[17:02:51.432]                         ns <- base::getNamespace("future")
[17:02:51.432]                         version <- ns[[".package"]][["version"]]
[17:02:51.432]                         if (is.null(version)) 
[17:02:51.432]                           version <- utils::packageVersion("future")
[17:02:51.432]                       }
[17:02:51.432]                       else {
[17:02:51.432]                         version <- NULL
[17:02:51.432]                       }
[17:02:51.432]                       if (!has_future || version < "1.8.0") {
[17:02:51.432]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.432]                           "", base::R.version$version.string), 
[17:02:51.432]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.432]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.432]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.432]                             "release", "version")], collapse = " "), 
[17:02:51.432]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.432]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.432]                           info)
[17:02:51.432]                         info <- base::paste(info, collapse = "; ")
[17:02:51.432]                         if (!has_future) {
[17:02:51.432]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.432]                             info)
[17:02:51.432]                         }
[17:02:51.432]                         else {
[17:02:51.432]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.432]                             info, version)
[17:02:51.432]                         }
[17:02:51.432]                         base::stop(msg)
[17:02:51.432]                       }
[17:02:51.432]                     })
[17:02:51.432]                   }
[17:02:51.432]                   ...future.strategy.old <- future::plan("list")
[17:02:51.432]                   options(future.plan = NULL)
[17:02:51.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.432]                 }
[17:02:51.432]                 ...future.workdir <- getwd()
[17:02:51.432]             }
[17:02:51.432]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.432]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.432]         }
[17:02:51.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.432]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.432]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.432]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.432]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.432]             base::names(...future.oldOptions))
[17:02:51.432]     }
[17:02:51.432]     if (FALSE) {
[17:02:51.432]     }
[17:02:51.432]     else {
[17:02:51.432]         if (TRUE) {
[17:02:51.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.432]                 open = "w")
[17:02:51.432]         }
[17:02:51.432]         else {
[17:02:51.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.432]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.432]         }
[17:02:51.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.432]             base::sink(type = "output", split = FALSE)
[17:02:51.432]             base::close(...future.stdout)
[17:02:51.432]         }, add = TRUE)
[17:02:51.432]     }
[17:02:51.432]     ...future.frame <- base::sys.nframe()
[17:02:51.432]     ...future.conditions <- base::list()
[17:02:51.432]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.432]     if (FALSE) {
[17:02:51.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.432]     }
[17:02:51.432]     ...future.result <- base::tryCatch({
[17:02:51.432]         base::withCallingHandlers({
[17:02:51.432]             ...future.value <- base::withVisible(base::local({
[17:02:51.432]                 x <- 0
[17:02:51.432]                 x <- x + 1
[17:02:51.432]                 x
[17:02:51.432]             }))
[17:02:51.432]             future::FutureResult(value = ...future.value$value, 
[17:02:51.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.432]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.432]                     ...future.globalenv.names))
[17:02:51.432]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.432]         }, condition = base::local({
[17:02:51.432]             c <- base::c
[17:02:51.432]             inherits <- base::inherits
[17:02:51.432]             invokeRestart <- base::invokeRestart
[17:02:51.432]             length <- base::length
[17:02:51.432]             list <- base::list
[17:02:51.432]             seq.int <- base::seq.int
[17:02:51.432]             signalCondition <- base::signalCondition
[17:02:51.432]             sys.calls <- base::sys.calls
[17:02:51.432]             `[[` <- base::`[[`
[17:02:51.432]             `+` <- base::`+`
[17:02:51.432]             `<<-` <- base::`<<-`
[17:02:51.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.432]                   3L)]
[17:02:51.432]             }
[17:02:51.432]             function(cond) {
[17:02:51.432]                 is_error <- inherits(cond, "error")
[17:02:51.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.432]                   NULL)
[17:02:51.432]                 if (is_error) {
[17:02:51.432]                   sessionInformation <- function() {
[17:02:51.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.432]                       search = base::search(), system = base::Sys.info())
[17:02:51.432]                   }
[17:02:51.432]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.432]                     cond$call), session = sessionInformation(), 
[17:02:51.432]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.432]                   signalCondition(cond)
[17:02:51.432]                 }
[17:02:51.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.432]                 "immediateCondition"))) {
[17:02:51.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.432]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.432]                   if (TRUE && !signal) {
[17:02:51.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.432]                     {
[17:02:51.432]                       inherits <- base::inherits
[17:02:51.432]                       invokeRestart <- base::invokeRestart
[17:02:51.432]                       is.null <- base::is.null
[17:02:51.432]                       muffled <- FALSE
[17:02:51.432]                       if (inherits(cond, "message")) {
[17:02:51.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.432]                         if (muffled) 
[17:02:51.432]                           invokeRestart("muffleMessage")
[17:02:51.432]                       }
[17:02:51.432]                       else if (inherits(cond, "warning")) {
[17:02:51.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.432]                         if (muffled) 
[17:02:51.432]                           invokeRestart("muffleWarning")
[17:02:51.432]                       }
[17:02:51.432]                       else if (inherits(cond, "condition")) {
[17:02:51.432]                         if (!is.null(pattern)) {
[17:02:51.432]                           computeRestarts <- base::computeRestarts
[17:02:51.432]                           grepl <- base::grepl
[17:02:51.432]                           restarts <- computeRestarts(cond)
[17:02:51.432]                           for (restart in restarts) {
[17:02:51.432]                             name <- restart$name
[17:02:51.432]                             if (is.null(name)) 
[17:02:51.432]                               next
[17:02:51.432]                             if (!grepl(pattern, name)) 
[17:02:51.432]                               next
[17:02:51.432]                             invokeRestart(restart)
[17:02:51.432]                             muffled <- TRUE
[17:02:51.432]                             break
[17:02:51.432]                           }
[17:02:51.432]                         }
[17:02:51.432]                       }
[17:02:51.432]                       invisible(muffled)
[17:02:51.432]                     }
[17:02:51.432]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.432]                   }
[17:02:51.432]                 }
[17:02:51.432]                 else {
[17:02:51.432]                   if (TRUE) {
[17:02:51.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.432]                     {
[17:02:51.432]                       inherits <- base::inherits
[17:02:51.432]                       invokeRestart <- base::invokeRestart
[17:02:51.432]                       is.null <- base::is.null
[17:02:51.432]                       muffled <- FALSE
[17:02:51.432]                       if (inherits(cond, "message")) {
[17:02:51.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.432]                         if (muffled) 
[17:02:51.432]                           invokeRestart("muffleMessage")
[17:02:51.432]                       }
[17:02:51.432]                       else if (inherits(cond, "warning")) {
[17:02:51.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.432]                         if (muffled) 
[17:02:51.432]                           invokeRestart("muffleWarning")
[17:02:51.432]                       }
[17:02:51.432]                       else if (inherits(cond, "condition")) {
[17:02:51.432]                         if (!is.null(pattern)) {
[17:02:51.432]                           computeRestarts <- base::computeRestarts
[17:02:51.432]                           grepl <- base::grepl
[17:02:51.432]                           restarts <- computeRestarts(cond)
[17:02:51.432]                           for (restart in restarts) {
[17:02:51.432]                             name <- restart$name
[17:02:51.432]                             if (is.null(name)) 
[17:02:51.432]                               next
[17:02:51.432]                             if (!grepl(pattern, name)) 
[17:02:51.432]                               next
[17:02:51.432]                             invokeRestart(restart)
[17:02:51.432]                             muffled <- TRUE
[17:02:51.432]                             break
[17:02:51.432]                           }
[17:02:51.432]                         }
[17:02:51.432]                       }
[17:02:51.432]                       invisible(muffled)
[17:02:51.432]                     }
[17:02:51.432]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.432]                   }
[17:02:51.432]                 }
[17:02:51.432]             }
[17:02:51.432]         }))
[17:02:51.432]     }, error = function(ex) {
[17:02:51.432]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.432]                 ...future.rng), started = ...future.startTime, 
[17:02:51.432]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.432]             version = "1.8"), class = "FutureResult")
[17:02:51.432]     }, finally = {
[17:02:51.432]         if (!identical(...future.workdir, getwd())) 
[17:02:51.432]             setwd(...future.workdir)
[17:02:51.432]         {
[17:02:51.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.432]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.432]             }
[17:02:51.432]             base::options(...future.oldOptions)
[17:02:51.432]             if (.Platform$OS.type == "windows") {
[17:02:51.432]                 old_names <- names(...future.oldEnvVars)
[17:02:51.432]                 envs <- base::Sys.getenv()
[17:02:51.432]                 names <- names(envs)
[17:02:51.432]                 common <- intersect(names, old_names)
[17:02:51.432]                 added <- setdiff(names, old_names)
[17:02:51.432]                 removed <- setdiff(old_names, names)
[17:02:51.432]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.432]                   envs[common]]
[17:02:51.432]                 NAMES <- toupper(changed)
[17:02:51.432]                 args <- list()
[17:02:51.432]                 for (kk in seq_along(NAMES)) {
[17:02:51.432]                   name <- changed[[kk]]
[17:02:51.432]                   NAME <- NAMES[[kk]]
[17:02:51.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.432]                     next
[17:02:51.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.432]                 }
[17:02:51.432]                 NAMES <- toupper(added)
[17:02:51.432]                 for (kk in seq_along(NAMES)) {
[17:02:51.432]                   name <- added[[kk]]
[17:02:51.432]                   NAME <- NAMES[[kk]]
[17:02:51.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.432]                     next
[17:02:51.432]                   args[[name]] <- ""
[17:02:51.432]                 }
[17:02:51.432]                 NAMES <- toupper(removed)
[17:02:51.432]                 for (kk in seq_along(NAMES)) {
[17:02:51.432]                   name <- removed[[kk]]
[17:02:51.432]                   NAME <- NAMES[[kk]]
[17:02:51.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.432]                     next
[17:02:51.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.432]                 }
[17:02:51.432]                 if (length(args) > 0) 
[17:02:51.432]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.432]             }
[17:02:51.432]             else {
[17:02:51.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.432]             }
[17:02:51.432]             {
[17:02:51.432]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.432]                   0L) {
[17:02:51.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.432]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.432]                   base::options(opts)
[17:02:51.432]                 }
[17:02:51.432]                 {
[17:02:51.432]                   {
[17:02:51.432]                     NULL
[17:02:51.432]                     RNGkind("Mersenne-Twister")
[17:02:51.432]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.432]                       inherits = FALSE)
[17:02:51.432]                   }
[17:02:51.432]                   options(future.plan = NULL)
[17:02:51.432]                   if (is.na(NA_character_)) 
[17:02:51.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.432]                     .init = FALSE)
[17:02:51.432]                 }
[17:02:51.432]             }
[17:02:51.432]         }
[17:02:51.432]     })
[17:02:51.432]     if (TRUE) {
[17:02:51.432]         base::sink(type = "output", split = FALSE)
[17:02:51.432]         if (TRUE) {
[17:02:51.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.432]         }
[17:02:51.432]         else {
[17:02:51.432]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.432]         }
[17:02:51.432]         base::close(...future.stdout)
[17:02:51.432]         ...future.stdout <- NULL
[17:02:51.432]     }
[17:02:51.432]     ...future.result$conditions <- ...future.conditions
[17:02:51.432]     ...future.result$finished <- base::Sys.time()
[17:02:51.432]     ...future.result
[17:02:51.432] }
[17:02:51.434] plan(): Setting new future strategy stack:
[17:02:51.434] List of future strategies:
[17:02:51.434] 1. sequential:
[17:02:51.434]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.434]    - tweaked: FALSE
[17:02:51.434]    - call: NULL
[17:02:51.434] plan(): nbrOfWorkers() = 1
[17:02:51.435] plan(): Setting new future strategy stack:
[17:02:51.435] List of future strategies:
[17:02:51.435] 1. sequential:
[17:02:51.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.435]    - tweaked: FALSE
[17:02:51.435]    - call: plan(strategy)
[17:02:51.436] plan(): nbrOfWorkers() = 1
[17:02:51.436] SequentialFuture started (and completed)
[17:02:51.436] - Launch lazy future ... done
[17:02:51.436] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.436] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.437] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.438] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:02:51.438] Searching for globals ... DONE
[17:02:51.438] Resolving globals: TRUE
[17:02:51.438] Resolving any globals that are futures ...
[17:02:51.438] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:02:51.439] Resolving any globals that are futures ... DONE
[17:02:51.439] Resolving futures part of globals (recursively) ...
[17:02:51.439] resolve() on list ...
[17:02:51.439]  recursive: 99
[17:02:51.439]  length: 1
[17:02:51.439]  elements: ‘x’
[17:02:51.440]  length: 0 (resolved future 1)
[17:02:51.440] resolve() on list ... DONE
[17:02:51.440] - globals: [1] ‘x’
[17:02:51.440] Resolving futures part of globals (recursively) ... DONE
[17:02:51.440] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.440] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:02:51.440] - globals: [1] ‘x’
[17:02:51.441] 
[17:02:51.441] getGlobalsAndPackages() ... DONE
[17:02:51.441] run() for ‘Future’ ...
[17:02:51.441] - state: ‘created’
[17:02:51.441] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.441] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.442]   - Field: ‘label’
[17:02:51.442]   - Field: ‘local’
[17:02:51.442]   - Field: ‘owner’
[17:02:51.442]   - Field: ‘envir’
[17:02:51.442]   - Field: ‘packages’
[17:02:51.442]   - Field: ‘gc’
[17:02:51.442]   - Field: ‘conditions’
[17:02:51.442]   - Field: ‘expr’
[17:02:51.442]   - Field: ‘uuid’
[17:02:51.442]   - Field: ‘seed’
[17:02:51.442]   - Field: ‘version’
[17:02:51.443]   - Field: ‘result’
[17:02:51.443]   - Field: ‘asynchronous’
[17:02:51.443]   - Field: ‘calls’
[17:02:51.443]   - Field: ‘globals’
[17:02:51.443]   - Field: ‘stdout’
[17:02:51.443]   - Field: ‘earlySignal’
[17:02:51.443]   - Field: ‘lazy’
[17:02:51.443]   - Field: ‘state’
[17:02:51.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.443] - Launch lazy future ...
[17:02:51.444] Packages needed by the future expression (n = 0): <none>
[17:02:51.444] Packages needed by future strategies (n = 0): <none>
[17:02:51.444] {
[17:02:51.444]     {
[17:02:51.444]         {
[17:02:51.444]             ...future.startTime <- base::Sys.time()
[17:02:51.444]             {
[17:02:51.444]                 {
[17:02:51.444]                   {
[17:02:51.444]                     base::local({
[17:02:51.444]                       has_future <- base::requireNamespace("future", 
[17:02:51.444]                         quietly = TRUE)
[17:02:51.444]                       if (has_future) {
[17:02:51.444]                         ns <- base::getNamespace("future")
[17:02:51.444]                         version <- ns[[".package"]][["version"]]
[17:02:51.444]                         if (is.null(version)) 
[17:02:51.444]                           version <- utils::packageVersion("future")
[17:02:51.444]                       }
[17:02:51.444]                       else {
[17:02:51.444]                         version <- NULL
[17:02:51.444]                       }
[17:02:51.444]                       if (!has_future || version < "1.8.0") {
[17:02:51.444]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.444]                           "", base::R.version$version.string), 
[17:02:51.444]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.444]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.444]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.444]                             "release", "version")], collapse = " "), 
[17:02:51.444]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.444]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.444]                           info)
[17:02:51.444]                         info <- base::paste(info, collapse = "; ")
[17:02:51.444]                         if (!has_future) {
[17:02:51.444]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.444]                             info)
[17:02:51.444]                         }
[17:02:51.444]                         else {
[17:02:51.444]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.444]                             info, version)
[17:02:51.444]                         }
[17:02:51.444]                         base::stop(msg)
[17:02:51.444]                       }
[17:02:51.444]                     })
[17:02:51.444]                   }
[17:02:51.444]                   ...future.strategy.old <- future::plan("list")
[17:02:51.444]                   options(future.plan = NULL)
[17:02:51.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.444]                 }
[17:02:51.444]                 ...future.workdir <- getwd()
[17:02:51.444]             }
[17:02:51.444]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.444]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.444]         }
[17:02:51.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.444]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.444]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.444]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.444]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.444]             base::names(...future.oldOptions))
[17:02:51.444]     }
[17:02:51.444]     if (FALSE) {
[17:02:51.444]     }
[17:02:51.444]     else {
[17:02:51.444]         if (TRUE) {
[17:02:51.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.444]                 open = "w")
[17:02:51.444]         }
[17:02:51.444]         else {
[17:02:51.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.444]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.444]         }
[17:02:51.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.444]             base::sink(type = "output", split = FALSE)
[17:02:51.444]             base::close(...future.stdout)
[17:02:51.444]         }, add = TRUE)
[17:02:51.444]     }
[17:02:51.444]     ...future.frame <- base::sys.nframe()
[17:02:51.444]     ...future.conditions <- base::list()
[17:02:51.444]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.444]     if (FALSE) {
[17:02:51.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.444]     }
[17:02:51.444]     ...future.result <- base::tryCatch({
[17:02:51.444]         base::withCallingHandlers({
[17:02:51.444]             ...future.value <- base::withVisible(base::local({
[17:02:51.444]                 x <- x + 1
[17:02:51.444]                 x
[17:02:51.444]             }))
[17:02:51.444]             future::FutureResult(value = ...future.value$value, 
[17:02:51.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.444]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.444]                     ...future.globalenv.names))
[17:02:51.444]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.444]         }, condition = base::local({
[17:02:51.444]             c <- base::c
[17:02:51.444]             inherits <- base::inherits
[17:02:51.444]             invokeRestart <- base::invokeRestart
[17:02:51.444]             length <- base::length
[17:02:51.444]             list <- base::list
[17:02:51.444]             seq.int <- base::seq.int
[17:02:51.444]             signalCondition <- base::signalCondition
[17:02:51.444]             sys.calls <- base::sys.calls
[17:02:51.444]             `[[` <- base::`[[`
[17:02:51.444]             `+` <- base::`+`
[17:02:51.444]             `<<-` <- base::`<<-`
[17:02:51.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.444]                   3L)]
[17:02:51.444]             }
[17:02:51.444]             function(cond) {
[17:02:51.444]                 is_error <- inherits(cond, "error")
[17:02:51.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.444]                   NULL)
[17:02:51.444]                 if (is_error) {
[17:02:51.444]                   sessionInformation <- function() {
[17:02:51.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.444]                       search = base::search(), system = base::Sys.info())
[17:02:51.444]                   }
[17:02:51.444]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.444]                     cond$call), session = sessionInformation(), 
[17:02:51.444]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.444]                   signalCondition(cond)
[17:02:51.444]                 }
[17:02:51.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.444]                 "immediateCondition"))) {
[17:02:51.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.444]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.444]                   if (TRUE && !signal) {
[17:02:51.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.444]                     {
[17:02:51.444]                       inherits <- base::inherits
[17:02:51.444]                       invokeRestart <- base::invokeRestart
[17:02:51.444]                       is.null <- base::is.null
[17:02:51.444]                       muffled <- FALSE
[17:02:51.444]                       if (inherits(cond, "message")) {
[17:02:51.444]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.444]                         if (muffled) 
[17:02:51.444]                           invokeRestart("muffleMessage")
[17:02:51.444]                       }
[17:02:51.444]                       else if (inherits(cond, "warning")) {
[17:02:51.444]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.444]                         if (muffled) 
[17:02:51.444]                           invokeRestart("muffleWarning")
[17:02:51.444]                       }
[17:02:51.444]                       else if (inherits(cond, "condition")) {
[17:02:51.444]                         if (!is.null(pattern)) {
[17:02:51.444]                           computeRestarts <- base::computeRestarts
[17:02:51.444]                           grepl <- base::grepl
[17:02:51.444]                           restarts <- computeRestarts(cond)
[17:02:51.444]                           for (restart in restarts) {
[17:02:51.444]                             name <- restart$name
[17:02:51.444]                             if (is.null(name)) 
[17:02:51.444]                               next
[17:02:51.444]                             if (!grepl(pattern, name)) 
[17:02:51.444]                               next
[17:02:51.444]                             invokeRestart(restart)
[17:02:51.444]                             muffled <- TRUE
[17:02:51.444]                             break
[17:02:51.444]                           }
[17:02:51.444]                         }
[17:02:51.444]                       }
[17:02:51.444]                       invisible(muffled)
[17:02:51.444]                     }
[17:02:51.444]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.444]                   }
[17:02:51.444]                 }
[17:02:51.444]                 else {
[17:02:51.444]                   if (TRUE) {
[17:02:51.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.444]                     {
[17:02:51.444]                       inherits <- base::inherits
[17:02:51.444]                       invokeRestart <- base::invokeRestart
[17:02:51.444]                       is.null <- base::is.null
[17:02:51.444]                       muffled <- FALSE
[17:02:51.444]                       if (inherits(cond, "message")) {
[17:02:51.444]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.444]                         if (muffled) 
[17:02:51.444]                           invokeRestart("muffleMessage")
[17:02:51.444]                       }
[17:02:51.444]                       else if (inherits(cond, "warning")) {
[17:02:51.444]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.444]                         if (muffled) 
[17:02:51.444]                           invokeRestart("muffleWarning")
[17:02:51.444]                       }
[17:02:51.444]                       else if (inherits(cond, "condition")) {
[17:02:51.444]                         if (!is.null(pattern)) {
[17:02:51.444]                           computeRestarts <- base::computeRestarts
[17:02:51.444]                           grepl <- base::grepl
[17:02:51.444]                           restarts <- computeRestarts(cond)
[17:02:51.444]                           for (restart in restarts) {
[17:02:51.444]                             name <- restart$name
[17:02:51.444]                             if (is.null(name)) 
[17:02:51.444]                               next
[17:02:51.444]                             if (!grepl(pattern, name)) 
[17:02:51.444]                               next
[17:02:51.444]                             invokeRestart(restart)
[17:02:51.444]                             muffled <- TRUE
[17:02:51.444]                             break
[17:02:51.444]                           }
[17:02:51.444]                         }
[17:02:51.444]                       }
[17:02:51.444]                       invisible(muffled)
[17:02:51.444]                     }
[17:02:51.444]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.444]                   }
[17:02:51.444]                 }
[17:02:51.444]             }
[17:02:51.444]         }))
[17:02:51.444]     }, error = function(ex) {
[17:02:51.444]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.444]                 ...future.rng), started = ...future.startTime, 
[17:02:51.444]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.444]             version = "1.8"), class = "FutureResult")
[17:02:51.444]     }, finally = {
[17:02:51.444]         if (!identical(...future.workdir, getwd())) 
[17:02:51.444]             setwd(...future.workdir)
[17:02:51.444]         {
[17:02:51.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.444]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.444]             }
[17:02:51.444]             base::options(...future.oldOptions)
[17:02:51.444]             if (.Platform$OS.type == "windows") {
[17:02:51.444]                 old_names <- names(...future.oldEnvVars)
[17:02:51.444]                 envs <- base::Sys.getenv()
[17:02:51.444]                 names <- names(envs)
[17:02:51.444]                 common <- intersect(names, old_names)
[17:02:51.444]                 added <- setdiff(names, old_names)
[17:02:51.444]                 removed <- setdiff(old_names, names)
[17:02:51.444]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.444]                   envs[common]]
[17:02:51.444]                 NAMES <- toupper(changed)
[17:02:51.444]                 args <- list()
[17:02:51.444]                 for (kk in seq_along(NAMES)) {
[17:02:51.444]                   name <- changed[[kk]]
[17:02:51.444]                   NAME <- NAMES[[kk]]
[17:02:51.444]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.444]                     next
[17:02:51.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.444]                 }
[17:02:51.444]                 NAMES <- toupper(added)
[17:02:51.444]                 for (kk in seq_along(NAMES)) {
[17:02:51.444]                   name <- added[[kk]]
[17:02:51.444]                   NAME <- NAMES[[kk]]
[17:02:51.444]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.444]                     next
[17:02:51.444]                   args[[name]] <- ""
[17:02:51.444]                 }
[17:02:51.444]                 NAMES <- toupper(removed)
[17:02:51.444]                 for (kk in seq_along(NAMES)) {
[17:02:51.444]                   name <- removed[[kk]]
[17:02:51.444]                   NAME <- NAMES[[kk]]
[17:02:51.444]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.444]                     next
[17:02:51.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.444]                 }
[17:02:51.444]                 if (length(args) > 0) 
[17:02:51.444]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.444]             }
[17:02:51.444]             else {
[17:02:51.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.444]             }
[17:02:51.444]             {
[17:02:51.444]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.444]                   0L) {
[17:02:51.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.444]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.444]                   base::options(opts)
[17:02:51.444]                 }
[17:02:51.444]                 {
[17:02:51.444]                   {
[17:02:51.444]                     NULL
[17:02:51.444]                     RNGkind("Mersenne-Twister")
[17:02:51.444]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.444]                       inherits = FALSE)
[17:02:51.444]                   }
[17:02:51.444]                   options(future.plan = NULL)
[17:02:51.444]                   if (is.na(NA_character_)) 
[17:02:51.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.444]                     .init = FALSE)
[17:02:51.444]                 }
[17:02:51.444]             }
[17:02:51.444]         }
[17:02:51.444]     })
[17:02:51.444]     if (TRUE) {
[17:02:51.444]         base::sink(type = "output", split = FALSE)
[17:02:51.444]         if (TRUE) {
[17:02:51.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.444]         }
[17:02:51.444]         else {
[17:02:51.444]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.444]         }
[17:02:51.444]         base::close(...future.stdout)
[17:02:51.444]         ...future.stdout <- NULL
[17:02:51.444]     }
[17:02:51.444]     ...future.result$conditions <- ...future.conditions
[17:02:51.444]     ...future.result$finished <- base::Sys.time()
[17:02:51.444]     ...future.result
[17:02:51.444] }
[17:02:51.446] assign_globals() ...
[17:02:51.446] List of 1
[17:02:51.446]  $ x: num 1
[17:02:51.446]  - attr(*, "where")=List of 1
[17:02:51.446]   ..$ x:<environment: R_EmptyEnv> 
[17:02:51.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.446]  - attr(*, "resolved")= logi TRUE
[17:02:51.446]  - attr(*, "total_size")= num 56
[17:02:51.446]  - attr(*, "already-done")= logi TRUE
[17:02:51.448] - copied ‘x’ to environment
[17:02:51.448] assign_globals() ... done
[17:02:51.449] plan(): Setting new future strategy stack:
[17:02:51.449] List of future strategies:
[17:02:51.449] 1. sequential:
[17:02:51.449]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.449]    - tweaked: FALSE
[17:02:51.449]    - call: NULL
[17:02:51.449] plan(): nbrOfWorkers() = 1
[17:02:51.450] plan(): Setting new future strategy stack:
[17:02:51.450] List of future strategies:
[17:02:51.450] 1. sequential:
[17:02:51.450]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.450]    - tweaked: FALSE
[17:02:51.450]    - call: plan(strategy)
[17:02:51.450] plan(): nbrOfWorkers() = 1
[17:02:51.451] SequentialFuture started (and completed)
[17:02:51.451] - Launch lazy future ... done
[17:02:51.451] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.451] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.451] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:51.453] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:02:51.453] Searching for globals ... DONE
[17:02:51.453] Resolving globals: TRUE
[17:02:51.453] Resolving any globals that are futures ...
[17:02:51.453] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:02:51.454] Resolving any globals that are futures ... DONE
[17:02:51.454] Resolving futures part of globals (recursively) ...
[17:02:51.454] resolve() on list ...
[17:02:51.454]  recursive: 99
[17:02:51.454]  length: 1
[17:02:51.454]  elements: ‘x’
[17:02:51.455]  length: 0 (resolved future 1)
[17:02:51.455] resolve() on list ... DONE
[17:02:51.455] - globals: [1] ‘x’
[17:02:51.455] Resolving futures part of globals (recursively) ... DONE
[17:02:51.455] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:02:51.455] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:02:51.455] - globals: [1] ‘x’
[17:02:51.456] 
[17:02:51.456] getGlobalsAndPackages() ... DONE
[17:02:51.456] run() for ‘Future’ ...
[17:02:51.456] - state: ‘created’
[17:02:51.456] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:51.456] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:51.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:51.457]   - Field: ‘label’
[17:02:51.457]   - Field: ‘local’
[17:02:51.457]   - Field: ‘owner’
[17:02:51.457]   - Field: ‘envir’
[17:02:51.457]   - Field: ‘packages’
[17:02:51.457]   - Field: ‘gc’
[17:02:51.457]   - Field: ‘conditions’
[17:02:51.457]   - Field: ‘expr’
[17:02:51.457]   - Field: ‘uuid’
[17:02:51.457]   - Field: ‘seed’
[17:02:51.458]   - Field: ‘version’
[17:02:51.458]   - Field: ‘result’
[17:02:51.458]   - Field: ‘asynchronous’
[17:02:51.459]   - Field: ‘calls’
[17:02:51.459]   - Field: ‘globals’
[17:02:51.460]   - Field: ‘stdout’
[17:02:51.460]   - Field: ‘earlySignal’
[17:02:51.460]   - Field: ‘lazy’
[17:02:51.460]   - Field: ‘state’
[17:02:51.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:51.460] - Launch lazy future ...
[17:02:51.460] Packages needed by the future expression (n = 0): <none>
[17:02:51.460] Packages needed by future strategies (n = 0): <none>
[17:02:51.461] {
[17:02:51.461]     {
[17:02:51.461]         {
[17:02:51.461]             ...future.startTime <- base::Sys.time()
[17:02:51.461]             {
[17:02:51.461]                 {
[17:02:51.461]                   {
[17:02:51.461]                     base::local({
[17:02:51.461]                       has_future <- base::requireNamespace("future", 
[17:02:51.461]                         quietly = TRUE)
[17:02:51.461]                       if (has_future) {
[17:02:51.461]                         ns <- base::getNamespace("future")
[17:02:51.461]                         version <- ns[[".package"]][["version"]]
[17:02:51.461]                         if (is.null(version)) 
[17:02:51.461]                           version <- utils::packageVersion("future")
[17:02:51.461]                       }
[17:02:51.461]                       else {
[17:02:51.461]                         version <- NULL
[17:02:51.461]                       }
[17:02:51.461]                       if (!has_future || version < "1.8.0") {
[17:02:51.461]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.461]                           "", base::R.version$version.string), 
[17:02:51.461]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:51.461]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.461]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.461]                             "release", "version")], collapse = " "), 
[17:02:51.461]                           hostname = base::Sys.info()[["nodename"]])
[17:02:51.461]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.461]                           info)
[17:02:51.461]                         info <- base::paste(info, collapse = "; ")
[17:02:51.461]                         if (!has_future) {
[17:02:51.461]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.461]                             info)
[17:02:51.461]                         }
[17:02:51.461]                         else {
[17:02:51.461]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.461]                             info, version)
[17:02:51.461]                         }
[17:02:51.461]                         base::stop(msg)
[17:02:51.461]                       }
[17:02:51.461]                     })
[17:02:51.461]                   }
[17:02:51.461]                   ...future.strategy.old <- future::plan("list")
[17:02:51.461]                   options(future.plan = NULL)
[17:02:51.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.461]                 }
[17:02:51.461]                 ...future.workdir <- getwd()
[17:02:51.461]             }
[17:02:51.461]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.461]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.461]         }
[17:02:51.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.461]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:51.461]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.461]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.461]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.461]             base::names(...future.oldOptions))
[17:02:51.461]     }
[17:02:51.461]     if (FALSE) {
[17:02:51.461]     }
[17:02:51.461]     else {
[17:02:51.461]         if (TRUE) {
[17:02:51.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.461]                 open = "w")
[17:02:51.461]         }
[17:02:51.461]         else {
[17:02:51.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.461]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.461]         }
[17:02:51.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.461]             base::sink(type = "output", split = FALSE)
[17:02:51.461]             base::close(...future.stdout)
[17:02:51.461]         }, add = TRUE)
[17:02:51.461]     }
[17:02:51.461]     ...future.frame <- base::sys.nframe()
[17:02:51.461]     ...future.conditions <- base::list()
[17:02:51.461]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.461]     if (FALSE) {
[17:02:51.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.461]     }
[17:02:51.461]     ...future.result <- base::tryCatch({
[17:02:51.461]         base::withCallingHandlers({
[17:02:51.461]             ...future.value <- base::withVisible(base::local({
[17:02:51.461]                 x <- x()
[17:02:51.461]                 x
[17:02:51.461]             }))
[17:02:51.461]             future::FutureResult(value = ...future.value$value, 
[17:02:51.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.461]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.461]                     ...future.globalenv.names))
[17:02:51.461]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.461]         }, condition = base::local({
[17:02:51.461]             c <- base::c
[17:02:51.461]             inherits <- base::inherits
[17:02:51.461]             invokeRestart <- base::invokeRestart
[17:02:51.461]             length <- base::length
[17:02:51.461]             list <- base::list
[17:02:51.461]             seq.int <- base::seq.int
[17:02:51.461]             signalCondition <- base::signalCondition
[17:02:51.461]             sys.calls <- base::sys.calls
[17:02:51.461]             `[[` <- base::`[[`
[17:02:51.461]             `+` <- base::`+`
[17:02:51.461]             `<<-` <- base::`<<-`
[17:02:51.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.461]                   3L)]
[17:02:51.461]             }
[17:02:51.461]             function(cond) {
[17:02:51.461]                 is_error <- inherits(cond, "error")
[17:02:51.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.461]                   NULL)
[17:02:51.461]                 if (is_error) {
[17:02:51.461]                   sessionInformation <- function() {
[17:02:51.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.461]                       search = base::search(), system = base::Sys.info())
[17:02:51.461]                   }
[17:02:51.461]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.461]                     cond$call), session = sessionInformation(), 
[17:02:51.461]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.461]                   signalCondition(cond)
[17:02:51.461]                 }
[17:02:51.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.461]                 "immediateCondition"))) {
[17:02:51.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.461]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.461]                   if (TRUE && !signal) {
[17:02:51.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.461]                     {
[17:02:51.461]                       inherits <- base::inherits
[17:02:51.461]                       invokeRestart <- base::invokeRestart
[17:02:51.461]                       is.null <- base::is.null
[17:02:51.461]                       muffled <- FALSE
[17:02:51.461]                       if (inherits(cond, "message")) {
[17:02:51.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.461]                         if (muffled) 
[17:02:51.461]                           invokeRestart("muffleMessage")
[17:02:51.461]                       }
[17:02:51.461]                       else if (inherits(cond, "warning")) {
[17:02:51.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.461]                         if (muffled) 
[17:02:51.461]                           invokeRestart("muffleWarning")
[17:02:51.461]                       }
[17:02:51.461]                       else if (inherits(cond, "condition")) {
[17:02:51.461]                         if (!is.null(pattern)) {
[17:02:51.461]                           computeRestarts <- base::computeRestarts
[17:02:51.461]                           grepl <- base::grepl
[17:02:51.461]                           restarts <- computeRestarts(cond)
[17:02:51.461]                           for (restart in restarts) {
[17:02:51.461]                             name <- restart$name
[17:02:51.461]                             if (is.null(name)) 
[17:02:51.461]                               next
[17:02:51.461]                             if (!grepl(pattern, name)) 
[17:02:51.461]                               next
[17:02:51.461]                             invokeRestart(restart)
[17:02:51.461]                             muffled <- TRUE
[17:02:51.461]                             break
[17:02:51.461]                           }
[17:02:51.461]                         }
[17:02:51.461]                       }
[17:02:51.461]                       invisible(muffled)
[17:02:51.461]                     }
[17:02:51.461]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.461]                   }
[17:02:51.461]                 }
[17:02:51.461]                 else {
[17:02:51.461]                   if (TRUE) {
[17:02:51.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.461]                     {
[17:02:51.461]                       inherits <- base::inherits
[17:02:51.461]                       invokeRestart <- base::invokeRestart
[17:02:51.461]                       is.null <- base::is.null
[17:02:51.461]                       muffled <- FALSE
[17:02:51.461]                       if (inherits(cond, "message")) {
[17:02:51.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.461]                         if (muffled) 
[17:02:51.461]                           invokeRestart("muffleMessage")
[17:02:51.461]                       }
[17:02:51.461]                       else if (inherits(cond, "warning")) {
[17:02:51.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.461]                         if (muffled) 
[17:02:51.461]                           invokeRestart("muffleWarning")
[17:02:51.461]                       }
[17:02:51.461]                       else if (inherits(cond, "condition")) {
[17:02:51.461]                         if (!is.null(pattern)) {
[17:02:51.461]                           computeRestarts <- base::computeRestarts
[17:02:51.461]                           grepl <- base::grepl
[17:02:51.461]                           restarts <- computeRestarts(cond)
[17:02:51.461]                           for (restart in restarts) {
[17:02:51.461]                             name <- restart$name
[17:02:51.461]                             if (is.null(name)) 
[17:02:51.461]                               next
[17:02:51.461]                             if (!grepl(pattern, name)) 
[17:02:51.461]                               next
[17:02:51.461]                             invokeRestart(restart)
[17:02:51.461]                             muffled <- TRUE
[17:02:51.461]                             break
[17:02:51.461]                           }
[17:02:51.461]                         }
[17:02:51.461]                       }
[17:02:51.461]                       invisible(muffled)
[17:02:51.461]                     }
[17:02:51.461]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.461]                   }
[17:02:51.461]                 }
[17:02:51.461]             }
[17:02:51.461]         }))
[17:02:51.461]     }, error = function(ex) {
[17:02:51.461]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.461]                 ...future.rng), started = ...future.startTime, 
[17:02:51.461]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.461]             version = "1.8"), class = "FutureResult")
[17:02:51.461]     }, finally = {
[17:02:51.461]         if (!identical(...future.workdir, getwd())) 
[17:02:51.461]             setwd(...future.workdir)
[17:02:51.461]         {
[17:02:51.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.461]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.461]             }
[17:02:51.461]             base::options(...future.oldOptions)
[17:02:51.461]             if (.Platform$OS.type == "windows") {
[17:02:51.461]                 old_names <- names(...future.oldEnvVars)
[17:02:51.461]                 envs <- base::Sys.getenv()
[17:02:51.461]                 names <- names(envs)
[17:02:51.461]                 common <- intersect(names, old_names)
[17:02:51.461]                 added <- setdiff(names, old_names)
[17:02:51.461]                 removed <- setdiff(old_names, names)
[17:02:51.461]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.461]                   envs[common]]
[17:02:51.461]                 NAMES <- toupper(changed)
[17:02:51.461]                 args <- list()
[17:02:51.461]                 for (kk in seq_along(NAMES)) {
[17:02:51.461]                   name <- changed[[kk]]
[17:02:51.461]                   NAME <- NAMES[[kk]]
[17:02:51.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.461]                     next
[17:02:51.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.461]                 }
[17:02:51.461]                 NAMES <- toupper(added)
[17:02:51.461]                 for (kk in seq_along(NAMES)) {
[17:02:51.461]                   name <- added[[kk]]
[17:02:51.461]                   NAME <- NAMES[[kk]]
[17:02:51.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.461]                     next
[17:02:51.461]                   args[[name]] <- ""
[17:02:51.461]                 }
[17:02:51.461]                 NAMES <- toupper(removed)
[17:02:51.461]                 for (kk in seq_along(NAMES)) {
[17:02:51.461]                   name <- removed[[kk]]
[17:02:51.461]                   NAME <- NAMES[[kk]]
[17:02:51.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.461]                     next
[17:02:51.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.461]                 }
[17:02:51.461]                 if (length(args) > 0) 
[17:02:51.461]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.461]             }
[17:02:51.461]             else {
[17:02:51.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.461]             }
[17:02:51.461]             {
[17:02:51.461]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.461]                   0L) {
[17:02:51.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.461]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.461]                   base::options(opts)
[17:02:51.461]                 }
[17:02:51.461]                 {
[17:02:51.461]                   {
[17:02:51.461]                     NULL
[17:02:51.461]                     RNGkind("Mersenne-Twister")
[17:02:51.461]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:51.461]                       inherits = FALSE)
[17:02:51.461]                   }
[17:02:51.461]                   options(future.plan = NULL)
[17:02:51.461]                   if (is.na(NA_character_)) 
[17:02:51.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.461]                     .init = FALSE)
[17:02:51.461]                 }
[17:02:51.461]             }
[17:02:51.461]         }
[17:02:51.461]     })
[17:02:51.461]     if (TRUE) {
[17:02:51.461]         base::sink(type = "output", split = FALSE)
[17:02:51.461]         if (TRUE) {
[17:02:51.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.461]         }
[17:02:51.461]         else {
[17:02:51.461]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.461]         }
[17:02:51.461]         base::close(...future.stdout)
[17:02:51.461]         ...future.stdout <- NULL
[17:02:51.461]     }
[17:02:51.461]     ...future.result$conditions <- ...future.conditions
[17:02:51.461]     ...future.result$finished <- base::Sys.time()
[17:02:51.461]     ...future.result
[17:02:51.461] }
[17:02:51.463] assign_globals() ...
[17:02:51.463] List of 1
[17:02:51.463]  $ x:function ()  
[17:02:51.463]  - attr(*, "where")=List of 1
[17:02:51.463]   ..$ x:<environment: R_EmptyEnv> 
[17:02:51.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.463]  - attr(*, "resolved")= logi TRUE
[17:02:51.463]  - attr(*, "total_size")= num 1032
[17:02:51.463]  - attr(*, "already-done")= logi TRUE
[17:02:51.465] - reassign environment for ‘x’
[17:02:51.465] - copied ‘x’ to environment
[17:02:51.465] assign_globals() ... done
[17:02:51.466] plan(): Setting new future strategy stack:
[17:02:51.466] List of future strategies:
[17:02:51.466] 1. sequential:
[17:02:51.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.466]    - tweaked: FALSE
[17:02:51.466]    - call: NULL
[17:02:51.466] plan(): nbrOfWorkers() = 1
[17:02:51.467] plan(): Setting new future strategy stack:
[17:02:51.467] List of future strategies:
[17:02:51.467] 1. sequential:
[17:02:51.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.467]    - tweaked: FALSE
[17:02:51.467]    - call: plan(strategy)
[17:02:51.467] plan(): nbrOfWorkers() = 1
[17:02:51.468] SequentialFuture started (and completed)
[17:02:51.468] - Launch lazy future ... done
[17:02:51.468] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[17:02:51.477] plan(): Setting new future strategy stack:
[17:02:51.477] List of future strategies:
[17:02:51.477] 1. multicore:
[17:02:51.477]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.477]    - tweaked: FALSE
[17:02:51.477]    - call: plan(strategy)
[17:02:51.480] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.481] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.481] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.482] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:02:51.482] Searching for globals ... DONE
[17:02:51.483] Resolving globals: TRUE
[17:02:51.483] Resolving any globals that are futures ...
[17:02:51.483] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:02:51.483] Resolving any globals that are futures ... DONE
[17:02:51.483] 
[17:02:51.483] 
[17:02:51.483] getGlobalsAndPackages() ... DONE
[17:02:51.484] run() for ‘Future’ ...
[17:02:51.484] - state: ‘created’
[17:02:51.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.488]   - Field: ‘label’
[17:02:51.488]   - Field: ‘local’
[17:02:51.488]   - Field: ‘owner’
[17:02:51.488]   - Field: ‘envir’
[17:02:51.488]   - Field: ‘workers’
[17:02:51.488]   - Field: ‘packages’
[17:02:51.488]   - Field: ‘gc’
[17:02:51.488]   - Field: ‘job’
[17:02:51.488]   - Field: ‘conditions’
[17:02:51.488]   - Field: ‘expr’
[17:02:51.488]   - Field: ‘uuid’
[17:02:51.489]   - Field: ‘seed’
[17:02:51.489]   - Field: ‘version’
[17:02:51.489]   - Field: ‘result’
[17:02:51.489]   - Field: ‘asynchronous’
[17:02:51.489]   - Field: ‘calls’
[17:02:51.489]   - Field: ‘globals’
[17:02:51.489]   - Field: ‘stdout’
[17:02:51.489]   - Field: ‘earlySignal’
[17:02:51.489]   - Field: ‘lazy’
[17:02:51.489]   - Field: ‘state’
[17:02:51.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.490] - Launch lazy future ...
[17:02:51.490] Packages needed by the future expression (n = 0): <none>
[17:02:51.491] Packages needed by future strategies (n = 0): <none>
[17:02:51.491] {
[17:02:51.491]     {
[17:02:51.491]         {
[17:02:51.491]             ...future.startTime <- base::Sys.time()
[17:02:51.491]             {
[17:02:51.491]                 {
[17:02:51.491]                   {
[17:02:51.491]                     {
[17:02:51.491]                       base::local({
[17:02:51.491]                         has_future <- base::requireNamespace("future", 
[17:02:51.491]                           quietly = TRUE)
[17:02:51.491]                         if (has_future) {
[17:02:51.491]                           ns <- base::getNamespace("future")
[17:02:51.491]                           version <- ns[[".package"]][["version"]]
[17:02:51.491]                           if (is.null(version)) 
[17:02:51.491]                             version <- utils::packageVersion("future")
[17:02:51.491]                         }
[17:02:51.491]                         else {
[17:02:51.491]                           version <- NULL
[17:02:51.491]                         }
[17:02:51.491]                         if (!has_future || version < "1.8.0") {
[17:02:51.491]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.491]                             "", base::R.version$version.string), 
[17:02:51.491]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.491]                               "release", "version")], collapse = " "), 
[17:02:51.491]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.491]                             info)
[17:02:51.491]                           info <- base::paste(info, collapse = "; ")
[17:02:51.491]                           if (!has_future) {
[17:02:51.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.491]                               info)
[17:02:51.491]                           }
[17:02:51.491]                           else {
[17:02:51.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.491]                               info, version)
[17:02:51.491]                           }
[17:02:51.491]                           base::stop(msg)
[17:02:51.491]                         }
[17:02:51.491]                       })
[17:02:51.491]                     }
[17:02:51.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.491]                     base::options(mc.cores = 1L)
[17:02:51.491]                   }
[17:02:51.491]                   ...future.strategy.old <- future::plan("list")
[17:02:51.491]                   options(future.plan = NULL)
[17:02:51.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.491]                 }
[17:02:51.491]                 ...future.workdir <- getwd()
[17:02:51.491]             }
[17:02:51.491]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.491]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.491]         }
[17:02:51.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.491]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.491]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.491]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.491]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.491]             base::names(...future.oldOptions))
[17:02:51.491]     }
[17:02:51.491]     if (FALSE) {
[17:02:51.491]     }
[17:02:51.491]     else {
[17:02:51.491]         if (TRUE) {
[17:02:51.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.491]                 open = "w")
[17:02:51.491]         }
[17:02:51.491]         else {
[17:02:51.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.491]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.491]         }
[17:02:51.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.491]             base::sink(type = "output", split = FALSE)
[17:02:51.491]             base::close(...future.stdout)
[17:02:51.491]         }, add = TRUE)
[17:02:51.491]     }
[17:02:51.491]     ...future.frame <- base::sys.nframe()
[17:02:51.491]     ...future.conditions <- base::list()
[17:02:51.491]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.491]     if (FALSE) {
[17:02:51.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.491]     }
[17:02:51.491]     ...future.result <- base::tryCatch({
[17:02:51.491]         base::withCallingHandlers({
[17:02:51.491]             ...future.value <- base::withVisible(base::local({
[17:02:51.491]                 withCallingHandlers({
[17:02:51.491]                   {
[17:02:51.491]                     b <- a
[17:02:51.491]                     a <- 2
[17:02:51.491]                     a * b
[17:02:51.491]                   }
[17:02:51.491]                 }, immediateCondition = function(cond) {
[17:02:51.491]                   save_rds <- function (object, pathname, ...) 
[17:02:51.491]                   {
[17:02:51.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.491]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.491]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.491]                         fi_tmp[["mtime"]])
[17:02:51.491]                     }
[17:02:51.491]                     tryCatch({
[17:02:51.491]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.491]                     }, error = function(ex) {
[17:02:51.491]                       msg <- conditionMessage(ex)
[17:02:51.491]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.491]                         fi_tmp[["mtime"]], msg)
[17:02:51.491]                       ex$message <- msg
[17:02:51.491]                       stop(ex)
[17:02:51.491]                     })
[17:02:51.491]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.491]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.491]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.491]                       fi <- file.info(pathname)
[17:02:51.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.491]                         fi[["size"]], fi[["mtime"]])
[17:02:51.491]                       stop(msg)
[17:02:51.491]                     }
[17:02:51.491]                     invisible(pathname)
[17:02:51.491]                   }
[17:02:51.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.491]                     rootPath = tempdir()) 
[17:02:51.491]                   {
[17:02:51.491]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.491]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.491]                       tmpdir = path, fileext = ".rds")
[17:02:51.491]                     save_rds(obj, file)
[17:02:51.491]                   }
[17:02:51.491]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.491]                   {
[17:02:51.491]                     inherits <- base::inherits
[17:02:51.491]                     invokeRestart <- base::invokeRestart
[17:02:51.491]                     is.null <- base::is.null
[17:02:51.491]                     muffled <- FALSE
[17:02:51.491]                     if (inherits(cond, "message")) {
[17:02:51.491]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.491]                       if (muffled) 
[17:02:51.491]                         invokeRestart("muffleMessage")
[17:02:51.491]                     }
[17:02:51.491]                     else if (inherits(cond, "warning")) {
[17:02:51.491]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.491]                       if (muffled) 
[17:02:51.491]                         invokeRestart("muffleWarning")
[17:02:51.491]                     }
[17:02:51.491]                     else if (inherits(cond, "condition")) {
[17:02:51.491]                       if (!is.null(pattern)) {
[17:02:51.491]                         computeRestarts <- base::computeRestarts
[17:02:51.491]                         grepl <- base::grepl
[17:02:51.491]                         restarts <- computeRestarts(cond)
[17:02:51.491]                         for (restart in restarts) {
[17:02:51.491]                           name <- restart$name
[17:02:51.491]                           if (is.null(name)) 
[17:02:51.491]                             next
[17:02:51.491]                           if (!grepl(pattern, name)) 
[17:02:51.491]                             next
[17:02:51.491]                           invokeRestart(restart)
[17:02:51.491]                           muffled <- TRUE
[17:02:51.491]                           break
[17:02:51.491]                         }
[17:02:51.491]                       }
[17:02:51.491]                     }
[17:02:51.491]                     invisible(muffled)
[17:02:51.491]                   }
[17:02:51.491]                   muffleCondition(cond)
[17:02:51.491]                 })
[17:02:51.491]             }))
[17:02:51.491]             future::FutureResult(value = ...future.value$value, 
[17:02:51.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.491]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.491]                     ...future.globalenv.names))
[17:02:51.491]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.491]         }, condition = base::local({
[17:02:51.491]             c <- base::c
[17:02:51.491]             inherits <- base::inherits
[17:02:51.491]             invokeRestart <- base::invokeRestart
[17:02:51.491]             length <- base::length
[17:02:51.491]             list <- base::list
[17:02:51.491]             seq.int <- base::seq.int
[17:02:51.491]             signalCondition <- base::signalCondition
[17:02:51.491]             sys.calls <- base::sys.calls
[17:02:51.491]             `[[` <- base::`[[`
[17:02:51.491]             `+` <- base::`+`
[17:02:51.491]             `<<-` <- base::`<<-`
[17:02:51.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.491]                   3L)]
[17:02:51.491]             }
[17:02:51.491]             function(cond) {
[17:02:51.491]                 is_error <- inherits(cond, "error")
[17:02:51.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.491]                   NULL)
[17:02:51.491]                 if (is_error) {
[17:02:51.491]                   sessionInformation <- function() {
[17:02:51.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.491]                       search = base::search(), system = base::Sys.info())
[17:02:51.491]                   }
[17:02:51.491]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.491]                     cond$call), session = sessionInformation(), 
[17:02:51.491]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.491]                   signalCondition(cond)
[17:02:51.491]                 }
[17:02:51.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.491]                 "immediateCondition"))) {
[17:02:51.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.491]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.491]                   if (TRUE && !signal) {
[17:02:51.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.491]                     {
[17:02:51.491]                       inherits <- base::inherits
[17:02:51.491]                       invokeRestart <- base::invokeRestart
[17:02:51.491]                       is.null <- base::is.null
[17:02:51.491]                       muffled <- FALSE
[17:02:51.491]                       if (inherits(cond, "message")) {
[17:02:51.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.491]                         if (muffled) 
[17:02:51.491]                           invokeRestart("muffleMessage")
[17:02:51.491]                       }
[17:02:51.491]                       else if (inherits(cond, "warning")) {
[17:02:51.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.491]                         if (muffled) 
[17:02:51.491]                           invokeRestart("muffleWarning")
[17:02:51.491]                       }
[17:02:51.491]                       else if (inherits(cond, "condition")) {
[17:02:51.491]                         if (!is.null(pattern)) {
[17:02:51.491]                           computeRestarts <- base::computeRestarts
[17:02:51.491]                           grepl <- base::grepl
[17:02:51.491]                           restarts <- computeRestarts(cond)
[17:02:51.491]                           for (restart in restarts) {
[17:02:51.491]                             name <- restart$name
[17:02:51.491]                             if (is.null(name)) 
[17:02:51.491]                               next
[17:02:51.491]                             if (!grepl(pattern, name)) 
[17:02:51.491]                               next
[17:02:51.491]                             invokeRestart(restart)
[17:02:51.491]                             muffled <- TRUE
[17:02:51.491]                             break
[17:02:51.491]                           }
[17:02:51.491]                         }
[17:02:51.491]                       }
[17:02:51.491]                       invisible(muffled)
[17:02:51.491]                     }
[17:02:51.491]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.491]                   }
[17:02:51.491]                 }
[17:02:51.491]                 else {
[17:02:51.491]                   if (TRUE) {
[17:02:51.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.491]                     {
[17:02:51.491]                       inherits <- base::inherits
[17:02:51.491]                       invokeRestart <- base::invokeRestart
[17:02:51.491]                       is.null <- base::is.null
[17:02:51.491]                       muffled <- FALSE
[17:02:51.491]                       if (inherits(cond, "message")) {
[17:02:51.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.491]                         if (muffled) 
[17:02:51.491]                           invokeRestart("muffleMessage")
[17:02:51.491]                       }
[17:02:51.491]                       else if (inherits(cond, "warning")) {
[17:02:51.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.491]                         if (muffled) 
[17:02:51.491]                           invokeRestart("muffleWarning")
[17:02:51.491]                       }
[17:02:51.491]                       else if (inherits(cond, "condition")) {
[17:02:51.491]                         if (!is.null(pattern)) {
[17:02:51.491]                           computeRestarts <- base::computeRestarts
[17:02:51.491]                           grepl <- base::grepl
[17:02:51.491]                           restarts <- computeRestarts(cond)
[17:02:51.491]                           for (restart in restarts) {
[17:02:51.491]                             name <- restart$name
[17:02:51.491]                             if (is.null(name)) 
[17:02:51.491]                               next
[17:02:51.491]                             if (!grepl(pattern, name)) 
[17:02:51.491]                               next
[17:02:51.491]                             invokeRestart(restart)
[17:02:51.491]                             muffled <- TRUE
[17:02:51.491]                             break
[17:02:51.491]                           }
[17:02:51.491]                         }
[17:02:51.491]                       }
[17:02:51.491]                       invisible(muffled)
[17:02:51.491]                     }
[17:02:51.491]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.491]                   }
[17:02:51.491]                 }
[17:02:51.491]             }
[17:02:51.491]         }))
[17:02:51.491]     }, error = function(ex) {
[17:02:51.491]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.491]                 ...future.rng), started = ...future.startTime, 
[17:02:51.491]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.491]             version = "1.8"), class = "FutureResult")
[17:02:51.491]     }, finally = {
[17:02:51.491]         if (!identical(...future.workdir, getwd())) 
[17:02:51.491]             setwd(...future.workdir)
[17:02:51.491]         {
[17:02:51.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.491]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.491]             }
[17:02:51.491]             base::options(...future.oldOptions)
[17:02:51.491]             if (.Platform$OS.type == "windows") {
[17:02:51.491]                 old_names <- names(...future.oldEnvVars)
[17:02:51.491]                 envs <- base::Sys.getenv()
[17:02:51.491]                 names <- names(envs)
[17:02:51.491]                 common <- intersect(names, old_names)
[17:02:51.491]                 added <- setdiff(names, old_names)
[17:02:51.491]                 removed <- setdiff(old_names, names)
[17:02:51.491]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.491]                   envs[common]]
[17:02:51.491]                 NAMES <- toupper(changed)
[17:02:51.491]                 args <- list()
[17:02:51.491]                 for (kk in seq_along(NAMES)) {
[17:02:51.491]                   name <- changed[[kk]]
[17:02:51.491]                   NAME <- NAMES[[kk]]
[17:02:51.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.491]                     next
[17:02:51.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.491]                 }
[17:02:51.491]                 NAMES <- toupper(added)
[17:02:51.491]                 for (kk in seq_along(NAMES)) {
[17:02:51.491]                   name <- added[[kk]]
[17:02:51.491]                   NAME <- NAMES[[kk]]
[17:02:51.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.491]                     next
[17:02:51.491]                   args[[name]] <- ""
[17:02:51.491]                 }
[17:02:51.491]                 NAMES <- toupper(removed)
[17:02:51.491]                 for (kk in seq_along(NAMES)) {
[17:02:51.491]                   name <- removed[[kk]]
[17:02:51.491]                   NAME <- NAMES[[kk]]
[17:02:51.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.491]                     next
[17:02:51.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.491]                 }
[17:02:51.491]                 if (length(args) > 0) 
[17:02:51.491]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.491]             }
[17:02:51.491]             else {
[17:02:51.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.491]             }
[17:02:51.491]             {
[17:02:51.491]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.491]                   0L) {
[17:02:51.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.491]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.491]                   base::options(opts)
[17:02:51.491]                 }
[17:02:51.491]                 {
[17:02:51.491]                   {
[17:02:51.491]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.491]                     NULL
[17:02:51.491]                   }
[17:02:51.491]                   options(future.plan = NULL)
[17:02:51.491]                   if (is.na(NA_character_)) 
[17:02:51.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.491]                     .init = FALSE)
[17:02:51.491]                 }
[17:02:51.491]             }
[17:02:51.491]         }
[17:02:51.491]     })
[17:02:51.491]     if (TRUE) {
[17:02:51.491]         base::sink(type = "output", split = FALSE)
[17:02:51.491]         if (TRUE) {
[17:02:51.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.491]         }
[17:02:51.491]         else {
[17:02:51.491]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.491]         }
[17:02:51.491]         base::close(...future.stdout)
[17:02:51.491]         ...future.stdout <- NULL
[17:02:51.491]     }
[17:02:51.491]     ...future.result$conditions <- ...future.conditions
[17:02:51.491]     ...future.result$finished <- base::Sys.time()
[17:02:51.491]     ...future.result
[17:02:51.491] }
[17:02:51.493] requestCore(): workers = 2
[17:02:51.496] MulticoreFuture started
[17:02:51.497] - Launch lazy future ... done
[17:02:51.497] run() for ‘MulticoreFuture’ ... done
[17:02:51.497] plan(): Setting new future strategy stack:
[17:02:51.498] result() for MulticoreFuture ...
[17:02:51.497] List of future strategies:
[17:02:51.497] 1. sequential:
[17:02:51.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.497]    - tweaked: FALSE
[17:02:51.497]    - call: NULL
[17:02:51.504] plan(): nbrOfWorkers() = 1
[17:02:51.507] plan(): Setting new future strategy stack:
[17:02:51.507] List of future strategies:
[17:02:51.507] 1. multicore:
[17:02:51.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.507]    - tweaked: FALSE
[17:02:51.507]    - call: plan(strategy)
[17:02:51.514] plan(): nbrOfWorkers() = 2
[17:02:51.520] result() for MulticoreFuture ...
[17:02:51.520] result() for MulticoreFuture ... done
[17:02:51.520] result() for MulticoreFuture ... done
[17:02:51.520] result() for MulticoreFuture ...
[17:02:51.520] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.521] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.521] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.523] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:02:51.523] Searching for globals ... DONE
[17:02:51.523] Resolving globals: TRUE
[17:02:51.523] Resolving any globals that are futures ...
[17:02:51.523] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:02:51.523] Resolving any globals that are futures ... DONE
[17:02:51.524] 
[17:02:51.524] 
[17:02:51.524] getGlobalsAndPackages() ... DONE
[17:02:51.524] run() for ‘Future’ ...
[17:02:51.524] - state: ‘created’
[17:02:51.525] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.529] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.529]   - Field: ‘label’
[17:02:51.529]   - Field: ‘local’
[17:02:51.529]   - Field: ‘owner’
[17:02:51.529]   - Field: ‘envir’
[17:02:51.529]   - Field: ‘workers’
[17:02:51.529]   - Field: ‘packages’
[17:02:51.530]   - Field: ‘gc’
[17:02:51.530]   - Field: ‘job’
[17:02:51.530]   - Field: ‘conditions’
[17:02:51.530]   - Field: ‘expr’
[17:02:51.530]   - Field: ‘uuid’
[17:02:51.530]   - Field: ‘seed’
[17:02:51.530]   - Field: ‘version’
[17:02:51.530]   - Field: ‘result’
[17:02:51.530]   - Field: ‘asynchronous’
[17:02:51.531]   - Field: ‘calls’
[17:02:51.531]   - Field: ‘globals’
[17:02:51.531]   - Field: ‘stdout’
[17:02:51.531]   - Field: ‘earlySignal’
[17:02:51.531]   - Field: ‘lazy’
[17:02:51.531]   - Field: ‘state’
[17:02:51.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.531] - Launch lazy future ...
[17:02:51.532] Packages needed by the future expression (n = 0): <none>
[17:02:51.532] Packages needed by future strategies (n = 0): <none>
[17:02:51.532] {
[17:02:51.532]     {
[17:02:51.532]         {
[17:02:51.532]             ...future.startTime <- base::Sys.time()
[17:02:51.532]             {
[17:02:51.532]                 {
[17:02:51.532]                   {
[17:02:51.532]                     {
[17:02:51.532]                       base::local({
[17:02:51.532]                         has_future <- base::requireNamespace("future", 
[17:02:51.532]                           quietly = TRUE)
[17:02:51.532]                         if (has_future) {
[17:02:51.532]                           ns <- base::getNamespace("future")
[17:02:51.532]                           version <- ns[[".package"]][["version"]]
[17:02:51.532]                           if (is.null(version)) 
[17:02:51.532]                             version <- utils::packageVersion("future")
[17:02:51.532]                         }
[17:02:51.532]                         else {
[17:02:51.532]                           version <- NULL
[17:02:51.532]                         }
[17:02:51.532]                         if (!has_future || version < "1.8.0") {
[17:02:51.532]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.532]                             "", base::R.version$version.string), 
[17:02:51.532]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.532]                               "release", "version")], collapse = " "), 
[17:02:51.532]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.532]                             info)
[17:02:51.532]                           info <- base::paste(info, collapse = "; ")
[17:02:51.532]                           if (!has_future) {
[17:02:51.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.532]                               info)
[17:02:51.532]                           }
[17:02:51.532]                           else {
[17:02:51.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.532]                               info, version)
[17:02:51.532]                           }
[17:02:51.532]                           base::stop(msg)
[17:02:51.532]                         }
[17:02:51.532]                       })
[17:02:51.532]                     }
[17:02:51.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.532]                     base::options(mc.cores = 1L)
[17:02:51.532]                   }
[17:02:51.532]                   ...future.strategy.old <- future::plan("list")
[17:02:51.532]                   options(future.plan = NULL)
[17:02:51.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.532]                 }
[17:02:51.532]                 ...future.workdir <- getwd()
[17:02:51.532]             }
[17:02:51.532]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.532]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.532]         }
[17:02:51.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.532]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.532]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.532]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.532]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.532]             base::names(...future.oldOptions))
[17:02:51.532]     }
[17:02:51.532]     if (FALSE) {
[17:02:51.532]     }
[17:02:51.532]     else {
[17:02:51.532]         if (TRUE) {
[17:02:51.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.532]                 open = "w")
[17:02:51.532]         }
[17:02:51.532]         else {
[17:02:51.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.532]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.532]         }
[17:02:51.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.532]             base::sink(type = "output", split = FALSE)
[17:02:51.532]             base::close(...future.stdout)
[17:02:51.532]         }, add = TRUE)
[17:02:51.532]     }
[17:02:51.532]     ...future.frame <- base::sys.nframe()
[17:02:51.532]     ...future.conditions <- base::list()
[17:02:51.532]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.532]     if (FALSE) {
[17:02:51.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.532]     }
[17:02:51.532]     ...future.result <- base::tryCatch({
[17:02:51.532]         base::withCallingHandlers({
[17:02:51.532]             ...future.value <- base::withVisible(base::local({
[17:02:51.532]                 withCallingHandlers({
[17:02:51.532]                   {
[17:02:51.532]                     b <- a
[17:02:51.532]                     a <- 2
[17:02:51.532]                     a * b
[17:02:51.532]                   }
[17:02:51.532]                 }, immediateCondition = function(cond) {
[17:02:51.532]                   save_rds <- function (object, pathname, ...) 
[17:02:51.532]                   {
[17:02:51.532]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.532]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.532]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.532]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.532]                         fi_tmp[["mtime"]])
[17:02:51.532]                     }
[17:02:51.532]                     tryCatch({
[17:02:51.532]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.532]                     }, error = function(ex) {
[17:02:51.532]                       msg <- conditionMessage(ex)
[17:02:51.532]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.532]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.532]                         fi_tmp[["mtime"]], msg)
[17:02:51.532]                       ex$message <- msg
[17:02:51.532]                       stop(ex)
[17:02:51.532]                     })
[17:02:51.532]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.532]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.532]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.532]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.532]                       fi <- file.info(pathname)
[17:02:51.532]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.532]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.532]                         fi[["size"]], fi[["mtime"]])
[17:02:51.532]                       stop(msg)
[17:02:51.532]                     }
[17:02:51.532]                     invisible(pathname)
[17:02:51.532]                   }
[17:02:51.532]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.532]                     rootPath = tempdir()) 
[17:02:51.532]                   {
[17:02:51.532]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.532]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.532]                       tmpdir = path, fileext = ".rds")
[17:02:51.532]                     save_rds(obj, file)
[17:02:51.532]                   }
[17:02:51.532]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.532]                   {
[17:02:51.532]                     inherits <- base::inherits
[17:02:51.532]                     invokeRestart <- base::invokeRestart
[17:02:51.532]                     is.null <- base::is.null
[17:02:51.532]                     muffled <- FALSE
[17:02:51.532]                     if (inherits(cond, "message")) {
[17:02:51.532]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.532]                       if (muffled) 
[17:02:51.532]                         invokeRestart("muffleMessage")
[17:02:51.532]                     }
[17:02:51.532]                     else if (inherits(cond, "warning")) {
[17:02:51.532]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.532]                       if (muffled) 
[17:02:51.532]                         invokeRestart("muffleWarning")
[17:02:51.532]                     }
[17:02:51.532]                     else if (inherits(cond, "condition")) {
[17:02:51.532]                       if (!is.null(pattern)) {
[17:02:51.532]                         computeRestarts <- base::computeRestarts
[17:02:51.532]                         grepl <- base::grepl
[17:02:51.532]                         restarts <- computeRestarts(cond)
[17:02:51.532]                         for (restart in restarts) {
[17:02:51.532]                           name <- restart$name
[17:02:51.532]                           if (is.null(name)) 
[17:02:51.532]                             next
[17:02:51.532]                           if (!grepl(pattern, name)) 
[17:02:51.532]                             next
[17:02:51.532]                           invokeRestart(restart)
[17:02:51.532]                           muffled <- TRUE
[17:02:51.532]                           break
[17:02:51.532]                         }
[17:02:51.532]                       }
[17:02:51.532]                     }
[17:02:51.532]                     invisible(muffled)
[17:02:51.532]                   }
[17:02:51.532]                   muffleCondition(cond)
[17:02:51.532]                 })
[17:02:51.532]             }))
[17:02:51.532]             future::FutureResult(value = ...future.value$value, 
[17:02:51.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.532]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.532]                     ...future.globalenv.names))
[17:02:51.532]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.532]         }, condition = base::local({
[17:02:51.532]             c <- base::c
[17:02:51.532]             inherits <- base::inherits
[17:02:51.532]             invokeRestart <- base::invokeRestart
[17:02:51.532]             length <- base::length
[17:02:51.532]             list <- base::list
[17:02:51.532]             seq.int <- base::seq.int
[17:02:51.532]             signalCondition <- base::signalCondition
[17:02:51.532]             sys.calls <- base::sys.calls
[17:02:51.532]             `[[` <- base::`[[`
[17:02:51.532]             `+` <- base::`+`
[17:02:51.532]             `<<-` <- base::`<<-`
[17:02:51.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.532]                   3L)]
[17:02:51.532]             }
[17:02:51.532]             function(cond) {
[17:02:51.532]                 is_error <- inherits(cond, "error")
[17:02:51.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.532]                   NULL)
[17:02:51.532]                 if (is_error) {
[17:02:51.532]                   sessionInformation <- function() {
[17:02:51.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.532]                       search = base::search(), system = base::Sys.info())
[17:02:51.532]                   }
[17:02:51.532]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.532]                     cond$call), session = sessionInformation(), 
[17:02:51.532]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.532]                   signalCondition(cond)
[17:02:51.532]                 }
[17:02:51.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.532]                 "immediateCondition"))) {
[17:02:51.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.532]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.532]                   if (TRUE && !signal) {
[17:02:51.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.532]                     {
[17:02:51.532]                       inherits <- base::inherits
[17:02:51.532]                       invokeRestart <- base::invokeRestart
[17:02:51.532]                       is.null <- base::is.null
[17:02:51.532]                       muffled <- FALSE
[17:02:51.532]                       if (inherits(cond, "message")) {
[17:02:51.532]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.532]                         if (muffled) 
[17:02:51.532]                           invokeRestart("muffleMessage")
[17:02:51.532]                       }
[17:02:51.532]                       else if (inherits(cond, "warning")) {
[17:02:51.532]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.532]                         if (muffled) 
[17:02:51.532]                           invokeRestart("muffleWarning")
[17:02:51.532]                       }
[17:02:51.532]                       else if (inherits(cond, "condition")) {
[17:02:51.532]                         if (!is.null(pattern)) {
[17:02:51.532]                           computeRestarts <- base::computeRestarts
[17:02:51.532]                           grepl <- base::grepl
[17:02:51.532]                           restarts <- computeRestarts(cond)
[17:02:51.532]                           for (restart in restarts) {
[17:02:51.532]                             name <- restart$name
[17:02:51.532]                             if (is.null(name)) 
[17:02:51.532]                               next
[17:02:51.532]                             if (!grepl(pattern, name)) 
[17:02:51.532]                               next
[17:02:51.532]                             invokeRestart(restart)
[17:02:51.532]                             muffled <- TRUE
[17:02:51.532]                             break
[17:02:51.532]                           }
[17:02:51.532]                         }
[17:02:51.532]                       }
[17:02:51.532]                       invisible(muffled)
[17:02:51.532]                     }
[17:02:51.532]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.532]                   }
[17:02:51.532]                 }
[17:02:51.532]                 else {
[17:02:51.532]                   if (TRUE) {
[17:02:51.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.532]                     {
[17:02:51.532]                       inherits <- base::inherits
[17:02:51.532]                       invokeRestart <- base::invokeRestart
[17:02:51.532]                       is.null <- base::is.null
[17:02:51.532]                       muffled <- FALSE
[17:02:51.532]                       if (inherits(cond, "message")) {
[17:02:51.532]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.532]                         if (muffled) 
[17:02:51.532]                           invokeRestart("muffleMessage")
[17:02:51.532]                       }
[17:02:51.532]                       else if (inherits(cond, "warning")) {
[17:02:51.532]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.532]                         if (muffled) 
[17:02:51.532]                           invokeRestart("muffleWarning")
[17:02:51.532]                       }
[17:02:51.532]                       else if (inherits(cond, "condition")) {
[17:02:51.532]                         if (!is.null(pattern)) {
[17:02:51.532]                           computeRestarts <- base::computeRestarts
[17:02:51.532]                           grepl <- base::grepl
[17:02:51.532]                           restarts <- computeRestarts(cond)
[17:02:51.532]                           for (restart in restarts) {
[17:02:51.532]                             name <- restart$name
[17:02:51.532]                             if (is.null(name)) 
[17:02:51.532]                               next
[17:02:51.532]                             if (!grepl(pattern, name)) 
[17:02:51.532]                               next
[17:02:51.532]                             invokeRestart(restart)
[17:02:51.532]                             muffled <- TRUE
[17:02:51.532]                             break
[17:02:51.532]                           }
[17:02:51.532]                         }
[17:02:51.532]                       }
[17:02:51.532]                       invisible(muffled)
[17:02:51.532]                     }
[17:02:51.532]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.532]                   }
[17:02:51.532]                 }
[17:02:51.532]             }
[17:02:51.532]         }))
[17:02:51.532]     }, error = function(ex) {
[17:02:51.532]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.532]                 ...future.rng), started = ...future.startTime, 
[17:02:51.532]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.532]             version = "1.8"), class = "FutureResult")
[17:02:51.532]     }, finally = {
[17:02:51.532]         if (!identical(...future.workdir, getwd())) 
[17:02:51.532]             setwd(...future.workdir)
[17:02:51.532]         {
[17:02:51.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.532]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.532]             }
[17:02:51.532]             base::options(...future.oldOptions)
[17:02:51.532]             if (.Platform$OS.type == "windows") {
[17:02:51.532]                 old_names <- names(...future.oldEnvVars)
[17:02:51.532]                 envs <- base::Sys.getenv()
[17:02:51.532]                 names <- names(envs)
[17:02:51.532]                 common <- intersect(names, old_names)
[17:02:51.532]                 added <- setdiff(names, old_names)
[17:02:51.532]                 removed <- setdiff(old_names, names)
[17:02:51.532]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.532]                   envs[common]]
[17:02:51.532]                 NAMES <- toupper(changed)
[17:02:51.532]                 args <- list()
[17:02:51.532]                 for (kk in seq_along(NAMES)) {
[17:02:51.532]                   name <- changed[[kk]]
[17:02:51.532]                   NAME <- NAMES[[kk]]
[17:02:51.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.532]                     next
[17:02:51.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.532]                 }
[17:02:51.532]                 NAMES <- toupper(added)
[17:02:51.532]                 for (kk in seq_along(NAMES)) {
[17:02:51.532]                   name <- added[[kk]]
[17:02:51.532]                   NAME <- NAMES[[kk]]
[17:02:51.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.532]                     next
[17:02:51.532]                   args[[name]] <- ""
[17:02:51.532]                 }
[17:02:51.532]                 NAMES <- toupper(removed)
[17:02:51.532]                 for (kk in seq_along(NAMES)) {
[17:02:51.532]                   name <- removed[[kk]]
[17:02:51.532]                   NAME <- NAMES[[kk]]
[17:02:51.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.532]                     next
[17:02:51.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.532]                 }
[17:02:51.532]                 if (length(args) > 0) 
[17:02:51.532]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.532]             }
[17:02:51.532]             else {
[17:02:51.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.532]             }
[17:02:51.532]             {
[17:02:51.532]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.532]                   0L) {
[17:02:51.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.532]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.532]                   base::options(opts)
[17:02:51.532]                 }
[17:02:51.532]                 {
[17:02:51.532]                   {
[17:02:51.532]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.532]                     NULL
[17:02:51.532]                   }
[17:02:51.532]                   options(future.plan = NULL)
[17:02:51.532]                   if (is.na(NA_character_)) 
[17:02:51.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.532]                     .init = FALSE)
[17:02:51.532]                 }
[17:02:51.532]             }
[17:02:51.532]         }
[17:02:51.532]     })
[17:02:51.532]     if (TRUE) {
[17:02:51.532]         base::sink(type = "output", split = FALSE)
[17:02:51.532]         if (TRUE) {
[17:02:51.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.532]         }
[17:02:51.532]         else {
[17:02:51.532]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.532]         }
[17:02:51.532]         base::close(...future.stdout)
[17:02:51.532]         ...future.stdout <- NULL
[17:02:51.532]     }
[17:02:51.532]     ...future.result$conditions <- ...future.conditions
[17:02:51.532]     ...future.result$finished <- base::Sys.time()
[17:02:51.532]     ...future.result
[17:02:51.532] }
[17:02:51.535] requestCore(): workers = 2
[17:02:51.537] MulticoreFuture started
[17:02:51.537] - Launch lazy future ... done
[17:02:51.537] run() for ‘MulticoreFuture’ ... done
[17:02:51.538] result() for MulticoreFuture ...
[17:02:51.538] plan(): Setting new future strategy stack:
[17:02:51.538] List of future strategies:
[17:02:51.538] 1. sequential:
[17:02:51.538]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.538]    - tweaked: FALSE
[17:02:51.538]    - call: NULL
[17:02:51.539] plan(): nbrOfWorkers() = 1
[17:02:51.541] plan(): Setting new future strategy stack:
[17:02:51.541] List of future strategies:
[17:02:51.541] 1. multicore:
[17:02:51.541]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.541]    - tweaked: FALSE
[17:02:51.541]    - call: plan(strategy)
[17:02:51.547] plan(): nbrOfWorkers() = 2
[17:02:51.553] result() for MulticoreFuture ...
[17:02:51.553] result() for MulticoreFuture ... done
[17:02:51.553] signalConditions() ...
[17:02:51.553]  - include = ‘immediateCondition’
[17:02:51.553]  - exclude = 
[17:02:51.553]  - resignal = FALSE
[17:02:51.554]  - Number of conditions: 1
[17:02:51.554] signalConditions() ... done
[17:02:51.554] result() for MulticoreFuture ... done
[17:02:51.554] result() for MulticoreFuture ...
[17:02:51.554] result() for MulticoreFuture ... done
[17:02:51.554] signalConditions() ...
[17:02:51.554]  - include = ‘immediateCondition’
[17:02:51.554]  - exclude = 
[17:02:51.555]  - resignal = FALSE
[17:02:51.555]  - Number of conditions: 1
[17:02:51.555] signalConditions() ... done
[17:02:51.555] Future state: ‘finished’
[17:02:51.555] result() for MulticoreFuture ...
[17:02:51.555] result() for MulticoreFuture ... done
[17:02:51.555] signalConditions() ...
[17:02:51.555]  - include = ‘condition’
[17:02:51.556]  - exclude = ‘immediateCondition’
[17:02:51.556]  - resignal = TRUE
[17:02:51.556]  - Number of conditions: 1
[17:02:51.556]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:51.556] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.585] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.585] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.587] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.587] Searching for globals ... DONE
[17:02:51.587] Resolving globals: TRUE
[17:02:51.587] Resolving any globals that are futures ...
[17:02:51.587] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.587] Resolving any globals that are futures ... DONE
[17:02:51.588] Resolving futures part of globals (recursively) ...
[17:02:51.588] resolve() on list ...
[17:02:51.588]  recursive: 99
[17:02:51.588]  length: 1
[17:02:51.588]  elements: ‘ii’
[17:02:51.589]  length: 0 (resolved future 1)
[17:02:51.589] resolve() on list ... DONE
[17:02:51.589] - globals: [1] ‘ii’
[17:02:51.589] Resolving futures part of globals (recursively) ... DONE
[17:02:51.589] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.589] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.589] - globals: [1] ‘ii’
[17:02:51.590] 
[17:02:51.590] getGlobalsAndPackages() ... DONE
[17:02:51.590] run() for ‘Future’ ...
[17:02:51.590] - state: ‘created’
[17:02:51.590] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.594] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.595]   - Field: ‘label’
[17:02:51.595]   - Field: ‘local’
[17:02:51.595]   - Field: ‘owner’
[17:02:51.595]   - Field: ‘envir’
[17:02:51.595]   - Field: ‘workers’
[17:02:51.597]   - Field: ‘packages’
[17:02:51.597]   - Field: ‘gc’
[17:02:51.597]   - Field: ‘job’
[17:02:51.597]   - Field: ‘conditions’
[17:02:51.597]   - Field: ‘expr’
[17:02:51.598]   - Field: ‘uuid’
[17:02:51.598]   - Field: ‘seed’
[17:02:51.598]   - Field: ‘version’
[17:02:51.598]   - Field: ‘result’
[17:02:51.598]   - Field: ‘asynchronous’
[17:02:51.598]   - Field: ‘calls’
[17:02:51.598]   - Field: ‘globals’
[17:02:51.598]   - Field: ‘stdout’
[17:02:51.598]   - Field: ‘earlySignal’
[17:02:51.599]   - Field: ‘lazy’
[17:02:51.599]   - Field: ‘state’
[17:02:51.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.599] - Launch lazy future ...
[17:02:51.599] Packages needed by the future expression (n = 0): <none>
[17:02:51.599] Packages needed by future strategies (n = 0): <none>
[17:02:51.600] {
[17:02:51.600]     {
[17:02:51.600]         {
[17:02:51.600]             ...future.startTime <- base::Sys.time()
[17:02:51.600]             {
[17:02:51.600]                 {
[17:02:51.600]                   {
[17:02:51.600]                     {
[17:02:51.600]                       base::local({
[17:02:51.600]                         has_future <- base::requireNamespace("future", 
[17:02:51.600]                           quietly = TRUE)
[17:02:51.600]                         if (has_future) {
[17:02:51.600]                           ns <- base::getNamespace("future")
[17:02:51.600]                           version <- ns[[".package"]][["version"]]
[17:02:51.600]                           if (is.null(version)) 
[17:02:51.600]                             version <- utils::packageVersion("future")
[17:02:51.600]                         }
[17:02:51.600]                         else {
[17:02:51.600]                           version <- NULL
[17:02:51.600]                         }
[17:02:51.600]                         if (!has_future || version < "1.8.0") {
[17:02:51.600]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.600]                             "", base::R.version$version.string), 
[17:02:51.600]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.600]                               "release", "version")], collapse = " "), 
[17:02:51.600]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.600]                             info)
[17:02:51.600]                           info <- base::paste(info, collapse = "; ")
[17:02:51.600]                           if (!has_future) {
[17:02:51.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.600]                               info)
[17:02:51.600]                           }
[17:02:51.600]                           else {
[17:02:51.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.600]                               info, version)
[17:02:51.600]                           }
[17:02:51.600]                           base::stop(msg)
[17:02:51.600]                         }
[17:02:51.600]                       })
[17:02:51.600]                     }
[17:02:51.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.600]                     base::options(mc.cores = 1L)
[17:02:51.600]                   }
[17:02:51.600]                   ...future.strategy.old <- future::plan("list")
[17:02:51.600]                   options(future.plan = NULL)
[17:02:51.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.600]                 }
[17:02:51.600]                 ...future.workdir <- getwd()
[17:02:51.600]             }
[17:02:51.600]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.600]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.600]         }
[17:02:51.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.600]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.600]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.600]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.600]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.600]             base::names(...future.oldOptions))
[17:02:51.600]     }
[17:02:51.600]     if (FALSE) {
[17:02:51.600]     }
[17:02:51.600]     else {
[17:02:51.600]         if (TRUE) {
[17:02:51.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.600]                 open = "w")
[17:02:51.600]         }
[17:02:51.600]         else {
[17:02:51.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.600]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.600]         }
[17:02:51.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.600]             base::sink(type = "output", split = FALSE)
[17:02:51.600]             base::close(...future.stdout)
[17:02:51.600]         }, add = TRUE)
[17:02:51.600]     }
[17:02:51.600]     ...future.frame <- base::sys.nframe()
[17:02:51.600]     ...future.conditions <- base::list()
[17:02:51.600]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.600]     if (FALSE) {
[17:02:51.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.600]     }
[17:02:51.600]     ...future.result <- base::tryCatch({
[17:02:51.600]         base::withCallingHandlers({
[17:02:51.600]             ...future.value <- base::withVisible(base::local({
[17:02:51.600]                 withCallingHandlers({
[17:02:51.600]                   {
[17:02:51.600]                     b <- a * ii
[17:02:51.600]                     a <- 0
[17:02:51.600]                     b
[17:02:51.600]                   }
[17:02:51.600]                 }, immediateCondition = function(cond) {
[17:02:51.600]                   save_rds <- function (object, pathname, ...) 
[17:02:51.600]                   {
[17:02:51.600]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.600]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.600]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.600]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.600]                         fi_tmp[["mtime"]])
[17:02:51.600]                     }
[17:02:51.600]                     tryCatch({
[17:02:51.600]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.600]                     }, error = function(ex) {
[17:02:51.600]                       msg <- conditionMessage(ex)
[17:02:51.600]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.600]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.600]                         fi_tmp[["mtime"]], msg)
[17:02:51.600]                       ex$message <- msg
[17:02:51.600]                       stop(ex)
[17:02:51.600]                     })
[17:02:51.600]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.600]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.600]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.600]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.600]                       fi <- file.info(pathname)
[17:02:51.600]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.600]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.600]                         fi[["size"]], fi[["mtime"]])
[17:02:51.600]                       stop(msg)
[17:02:51.600]                     }
[17:02:51.600]                     invisible(pathname)
[17:02:51.600]                   }
[17:02:51.600]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.600]                     rootPath = tempdir()) 
[17:02:51.600]                   {
[17:02:51.600]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.600]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.600]                       tmpdir = path, fileext = ".rds")
[17:02:51.600]                     save_rds(obj, file)
[17:02:51.600]                   }
[17:02:51.600]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.600]                   {
[17:02:51.600]                     inherits <- base::inherits
[17:02:51.600]                     invokeRestart <- base::invokeRestart
[17:02:51.600]                     is.null <- base::is.null
[17:02:51.600]                     muffled <- FALSE
[17:02:51.600]                     if (inherits(cond, "message")) {
[17:02:51.600]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.600]                       if (muffled) 
[17:02:51.600]                         invokeRestart("muffleMessage")
[17:02:51.600]                     }
[17:02:51.600]                     else if (inherits(cond, "warning")) {
[17:02:51.600]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.600]                       if (muffled) 
[17:02:51.600]                         invokeRestart("muffleWarning")
[17:02:51.600]                     }
[17:02:51.600]                     else if (inherits(cond, "condition")) {
[17:02:51.600]                       if (!is.null(pattern)) {
[17:02:51.600]                         computeRestarts <- base::computeRestarts
[17:02:51.600]                         grepl <- base::grepl
[17:02:51.600]                         restarts <- computeRestarts(cond)
[17:02:51.600]                         for (restart in restarts) {
[17:02:51.600]                           name <- restart$name
[17:02:51.600]                           if (is.null(name)) 
[17:02:51.600]                             next
[17:02:51.600]                           if (!grepl(pattern, name)) 
[17:02:51.600]                             next
[17:02:51.600]                           invokeRestart(restart)
[17:02:51.600]                           muffled <- TRUE
[17:02:51.600]                           break
[17:02:51.600]                         }
[17:02:51.600]                       }
[17:02:51.600]                     }
[17:02:51.600]                     invisible(muffled)
[17:02:51.600]                   }
[17:02:51.600]                   muffleCondition(cond)
[17:02:51.600]                 })
[17:02:51.600]             }))
[17:02:51.600]             future::FutureResult(value = ...future.value$value, 
[17:02:51.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.600]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.600]                     ...future.globalenv.names))
[17:02:51.600]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.600]         }, condition = base::local({
[17:02:51.600]             c <- base::c
[17:02:51.600]             inherits <- base::inherits
[17:02:51.600]             invokeRestart <- base::invokeRestart
[17:02:51.600]             length <- base::length
[17:02:51.600]             list <- base::list
[17:02:51.600]             seq.int <- base::seq.int
[17:02:51.600]             signalCondition <- base::signalCondition
[17:02:51.600]             sys.calls <- base::sys.calls
[17:02:51.600]             `[[` <- base::`[[`
[17:02:51.600]             `+` <- base::`+`
[17:02:51.600]             `<<-` <- base::`<<-`
[17:02:51.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.600]                   3L)]
[17:02:51.600]             }
[17:02:51.600]             function(cond) {
[17:02:51.600]                 is_error <- inherits(cond, "error")
[17:02:51.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.600]                   NULL)
[17:02:51.600]                 if (is_error) {
[17:02:51.600]                   sessionInformation <- function() {
[17:02:51.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.600]                       search = base::search(), system = base::Sys.info())
[17:02:51.600]                   }
[17:02:51.600]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.600]                     cond$call), session = sessionInformation(), 
[17:02:51.600]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.600]                   signalCondition(cond)
[17:02:51.600]                 }
[17:02:51.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.600]                 "immediateCondition"))) {
[17:02:51.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.600]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.600]                   if (TRUE && !signal) {
[17:02:51.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.600]                     {
[17:02:51.600]                       inherits <- base::inherits
[17:02:51.600]                       invokeRestart <- base::invokeRestart
[17:02:51.600]                       is.null <- base::is.null
[17:02:51.600]                       muffled <- FALSE
[17:02:51.600]                       if (inherits(cond, "message")) {
[17:02:51.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.600]                         if (muffled) 
[17:02:51.600]                           invokeRestart("muffleMessage")
[17:02:51.600]                       }
[17:02:51.600]                       else if (inherits(cond, "warning")) {
[17:02:51.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.600]                         if (muffled) 
[17:02:51.600]                           invokeRestart("muffleWarning")
[17:02:51.600]                       }
[17:02:51.600]                       else if (inherits(cond, "condition")) {
[17:02:51.600]                         if (!is.null(pattern)) {
[17:02:51.600]                           computeRestarts <- base::computeRestarts
[17:02:51.600]                           grepl <- base::grepl
[17:02:51.600]                           restarts <- computeRestarts(cond)
[17:02:51.600]                           for (restart in restarts) {
[17:02:51.600]                             name <- restart$name
[17:02:51.600]                             if (is.null(name)) 
[17:02:51.600]                               next
[17:02:51.600]                             if (!grepl(pattern, name)) 
[17:02:51.600]                               next
[17:02:51.600]                             invokeRestart(restart)
[17:02:51.600]                             muffled <- TRUE
[17:02:51.600]                             break
[17:02:51.600]                           }
[17:02:51.600]                         }
[17:02:51.600]                       }
[17:02:51.600]                       invisible(muffled)
[17:02:51.600]                     }
[17:02:51.600]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.600]                   }
[17:02:51.600]                 }
[17:02:51.600]                 else {
[17:02:51.600]                   if (TRUE) {
[17:02:51.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.600]                     {
[17:02:51.600]                       inherits <- base::inherits
[17:02:51.600]                       invokeRestart <- base::invokeRestart
[17:02:51.600]                       is.null <- base::is.null
[17:02:51.600]                       muffled <- FALSE
[17:02:51.600]                       if (inherits(cond, "message")) {
[17:02:51.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.600]                         if (muffled) 
[17:02:51.600]                           invokeRestart("muffleMessage")
[17:02:51.600]                       }
[17:02:51.600]                       else if (inherits(cond, "warning")) {
[17:02:51.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.600]                         if (muffled) 
[17:02:51.600]                           invokeRestart("muffleWarning")
[17:02:51.600]                       }
[17:02:51.600]                       else if (inherits(cond, "condition")) {
[17:02:51.600]                         if (!is.null(pattern)) {
[17:02:51.600]                           computeRestarts <- base::computeRestarts
[17:02:51.600]                           grepl <- base::grepl
[17:02:51.600]                           restarts <- computeRestarts(cond)
[17:02:51.600]                           for (restart in restarts) {
[17:02:51.600]                             name <- restart$name
[17:02:51.600]                             if (is.null(name)) 
[17:02:51.600]                               next
[17:02:51.600]                             if (!grepl(pattern, name)) 
[17:02:51.600]                               next
[17:02:51.600]                             invokeRestart(restart)
[17:02:51.600]                             muffled <- TRUE
[17:02:51.600]                             break
[17:02:51.600]                           }
[17:02:51.600]                         }
[17:02:51.600]                       }
[17:02:51.600]                       invisible(muffled)
[17:02:51.600]                     }
[17:02:51.600]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.600]                   }
[17:02:51.600]                 }
[17:02:51.600]             }
[17:02:51.600]         }))
[17:02:51.600]     }, error = function(ex) {
[17:02:51.600]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.600]                 ...future.rng), started = ...future.startTime, 
[17:02:51.600]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.600]             version = "1.8"), class = "FutureResult")
[17:02:51.600]     }, finally = {
[17:02:51.600]         if (!identical(...future.workdir, getwd())) 
[17:02:51.600]             setwd(...future.workdir)
[17:02:51.600]         {
[17:02:51.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.600]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.600]             }
[17:02:51.600]             base::options(...future.oldOptions)
[17:02:51.600]             if (.Platform$OS.type == "windows") {
[17:02:51.600]                 old_names <- names(...future.oldEnvVars)
[17:02:51.600]                 envs <- base::Sys.getenv()
[17:02:51.600]                 names <- names(envs)
[17:02:51.600]                 common <- intersect(names, old_names)
[17:02:51.600]                 added <- setdiff(names, old_names)
[17:02:51.600]                 removed <- setdiff(old_names, names)
[17:02:51.600]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.600]                   envs[common]]
[17:02:51.600]                 NAMES <- toupper(changed)
[17:02:51.600]                 args <- list()
[17:02:51.600]                 for (kk in seq_along(NAMES)) {
[17:02:51.600]                   name <- changed[[kk]]
[17:02:51.600]                   NAME <- NAMES[[kk]]
[17:02:51.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.600]                     next
[17:02:51.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.600]                 }
[17:02:51.600]                 NAMES <- toupper(added)
[17:02:51.600]                 for (kk in seq_along(NAMES)) {
[17:02:51.600]                   name <- added[[kk]]
[17:02:51.600]                   NAME <- NAMES[[kk]]
[17:02:51.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.600]                     next
[17:02:51.600]                   args[[name]] <- ""
[17:02:51.600]                 }
[17:02:51.600]                 NAMES <- toupper(removed)
[17:02:51.600]                 for (kk in seq_along(NAMES)) {
[17:02:51.600]                   name <- removed[[kk]]
[17:02:51.600]                   NAME <- NAMES[[kk]]
[17:02:51.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.600]                     next
[17:02:51.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.600]                 }
[17:02:51.600]                 if (length(args) > 0) 
[17:02:51.600]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.600]             }
[17:02:51.600]             else {
[17:02:51.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.600]             }
[17:02:51.600]             {
[17:02:51.600]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.600]                   0L) {
[17:02:51.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.600]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.600]                   base::options(opts)
[17:02:51.600]                 }
[17:02:51.600]                 {
[17:02:51.600]                   {
[17:02:51.600]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.600]                     NULL
[17:02:51.600]                   }
[17:02:51.600]                   options(future.plan = NULL)
[17:02:51.600]                   if (is.na(NA_character_)) 
[17:02:51.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.600]                     .init = FALSE)
[17:02:51.600]                 }
[17:02:51.600]             }
[17:02:51.600]         }
[17:02:51.600]     })
[17:02:51.600]     if (TRUE) {
[17:02:51.600]         base::sink(type = "output", split = FALSE)
[17:02:51.600]         if (TRUE) {
[17:02:51.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.600]         }
[17:02:51.600]         else {
[17:02:51.600]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.600]         }
[17:02:51.600]         base::close(...future.stdout)
[17:02:51.600]         ...future.stdout <- NULL
[17:02:51.600]     }
[17:02:51.600]     ...future.result$conditions <- ...future.conditions
[17:02:51.600]     ...future.result$finished <- base::Sys.time()
[17:02:51.600]     ...future.result
[17:02:51.600] }
[17:02:51.602] assign_globals() ...
[17:02:51.602] List of 1
[17:02:51.602]  $ ii: int 1
[17:02:51.602]  - attr(*, "where")=List of 1
[17:02:51.602]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.602]  - attr(*, "resolved")= logi TRUE
[17:02:51.602]  - attr(*, "total_size")= num 56
[17:02:51.602]  - attr(*, "already-done")= logi TRUE
[17:02:51.605] - copied ‘ii’ to environment
[17:02:51.605] assign_globals() ... done
[17:02:51.605] requestCore(): workers = 2
[17:02:51.607] MulticoreFuture started
[17:02:51.608] - Launch lazy future ... done
[17:02:51.608] run() for ‘MulticoreFuture’ ... done
[17:02:51.608] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.609] getGlobalsAndPackages() ...
[17:02:51.609] List of future strategies:
[17:02:51.609] 1. sequential:
[17:02:51.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.609]    - tweaked: FALSE
[17:02:51.609]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.610] plan(): nbrOfWorkers() = 1
[17:02:51.610] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.612] plan(): Setting new future strategy stack:
[17:02:51.612] List of future strategies:
[17:02:51.612] 1. multicore:
[17:02:51.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.612]    - tweaked: FALSE
[17:02:51.612]    - call: plan(strategy)
[17:02:51.613] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.613] Searching for globals ... DONE
[17:02:51.613] Resolving globals: TRUE
[17:02:51.613] Resolving any globals that are futures ...
[17:02:51.613] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.613] Resolving any globals that are futures ... DONE
[17:02:51.614] Resolving futures part of globals (recursively) ...
[17:02:51.615] resolve() on list ...
[17:02:51.615]  recursive: 99
[17:02:51.615]  length: 1
[17:02:51.616]  elements: ‘ii’
[17:02:51.616]  length: 0 (resolved future 1)
[17:02:51.616] resolve() on list ... DONE
[17:02:51.616] - globals: [1] ‘ii’
[17:02:51.616] Resolving futures part of globals (recursively) ... DONE
[17:02:51.617] plan(): nbrOfWorkers() = 2
[17:02:51.617] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.617] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.618] - globals: [1] ‘ii’
[17:02:51.618] 
[17:02:51.618] getGlobalsAndPackages() ... DONE
[17:02:51.619] run() for ‘Future’ ...
[17:02:51.619] - state: ‘created’
[17:02:51.619] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.623] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.624]   - Field: ‘label’
[17:02:51.624]   - Field: ‘local’
[17:02:51.624]   - Field: ‘owner’
[17:02:51.624]   - Field: ‘envir’
[17:02:51.624]   - Field: ‘workers’
[17:02:51.625]   - Field: ‘packages’
[17:02:51.625]   - Field: ‘gc’
[17:02:51.625]   - Field: ‘job’
[17:02:51.625]   - Field: ‘conditions’
[17:02:51.625]   - Field: ‘expr’
[17:02:51.625]   - Field: ‘uuid’
[17:02:51.625]   - Field: ‘seed’
[17:02:51.626]   - Field: ‘version’
[17:02:51.626]   - Field: ‘result’
[17:02:51.626]   - Field: ‘asynchronous’
[17:02:51.626]   - Field: ‘calls’
[17:02:51.626]   - Field: ‘globals’
[17:02:51.626]   - Field: ‘stdout’
[17:02:51.626]   - Field: ‘earlySignal’
[17:02:51.626]   - Field: ‘lazy’
[17:02:51.627]   - Field: ‘state’
[17:02:51.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.627] - Launch lazy future ...
[17:02:51.627] Packages needed by the future expression (n = 0): <none>
[17:02:51.628] Packages needed by future strategies (n = 0): <none>
[17:02:51.628] {
[17:02:51.628]     {
[17:02:51.628]         {
[17:02:51.628]             ...future.startTime <- base::Sys.time()
[17:02:51.628]             {
[17:02:51.628]                 {
[17:02:51.628]                   {
[17:02:51.628]                     {
[17:02:51.628]                       base::local({
[17:02:51.628]                         has_future <- base::requireNamespace("future", 
[17:02:51.628]                           quietly = TRUE)
[17:02:51.628]                         if (has_future) {
[17:02:51.628]                           ns <- base::getNamespace("future")
[17:02:51.628]                           version <- ns[[".package"]][["version"]]
[17:02:51.628]                           if (is.null(version)) 
[17:02:51.628]                             version <- utils::packageVersion("future")
[17:02:51.628]                         }
[17:02:51.628]                         else {
[17:02:51.628]                           version <- NULL
[17:02:51.628]                         }
[17:02:51.628]                         if (!has_future || version < "1.8.0") {
[17:02:51.628]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.628]                             "", base::R.version$version.string), 
[17:02:51.628]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.628]                               "release", "version")], collapse = " "), 
[17:02:51.628]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.628]                             info)
[17:02:51.628]                           info <- base::paste(info, collapse = "; ")
[17:02:51.628]                           if (!has_future) {
[17:02:51.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.628]                               info)
[17:02:51.628]                           }
[17:02:51.628]                           else {
[17:02:51.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.628]                               info, version)
[17:02:51.628]                           }
[17:02:51.628]                           base::stop(msg)
[17:02:51.628]                         }
[17:02:51.628]                       })
[17:02:51.628]                     }
[17:02:51.628]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.628]                     base::options(mc.cores = 1L)
[17:02:51.628]                   }
[17:02:51.628]                   ...future.strategy.old <- future::plan("list")
[17:02:51.628]                   options(future.plan = NULL)
[17:02:51.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.628]                 }
[17:02:51.628]                 ...future.workdir <- getwd()
[17:02:51.628]             }
[17:02:51.628]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.628]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.628]         }
[17:02:51.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.628]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.628]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.628]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.628]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.628]             base::names(...future.oldOptions))
[17:02:51.628]     }
[17:02:51.628]     if (FALSE) {
[17:02:51.628]     }
[17:02:51.628]     else {
[17:02:51.628]         if (TRUE) {
[17:02:51.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.628]                 open = "w")
[17:02:51.628]         }
[17:02:51.628]         else {
[17:02:51.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.628]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.628]         }
[17:02:51.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.628]             base::sink(type = "output", split = FALSE)
[17:02:51.628]             base::close(...future.stdout)
[17:02:51.628]         }, add = TRUE)
[17:02:51.628]     }
[17:02:51.628]     ...future.frame <- base::sys.nframe()
[17:02:51.628]     ...future.conditions <- base::list()
[17:02:51.628]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.628]     if (FALSE) {
[17:02:51.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.628]     }
[17:02:51.628]     ...future.result <- base::tryCatch({
[17:02:51.628]         base::withCallingHandlers({
[17:02:51.628]             ...future.value <- base::withVisible(base::local({
[17:02:51.628]                 withCallingHandlers({
[17:02:51.628]                   {
[17:02:51.628]                     b <- a * ii
[17:02:51.628]                     a <- 0
[17:02:51.628]                     b
[17:02:51.628]                   }
[17:02:51.628]                 }, immediateCondition = function(cond) {
[17:02:51.628]                   save_rds <- function (object, pathname, ...) 
[17:02:51.628]                   {
[17:02:51.628]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.628]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.628]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.628]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.628]                         fi_tmp[["mtime"]])
[17:02:51.628]                     }
[17:02:51.628]                     tryCatch({
[17:02:51.628]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.628]                     }, error = function(ex) {
[17:02:51.628]                       msg <- conditionMessage(ex)
[17:02:51.628]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.628]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.628]                         fi_tmp[["mtime"]], msg)
[17:02:51.628]                       ex$message <- msg
[17:02:51.628]                       stop(ex)
[17:02:51.628]                     })
[17:02:51.628]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.628]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.628]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.628]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.628]                       fi <- file.info(pathname)
[17:02:51.628]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.628]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.628]                         fi[["size"]], fi[["mtime"]])
[17:02:51.628]                       stop(msg)
[17:02:51.628]                     }
[17:02:51.628]                     invisible(pathname)
[17:02:51.628]                   }
[17:02:51.628]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.628]                     rootPath = tempdir()) 
[17:02:51.628]                   {
[17:02:51.628]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.628]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.628]                       tmpdir = path, fileext = ".rds")
[17:02:51.628]                     save_rds(obj, file)
[17:02:51.628]                   }
[17:02:51.628]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.628]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.628]                   {
[17:02:51.628]                     inherits <- base::inherits
[17:02:51.628]                     invokeRestart <- base::invokeRestart
[17:02:51.628]                     is.null <- base::is.null
[17:02:51.628]                     muffled <- FALSE
[17:02:51.628]                     if (inherits(cond, "message")) {
[17:02:51.628]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.628]                       if (muffled) 
[17:02:51.628]                         invokeRestart("muffleMessage")
[17:02:51.628]                     }
[17:02:51.628]                     else if (inherits(cond, "warning")) {
[17:02:51.628]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.628]                       if (muffled) 
[17:02:51.628]                         invokeRestart("muffleWarning")
[17:02:51.628]                     }
[17:02:51.628]                     else if (inherits(cond, "condition")) {
[17:02:51.628]                       if (!is.null(pattern)) {
[17:02:51.628]                         computeRestarts <- base::computeRestarts
[17:02:51.628]                         grepl <- base::grepl
[17:02:51.628]                         restarts <- computeRestarts(cond)
[17:02:51.628]                         for (restart in restarts) {
[17:02:51.628]                           name <- restart$name
[17:02:51.628]                           if (is.null(name)) 
[17:02:51.628]                             next
[17:02:51.628]                           if (!grepl(pattern, name)) 
[17:02:51.628]                             next
[17:02:51.628]                           invokeRestart(restart)
[17:02:51.628]                           muffled <- TRUE
[17:02:51.628]                           break
[17:02:51.628]                         }
[17:02:51.628]                       }
[17:02:51.628]                     }
[17:02:51.628]                     invisible(muffled)
[17:02:51.628]                   }
[17:02:51.628]                   muffleCondition(cond)
[17:02:51.628]                 })
[17:02:51.628]             }))
[17:02:51.628]             future::FutureResult(value = ...future.value$value, 
[17:02:51.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.628]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.628]                     ...future.globalenv.names))
[17:02:51.628]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.628]         }, condition = base::local({
[17:02:51.628]             c <- base::c
[17:02:51.628]             inherits <- base::inherits
[17:02:51.628]             invokeRestart <- base::invokeRestart
[17:02:51.628]             length <- base::length
[17:02:51.628]             list <- base::list
[17:02:51.628]             seq.int <- base::seq.int
[17:02:51.628]             signalCondition <- base::signalCondition
[17:02:51.628]             sys.calls <- base::sys.calls
[17:02:51.628]             `[[` <- base::`[[`
[17:02:51.628]             `+` <- base::`+`
[17:02:51.628]             `<<-` <- base::`<<-`
[17:02:51.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.628]                   3L)]
[17:02:51.628]             }
[17:02:51.628]             function(cond) {
[17:02:51.628]                 is_error <- inherits(cond, "error")
[17:02:51.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.628]                   NULL)
[17:02:51.628]                 if (is_error) {
[17:02:51.628]                   sessionInformation <- function() {
[17:02:51.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.628]                       search = base::search(), system = base::Sys.info())
[17:02:51.628]                   }
[17:02:51.628]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.628]                     cond$call), session = sessionInformation(), 
[17:02:51.628]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.628]                   signalCondition(cond)
[17:02:51.628]                 }
[17:02:51.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.628]                 "immediateCondition"))) {
[17:02:51.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.628]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.628]                   if (TRUE && !signal) {
[17:02:51.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.628]                     {
[17:02:51.628]                       inherits <- base::inherits
[17:02:51.628]                       invokeRestart <- base::invokeRestart
[17:02:51.628]                       is.null <- base::is.null
[17:02:51.628]                       muffled <- FALSE
[17:02:51.628]                       if (inherits(cond, "message")) {
[17:02:51.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.628]                         if (muffled) 
[17:02:51.628]                           invokeRestart("muffleMessage")
[17:02:51.628]                       }
[17:02:51.628]                       else if (inherits(cond, "warning")) {
[17:02:51.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.628]                         if (muffled) 
[17:02:51.628]                           invokeRestart("muffleWarning")
[17:02:51.628]                       }
[17:02:51.628]                       else if (inherits(cond, "condition")) {
[17:02:51.628]                         if (!is.null(pattern)) {
[17:02:51.628]                           computeRestarts <- base::computeRestarts
[17:02:51.628]                           grepl <- base::grepl
[17:02:51.628]                           restarts <- computeRestarts(cond)
[17:02:51.628]                           for (restart in restarts) {
[17:02:51.628]                             name <- restart$name
[17:02:51.628]                             if (is.null(name)) 
[17:02:51.628]                               next
[17:02:51.628]                             if (!grepl(pattern, name)) 
[17:02:51.628]                               next
[17:02:51.628]                             invokeRestart(restart)
[17:02:51.628]                             muffled <- TRUE
[17:02:51.628]                             break
[17:02:51.628]                           }
[17:02:51.628]                         }
[17:02:51.628]                       }
[17:02:51.628]                       invisible(muffled)
[17:02:51.628]                     }
[17:02:51.628]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.628]                   }
[17:02:51.628]                 }
[17:02:51.628]                 else {
[17:02:51.628]                   if (TRUE) {
[17:02:51.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.628]                     {
[17:02:51.628]                       inherits <- base::inherits
[17:02:51.628]                       invokeRestart <- base::invokeRestart
[17:02:51.628]                       is.null <- base::is.null
[17:02:51.628]                       muffled <- FALSE
[17:02:51.628]                       if (inherits(cond, "message")) {
[17:02:51.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.628]                         if (muffled) 
[17:02:51.628]                           invokeRestart("muffleMessage")
[17:02:51.628]                       }
[17:02:51.628]                       else if (inherits(cond, "warning")) {
[17:02:51.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.628]                         if (muffled) 
[17:02:51.628]                           invokeRestart("muffleWarning")
[17:02:51.628]                       }
[17:02:51.628]                       else if (inherits(cond, "condition")) {
[17:02:51.628]                         if (!is.null(pattern)) {
[17:02:51.628]                           computeRestarts <- base::computeRestarts
[17:02:51.628]                           grepl <- base::grepl
[17:02:51.628]                           restarts <- computeRestarts(cond)
[17:02:51.628]                           for (restart in restarts) {
[17:02:51.628]                             name <- restart$name
[17:02:51.628]                             if (is.null(name)) 
[17:02:51.628]                               next
[17:02:51.628]                             if (!grepl(pattern, name)) 
[17:02:51.628]                               next
[17:02:51.628]                             invokeRestart(restart)
[17:02:51.628]                             muffled <- TRUE
[17:02:51.628]                             break
[17:02:51.628]                           }
[17:02:51.628]                         }
[17:02:51.628]                       }
[17:02:51.628]                       invisible(muffled)
[17:02:51.628]                     }
[17:02:51.628]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.628]                   }
[17:02:51.628]                 }
[17:02:51.628]             }
[17:02:51.628]         }))
[17:02:51.628]     }, error = function(ex) {
[17:02:51.628]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.628]                 ...future.rng), started = ...future.startTime, 
[17:02:51.628]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.628]             version = "1.8"), class = "FutureResult")
[17:02:51.628]     }, finally = {
[17:02:51.628]         if (!identical(...future.workdir, getwd())) 
[17:02:51.628]             setwd(...future.workdir)
[17:02:51.628]         {
[17:02:51.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.628]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.628]             }
[17:02:51.628]             base::options(...future.oldOptions)
[17:02:51.628]             if (.Platform$OS.type == "windows") {
[17:02:51.628]                 old_names <- names(...future.oldEnvVars)
[17:02:51.628]                 envs <- base::Sys.getenv()
[17:02:51.628]                 names <- names(envs)
[17:02:51.628]                 common <- intersect(names, old_names)
[17:02:51.628]                 added <- setdiff(names, old_names)
[17:02:51.628]                 removed <- setdiff(old_names, names)
[17:02:51.628]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.628]                   envs[common]]
[17:02:51.628]                 NAMES <- toupper(changed)
[17:02:51.628]                 args <- list()
[17:02:51.628]                 for (kk in seq_along(NAMES)) {
[17:02:51.628]                   name <- changed[[kk]]
[17:02:51.628]                   NAME <- NAMES[[kk]]
[17:02:51.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.628]                     next
[17:02:51.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.628]                 }
[17:02:51.628]                 NAMES <- toupper(added)
[17:02:51.628]                 for (kk in seq_along(NAMES)) {
[17:02:51.628]                   name <- added[[kk]]
[17:02:51.628]                   NAME <- NAMES[[kk]]
[17:02:51.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.628]                     next
[17:02:51.628]                   args[[name]] <- ""
[17:02:51.628]                 }
[17:02:51.628]                 NAMES <- toupper(removed)
[17:02:51.628]                 for (kk in seq_along(NAMES)) {
[17:02:51.628]                   name <- removed[[kk]]
[17:02:51.628]                   NAME <- NAMES[[kk]]
[17:02:51.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.628]                     next
[17:02:51.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.628]                 }
[17:02:51.628]                 if (length(args) > 0) 
[17:02:51.628]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.628]             }
[17:02:51.628]             else {
[17:02:51.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.628]             }
[17:02:51.628]             {
[17:02:51.628]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.628]                   0L) {
[17:02:51.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.628]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.628]                   base::options(opts)
[17:02:51.628]                 }
[17:02:51.628]                 {
[17:02:51.628]                   {
[17:02:51.628]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.628]                     NULL
[17:02:51.628]                   }
[17:02:51.628]                   options(future.plan = NULL)
[17:02:51.628]                   if (is.na(NA_character_)) 
[17:02:51.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.628]                     .init = FALSE)
[17:02:51.628]                 }
[17:02:51.628]             }
[17:02:51.628]         }
[17:02:51.628]     })
[17:02:51.628]     if (TRUE) {
[17:02:51.628]         base::sink(type = "output", split = FALSE)
[17:02:51.628]         if (TRUE) {
[17:02:51.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.628]         }
[17:02:51.628]         else {
[17:02:51.628]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.628]         }
[17:02:51.628]         base::close(...future.stdout)
[17:02:51.628]         ...future.stdout <- NULL
[17:02:51.628]     }
[17:02:51.628]     ...future.result$conditions <- ...future.conditions
[17:02:51.628]     ...future.result$finished <- base::Sys.time()
[17:02:51.628]     ...future.result
[17:02:51.628] }
[17:02:51.632] assign_globals() ...
[17:02:51.632] List of 1
[17:02:51.632]  $ ii: int 2
[17:02:51.632]  - attr(*, "where")=List of 1
[17:02:51.632]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.632]  - attr(*, "resolved")= logi TRUE
[17:02:51.632]  - attr(*, "total_size")= num 56
[17:02:51.632]  - attr(*, "already-done")= logi TRUE
[17:02:51.636] - copied ‘ii’ to environment
[17:02:51.636] assign_globals() ... done
[17:02:51.636] requestCore(): workers = 2
[17:02:51.638] MulticoreFuture started
[17:02:51.638] - Launch lazy future ... done
[17:02:51.639] run() for ‘MulticoreFuture’ ... done
[17:02:51.639] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.640] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.640] Searching for globals...
[17:02:51.640] List of future strategies:
[17:02:51.640] 1. sequential:
[17:02:51.640]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.640]    - tweaked: FALSE
[17:02:51.640]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.641] plan(): nbrOfWorkers() = 1
[17:02:51.643] plan(): Setting new future strategy stack:
[17:02:51.643] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.643] Searching for globals ... DONE
[17:02:51.643] List of future strategies:
[17:02:51.643] 1. multicore:
[17:02:51.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.643]    - tweaked: FALSE
[17:02:51.643]    - call: plan(strategy)
[17:02:51.644] Resolving globals: TRUE
[17:02:51.644] Resolving any globals that are futures ...
[17:02:51.644] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.648] plan(): nbrOfWorkers() = 2
[17:02:51.644] Resolving any globals that are futures ... DONE
[17:02:51.650] Resolving futures part of globals (recursively) ...
[17:02:51.651] resolve() on list ...
[17:02:51.651]  recursive: 99
[17:02:51.651]  length: 1
[17:02:51.651]  elements: ‘ii’
[17:02:51.652]  length: 0 (resolved future 1)
[17:02:51.652] resolve() on list ... DONE
[17:02:51.653] - globals: [1] ‘ii’
[17:02:51.653] Resolving futures part of globals (recursively) ... DONE
[17:02:51.653] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.654] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.655] - globals: [1] ‘ii’
[17:02:51.655] 
[17:02:51.655] getGlobalsAndPackages() ... DONE
[17:02:51.655] run() for ‘Future’ ...
[17:02:51.656] - state: ‘created’
[17:02:51.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.660] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.661]   - Field: ‘label’
[17:02:51.661]   - Field: ‘local’
[17:02:51.661]   - Field: ‘owner’
[17:02:51.661]   - Field: ‘envir’
[17:02:51.661]   - Field: ‘workers’
[17:02:51.662]   - Field: ‘packages’
[17:02:51.662]   - Field: ‘gc’
[17:02:51.662]   - Field: ‘job’
[17:02:51.662]   - Field: ‘conditions’
[17:02:51.662]   - Field: ‘expr’
[17:02:51.662]   - Field: ‘uuid’
[17:02:51.662]   - Field: ‘seed’
[17:02:51.663]   - Field: ‘version’
[17:02:51.663]   - Field: ‘result’
[17:02:51.663]   - Field: ‘asynchronous’
[17:02:51.663]   - Field: ‘calls’
[17:02:51.663]   - Field: ‘globals’
[17:02:51.663]   - Field: ‘stdout’
[17:02:51.663]   - Field: ‘earlySignal’
[17:02:51.664]   - Field: ‘lazy’
[17:02:51.664]   - Field: ‘state’
[17:02:51.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.664] - Launch lazy future ...
[17:02:51.664] Packages needed by the future expression (n = 0): <none>
[17:02:51.664] Packages needed by future strategies (n = 0): <none>
[17:02:51.665] {
[17:02:51.665]     {
[17:02:51.665]         {
[17:02:51.665]             ...future.startTime <- base::Sys.time()
[17:02:51.665]             {
[17:02:51.665]                 {
[17:02:51.665]                   {
[17:02:51.665]                     {
[17:02:51.665]                       base::local({
[17:02:51.665]                         has_future <- base::requireNamespace("future", 
[17:02:51.665]                           quietly = TRUE)
[17:02:51.665]                         if (has_future) {
[17:02:51.665]                           ns <- base::getNamespace("future")
[17:02:51.665]                           version <- ns[[".package"]][["version"]]
[17:02:51.665]                           if (is.null(version)) 
[17:02:51.665]                             version <- utils::packageVersion("future")
[17:02:51.665]                         }
[17:02:51.665]                         else {
[17:02:51.665]                           version <- NULL
[17:02:51.665]                         }
[17:02:51.665]                         if (!has_future || version < "1.8.0") {
[17:02:51.665]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.665]                             "", base::R.version$version.string), 
[17:02:51.665]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.665]                               "release", "version")], collapse = " "), 
[17:02:51.665]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.665]                             info)
[17:02:51.665]                           info <- base::paste(info, collapse = "; ")
[17:02:51.665]                           if (!has_future) {
[17:02:51.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.665]                               info)
[17:02:51.665]                           }
[17:02:51.665]                           else {
[17:02:51.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.665]                               info, version)
[17:02:51.665]                           }
[17:02:51.665]                           base::stop(msg)
[17:02:51.665]                         }
[17:02:51.665]                       })
[17:02:51.665]                     }
[17:02:51.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.665]                     base::options(mc.cores = 1L)
[17:02:51.665]                   }
[17:02:51.665]                   ...future.strategy.old <- future::plan("list")
[17:02:51.665]                   options(future.plan = NULL)
[17:02:51.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.665]                 }
[17:02:51.665]                 ...future.workdir <- getwd()
[17:02:51.665]             }
[17:02:51.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.665]         }
[17:02:51.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.665]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.665]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.665]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.665]             base::names(...future.oldOptions))
[17:02:51.665]     }
[17:02:51.665]     if (FALSE) {
[17:02:51.665]     }
[17:02:51.665]     else {
[17:02:51.665]         if (TRUE) {
[17:02:51.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.665]                 open = "w")
[17:02:51.665]         }
[17:02:51.665]         else {
[17:02:51.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.665]         }
[17:02:51.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.665]             base::sink(type = "output", split = FALSE)
[17:02:51.665]             base::close(...future.stdout)
[17:02:51.665]         }, add = TRUE)
[17:02:51.665]     }
[17:02:51.665]     ...future.frame <- base::sys.nframe()
[17:02:51.665]     ...future.conditions <- base::list()
[17:02:51.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.665]     if (FALSE) {
[17:02:51.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.665]     }
[17:02:51.665]     ...future.result <- base::tryCatch({
[17:02:51.665]         base::withCallingHandlers({
[17:02:51.665]             ...future.value <- base::withVisible(base::local({
[17:02:51.665]                 withCallingHandlers({
[17:02:51.665]                   {
[17:02:51.665]                     b <- a * ii
[17:02:51.665]                     a <- 0
[17:02:51.665]                     b
[17:02:51.665]                   }
[17:02:51.665]                 }, immediateCondition = function(cond) {
[17:02:51.665]                   save_rds <- function (object, pathname, ...) 
[17:02:51.665]                   {
[17:02:51.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.665]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.665]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.665]                         fi_tmp[["mtime"]])
[17:02:51.665]                     }
[17:02:51.665]                     tryCatch({
[17:02:51.665]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.665]                     }, error = function(ex) {
[17:02:51.665]                       msg <- conditionMessage(ex)
[17:02:51.665]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.665]                         fi_tmp[["mtime"]], msg)
[17:02:51.665]                       ex$message <- msg
[17:02:51.665]                       stop(ex)
[17:02:51.665]                     })
[17:02:51.665]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.665]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.665]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.665]                       fi <- file.info(pathname)
[17:02:51.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.665]                         fi[["size"]], fi[["mtime"]])
[17:02:51.665]                       stop(msg)
[17:02:51.665]                     }
[17:02:51.665]                     invisible(pathname)
[17:02:51.665]                   }
[17:02:51.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.665]                     rootPath = tempdir()) 
[17:02:51.665]                   {
[17:02:51.665]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.665]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.665]                       tmpdir = path, fileext = ".rds")
[17:02:51.665]                     save_rds(obj, file)
[17:02:51.665]                   }
[17:02:51.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.665]                   {
[17:02:51.665]                     inherits <- base::inherits
[17:02:51.665]                     invokeRestart <- base::invokeRestart
[17:02:51.665]                     is.null <- base::is.null
[17:02:51.665]                     muffled <- FALSE
[17:02:51.665]                     if (inherits(cond, "message")) {
[17:02:51.665]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.665]                       if (muffled) 
[17:02:51.665]                         invokeRestart("muffleMessage")
[17:02:51.665]                     }
[17:02:51.665]                     else if (inherits(cond, "warning")) {
[17:02:51.665]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.665]                       if (muffled) 
[17:02:51.665]                         invokeRestart("muffleWarning")
[17:02:51.665]                     }
[17:02:51.665]                     else if (inherits(cond, "condition")) {
[17:02:51.665]                       if (!is.null(pattern)) {
[17:02:51.665]                         computeRestarts <- base::computeRestarts
[17:02:51.665]                         grepl <- base::grepl
[17:02:51.665]                         restarts <- computeRestarts(cond)
[17:02:51.665]                         for (restart in restarts) {
[17:02:51.665]                           name <- restart$name
[17:02:51.665]                           if (is.null(name)) 
[17:02:51.665]                             next
[17:02:51.665]                           if (!grepl(pattern, name)) 
[17:02:51.665]                             next
[17:02:51.665]                           invokeRestart(restart)
[17:02:51.665]                           muffled <- TRUE
[17:02:51.665]                           break
[17:02:51.665]                         }
[17:02:51.665]                       }
[17:02:51.665]                     }
[17:02:51.665]                     invisible(muffled)
[17:02:51.665]                   }
[17:02:51.665]                   muffleCondition(cond)
[17:02:51.665]                 })
[17:02:51.665]             }))
[17:02:51.665]             future::FutureResult(value = ...future.value$value, 
[17:02:51.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.665]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.665]                     ...future.globalenv.names))
[17:02:51.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.665]         }, condition = base::local({
[17:02:51.665]             c <- base::c
[17:02:51.665]             inherits <- base::inherits
[17:02:51.665]             invokeRestart <- base::invokeRestart
[17:02:51.665]             length <- base::length
[17:02:51.665]             list <- base::list
[17:02:51.665]             seq.int <- base::seq.int
[17:02:51.665]             signalCondition <- base::signalCondition
[17:02:51.665]             sys.calls <- base::sys.calls
[17:02:51.665]             `[[` <- base::`[[`
[17:02:51.665]             `+` <- base::`+`
[17:02:51.665]             `<<-` <- base::`<<-`
[17:02:51.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.665]                   3L)]
[17:02:51.665]             }
[17:02:51.665]             function(cond) {
[17:02:51.665]                 is_error <- inherits(cond, "error")
[17:02:51.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.665]                   NULL)
[17:02:51.665]                 if (is_error) {
[17:02:51.665]                   sessionInformation <- function() {
[17:02:51.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.665]                       search = base::search(), system = base::Sys.info())
[17:02:51.665]                   }
[17:02:51.665]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.665]                     cond$call), session = sessionInformation(), 
[17:02:51.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.665]                   signalCondition(cond)
[17:02:51.665]                 }
[17:02:51.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.665]                 "immediateCondition"))) {
[17:02:51.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.665]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.665]                   if (TRUE && !signal) {
[17:02:51.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.665]                     {
[17:02:51.665]                       inherits <- base::inherits
[17:02:51.665]                       invokeRestart <- base::invokeRestart
[17:02:51.665]                       is.null <- base::is.null
[17:02:51.665]                       muffled <- FALSE
[17:02:51.665]                       if (inherits(cond, "message")) {
[17:02:51.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.665]                         if (muffled) 
[17:02:51.665]                           invokeRestart("muffleMessage")
[17:02:51.665]                       }
[17:02:51.665]                       else if (inherits(cond, "warning")) {
[17:02:51.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.665]                         if (muffled) 
[17:02:51.665]                           invokeRestart("muffleWarning")
[17:02:51.665]                       }
[17:02:51.665]                       else if (inherits(cond, "condition")) {
[17:02:51.665]                         if (!is.null(pattern)) {
[17:02:51.665]                           computeRestarts <- base::computeRestarts
[17:02:51.665]                           grepl <- base::grepl
[17:02:51.665]                           restarts <- computeRestarts(cond)
[17:02:51.665]                           for (restart in restarts) {
[17:02:51.665]                             name <- restart$name
[17:02:51.665]                             if (is.null(name)) 
[17:02:51.665]                               next
[17:02:51.665]                             if (!grepl(pattern, name)) 
[17:02:51.665]                               next
[17:02:51.665]                             invokeRestart(restart)
[17:02:51.665]                             muffled <- TRUE
[17:02:51.665]                             break
[17:02:51.665]                           }
[17:02:51.665]                         }
[17:02:51.665]                       }
[17:02:51.665]                       invisible(muffled)
[17:02:51.665]                     }
[17:02:51.665]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.665]                   }
[17:02:51.665]                 }
[17:02:51.665]                 else {
[17:02:51.665]                   if (TRUE) {
[17:02:51.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.665]                     {
[17:02:51.665]                       inherits <- base::inherits
[17:02:51.665]                       invokeRestart <- base::invokeRestart
[17:02:51.665]                       is.null <- base::is.null
[17:02:51.665]                       muffled <- FALSE
[17:02:51.665]                       if (inherits(cond, "message")) {
[17:02:51.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.665]                         if (muffled) 
[17:02:51.665]                           invokeRestart("muffleMessage")
[17:02:51.665]                       }
[17:02:51.665]                       else if (inherits(cond, "warning")) {
[17:02:51.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.665]                         if (muffled) 
[17:02:51.665]                           invokeRestart("muffleWarning")
[17:02:51.665]                       }
[17:02:51.665]                       else if (inherits(cond, "condition")) {
[17:02:51.665]                         if (!is.null(pattern)) {
[17:02:51.665]                           computeRestarts <- base::computeRestarts
[17:02:51.665]                           grepl <- base::grepl
[17:02:51.665]                           restarts <- computeRestarts(cond)
[17:02:51.665]                           for (restart in restarts) {
[17:02:51.665]                             name <- restart$name
[17:02:51.665]                             if (is.null(name)) 
[17:02:51.665]                               next
[17:02:51.665]                             if (!grepl(pattern, name)) 
[17:02:51.665]                               next
[17:02:51.665]                             invokeRestart(restart)
[17:02:51.665]                             muffled <- TRUE
[17:02:51.665]                             break
[17:02:51.665]                           }
[17:02:51.665]                         }
[17:02:51.665]                       }
[17:02:51.665]                       invisible(muffled)
[17:02:51.665]                     }
[17:02:51.665]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.665]                   }
[17:02:51.665]                 }
[17:02:51.665]             }
[17:02:51.665]         }))
[17:02:51.665]     }, error = function(ex) {
[17:02:51.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.665]                 ...future.rng), started = ...future.startTime, 
[17:02:51.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.665]             version = "1.8"), class = "FutureResult")
[17:02:51.665]     }, finally = {
[17:02:51.665]         if (!identical(...future.workdir, getwd())) 
[17:02:51.665]             setwd(...future.workdir)
[17:02:51.665]         {
[17:02:51.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.665]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.665]             }
[17:02:51.665]             base::options(...future.oldOptions)
[17:02:51.665]             if (.Platform$OS.type == "windows") {
[17:02:51.665]                 old_names <- names(...future.oldEnvVars)
[17:02:51.665]                 envs <- base::Sys.getenv()
[17:02:51.665]                 names <- names(envs)
[17:02:51.665]                 common <- intersect(names, old_names)
[17:02:51.665]                 added <- setdiff(names, old_names)
[17:02:51.665]                 removed <- setdiff(old_names, names)
[17:02:51.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.665]                   envs[common]]
[17:02:51.665]                 NAMES <- toupper(changed)
[17:02:51.665]                 args <- list()
[17:02:51.665]                 for (kk in seq_along(NAMES)) {
[17:02:51.665]                   name <- changed[[kk]]
[17:02:51.665]                   NAME <- NAMES[[kk]]
[17:02:51.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.665]                     next
[17:02:51.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.665]                 }
[17:02:51.665]                 NAMES <- toupper(added)
[17:02:51.665]                 for (kk in seq_along(NAMES)) {
[17:02:51.665]                   name <- added[[kk]]
[17:02:51.665]                   NAME <- NAMES[[kk]]
[17:02:51.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.665]                     next
[17:02:51.665]                   args[[name]] <- ""
[17:02:51.665]                 }
[17:02:51.665]                 NAMES <- toupper(removed)
[17:02:51.665]                 for (kk in seq_along(NAMES)) {
[17:02:51.665]                   name <- removed[[kk]]
[17:02:51.665]                   NAME <- NAMES[[kk]]
[17:02:51.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.665]                     next
[17:02:51.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.665]                 }
[17:02:51.665]                 if (length(args) > 0) 
[17:02:51.665]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.665]             }
[17:02:51.665]             else {
[17:02:51.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.665]             }
[17:02:51.665]             {
[17:02:51.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.665]                   0L) {
[17:02:51.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.665]                   base::options(opts)
[17:02:51.665]                 }
[17:02:51.665]                 {
[17:02:51.665]                   {
[17:02:51.665]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.665]                     NULL
[17:02:51.665]                   }
[17:02:51.665]                   options(future.plan = NULL)
[17:02:51.665]                   if (is.na(NA_character_)) 
[17:02:51.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.665]                     .init = FALSE)
[17:02:51.665]                 }
[17:02:51.665]             }
[17:02:51.665]         }
[17:02:51.665]     })
[17:02:51.665]     if (TRUE) {
[17:02:51.665]         base::sink(type = "output", split = FALSE)
[17:02:51.665]         if (TRUE) {
[17:02:51.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.665]         }
[17:02:51.665]         else {
[17:02:51.665]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.665]         }
[17:02:51.665]         base::close(...future.stdout)
[17:02:51.665]         ...future.stdout <- NULL
[17:02:51.665]     }
[17:02:51.665]     ...future.result$conditions <- ...future.conditions
[17:02:51.665]     ...future.result$finished <- base::Sys.time()
[17:02:51.665]     ...future.result
[17:02:51.665] }
[17:02:51.668] assign_globals() ...
[17:02:51.668] List of 1
[17:02:51.668]  $ ii: int 3
[17:02:51.668]  - attr(*, "where")=List of 1
[17:02:51.668]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.668]  - attr(*, "resolved")= logi TRUE
[17:02:51.668]  - attr(*, "total_size")= num 56
[17:02:51.668]  - attr(*, "already-done")= logi TRUE
[17:02:51.671] - copied ‘ii’ to environment
[17:02:51.672] assign_globals() ... done
[17:02:51.672] requestCore(): workers = 2
[17:02:51.672] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:51.684] result() for MulticoreFuture ...
[17:02:51.684] result() for MulticoreFuture ...
[17:02:51.684] result() for MulticoreFuture ... done
[17:02:51.685] result() for MulticoreFuture ... done
[17:02:51.685] result() for MulticoreFuture ...
[17:02:51.685] result() for MulticoreFuture ... done
[17:02:51.688] MulticoreFuture started
[17:02:51.688] - Launch lazy future ... done
[17:02:51.688] run() for ‘MulticoreFuture’ ... done
[17:02:51.689] plan(): Setting new future strategy stack:
[17:02:51.689] result() for MulticoreFuture ...
[17:02:51.690] result() for MulticoreFuture ... done
[17:02:51.690] result() for MulticoreFuture ...
[17:02:51.690] result() for MulticoreFuture ... done
[17:02:51.689] List of future strategies:
[17:02:51.689] 1. sequential:
[17:02:51.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.689]    - tweaked: FALSE
[17:02:51.689]    - call: NULL
[17:02:51.690] result() for MulticoreFuture ...
[17:02:51.691] plan(): nbrOfWorkers() = 1
[17:02:51.692] result() for MulticoreFuture ...
[17:02:51.692] result() for MulticoreFuture ... done
[17:02:51.693] result() for MulticoreFuture ... done
[17:02:51.693] result() for MulticoreFuture ...
[17:02:51.693] result() for MulticoreFuture ... done
[17:02:51.694] result() for MulticoreFuture ...
[17:02:51.694] plan(): Setting new future strategy stack:
[17:02:51.694] List of future strategies:
[17:02:51.694] 1. multicore:
[17:02:51.694]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.694]    - tweaked: FALSE
[17:02:51.694]    - call: plan(strategy)
[17:02:51.699] plan(): nbrOfWorkers() = 2
[17:02:51.700] result() for MulticoreFuture ...
[17:02:51.700] result() for MulticoreFuture ... done
[17:02:51.700] result() for MulticoreFuture ... done
[17:02:51.701] result() for MulticoreFuture ...
[17:02:51.701] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.702] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.703] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.705] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.705] Searching for globals ... DONE
[17:02:51.705] Resolving globals: TRUE
[17:02:51.705] Resolving any globals that are futures ...
[17:02:51.705] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.705] Resolving any globals that are futures ... DONE
[17:02:51.706] Resolving futures part of globals (recursively) ...
[17:02:51.706] resolve() on list ...
[17:02:51.706]  recursive: 99
[17:02:51.706]  length: 1
[17:02:51.707]  elements: ‘ii’
[17:02:51.707]  length: 0 (resolved future 1)
[17:02:51.707] resolve() on list ... DONE
[17:02:51.707] - globals: [1] ‘ii’
[17:02:51.707] Resolving futures part of globals (recursively) ... DONE
[17:02:51.707] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.708] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.708] - globals: [1] ‘ii’
[17:02:51.708] 
[17:02:51.708] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.709] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.709] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.711] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.711] Searching for globals ... DONE
[17:02:51.711] Resolving globals: TRUE
[17:02:51.711] Resolving any globals that are futures ...
[17:02:51.711] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.712] Resolving any globals that are futures ... DONE
[17:02:51.714] Resolving futures part of globals (recursively) ...
[17:02:51.715] resolve() on list ...
[17:02:51.715]  recursive: 99
[17:02:51.715]  length: 1
[17:02:51.715]  elements: ‘ii’
[17:02:51.715]  length: 0 (resolved future 1)
[17:02:51.716] resolve() on list ... DONE
[17:02:51.716] - globals: [1] ‘ii’
[17:02:51.716] Resolving futures part of globals (recursively) ... DONE
[17:02:51.716] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.717] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.717] - globals: [1] ‘ii’
[17:02:51.717] 
[17:02:51.717] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.718] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.718] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.720] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.720] Searching for globals ... DONE
[17:02:51.720] Resolving globals: TRUE
[17:02:51.720] Resolving any globals that are futures ...
[17:02:51.720] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:51.720] Resolving any globals that are futures ... DONE
[17:02:51.721] Resolving futures part of globals (recursively) ...
[17:02:51.721] resolve() on list ...
[17:02:51.721]  recursive: 99
[17:02:51.721]  length: 1
[17:02:51.721]  elements: ‘ii’
[17:02:51.721]  length: 0 (resolved future 1)
[17:02:51.721] resolve() on list ... DONE
[17:02:51.722] - globals: [1] ‘ii’
[17:02:51.722] Resolving futures part of globals (recursively) ... DONE
[17:02:51.722] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:51.722] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:51.722] - globals: [1] ‘ii’
[17:02:51.723] 
[17:02:51.723] getGlobalsAndPackages() ... DONE
[17:02:51.723] run() for ‘Future’ ...
[17:02:51.723] - state: ‘created’
[17:02:51.723] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.728] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.728]   - Field: ‘label’
[17:02:51.728]   - Field: ‘local’
[17:02:51.728]   - Field: ‘owner’
[17:02:51.728]   - Field: ‘envir’
[17:02:51.728]   - Field: ‘workers’
[17:02:51.728]   - Field: ‘packages’
[17:02:51.728]   - Field: ‘gc’
[17:02:51.729]   - Field: ‘job’
[17:02:51.729]   - Field: ‘conditions’
[17:02:51.729]   - Field: ‘expr’
[17:02:51.729]   - Field: ‘uuid’
[17:02:51.729]   - Field: ‘seed’
[17:02:51.729]   - Field: ‘version’
[17:02:51.729]   - Field: ‘result’
[17:02:51.729]   - Field: ‘asynchronous’
[17:02:51.729]   - Field: ‘calls’
[17:02:51.730]   - Field: ‘globals’
[17:02:51.730]   - Field: ‘stdout’
[17:02:51.730]   - Field: ‘earlySignal’
[17:02:51.730]   - Field: ‘lazy’
[17:02:51.730]   - Field: ‘state’
[17:02:51.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.730] - Launch lazy future ...
[17:02:51.731] Packages needed by the future expression (n = 0): <none>
[17:02:51.731] Packages needed by future strategies (n = 0): <none>
[17:02:51.731] {
[17:02:51.731]     {
[17:02:51.731]         {
[17:02:51.731]             ...future.startTime <- base::Sys.time()
[17:02:51.731]             {
[17:02:51.731]                 {
[17:02:51.731]                   {
[17:02:51.731]                     {
[17:02:51.731]                       base::local({
[17:02:51.731]                         has_future <- base::requireNamespace("future", 
[17:02:51.731]                           quietly = TRUE)
[17:02:51.731]                         if (has_future) {
[17:02:51.731]                           ns <- base::getNamespace("future")
[17:02:51.731]                           version <- ns[[".package"]][["version"]]
[17:02:51.731]                           if (is.null(version)) 
[17:02:51.731]                             version <- utils::packageVersion("future")
[17:02:51.731]                         }
[17:02:51.731]                         else {
[17:02:51.731]                           version <- NULL
[17:02:51.731]                         }
[17:02:51.731]                         if (!has_future || version < "1.8.0") {
[17:02:51.731]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.731]                             "", base::R.version$version.string), 
[17:02:51.731]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.731]                               "release", "version")], collapse = " "), 
[17:02:51.731]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.731]                             info)
[17:02:51.731]                           info <- base::paste(info, collapse = "; ")
[17:02:51.731]                           if (!has_future) {
[17:02:51.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.731]                               info)
[17:02:51.731]                           }
[17:02:51.731]                           else {
[17:02:51.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.731]                               info, version)
[17:02:51.731]                           }
[17:02:51.731]                           base::stop(msg)
[17:02:51.731]                         }
[17:02:51.731]                       })
[17:02:51.731]                     }
[17:02:51.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.731]                     base::options(mc.cores = 1L)
[17:02:51.731]                   }
[17:02:51.731]                   ...future.strategy.old <- future::plan("list")
[17:02:51.731]                   options(future.plan = NULL)
[17:02:51.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.731]                 }
[17:02:51.731]                 ...future.workdir <- getwd()
[17:02:51.731]             }
[17:02:51.731]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.731]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.731]         }
[17:02:51.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.731]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.731]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.731]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.731]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.731]             base::names(...future.oldOptions))
[17:02:51.731]     }
[17:02:51.731]     if (FALSE) {
[17:02:51.731]     }
[17:02:51.731]     else {
[17:02:51.731]         if (TRUE) {
[17:02:51.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.731]                 open = "w")
[17:02:51.731]         }
[17:02:51.731]         else {
[17:02:51.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.731]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.731]         }
[17:02:51.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.731]             base::sink(type = "output", split = FALSE)
[17:02:51.731]             base::close(...future.stdout)
[17:02:51.731]         }, add = TRUE)
[17:02:51.731]     }
[17:02:51.731]     ...future.frame <- base::sys.nframe()
[17:02:51.731]     ...future.conditions <- base::list()
[17:02:51.731]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.731]     if (FALSE) {
[17:02:51.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.731]     }
[17:02:51.731]     ...future.result <- base::tryCatch({
[17:02:51.731]         base::withCallingHandlers({
[17:02:51.731]             ...future.value <- base::withVisible(base::local({
[17:02:51.731]                 withCallingHandlers({
[17:02:51.731]                   {
[17:02:51.731]                     b <- a * ii
[17:02:51.731]                     a <- 0
[17:02:51.731]                     b
[17:02:51.731]                   }
[17:02:51.731]                 }, immediateCondition = function(cond) {
[17:02:51.731]                   save_rds <- function (object, pathname, ...) 
[17:02:51.731]                   {
[17:02:51.731]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.731]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.731]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.731]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.731]                         fi_tmp[["mtime"]])
[17:02:51.731]                     }
[17:02:51.731]                     tryCatch({
[17:02:51.731]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.731]                     }, error = function(ex) {
[17:02:51.731]                       msg <- conditionMessage(ex)
[17:02:51.731]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.731]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.731]                         fi_tmp[["mtime"]], msg)
[17:02:51.731]                       ex$message <- msg
[17:02:51.731]                       stop(ex)
[17:02:51.731]                     })
[17:02:51.731]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.731]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.731]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.731]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.731]                       fi <- file.info(pathname)
[17:02:51.731]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.731]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.731]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.731]                         fi[["size"]], fi[["mtime"]])
[17:02:51.731]                       stop(msg)
[17:02:51.731]                     }
[17:02:51.731]                     invisible(pathname)
[17:02:51.731]                   }
[17:02:51.731]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.731]                     rootPath = tempdir()) 
[17:02:51.731]                   {
[17:02:51.731]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.731]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.731]                       tmpdir = path, fileext = ".rds")
[17:02:51.731]                     save_rds(obj, file)
[17:02:51.731]                   }
[17:02:51.731]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.731]                   {
[17:02:51.731]                     inherits <- base::inherits
[17:02:51.731]                     invokeRestart <- base::invokeRestart
[17:02:51.731]                     is.null <- base::is.null
[17:02:51.731]                     muffled <- FALSE
[17:02:51.731]                     if (inherits(cond, "message")) {
[17:02:51.731]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.731]                       if (muffled) 
[17:02:51.731]                         invokeRestart("muffleMessage")
[17:02:51.731]                     }
[17:02:51.731]                     else if (inherits(cond, "warning")) {
[17:02:51.731]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.731]                       if (muffled) 
[17:02:51.731]                         invokeRestart("muffleWarning")
[17:02:51.731]                     }
[17:02:51.731]                     else if (inherits(cond, "condition")) {
[17:02:51.731]                       if (!is.null(pattern)) {
[17:02:51.731]                         computeRestarts <- base::computeRestarts
[17:02:51.731]                         grepl <- base::grepl
[17:02:51.731]                         restarts <- computeRestarts(cond)
[17:02:51.731]                         for (restart in restarts) {
[17:02:51.731]                           name <- restart$name
[17:02:51.731]                           if (is.null(name)) 
[17:02:51.731]                             next
[17:02:51.731]                           if (!grepl(pattern, name)) 
[17:02:51.731]                             next
[17:02:51.731]                           invokeRestart(restart)
[17:02:51.731]                           muffled <- TRUE
[17:02:51.731]                           break
[17:02:51.731]                         }
[17:02:51.731]                       }
[17:02:51.731]                     }
[17:02:51.731]                     invisible(muffled)
[17:02:51.731]                   }
[17:02:51.731]                   muffleCondition(cond)
[17:02:51.731]                 })
[17:02:51.731]             }))
[17:02:51.731]             future::FutureResult(value = ...future.value$value, 
[17:02:51.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.731]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.731]                     ...future.globalenv.names))
[17:02:51.731]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.731]         }, condition = base::local({
[17:02:51.731]             c <- base::c
[17:02:51.731]             inherits <- base::inherits
[17:02:51.731]             invokeRestart <- base::invokeRestart
[17:02:51.731]             length <- base::length
[17:02:51.731]             list <- base::list
[17:02:51.731]             seq.int <- base::seq.int
[17:02:51.731]             signalCondition <- base::signalCondition
[17:02:51.731]             sys.calls <- base::sys.calls
[17:02:51.731]             `[[` <- base::`[[`
[17:02:51.731]             `+` <- base::`+`
[17:02:51.731]             `<<-` <- base::`<<-`
[17:02:51.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.731]                   3L)]
[17:02:51.731]             }
[17:02:51.731]             function(cond) {
[17:02:51.731]                 is_error <- inherits(cond, "error")
[17:02:51.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.731]                   NULL)
[17:02:51.731]                 if (is_error) {
[17:02:51.731]                   sessionInformation <- function() {
[17:02:51.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.731]                       search = base::search(), system = base::Sys.info())
[17:02:51.731]                   }
[17:02:51.731]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.731]                     cond$call), session = sessionInformation(), 
[17:02:51.731]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.731]                   signalCondition(cond)
[17:02:51.731]                 }
[17:02:51.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.731]                 "immediateCondition"))) {
[17:02:51.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.731]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.731]                   if (TRUE && !signal) {
[17:02:51.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.731]                     {
[17:02:51.731]                       inherits <- base::inherits
[17:02:51.731]                       invokeRestart <- base::invokeRestart
[17:02:51.731]                       is.null <- base::is.null
[17:02:51.731]                       muffled <- FALSE
[17:02:51.731]                       if (inherits(cond, "message")) {
[17:02:51.731]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.731]                         if (muffled) 
[17:02:51.731]                           invokeRestart("muffleMessage")
[17:02:51.731]                       }
[17:02:51.731]                       else if (inherits(cond, "warning")) {
[17:02:51.731]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.731]                         if (muffled) 
[17:02:51.731]                           invokeRestart("muffleWarning")
[17:02:51.731]                       }
[17:02:51.731]                       else if (inherits(cond, "condition")) {
[17:02:51.731]                         if (!is.null(pattern)) {
[17:02:51.731]                           computeRestarts <- base::computeRestarts
[17:02:51.731]                           grepl <- base::grepl
[17:02:51.731]                           restarts <- computeRestarts(cond)
[17:02:51.731]                           for (restart in restarts) {
[17:02:51.731]                             name <- restart$name
[17:02:51.731]                             if (is.null(name)) 
[17:02:51.731]                               next
[17:02:51.731]                             if (!grepl(pattern, name)) 
[17:02:51.731]                               next
[17:02:51.731]                             invokeRestart(restart)
[17:02:51.731]                             muffled <- TRUE
[17:02:51.731]                             break
[17:02:51.731]                           }
[17:02:51.731]                         }
[17:02:51.731]                       }
[17:02:51.731]                       invisible(muffled)
[17:02:51.731]                     }
[17:02:51.731]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.731]                   }
[17:02:51.731]                 }
[17:02:51.731]                 else {
[17:02:51.731]                   if (TRUE) {
[17:02:51.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.731]                     {
[17:02:51.731]                       inherits <- base::inherits
[17:02:51.731]                       invokeRestart <- base::invokeRestart
[17:02:51.731]                       is.null <- base::is.null
[17:02:51.731]                       muffled <- FALSE
[17:02:51.731]                       if (inherits(cond, "message")) {
[17:02:51.731]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.731]                         if (muffled) 
[17:02:51.731]                           invokeRestart("muffleMessage")
[17:02:51.731]                       }
[17:02:51.731]                       else if (inherits(cond, "warning")) {
[17:02:51.731]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.731]                         if (muffled) 
[17:02:51.731]                           invokeRestart("muffleWarning")
[17:02:51.731]                       }
[17:02:51.731]                       else if (inherits(cond, "condition")) {
[17:02:51.731]                         if (!is.null(pattern)) {
[17:02:51.731]                           computeRestarts <- base::computeRestarts
[17:02:51.731]                           grepl <- base::grepl
[17:02:51.731]                           restarts <- computeRestarts(cond)
[17:02:51.731]                           for (restart in restarts) {
[17:02:51.731]                             name <- restart$name
[17:02:51.731]                             if (is.null(name)) 
[17:02:51.731]                               next
[17:02:51.731]                             if (!grepl(pattern, name)) 
[17:02:51.731]                               next
[17:02:51.731]                             invokeRestart(restart)
[17:02:51.731]                             muffled <- TRUE
[17:02:51.731]                             break
[17:02:51.731]                           }
[17:02:51.731]                         }
[17:02:51.731]                       }
[17:02:51.731]                       invisible(muffled)
[17:02:51.731]                     }
[17:02:51.731]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.731]                   }
[17:02:51.731]                 }
[17:02:51.731]             }
[17:02:51.731]         }))
[17:02:51.731]     }, error = function(ex) {
[17:02:51.731]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.731]                 ...future.rng), started = ...future.startTime, 
[17:02:51.731]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.731]             version = "1.8"), class = "FutureResult")
[17:02:51.731]     }, finally = {
[17:02:51.731]         if (!identical(...future.workdir, getwd())) 
[17:02:51.731]             setwd(...future.workdir)
[17:02:51.731]         {
[17:02:51.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.731]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.731]             }
[17:02:51.731]             base::options(...future.oldOptions)
[17:02:51.731]             if (.Platform$OS.type == "windows") {
[17:02:51.731]                 old_names <- names(...future.oldEnvVars)
[17:02:51.731]                 envs <- base::Sys.getenv()
[17:02:51.731]                 names <- names(envs)
[17:02:51.731]                 common <- intersect(names, old_names)
[17:02:51.731]                 added <- setdiff(names, old_names)
[17:02:51.731]                 removed <- setdiff(old_names, names)
[17:02:51.731]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.731]                   envs[common]]
[17:02:51.731]                 NAMES <- toupper(changed)
[17:02:51.731]                 args <- list()
[17:02:51.731]                 for (kk in seq_along(NAMES)) {
[17:02:51.731]                   name <- changed[[kk]]
[17:02:51.731]                   NAME <- NAMES[[kk]]
[17:02:51.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.731]                     next
[17:02:51.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.731]                 }
[17:02:51.731]                 NAMES <- toupper(added)
[17:02:51.731]                 for (kk in seq_along(NAMES)) {
[17:02:51.731]                   name <- added[[kk]]
[17:02:51.731]                   NAME <- NAMES[[kk]]
[17:02:51.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.731]                     next
[17:02:51.731]                   args[[name]] <- ""
[17:02:51.731]                 }
[17:02:51.731]                 NAMES <- toupper(removed)
[17:02:51.731]                 for (kk in seq_along(NAMES)) {
[17:02:51.731]                   name <- removed[[kk]]
[17:02:51.731]                   NAME <- NAMES[[kk]]
[17:02:51.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.731]                     next
[17:02:51.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.731]                 }
[17:02:51.731]                 if (length(args) > 0) 
[17:02:51.731]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.731]             }
[17:02:51.731]             else {
[17:02:51.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.731]             }
[17:02:51.731]             {
[17:02:51.731]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.731]                   0L) {
[17:02:51.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.731]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.731]                   base::options(opts)
[17:02:51.731]                 }
[17:02:51.731]                 {
[17:02:51.731]                   {
[17:02:51.731]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.731]                     NULL
[17:02:51.731]                   }
[17:02:51.731]                   options(future.plan = NULL)
[17:02:51.731]                   if (is.na(NA_character_)) 
[17:02:51.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.731]                     .init = FALSE)
[17:02:51.731]                 }
[17:02:51.731]             }
[17:02:51.731]         }
[17:02:51.731]     })
[17:02:51.731]     if (TRUE) {
[17:02:51.731]         base::sink(type = "output", split = FALSE)
[17:02:51.731]         if (TRUE) {
[17:02:51.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.731]         }
[17:02:51.731]         else {
[17:02:51.731]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.731]         }
[17:02:51.731]         base::close(...future.stdout)
[17:02:51.731]         ...future.stdout <- NULL
[17:02:51.731]     }
[17:02:51.731]     ...future.result$conditions <- ...future.conditions
[17:02:51.731]     ...future.result$finished <- base::Sys.time()
[17:02:51.731]     ...future.result
[17:02:51.731] }
[17:02:51.733] assign_globals() ...
[17:02:51.734] List of 1
[17:02:51.734]  $ ii: int 1
[17:02:51.734]  - attr(*, "where")=List of 1
[17:02:51.734]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:51.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.734]  - attr(*, "resolved")= logi TRUE
[17:02:51.734]  - attr(*, "total_size")= num 56
[17:02:51.734]  - attr(*, "already-done")= logi TRUE
[17:02:51.736] - copied ‘ii’ to environment
[17:02:51.736] assign_globals() ... done
[17:02:51.737] requestCore(): workers = 2
[17:02:51.739] MulticoreFuture started
[17:02:51.739] - Launch lazy future ... done
[17:02:51.739] run() for ‘MulticoreFuture’ ... done
[17:02:51.740] result() for MulticoreFuture ...
[17:02:51.740] plan(): Setting new future strategy stack:
[17:02:51.740] List of future strategies:
[17:02:51.740] 1. sequential:
[17:02:51.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.740]    - tweaked: FALSE
[17:02:51.740]    - call: NULL
[17:02:51.741] plan(): nbrOfWorkers() = 1
[17:02:51.743] plan(): Setting new future strategy stack:
[17:02:51.744] List of future strategies:
[17:02:51.744] 1. multicore:
[17:02:51.744]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.744]    - tweaked: FALSE
[17:02:51.744]    - call: plan(strategy)
[17:02:51.749] plan(): nbrOfWorkers() = 2
[17:02:51.755] result() for MulticoreFuture ...
[17:02:51.755] result() for MulticoreFuture ... done
[17:02:51.755] signalConditions() ...
[17:02:51.755]  - include = ‘immediateCondition’
[17:02:51.755]  - exclude = 
[17:02:51.756]  - resignal = FALSE
[17:02:51.756]  - Number of conditions: 1
[17:02:51.756] signalConditions() ... done
[17:02:51.756] result() for MulticoreFuture ... done
[17:02:51.756] result() for MulticoreFuture ...
[17:02:51.756] result() for MulticoreFuture ... done
[17:02:51.757] signalConditions() ...
[17:02:51.757]  - include = ‘immediateCondition’
[17:02:51.757]  - exclude = 
[17:02:51.757]  - resignal = FALSE
[17:02:51.757]  - Number of conditions: 1
[17:02:51.757] signalConditions() ... done
[17:02:51.758] Future state: ‘finished’
[17:02:51.758] result() for MulticoreFuture ...
[17:02:51.758] result() for MulticoreFuture ... done
[17:02:51.758] signalConditions() ...
[17:02:51.758]  - include = ‘condition’
[17:02:51.758]  - exclude = ‘immediateCondition’
[17:02:51.758]  - resignal = TRUE
[17:02:51.759]  - Number of conditions: 1
[17:02:51.759]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:51.759] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.791] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.792] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.792] 
[17:02:51.792] Searching for globals ... DONE
[17:02:51.792] - globals: [0] <none>
[17:02:51.793] getGlobalsAndPackages() ... DONE
[17:02:51.793] run() for ‘Future’ ...
[17:02:51.793] - state: ‘created’
[17:02:51.793] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.797] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.797]   - Field: ‘label’
[17:02:51.797]   - Field: ‘local’
[17:02:51.798]   - Field: ‘owner’
[17:02:51.798]   - Field: ‘envir’
[17:02:51.798]   - Field: ‘workers’
[17:02:51.798]   - Field: ‘packages’
[17:02:51.798]   - Field: ‘gc’
[17:02:51.798]   - Field: ‘job’
[17:02:51.798]   - Field: ‘conditions’
[17:02:51.798]   - Field: ‘expr’
[17:02:51.798]   - Field: ‘uuid’
[17:02:51.798]   - Field: ‘seed’
[17:02:51.799]   - Field: ‘version’
[17:02:51.799]   - Field: ‘result’
[17:02:51.799]   - Field: ‘asynchronous’
[17:02:51.799]   - Field: ‘calls’
[17:02:51.799]   - Field: ‘globals’
[17:02:51.799]   - Field: ‘stdout’
[17:02:51.799]   - Field: ‘earlySignal’
[17:02:51.799]   - Field: ‘lazy’
[17:02:51.799]   - Field: ‘state’
[17:02:51.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.800] - Launch lazy future ...
[17:02:51.800] Packages needed by the future expression (n = 0): <none>
[17:02:51.800] Packages needed by future strategies (n = 0): <none>
[17:02:51.800] {
[17:02:51.800]     {
[17:02:51.800]         {
[17:02:51.800]             ...future.startTime <- base::Sys.time()
[17:02:51.800]             {
[17:02:51.800]                 {
[17:02:51.800]                   {
[17:02:51.800]                     {
[17:02:51.800]                       base::local({
[17:02:51.800]                         has_future <- base::requireNamespace("future", 
[17:02:51.800]                           quietly = TRUE)
[17:02:51.800]                         if (has_future) {
[17:02:51.800]                           ns <- base::getNamespace("future")
[17:02:51.800]                           version <- ns[[".package"]][["version"]]
[17:02:51.800]                           if (is.null(version)) 
[17:02:51.800]                             version <- utils::packageVersion("future")
[17:02:51.800]                         }
[17:02:51.800]                         else {
[17:02:51.800]                           version <- NULL
[17:02:51.800]                         }
[17:02:51.800]                         if (!has_future || version < "1.8.0") {
[17:02:51.800]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.800]                             "", base::R.version$version.string), 
[17:02:51.800]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.800]                               "release", "version")], collapse = " "), 
[17:02:51.800]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.800]                             info)
[17:02:51.800]                           info <- base::paste(info, collapse = "; ")
[17:02:51.800]                           if (!has_future) {
[17:02:51.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.800]                               info)
[17:02:51.800]                           }
[17:02:51.800]                           else {
[17:02:51.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.800]                               info, version)
[17:02:51.800]                           }
[17:02:51.800]                           base::stop(msg)
[17:02:51.800]                         }
[17:02:51.800]                       })
[17:02:51.800]                     }
[17:02:51.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.800]                     base::options(mc.cores = 1L)
[17:02:51.800]                   }
[17:02:51.800]                   ...future.strategy.old <- future::plan("list")
[17:02:51.800]                   options(future.plan = NULL)
[17:02:51.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.800]                 }
[17:02:51.800]                 ...future.workdir <- getwd()
[17:02:51.800]             }
[17:02:51.800]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.800]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.800]         }
[17:02:51.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.800]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.800]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.800]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.800]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.800]             base::names(...future.oldOptions))
[17:02:51.800]     }
[17:02:51.800]     if (FALSE) {
[17:02:51.800]     }
[17:02:51.800]     else {
[17:02:51.800]         if (TRUE) {
[17:02:51.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.800]                 open = "w")
[17:02:51.800]         }
[17:02:51.800]         else {
[17:02:51.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.800]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.800]         }
[17:02:51.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.800]             base::sink(type = "output", split = FALSE)
[17:02:51.800]             base::close(...future.stdout)
[17:02:51.800]         }, add = TRUE)
[17:02:51.800]     }
[17:02:51.800]     ...future.frame <- base::sys.nframe()
[17:02:51.800]     ...future.conditions <- base::list()
[17:02:51.800]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.800]     if (FALSE) {
[17:02:51.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.800]     }
[17:02:51.800]     ...future.result <- base::tryCatch({
[17:02:51.800]         base::withCallingHandlers({
[17:02:51.800]             ...future.value <- base::withVisible(base::local({
[17:02:51.800]                 withCallingHandlers({
[17:02:51.800]                   1
[17:02:51.800]                 }, immediateCondition = function(cond) {
[17:02:51.800]                   save_rds <- function (object, pathname, ...) 
[17:02:51.800]                   {
[17:02:51.800]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.800]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.800]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.800]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.800]                         fi_tmp[["mtime"]])
[17:02:51.800]                     }
[17:02:51.800]                     tryCatch({
[17:02:51.800]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.800]                     }, error = function(ex) {
[17:02:51.800]                       msg <- conditionMessage(ex)
[17:02:51.800]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.800]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.800]                         fi_tmp[["mtime"]], msg)
[17:02:51.800]                       ex$message <- msg
[17:02:51.800]                       stop(ex)
[17:02:51.800]                     })
[17:02:51.800]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.800]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.800]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.800]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.800]                       fi <- file.info(pathname)
[17:02:51.800]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.800]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.800]                         fi[["size"]], fi[["mtime"]])
[17:02:51.800]                       stop(msg)
[17:02:51.800]                     }
[17:02:51.800]                     invisible(pathname)
[17:02:51.800]                   }
[17:02:51.800]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.800]                     rootPath = tempdir()) 
[17:02:51.800]                   {
[17:02:51.800]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.800]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.800]                       tmpdir = path, fileext = ".rds")
[17:02:51.800]                     save_rds(obj, file)
[17:02:51.800]                   }
[17:02:51.800]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.800]                   {
[17:02:51.800]                     inherits <- base::inherits
[17:02:51.800]                     invokeRestart <- base::invokeRestart
[17:02:51.800]                     is.null <- base::is.null
[17:02:51.800]                     muffled <- FALSE
[17:02:51.800]                     if (inherits(cond, "message")) {
[17:02:51.800]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.800]                       if (muffled) 
[17:02:51.800]                         invokeRestart("muffleMessage")
[17:02:51.800]                     }
[17:02:51.800]                     else if (inherits(cond, "warning")) {
[17:02:51.800]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.800]                       if (muffled) 
[17:02:51.800]                         invokeRestart("muffleWarning")
[17:02:51.800]                     }
[17:02:51.800]                     else if (inherits(cond, "condition")) {
[17:02:51.800]                       if (!is.null(pattern)) {
[17:02:51.800]                         computeRestarts <- base::computeRestarts
[17:02:51.800]                         grepl <- base::grepl
[17:02:51.800]                         restarts <- computeRestarts(cond)
[17:02:51.800]                         for (restart in restarts) {
[17:02:51.800]                           name <- restart$name
[17:02:51.800]                           if (is.null(name)) 
[17:02:51.800]                             next
[17:02:51.800]                           if (!grepl(pattern, name)) 
[17:02:51.800]                             next
[17:02:51.800]                           invokeRestart(restart)
[17:02:51.800]                           muffled <- TRUE
[17:02:51.800]                           break
[17:02:51.800]                         }
[17:02:51.800]                       }
[17:02:51.800]                     }
[17:02:51.800]                     invisible(muffled)
[17:02:51.800]                   }
[17:02:51.800]                   muffleCondition(cond)
[17:02:51.800]                 })
[17:02:51.800]             }))
[17:02:51.800]             future::FutureResult(value = ...future.value$value, 
[17:02:51.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.800]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.800]                     ...future.globalenv.names))
[17:02:51.800]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.800]         }, condition = base::local({
[17:02:51.800]             c <- base::c
[17:02:51.800]             inherits <- base::inherits
[17:02:51.800]             invokeRestart <- base::invokeRestart
[17:02:51.800]             length <- base::length
[17:02:51.800]             list <- base::list
[17:02:51.800]             seq.int <- base::seq.int
[17:02:51.800]             signalCondition <- base::signalCondition
[17:02:51.800]             sys.calls <- base::sys.calls
[17:02:51.800]             `[[` <- base::`[[`
[17:02:51.800]             `+` <- base::`+`
[17:02:51.800]             `<<-` <- base::`<<-`
[17:02:51.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.800]                   3L)]
[17:02:51.800]             }
[17:02:51.800]             function(cond) {
[17:02:51.800]                 is_error <- inherits(cond, "error")
[17:02:51.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.800]                   NULL)
[17:02:51.800]                 if (is_error) {
[17:02:51.800]                   sessionInformation <- function() {
[17:02:51.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.800]                       search = base::search(), system = base::Sys.info())
[17:02:51.800]                   }
[17:02:51.800]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.800]                     cond$call), session = sessionInformation(), 
[17:02:51.800]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.800]                   signalCondition(cond)
[17:02:51.800]                 }
[17:02:51.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.800]                 "immediateCondition"))) {
[17:02:51.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.800]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.800]                   if (TRUE && !signal) {
[17:02:51.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.800]                     {
[17:02:51.800]                       inherits <- base::inherits
[17:02:51.800]                       invokeRestart <- base::invokeRestart
[17:02:51.800]                       is.null <- base::is.null
[17:02:51.800]                       muffled <- FALSE
[17:02:51.800]                       if (inherits(cond, "message")) {
[17:02:51.800]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.800]                         if (muffled) 
[17:02:51.800]                           invokeRestart("muffleMessage")
[17:02:51.800]                       }
[17:02:51.800]                       else if (inherits(cond, "warning")) {
[17:02:51.800]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.800]                         if (muffled) 
[17:02:51.800]                           invokeRestart("muffleWarning")
[17:02:51.800]                       }
[17:02:51.800]                       else if (inherits(cond, "condition")) {
[17:02:51.800]                         if (!is.null(pattern)) {
[17:02:51.800]                           computeRestarts <- base::computeRestarts
[17:02:51.800]                           grepl <- base::grepl
[17:02:51.800]                           restarts <- computeRestarts(cond)
[17:02:51.800]                           for (restart in restarts) {
[17:02:51.800]                             name <- restart$name
[17:02:51.800]                             if (is.null(name)) 
[17:02:51.800]                               next
[17:02:51.800]                             if (!grepl(pattern, name)) 
[17:02:51.800]                               next
[17:02:51.800]                             invokeRestart(restart)
[17:02:51.800]                             muffled <- TRUE
[17:02:51.800]                             break
[17:02:51.800]                           }
[17:02:51.800]                         }
[17:02:51.800]                       }
[17:02:51.800]                       invisible(muffled)
[17:02:51.800]                     }
[17:02:51.800]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.800]                   }
[17:02:51.800]                 }
[17:02:51.800]                 else {
[17:02:51.800]                   if (TRUE) {
[17:02:51.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.800]                     {
[17:02:51.800]                       inherits <- base::inherits
[17:02:51.800]                       invokeRestart <- base::invokeRestart
[17:02:51.800]                       is.null <- base::is.null
[17:02:51.800]                       muffled <- FALSE
[17:02:51.800]                       if (inherits(cond, "message")) {
[17:02:51.800]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.800]                         if (muffled) 
[17:02:51.800]                           invokeRestart("muffleMessage")
[17:02:51.800]                       }
[17:02:51.800]                       else if (inherits(cond, "warning")) {
[17:02:51.800]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.800]                         if (muffled) 
[17:02:51.800]                           invokeRestart("muffleWarning")
[17:02:51.800]                       }
[17:02:51.800]                       else if (inherits(cond, "condition")) {
[17:02:51.800]                         if (!is.null(pattern)) {
[17:02:51.800]                           computeRestarts <- base::computeRestarts
[17:02:51.800]                           grepl <- base::grepl
[17:02:51.800]                           restarts <- computeRestarts(cond)
[17:02:51.800]                           for (restart in restarts) {
[17:02:51.800]                             name <- restart$name
[17:02:51.800]                             if (is.null(name)) 
[17:02:51.800]                               next
[17:02:51.800]                             if (!grepl(pattern, name)) 
[17:02:51.800]                               next
[17:02:51.800]                             invokeRestart(restart)
[17:02:51.800]                             muffled <- TRUE
[17:02:51.800]                             break
[17:02:51.800]                           }
[17:02:51.800]                         }
[17:02:51.800]                       }
[17:02:51.800]                       invisible(muffled)
[17:02:51.800]                     }
[17:02:51.800]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.800]                   }
[17:02:51.800]                 }
[17:02:51.800]             }
[17:02:51.800]         }))
[17:02:51.800]     }, error = function(ex) {
[17:02:51.800]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.800]                 ...future.rng), started = ...future.startTime, 
[17:02:51.800]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.800]             version = "1.8"), class = "FutureResult")
[17:02:51.800]     }, finally = {
[17:02:51.800]         if (!identical(...future.workdir, getwd())) 
[17:02:51.800]             setwd(...future.workdir)
[17:02:51.800]         {
[17:02:51.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.800]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.800]             }
[17:02:51.800]             base::options(...future.oldOptions)
[17:02:51.800]             if (.Platform$OS.type == "windows") {
[17:02:51.800]                 old_names <- names(...future.oldEnvVars)
[17:02:51.800]                 envs <- base::Sys.getenv()
[17:02:51.800]                 names <- names(envs)
[17:02:51.800]                 common <- intersect(names, old_names)
[17:02:51.800]                 added <- setdiff(names, old_names)
[17:02:51.800]                 removed <- setdiff(old_names, names)
[17:02:51.800]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.800]                   envs[common]]
[17:02:51.800]                 NAMES <- toupper(changed)
[17:02:51.800]                 args <- list()
[17:02:51.800]                 for (kk in seq_along(NAMES)) {
[17:02:51.800]                   name <- changed[[kk]]
[17:02:51.800]                   NAME <- NAMES[[kk]]
[17:02:51.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.800]                     next
[17:02:51.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.800]                 }
[17:02:51.800]                 NAMES <- toupper(added)
[17:02:51.800]                 for (kk in seq_along(NAMES)) {
[17:02:51.800]                   name <- added[[kk]]
[17:02:51.800]                   NAME <- NAMES[[kk]]
[17:02:51.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.800]                     next
[17:02:51.800]                   args[[name]] <- ""
[17:02:51.800]                 }
[17:02:51.800]                 NAMES <- toupper(removed)
[17:02:51.800]                 for (kk in seq_along(NAMES)) {
[17:02:51.800]                   name <- removed[[kk]]
[17:02:51.800]                   NAME <- NAMES[[kk]]
[17:02:51.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.800]                     next
[17:02:51.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.800]                 }
[17:02:51.800]                 if (length(args) > 0) 
[17:02:51.800]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.800]             }
[17:02:51.800]             else {
[17:02:51.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.800]             }
[17:02:51.800]             {
[17:02:51.800]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.800]                   0L) {
[17:02:51.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.800]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.800]                   base::options(opts)
[17:02:51.800]                 }
[17:02:51.800]                 {
[17:02:51.800]                   {
[17:02:51.800]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.800]                     NULL
[17:02:51.800]                   }
[17:02:51.800]                   options(future.plan = NULL)
[17:02:51.800]                   if (is.na(NA_character_)) 
[17:02:51.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.800]                     .init = FALSE)
[17:02:51.800]                 }
[17:02:51.800]             }
[17:02:51.800]         }
[17:02:51.800]     })
[17:02:51.800]     if (TRUE) {
[17:02:51.800]         base::sink(type = "output", split = FALSE)
[17:02:51.800]         if (TRUE) {
[17:02:51.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.800]         }
[17:02:51.800]         else {
[17:02:51.800]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.800]         }
[17:02:51.800]         base::close(...future.stdout)
[17:02:51.800]         ...future.stdout <- NULL
[17:02:51.800]     }
[17:02:51.800]     ...future.result$conditions <- ...future.conditions
[17:02:51.800]     ...future.result$finished <- base::Sys.time()
[17:02:51.800]     ...future.result
[17:02:51.800] }
[17:02:51.803] requestCore(): workers = 2
[17:02:51.805] MulticoreFuture started
[17:02:51.805] - Launch lazy future ... done
[17:02:51.806] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.806] plan(): Setting new future strategy stack:
[17:02:51.806] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.807] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.806] List of future strategies:
[17:02:51.806] 1. sequential:
[17:02:51.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.806]    - tweaked: FALSE
[17:02:51.806]    - call: NULL
[17:02:51.808] plan(): nbrOfWorkers() = 1
[17:02:51.809] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.809] Searching for globals ... DONE
[17:02:51.809] Resolving globals: TRUE
[17:02:51.809] Resolving any globals that are futures ...
[17:02:51.809] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.810] Resolving any globals that are futures ... DONE
[17:02:51.810] plan(): Setting new future strategy stack:
[17:02:51.810] List of future strategies:
[17:02:51.810] 1. multicore:
[17:02:51.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.810]    - tweaked: FALSE
[17:02:51.810]    - call: plan(strategy)
[17:02:51.810] Resolving futures part of globals (recursively) ...
[17:02:51.811] resolve() on list ...
[17:02:51.811]  recursive: 99
[17:02:51.811]  length: 1
[17:02:51.811]  elements: ‘a’
[17:02:51.815] plan(): nbrOfWorkers() = 2
[17:02:51.815] Future #1
[17:02:51.815] result() for MulticoreFuture ...
[17:02:51.816] result() for MulticoreFuture ...
[17:02:51.817] result() for MulticoreFuture ... done
[17:02:51.817] result() for MulticoreFuture ... done
[17:02:51.817] result() for MulticoreFuture ...
[17:02:51.817] result() for MulticoreFuture ... done
[17:02:51.817] A MulticoreFuture was resolved
[17:02:51.818]  length: 0 (resolved future 1)
[17:02:51.818] resolve() on list ... DONE
[17:02:51.818] - globals: [1] ‘a’
[17:02:51.818] Resolving futures part of globals (recursively) ... DONE
[17:02:51.819] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:02:51.820] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:02:51.820] - globals: [1] ‘a’
[17:02:51.820] - packages: [1] ‘future’
[17:02:51.820] getGlobalsAndPackages() ... DONE
[17:02:51.821] run() for ‘Future’ ...
[17:02:51.821] - state: ‘created’
[17:02:51.821] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.825] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.825]   - Field: ‘label’
[17:02:51.826]   - Field: ‘local’
[17:02:51.826]   - Field: ‘owner’
[17:02:51.826]   - Field: ‘envir’
[17:02:51.826]   - Field: ‘workers’
[17:02:51.826]   - Field: ‘packages’
[17:02:51.826]   - Field: ‘gc’
[17:02:51.826]   - Field: ‘job’
[17:02:51.826]   - Field: ‘conditions’
[17:02:51.827]   - Field: ‘expr’
[17:02:51.827]   - Field: ‘uuid’
[17:02:51.827]   - Field: ‘seed’
[17:02:51.827]   - Field: ‘version’
[17:02:51.827]   - Field: ‘result’
[17:02:51.827]   - Field: ‘asynchronous’
[17:02:51.827]   - Field: ‘calls’
[17:02:51.829]   - Field: ‘globals’
[17:02:51.830]   - Field: ‘stdout’
[17:02:51.830]   - Field: ‘earlySignal’
[17:02:51.830]   - Field: ‘lazy’
[17:02:51.830]   - Field: ‘state’
[17:02:51.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.830] - Launch lazy future ...
[17:02:51.831] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.831] Packages needed by future strategies (n = 0): <none>
[17:02:51.832] {
[17:02:51.832]     {
[17:02:51.832]         {
[17:02:51.832]             ...future.startTime <- base::Sys.time()
[17:02:51.832]             {
[17:02:51.832]                 {
[17:02:51.832]                   {
[17:02:51.832]                     {
[17:02:51.832]                       {
[17:02:51.832]                         base::local({
[17:02:51.832]                           has_future <- base::requireNamespace("future", 
[17:02:51.832]                             quietly = TRUE)
[17:02:51.832]                           if (has_future) {
[17:02:51.832]                             ns <- base::getNamespace("future")
[17:02:51.832]                             version <- ns[[".package"]][["version"]]
[17:02:51.832]                             if (is.null(version)) 
[17:02:51.832]                               version <- utils::packageVersion("future")
[17:02:51.832]                           }
[17:02:51.832]                           else {
[17:02:51.832]                             version <- NULL
[17:02:51.832]                           }
[17:02:51.832]                           if (!has_future || version < "1.8.0") {
[17:02:51.832]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.832]                               "", base::R.version$version.string), 
[17:02:51.832]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:51.832]                                 base::R.version$platform, 8 * 
[17:02:51.832]                                   base::.Machine$sizeof.pointer), 
[17:02:51.832]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.832]                                 "release", "version")], collapse = " "), 
[17:02:51.832]                               hostname = base::Sys.info()[["nodename"]])
[17:02:51.832]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.832]                               info)
[17:02:51.832]                             info <- base::paste(info, collapse = "; ")
[17:02:51.832]                             if (!has_future) {
[17:02:51.832]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.832]                                 info)
[17:02:51.832]                             }
[17:02:51.832]                             else {
[17:02:51.832]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.832]                                 info, version)
[17:02:51.832]                             }
[17:02:51.832]                             base::stop(msg)
[17:02:51.832]                           }
[17:02:51.832]                         })
[17:02:51.832]                       }
[17:02:51.832]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.832]                       base::options(mc.cores = 1L)
[17:02:51.832]                     }
[17:02:51.832]                     base::local({
[17:02:51.832]                       for (pkg in "future") {
[17:02:51.832]                         base::loadNamespace(pkg)
[17:02:51.832]                         base::library(pkg, character.only = TRUE)
[17:02:51.832]                       }
[17:02:51.832]                     })
[17:02:51.832]                   }
[17:02:51.832]                   ...future.strategy.old <- future::plan("list")
[17:02:51.832]                   options(future.plan = NULL)
[17:02:51.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.832]                 }
[17:02:51.832]                 ...future.workdir <- getwd()
[17:02:51.832]             }
[17:02:51.832]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.832]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.832]         }
[17:02:51.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.832]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.832]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.832]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.832]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.832]             base::names(...future.oldOptions))
[17:02:51.832]     }
[17:02:51.832]     if (FALSE) {
[17:02:51.832]     }
[17:02:51.832]     else {
[17:02:51.832]         if (TRUE) {
[17:02:51.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.832]                 open = "w")
[17:02:51.832]         }
[17:02:51.832]         else {
[17:02:51.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.832]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.832]         }
[17:02:51.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.832]             base::sink(type = "output", split = FALSE)
[17:02:51.832]             base::close(...future.stdout)
[17:02:51.832]         }, add = TRUE)
[17:02:51.832]     }
[17:02:51.832]     ...future.frame <- base::sys.nframe()
[17:02:51.832]     ...future.conditions <- base::list()
[17:02:51.832]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.832]     if (FALSE) {
[17:02:51.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.832]     }
[17:02:51.832]     ...future.result <- base::tryCatch({
[17:02:51.832]         base::withCallingHandlers({
[17:02:51.832]             ...future.value <- base::withVisible(base::local({
[17:02:51.832]                 withCallingHandlers({
[17:02:51.832]                   value(a) + 1
[17:02:51.832]                 }, immediateCondition = function(cond) {
[17:02:51.832]                   save_rds <- function (object, pathname, ...) 
[17:02:51.832]                   {
[17:02:51.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.832]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.832]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.832]                         fi_tmp[["mtime"]])
[17:02:51.832]                     }
[17:02:51.832]                     tryCatch({
[17:02:51.832]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.832]                     }, error = function(ex) {
[17:02:51.832]                       msg <- conditionMessage(ex)
[17:02:51.832]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.832]                         fi_tmp[["mtime"]], msg)
[17:02:51.832]                       ex$message <- msg
[17:02:51.832]                       stop(ex)
[17:02:51.832]                     })
[17:02:51.832]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.832]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.832]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.832]                       fi <- file.info(pathname)
[17:02:51.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.832]                         fi[["size"]], fi[["mtime"]])
[17:02:51.832]                       stop(msg)
[17:02:51.832]                     }
[17:02:51.832]                     invisible(pathname)
[17:02:51.832]                   }
[17:02:51.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.832]                     rootPath = tempdir()) 
[17:02:51.832]                   {
[17:02:51.832]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.832]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.832]                       tmpdir = path, fileext = ".rds")
[17:02:51.832]                     save_rds(obj, file)
[17:02:51.832]                   }
[17:02:51.832]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.832]                   {
[17:02:51.832]                     inherits <- base::inherits
[17:02:51.832]                     invokeRestart <- base::invokeRestart
[17:02:51.832]                     is.null <- base::is.null
[17:02:51.832]                     muffled <- FALSE
[17:02:51.832]                     if (inherits(cond, "message")) {
[17:02:51.832]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.832]                       if (muffled) 
[17:02:51.832]                         invokeRestart("muffleMessage")
[17:02:51.832]                     }
[17:02:51.832]                     else if (inherits(cond, "warning")) {
[17:02:51.832]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.832]                       if (muffled) 
[17:02:51.832]                         invokeRestart("muffleWarning")
[17:02:51.832]                     }
[17:02:51.832]                     else if (inherits(cond, "condition")) {
[17:02:51.832]                       if (!is.null(pattern)) {
[17:02:51.832]                         computeRestarts <- base::computeRestarts
[17:02:51.832]                         grepl <- base::grepl
[17:02:51.832]                         restarts <- computeRestarts(cond)
[17:02:51.832]                         for (restart in restarts) {
[17:02:51.832]                           name <- restart$name
[17:02:51.832]                           if (is.null(name)) 
[17:02:51.832]                             next
[17:02:51.832]                           if (!grepl(pattern, name)) 
[17:02:51.832]                             next
[17:02:51.832]                           invokeRestart(restart)
[17:02:51.832]                           muffled <- TRUE
[17:02:51.832]                           break
[17:02:51.832]                         }
[17:02:51.832]                       }
[17:02:51.832]                     }
[17:02:51.832]                     invisible(muffled)
[17:02:51.832]                   }
[17:02:51.832]                   muffleCondition(cond)
[17:02:51.832]                 })
[17:02:51.832]             }))
[17:02:51.832]             future::FutureResult(value = ...future.value$value, 
[17:02:51.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.832]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.832]                     ...future.globalenv.names))
[17:02:51.832]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.832]         }, condition = base::local({
[17:02:51.832]             c <- base::c
[17:02:51.832]             inherits <- base::inherits
[17:02:51.832]             invokeRestart <- base::invokeRestart
[17:02:51.832]             length <- base::length
[17:02:51.832]             list <- base::list
[17:02:51.832]             seq.int <- base::seq.int
[17:02:51.832]             signalCondition <- base::signalCondition
[17:02:51.832]             sys.calls <- base::sys.calls
[17:02:51.832]             `[[` <- base::`[[`
[17:02:51.832]             `+` <- base::`+`
[17:02:51.832]             `<<-` <- base::`<<-`
[17:02:51.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.832]                   3L)]
[17:02:51.832]             }
[17:02:51.832]             function(cond) {
[17:02:51.832]                 is_error <- inherits(cond, "error")
[17:02:51.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.832]                   NULL)
[17:02:51.832]                 if (is_error) {
[17:02:51.832]                   sessionInformation <- function() {
[17:02:51.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.832]                       search = base::search(), system = base::Sys.info())
[17:02:51.832]                   }
[17:02:51.832]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.832]                     cond$call), session = sessionInformation(), 
[17:02:51.832]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.832]                   signalCondition(cond)
[17:02:51.832]                 }
[17:02:51.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.832]                 "immediateCondition"))) {
[17:02:51.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.832]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.832]                   if (TRUE && !signal) {
[17:02:51.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.832]                     {
[17:02:51.832]                       inherits <- base::inherits
[17:02:51.832]                       invokeRestart <- base::invokeRestart
[17:02:51.832]                       is.null <- base::is.null
[17:02:51.832]                       muffled <- FALSE
[17:02:51.832]                       if (inherits(cond, "message")) {
[17:02:51.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.832]                         if (muffled) 
[17:02:51.832]                           invokeRestart("muffleMessage")
[17:02:51.832]                       }
[17:02:51.832]                       else if (inherits(cond, "warning")) {
[17:02:51.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.832]                         if (muffled) 
[17:02:51.832]                           invokeRestart("muffleWarning")
[17:02:51.832]                       }
[17:02:51.832]                       else if (inherits(cond, "condition")) {
[17:02:51.832]                         if (!is.null(pattern)) {
[17:02:51.832]                           computeRestarts <- base::computeRestarts
[17:02:51.832]                           grepl <- base::grepl
[17:02:51.832]                           restarts <- computeRestarts(cond)
[17:02:51.832]                           for (restart in restarts) {
[17:02:51.832]                             name <- restart$name
[17:02:51.832]                             if (is.null(name)) 
[17:02:51.832]                               next
[17:02:51.832]                             if (!grepl(pattern, name)) 
[17:02:51.832]                               next
[17:02:51.832]                             invokeRestart(restart)
[17:02:51.832]                             muffled <- TRUE
[17:02:51.832]                             break
[17:02:51.832]                           }
[17:02:51.832]                         }
[17:02:51.832]                       }
[17:02:51.832]                       invisible(muffled)
[17:02:51.832]                     }
[17:02:51.832]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.832]                   }
[17:02:51.832]                 }
[17:02:51.832]                 else {
[17:02:51.832]                   if (TRUE) {
[17:02:51.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.832]                     {
[17:02:51.832]                       inherits <- base::inherits
[17:02:51.832]                       invokeRestart <- base::invokeRestart
[17:02:51.832]                       is.null <- base::is.null
[17:02:51.832]                       muffled <- FALSE
[17:02:51.832]                       if (inherits(cond, "message")) {
[17:02:51.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.832]                         if (muffled) 
[17:02:51.832]                           invokeRestart("muffleMessage")
[17:02:51.832]                       }
[17:02:51.832]                       else if (inherits(cond, "warning")) {
[17:02:51.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.832]                         if (muffled) 
[17:02:51.832]                           invokeRestart("muffleWarning")
[17:02:51.832]                       }
[17:02:51.832]                       else if (inherits(cond, "condition")) {
[17:02:51.832]                         if (!is.null(pattern)) {
[17:02:51.832]                           computeRestarts <- base::computeRestarts
[17:02:51.832]                           grepl <- base::grepl
[17:02:51.832]                           restarts <- computeRestarts(cond)
[17:02:51.832]                           for (restart in restarts) {
[17:02:51.832]                             name <- restart$name
[17:02:51.832]                             if (is.null(name)) 
[17:02:51.832]                               next
[17:02:51.832]                             if (!grepl(pattern, name)) 
[17:02:51.832]                               next
[17:02:51.832]                             invokeRestart(restart)
[17:02:51.832]                             muffled <- TRUE
[17:02:51.832]                             break
[17:02:51.832]                           }
[17:02:51.832]                         }
[17:02:51.832]                       }
[17:02:51.832]                       invisible(muffled)
[17:02:51.832]                     }
[17:02:51.832]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.832]                   }
[17:02:51.832]                 }
[17:02:51.832]             }
[17:02:51.832]         }))
[17:02:51.832]     }, error = function(ex) {
[17:02:51.832]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.832]                 ...future.rng), started = ...future.startTime, 
[17:02:51.832]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.832]             version = "1.8"), class = "FutureResult")
[17:02:51.832]     }, finally = {
[17:02:51.832]         if (!identical(...future.workdir, getwd())) 
[17:02:51.832]             setwd(...future.workdir)
[17:02:51.832]         {
[17:02:51.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.832]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.832]             }
[17:02:51.832]             base::options(...future.oldOptions)
[17:02:51.832]             if (.Platform$OS.type == "windows") {
[17:02:51.832]                 old_names <- names(...future.oldEnvVars)
[17:02:51.832]                 envs <- base::Sys.getenv()
[17:02:51.832]                 names <- names(envs)
[17:02:51.832]                 common <- intersect(names, old_names)
[17:02:51.832]                 added <- setdiff(names, old_names)
[17:02:51.832]                 removed <- setdiff(old_names, names)
[17:02:51.832]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.832]                   envs[common]]
[17:02:51.832]                 NAMES <- toupper(changed)
[17:02:51.832]                 args <- list()
[17:02:51.832]                 for (kk in seq_along(NAMES)) {
[17:02:51.832]                   name <- changed[[kk]]
[17:02:51.832]                   NAME <- NAMES[[kk]]
[17:02:51.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.832]                     next
[17:02:51.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.832]                 }
[17:02:51.832]                 NAMES <- toupper(added)
[17:02:51.832]                 for (kk in seq_along(NAMES)) {
[17:02:51.832]                   name <- added[[kk]]
[17:02:51.832]                   NAME <- NAMES[[kk]]
[17:02:51.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.832]                     next
[17:02:51.832]                   args[[name]] <- ""
[17:02:51.832]                 }
[17:02:51.832]                 NAMES <- toupper(removed)
[17:02:51.832]                 for (kk in seq_along(NAMES)) {
[17:02:51.832]                   name <- removed[[kk]]
[17:02:51.832]                   NAME <- NAMES[[kk]]
[17:02:51.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.832]                     next
[17:02:51.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.832]                 }
[17:02:51.832]                 if (length(args) > 0) 
[17:02:51.832]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.832]             }
[17:02:51.832]             else {
[17:02:51.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.832]             }
[17:02:51.832]             {
[17:02:51.832]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.832]                   0L) {
[17:02:51.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.832]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.832]                   base::options(opts)
[17:02:51.832]                 }
[17:02:51.832]                 {
[17:02:51.832]                   {
[17:02:51.832]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.832]                     NULL
[17:02:51.832]                   }
[17:02:51.832]                   options(future.plan = NULL)
[17:02:51.832]                   if (is.na(NA_character_)) 
[17:02:51.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.832]                     .init = FALSE)
[17:02:51.832]                 }
[17:02:51.832]             }
[17:02:51.832]         }
[17:02:51.832]     })
[17:02:51.832]     if (TRUE) {
[17:02:51.832]         base::sink(type = "output", split = FALSE)
[17:02:51.832]         if (TRUE) {
[17:02:51.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.832]         }
[17:02:51.832]         else {
[17:02:51.832]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.832]         }
[17:02:51.832]         base::close(...future.stdout)
[17:02:51.832]         ...future.stdout <- NULL
[17:02:51.832]     }
[17:02:51.832]     ...future.result$conditions <- ...future.conditions
[17:02:51.832]     ...future.result$finished <- base::Sys.time()
[17:02:51.832]     ...future.result
[17:02:51.832] }
[17:02:51.835] assign_globals() ...
[17:02:51.835] List of 1
[17:02:51.835]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f49495c0> 
[17:02:51.835]  - attr(*, "where")=List of 1
[17:02:51.835]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.835]  - attr(*, "resolved")= logi TRUE
[17:02:51.835]  - attr(*, "total_size")= num 10816
[17:02:51.835]  - attr(*, "already-done")= logi TRUE
[17:02:51.838] - copied ‘a’ to environment
[17:02:51.838] assign_globals() ... done
[17:02:51.838] requestCore(): workers = 2
[17:02:51.840] MulticoreFuture started
[17:02:51.841] - Launch lazy future ... done
[17:02:51.841] run() for ‘MulticoreFuture’ ... done
[17:02:51.841] result() for MulticoreFuture ...
[17:02:51.842] plan(): Setting new future strategy stack:
[17:02:51.842] List of future strategies:
[17:02:51.842] 1. sequential:
[17:02:51.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.842]    - tweaked: FALSE
[17:02:51.842]    - call: NULL
[17:02:51.843] plan(): nbrOfWorkers() = 1
[17:02:51.847] plan(): Setting new future strategy stack:
[17:02:51.847] List of future strategies:
[17:02:51.847] 1. multicore:
[17:02:51.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.847]    - tweaked: FALSE
[17:02:51.847]    - call: plan(strategy)
[17:02:51.853] plan(): nbrOfWorkers() = 2
[17:02:51.854] result() for MulticoreFuture ...
[17:02:51.854] result() for MulticoreFuture ... done
[17:02:51.854] signalConditions() ...
[17:02:51.854]  - include = ‘immediateCondition’
[17:02:51.854]  - exclude = 
[17:02:51.854]  - resignal = FALSE
[17:02:51.855]  - Number of conditions: 4
[17:02:51.855] signalConditions() ... done
[17:02:51.855] result() for MulticoreFuture ... done
[17:02:51.855] result() for MulticoreFuture ...
[17:02:51.855] result() for MulticoreFuture ... done
[17:02:51.855] signalConditions() ...
[17:02:51.855]  - include = ‘immediateCondition’
[17:02:51.856]  - exclude = 
[17:02:51.856]  - resignal = FALSE
[17:02:51.856]  - Number of conditions: 4
[17:02:51.856] signalConditions() ... done
[17:02:51.856] Future state: ‘finished’
[17:02:51.856] result() for MulticoreFuture ...
[17:02:51.856] result() for MulticoreFuture ... done
[17:02:51.857] signalConditions() ...
[17:02:51.857]  - include = ‘condition’
[17:02:51.857]  - exclude = ‘immediateCondition’
[17:02:51.857]  - resignal = TRUE
[17:02:51.857]  - Number of conditions: 4
[17:02:51.857]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.844] result() for MulticoreFuture ...
[17:02:51.857]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.845] result() for MulticoreFuture ... done
[17:02:51.857]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.845] result() for MulticoreFuture ...
[17:02:51.858]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.845] result() for MulticoreFuture ... done
[17:02:51.858] signalConditions() ... done
value(b) = 2
[17:02:51.858] result() for MulticoreFuture ...
[17:02:51.858] result() for MulticoreFuture ... done
[17:02:51.858] result() for MulticoreFuture ...
[17:02:51.858] result() for MulticoreFuture ... done
[17:02:51.858] signalConditions() ...
[17:02:51.858]  - include = ‘immediateCondition’
[17:02:51.859]  - exclude = 
[17:02:51.859]  - resignal = FALSE
[17:02:51.859]  - Number of conditions: 4
[17:02:51.859] signalConditions() ... done
[17:02:51.859] Future state: ‘finished’
[17:02:51.859] result() for MulticoreFuture ...
[17:02:51.859] result() for MulticoreFuture ... done
[17:02:51.859] signalConditions() ...
[17:02:51.860]  - include = ‘condition’
[17:02:51.860]  - exclude = ‘immediateCondition’
[17:02:51.860]  - resignal = TRUE
[17:02:51.860]  - Number of conditions: 4
[17:02:51.860]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.844] result() for MulticoreFuture ...
[17:02:51.860]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.845] result() for MulticoreFuture ... done
[17:02:51.860]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.845] result() for MulticoreFuture ...
[17:02:51.860]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.845] result() for MulticoreFuture ... done
[17:02:51.861] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.861] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.861] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.862] 
[17:02:51.862] Searching for globals ... DONE
[17:02:51.862] - globals: [0] <none>
[17:02:51.862] getGlobalsAndPackages() ... DONE
[17:02:51.863] run() for ‘Future’ ...
[17:02:51.863] - state: ‘created’
[17:02:51.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.868]   - Field: ‘label’
[17:02:51.868]   - Field: ‘local’
[17:02:51.868]   - Field: ‘owner’
[17:02:51.868]   - Field: ‘envir’
[17:02:51.868]   - Field: ‘workers’
[17:02:51.868]   - Field: ‘packages’
[17:02:51.868]   - Field: ‘gc’
[17:02:51.868]   - Field: ‘job’
[17:02:51.869]   - Field: ‘conditions’
[17:02:51.869]   - Field: ‘expr’
[17:02:51.869]   - Field: ‘uuid’
[17:02:51.869]   - Field: ‘seed’
[17:02:51.869]   - Field: ‘version’
[17:02:51.869]   - Field: ‘result’
[17:02:51.869]   - Field: ‘asynchronous’
[17:02:51.869]   - Field: ‘calls’
[17:02:51.869]   - Field: ‘globals’
[17:02:51.870]   - Field: ‘stdout’
[17:02:51.870]   - Field: ‘earlySignal’
[17:02:51.870]   - Field: ‘lazy’
[17:02:51.870]   - Field: ‘state’
[17:02:51.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.870] - Launch lazy future ...
[17:02:51.870] Packages needed by the future expression (n = 0): <none>
[17:02:51.871] Packages needed by future strategies (n = 0): <none>
[17:02:51.871] {
[17:02:51.871]     {
[17:02:51.871]         {
[17:02:51.871]             ...future.startTime <- base::Sys.time()
[17:02:51.871]             {
[17:02:51.871]                 {
[17:02:51.871]                   {
[17:02:51.871]                     {
[17:02:51.871]                       base::local({
[17:02:51.871]                         has_future <- base::requireNamespace("future", 
[17:02:51.871]                           quietly = TRUE)
[17:02:51.871]                         if (has_future) {
[17:02:51.871]                           ns <- base::getNamespace("future")
[17:02:51.871]                           version <- ns[[".package"]][["version"]]
[17:02:51.871]                           if (is.null(version)) 
[17:02:51.871]                             version <- utils::packageVersion("future")
[17:02:51.871]                         }
[17:02:51.871]                         else {
[17:02:51.871]                           version <- NULL
[17:02:51.871]                         }
[17:02:51.871]                         if (!has_future || version < "1.8.0") {
[17:02:51.871]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.871]                             "", base::R.version$version.string), 
[17:02:51.871]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.871]                               "release", "version")], collapse = " "), 
[17:02:51.871]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.871]                             info)
[17:02:51.871]                           info <- base::paste(info, collapse = "; ")
[17:02:51.871]                           if (!has_future) {
[17:02:51.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.871]                               info)
[17:02:51.871]                           }
[17:02:51.871]                           else {
[17:02:51.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.871]                               info, version)
[17:02:51.871]                           }
[17:02:51.871]                           base::stop(msg)
[17:02:51.871]                         }
[17:02:51.871]                       })
[17:02:51.871]                     }
[17:02:51.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.871]                     base::options(mc.cores = 1L)
[17:02:51.871]                   }
[17:02:51.871]                   ...future.strategy.old <- future::plan("list")
[17:02:51.871]                   options(future.plan = NULL)
[17:02:51.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.871]                 }
[17:02:51.871]                 ...future.workdir <- getwd()
[17:02:51.871]             }
[17:02:51.871]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.871]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.871]         }
[17:02:51.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.871]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.871]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.871]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.871]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.871]             base::names(...future.oldOptions))
[17:02:51.871]     }
[17:02:51.871]     if (FALSE) {
[17:02:51.871]     }
[17:02:51.871]     else {
[17:02:51.871]         if (TRUE) {
[17:02:51.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.871]                 open = "w")
[17:02:51.871]         }
[17:02:51.871]         else {
[17:02:51.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.871]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.871]         }
[17:02:51.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.871]             base::sink(type = "output", split = FALSE)
[17:02:51.871]             base::close(...future.stdout)
[17:02:51.871]         }, add = TRUE)
[17:02:51.871]     }
[17:02:51.871]     ...future.frame <- base::sys.nframe()
[17:02:51.871]     ...future.conditions <- base::list()
[17:02:51.871]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.871]     if (FALSE) {
[17:02:51.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.871]     }
[17:02:51.871]     ...future.result <- base::tryCatch({
[17:02:51.871]         base::withCallingHandlers({
[17:02:51.871]             ...future.value <- base::withVisible(base::local({
[17:02:51.871]                 withCallingHandlers({
[17:02:51.871]                   1
[17:02:51.871]                 }, immediateCondition = function(cond) {
[17:02:51.871]                   save_rds <- function (object, pathname, ...) 
[17:02:51.871]                   {
[17:02:51.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.871]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.871]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.871]                         fi_tmp[["mtime"]])
[17:02:51.871]                     }
[17:02:51.871]                     tryCatch({
[17:02:51.871]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.871]                     }, error = function(ex) {
[17:02:51.871]                       msg <- conditionMessage(ex)
[17:02:51.871]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.871]                         fi_tmp[["mtime"]], msg)
[17:02:51.871]                       ex$message <- msg
[17:02:51.871]                       stop(ex)
[17:02:51.871]                     })
[17:02:51.871]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.871]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.871]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.871]                       fi <- file.info(pathname)
[17:02:51.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.871]                         fi[["size"]], fi[["mtime"]])
[17:02:51.871]                       stop(msg)
[17:02:51.871]                     }
[17:02:51.871]                     invisible(pathname)
[17:02:51.871]                   }
[17:02:51.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.871]                     rootPath = tempdir()) 
[17:02:51.871]                   {
[17:02:51.871]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.871]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.871]                       tmpdir = path, fileext = ".rds")
[17:02:51.871]                     save_rds(obj, file)
[17:02:51.871]                   }
[17:02:51.871]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.871]                   {
[17:02:51.871]                     inherits <- base::inherits
[17:02:51.871]                     invokeRestart <- base::invokeRestart
[17:02:51.871]                     is.null <- base::is.null
[17:02:51.871]                     muffled <- FALSE
[17:02:51.871]                     if (inherits(cond, "message")) {
[17:02:51.871]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.871]                       if (muffled) 
[17:02:51.871]                         invokeRestart("muffleMessage")
[17:02:51.871]                     }
[17:02:51.871]                     else if (inherits(cond, "warning")) {
[17:02:51.871]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.871]                       if (muffled) 
[17:02:51.871]                         invokeRestart("muffleWarning")
[17:02:51.871]                     }
[17:02:51.871]                     else if (inherits(cond, "condition")) {
[17:02:51.871]                       if (!is.null(pattern)) {
[17:02:51.871]                         computeRestarts <- base::computeRestarts
[17:02:51.871]                         grepl <- base::grepl
[17:02:51.871]                         restarts <- computeRestarts(cond)
[17:02:51.871]                         for (restart in restarts) {
[17:02:51.871]                           name <- restart$name
[17:02:51.871]                           if (is.null(name)) 
[17:02:51.871]                             next
[17:02:51.871]                           if (!grepl(pattern, name)) 
[17:02:51.871]                             next
[17:02:51.871]                           invokeRestart(restart)
[17:02:51.871]                           muffled <- TRUE
[17:02:51.871]                           break
[17:02:51.871]                         }
[17:02:51.871]                       }
[17:02:51.871]                     }
[17:02:51.871]                     invisible(muffled)
[17:02:51.871]                   }
[17:02:51.871]                   muffleCondition(cond)
[17:02:51.871]                 })
[17:02:51.871]             }))
[17:02:51.871]             future::FutureResult(value = ...future.value$value, 
[17:02:51.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.871]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.871]                     ...future.globalenv.names))
[17:02:51.871]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.871]         }, condition = base::local({
[17:02:51.871]             c <- base::c
[17:02:51.871]             inherits <- base::inherits
[17:02:51.871]             invokeRestart <- base::invokeRestart
[17:02:51.871]             length <- base::length
[17:02:51.871]             list <- base::list
[17:02:51.871]             seq.int <- base::seq.int
[17:02:51.871]             signalCondition <- base::signalCondition
[17:02:51.871]             sys.calls <- base::sys.calls
[17:02:51.871]             `[[` <- base::`[[`
[17:02:51.871]             `+` <- base::`+`
[17:02:51.871]             `<<-` <- base::`<<-`
[17:02:51.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.871]                   3L)]
[17:02:51.871]             }
[17:02:51.871]             function(cond) {
[17:02:51.871]                 is_error <- inherits(cond, "error")
[17:02:51.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.871]                   NULL)
[17:02:51.871]                 if (is_error) {
[17:02:51.871]                   sessionInformation <- function() {
[17:02:51.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.871]                       search = base::search(), system = base::Sys.info())
[17:02:51.871]                   }
[17:02:51.871]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.871]                     cond$call), session = sessionInformation(), 
[17:02:51.871]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.871]                   signalCondition(cond)
[17:02:51.871]                 }
[17:02:51.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.871]                 "immediateCondition"))) {
[17:02:51.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.871]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.871]                   if (TRUE && !signal) {
[17:02:51.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.871]                     {
[17:02:51.871]                       inherits <- base::inherits
[17:02:51.871]                       invokeRestart <- base::invokeRestart
[17:02:51.871]                       is.null <- base::is.null
[17:02:51.871]                       muffled <- FALSE
[17:02:51.871]                       if (inherits(cond, "message")) {
[17:02:51.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.871]                         if (muffled) 
[17:02:51.871]                           invokeRestart("muffleMessage")
[17:02:51.871]                       }
[17:02:51.871]                       else if (inherits(cond, "warning")) {
[17:02:51.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.871]                         if (muffled) 
[17:02:51.871]                           invokeRestart("muffleWarning")
[17:02:51.871]                       }
[17:02:51.871]                       else if (inherits(cond, "condition")) {
[17:02:51.871]                         if (!is.null(pattern)) {
[17:02:51.871]                           computeRestarts <- base::computeRestarts
[17:02:51.871]                           grepl <- base::grepl
[17:02:51.871]                           restarts <- computeRestarts(cond)
[17:02:51.871]                           for (restart in restarts) {
[17:02:51.871]                             name <- restart$name
[17:02:51.871]                             if (is.null(name)) 
[17:02:51.871]                               next
[17:02:51.871]                             if (!grepl(pattern, name)) 
[17:02:51.871]                               next
[17:02:51.871]                             invokeRestart(restart)
[17:02:51.871]                             muffled <- TRUE
[17:02:51.871]                             break
[17:02:51.871]                           }
[17:02:51.871]                         }
[17:02:51.871]                       }
[17:02:51.871]                       invisible(muffled)
[17:02:51.871]                     }
[17:02:51.871]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.871]                   }
[17:02:51.871]                 }
[17:02:51.871]                 else {
[17:02:51.871]                   if (TRUE) {
[17:02:51.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.871]                     {
[17:02:51.871]                       inherits <- base::inherits
[17:02:51.871]                       invokeRestart <- base::invokeRestart
[17:02:51.871]                       is.null <- base::is.null
[17:02:51.871]                       muffled <- FALSE
[17:02:51.871]                       if (inherits(cond, "message")) {
[17:02:51.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.871]                         if (muffled) 
[17:02:51.871]                           invokeRestart("muffleMessage")
[17:02:51.871]                       }
[17:02:51.871]                       else if (inherits(cond, "warning")) {
[17:02:51.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.871]                         if (muffled) 
[17:02:51.871]                           invokeRestart("muffleWarning")
[17:02:51.871]                       }
[17:02:51.871]                       else if (inherits(cond, "condition")) {
[17:02:51.871]                         if (!is.null(pattern)) {
[17:02:51.871]                           computeRestarts <- base::computeRestarts
[17:02:51.871]                           grepl <- base::grepl
[17:02:51.871]                           restarts <- computeRestarts(cond)
[17:02:51.871]                           for (restart in restarts) {
[17:02:51.871]                             name <- restart$name
[17:02:51.871]                             if (is.null(name)) 
[17:02:51.871]                               next
[17:02:51.871]                             if (!grepl(pattern, name)) 
[17:02:51.871]                               next
[17:02:51.871]                             invokeRestart(restart)
[17:02:51.871]                             muffled <- TRUE
[17:02:51.871]                             break
[17:02:51.871]                           }
[17:02:51.871]                         }
[17:02:51.871]                       }
[17:02:51.871]                       invisible(muffled)
[17:02:51.871]                     }
[17:02:51.871]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.871]                   }
[17:02:51.871]                 }
[17:02:51.871]             }
[17:02:51.871]         }))
[17:02:51.871]     }, error = function(ex) {
[17:02:51.871]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.871]                 ...future.rng), started = ...future.startTime, 
[17:02:51.871]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.871]             version = "1.8"), class = "FutureResult")
[17:02:51.871]     }, finally = {
[17:02:51.871]         if (!identical(...future.workdir, getwd())) 
[17:02:51.871]             setwd(...future.workdir)
[17:02:51.871]         {
[17:02:51.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.871]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.871]             }
[17:02:51.871]             base::options(...future.oldOptions)
[17:02:51.871]             if (.Platform$OS.type == "windows") {
[17:02:51.871]                 old_names <- names(...future.oldEnvVars)
[17:02:51.871]                 envs <- base::Sys.getenv()
[17:02:51.871]                 names <- names(envs)
[17:02:51.871]                 common <- intersect(names, old_names)
[17:02:51.871]                 added <- setdiff(names, old_names)
[17:02:51.871]                 removed <- setdiff(old_names, names)
[17:02:51.871]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.871]                   envs[common]]
[17:02:51.871]                 NAMES <- toupper(changed)
[17:02:51.871]                 args <- list()
[17:02:51.871]                 for (kk in seq_along(NAMES)) {
[17:02:51.871]                   name <- changed[[kk]]
[17:02:51.871]                   NAME <- NAMES[[kk]]
[17:02:51.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.871]                     next
[17:02:51.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.871]                 }
[17:02:51.871]                 NAMES <- toupper(added)
[17:02:51.871]                 for (kk in seq_along(NAMES)) {
[17:02:51.871]                   name <- added[[kk]]
[17:02:51.871]                   NAME <- NAMES[[kk]]
[17:02:51.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.871]                     next
[17:02:51.871]                   args[[name]] <- ""
[17:02:51.871]                 }
[17:02:51.871]                 NAMES <- toupper(removed)
[17:02:51.871]                 for (kk in seq_along(NAMES)) {
[17:02:51.871]                   name <- removed[[kk]]
[17:02:51.871]                   NAME <- NAMES[[kk]]
[17:02:51.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.871]                     next
[17:02:51.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.871]                 }
[17:02:51.871]                 if (length(args) > 0) 
[17:02:51.871]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.871]             }
[17:02:51.871]             else {
[17:02:51.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.871]             }
[17:02:51.871]             {
[17:02:51.871]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.871]                   0L) {
[17:02:51.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.871]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.871]                   base::options(opts)
[17:02:51.871]                 }
[17:02:51.871]                 {
[17:02:51.871]                   {
[17:02:51.871]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.871]                     NULL
[17:02:51.871]                   }
[17:02:51.871]                   options(future.plan = NULL)
[17:02:51.871]                   if (is.na(NA_character_)) 
[17:02:51.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.871]                     .init = FALSE)
[17:02:51.871]                 }
[17:02:51.871]             }
[17:02:51.871]         }
[17:02:51.871]     })
[17:02:51.871]     if (TRUE) {
[17:02:51.871]         base::sink(type = "output", split = FALSE)
[17:02:51.871]         if (TRUE) {
[17:02:51.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.871]         }
[17:02:51.871]         else {
[17:02:51.871]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.871]         }
[17:02:51.871]         base::close(...future.stdout)
[17:02:51.871]         ...future.stdout <- NULL
[17:02:51.871]     }
[17:02:51.871]     ...future.result$conditions <- ...future.conditions
[17:02:51.871]     ...future.result$finished <- base::Sys.time()
[17:02:51.871]     ...future.result
[17:02:51.871] }
[17:02:51.874] requestCore(): workers = 2
[17:02:51.876] MulticoreFuture started
[17:02:51.876] - Launch lazy future ... done
[17:02:51.877] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.877] plan(): Setting new future strategy stack:
[17:02:51.877] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.877] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.877] List of future strategies:
[17:02:51.877] 1. sequential:
[17:02:51.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.877]    - tweaked: FALSE
[17:02:51.877]    - call: NULL
[17:02:51.878] plan(): nbrOfWorkers() = 1
[17:02:51.880] plan(): Setting new future strategy stack:
[17:02:51.880] List of future strategies:
[17:02:51.880] 1. multicore:
[17:02:51.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.880]    - tweaked: FALSE
[17:02:51.880]    - call: plan(strategy)
[17:02:51.879] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.884] Searching for globals ... DONE
[17:02:51.884] Resolving globals: TRUE
[17:02:51.885] Resolving any globals that are futures ...
[17:02:51.885] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.886] Resolving any globals that are futures ... DONE
[17:02:51.887] Resolving futures part of globals (recursively) ...
[17:02:51.888] resolve() on list ...
[17:02:51.888] plan(): nbrOfWorkers() = 2
[17:02:51.888]  recursive: 99
[17:02:51.889]  length: 1
[17:02:51.889]  elements: ‘a’
[17:02:51.890] Future #1
[17:02:51.890] result() for MulticoreFuture ...
[17:02:51.891] result() for MulticoreFuture ...
[17:02:51.891] result() for MulticoreFuture ... done
[17:02:51.892] result() for MulticoreFuture ... done
[17:02:51.892] result() for MulticoreFuture ...
[17:02:51.892] result() for MulticoreFuture ... done
[17:02:51.892] A MulticoreFuture was resolved
[17:02:51.892]  length: 0 (resolved future 1)
[17:02:51.893] resolve() on list ... DONE
[17:02:51.893] - globals: [1] ‘a’
[17:02:51.893] Resolving futures part of globals (recursively) ... DONE
[17:02:51.894] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:02:51.895] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:02:51.895] - globals: [1] ‘a’
[17:02:51.895] - packages: [1] ‘future’
[17:02:51.895] getGlobalsAndPackages() ... DONE
[17:02:51.895] run() for ‘Future’ ...
[17:02:51.896] - state: ‘created’
[17:02:51.896] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.900]   - Field: ‘label’
[17:02:51.900]   - Field: ‘local’
[17:02:51.900]   - Field: ‘owner’
[17:02:51.901]   - Field: ‘envir’
[17:02:51.901]   - Field: ‘workers’
[17:02:51.901]   - Field: ‘packages’
[17:02:51.901]   - Field: ‘gc’
[17:02:51.901]   - Field: ‘job’
[17:02:51.901]   - Field: ‘conditions’
[17:02:51.901]   - Field: ‘expr’
[17:02:51.902]   - Field: ‘uuid’
[17:02:51.902]   - Field: ‘seed’
[17:02:51.902]   - Field: ‘version’
[17:02:51.902]   - Field: ‘result’
[17:02:51.902]   - Field: ‘asynchronous’
[17:02:51.902]   - Field: ‘calls’
[17:02:51.902]   - Field: ‘globals’
[17:02:51.903]   - Field: ‘stdout’
[17:02:51.903]   - Field: ‘earlySignal’
[17:02:51.903]   - Field: ‘lazy’
[17:02:51.903]   - Field: ‘state’
[17:02:51.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.903] - Launch lazy future ...
[17:02:51.904] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.904] Packages needed by future strategies (n = 0): <none>
[17:02:51.904] {
[17:02:51.904]     {
[17:02:51.904]         {
[17:02:51.904]             ...future.startTime <- base::Sys.time()
[17:02:51.904]             {
[17:02:51.904]                 {
[17:02:51.904]                   {
[17:02:51.904]                     {
[17:02:51.904]                       {
[17:02:51.904]                         base::local({
[17:02:51.904]                           has_future <- base::requireNamespace("future", 
[17:02:51.904]                             quietly = TRUE)
[17:02:51.904]                           if (has_future) {
[17:02:51.904]                             ns <- base::getNamespace("future")
[17:02:51.904]                             version <- ns[[".package"]][["version"]]
[17:02:51.904]                             if (is.null(version)) 
[17:02:51.904]                               version <- utils::packageVersion("future")
[17:02:51.904]                           }
[17:02:51.904]                           else {
[17:02:51.904]                             version <- NULL
[17:02:51.904]                           }
[17:02:51.904]                           if (!has_future || version < "1.8.0") {
[17:02:51.904]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.904]                               "", base::R.version$version.string), 
[17:02:51.904]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:51.904]                                 base::R.version$platform, 8 * 
[17:02:51.904]                                   base::.Machine$sizeof.pointer), 
[17:02:51.904]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.904]                                 "release", "version")], collapse = " "), 
[17:02:51.904]                               hostname = base::Sys.info()[["nodename"]])
[17:02:51.904]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.904]                               info)
[17:02:51.904]                             info <- base::paste(info, collapse = "; ")
[17:02:51.904]                             if (!has_future) {
[17:02:51.904]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.904]                                 info)
[17:02:51.904]                             }
[17:02:51.904]                             else {
[17:02:51.904]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.904]                                 info, version)
[17:02:51.904]                             }
[17:02:51.904]                             base::stop(msg)
[17:02:51.904]                           }
[17:02:51.904]                         })
[17:02:51.904]                       }
[17:02:51.904]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.904]                       base::options(mc.cores = 1L)
[17:02:51.904]                     }
[17:02:51.904]                     base::local({
[17:02:51.904]                       for (pkg in "future") {
[17:02:51.904]                         base::loadNamespace(pkg)
[17:02:51.904]                         base::library(pkg, character.only = TRUE)
[17:02:51.904]                       }
[17:02:51.904]                     })
[17:02:51.904]                   }
[17:02:51.904]                   ...future.strategy.old <- future::plan("list")
[17:02:51.904]                   options(future.plan = NULL)
[17:02:51.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.904]                 }
[17:02:51.904]                 ...future.workdir <- getwd()
[17:02:51.904]             }
[17:02:51.904]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.904]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.904]         }
[17:02:51.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.904]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.904]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.904]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.904]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.904]             base::names(...future.oldOptions))
[17:02:51.904]     }
[17:02:51.904]     if (FALSE) {
[17:02:51.904]     }
[17:02:51.904]     else {
[17:02:51.904]         if (TRUE) {
[17:02:51.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.904]                 open = "w")
[17:02:51.904]         }
[17:02:51.904]         else {
[17:02:51.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.904]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.904]         }
[17:02:51.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.904]             base::sink(type = "output", split = FALSE)
[17:02:51.904]             base::close(...future.stdout)
[17:02:51.904]         }, add = TRUE)
[17:02:51.904]     }
[17:02:51.904]     ...future.frame <- base::sys.nframe()
[17:02:51.904]     ...future.conditions <- base::list()
[17:02:51.904]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.904]     if (FALSE) {
[17:02:51.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.904]     }
[17:02:51.904]     ...future.result <- base::tryCatch({
[17:02:51.904]         base::withCallingHandlers({
[17:02:51.904]             ...future.value <- base::withVisible(base::local({
[17:02:51.904]                 withCallingHandlers({
[17:02:51.904]                   value(a) + 1
[17:02:51.904]                 }, immediateCondition = function(cond) {
[17:02:51.904]                   save_rds <- function (object, pathname, ...) 
[17:02:51.904]                   {
[17:02:51.904]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.904]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.904]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.904]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.904]                         fi_tmp[["mtime"]])
[17:02:51.904]                     }
[17:02:51.904]                     tryCatch({
[17:02:51.904]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.904]                     }, error = function(ex) {
[17:02:51.904]                       msg <- conditionMessage(ex)
[17:02:51.904]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.904]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.904]                         fi_tmp[["mtime"]], msg)
[17:02:51.904]                       ex$message <- msg
[17:02:51.904]                       stop(ex)
[17:02:51.904]                     })
[17:02:51.904]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.904]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.904]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.904]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.904]                       fi <- file.info(pathname)
[17:02:51.904]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.904]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.904]                         fi[["size"]], fi[["mtime"]])
[17:02:51.904]                       stop(msg)
[17:02:51.904]                     }
[17:02:51.904]                     invisible(pathname)
[17:02:51.904]                   }
[17:02:51.904]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.904]                     rootPath = tempdir()) 
[17:02:51.904]                   {
[17:02:51.904]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.904]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.904]                       tmpdir = path, fileext = ".rds")
[17:02:51.904]                     save_rds(obj, file)
[17:02:51.904]                   }
[17:02:51.904]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.904]                   {
[17:02:51.904]                     inherits <- base::inherits
[17:02:51.904]                     invokeRestart <- base::invokeRestart
[17:02:51.904]                     is.null <- base::is.null
[17:02:51.904]                     muffled <- FALSE
[17:02:51.904]                     if (inherits(cond, "message")) {
[17:02:51.904]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.904]                       if (muffled) 
[17:02:51.904]                         invokeRestart("muffleMessage")
[17:02:51.904]                     }
[17:02:51.904]                     else if (inherits(cond, "warning")) {
[17:02:51.904]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.904]                       if (muffled) 
[17:02:51.904]                         invokeRestart("muffleWarning")
[17:02:51.904]                     }
[17:02:51.904]                     else if (inherits(cond, "condition")) {
[17:02:51.904]                       if (!is.null(pattern)) {
[17:02:51.904]                         computeRestarts <- base::computeRestarts
[17:02:51.904]                         grepl <- base::grepl
[17:02:51.904]                         restarts <- computeRestarts(cond)
[17:02:51.904]                         for (restart in restarts) {
[17:02:51.904]                           name <- restart$name
[17:02:51.904]                           if (is.null(name)) 
[17:02:51.904]                             next
[17:02:51.904]                           if (!grepl(pattern, name)) 
[17:02:51.904]                             next
[17:02:51.904]                           invokeRestart(restart)
[17:02:51.904]                           muffled <- TRUE
[17:02:51.904]                           break
[17:02:51.904]                         }
[17:02:51.904]                       }
[17:02:51.904]                     }
[17:02:51.904]                     invisible(muffled)
[17:02:51.904]                   }
[17:02:51.904]                   muffleCondition(cond)
[17:02:51.904]                 })
[17:02:51.904]             }))
[17:02:51.904]             future::FutureResult(value = ...future.value$value, 
[17:02:51.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.904]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.904]                     ...future.globalenv.names))
[17:02:51.904]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.904]         }, condition = base::local({
[17:02:51.904]             c <- base::c
[17:02:51.904]             inherits <- base::inherits
[17:02:51.904]             invokeRestart <- base::invokeRestart
[17:02:51.904]             length <- base::length
[17:02:51.904]             list <- base::list
[17:02:51.904]             seq.int <- base::seq.int
[17:02:51.904]             signalCondition <- base::signalCondition
[17:02:51.904]             sys.calls <- base::sys.calls
[17:02:51.904]             `[[` <- base::`[[`
[17:02:51.904]             `+` <- base::`+`
[17:02:51.904]             `<<-` <- base::`<<-`
[17:02:51.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.904]                   3L)]
[17:02:51.904]             }
[17:02:51.904]             function(cond) {
[17:02:51.904]                 is_error <- inherits(cond, "error")
[17:02:51.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.904]                   NULL)
[17:02:51.904]                 if (is_error) {
[17:02:51.904]                   sessionInformation <- function() {
[17:02:51.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.904]                       search = base::search(), system = base::Sys.info())
[17:02:51.904]                   }
[17:02:51.904]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.904]                     cond$call), session = sessionInformation(), 
[17:02:51.904]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.904]                   signalCondition(cond)
[17:02:51.904]                 }
[17:02:51.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.904]                 "immediateCondition"))) {
[17:02:51.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.904]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.904]                   if (TRUE && !signal) {
[17:02:51.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.904]                     {
[17:02:51.904]                       inherits <- base::inherits
[17:02:51.904]                       invokeRestart <- base::invokeRestart
[17:02:51.904]                       is.null <- base::is.null
[17:02:51.904]                       muffled <- FALSE
[17:02:51.904]                       if (inherits(cond, "message")) {
[17:02:51.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.904]                         if (muffled) 
[17:02:51.904]                           invokeRestart("muffleMessage")
[17:02:51.904]                       }
[17:02:51.904]                       else if (inherits(cond, "warning")) {
[17:02:51.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.904]                         if (muffled) 
[17:02:51.904]                           invokeRestart("muffleWarning")
[17:02:51.904]                       }
[17:02:51.904]                       else if (inherits(cond, "condition")) {
[17:02:51.904]                         if (!is.null(pattern)) {
[17:02:51.904]                           computeRestarts <- base::computeRestarts
[17:02:51.904]                           grepl <- base::grepl
[17:02:51.904]                           restarts <- computeRestarts(cond)
[17:02:51.904]                           for (restart in restarts) {
[17:02:51.904]                             name <- restart$name
[17:02:51.904]                             if (is.null(name)) 
[17:02:51.904]                               next
[17:02:51.904]                             if (!grepl(pattern, name)) 
[17:02:51.904]                               next
[17:02:51.904]                             invokeRestart(restart)
[17:02:51.904]                             muffled <- TRUE
[17:02:51.904]                             break
[17:02:51.904]                           }
[17:02:51.904]                         }
[17:02:51.904]                       }
[17:02:51.904]                       invisible(muffled)
[17:02:51.904]                     }
[17:02:51.904]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.904]                   }
[17:02:51.904]                 }
[17:02:51.904]                 else {
[17:02:51.904]                   if (TRUE) {
[17:02:51.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.904]                     {
[17:02:51.904]                       inherits <- base::inherits
[17:02:51.904]                       invokeRestart <- base::invokeRestart
[17:02:51.904]                       is.null <- base::is.null
[17:02:51.904]                       muffled <- FALSE
[17:02:51.904]                       if (inherits(cond, "message")) {
[17:02:51.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.904]                         if (muffled) 
[17:02:51.904]                           invokeRestart("muffleMessage")
[17:02:51.904]                       }
[17:02:51.904]                       else if (inherits(cond, "warning")) {
[17:02:51.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.904]                         if (muffled) 
[17:02:51.904]                           invokeRestart("muffleWarning")
[17:02:51.904]                       }
[17:02:51.904]                       else if (inherits(cond, "condition")) {
[17:02:51.904]                         if (!is.null(pattern)) {
[17:02:51.904]                           computeRestarts <- base::computeRestarts
[17:02:51.904]                           grepl <- base::grepl
[17:02:51.904]                           restarts <- computeRestarts(cond)
[17:02:51.904]                           for (restart in restarts) {
[17:02:51.904]                             name <- restart$name
[17:02:51.904]                             if (is.null(name)) 
[17:02:51.904]                               next
[17:02:51.904]                             if (!grepl(pattern, name)) 
[17:02:51.904]                               next
[17:02:51.904]                             invokeRestart(restart)
[17:02:51.904]                             muffled <- TRUE
[17:02:51.904]                             break
[17:02:51.904]                           }
[17:02:51.904]                         }
[17:02:51.904]                       }
[17:02:51.904]                       invisible(muffled)
[17:02:51.904]                     }
[17:02:51.904]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.904]                   }
[17:02:51.904]                 }
[17:02:51.904]             }
[17:02:51.904]         }))
[17:02:51.904]     }, error = function(ex) {
[17:02:51.904]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.904]                 ...future.rng), started = ...future.startTime, 
[17:02:51.904]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.904]             version = "1.8"), class = "FutureResult")
[17:02:51.904]     }, finally = {
[17:02:51.904]         if (!identical(...future.workdir, getwd())) 
[17:02:51.904]             setwd(...future.workdir)
[17:02:51.904]         {
[17:02:51.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.904]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.904]             }
[17:02:51.904]             base::options(...future.oldOptions)
[17:02:51.904]             if (.Platform$OS.type == "windows") {
[17:02:51.904]                 old_names <- names(...future.oldEnvVars)
[17:02:51.904]                 envs <- base::Sys.getenv()
[17:02:51.904]                 names <- names(envs)
[17:02:51.904]                 common <- intersect(names, old_names)
[17:02:51.904]                 added <- setdiff(names, old_names)
[17:02:51.904]                 removed <- setdiff(old_names, names)
[17:02:51.904]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.904]                   envs[common]]
[17:02:51.904]                 NAMES <- toupper(changed)
[17:02:51.904]                 args <- list()
[17:02:51.904]                 for (kk in seq_along(NAMES)) {
[17:02:51.904]                   name <- changed[[kk]]
[17:02:51.904]                   NAME <- NAMES[[kk]]
[17:02:51.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.904]                     next
[17:02:51.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.904]                 }
[17:02:51.904]                 NAMES <- toupper(added)
[17:02:51.904]                 for (kk in seq_along(NAMES)) {
[17:02:51.904]                   name <- added[[kk]]
[17:02:51.904]                   NAME <- NAMES[[kk]]
[17:02:51.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.904]                     next
[17:02:51.904]                   args[[name]] <- ""
[17:02:51.904]                 }
[17:02:51.904]                 NAMES <- toupper(removed)
[17:02:51.904]                 for (kk in seq_along(NAMES)) {
[17:02:51.904]                   name <- removed[[kk]]
[17:02:51.904]                   NAME <- NAMES[[kk]]
[17:02:51.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.904]                     next
[17:02:51.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.904]                 }
[17:02:51.904]                 if (length(args) > 0) 
[17:02:51.904]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.904]             }
[17:02:51.904]             else {
[17:02:51.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.904]             }
[17:02:51.904]             {
[17:02:51.904]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.904]                   0L) {
[17:02:51.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.904]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.904]                   base::options(opts)
[17:02:51.904]                 }
[17:02:51.904]                 {
[17:02:51.904]                   {
[17:02:51.904]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.904]                     NULL
[17:02:51.904]                   }
[17:02:51.904]                   options(future.plan = NULL)
[17:02:51.904]                   if (is.na(NA_character_)) 
[17:02:51.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.904]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.904]                     .init = FALSE)
[17:02:51.904]                 }
[17:02:51.904]             }
[17:02:51.904]         }
[17:02:51.904]     })
[17:02:51.904]     if (TRUE) {
[17:02:51.904]         base::sink(type = "output", split = FALSE)
[17:02:51.904]         if (TRUE) {
[17:02:51.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.904]         }
[17:02:51.904]         else {
[17:02:51.904]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.904]         }
[17:02:51.904]         base::close(...future.stdout)
[17:02:51.904]         ...future.stdout <- NULL
[17:02:51.904]     }
[17:02:51.904]     ...future.result$conditions <- ...future.conditions
[17:02:51.904]     ...future.result$finished <- base::Sys.time()
[17:02:51.904]     ...future.result
[17:02:51.904] }
[17:02:51.907] assign_globals() ...
[17:02:51.907] List of 1
[17:02:51.907]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f63b49b8> 
[17:02:51.907]  - attr(*, "where")=List of 1
[17:02:51.907]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.907]  - attr(*, "resolved")= logi TRUE
[17:02:51.907]  - attr(*, "total_size")= num 10816
[17:02:51.907]  - attr(*, "already-done")= logi TRUE
[17:02:51.910] - copied ‘a’ to environment
[17:02:51.910] assign_globals() ... done
[17:02:51.910] requestCore(): workers = 2
[17:02:51.912] MulticoreFuture started
[17:02:51.913] - Launch lazy future ... done
[17:02:51.913] run() for ‘MulticoreFuture’ ... done
[17:02:51.913] result() for MulticoreFuture ...
[17:02:51.914] plan(): Setting new future strategy stack:
[17:02:51.914] List of future strategies:
[17:02:51.914] 1. sequential:
[17:02:51.914]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.914]    - tweaked: FALSE
[17:02:51.914]    - call: NULL
[17:02:51.915] plan(): nbrOfWorkers() = 1
[17:02:51.918] plan(): Setting new future strategy stack:
[17:02:51.918] List of future strategies:
[17:02:51.918] 1. multicore:
[17:02:51.918]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.918]    - tweaked: FALSE
[17:02:51.918]    - call: plan(strategy)
[17:02:51.924] plan(): nbrOfWorkers() = 2
[17:02:51.925] result() for MulticoreFuture ...
[17:02:51.925] result() for MulticoreFuture ... done
[17:02:51.925] signalConditions() ...
[17:02:51.925]  - include = ‘immediateCondition’
[17:02:51.925]  - exclude = 
[17:02:51.926]  - resignal = FALSE
[17:02:51.926]  - Number of conditions: 4
[17:02:51.926] signalConditions() ... done
[17:02:51.926] result() for MulticoreFuture ... done
[17:02:51.926] result() for MulticoreFuture ...
[17:02:51.926] result() for MulticoreFuture ... done
[17:02:51.927] signalConditions() ...
[17:02:51.927]  - include = ‘immediateCondition’
[17:02:51.927]  - exclude = 
[17:02:51.927]  - resignal = FALSE
[17:02:51.927]  - Number of conditions: 4
[17:02:51.927] signalConditions() ... done
[17:02:51.928] Future state: ‘finished’
[17:02:51.928] result() for MulticoreFuture ...
[17:02:51.928] result() for MulticoreFuture ... done
[17:02:51.928] signalConditions() ...
[17:02:51.928]  - include = ‘condition’
[17:02:51.928]  - exclude = ‘immediateCondition’
[17:02:51.928]  - resignal = TRUE
[17:02:51.928]  - Number of conditions: 4
[17:02:51.929]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.916] result() for MulticoreFuture ...
[17:02:51.929]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.917] result() for MulticoreFuture ... done
[17:02:51.929]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.917] result() for MulticoreFuture ...
[17:02:51.929]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.917] result() for MulticoreFuture ... done
[17:02:51.929] signalConditions() ... done
value(b) = 2
[17:02:51.929] result() for MulticoreFuture ...
[17:02:51.930] result() for MulticoreFuture ... done
[17:02:51.930] result() for MulticoreFuture ...
[17:02:51.930] result() for MulticoreFuture ... done
[17:02:51.930] signalConditions() ...
[17:02:51.930]  - include = ‘immediateCondition’
[17:02:51.930]  - exclude = 
[17:02:51.930]  - resignal = FALSE
[17:02:51.930]  - Number of conditions: 4
[17:02:51.930] signalConditions() ... done
[17:02:51.931] Future state: ‘finished’
[17:02:51.931] result() for MulticoreFuture ...
[17:02:51.931] result() for MulticoreFuture ... done
[17:02:51.931] signalConditions() ...
[17:02:51.931]  - include = ‘condition’
[17:02:51.931]  - exclude = ‘immediateCondition’
[17:02:51.931]  - resignal = TRUE
[17:02:51.931]  - Number of conditions: 4
[17:02:51.932]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.916] result() for MulticoreFuture ...
[17:02:51.932]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.917] result() for MulticoreFuture ... done
[17:02:51.932]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.917] result() for MulticoreFuture ...
[17:02:51.932]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.917] result() for MulticoreFuture ... done
[17:02:51.932] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.932] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.935] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.937] 
[17:02:51.937] Searching for globals ... DONE
[17:02:51.937] - globals: [0] <none>
[17:02:51.937] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:51.938] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:51.938] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:51.940] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:51.940] Searching for globals ... DONE
[17:02:51.940] Resolving globals: TRUE
[17:02:51.940] Resolving any globals that are futures ...
[17:02:51.940] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:51.940] Resolving any globals that are futures ... DONE
[17:02:51.941] Resolving futures part of globals (recursively) ...
[17:02:51.941] resolve() on list ...
[17:02:51.941]  recursive: 99
[17:02:51.941]  length: 1
[17:02:51.941]  elements: ‘a’
[17:02:51.942] run() for ‘Future’ ...
[17:02:51.942] - state: ‘created’
[17:02:51.942] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.946] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.946]   - Field: ‘label’
[17:02:51.946]   - Field: ‘local’
[17:02:51.946]   - Field: ‘owner’
[17:02:51.947]   - Field: ‘envir’
[17:02:51.947]   - Field: ‘workers’
[17:02:51.947]   - Field: ‘packages’
[17:02:51.947]   - Field: ‘gc’
[17:02:51.947]   - Field: ‘job’
[17:02:51.947]   - Field: ‘conditions’
[17:02:51.947]   - Field: ‘expr’
[17:02:51.947]   - Field: ‘uuid’
[17:02:51.948]   - Field: ‘seed’
[17:02:51.948]   - Field: ‘version’
[17:02:51.948]   - Field: ‘result’
[17:02:51.948]   - Field: ‘asynchronous’
[17:02:51.948]   - Field: ‘calls’
[17:02:51.948]   - Field: ‘globals’
[17:02:51.948]   - Field: ‘stdout’
[17:02:51.948]   - Field: ‘earlySignal’
[17:02:51.948]   - Field: ‘lazy’
[17:02:51.948]   - Field: ‘state’
[17:02:51.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.949] - Launch lazy future ...
[17:02:51.949] Packages needed by the future expression (n = 0): <none>
[17:02:51.949] Packages needed by future strategies (n = 0): <none>
[17:02:51.950] {
[17:02:51.950]     {
[17:02:51.950]         {
[17:02:51.950]             ...future.startTime <- base::Sys.time()
[17:02:51.950]             {
[17:02:51.950]                 {
[17:02:51.950]                   {
[17:02:51.950]                     {
[17:02:51.950]                       base::local({
[17:02:51.950]                         has_future <- base::requireNamespace("future", 
[17:02:51.950]                           quietly = TRUE)
[17:02:51.950]                         if (has_future) {
[17:02:51.950]                           ns <- base::getNamespace("future")
[17:02:51.950]                           version <- ns[[".package"]][["version"]]
[17:02:51.950]                           if (is.null(version)) 
[17:02:51.950]                             version <- utils::packageVersion("future")
[17:02:51.950]                         }
[17:02:51.950]                         else {
[17:02:51.950]                           version <- NULL
[17:02:51.950]                         }
[17:02:51.950]                         if (!has_future || version < "1.8.0") {
[17:02:51.950]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.950]                             "", base::R.version$version.string), 
[17:02:51.950]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:51.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:51.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.950]                               "release", "version")], collapse = " "), 
[17:02:51.950]                             hostname = base::Sys.info()[["nodename"]])
[17:02:51.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.950]                             info)
[17:02:51.950]                           info <- base::paste(info, collapse = "; ")
[17:02:51.950]                           if (!has_future) {
[17:02:51.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.950]                               info)
[17:02:51.950]                           }
[17:02:51.950]                           else {
[17:02:51.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.950]                               info, version)
[17:02:51.950]                           }
[17:02:51.950]                           base::stop(msg)
[17:02:51.950]                         }
[17:02:51.950]                       })
[17:02:51.950]                     }
[17:02:51.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.950]                     base::options(mc.cores = 1L)
[17:02:51.950]                   }
[17:02:51.950]                   ...future.strategy.old <- future::plan("list")
[17:02:51.950]                   options(future.plan = NULL)
[17:02:51.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.950]                 }
[17:02:51.950]                 ...future.workdir <- getwd()
[17:02:51.950]             }
[17:02:51.950]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.950]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.950]         }
[17:02:51.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.950]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.950]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.950]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.950]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.950]             base::names(...future.oldOptions))
[17:02:51.950]     }
[17:02:51.950]     if (FALSE) {
[17:02:51.950]     }
[17:02:51.950]     else {
[17:02:51.950]         if (TRUE) {
[17:02:51.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.950]                 open = "w")
[17:02:51.950]         }
[17:02:51.950]         else {
[17:02:51.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.950]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.950]         }
[17:02:51.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.950]             base::sink(type = "output", split = FALSE)
[17:02:51.950]             base::close(...future.stdout)
[17:02:51.950]         }, add = TRUE)
[17:02:51.950]     }
[17:02:51.950]     ...future.frame <- base::sys.nframe()
[17:02:51.950]     ...future.conditions <- base::list()
[17:02:51.950]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.950]     if (FALSE) {
[17:02:51.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.950]     }
[17:02:51.950]     ...future.result <- base::tryCatch({
[17:02:51.950]         base::withCallingHandlers({
[17:02:51.950]             ...future.value <- base::withVisible(base::local({
[17:02:51.950]                 withCallingHandlers({
[17:02:51.950]                   1
[17:02:51.950]                 }, immediateCondition = function(cond) {
[17:02:51.950]                   save_rds <- function (object, pathname, ...) 
[17:02:51.950]                   {
[17:02:51.950]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.950]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.950]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.950]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.950]                         fi_tmp[["mtime"]])
[17:02:51.950]                     }
[17:02:51.950]                     tryCatch({
[17:02:51.950]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.950]                     }, error = function(ex) {
[17:02:51.950]                       msg <- conditionMessage(ex)
[17:02:51.950]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.950]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.950]                         fi_tmp[["mtime"]], msg)
[17:02:51.950]                       ex$message <- msg
[17:02:51.950]                       stop(ex)
[17:02:51.950]                     })
[17:02:51.950]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.950]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.950]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.950]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.950]                       fi <- file.info(pathname)
[17:02:51.950]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.950]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.950]                         fi[["size"]], fi[["mtime"]])
[17:02:51.950]                       stop(msg)
[17:02:51.950]                     }
[17:02:51.950]                     invisible(pathname)
[17:02:51.950]                   }
[17:02:51.950]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.950]                     rootPath = tempdir()) 
[17:02:51.950]                   {
[17:02:51.950]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.950]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.950]                       tmpdir = path, fileext = ".rds")
[17:02:51.950]                     save_rds(obj, file)
[17:02:51.950]                   }
[17:02:51.950]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.950]                   {
[17:02:51.950]                     inherits <- base::inherits
[17:02:51.950]                     invokeRestart <- base::invokeRestart
[17:02:51.950]                     is.null <- base::is.null
[17:02:51.950]                     muffled <- FALSE
[17:02:51.950]                     if (inherits(cond, "message")) {
[17:02:51.950]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.950]                       if (muffled) 
[17:02:51.950]                         invokeRestart("muffleMessage")
[17:02:51.950]                     }
[17:02:51.950]                     else if (inherits(cond, "warning")) {
[17:02:51.950]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.950]                       if (muffled) 
[17:02:51.950]                         invokeRestart("muffleWarning")
[17:02:51.950]                     }
[17:02:51.950]                     else if (inherits(cond, "condition")) {
[17:02:51.950]                       if (!is.null(pattern)) {
[17:02:51.950]                         computeRestarts <- base::computeRestarts
[17:02:51.950]                         grepl <- base::grepl
[17:02:51.950]                         restarts <- computeRestarts(cond)
[17:02:51.950]                         for (restart in restarts) {
[17:02:51.950]                           name <- restart$name
[17:02:51.950]                           if (is.null(name)) 
[17:02:51.950]                             next
[17:02:51.950]                           if (!grepl(pattern, name)) 
[17:02:51.950]                             next
[17:02:51.950]                           invokeRestart(restart)
[17:02:51.950]                           muffled <- TRUE
[17:02:51.950]                           break
[17:02:51.950]                         }
[17:02:51.950]                       }
[17:02:51.950]                     }
[17:02:51.950]                     invisible(muffled)
[17:02:51.950]                   }
[17:02:51.950]                   muffleCondition(cond)
[17:02:51.950]                 })
[17:02:51.950]             }))
[17:02:51.950]             future::FutureResult(value = ...future.value$value, 
[17:02:51.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.950]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.950]                     ...future.globalenv.names))
[17:02:51.950]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.950]         }, condition = base::local({
[17:02:51.950]             c <- base::c
[17:02:51.950]             inherits <- base::inherits
[17:02:51.950]             invokeRestart <- base::invokeRestart
[17:02:51.950]             length <- base::length
[17:02:51.950]             list <- base::list
[17:02:51.950]             seq.int <- base::seq.int
[17:02:51.950]             signalCondition <- base::signalCondition
[17:02:51.950]             sys.calls <- base::sys.calls
[17:02:51.950]             `[[` <- base::`[[`
[17:02:51.950]             `+` <- base::`+`
[17:02:51.950]             `<<-` <- base::`<<-`
[17:02:51.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.950]                   3L)]
[17:02:51.950]             }
[17:02:51.950]             function(cond) {
[17:02:51.950]                 is_error <- inherits(cond, "error")
[17:02:51.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.950]                   NULL)
[17:02:51.950]                 if (is_error) {
[17:02:51.950]                   sessionInformation <- function() {
[17:02:51.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.950]                       search = base::search(), system = base::Sys.info())
[17:02:51.950]                   }
[17:02:51.950]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.950]                     cond$call), session = sessionInformation(), 
[17:02:51.950]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.950]                   signalCondition(cond)
[17:02:51.950]                 }
[17:02:51.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.950]                 "immediateCondition"))) {
[17:02:51.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.950]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.950]                   if (TRUE && !signal) {
[17:02:51.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.950]                     {
[17:02:51.950]                       inherits <- base::inherits
[17:02:51.950]                       invokeRestart <- base::invokeRestart
[17:02:51.950]                       is.null <- base::is.null
[17:02:51.950]                       muffled <- FALSE
[17:02:51.950]                       if (inherits(cond, "message")) {
[17:02:51.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.950]                         if (muffled) 
[17:02:51.950]                           invokeRestart("muffleMessage")
[17:02:51.950]                       }
[17:02:51.950]                       else if (inherits(cond, "warning")) {
[17:02:51.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.950]                         if (muffled) 
[17:02:51.950]                           invokeRestart("muffleWarning")
[17:02:51.950]                       }
[17:02:51.950]                       else if (inherits(cond, "condition")) {
[17:02:51.950]                         if (!is.null(pattern)) {
[17:02:51.950]                           computeRestarts <- base::computeRestarts
[17:02:51.950]                           grepl <- base::grepl
[17:02:51.950]                           restarts <- computeRestarts(cond)
[17:02:51.950]                           for (restart in restarts) {
[17:02:51.950]                             name <- restart$name
[17:02:51.950]                             if (is.null(name)) 
[17:02:51.950]                               next
[17:02:51.950]                             if (!grepl(pattern, name)) 
[17:02:51.950]                               next
[17:02:51.950]                             invokeRestart(restart)
[17:02:51.950]                             muffled <- TRUE
[17:02:51.950]                             break
[17:02:51.950]                           }
[17:02:51.950]                         }
[17:02:51.950]                       }
[17:02:51.950]                       invisible(muffled)
[17:02:51.950]                     }
[17:02:51.950]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.950]                   }
[17:02:51.950]                 }
[17:02:51.950]                 else {
[17:02:51.950]                   if (TRUE) {
[17:02:51.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.950]                     {
[17:02:51.950]                       inherits <- base::inherits
[17:02:51.950]                       invokeRestart <- base::invokeRestart
[17:02:51.950]                       is.null <- base::is.null
[17:02:51.950]                       muffled <- FALSE
[17:02:51.950]                       if (inherits(cond, "message")) {
[17:02:51.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.950]                         if (muffled) 
[17:02:51.950]                           invokeRestart("muffleMessage")
[17:02:51.950]                       }
[17:02:51.950]                       else if (inherits(cond, "warning")) {
[17:02:51.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.950]                         if (muffled) 
[17:02:51.950]                           invokeRestart("muffleWarning")
[17:02:51.950]                       }
[17:02:51.950]                       else if (inherits(cond, "condition")) {
[17:02:51.950]                         if (!is.null(pattern)) {
[17:02:51.950]                           computeRestarts <- base::computeRestarts
[17:02:51.950]                           grepl <- base::grepl
[17:02:51.950]                           restarts <- computeRestarts(cond)
[17:02:51.950]                           for (restart in restarts) {
[17:02:51.950]                             name <- restart$name
[17:02:51.950]                             if (is.null(name)) 
[17:02:51.950]                               next
[17:02:51.950]                             if (!grepl(pattern, name)) 
[17:02:51.950]                               next
[17:02:51.950]                             invokeRestart(restart)
[17:02:51.950]                             muffled <- TRUE
[17:02:51.950]                             break
[17:02:51.950]                           }
[17:02:51.950]                         }
[17:02:51.950]                       }
[17:02:51.950]                       invisible(muffled)
[17:02:51.950]                     }
[17:02:51.950]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.950]                   }
[17:02:51.950]                 }
[17:02:51.950]             }
[17:02:51.950]         }))
[17:02:51.950]     }, error = function(ex) {
[17:02:51.950]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.950]                 ...future.rng), started = ...future.startTime, 
[17:02:51.950]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.950]             version = "1.8"), class = "FutureResult")
[17:02:51.950]     }, finally = {
[17:02:51.950]         if (!identical(...future.workdir, getwd())) 
[17:02:51.950]             setwd(...future.workdir)
[17:02:51.950]         {
[17:02:51.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.950]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.950]             }
[17:02:51.950]             base::options(...future.oldOptions)
[17:02:51.950]             if (.Platform$OS.type == "windows") {
[17:02:51.950]                 old_names <- names(...future.oldEnvVars)
[17:02:51.950]                 envs <- base::Sys.getenv()
[17:02:51.950]                 names <- names(envs)
[17:02:51.950]                 common <- intersect(names, old_names)
[17:02:51.950]                 added <- setdiff(names, old_names)
[17:02:51.950]                 removed <- setdiff(old_names, names)
[17:02:51.950]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.950]                   envs[common]]
[17:02:51.950]                 NAMES <- toupper(changed)
[17:02:51.950]                 args <- list()
[17:02:51.950]                 for (kk in seq_along(NAMES)) {
[17:02:51.950]                   name <- changed[[kk]]
[17:02:51.950]                   NAME <- NAMES[[kk]]
[17:02:51.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.950]                     next
[17:02:51.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.950]                 }
[17:02:51.950]                 NAMES <- toupper(added)
[17:02:51.950]                 for (kk in seq_along(NAMES)) {
[17:02:51.950]                   name <- added[[kk]]
[17:02:51.950]                   NAME <- NAMES[[kk]]
[17:02:51.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.950]                     next
[17:02:51.950]                   args[[name]] <- ""
[17:02:51.950]                 }
[17:02:51.950]                 NAMES <- toupper(removed)
[17:02:51.950]                 for (kk in seq_along(NAMES)) {
[17:02:51.950]                   name <- removed[[kk]]
[17:02:51.950]                   NAME <- NAMES[[kk]]
[17:02:51.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.950]                     next
[17:02:51.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.950]                 }
[17:02:51.950]                 if (length(args) > 0) 
[17:02:51.950]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.950]             }
[17:02:51.950]             else {
[17:02:51.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.950]             }
[17:02:51.950]             {
[17:02:51.950]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.950]                   0L) {
[17:02:51.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.950]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.950]                   base::options(opts)
[17:02:51.950]                 }
[17:02:51.950]                 {
[17:02:51.950]                   {
[17:02:51.950]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.950]                     NULL
[17:02:51.950]                   }
[17:02:51.950]                   options(future.plan = NULL)
[17:02:51.950]                   if (is.na(NA_character_)) 
[17:02:51.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.950]                     .init = FALSE)
[17:02:51.950]                 }
[17:02:51.950]             }
[17:02:51.950]         }
[17:02:51.950]     })
[17:02:51.950]     if (TRUE) {
[17:02:51.950]         base::sink(type = "output", split = FALSE)
[17:02:51.950]         if (TRUE) {
[17:02:51.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.950]         }
[17:02:51.950]         else {
[17:02:51.950]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.950]         }
[17:02:51.950]         base::close(...future.stdout)
[17:02:51.950]         ...future.stdout <- NULL
[17:02:51.950]     }
[17:02:51.950]     ...future.result$conditions <- ...future.conditions
[17:02:51.950]     ...future.result$finished <- base::Sys.time()
[17:02:51.950]     ...future.result
[17:02:51.950] }
[17:02:51.952] requestCore(): workers = 2
[17:02:51.954] MulticoreFuture started
[17:02:51.955] - Launch lazy future ... done
[17:02:51.955] run() for ‘MulticoreFuture’ ... done
[17:02:51.955] plan(): Setting new future strategy stack:
[17:02:51.955] List of future strategies:
[17:02:51.955] 1. sequential:
[17:02:51.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.955]    - tweaked: FALSE
[17:02:51.955]    - call: NULL
[17:02:51.957] plan(): nbrOfWorkers() = 1
[17:02:51.959] plan(): Setting new future strategy stack:
[17:02:51.959] List of future strategies:
[17:02:51.959] 1. multicore:
[17:02:51.959]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.959]    - tweaked: FALSE
[17:02:51.959]    - call: plan(strategy)
[17:02:51.964] plan(): nbrOfWorkers() = 2
[17:02:51.965] Future #1
[17:02:51.965] result() for MulticoreFuture ...
[17:02:51.966] result() for MulticoreFuture ...
[17:02:51.966] result() for MulticoreFuture ... done
[17:02:51.967] result() for MulticoreFuture ... done
[17:02:51.967] result() for MulticoreFuture ...
[17:02:51.967] result() for MulticoreFuture ... done
[17:02:51.967] A MulticoreFuture was resolved
[17:02:51.967]  length: 0 (resolved future 1)
[17:02:51.967] resolve() on list ... DONE
[17:02:51.968] - globals: [1] ‘a’
[17:02:51.968] Resolving futures part of globals (recursively) ... DONE
[17:02:51.969] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:02:51.970] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:02:51.970] - globals: [1] ‘a’
[17:02:51.970] - packages: [1] ‘future’
[17:02:51.970] getGlobalsAndPackages() ... DONE
[17:02:51.971] run() for ‘Future’ ...
[17:02:51.971] - state: ‘created’
[17:02:51.971] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:51.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:51.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:51.975]   - Field: ‘label’
[17:02:51.976]   - Field: ‘local’
[17:02:51.976]   - Field: ‘owner’
[17:02:51.976]   - Field: ‘envir’
[17:02:51.976]   - Field: ‘workers’
[17:02:51.976]   - Field: ‘packages’
[17:02:51.976]   - Field: ‘gc’
[17:02:51.976]   - Field: ‘job’
[17:02:51.976]   - Field: ‘conditions’
[17:02:51.977]   - Field: ‘expr’
[17:02:51.977]   - Field: ‘uuid’
[17:02:51.977]   - Field: ‘seed’
[17:02:51.977]   - Field: ‘version’
[17:02:51.977]   - Field: ‘result’
[17:02:51.977]   - Field: ‘asynchronous’
[17:02:51.977]   - Field: ‘calls’
[17:02:51.977]   - Field: ‘globals’
[17:02:51.977]   - Field: ‘stdout’
[17:02:51.978]   - Field: ‘earlySignal’
[17:02:51.978]   - Field: ‘lazy’
[17:02:51.978]   - Field: ‘state’
[17:02:51.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:51.978] - Launch lazy future ...
[17:02:51.978] Packages needed by the future expression (n = 1): ‘future’
[17:02:51.979] Packages needed by future strategies (n = 0): <none>
[17:02:51.979] {
[17:02:51.979]     {
[17:02:51.979]         {
[17:02:51.979]             ...future.startTime <- base::Sys.time()
[17:02:51.979]             {
[17:02:51.979]                 {
[17:02:51.979]                   {
[17:02:51.979]                     {
[17:02:51.979]                       {
[17:02:51.979]                         base::local({
[17:02:51.979]                           has_future <- base::requireNamespace("future", 
[17:02:51.979]                             quietly = TRUE)
[17:02:51.979]                           if (has_future) {
[17:02:51.979]                             ns <- base::getNamespace("future")
[17:02:51.979]                             version <- ns[[".package"]][["version"]]
[17:02:51.979]                             if (is.null(version)) 
[17:02:51.979]                               version <- utils::packageVersion("future")
[17:02:51.979]                           }
[17:02:51.979]                           else {
[17:02:51.979]                             version <- NULL
[17:02:51.979]                           }
[17:02:51.979]                           if (!has_future || version < "1.8.0") {
[17:02:51.979]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:51.979]                               "", base::R.version$version.string), 
[17:02:51.979]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:51.979]                                 base::R.version$platform, 8 * 
[17:02:51.979]                                   base::.Machine$sizeof.pointer), 
[17:02:51.979]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:51.979]                                 "release", "version")], collapse = " "), 
[17:02:51.979]                               hostname = base::Sys.info()[["nodename"]])
[17:02:51.979]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:51.979]                               info)
[17:02:51.979]                             info <- base::paste(info, collapse = "; ")
[17:02:51.979]                             if (!has_future) {
[17:02:51.979]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:51.979]                                 info)
[17:02:51.979]                             }
[17:02:51.979]                             else {
[17:02:51.979]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:51.979]                                 info, version)
[17:02:51.979]                             }
[17:02:51.979]                             base::stop(msg)
[17:02:51.979]                           }
[17:02:51.979]                         })
[17:02:51.979]                       }
[17:02:51.979]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:51.979]                       base::options(mc.cores = 1L)
[17:02:51.979]                     }
[17:02:51.979]                     base::local({
[17:02:51.979]                       for (pkg in "future") {
[17:02:51.979]                         base::loadNamespace(pkg)
[17:02:51.979]                         base::library(pkg, character.only = TRUE)
[17:02:51.979]                       }
[17:02:51.979]                     })
[17:02:51.979]                   }
[17:02:51.979]                   ...future.strategy.old <- future::plan("list")
[17:02:51.979]                   options(future.plan = NULL)
[17:02:51.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:51.979]                 }
[17:02:51.979]                 ...future.workdir <- getwd()
[17:02:51.979]             }
[17:02:51.979]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:51.979]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:51.979]         }
[17:02:51.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:51.979]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:51.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:51.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:51.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:51.979]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:51.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:51.979]             base::names(...future.oldOptions))
[17:02:51.979]     }
[17:02:51.979]     if (FALSE) {
[17:02:51.979]     }
[17:02:51.979]     else {
[17:02:51.979]         if (TRUE) {
[17:02:51.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:51.979]                 open = "w")
[17:02:51.979]         }
[17:02:51.979]         else {
[17:02:51.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:51.979]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:51.979]         }
[17:02:51.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:51.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:51.979]             base::sink(type = "output", split = FALSE)
[17:02:51.979]             base::close(...future.stdout)
[17:02:51.979]         }, add = TRUE)
[17:02:51.979]     }
[17:02:51.979]     ...future.frame <- base::sys.nframe()
[17:02:51.979]     ...future.conditions <- base::list()
[17:02:51.979]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:51.979]     if (FALSE) {
[17:02:51.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:51.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:51.979]     }
[17:02:51.979]     ...future.result <- base::tryCatch({
[17:02:51.979]         base::withCallingHandlers({
[17:02:51.979]             ...future.value <- base::withVisible(base::local({
[17:02:51.979]                 withCallingHandlers({
[17:02:51.979]                   value(a) + 1
[17:02:51.979]                 }, immediateCondition = function(cond) {
[17:02:51.979]                   save_rds <- function (object, pathname, ...) 
[17:02:51.979]                   {
[17:02:51.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:51.979]                     if (file_test("-f", pathname_tmp)) {
[17:02:51.979]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:51.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.979]                         fi_tmp[["mtime"]])
[17:02:51.979]                     }
[17:02:51.979]                     tryCatch({
[17:02:51.979]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:51.979]                     }, error = function(ex) {
[17:02:51.979]                       msg <- conditionMessage(ex)
[17:02:51.979]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:51.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.979]                         fi_tmp[["mtime"]], msg)
[17:02:51.979]                       ex$message <- msg
[17:02:51.979]                       stop(ex)
[17:02:51.979]                     })
[17:02:51.979]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:51.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:51.979]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:51.979]                       fi_tmp <- file.info(pathname_tmp)
[17:02:51.979]                       fi <- file.info(pathname)
[17:02:51.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:51.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:51.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:51.979]                         fi[["size"]], fi[["mtime"]])
[17:02:51.979]                       stop(msg)
[17:02:51.979]                     }
[17:02:51.979]                     invisible(pathname)
[17:02:51.979]                   }
[17:02:51.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:51.979]                     rootPath = tempdir()) 
[17:02:51.979]                   {
[17:02:51.979]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:51.979]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:51.979]                       tmpdir = path, fileext = ".rds")
[17:02:51.979]                     save_rds(obj, file)
[17:02:51.979]                   }
[17:02:51.979]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:51.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.979]                   {
[17:02:51.979]                     inherits <- base::inherits
[17:02:51.979]                     invokeRestart <- base::invokeRestart
[17:02:51.979]                     is.null <- base::is.null
[17:02:51.979]                     muffled <- FALSE
[17:02:51.979]                     if (inherits(cond, "message")) {
[17:02:51.979]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:51.979]                       if (muffled) 
[17:02:51.979]                         invokeRestart("muffleMessage")
[17:02:51.979]                     }
[17:02:51.979]                     else if (inherits(cond, "warning")) {
[17:02:51.979]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:51.979]                       if (muffled) 
[17:02:51.979]                         invokeRestart("muffleWarning")
[17:02:51.979]                     }
[17:02:51.979]                     else if (inherits(cond, "condition")) {
[17:02:51.979]                       if (!is.null(pattern)) {
[17:02:51.979]                         computeRestarts <- base::computeRestarts
[17:02:51.979]                         grepl <- base::grepl
[17:02:51.979]                         restarts <- computeRestarts(cond)
[17:02:51.979]                         for (restart in restarts) {
[17:02:51.979]                           name <- restart$name
[17:02:51.979]                           if (is.null(name)) 
[17:02:51.979]                             next
[17:02:51.979]                           if (!grepl(pattern, name)) 
[17:02:51.979]                             next
[17:02:51.979]                           invokeRestart(restart)
[17:02:51.979]                           muffled <- TRUE
[17:02:51.979]                           break
[17:02:51.979]                         }
[17:02:51.979]                       }
[17:02:51.979]                     }
[17:02:51.979]                     invisible(muffled)
[17:02:51.979]                   }
[17:02:51.979]                   muffleCondition(cond)
[17:02:51.979]                 })
[17:02:51.979]             }))
[17:02:51.979]             future::FutureResult(value = ...future.value$value, 
[17:02:51.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.979]                   ...future.rng), globalenv = if (FALSE) 
[17:02:51.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:51.979]                     ...future.globalenv.names))
[17:02:51.979]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:51.979]         }, condition = base::local({
[17:02:51.979]             c <- base::c
[17:02:51.979]             inherits <- base::inherits
[17:02:51.979]             invokeRestart <- base::invokeRestart
[17:02:51.979]             length <- base::length
[17:02:51.979]             list <- base::list
[17:02:51.979]             seq.int <- base::seq.int
[17:02:51.979]             signalCondition <- base::signalCondition
[17:02:51.979]             sys.calls <- base::sys.calls
[17:02:51.979]             `[[` <- base::`[[`
[17:02:51.979]             `+` <- base::`+`
[17:02:51.979]             `<<-` <- base::`<<-`
[17:02:51.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:51.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:51.979]                   3L)]
[17:02:51.979]             }
[17:02:51.979]             function(cond) {
[17:02:51.979]                 is_error <- inherits(cond, "error")
[17:02:51.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:51.979]                   NULL)
[17:02:51.979]                 if (is_error) {
[17:02:51.979]                   sessionInformation <- function() {
[17:02:51.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:51.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:51.979]                       search = base::search(), system = base::Sys.info())
[17:02:51.979]                   }
[17:02:51.979]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:51.979]                     cond$call), session = sessionInformation(), 
[17:02:51.979]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:51.979]                   signalCondition(cond)
[17:02:51.979]                 }
[17:02:51.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:51.979]                 "immediateCondition"))) {
[17:02:51.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:51.979]                   ...future.conditions[[length(...future.conditions) + 
[17:02:51.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:51.979]                   if (TRUE && !signal) {
[17:02:51.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.979]                     {
[17:02:51.979]                       inherits <- base::inherits
[17:02:51.979]                       invokeRestart <- base::invokeRestart
[17:02:51.979]                       is.null <- base::is.null
[17:02:51.979]                       muffled <- FALSE
[17:02:51.979]                       if (inherits(cond, "message")) {
[17:02:51.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.979]                         if (muffled) 
[17:02:51.979]                           invokeRestart("muffleMessage")
[17:02:51.979]                       }
[17:02:51.979]                       else if (inherits(cond, "warning")) {
[17:02:51.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.979]                         if (muffled) 
[17:02:51.979]                           invokeRestart("muffleWarning")
[17:02:51.979]                       }
[17:02:51.979]                       else if (inherits(cond, "condition")) {
[17:02:51.979]                         if (!is.null(pattern)) {
[17:02:51.979]                           computeRestarts <- base::computeRestarts
[17:02:51.979]                           grepl <- base::grepl
[17:02:51.979]                           restarts <- computeRestarts(cond)
[17:02:51.979]                           for (restart in restarts) {
[17:02:51.979]                             name <- restart$name
[17:02:51.979]                             if (is.null(name)) 
[17:02:51.979]                               next
[17:02:51.979]                             if (!grepl(pattern, name)) 
[17:02:51.979]                               next
[17:02:51.979]                             invokeRestart(restart)
[17:02:51.979]                             muffled <- TRUE
[17:02:51.979]                             break
[17:02:51.979]                           }
[17:02:51.979]                         }
[17:02:51.979]                       }
[17:02:51.979]                       invisible(muffled)
[17:02:51.979]                     }
[17:02:51.979]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.979]                   }
[17:02:51.979]                 }
[17:02:51.979]                 else {
[17:02:51.979]                   if (TRUE) {
[17:02:51.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:51.979]                     {
[17:02:51.979]                       inherits <- base::inherits
[17:02:51.979]                       invokeRestart <- base::invokeRestart
[17:02:51.979]                       is.null <- base::is.null
[17:02:51.979]                       muffled <- FALSE
[17:02:51.979]                       if (inherits(cond, "message")) {
[17:02:51.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:51.979]                         if (muffled) 
[17:02:51.979]                           invokeRestart("muffleMessage")
[17:02:51.979]                       }
[17:02:51.979]                       else if (inherits(cond, "warning")) {
[17:02:51.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:51.979]                         if (muffled) 
[17:02:51.979]                           invokeRestart("muffleWarning")
[17:02:51.979]                       }
[17:02:51.979]                       else if (inherits(cond, "condition")) {
[17:02:51.979]                         if (!is.null(pattern)) {
[17:02:51.979]                           computeRestarts <- base::computeRestarts
[17:02:51.979]                           grepl <- base::grepl
[17:02:51.979]                           restarts <- computeRestarts(cond)
[17:02:51.979]                           for (restart in restarts) {
[17:02:51.979]                             name <- restart$name
[17:02:51.979]                             if (is.null(name)) 
[17:02:51.979]                               next
[17:02:51.979]                             if (!grepl(pattern, name)) 
[17:02:51.979]                               next
[17:02:51.979]                             invokeRestart(restart)
[17:02:51.979]                             muffled <- TRUE
[17:02:51.979]                             break
[17:02:51.979]                           }
[17:02:51.979]                         }
[17:02:51.979]                       }
[17:02:51.979]                       invisible(muffled)
[17:02:51.979]                     }
[17:02:51.979]                     muffleCondition(cond, pattern = "^muffle")
[17:02:51.979]                   }
[17:02:51.979]                 }
[17:02:51.979]             }
[17:02:51.979]         }))
[17:02:51.979]     }, error = function(ex) {
[17:02:51.979]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:51.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:51.979]                 ...future.rng), started = ...future.startTime, 
[17:02:51.979]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:51.979]             version = "1.8"), class = "FutureResult")
[17:02:51.979]     }, finally = {
[17:02:51.979]         if (!identical(...future.workdir, getwd())) 
[17:02:51.979]             setwd(...future.workdir)
[17:02:51.979]         {
[17:02:51.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:51.979]                 ...future.oldOptions$nwarnings <- NULL
[17:02:51.979]             }
[17:02:51.979]             base::options(...future.oldOptions)
[17:02:51.979]             if (.Platform$OS.type == "windows") {
[17:02:51.979]                 old_names <- names(...future.oldEnvVars)
[17:02:51.979]                 envs <- base::Sys.getenv()
[17:02:51.979]                 names <- names(envs)
[17:02:51.979]                 common <- intersect(names, old_names)
[17:02:51.979]                 added <- setdiff(names, old_names)
[17:02:51.979]                 removed <- setdiff(old_names, names)
[17:02:51.979]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:51.979]                   envs[common]]
[17:02:51.979]                 NAMES <- toupper(changed)
[17:02:51.979]                 args <- list()
[17:02:51.979]                 for (kk in seq_along(NAMES)) {
[17:02:51.979]                   name <- changed[[kk]]
[17:02:51.979]                   NAME <- NAMES[[kk]]
[17:02:51.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.979]                     next
[17:02:51.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.979]                 }
[17:02:51.979]                 NAMES <- toupper(added)
[17:02:51.979]                 for (kk in seq_along(NAMES)) {
[17:02:51.979]                   name <- added[[kk]]
[17:02:51.979]                   NAME <- NAMES[[kk]]
[17:02:51.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.979]                     next
[17:02:51.979]                   args[[name]] <- ""
[17:02:51.979]                 }
[17:02:51.979]                 NAMES <- toupper(removed)
[17:02:51.979]                 for (kk in seq_along(NAMES)) {
[17:02:51.979]                   name <- removed[[kk]]
[17:02:51.979]                   NAME <- NAMES[[kk]]
[17:02:51.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:51.979]                     next
[17:02:51.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:51.979]                 }
[17:02:51.979]                 if (length(args) > 0) 
[17:02:51.979]                   base::do.call(base::Sys.setenv, args = args)
[17:02:51.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:51.979]             }
[17:02:51.979]             else {
[17:02:51.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:51.979]             }
[17:02:51.979]             {
[17:02:51.979]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:51.979]                   0L) {
[17:02:51.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:51.979]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:51.979]                   base::options(opts)
[17:02:51.979]                 }
[17:02:51.979]                 {
[17:02:51.979]                   {
[17:02:51.979]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:51.979]                     NULL
[17:02:51.979]                   }
[17:02:51.979]                   options(future.plan = NULL)
[17:02:51.979]                   if (is.na(NA_character_)) 
[17:02:51.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:51.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:51.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:51.979]                     .init = FALSE)
[17:02:51.979]                 }
[17:02:51.979]             }
[17:02:51.979]         }
[17:02:51.979]     })
[17:02:51.979]     if (TRUE) {
[17:02:51.979]         base::sink(type = "output", split = FALSE)
[17:02:51.979]         if (TRUE) {
[17:02:51.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:51.979]         }
[17:02:51.979]         else {
[17:02:51.979]             ...future.result["stdout"] <- base::list(NULL)
[17:02:51.979]         }
[17:02:51.979]         base::close(...future.stdout)
[17:02:51.979]         ...future.stdout <- NULL
[17:02:51.979]     }
[17:02:51.979]     ...future.result$conditions <- ...future.conditions
[17:02:51.979]     ...future.result$finished <- base::Sys.time()
[17:02:51.979]     ...future.result
[17:02:51.979] }
[17:02:51.982] assign_globals() ...
[17:02:51.982] List of 1
[17:02:51.982]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f61cae58> 
[17:02:51.982]  - attr(*, "where")=List of 1
[17:02:51.982]   ..$ a:<environment: R_EmptyEnv> 
[17:02:51.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:51.982]  - attr(*, "resolved")= logi TRUE
[17:02:51.982]  - attr(*, "total_size")= num 10984
[17:02:51.982]  - attr(*, "already-done")= logi TRUE
[17:02:51.988] - copied ‘a’ to environment
[17:02:51.989] assign_globals() ... done
[17:02:51.989] requestCore(): workers = 2
[17:02:51.992] MulticoreFuture started
[17:02:51.992] - Launch lazy future ... done
[17:02:51.993] run() for ‘MulticoreFuture’ ... done
[17:02:51.993] result() for MulticoreFuture ...
[17:02:51.993] plan(): Setting new future strategy stack:
[17:02:51.993] List of future strategies:
[17:02:51.993] 1. sequential:
[17:02:51.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:51.993]    - tweaked: FALSE
[17:02:51.993]    - call: NULL
[17:02:51.995] plan(): nbrOfWorkers() = 1
[17:02:51.999] plan(): Setting new future strategy stack:
[17:02:51.999] List of future strategies:
[17:02:51.999] 1. multicore:
[17:02:51.999]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:51.999]    - tweaked: FALSE
[17:02:51.999]    - call: plan(strategy)
[17:02:52.005] plan(): nbrOfWorkers() = 2
[17:02:52.006] result() for MulticoreFuture ...
[17:02:52.006] result() for MulticoreFuture ... done
[17:02:52.006] signalConditions() ...
[17:02:52.007]  - include = ‘immediateCondition’
[17:02:52.007]  - exclude = 
[17:02:52.007]  - resignal = FALSE
[17:02:52.007]  - Number of conditions: 4
[17:02:52.007] signalConditions() ... done
[17:02:52.008] result() for MulticoreFuture ... done
[17:02:52.008] result() for MulticoreFuture ...
[17:02:52.008] result() for MulticoreFuture ... done
[17:02:52.008] signalConditions() ...
[17:02:52.008]  - include = ‘immediateCondition’
[17:02:52.008]  - exclude = 
[17:02:52.009]  - resignal = FALSE
[17:02:52.009]  - Number of conditions: 4
[17:02:52.009] signalConditions() ... done
[17:02:52.009] Future state: ‘finished’
[17:02:52.009] result() for MulticoreFuture ...
[17:02:52.009] result() for MulticoreFuture ... done
[17:02:52.010] signalConditions() ...
[17:02:52.010]  - include = ‘condition’
[17:02:52.010]  - exclude = ‘immediateCondition’
[17:02:52.010]  - resignal = TRUE
[17:02:52.010]  - Number of conditions: 4
[17:02:52.010]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.996] result() for MulticoreFuture ...
[17:02:52.010]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.997] result() for MulticoreFuture ... done
[17:02:52.011]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.997] result() for MulticoreFuture ...
[17:02:52.011]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.997] result() for MulticoreFuture ... done
[17:02:52.011] signalConditions() ... done
value(b) = 2
[17:02:52.011] result() for MulticoreFuture ...
[17:02:52.011] result() for MulticoreFuture ... done
[17:02:52.011] result() for MulticoreFuture ...
[17:02:52.012] result() for MulticoreFuture ... done
[17:02:52.012] signalConditions() ...
[17:02:52.012]  - include = ‘immediateCondition’
[17:02:52.012]  - exclude = 
[17:02:52.012]  - resignal = FALSE
[17:02:52.012]  - Number of conditions: 4
[17:02:52.012] signalConditions() ... done
[17:02:52.012] Future state: ‘finished’
[17:02:52.013] result() for MulticoreFuture ...
[17:02:52.013] result() for MulticoreFuture ... done
[17:02:52.013] signalConditions() ...
[17:02:52.013]  - include = ‘condition’
[17:02:52.013]  - exclude = ‘immediateCondition’
[17:02:52.013]  - resignal = TRUE
[17:02:52.013]  - Number of conditions: 4
[17:02:52.013]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.996] result() for MulticoreFuture ...
[17:02:52.013]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.997] result() for MulticoreFuture ... done
[17:02:52.014]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.997] result() for MulticoreFuture ...
[17:02:52.014]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:51.997] result() for MulticoreFuture ... done
[17:02:52.014] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.014] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.014] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:52.015] 
[17:02:52.015] Searching for globals ... DONE
[17:02:52.015] - globals: [0] <none>
[17:02:52.016] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.016] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.016] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:52.017] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:52.018] Searching for globals ... DONE
[17:02:52.018] Resolving globals: TRUE
[17:02:52.018] Resolving any globals that are futures ...
[17:02:52.018] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:52.018] Resolving any globals that are futures ... DONE
[17:02:52.018] Resolving futures part of globals (recursively) ...
[17:02:52.019] resolve() on list ...
[17:02:52.019]  recursive: 99
[17:02:52.019]  length: 1
[17:02:52.019]  elements: ‘a’
[17:02:52.019] run() for ‘Future’ ...
[17:02:52.019] - state: ‘created’
[17:02:52.020] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.024] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.024]   - Field: ‘label’
[17:02:52.024]   - Field: ‘local’
[17:02:52.024]   - Field: ‘owner’
[17:02:52.024]   - Field: ‘envir’
[17:02:52.025]   - Field: ‘workers’
[17:02:52.025]   - Field: ‘packages’
[17:02:52.025]   - Field: ‘gc’
[17:02:52.025]   - Field: ‘job’
[17:02:52.025]   - Field: ‘conditions’
[17:02:52.025]   - Field: ‘expr’
[17:02:52.025]   - Field: ‘uuid’
[17:02:52.025]   - Field: ‘seed’
[17:02:52.025]   - Field: ‘version’
[17:02:52.026]   - Field: ‘result’
[17:02:52.026]   - Field: ‘asynchronous’
[17:02:52.026]   - Field: ‘calls’
[17:02:52.026]   - Field: ‘globals’
[17:02:52.026]   - Field: ‘stdout’
[17:02:52.026]   - Field: ‘earlySignal’
[17:02:52.026]   - Field: ‘lazy’
[17:02:52.026]   - Field: ‘state’
[17:02:52.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.027] - Launch lazy future ...
[17:02:52.027] Packages needed by the future expression (n = 0): <none>
[17:02:52.027] Packages needed by future strategies (n = 0): <none>
[17:02:52.028] {
[17:02:52.028]     {
[17:02:52.028]         {
[17:02:52.028]             ...future.startTime <- base::Sys.time()
[17:02:52.028]             {
[17:02:52.028]                 {
[17:02:52.028]                   {
[17:02:52.028]                     {
[17:02:52.028]                       base::local({
[17:02:52.028]                         has_future <- base::requireNamespace("future", 
[17:02:52.028]                           quietly = TRUE)
[17:02:52.028]                         if (has_future) {
[17:02:52.028]                           ns <- base::getNamespace("future")
[17:02:52.028]                           version <- ns[[".package"]][["version"]]
[17:02:52.028]                           if (is.null(version)) 
[17:02:52.028]                             version <- utils::packageVersion("future")
[17:02:52.028]                         }
[17:02:52.028]                         else {
[17:02:52.028]                           version <- NULL
[17:02:52.028]                         }
[17:02:52.028]                         if (!has_future || version < "1.8.0") {
[17:02:52.028]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.028]                             "", base::R.version$version.string), 
[17:02:52.028]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.028]                               "release", "version")], collapse = " "), 
[17:02:52.028]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.028]                             info)
[17:02:52.028]                           info <- base::paste(info, collapse = "; ")
[17:02:52.028]                           if (!has_future) {
[17:02:52.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.028]                               info)
[17:02:52.028]                           }
[17:02:52.028]                           else {
[17:02:52.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.028]                               info, version)
[17:02:52.028]                           }
[17:02:52.028]                           base::stop(msg)
[17:02:52.028]                         }
[17:02:52.028]                       })
[17:02:52.028]                     }
[17:02:52.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.028]                     base::options(mc.cores = 1L)
[17:02:52.028]                   }
[17:02:52.028]                   ...future.strategy.old <- future::plan("list")
[17:02:52.028]                   options(future.plan = NULL)
[17:02:52.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.028]                 }
[17:02:52.028]                 ...future.workdir <- getwd()
[17:02:52.028]             }
[17:02:52.028]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.028]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.028]         }
[17:02:52.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.028]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:52.028]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.028]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.028]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.028]             base::names(...future.oldOptions))
[17:02:52.028]     }
[17:02:52.028]     if (FALSE) {
[17:02:52.028]     }
[17:02:52.028]     else {
[17:02:52.028]         if (TRUE) {
[17:02:52.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.028]                 open = "w")
[17:02:52.028]         }
[17:02:52.028]         else {
[17:02:52.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.028]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.028]         }
[17:02:52.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.028]             base::sink(type = "output", split = FALSE)
[17:02:52.028]             base::close(...future.stdout)
[17:02:52.028]         }, add = TRUE)
[17:02:52.028]     }
[17:02:52.028]     ...future.frame <- base::sys.nframe()
[17:02:52.028]     ...future.conditions <- base::list()
[17:02:52.028]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.028]     if (FALSE) {
[17:02:52.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.028]     }
[17:02:52.028]     ...future.result <- base::tryCatch({
[17:02:52.028]         base::withCallingHandlers({
[17:02:52.028]             ...future.value <- base::withVisible(base::local({
[17:02:52.028]                 withCallingHandlers({
[17:02:52.028]                   1
[17:02:52.028]                 }, immediateCondition = function(cond) {
[17:02:52.028]                   save_rds <- function (object, pathname, ...) 
[17:02:52.028]                   {
[17:02:52.028]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.028]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.028]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.028]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.028]                         fi_tmp[["mtime"]])
[17:02:52.028]                     }
[17:02:52.028]                     tryCatch({
[17:02:52.028]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.028]                     }, error = function(ex) {
[17:02:52.028]                       msg <- conditionMessage(ex)
[17:02:52.028]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.028]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.028]                         fi_tmp[["mtime"]], msg)
[17:02:52.028]                       ex$message <- msg
[17:02:52.028]                       stop(ex)
[17:02:52.028]                     })
[17:02:52.028]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.028]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.028]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.028]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.028]                       fi <- file.info(pathname)
[17:02:52.028]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.028]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.028]                         fi[["size"]], fi[["mtime"]])
[17:02:52.028]                       stop(msg)
[17:02:52.028]                     }
[17:02:52.028]                     invisible(pathname)
[17:02:52.028]                   }
[17:02:52.028]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.028]                     rootPath = tempdir()) 
[17:02:52.028]                   {
[17:02:52.028]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.028]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.028]                       tmpdir = path, fileext = ".rds")
[17:02:52.028]                     save_rds(obj, file)
[17:02:52.028]                   }
[17:02:52.028]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.028]                   {
[17:02:52.028]                     inherits <- base::inherits
[17:02:52.028]                     invokeRestart <- base::invokeRestart
[17:02:52.028]                     is.null <- base::is.null
[17:02:52.028]                     muffled <- FALSE
[17:02:52.028]                     if (inherits(cond, "message")) {
[17:02:52.028]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.028]                       if (muffled) 
[17:02:52.028]                         invokeRestart("muffleMessage")
[17:02:52.028]                     }
[17:02:52.028]                     else if (inherits(cond, "warning")) {
[17:02:52.028]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.028]                       if (muffled) 
[17:02:52.028]                         invokeRestart("muffleWarning")
[17:02:52.028]                     }
[17:02:52.028]                     else if (inherits(cond, "condition")) {
[17:02:52.028]                       if (!is.null(pattern)) {
[17:02:52.028]                         computeRestarts <- base::computeRestarts
[17:02:52.028]                         grepl <- base::grepl
[17:02:52.028]                         restarts <- computeRestarts(cond)
[17:02:52.028]                         for (restart in restarts) {
[17:02:52.028]                           name <- restart$name
[17:02:52.028]                           if (is.null(name)) 
[17:02:52.028]                             next
[17:02:52.028]                           if (!grepl(pattern, name)) 
[17:02:52.028]                             next
[17:02:52.028]                           invokeRestart(restart)
[17:02:52.028]                           muffled <- TRUE
[17:02:52.028]                           break
[17:02:52.028]                         }
[17:02:52.028]                       }
[17:02:52.028]                     }
[17:02:52.028]                     invisible(muffled)
[17:02:52.028]                   }
[17:02:52.028]                   muffleCondition(cond)
[17:02:52.028]                 })
[17:02:52.028]             }))
[17:02:52.028]             future::FutureResult(value = ...future.value$value, 
[17:02:52.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.028]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.028]                     ...future.globalenv.names))
[17:02:52.028]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.028]         }, condition = base::local({
[17:02:52.028]             c <- base::c
[17:02:52.028]             inherits <- base::inherits
[17:02:52.028]             invokeRestart <- base::invokeRestart
[17:02:52.028]             length <- base::length
[17:02:52.028]             list <- base::list
[17:02:52.028]             seq.int <- base::seq.int
[17:02:52.028]             signalCondition <- base::signalCondition
[17:02:52.028]             sys.calls <- base::sys.calls
[17:02:52.028]             `[[` <- base::`[[`
[17:02:52.028]             `+` <- base::`+`
[17:02:52.028]             `<<-` <- base::`<<-`
[17:02:52.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.028]                   3L)]
[17:02:52.028]             }
[17:02:52.028]             function(cond) {
[17:02:52.028]                 is_error <- inherits(cond, "error")
[17:02:52.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.028]                   NULL)
[17:02:52.028]                 if (is_error) {
[17:02:52.028]                   sessionInformation <- function() {
[17:02:52.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.028]                       search = base::search(), system = base::Sys.info())
[17:02:52.028]                   }
[17:02:52.028]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.028]                     cond$call), session = sessionInformation(), 
[17:02:52.028]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.028]                   signalCondition(cond)
[17:02:52.028]                 }
[17:02:52.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.028]                 "immediateCondition"))) {
[17:02:52.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.028]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.028]                   if (TRUE && !signal) {
[17:02:52.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.028]                     {
[17:02:52.028]                       inherits <- base::inherits
[17:02:52.028]                       invokeRestart <- base::invokeRestart
[17:02:52.028]                       is.null <- base::is.null
[17:02:52.028]                       muffled <- FALSE
[17:02:52.028]                       if (inherits(cond, "message")) {
[17:02:52.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.028]                         if (muffled) 
[17:02:52.028]                           invokeRestart("muffleMessage")
[17:02:52.028]                       }
[17:02:52.028]                       else if (inherits(cond, "warning")) {
[17:02:52.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.028]                         if (muffled) 
[17:02:52.028]                           invokeRestart("muffleWarning")
[17:02:52.028]                       }
[17:02:52.028]                       else if (inherits(cond, "condition")) {
[17:02:52.028]                         if (!is.null(pattern)) {
[17:02:52.028]                           computeRestarts <- base::computeRestarts
[17:02:52.028]                           grepl <- base::grepl
[17:02:52.028]                           restarts <- computeRestarts(cond)
[17:02:52.028]                           for (restart in restarts) {
[17:02:52.028]                             name <- restart$name
[17:02:52.028]                             if (is.null(name)) 
[17:02:52.028]                               next
[17:02:52.028]                             if (!grepl(pattern, name)) 
[17:02:52.028]                               next
[17:02:52.028]                             invokeRestart(restart)
[17:02:52.028]                             muffled <- TRUE
[17:02:52.028]                             break
[17:02:52.028]                           }
[17:02:52.028]                         }
[17:02:52.028]                       }
[17:02:52.028]                       invisible(muffled)
[17:02:52.028]                     }
[17:02:52.028]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.028]                   }
[17:02:52.028]                 }
[17:02:52.028]                 else {
[17:02:52.028]                   if (TRUE) {
[17:02:52.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.028]                     {
[17:02:52.028]                       inherits <- base::inherits
[17:02:52.028]                       invokeRestart <- base::invokeRestart
[17:02:52.028]                       is.null <- base::is.null
[17:02:52.028]                       muffled <- FALSE
[17:02:52.028]                       if (inherits(cond, "message")) {
[17:02:52.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.028]                         if (muffled) 
[17:02:52.028]                           invokeRestart("muffleMessage")
[17:02:52.028]                       }
[17:02:52.028]                       else if (inherits(cond, "warning")) {
[17:02:52.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.028]                         if (muffled) 
[17:02:52.028]                           invokeRestart("muffleWarning")
[17:02:52.028]                       }
[17:02:52.028]                       else if (inherits(cond, "condition")) {
[17:02:52.028]                         if (!is.null(pattern)) {
[17:02:52.028]                           computeRestarts <- base::computeRestarts
[17:02:52.028]                           grepl <- base::grepl
[17:02:52.028]                           restarts <- computeRestarts(cond)
[17:02:52.028]                           for (restart in restarts) {
[17:02:52.028]                             name <- restart$name
[17:02:52.028]                             if (is.null(name)) 
[17:02:52.028]                               next
[17:02:52.028]                             if (!grepl(pattern, name)) 
[17:02:52.028]                               next
[17:02:52.028]                             invokeRestart(restart)
[17:02:52.028]                             muffled <- TRUE
[17:02:52.028]                             break
[17:02:52.028]                           }
[17:02:52.028]                         }
[17:02:52.028]                       }
[17:02:52.028]                       invisible(muffled)
[17:02:52.028]                     }
[17:02:52.028]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.028]                   }
[17:02:52.028]                 }
[17:02:52.028]             }
[17:02:52.028]         }))
[17:02:52.028]     }, error = function(ex) {
[17:02:52.028]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.028]                 ...future.rng), started = ...future.startTime, 
[17:02:52.028]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.028]             version = "1.8"), class = "FutureResult")
[17:02:52.028]     }, finally = {
[17:02:52.028]         if (!identical(...future.workdir, getwd())) 
[17:02:52.028]             setwd(...future.workdir)
[17:02:52.028]         {
[17:02:52.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.028]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.028]             }
[17:02:52.028]             base::options(...future.oldOptions)
[17:02:52.028]             if (.Platform$OS.type == "windows") {
[17:02:52.028]                 old_names <- names(...future.oldEnvVars)
[17:02:52.028]                 envs <- base::Sys.getenv()
[17:02:52.028]                 names <- names(envs)
[17:02:52.028]                 common <- intersect(names, old_names)
[17:02:52.028]                 added <- setdiff(names, old_names)
[17:02:52.028]                 removed <- setdiff(old_names, names)
[17:02:52.028]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.028]                   envs[common]]
[17:02:52.028]                 NAMES <- toupper(changed)
[17:02:52.028]                 args <- list()
[17:02:52.028]                 for (kk in seq_along(NAMES)) {
[17:02:52.028]                   name <- changed[[kk]]
[17:02:52.028]                   NAME <- NAMES[[kk]]
[17:02:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.028]                     next
[17:02:52.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.028]                 }
[17:02:52.028]                 NAMES <- toupper(added)
[17:02:52.028]                 for (kk in seq_along(NAMES)) {
[17:02:52.028]                   name <- added[[kk]]
[17:02:52.028]                   NAME <- NAMES[[kk]]
[17:02:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.028]                     next
[17:02:52.028]                   args[[name]] <- ""
[17:02:52.028]                 }
[17:02:52.028]                 NAMES <- toupper(removed)
[17:02:52.028]                 for (kk in seq_along(NAMES)) {
[17:02:52.028]                   name <- removed[[kk]]
[17:02:52.028]                   NAME <- NAMES[[kk]]
[17:02:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.028]                     next
[17:02:52.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.028]                 }
[17:02:52.028]                 if (length(args) > 0) 
[17:02:52.028]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.028]             }
[17:02:52.028]             else {
[17:02:52.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.028]             }
[17:02:52.028]             {
[17:02:52.028]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.028]                   0L) {
[17:02:52.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.028]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.028]                   base::options(opts)
[17:02:52.028]                 }
[17:02:52.028]                 {
[17:02:52.028]                   {
[17:02:52.028]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.028]                     NULL
[17:02:52.028]                   }
[17:02:52.028]                   options(future.plan = NULL)
[17:02:52.028]                   if (is.na(NA_character_)) 
[17:02:52.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.028]                     .init = FALSE)
[17:02:52.028]                 }
[17:02:52.028]             }
[17:02:52.028]         }
[17:02:52.028]     })
[17:02:52.028]     if (TRUE) {
[17:02:52.028]         base::sink(type = "output", split = FALSE)
[17:02:52.028]         if (TRUE) {
[17:02:52.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.028]         }
[17:02:52.028]         else {
[17:02:52.028]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.028]         }
[17:02:52.028]         base::close(...future.stdout)
[17:02:52.028]         ...future.stdout <- NULL
[17:02:52.028]     }
[17:02:52.028]     ...future.result$conditions <- ...future.conditions
[17:02:52.028]     ...future.result$finished <- base::Sys.time()
[17:02:52.028]     ...future.result
[17:02:52.028] }
[17:02:52.030] requestCore(): workers = 2
[17:02:52.032] MulticoreFuture started
[17:02:52.033] - Launch lazy future ... done
[17:02:52.033] run() for ‘MulticoreFuture’ ... done
[17:02:52.033] plan(): Setting new future strategy stack:
[17:02:52.034] List of future strategies:
[17:02:52.034] 1. sequential:
[17:02:52.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.034]    - tweaked: FALSE
[17:02:52.034]    - call: NULL
[17:02:52.035] plan(): nbrOfWorkers() = 1
[17:02:52.037] plan(): Setting new future strategy stack:
[17:02:52.037] List of future strategies:
[17:02:52.037] 1. multicore:
[17:02:52.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.037]    - tweaked: FALSE
[17:02:52.037]    - call: plan(strategy)
[17:02:52.049] plan(): nbrOfWorkers() = 2
[17:02:52.054] Future #1
[17:02:52.054] result() for MulticoreFuture ...
[17:02:52.055] result() for MulticoreFuture ...
[17:02:52.056] result() for MulticoreFuture ... done
[17:02:52.056] result() for MulticoreFuture ... done
[17:02:52.056] result() for MulticoreFuture ...
[17:02:52.056] result() for MulticoreFuture ... done
[17:02:52.056] A MulticoreFuture was resolved
[17:02:52.056]  length: 0 (resolved future 1)
[17:02:52.056] resolve() on list ... DONE
[17:02:52.059] - globals: [1] ‘a’
[17:02:52.060] Resolving futures part of globals (recursively) ... DONE
[17:02:52.062] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:02:52.062] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:02:52.063] - globals: [1] ‘a’
[17:02:52.063] - packages: [1] ‘future’
[17:02:52.063] getGlobalsAndPackages() ... DONE
[17:02:52.063] run() for ‘Future’ ...
[17:02:52.064] - state: ‘created’
[17:02:52.064] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.068] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.069]   - Field: ‘label’
[17:02:52.069]   - Field: ‘local’
[17:02:52.069]   - Field: ‘owner’
[17:02:52.069]   - Field: ‘envir’
[17:02:52.069]   - Field: ‘workers’
[17:02:52.069]   - Field: ‘packages’
[17:02:52.070]   - Field: ‘gc’
[17:02:52.070]   - Field: ‘job’
[17:02:52.070]   - Field: ‘conditions’
[17:02:52.070]   - Field: ‘expr’
[17:02:52.070]   - Field: ‘uuid’
[17:02:52.070]   - Field: ‘seed’
[17:02:52.070]   - Field: ‘version’
[17:02:52.070]   - Field: ‘result’
[17:02:52.071]   - Field: ‘asynchronous’
[17:02:52.071]   - Field: ‘calls’
[17:02:52.071]   - Field: ‘globals’
[17:02:52.071]   - Field: ‘stdout’
[17:02:52.071]   - Field: ‘earlySignal’
[17:02:52.071]   - Field: ‘lazy’
[17:02:52.071]   - Field: ‘state’
[17:02:52.071] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.071] - Launch lazy future ...
[17:02:52.072] Packages needed by the future expression (n = 1): ‘future’
[17:02:52.072] Packages needed by future strategies (n = 0): <none>
[17:02:52.073] {
[17:02:52.073]     {
[17:02:52.073]         {
[17:02:52.073]             ...future.startTime <- base::Sys.time()
[17:02:52.073]             {
[17:02:52.073]                 {
[17:02:52.073]                   {
[17:02:52.073]                     {
[17:02:52.073]                       {
[17:02:52.073]                         base::local({
[17:02:52.073]                           has_future <- base::requireNamespace("future", 
[17:02:52.073]                             quietly = TRUE)
[17:02:52.073]                           if (has_future) {
[17:02:52.073]                             ns <- base::getNamespace("future")
[17:02:52.073]                             version <- ns[[".package"]][["version"]]
[17:02:52.073]                             if (is.null(version)) 
[17:02:52.073]                               version <- utils::packageVersion("future")
[17:02:52.073]                           }
[17:02:52.073]                           else {
[17:02:52.073]                             version <- NULL
[17:02:52.073]                           }
[17:02:52.073]                           if (!has_future || version < "1.8.0") {
[17:02:52.073]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.073]                               "", base::R.version$version.string), 
[17:02:52.073]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:52.073]                                 base::R.version$platform, 8 * 
[17:02:52.073]                                   base::.Machine$sizeof.pointer), 
[17:02:52.073]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.073]                                 "release", "version")], collapse = " "), 
[17:02:52.073]                               hostname = base::Sys.info()[["nodename"]])
[17:02:52.073]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.073]                               info)
[17:02:52.073]                             info <- base::paste(info, collapse = "; ")
[17:02:52.073]                             if (!has_future) {
[17:02:52.073]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.073]                                 info)
[17:02:52.073]                             }
[17:02:52.073]                             else {
[17:02:52.073]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.073]                                 info, version)
[17:02:52.073]                             }
[17:02:52.073]                             base::stop(msg)
[17:02:52.073]                           }
[17:02:52.073]                         })
[17:02:52.073]                       }
[17:02:52.073]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.073]                       base::options(mc.cores = 1L)
[17:02:52.073]                     }
[17:02:52.073]                     base::local({
[17:02:52.073]                       for (pkg in "future") {
[17:02:52.073]                         base::loadNamespace(pkg)
[17:02:52.073]                         base::library(pkg, character.only = TRUE)
[17:02:52.073]                       }
[17:02:52.073]                     })
[17:02:52.073]                   }
[17:02:52.073]                   ...future.strategy.old <- future::plan("list")
[17:02:52.073]                   options(future.plan = NULL)
[17:02:52.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.073]                 }
[17:02:52.073]                 ...future.workdir <- getwd()
[17:02:52.073]             }
[17:02:52.073]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.073]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.073]         }
[17:02:52.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.073]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:52.073]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.073]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.073]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.073]             base::names(...future.oldOptions))
[17:02:52.073]     }
[17:02:52.073]     if (FALSE) {
[17:02:52.073]     }
[17:02:52.073]     else {
[17:02:52.073]         if (TRUE) {
[17:02:52.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.073]                 open = "w")
[17:02:52.073]         }
[17:02:52.073]         else {
[17:02:52.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.073]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.073]         }
[17:02:52.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.073]             base::sink(type = "output", split = FALSE)
[17:02:52.073]             base::close(...future.stdout)
[17:02:52.073]         }, add = TRUE)
[17:02:52.073]     }
[17:02:52.073]     ...future.frame <- base::sys.nframe()
[17:02:52.073]     ...future.conditions <- base::list()
[17:02:52.073]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.073]     if (FALSE) {
[17:02:52.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.073]     }
[17:02:52.073]     ...future.result <- base::tryCatch({
[17:02:52.073]         base::withCallingHandlers({
[17:02:52.073]             ...future.value <- base::withVisible(base::local({
[17:02:52.073]                 withCallingHandlers({
[17:02:52.073]                   value(a) + 1
[17:02:52.073]                 }, immediateCondition = function(cond) {
[17:02:52.073]                   save_rds <- function (object, pathname, ...) 
[17:02:52.073]                   {
[17:02:52.073]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.073]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.073]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.073]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.073]                         fi_tmp[["mtime"]])
[17:02:52.073]                     }
[17:02:52.073]                     tryCatch({
[17:02:52.073]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.073]                     }, error = function(ex) {
[17:02:52.073]                       msg <- conditionMessage(ex)
[17:02:52.073]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.073]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.073]                         fi_tmp[["mtime"]], msg)
[17:02:52.073]                       ex$message <- msg
[17:02:52.073]                       stop(ex)
[17:02:52.073]                     })
[17:02:52.073]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.073]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.073]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.073]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.073]                       fi <- file.info(pathname)
[17:02:52.073]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.073]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.073]                         fi[["size"]], fi[["mtime"]])
[17:02:52.073]                       stop(msg)
[17:02:52.073]                     }
[17:02:52.073]                     invisible(pathname)
[17:02:52.073]                   }
[17:02:52.073]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.073]                     rootPath = tempdir()) 
[17:02:52.073]                   {
[17:02:52.073]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.073]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.073]                       tmpdir = path, fileext = ".rds")
[17:02:52.073]                     save_rds(obj, file)
[17:02:52.073]                   }
[17:02:52.073]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.073]                   {
[17:02:52.073]                     inherits <- base::inherits
[17:02:52.073]                     invokeRestart <- base::invokeRestart
[17:02:52.073]                     is.null <- base::is.null
[17:02:52.073]                     muffled <- FALSE
[17:02:52.073]                     if (inherits(cond, "message")) {
[17:02:52.073]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.073]                       if (muffled) 
[17:02:52.073]                         invokeRestart("muffleMessage")
[17:02:52.073]                     }
[17:02:52.073]                     else if (inherits(cond, "warning")) {
[17:02:52.073]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.073]                       if (muffled) 
[17:02:52.073]                         invokeRestart("muffleWarning")
[17:02:52.073]                     }
[17:02:52.073]                     else if (inherits(cond, "condition")) {
[17:02:52.073]                       if (!is.null(pattern)) {
[17:02:52.073]                         computeRestarts <- base::computeRestarts
[17:02:52.073]                         grepl <- base::grepl
[17:02:52.073]                         restarts <- computeRestarts(cond)
[17:02:52.073]                         for (restart in restarts) {
[17:02:52.073]                           name <- restart$name
[17:02:52.073]                           if (is.null(name)) 
[17:02:52.073]                             next
[17:02:52.073]                           if (!grepl(pattern, name)) 
[17:02:52.073]                             next
[17:02:52.073]                           invokeRestart(restart)
[17:02:52.073]                           muffled <- TRUE
[17:02:52.073]                           break
[17:02:52.073]                         }
[17:02:52.073]                       }
[17:02:52.073]                     }
[17:02:52.073]                     invisible(muffled)
[17:02:52.073]                   }
[17:02:52.073]                   muffleCondition(cond)
[17:02:52.073]                 })
[17:02:52.073]             }))
[17:02:52.073]             future::FutureResult(value = ...future.value$value, 
[17:02:52.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.073]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.073]                     ...future.globalenv.names))
[17:02:52.073]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.073]         }, condition = base::local({
[17:02:52.073]             c <- base::c
[17:02:52.073]             inherits <- base::inherits
[17:02:52.073]             invokeRestart <- base::invokeRestart
[17:02:52.073]             length <- base::length
[17:02:52.073]             list <- base::list
[17:02:52.073]             seq.int <- base::seq.int
[17:02:52.073]             signalCondition <- base::signalCondition
[17:02:52.073]             sys.calls <- base::sys.calls
[17:02:52.073]             `[[` <- base::`[[`
[17:02:52.073]             `+` <- base::`+`
[17:02:52.073]             `<<-` <- base::`<<-`
[17:02:52.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.073]                   3L)]
[17:02:52.073]             }
[17:02:52.073]             function(cond) {
[17:02:52.073]                 is_error <- inherits(cond, "error")
[17:02:52.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.073]                   NULL)
[17:02:52.073]                 if (is_error) {
[17:02:52.073]                   sessionInformation <- function() {
[17:02:52.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.073]                       search = base::search(), system = base::Sys.info())
[17:02:52.073]                   }
[17:02:52.073]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.073]                     cond$call), session = sessionInformation(), 
[17:02:52.073]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.073]                   signalCondition(cond)
[17:02:52.073]                 }
[17:02:52.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.073]                 "immediateCondition"))) {
[17:02:52.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.073]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.073]                   if (TRUE && !signal) {
[17:02:52.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.073]                     {
[17:02:52.073]                       inherits <- base::inherits
[17:02:52.073]                       invokeRestart <- base::invokeRestart
[17:02:52.073]                       is.null <- base::is.null
[17:02:52.073]                       muffled <- FALSE
[17:02:52.073]                       if (inherits(cond, "message")) {
[17:02:52.073]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.073]                         if (muffled) 
[17:02:52.073]                           invokeRestart("muffleMessage")
[17:02:52.073]                       }
[17:02:52.073]                       else if (inherits(cond, "warning")) {
[17:02:52.073]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.073]                         if (muffled) 
[17:02:52.073]                           invokeRestart("muffleWarning")
[17:02:52.073]                       }
[17:02:52.073]                       else if (inherits(cond, "condition")) {
[17:02:52.073]                         if (!is.null(pattern)) {
[17:02:52.073]                           computeRestarts <- base::computeRestarts
[17:02:52.073]                           grepl <- base::grepl
[17:02:52.073]                           restarts <- computeRestarts(cond)
[17:02:52.073]                           for (restart in restarts) {
[17:02:52.073]                             name <- restart$name
[17:02:52.073]                             if (is.null(name)) 
[17:02:52.073]                               next
[17:02:52.073]                             if (!grepl(pattern, name)) 
[17:02:52.073]                               next
[17:02:52.073]                             invokeRestart(restart)
[17:02:52.073]                             muffled <- TRUE
[17:02:52.073]                             break
[17:02:52.073]                           }
[17:02:52.073]                         }
[17:02:52.073]                       }
[17:02:52.073]                       invisible(muffled)
[17:02:52.073]                     }
[17:02:52.073]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.073]                   }
[17:02:52.073]                 }
[17:02:52.073]                 else {
[17:02:52.073]                   if (TRUE) {
[17:02:52.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.073]                     {
[17:02:52.073]                       inherits <- base::inherits
[17:02:52.073]                       invokeRestart <- base::invokeRestart
[17:02:52.073]                       is.null <- base::is.null
[17:02:52.073]                       muffled <- FALSE
[17:02:52.073]                       if (inherits(cond, "message")) {
[17:02:52.073]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.073]                         if (muffled) 
[17:02:52.073]                           invokeRestart("muffleMessage")
[17:02:52.073]                       }
[17:02:52.073]                       else if (inherits(cond, "warning")) {
[17:02:52.073]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.073]                         if (muffled) 
[17:02:52.073]                           invokeRestart("muffleWarning")
[17:02:52.073]                       }
[17:02:52.073]                       else if (inherits(cond, "condition")) {
[17:02:52.073]                         if (!is.null(pattern)) {
[17:02:52.073]                           computeRestarts <- base::computeRestarts
[17:02:52.073]                           grepl <- base::grepl
[17:02:52.073]                           restarts <- computeRestarts(cond)
[17:02:52.073]                           for (restart in restarts) {
[17:02:52.073]                             name <- restart$name
[17:02:52.073]                             if (is.null(name)) 
[17:02:52.073]                               next
[17:02:52.073]                             if (!grepl(pattern, name)) 
[17:02:52.073]                               next
[17:02:52.073]                             invokeRestart(restart)
[17:02:52.073]                             muffled <- TRUE
[17:02:52.073]                             break
[17:02:52.073]                           }
[17:02:52.073]                         }
[17:02:52.073]                       }
[17:02:52.073]                       invisible(muffled)
[17:02:52.073]                     }
[17:02:52.073]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.073]                   }
[17:02:52.073]                 }
[17:02:52.073]             }
[17:02:52.073]         }))
[17:02:52.073]     }, error = function(ex) {
[17:02:52.073]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.073]                 ...future.rng), started = ...future.startTime, 
[17:02:52.073]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.073]             version = "1.8"), class = "FutureResult")
[17:02:52.073]     }, finally = {
[17:02:52.073]         if (!identical(...future.workdir, getwd())) 
[17:02:52.073]             setwd(...future.workdir)
[17:02:52.073]         {
[17:02:52.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.073]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.073]             }
[17:02:52.073]             base::options(...future.oldOptions)
[17:02:52.073]             if (.Platform$OS.type == "windows") {
[17:02:52.073]                 old_names <- names(...future.oldEnvVars)
[17:02:52.073]                 envs <- base::Sys.getenv()
[17:02:52.073]                 names <- names(envs)
[17:02:52.073]                 common <- intersect(names, old_names)
[17:02:52.073]                 added <- setdiff(names, old_names)
[17:02:52.073]                 removed <- setdiff(old_names, names)
[17:02:52.073]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.073]                   envs[common]]
[17:02:52.073]                 NAMES <- toupper(changed)
[17:02:52.073]                 args <- list()
[17:02:52.073]                 for (kk in seq_along(NAMES)) {
[17:02:52.073]                   name <- changed[[kk]]
[17:02:52.073]                   NAME <- NAMES[[kk]]
[17:02:52.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.073]                     next
[17:02:52.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.073]                 }
[17:02:52.073]                 NAMES <- toupper(added)
[17:02:52.073]                 for (kk in seq_along(NAMES)) {
[17:02:52.073]                   name <- added[[kk]]
[17:02:52.073]                   NAME <- NAMES[[kk]]
[17:02:52.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.073]                     next
[17:02:52.073]                   args[[name]] <- ""
[17:02:52.073]                 }
[17:02:52.073]                 NAMES <- toupper(removed)
[17:02:52.073]                 for (kk in seq_along(NAMES)) {
[17:02:52.073]                   name <- removed[[kk]]
[17:02:52.073]                   NAME <- NAMES[[kk]]
[17:02:52.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.073]                     next
[17:02:52.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.073]                 }
[17:02:52.073]                 if (length(args) > 0) 
[17:02:52.073]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.073]             }
[17:02:52.073]             else {
[17:02:52.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.073]             }
[17:02:52.073]             {
[17:02:52.073]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.073]                   0L) {
[17:02:52.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.073]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.073]                   base::options(opts)
[17:02:52.073]                 }
[17:02:52.073]                 {
[17:02:52.073]                   {
[17:02:52.073]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.073]                     NULL
[17:02:52.073]                   }
[17:02:52.073]                   options(future.plan = NULL)
[17:02:52.073]                   if (is.na(NA_character_)) 
[17:02:52.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.073]                     .init = FALSE)
[17:02:52.073]                 }
[17:02:52.073]             }
[17:02:52.073]         }
[17:02:52.073]     })
[17:02:52.073]     if (TRUE) {
[17:02:52.073]         base::sink(type = "output", split = FALSE)
[17:02:52.073]         if (TRUE) {
[17:02:52.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.073]         }
[17:02:52.073]         else {
[17:02:52.073]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.073]         }
[17:02:52.073]         base::close(...future.stdout)
[17:02:52.073]         ...future.stdout <- NULL
[17:02:52.073]     }
[17:02:52.073]     ...future.result$conditions <- ...future.conditions
[17:02:52.073]     ...future.result$finished <- base::Sys.time()
[17:02:52.073]     ...future.result
[17:02:52.073] }
[17:02:52.075] assign_globals() ...
[17:02:52.075] List of 1
[17:02:52.075]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f5e0e770> 
[17:02:52.075]  - attr(*, "where")=List of 1
[17:02:52.075]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.075]  - attr(*, "resolved")= logi TRUE
[17:02:52.075]  - attr(*, "total_size")= num 10984
[17:02:52.075]  - attr(*, "already-done")= logi TRUE
[17:02:52.078] - copied ‘a’ to environment
[17:02:52.078] assign_globals() ... done
[17:02:52.078] requestCore(): workers = 2
[17:02:52.081] MulticoreFuture started
[17:02:52.081] - Launch lazy future ... done
[17:02:52.081] run() for ‘MulticoreFuture’ ... done
[17:02:52.081] result() for MulticoreFuture ...
[17:02:52.082] plan(): Setting new future strategy stack:
[17:02:52.082] List of future strategies:
[17:02:52.082] 1. sequential:
[17:02:52.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.082]    - tweaked: FALSE
[17:02:52.082]    - call: NULL
[17:02:52.083] plan(): nbrOfWorkers() = 1
[17:02:52.087] plan(): Setting new future strategy stack:
[17:02:52.087] List of future strategies:
[17:02:52.087] 1. multicore:
[17:02:52.087]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.087]    - tweaked: FALSE
[17:02:52.087]    - call: plan(strategy)
[17:02:52.092] plan(): nbrOfWorkers() = 2
[17:02:52.093] result() for MulticoreFuture ...
[17:02:52.093] result() for MulticoreFuture ... done
[17:02:52.093] signalConditions() ...
[17:02:52.093]  - include = ‘immediateCondition’
[17:02:52.093]  - exclude = 
[17:02:52.093]  - resignal = FALSE
[17:02:52.094]  - Number of conditions: 4
[17:02:52.094] signalConditions() ... done
[17:02:52.094] result() for MulticoreFuture ... done
[17:02:52.094] result() for MulticoreFuture ...
[17:02:52.094] result() for MulticoreFuture ... done
[17:02:52.094] signalConditions() ...
[17:02:52.094]  - include = ‘immediateCondition’
[17:02:52.094]  - exclude = 
[17:02:52.095]  - resignal = FALSE
[17:02:52.095]  - Number of conditions: 4
[17:02:52.095] signalConditions() ... done
[17:02:52.095] Future state: ‘finished’
[17:02:52.095] result() for MulticoreFuture ...
[17:02:52.095] result() for MulticoreFuture ... done
[17:02:52.095] signalConditions() ...
[17:02:52.096]  - include = ‘condition’
[17:02:52.096]  - exclude = ‘immediateCondition’
[17:02:52.096]  - resignal = TRUE
[17:02:52.096]  - Number of conditions: 4
[17:02:52.096]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ...
[17:02:52.096]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ... done
[17:02:52.096]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ...
[17:02:52.097]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ... done
[17:02:52.097] signalConditions() ... done
value(b) = 2
[17:02:52.097] result() for MulticoreFuture ...
[17:02:52.097] result() for MulticoreFuture ... done
[17:02:52.097] result() for MulticoreFuture ...
[17:02:52.097] result() for MulticoreFuture ... done
[17:02:52.097] signalConditions() ...
[17:02:52.097]  - include = ‘immediateCondition’
[17:02:52.098]  - exclude = 
[17:02:52.098]  - resignal = FALSE
[17:02:52.098]  - Number of conditions: 4
[17:02:52.098] signalConditions() ... done
[17:02:52.098] Future state: ‘finished’
[17:02:52.098] result() for MulticoreFuture ...
[17:02:52.098] result() for MulticoreFuture ... done
[17:02:52.098] signalConditions() ...
[17:02:52.099]  - include = ‘condition’
[17:02:52.099]  - exclude = ‘immediateCondition’
[17:02:52.099]  - resignal = TRUE
[17:02:52.099]  - Number of conditions: 4
[17:02:52.099]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ...
[17:02:52.099]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ... done
[17:02:52.099]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ...
[17:02:52.099]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.085] result() for MulticoreFuture ... done
[17:02:52.100] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.100] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.100] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:52.101] - globals found: [2] ‘{’, ‘pkg’
[17:02:52.102] Searching for globals ... DONE
[17:02:52.102] Resolving globals: TRUE
[17:02:52.102] Resolving any globals that are futures ...
[17:02:52.102] - globals: [2] ‘{’, ‘pkg’
[17:02:52.102] Resolving any globals that are futures ... DONE
[17:02:52.102] Resolving futures part of globals (recursively) ...
[17:02:52.103] resolve() on list ...
[17:02:52.103]  recursive: 99
[17:02:52.105]  length: 1
[17:02:52.106]  elements: ‘pkg’
[17:02:52.106]  length: 0 (resolved future 1)
[17:02:52.106] resolve() on list ... DONE
[17:02:52.106] - globals: [1] ‘pkg’
[17:02:52.106] Resolving futures part of globals (recursively) ... DONE
[17:02:52.107] The total size of the 1 globals is 112 bytes (112 bytes)
[17:02:52.107] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:02:52.108] - globals: [1] ‘pkg’
[17:02:52.108] 
[17:02:52.108] getGlobalsAndPackages() ... DONE
[17:02:52.108] Packages needed by the future expression (n = 0): <none>
[17:02:52.109] Packages needed by future strategies (n = 0): <none>
[17:02:52.109] {
[17:02:52.109]     {
[17:02:52.109]         {
[17:02:52.109]             ...future.startTime <- base::Sys.time()
[17:02:52.109]             {
[17:02:52.109]                 {
[17:02:52.109]                   {
[17:02:52.109]                     base::local({
[17:02:52.109]                       has_future <- base::requireNamespace("future", 
[17:02:52.109]                         quietly = TRUE)
[17:02:52.109]                       if (has_future) {
[17:02:52.109]                         ns <- base::getNamespace("future")
[17:02:52.109]                         version <- ns[[".package"]][["version"]]
[17:02:52.109]                         if (is.null(version)) 
[17:02:52.109]                           version <- utils::packageVersion("future")
[17:02:52.109]                       }
[17:02:52.109]                       else {
[17:02:52.109]                         version <- NULL
[17:02:52.109]                       }
[17:02:52.109]                       if (!has_future || version < "1.8.0") {
[17:02:52.109]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.109]                           "", base::R.version$version.string), 
[17:02:52.109]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:52.109]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.109]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.109]                             "release", "version")], collapse = " "), 
[17:02:52.109]                           hostname = base::Sys.info()[["nodename"]])
[17:02:52.109]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.109]                           info)
[17:02:52.109]                         info <- base::paste(info, collapse = "; ")
[17:02:52.109]                         if (!has_future) {
[17:02:52.109]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.109]                             info)
[17:02:52.109]                         }
[17:02:52.109]                         else {
[17:02:52.109]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.109]                             info, version)
[17:02:52.109]                         }
[17:02:52.109]                         base::stop(msg)
[17:02:52.109]                       }
[17:02:52.109]                     })
[17:02:52.109]                   }
[17:02:52.109]                   ...future.strategy.old <- future::plan("list")
[17:02:52.109]                   options(future.plan = NULL)
[17:02:52.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.109]                 }
[17:02:52.109]                 ...future.workdir <- getwd()
[17:02:52.109]             }
[17:02:52.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.109]         }
[17:02:52.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.109]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:52.109]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.109]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.109]             base::names(...future.oldOptions))
[17:02:52.109]     }
[17:02:52.109]     if (FALSE) {
[17:02:52.109]     }
[17:02:52.109]     else {
[17:02:52.109]         if (TRUE) {
[17:02:52.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.109]                 open = "w")
[17:02:52.109]         }
[17:02:52.109]         else {
[17:02:52.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.109]         }
[17:02:52.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.109]             base::sink(type = "output", split = FALSE)
[17:02:52.109]             base::close(...future.stdout)
[17:02:52.109]         }, add = TRUE)
[17:02:52.109]     }
[17:02:52.109]     ...future.frame <- base::sys.nframe()
[17:02:52.109]     ...future.conditions <- base::list()
[17:02:52.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.109]     if (FALSE) {
[17:02:52.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.109]     }
[17:02:52.109]     ...future.result <- base::tryCatch({
[17:02:52.109]         base::withCallingHandlers({
[17:02:52.109]             ...future.value <- base::withVisible(base::local({
[17:02:52.109]                 pkg
[17:02:52.109]             }))
[17:02:52.109]             future::FutureResult(value = ...future.value$value, 
[17:02:52.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.109]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.109]                     ...future.globalenv.names))
[17:02:52.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.109]         }, condition = base::local({
[17:02:52.109]             c <- base::c
[17:02:52.109]             inherits <- base::inherits
[17:02:52.109]             invokeRestart <- base::invokeRestart
[17:02:52.109]             length <- base::length
[17:02:52.109]             list <- base::list
[17:02:52.109]             seq.int <- base::seq.int
[17:02:52.109]             signalCondition <- base::signalCondition
[17:02:52.109]             sys.calls <- base::sys.calls
[17:02:52.109]             `[[` <- base::`[[`
[17:02:52.109]             `+` <- base::`+`
[17:02:52.109]             `<<-` <- base::`<<-`
[17:02:52.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.109]                   3L)]
[17:02:52.109]             }
[17:02:52.109]             function(cond) {
[17:02:52.109]                 is_error <- inherits(cond, "error")
[17:02:52.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.109]                   NULL)
[17:02:52.109]                 if (is_error) {
[17:02:52.109]                   sessionInformation <- function() {
[17:02:52.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.109]                       search = base::search(), system = base::Sys.info())
[17:02:52.109]                   }
[17:02:52.109]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.109]                     cond$call), session = sessionInformation(), 
[17:02:52.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.109]                   signalCondition(cond)
[17:02:52.109]                 }
[17:02:52.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.109]                 "immediateCondition"))) {
[17:02:52.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.109]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.109]                   if (TRUE && !signal) {
[17:02:52.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.109]                     {
[17:02:52.109]                       inherits <- base::inherits
[17:02:52.109]                       invokeRestart <- base::invokeRestart
[17:02:52.109]                       is.null <- base::is.null
[17:02:52.109]                       muffled <- FALSE
[17:02:52.109]                       if (inherits(cond, "message")) {
[17:02:52.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.109]                         if (muffled) 
[17:02:52.109]                           invokeRestart("muffleMessage")
[17:02:52.109]                       }
[17:02:52.109]                       else if (inherits(cond, "warning")) {
[17:02:52.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.109]                         if (muffled) 
[17:02:52.109]                           invokeRestart("muffleWarning")
[17:02:52.109]                       }
[17:02:52.109]                       else if (inherits(cond, "condition")) {
[17:02:52.109]                         if (!is.null(pattern)) {
[17:02:52.109]                           computeRestarts <- base::computeRestarts
[17:02:52.109]                           grepl <- base::grepl
[17:02:52.109]                           restarts <- computeRestarts(cond)
[17:02:52.109]                           for (restart in restarts) {
[17:02:52.109]                             name <- restart$name
[17:02:52.109]                             if (is.null(name)) 
[17:02:52.109]                               next
[17:02:52.109]                             if (!grepl(pattern, name)) 
[17:02:52.109]                               next
[17:02:52.109]                             invokeRestart(restart)
[17:02:52.109]                             muffled <- TRUE
[17:02:52.109]                             break
[17:02:52.109]                           }
[17:02:52.109]                         }
[17:02:52.109]                       }
[17:02:52.109]                       invisible(muffled)
[17:02:52.109]                     }
[17:02:52.109]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.109]                   }
[17:02:52.109]                 }
[17:02:52.109]                 else {
[17:02:52.109]                   if (TRUE) {
[17:02:52.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.109]                     {
[17:02:52.109]                       inherits <- base::inherits
[17:02:52.109]                       invokeRestart <- base::invokeRestart
[17:02:52.109]                       is.null <- base::is.null
[17:02:52.109]                       muffled <- FALSE
[17:02:52.109]                       if (inherits(cond, "message")) {
[17:02:52.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.109]                         if (muffled) 
[17:02:52.109]                           invokeRestart("muffleMessage")
[17:02:52.109]                       }
[17:02:52.109]                       else if (inherits(cond, "warning")) {
[17:02:52.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.109]                         if (muffled) 
[17:02:52.109]                           invokeRestart("muffleWarning")
[17:02:52.109]                       }
[17:02:52.109]                       else if (inherits(cond, "condition")) {
[17:02:52.109]                         if (!is.null(pattern)) {
[17:02:52.109]                           computeRestarts <- base::computeRestarts
[17:02:52.109]                           grepl <- base::grepl
[17:02:52.109]                           restarts <- computeRestarts(cond)
[17:02:52.109]                           for (restart in restarts) {
[17:02:52.109]                             name <- restart$name
[17:02:52.109]                             if (is.null(name)) 
[17:02:52.109]                               next
[17:02:52.109]                             if (!grepl(pattern, name)) 
[17:02:52.109]                               next
[17:02:52.109]                             invokeRestart(restart)
[17:02:52.109]                             muffled <- TRUE
[17:02:52.109]                             break
[17:02:52.109]                           }
[17:02:52.109]                         }
[17:02:52.109]                       }
[17:02:52.109]                       invisible(muffled)
[17:02:52.109]                     }
[17:02:52.109]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.109]                   }
[17:02:52.109]                 }
[17:02:52.109]             }
[17:02:52.109]         }))
[17:02:52.109]     }, error = function(ex) {
[17:02:52.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.109]                 ...future.rng), started = ...future.startTime, 
[17:02:52.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.109]             version = "1.8"), class = "FutureResult")
[17:02:52.109]     }, finally = {
[17:02:52.109]         if (!identical(...future.workdir, getwd())) 
[17:02:52.109]             setwd(...future.workdir)
[17:02:52.109]         {
[17:02:52.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.109]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.109]             }
[17:02:52.109]             base::options(...future.oldOptions)
[17:02:52.109]             if (.Platform$OS.type == "windows") {
[17:02:52.109]                 old_names <- names(...future.oldEnvVars)
[17:02:52.109]                 envs <- base::Sys.getenv()
[17:02:52.109]                 names <- names(envs)
[17:02:52.109]                 common <- intersect(names, old_names)
[17:02:52.109]                 added <- setdiff(names, old_names)
[17:02:52.109]                 removed <- setdiff(old_names, names)
[17:02:52.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.109]                   envs[common]]
[17:02:52.109]                 NAMES <- toupper(changed)
[17:02:52.109]                 args <- list()
[17:02:52.109]                 for (kk in seq_along(NAMES)) {
[17:02:52.109]                   name <- changed[[kk]]
[17:02:52.109]                   NAME <- NAMES[[kk]]
[17:02:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.109]                     next
[17:02:52.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.109]                 }
[17:02:52.109]                 NAMES <- toupper(added)
[17:02:52.109]                 for (kk in seq_along(NAMES)) {
[17:02:52.109]                   name <- added[[kk]]
[17:02:52.109]                   NAME <- NAMES[[kk]]
[17:02:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.109]                     next
[17:02:52.109]                   args[[name]] <- ""
[17:02:52.109]                 }
[17:02:52.109]                 NAMES <- toupper(removed)
[17:02:52.109]                 for (kk in seq_along(NAMES)) {
[17:02:52.109]                   name <- removed[[kk]]
[17:02:52.109]                   NAME <- NAMES[[kk]]
[17:02:52.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.109]                     next
[17:02:52.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.109]                 }
[17:02:52.109]                 if (length(args) > 0) 
[17:02:52.109]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.109]             }
[17:02:52.109]             else {
[17:02:52.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.109]             }
[17:02:52.109]             {
[17:02:52.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.109]                   0L) {
[17:02:52.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.109]                   base::options(opts)
[17:02:52.109]                 }
[17:02:52.109]                 {
[17:02:52.109]                   {
[17:02:52.109]                     NULL
[17:02:52.109]                     RNGkind("Mersenne-Twister")
[17:02:52.109]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:52.109]                       inherits = FALSE)
[17:02:52.109]                   }
[17:02:52.109]                   options(future.plan = NULL)
[17:02:52.109]                   if (is.na(NA_character_)) 
[17:02:52.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.109]                     .init = FALSE)
[17:02:52.109]                 }
[17:02:52.109]             }
[17:02:52.109]         }
[17:02:52.109]     })
[17:02:52.109]     if (TRUE) {
[17:02:52.109]         base::sink(type = "output", split = FALSE)
[17:02:52.109]         if (TRUE) {
[17:02:52.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.109]         }
[17:02:52.109]         else {
[17:02:52.109]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.109]         }
[17:02:52.109]         base::close(...future.stdout)
[17:02:52.109]         ...future.stdout <- NULL
[17:02:52.109]     }
[17:02:52.109]     ...future.result$conditions <- ...future.conditions
[17:02:52.109]     ...future.result$finished <- base::Sys.time()
[17:02:52.109]     ...future.result
[17:02:52.109] }
[17:02:52.111] assign_globals() ...
[17:02:52.111] List of 1
[17:02:52.111]  $ pkg: chr "foo"
[17:02:52.111]  - attr(*, "where")=List of 1
[17:02:52.111]   ..$ pkg:<environment: R_EmptyEnv> 
[17:02:52.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.111]  - attr(*, "resolved")= logi TRUE
[17:02:52.111]  - attr(*, "total_size")= num 112
[17:02:52.114] - copied ‘pkg’ to environment
[17:02:52.114] assign_globals() ... done
[17:02:52.114] plan(): Setting new future strategy stack:
[17:02:52.114] List of future strategies:
[17:02:52.114] 1. sequential:
[17:02:52.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.114]    - tweaked: FALSE
[17:02:52.114]    - call: NULL
[17:02:52.115] plan(): nbrOfWorkers() = 1
[17:02:52.116] plan(): Setting new future strategy stack:
[17:02:52.116] List of future strategies:
[17:02:52.116] 1. multicore:
[17:02:52.116]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.116]    - tweaked: FALSE
[17:02:52.116]    - call: plan(strategy)
[17:02:52.120] plan(): nbrOfWorkers() = 2
[17:02:52.120] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.121] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.121] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.123] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:52.123] Searching for globals ... DONE
[17:02:52.123] Resolving globals: TRUE
[17:02:52.123] Resolving any globals that are futures ...
[17:02:52.124] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:52.124] Resolving any globals that are futures ... DONE
[17:02:52.124] Resolving futures part of globals (recursively) ...
[17:02:52.124] resolve() on list ...
[17:02:52.124]  recursive: 99
[17:02:52.124]  length: 1
[17:02:52.124]  elements: ‘a’
[17:02:52.125]  length: 0 (resolved future 1)
[17:02:52.125] resolve() on list ... DONE
[17:02:52.125] - globals: [1] ‘a’
[17:02:52.125] Resolving futures part of globals (recursively) ... DONE
[17:02:52.125] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:52.125] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:02:52.125] - globals: [1] ‘a’
[17:02:52.126] 
[17:02:52.126] getGlobalsAndPackages() ... DONE
[17:02:52.126] run() for ‘Future’ ...
[17:02:52.126] - state: ‘created’
[17:02:52.126] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.130] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.130]   - Field: ‘label’
[17:02:52.130]   - Field: ‘local’
[17:02:52.130]   - Field: ‘owner’
[17:02:52.130]   - Field: ‘envir’
[17:02:52.130]   - Field: ‘workers’
[17:02:52.130]   - Field: ‘packages’
[17:02:52.131]   - Field: ‘gc’
[17:02:52.131]   - Field: ‘job’
[17:02:52.131]   - Field: ‘conditions’
[17:02:52.131]   - Field: ‘expr’
[17:02:52.131]   - Field: ‘uuid’
[17:02:52.131]   - Field: ‘seed’
[17:02:52.131]   - Field: ‘version’
[17:02:52.131]   - Field: ‘result’
[17:02:52.131]   - Field: ‘asynchronous’
[17:02:52.131]   - Field: ‘calls’
[17:02:52.132]   - Field: ‘globals’
[17:02:52.132]   - Field: ‘stdout’
[17:02:52.132]   - Field: ‘earlySignal’
[17:02:52.132]   - Field: ‘lazy’
[17:02:52.132]   - Field: ‘state’
[17:02:52.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.132] - Launch lazy future ...
[17:02:52.132] Packages needed by the future expression (n = 0): <none>
[17:02:52.132] Packages needed by future strategies (n = 0): <none>
[17:02:52.133] {
[17:02:52.133]     {
[17:02:52.133]         {
[17:02:52.133]             ...future.startTime <- base::Sys.time()
[17:02:52.133]             {
[17:02:52.133]                 {
[17:02:52.133]                   {
[17:02:52.133]                     {
[17:02:52.133]                       base::local({
[17:02:52.133]                         has_future <- base::requireNamespace("future", 
[17:02:52.133]                           quietly = TRUE)
[17:02:52.133]                         if (has_future) {
[17:02:52.133]                           ns <- base::getNamespace("future")
[17:02:52.133]                           version <- ns[[".package"]][["version"]]
[17:02:52.133]                           if (is.null(version)) 
[17:02:52.133]                             version <- utils::packageVersion("future")
[17:02:52.133]                         }
[17:02:52.133]                         else {
[17:02:52.133]                           version <- NULL
[17:02:52.133]                         }
[17:02:52.133]                         if (!has_future || version < "1.8.0") {
[17:02:52.133]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.133]                             "", base::R.version$version.string), 
[17:02:52.133]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.133]                               "release", "version")], collapse = " "), 
[17:02:52.133]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.133]                             info)
[17:02:52.133]                           info <- base::paste(info, collapse = "; ")
[17:02:52.133]                           if (!has_future) {
[17:02:52.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.133]                               info)
[17:02:52.133]                           }
[17:02:52.133]                           else {
[17:02:52.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.133]                               info, version)
[17:02:52.133]                           }
[17:02:52.133]                           base::stop(msg)
[17:02:52.133]                         }
[17:02:52.133]                       })
[17:02:52.133]                     }
[17:02:52.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.133]                     base::options(mc.cores = 1L)
[17:02:52.133]                   }
[17:02:52.133]                   ...future.strategy.old <- future::plan("list")
[17:02:52.133]                   options(future.plan = NULL)
[17:02:52.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.133]                 }
[17:02:52.133]                 ...future.workdir <- getwd()
[17:02:52.133]             }
[17:02:52.133]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.133]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.133]         }
[17:02:52.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.133]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.133]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.133]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.133]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.133]             base::names(...future.oldOptions))
[17:02:52.133]     }
[17:02:52.133]     if (FALSE) {
[17:02:52.133]     }
[17:02:52.133]     else {
[17:02:52.133]         if (TRUE) {
[17:02:52.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.133]                 open = "w")
[17:02:52.133]         }
[17:02:52.133]         else {
[17:02:52.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.133]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.133]         }
[17:02:52.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.133]             base::sink(type = "output", split = FALSE)
[17:02:52.133]             base::close(...future.stdout)
[17:02:52.133]         }, add = TRUE)
[17:02:52.133]     }
[17:02:52.133]     ...future.frame <- base::sys.nframe()
[17:02:52.133]     ...future.conditions <- base::list()
[17:02:52.133]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.133]     if (FALSE) {
[17:02:52.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.133]     }
[17:02:52.133]     ...future.result <- base::tryCatch({
[17:02:52.133]         base::withCallingHandlers({
[17:02:52.133]             ...future.value <- base::withVisible(base::local({
[17:02:52.133]                 withCallingHandlers({
[17:02:52.133]                   {
[17:02:52.133]                     b <- a
[17:02:52.133]                     a <- 2
[17:02:52.133]                     a * b
[17:02:52.133]                   }
[17:02:52.133]                 }, immediateCondition = function(cond) {
[17:02:52.133]                   save_rds <- function (object, pathname, ...) 
[17:02:52.133]                   {
[17:02:52.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.133]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.133]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.133]                         fi_tmp[["mtime"]])
[17:02:52.133]                     }
[17:02:52.133]                     tryCatch({
[17:02:52.133]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.133]                     }, error = function(ex) {
[17:02:52.133]                       msg <- conditionMessage(ex)
[17:02:52.133]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.133]                         fi_tmp[["mtime"]], msg)
[17:02:52.133]                       ex$message <- msg
[17:02:52.133]                       stop(ex)
[17:02:52.133]                     })
[17:02:52.133]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.133]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.133]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.133]                       fi <- file.info(pathname)
[17:02:52.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.133]                         fi[["size"]], fi[["mtime"]])
[17:02:52.133]                       stop(msg)
[17:02:52.133]                     }
[17:02:52.133]                     invisible(pathname)
[17:02:52.133]                   }
[17:02:52.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.133]                     rootPath = tempdir()) 
[17:02:52.133]                   {
[17:02:52.133]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.133]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.133]                       tmpdir = path, fileext = ".rds")
[17:02:52.133]                     save_rds(obj, file)
[17:02:52.133]                   }
[17:02:52.133]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.133]                   {
[17:02:52.133]                     inherits <- base::inherits
[17:02:52.133]                     invokeRestart <- base::invokeRestart
[17:02:52.133]                     is.null <- base::is.null
[17:02:52.133]                     muffled <- FALSE
[17:02:52.133]                     if (inherits(cond, "message")) {
[17:02:52.133]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.133]                       if (muffled) 
[17:02:52.133]                         invokeRestart("muffleMessage")
[17:02:52.133]                     }
[17:02:52.133]                     else if (inherits(cond, "warning")) {
[17:02:52.133]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.133]                       if (muffled) 
[17:02:52.133]                         invokeRestart("muffleWarning")
[17:02:52.133]                     }
[17:02:52.133]                     else if (inherits(cond, "condition")) {
[17:02:52.133]                       if (!is.null(pattern)) {
[17:02:52.133]                         computeRestarts <- base::computeRestarts
[17:02:52.133]                         grepl <- base::grepl
[17:02:52.133]                         restarts <- computeRestarts(cond)
[17:02:52.133]                         for (restart in restarts) {
[17:02:52.133]                           name <- restart$name
[17:02:52.133]                           if (is.null(name)) 
[17:02:52.133]                             next
[17:02:52.133]                           if (!grepl(pattern, name)) 
[17:02:52.133]                             next
[17:02:52.133]                           invokeRestart(restart)
[17:02:52.133]                           muffled <- TRUE
[17:02:52.133]                           break
[17:02:52.133]                         }
[17:02:52.133]                       }
[17:02:52.133]                     }
[17:02:52.133]                     invisible(muffled)
[17:02:52.133]                   }
[17:02:52.133]                   muffleCondition(cond)
[17:02:52.133]                 })
[17:02:52.133]             }))
[17:02:52.133]             future::FutureResult(value = ...future.value$value, 
[17:02:52.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.133]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.133]                     ...future.globalenv.names))
[17:02:52.133]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.133]         }, condition = base::local({
[17:02:52.133]             c <- base::c
[17:02:52.133]             inherits <- base::inherits
[17:02:52.133]             invokeRestart <- base::invokeRestart
[17:02:52.133]             length <- base::length
[17:02:52.133]             list <- base::list
[17:02:52.133]             seq.int <- base::seq.int
[17:02:52.133]             signalCondition <- base::signalCondition
[17:02:52.133]             sys.calls <- base::sys.calls
[17:02:52.133]             `[[` <- base::`[[`
[17:02:52.133]             `+` <- base::`+`
[17:02:52.133]             `<<-` <- base::`<<-`
[17:02:52.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.133]                   3L)]
[17:02:52.133]             }
[17:02:52.133]             function(cond) {
[17:02:52.133]                 is_error <- inherits(cond, "error")
[17:02:52.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.133]                   NULL)
[17:02:52.133]                 if (is_error) {
[17:02:52.133]                   sessionInformation <- function() {
[17:02:52.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.133]                       search = base::search(), system = base::Sys.info())
[17:02:52.133]                   }
[17:02:52.133]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.133]                     cond$call), session = sessionInformation(), 
[17:02:52.133]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.133]                   signalCondition(cond)
[17:02:52.133]                 }
[17:02:52.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.133]                 "immediateCondition"))) {
[17:02:52.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.133]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.133]                   if (TRUE && !signal) {
[17:02:52.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.133]                     {
[17:02:52.133]                       inherits <- base::inherits
[17:02:52.133]                       invokeRestart <- base::invokeRestart
[17:02:52.133]                       is.null <- base::is.null
[17:02:52.133]                       muffled <- FALSE
[17:02:52.133]                       if (inherits(cond, "message")) {
[17:02:52.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.133]                         if (muffled) 
[17:02:52.133]                           invokeRestart("muffleMessage")
[17:02:52.133]                       }
[17:02:52.133]                       else if (inherits(cond, "warning")) {
[17:02:52.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.133]                         if (muffled) 
[17:02:52.133]                           invokeRestart("muffleWarning")
[17:02:52.133]                       }
[17:02:52.133]                       else if (inherits(cond, "condition")) {
[17:02:52.133]                         if (!is.null(pattern)) {
[17:02:52.133]                           computeRestarts <- base::computeRestarts
[17:02:52.133]                           grepl <- base::grepl
[17:02:52.133]                           restarts <- computeRestarts(cond)
[17:02:52.133]                           for (restart in restarts) {
[17:02:52.133]                             name <- restart$name
[17:02:52.133]                             if (is.null(name)) 
[17:02:52.133]                               next
[17:02:52.133]                             if (!grepl(pattern, name)) 
[17:02:52.133]                               next
[17:02:52.133]                             invokeRestart(restart)
[17:02:52.133]                             muffled <- TRUE
[17:02:52.133]                             break
[17:02:52.133]                           }
[17:02:52.133]                         }
[17:02:52.133]                       }
[17:02:52.133]                       invisible(muffled)
[17:02:52.133]                     }
[17:02:52.133]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.133]                   }
[17:02:52.133]                 }
[17:02:52.133]                 else {
[17:02:52.133]                   if (TRUE) {
[17:02:52.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.133]                     {
[17:02:52.133]                       inherits <- base::inherits
[17:02:52.133]                       invokeRestart <- base::invokeRestart
[17:02:52.133]                       is.null <- base::is.null
[17:02:52.133]                       muffled <- FALSE
[17:02:52.133]                       if (inherits(cond, "message")) {
[17:02:52.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.133]                         if (muffled) 
[17:02:52.133]                           invokeRestart("muffleMessage")
[17:02:52.133]                       }
[17:02:52.133]                       else if (inherits(cond, "warning")) {
[17:02:52.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.133]                         if (muffled) 
[17:02:52.133]                           invokeRestart("muffleWarning")
[17:02:52.133]                       }
[17:02:52.133]                       else if (inherits(cond, "condition")) {
[17:02:52.133]                         if (!is.null(pattern)) {
[17:02:52.133]                           computeRestarts <- base::computeRestarts
[17:02:52.133]                           grepl <- base::grepl
[17:02:52.133]                           restarts <- computeRestarts(cond)
[17:02:52.133]                           for (restart in restarts) {
[17:02:52.133]                             name <- restart$name
[17:02:52.133]                             if (is.null(name)) 
[17:02:52.133]                               next
[17:02:52.133]                             if (!grepl(pattern, name)) 
[17:02:52.133]                               next
[17:02:52.133]                             invokeRestart(restart)
[17:02:52.133]                             muffled <- TRUE
[17:02:52.133]                             break
[17:02:52.133]                           }
[17:02:52.133]                         }
[17:02:52.133]                       }
[17:02:52.133]                       invisible(muffled)
[17:02:52.133]                     }
[17:02:52.133]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.133]                   }
[17:02:52.133]                 }
[17:02:52.133]             }
[17:02:52.133]         }))
[17:02:52.133]     }, error = function(ex) {
[17:02:52.133]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.133]                 ...future.rng), started = ...future.startTime, 
[17:02:52.133]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.133]             version = "1.8"), class = "FutureResult")
[17:02:52.133]     }, finally = {
[17:02:52.133]         if (!identical(...future.workdir, getwd())) 
[17:02:52.133]             setwd(...future.workdir)
[17:02:52.133]         {
[17:02:52.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.133]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.133]             }
[17:02:52.133]             base::options(...future.oldOptions)
[17:02:52.133]             if (.Platform$OS.type == "windows") {
[17:02:52.133]                 old_names <- names(...future.oldEnvVars)
[17:02:52.133]                 envs <- base::Sys.getenv()
[17:02:52.133]                 names <- names(envs)
[17:02:52.133]                 common <- intersect(names, old_names)
[17:02:52.133]                 added <- setdiff(names, old_names)
[17:02:52.133]                 removed <- setdiff(old_names, names)
[17:02:52.133]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.133]                   envs[common]]
[17:02:52.133]                 NAMES <- toupper(changed)
[17:02:52.133]                 args <- list()
[17:02:52.133]                 for (kk in seq_along(NAMES)) {
[17:02:52.133]                   name <- changed[[kk]]
[17:02:52.133]                   NAME <- NAMES[[kk]]
[17:02:52.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.133]                     next
[17:02:52.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.133]                 }
[17:02:52.133]                 NAMES <- toupper(added)
[17:02:52.133]                 for (kk in seq_along(NAMES)) {
[17:02:52.133]                   name <- added[[kk]]
[17:02:52.133]                   NAME <- NAMES[[kk]]
[17:02:52.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.133]                     next
[17:02:52.133]                   args[[name]] <- ""
[17:02:52.133]                 }
[17:02:52.133]                 NAMES <- toupper(removed)
[17:02:52.133]                 for (kk in seq_along(NAMES)) {
[17:02:52.133]                   name <- removed[[kk]]
[17:02:52.133]                   NAME <- NAMES[[kk]]
[17:02:52.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.133]                     next
[17:02:52.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.133]                 }
[17:02:52.133]                 if (length(args) > 0) 
[17:02:52.133]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.133]             }
[17:02:52.133]             else {
[17:02:52.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.133]             }
[17:02:52.133]             {
[17:02:52.133]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.133]                   0L) {
[17:02:52.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.133]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.133]                   base::options(opts)
[17:02:52.133]                 }
[17:02:52.133]                 {
[17:02:52.133]                   {
[17:02:52.133]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.133]                     NULL
[17:02:52.133]                   }
[17:02:52.133]                   options(future.plan = NULL)
[17:02:52.133]                   if (is.na(NA_character_)) 
[17:02:52.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.133]                     .init = FALSE)
[17:02:52.133]                 }
[17:02:52.133]             }
[17:02:52.133]         }
[17:02:52.133]     })
[17:02:52.133]     if (TRUE) {
[17:02:52.133]         base::sink(type = "output", split = FALSE)
[17:02:52.133]         if (TRUE) {
[17:02:52.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.133]         }
[17:02:52.133]         else {
[17:02:52.133]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.133]         }
[17:02:52.133]         base::close(...future.stdout)
[17:02:52.133]         ...future.stdout <- NULL
[17:02:52.133]     }
[17:02:52.133]     ...future.result$conditions <- ...future.conditions
[17:02:52.133]     ...future.result$finished <- base::Sys.time()
[17:02:52.133]     ...future.result
[17:02:52.133] }
[17:02:52.135] assign_globals() ...
[17:02:52.135] List of 1
[17:02:52.135]  $ a: num 3
[17:02:52.135]  - attr(*, "where")=List of 1
[17:02:52.135]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.135]  - attr(*, "resolved")= logi TRUE
[17:02:52.135]  - attr(*, "total_size")= num 56
[17:02:52.135]  - attr(*, "already-done")= logi TRUE
[17:02:52.140] - copied ‘a’ to environment
[17:02:52.140] assign_globals() ... done
[17:02:52.140] requestCore(): workers = 2
[17:02:52.143] MulticoreFuture started
[17:02:52.143] - Launch lazy future ... done
[17:02:52.144] run() for ‘MulticoreFuture’ ... done
[17:02:52.144] plan(): Setting new future strategy stack:
[17:02:52.144] result() for MulticoreFuture ...
[17:02:52.144] List of future strategies:
[17:02:52.144] 1. sequential:
[17:02:52.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.144]    - tweaked: FALSE
[17:02:52.144]    - call: NULL
[17:02:52.146] plan(): nbrOfWorkers() = 1
[17:02:52.148] plan(): Setting new future strategy stack:
[17:02:52.148] List of future strategies:
[17:02:52.148] 1. multicore:
[17:02:52.148]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.148]    - tweaked: FALSE
[17:02:52.148]    - call: plan(strategy)
[17:02:52.154] plan(): nbrOfWorkers() = 2
[17:02:52.155] result() for MulticoreFuture ...
[17:02:52.155] result() for MulticoreFuture ... done
[17:02:52.155] result() for MulticoreFuture ... done
[17:02:52.155] result() for MulticoreFuture ...
[17:02:52.156] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.156] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.157] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.159] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:52.159] Searching for globals ... DONE
[17:02:52.160] Resolving globals: TRUE
[17:02:52.160] Resolving any globals that are futures ...
[17:02:52.160] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:52.160] Resolving any globals that are futures ... DONE
[17:02:52.160] Resolving futures part of globals (recursively) ...
[17:02:52.161] resolve() on list ...
[17:02:52.161]  recursive: 99
[17:02:52.161]  length: 1
[17:02:52.161]  elements: ‘a’
[17:02:52.161]  length: 0 (resolved future 1)
[17:02:52.161] resolve() on list ... DONE
[17:02:52.162] - globals: [1] ‘a’
[17:02:52.162] Resolving futures part of globals (recursively) ... DONE
[17:02:52.162] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:52.162] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:02:52.162] - globals: [1] ‘a’
[17:02:52.163] 
[17:02:52.163] getGlobalsAndPackages() ... DONE
[17:02:52.163] run() for ‘Future’ ...
[17:02:52.163] - state: ‘created’
[17:02:52.163] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.167] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.168]   - Field: ‘label’
[17:02:52.168]   - Field: ‘local’
[17:02:52.168]   - Field: ‘owner’
[17:02:52.168]   - Field: ‘envir’
[17:02:52.168]   - Field: ‘workers’
[17:02:52.168]   - Field: ‘packages’
[17:02:52.168]   - Field: ‘gc’
[17:02:52.169]   - Field: ‘job’
[17:02:52.169]   - Field: ‘conditions’
[17:02:52.169]   - Field: ‘expr’
[17:02:52.169]   - Field: ‘uuid’
[17:02:52.169]   - Field: ‘seed’
[17:02:52.169]   - Field: ‘version’
[17:02:52.169]   - Field: ‘result’
[17:02:52.169]   - Field: ‘asynchronous’
[17:02:52.169]   - Field: ‘calls’
[17:02:52.170]   - Field: ‘globals’
[17:02:52.170]   - Field: ‘stdout’
[17:02:52.170]   - Field: ‘earlySignal’
[17:02:52.170]   - Field: ‘lazy’
[17:02:52.170]   - Field: ‘state’
[17:02:52.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.170] - Launch lazy future ...
[17:02:52.171] Packages needed by the future expression (n = 0): <none>
[17:02:52.171] Packages needed by future strategies (n = 0): <none>
[17:02:52.171] {
[17:02:52.171]     {
[17:02:52.171]         {
[17:02:52.171]             ...future.startTime <- base::Sys.time()
[17:02:52.171]             {
[17:02:52.171]                 {
[17:02:52.171]                   {
[17:02:52.171]                     {
[17:02:52.171]                       base::local({
[17:02:52.171]                         has_future <- base::requireNamespace("future", 
[17:02:52.171]                           quietly = TRUE)
[17:02:52.171]                         if (has_future) {
[17:02:52.171]                           ns <- base::getNamespace("future")
[17:02:52.171]                           version <- ns[[".package"]][["version"]]
[17:02:52.171]                           if (is.null(version)) 
[17:02:52.171]                             version <- utils::packageVersion("future")
[17:02:52.171]                         }
[17:02:52.171]                         else {
[17:02:52.171]                           version <- NULL
[17:02:52.171]                         }
[17:02:52.171]                         if (!has_future || version < "1.8.0") {
[17:02:52.171]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.171]                             "", base::R.version$version.string), 
[17:02:52.171]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.171]                               "release", "version")], collapse = " "), 
[17:02:52.171]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.171]                             info)
[17:02:52.171]                           info <- base::paste(info, collapse = "; ")
[17:02:52.171]                           if (!has_future) {
[17:02:52.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.171]                               info)
[17:02:52.171]                           }
[17:02:52.171]                           else {
[17:02:52.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.171]                               info, version)
[17:02:52.171]                           }
[17:02:52.171]                           base::stop(msg)
[17:02:52.171]                         }
[17:02:52.171]                       })
[17:02:52.171]                     }
[17:02:52.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.171]                     base::options(mc.cores = 1L)
[17:02:52.171]                   }
[17:02:52.171]                   ...future.strategy.old <- future::plan("list")
[17:02:52.171]                   options(future.plan = NULL)
[17:02:52.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.171]                 }
[17:02:52.171]                 ...future.workdir <- getwd()
[17:02:52.171]             }
[17:02:52.171]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.171]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.171]         }
[17:02:52.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.171]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.171]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.171]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.171]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.171]             base::names(...future.oldOptions))
[17:02:52.171]     }
[17:02:52.171]     if (FALSE) {
[17:02:52.171]     }
[17:02:52.171]     else {
[17:02:52.171]         if (TRUE) {
[17:02:52.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.171]                 open = "w")
[17:02:52.171]         }
[17:02:52.171]         else {
[17:02:52.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.171]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.171]         }
[17:02:52.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.171]             base::sink(type = "output", split = FALSE)
[17:02:52.171]             base::close(...future.stdout)
[17:02:52.171]         }, add = TRUE)
[17:02:52.171]     }
[17:02:52.171]     ...future.frame <- base::sys.nframe()
[17:02:52.171]     ...future.conditions <- base::list()
[17:02:52.171]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.171]     if (FALSE) {
[17:02:52.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.171]     }
[17:02:52.171]     ...future.result <- base::tryCatch({
[17:02:52.171]         base::withCallingHandlers({
[17:02:52.171]             ...future.value <- base::withVisible(base::local({
[17:02:52.171]                 withCallingHandlers({
[17:02:52.171]                   {
[17:02:52.171]                     b <- a
[17:02:52.171]                     a <- 2
[17:02:52.171]                     a * b
[17:02:52.171]                   }
[17:02:52.171]                 }, immediateCondition = function(cond) {
[17:02:52.171]                   save_rds <- function (object, pathname, ...) 
[17:02:52.171]                   {
[17:02:52.171]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.171]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.171]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.171]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.171]                         fi_tmp[["mtime"]])
[17:02:52.171]                     }
[17:02:52.171]                     tryCatch({
[17:02:52.171]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.171]                     }, error = function(ex) {
[17:02:52.171]                       msg <- conditionMessage(ex)
[17:02:52.171]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.171]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.171]                         fi_tmp[["mtime"]], msg)
[17:02:52.171]                       ex$message <- msg
[17:02:52.171]                       stop(ex)
[17:02:52.171]                     })
[17:02:52.171]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.171]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.171]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.171]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.171]                       fi <- file.info(pathname)
[17:02:52.171]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.171]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.171]                         fi[["size"]], fi[["mtime"]])
[17:02:52.171]                       stop(msg)
[17:02:52.171]                     }
[17:02:52.171]                     invisible(pathname)
[17:02:52.171]                   }
[17:02:52.171]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.171]                     rootPath = tempdir()) 
[17:02:52.171]                   {
[17:02:52.171]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.171]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.171]                       tmpdir = path, fileext = ".rds")
[17:02:52.171]                     save_rds(obj, file)
[17:02:52.171]                   }
[17:02:52.171]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.171]                   {
[17:02:52.171]                     inherits <- base::inherits
[17:02:52.171]                     invokeRestart <- base::invokeRestart
[17:02:52.171]                     is.null <- base::is.null
[17:02:52.171]                     muffled <- FALSE
[17:02:52.171]                     if (inherits(cond, "message")) {
[17:02:52.171]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.171]                       if (muffled) 
[17:02:52.171]                         invokeRestart("muffleMessage")
[17:02:52.171]                     }
[17:02:52.171]                     else if (inherits(cond, "warning")) {
[17:02:52.171]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.171]                       if (muffled) 
[17:02:52.171]                         invokeRestart("muffleWarning")
[17:02:52.171]                     }
[17:02:52.171]                     else if (inherits(cond, "condition")) {
[17:02:52.171]                       if (!is.null(pattern)) {
[17:02:52.171]                         computeRestarts <- base::computeRestarts
[17:02:52.171]                         grepl <- base::grepl
[17:02:52.171]                         restarts <- computeRestarts(cond)
[17:02:52.171]                         for (restart in restarts) {
[17:02:52.171]                           name <- restart$name
[17:02:52.171]                           if (is.null(name)) 
[17:02:52.171]                             next
[17:02:52.171]                           if (!grepl(pattern, name)) 
[17:02:52.171]                             next
[17:02:52.171]                           invokeRestart(restart)
[17:02:52.171]                           muffled <- TRUE
[17:02:52.171]                           break
[17:02:52.171]                         }
[17:02:52.171]                       }
[17:02:52.171]                     }
[17:02:52.171]                     invisible(muffled)
[17:02:52.171]                   }
[17:02:52.171]                   muffleCondition(cond)
[17:02:52.171]                 })
[17:02:52.171]             }))
[17:02:52.171]             future::FutureResult(value = ...future.value$value, 
[17:02:52.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.171]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.171]                     ...future.globalenv.names))
[17:02:52.171]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.171]         }, condition = base::local({
[17:02:52.171]             c <- base::c
[17:02:52.171]             inherits <- base::inherits
[17:02:52.171]             invokeRestart <- base::invokeRestart
[17:02:52.171]             length <- base::length
[17:02:52.171]             list <- base::list
[17:02:52.171]             seq.int <- base::seq.int
[17:02:52.171]             signalCondition <- base::signalCondition
[17:02:52.171]             sys.calls <- base::sys.calls
[17:02:52.171]             `[[` <- base::`[[`
[17:02:52.171]             `+` <- base::`+`
[17:02:52.171]             `<<-` <- base::`<<-`
[17:02:52.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.171]                   3L)]
[17:02:52.171]             }
[17:02:52.171]             function(cond) {
[17:02:52.171]                 is_error <- inherits(cond, "error")
[17:02:52.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.171]                   NULL)
[17:02:52.171]                 if (is_error) {
[17:02:52.171]                   sessionInformation <- function() {
[17:02:52.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.171]                       search = base::search(), system = base::Sys.info())
[17:02:52.171]                   }
[17:02:52.171]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.171]                     cond$call), session = sessionInformation(), 
[17:02:52.171]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.171]                   signalCondition(cond)
[17:02:52.171]                 }
[17:02:52.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.171]                 "immediateCondition"))) {
[17:02:52.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.171]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.171]                   if (TRUE && !signal) {
[17:02:52.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.171]                     {
[17:02:52.171]                       inherits <- base::inherits
[17:02:52.171]                       invokeRestart <- base::invokeRestart
[17:02:52.171]                       is.null <- base::is.null
[17:02:52.171]                       muffled <- FALSE
[17:02:52.171]                       if (inherits(cond, "message")) {
[17:02:52.171]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.171]                         if (muffled) 
[17:02:52.171]                           invokeRestart("muffleMessage")
[17:02:52.171]                       }
[17:02:52.171]                       else if (inherits(cond, "warning")) {
[17:02:52.171]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.171]                         if (muffled) 
[17:02:52.171]                           invokeRestart("muffleWarning")
[17:02:52.171]                       }
[17:02:52.171]                       else if (inherits(cond, "condition")) {
[17:02:52.171]                         if (!is.null(pattern)) {
[17:02:52.171]                           computeRestarts <- base::computeRestarts
[17:02:52.171]                           grepl <- base::grepl
[17:02:52.171]                           restarts <- computeRestarts(cond)
[17:02:52.171]                           for (restart in restarts) {
[17:02:52.171]                             name <- restart$name
[17:02:52.171]                             if (is.null(name)) 
[17:02:52.171]                               next
[17:02:52.171]                             if (!grepl(pattern, name)) 
[17:02:52.171]                               next
[17:02:52.171]                             invokeRestart(restart)
[17:02:52.171]                             muffled <- TRUE
[17:02:52.171]                             break
[17:02:52.171]                           }
[17:02:52.171]                         }
[17:02:52.171]                       }
[17:02:52.171]                       invisible(muffled)
[17:02:52.171]                     }
[17:02:52.171]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.171]                   }
[17:02:52.171]                 }
[17:02:52.171]                 else {
[17:02:52.171]                   if (TRUE) {
[17:02:52.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.171]                     {
[17:02:52.171]                       inherits <- base::inherits
[17:02:52.171]                       invokeRestart <- base::invokeRestart
[17:02:52.171]                       is.null <- base::is.null
[17:02:52.171]                       muffled <- FALSE
[17:02:52.171]                       if (inherits(cond, "message")) {
[17:02:52.171]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.171]                         if (muffled) 
[17:02:52.171]                           invokeRestart("muffleMessage")
[17:02:52.171]                       }
[17:02:52.171]                       else if (inherits(cond, "warning")) {
[17:02:52.171]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.171]                         if (muffled) 
[17:02:52.171]                           invokeRestart("muffleWarning")
[17:02:52.171]                       }
[17:02:52.171]                       else if (inherits(cond, "condition")) {
[17:02:52.171]                         if (!is.null(pattern)) {
[17:02:52.171]                           computeRestarts <- base::computeRestarts
[17:02:52.171]                           grepl <- base::grepl
[17:02:52.171]                           restarts <- computeRestarts(cond)
[17:02:52.171]                           for (restart in restarts) {
[17:02:52.171]                             name <- restart$name
[17:02:52.171]                             if (is.null(name)) 
[17:02:52.171]                               next
[17:02:52.171]                             if (!grepl(pattern, name)) 
[17:02:52.171]                               next
[17:02:52.171]                             invokeRestart(restart)
[17:02:52.171]                             muffled <- TRUE
[17:02:52.171]                             break
[17:02:52.171]                           }
[17:02:52.171]                         }
[17:02:52.171]                       }
[17:02:52.171]                       invisible(muffled)
[17:02:52.171]                     }
[17:02:52.171]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.171]                   }
[17:02:52.171]                 }
[17:02:52.171]             }
[17:02:52.171]         }))
[17:02:52.171]     }, error = function(ex) {
[17:02:52.171]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.171]                 ...future.rng), started = ...future.startTime, 
[17:02:52.171]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.171]             version = "1.8"), class = "FutureResult")
[17:02:52.171]     }, finally = {
[17:02:52.171]         if (!identical(...future.workdir, getwd())) 
[17:02:52.171]             setwd(...future.workdir)
[17:02:52.171]         {
[17:02:52.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.171]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.171]             }
[17:02:52.171]             base::options(...future.oldOptions)
[17:02:52.171]             if (.Platform$OS.type == "windows") {
[17:02:52.171]                 old_names <- names(...future.oldEnvVars)
[17:02:52.171]                 envs <- base::Sys.getenv()
[17:02:52.171]                 names <- names(envs)
[17:02:52.171]                 common <- intersect(names, old_names)
[17:02:52.171]                 added <- setdiff(names, old_names)
[17:02:52.171]                 removed <- setdiff(old_names, names)
[17:02:52.171]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.171]                   envs[common]]
[17:02:52.171]                 NAMES <- toupper(changed)
[17:02:52.171]                 args <- list()
[17:02:52.171]                 for (kk in seq_along(NAMES)) {
[17:02:52.171]                   name <- changed[[kk]]
[17:02:52.171]                   NAME <- NAMES[[kk]]
[17:02:52.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.171]                     next
[17:02:52.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.171]                 }
[17:02:52.171]                 NAMES <- toupper(added)
[17:02:52.171]                 for (kk in seq_along(NAMES)) {
[17:02:52.171]                   name <- added[[kk]]
[17:02:52.171]                   NAME <- NAMES[[kk]]
[17:02:52.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.171]                     next
[17:02:52.171]                   args[[name]] <- ""
[17:02:52.171]                 }
[17:02:52.171]                 NAMES <- toupper(removed)
[17:02:52.171]                 for (kk in seq_along(NAMES)) {
[17:02:52.171]                   name <- removed[[kk]]
[17:02:52.171]                   NAME <- NAMES[[kk]]
[17:02:52.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.171]                     next
[17:02:52.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.171]                 }
[17:02:52.171]                 if (length(args) > 0) 
[17:02:52.171]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.171]             }
[17:02:52.171]             else {
[17:02:52.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.171]             }
[17:02:52.171]             {
[17:02:52.171]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.171]                   0L) {
[17:02:52.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.171]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.171]                   base::options(opts)
[17:02:52.171]                 }
[17:02:52.171]                 {
[17:02:52.171]                   {
[17:02:52.171]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.171]                     NULL
[17:02:52.171]                   }
[17:02:52.171]                   options(future.plan = NULL)
[17:02:52.171]                   if (is.na(NA_character_)) 
[17:02:52.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.171]                     .init = FALSE)
[17:02:52.171]                 }
[17:02:52.171]             }
[17:02:52.171]         }
[17:02:52.171]     })
[17:02:52.171]     if (TRUE) {
[17:02:52.171]         base::sink(type = "output", split = FALSE)
[17:02:52.171]         if (TRUE) {
[17:02:52.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.171]         }
[17:02:52.171]         else {
[17:02:52.171]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.171]         }
[17:02:52.171]         base::close(...future.stdout)
[17:02:52.171]         ...future.stdout <- NULL
[17:02:52.171]     }
[17:02:52.171]     ...future.result$conditions <- ...future.conditions
[17:02:52.171]     ...future.result$finished <- base::Sys.time()
[17:02:52.171]     ...future.result
[17:02:52.171] }
[17:02:52.174] assign_globals() ...
[17:02:52.174] List of 1
[17:02:52.174]  $ a: num 3
[17:02:52.174]  - attr(*, "where")=List of 1
[17:02:52.174]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.174]  - attr(*, "resolved")= logi TRUE
[17:02:52.174]  - attr(*, "total_size")= num 56
[17:02:52.174]  - attr(*, "already-done")= logi TRUE
[17:02:52.177] - copied ‘a’ to environment
[17:02:52.177] assign_globals() ... done
[17:02:52.177] requestCore(): workers = 2
[17:02:52.179] MulticoreFuture started
[17:02:52.180] - Launch lazy future ... done
[17:02:52.180] run() for ‘MulticoreFuture’ ... done
[17:02:52.180] result() for MulticoreFuture ...
[17:02:52.180] plan(): Setting new future strategy stack:
[17:02:52.181] List of future strategies:
[17:02:52.181] 1. sequential:
[17:02:52.181]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.181]    - tweaked: FALSE
[17:02:52.181]    - call: NULL
[17:02:52.182] plan(): nbrOfWorkers() = 1
[17:02:52.189] plan(): Setting new future strategy stack:
[17:02:52.189] List of future strategies:
[17:02:52.189] 1. multicore:
[17:02:52.189]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.189]    - tweaked: FALSE
[17:02:52.189]    - call: plan(strategy)
[17:02:52.196] plan(): nbrOfWorkers() = 2
[17:02:52.197] result() for MulticoreFuture ...
[17:02:52.198] result() for MulticoreFuture ... done
[17:02:52.198] result() for MulticoreFuture ... done
[17:02:52.200] result() for MulticoreFuture ...
[17:02:52.201] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.202] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.202] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.206] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.206] Searching for globals ... DONE
[17:02:52.206] Resolving globals: TRUE
[17:02:52.206] Resolving any globals that are futures ...
[17:02:52.206] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.207] Resolving any globals that are futures ... DONE
[17:02:52.207] Resolving futures part of globals (recursively) ...
[17:02:52.207] resolve() on list ...
[17:02:52.207]  recursive: 99
[17:02:52.208]  length: 2
[17:02:52.208]  elements: ‘a’, ‘ii’
[17:02:52.208]  length: 1 (resolved future 1)
[17:02:52.208]  length: 0 (resolved future 2)
[17:02:52.208] resolve() on list ... DONE
[17:02:52.208] - globals: [2] ‘a’, ‘ii’
[17:02:52.208] Resolving futures part of globals (recursively) ... DONE
[17:02:52.209] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:52.209] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:52.209] - globals: [2] ‘a’, ‘ii’
[17:02:52.209] 
[17:02:52.209] getGlobalsAndPackages() ... DONE
[17:02:52.210] run() for ‘Future’ ...
[17:02:52.210] - state: ‘created’
[17:02:52.210] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.214] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.215]   - Field: ‘label’
[17:02:52.215]   - Field: ‘local’
[17:02:52.215]   - Field: ‘owner’
[17:02:52.215]   - Field: ‘envir’
[17:02:52.215]   - Field: ‘workers’
[17:02:52.215]   - Field: ‘packages’
[17:02:52.216]   - Field: ‘gc’
[17:02:52.216]   - Field: ‘job’
[17:02:52.216]   - Field: ‘conditions’
[17:02:52.216]   - Field: ‘expr’
[17:02:52.216]   - Field: ‘uuid’
[17:02:52.216]   - Field: ‘seed’
[17:02:52.216]   - Field: ‘version’
[17:02:52.216]   - Field: ‘result’
[17:02:52.216]   - Field: ‘asynchronous’
[17:02:52.217]   - Field: ‘calls’
[17:02:52.217]   - Field: ‘globals’
[17:02:52.217]   - Field: ‘stdout’
[17:02:52.217]   - Field: ‘earlySignal’
[17:02:52.217]   - Field: ‘lazy’
[17:02:52.217]   - Field: ‘state’
[17:02:52.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.217] - Launch lazy future ...
[17:02:52.218] Packages needed by the future expression (n = 0): <none>
[17:02:52.218] Packages needed by future strategies (n = 0): <none>
[17:02:52.218] {
[17:02:52.218]     {
[17:02:52.218]         {
[17:02:52.218]             ...future.startTime <- base::Sys.time()
[17:02:52.218]             {
[17:02:52.218]                 {
[17:02:52.218]                   {
[17:02:52.218]                     {
[17:02:52.218]                       base::local({
[17:02:52.218]                         has_future <- base::requireNamespace("future", 
[17:02:52.218]                           quietly = TRUE)
[17:02:52.218]                         if (has_future) {
[17:02:52.218]                           ns <- base::getNamespace("future")
[17:02:52.218]                           version <- ns[[".package"]][["version"]]
[17:02:52.218]                           if (is.null(version)) 
[17:02:52.218]                             version <- utils::packageVersion("future")
[17:02:52.218]                         }
[17:02:52.218]                         else {
[17:02:52.218]                           version <- NULL
[17:02:52.218]                         }
[17:02:52.218]                         if (!has_future || version < "1.8.0") {
[17:02:52.218]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.218]                             "", base::R.version$version.string), 
[17:02:52.218]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.218]                               "release", "version")], collapse = " "), 
[17:02:52.218]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.218]                             info)
[17:02:52.218]                           info <- base::paste(info, collapse = "; ")
[17:02:52.218]                           if (!has_future) {
[17:02:52.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.218]                               info)
[17:02:52.218]                           }
[17:02:52.218]                           else {
[17:02:52.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.218]                               info, version)
[17:02:52.218]                           }
[17:02:52.218]                           base::stop(msg)
[17:02:52.218]                         }
[17:02:52.218]                       })
[17:02:52.218]                     }
[17:02:52.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.218]                     base::options(mc.cores = 1L)
[17:02:52.218]                   }
[17:02:52.218]                   ...future.strategy.old <- future::plan("list")
[17:02:52.218]                   options(future.plan = NULL)
[17:02:52.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.218]                 }
[17:02:52.218]                 ...future.workdir <- getwd()
[17:02:52.218]             }
[17:02:52.218]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.218]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.218]         }
[17:02:52.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.218]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.218]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.218]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.218]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.218]             base::names(...future.oldOptions))
[17:02:52.218]     }
[17:02:52.218]     if (FALSE) {
[17:02:52.218]     }
[17:02:52.218]     else {
[17:02:52.218]         if (TRUE) {
[17:02:52.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.218]                 open = "w")
[17:02:52.218]         }
[17:02:52.218]         else {
[17:02:52.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.218]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.218]         }
[17:02:52.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.218]             base::sink(type = "output", split = FALSE)
[17:02:52.218]             base::close(...future.stdout)
[17:02:52.218]         }, add = TRUE)
[17:02:52.218]     }
[17:02:52.218]     ...future.frame <- base::sys.nframe()
[17:02:52.218]     ...future.conditions <- base::list()
[17:02:52.218]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.218]     if (FALSE) {
[17:02:52.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.218]     }
[17:02:52.218]     ...future.result <- base::tryCatch({
[17:02:52.218]         base::withCallingHandlers({
[17:02:52.218]             ...future.value <- base::withVisible(base::local({
[17:02:52.218]                 withCallingHandlers({
[17:02:52.218]                   {
[17:02:52.218]                     b <- a * ii
[17:02:52.218]                     a <- 0
[17:02:52.218]                     b
[17:02:52.218]                   }
[17:02:52.218]                 }, immediateCondition = function(cond) {
[17:02:52.218]                   save_rds <- function (object, pathname, ...) 
[17:02:52.218]                   {
[17:02:52.218]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.218]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.218]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.218]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.218]                         fi_tmp[["mtime"]])
[17:02:52.218]                     }
[17:02:52.218]                     tryCatch({
[17:02:52.218]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.218]                     }, error = function(ex) {
[17:02:52.218]                       msg <- conditionMessage(ex)
[17:02:52.218]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.218]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.218]                         fi_tmp[["mtime"]], msg)
[17:02:52.218]                       ex$message <- msg
[17:02:52.218]                       stop(ex)
[17:02:52.218]                     })
[17:02:52.218]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.218]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.218]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.218]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.218]                       fi <- file.info(pathname)
[17:02:52.218]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.218]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.218]                         fi[["size"]], fi[["mtime"]])
[17:02:52.218]                       stop(msg)
[17:02:52.218]                     }
[17:02:52.218]                     invisible(pathname)
[17:02:52.218]                   }
[17:02:52.218]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.218]                     rootPath = tempdir()) 
[17:02:52.218]                   {
[17:02:52.218]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.218]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.218]                       tmpdir = path, fileext = ".rds")
[17:02:52.218]                     save_rds(obj, file)
[17:02:52.218]                   }
[17:02:52.218]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.218]                   {
[17:02:52.218]                     inherits <- base::inherits
[17:02:52.218]                     invokeRestart <- base::invokeRestart
[17:02:52.218]                     is.null <- base::is.null
[17:02:52.218]                     muffled <- FALSE
[17:02:52.218]                     if (inherits(cond, "message")) {
[17:02:52.218]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.218]                       if (muffled) 
[17:02:52.218]                         invokeRestart("muffleMessage")
[17:02:52.218]                     }
[17:02:52.218]                     else if (inherits(cond, "warning")) {
[17:02:52.218]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.218]                       if (muffled) 
[17:02:52.218]                         invokeRestart("muffleWarning")
[17:02:52.218]                     }
[17:02:52.218]                     else if (inherits(cond, "condition")) {
[17:02:52.218]                       if (!is.null(pattern)) {
[17:02:52.218]                         computeRestarts <- base::computeRestarts
[17:02:52.218]                         grepl <- base::grepl
[17:02:52.218]                         restarts <- computeRestarts(cond)
[17:02:52.218]                         for (restart in restarts) {
[17:02:52.218]                           name <- restart$name
[17:02:52.218]                           if (is.null(name)) 
[17:02:52.218]                             next
[17:02:52.218]                           if (!grepl(pattern, name)) 
[17:02:52.218]                             next
[17:02:52.218]                           invokeRestart(restart)
[17:02:52.218]                           muffled <- TRUE
[17:02:52.218]                           break
[17:02:52.218]                         }
[17:02:52.218]                       }
[17:02:52.218]                     }
[17:02:52.218]                     invisible(muffled)
[17:02:52.218]                   }
[17:02:52.218]                   muffleCondition(cond)
[17:02:52.218]                 })
[17:02:52.218]             }))
[17:02:52.218]             future::FutureResult(value = ...future.value$value, 
[17:02:52.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.218]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.218]                     ...future.globalenv.names))
[17:02:52.218]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.218]         }, condition = base::local({
[17:02:52.218]             c <- base::c
[17:02:52.218]             inherits <- base::inherits
[17:02:52.218]             invokeRestart <- base::invokeRestart
[17:02:52.218]             length <- base::length
[17:02:52.218]             list <- base::list
[17:02:52.218]             seq.int <- base::seq.int
[17:02:52.218]             signalCondition <- base::signalCondition
[17:02:52.218]             sys.calls <- base::sys.calls
[17:02:52.218]             `[[` <- base::`[[`
[17:02:52.218]             `+` <- base::`+`
[17:02:52.218]             `<<-` <- base::`<<-`
[17:02:52.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.218]                   3L)]
[17:02:52.218]             }
[17:02:52.218]             function(cond) {
[17:02:52.218]                 is_error <- inherits(cond, "error")
[17:02:52.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.218]                   NULL)
[17:02:52.218]                 if (is_error) {
[17:02:52.218]                   sessionInformation <- function() {
[17:02:52.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.218]                       search = base::search(), system = base::Sys.info())
[17:02:52.218]                   }
[17:02:52.218]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.218]                     cond$call), session = sessionInformation(), 
[17:02:52.218]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.218]                   signalCondition(cond)
[17:02:52.218]                 }
[17:02:52.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.218]                 "immediateCondition"))) {
[17:02:52.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.218]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.218]                   if (TRUE && !signal) {
[17:02:52.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.218]                     {
[17:02:52.218]                       inherits <- base::inherits
[17:02:52.218]                       invokeRestart <- base::invokeRestart
[17:02:52.218]                       is.null <- base::is.null
[17:02:52.218]                       muffled <- FALSE
[17:02:52.218]                       if (inherits(cond, "message")) {
[17:02:52.218]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.218]                         if (muffled) 
[17:02:52.218]                           invokeRestart("muffleMessage")
[17:02:52.218]                       }
[17:02:52.218]                       else if (inherits(cond, "warning")) {
[17:02:52.218]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.218]                         if (muffled) 
[17:02:52.218]                           invokeRestart("muffleWarning")
[17:02:52.218]                       }
[17:02:52.218]                       else if (inherits(cond, "condition")) {
[17:02:52.218]                         if (!is.null(pattern)) {
[17:02:52.218]                           computeRestarts <- base::computeRestarts
[17:02:52.218]                           grepl <- base::grepl
[17:02:52.218]                           restarts <- computeRestarts(cond)
[17:02:52.218]                           for (restart in restarts) {
[17:02:52.218]                             name <- restart$name
[17:02:52.218]                             if (is.null(name)) 
[17:02:52.218]                               next
[17:02:52.218]                             if (!grepl(pattern, name)) 
[17:02:52.218]                               next
[17:02:52.218]                             invokeRestart(restart)
[17:02:52.218]                             muffled <- TRUE
[17:02:52.218]                             break
[17:02:52.218]                           }
[17:02:52.218]                         }
[17:02:52.218]                       }
[17:02:52.218]                       invisible(muffled)
[17:02:52.218]                     }
[17:02:52.218]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.218]                   }
[17:02:52.218]                 }
[17:02:52.218]                 else {
[17:02:52.218]                   if (TRUE) {
[17:02:52.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.218]                     {
[17:02:52.218]                       inherits <- base::inherits
[17:02:52.218]                       invokeRestart <- base::invokeRestart
[17:02:52.218]                       is.null <- base::is.null
[17:02:52.218]                       muffled <- FALSE
[17:02:52.218]                       if (inherits(cond, "message")) {
[17:02:52.218]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.218]                         if (muffled) 
[17:02:52.218]                           invokeRestart("muffleMessage")
[17:02:52.218]                       }
[17:02:52.218]                       else if (inherits(cond, "warning")) {
[17:02:52.218]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.218]                         if (muffled) 
[17:02:52.218]                           invokeRestart("muffleWarning")
[17:02:52.218]                       }
[17:02:52.218]                       else if (inherits(cond, "condition")) {
[17:02:52.218]                         if (!is.null(pattern)) {
[17:02:52.218]                           computeRestarts <- base::computeRestarts
[17:02:52.218]                           grepl <- base::grepl
[17:02:52.218]                           restarts <- computeRestarts(cond)
[17:02:52.218]                           for (restart in restarts) {
[17:02:52.218]                             name <- restart$name
[17:02:52.218]                             if (is.null(name)) 
[17:02:52.218]                               next
[17:02:52.218]                             if (!grepl(pattern, name)) 
[17:02:52.218]                               next
[17:02:52.218]                             invokeRestart(restart)
[17:02:52.218]                             muffled <- TRUE
[17:02:52.218]                             break
[17:02:52.218]                           }
[17:02:52.218]                         }
[17:02:52.218]                       }
[17:02:52.218]                       invisible(muffled)
[17:02:52.218]                     }
[17:02:52.218]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.218]                   }
[17:02:52.218]                 }
[17:02:52.218]             }
[17:02:52.218]         }))
[17:02:52.218]     }, error = function(ex) {
[17:02:52.218]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.218]                 ...future.rng), started = ...future.startTime, 
[17:02:52.218]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.218]             version = "1.8"), class = "FutureResult")
[17:02:52.218]     }, finally = {
[17:02:52.218]         if (!identical(...future.workdir, getwd())) 
[17:02:52.218]             setwd(...future.workdir)
[17:02:52.218]         {
[17:02:52.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.218]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.218]             }
[17:02:52.218]             base::options(...future.oldOptions)
[17:02:52.218]             if (.Platform$OS.type == "windows") {
[17:02:52.218]                 old_names <- names(...future.oldEnvVars)
[17:02:52.218]                 envs <- base::Sys.getenv()
[17:02:52.218]                 names <- names(envs)
[17:02:52.218]                 common <- intersect(names, old_names)
[17:02:52.218]                 added <- setdiff(names, old_names)
[17:02:52.218]                 removed <- setdiff(old_names, names)
[17:02:52.218]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.218]                   envs[common]]
[17:02:52.218]                 NAMES <- toupper(changed)
[17:02:52.218]                 args <- list()
[17:02:52.218]                 for (kk in seq_along(NAMES)) {
[17:02:52.218]                   name <- changed[[kk]]
[17:02:52.218]                   NAME <- NAMES[[kk]]
[17:02:52.218]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.218]                     next
[17:02:52.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.218]                 }
[17:02:52.218]                 NAMES <- toupper(added)
[17:02:52.218]                 for (kk in seq_along(NAMES)) {
[17:02:52.218]                   name <- added[[kk]]
[17:02:52.218]                   NAME <- NAMES[[kk]]
[17:02:52.218]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.218]                     next
[17:02:52.218]                   args[[name]] <- ""
[17:02:52.218]                 }
[17:02:52.218]                 NAMES <- toupper(removed)
[17:02:52.218]                 for (kk in seq_along(NAMES)) {
[17:02:52.218]                   name <- removed[[kk]]
[17:02:52.218]                   NAME <- NAMES[[kk]]
[17:02:52.218]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.218]                     next
[17:02:52.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.218]                 }
[17:02:52.218]                 if (length(args) > 0) 
[17:02:52.218]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.218]             }
[17:02:52.218]             else {
[17:02:52.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.218]             }
[17:02:52.218]             {
[17:02:52.218]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.218]                   0L) {
[17:02:52.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.218]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.218]                   base::options(opts)
[17:02:52.218]                 }
[17:02:52.218]                 {
[17:02:52.218]                   {
[17:02:52.218]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.218]                     NULL
[17:02:52.218]                   }
[17:02:52.218]                   options(future.plan = NULL)
[17:02:52.218]                   if (is.na(NA_character_)) 
[17:02:52.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.218]                     .init = FALSE)
[17:02:52.218]                 }
[17:02:52.218]             }
[17:02:52.218]         }
[17:02:52.218]     })
[17:02:52.218]     if (TRUE) {
[17:02:52.218]         base::sink(type = "output", split = FALSE)
[17:02:52.218]         if (TRUE) {
[17:02:52.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.218]         }
[17:02:52.218]         else {
[17:02:52.218]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.218]         }
[17:02:52.218]         base::close(...future.stdout)
[17:02:52.218]         ...future.stdout <- NULL
[17:02:52.218]     }
[17:02:52.218]     ...future.result$conditions <- ...future.conditions
[17:02:52.218]     ...future.result$finished <- base::Sys.time()
[17:02:52.218]     ...future.result
[17:02:52.218] }
[17:02:52.221] assign_globals() ...
[17:02:52.221] List of 2
[17:02:52.221]  $ a : num 1
[17:02:52.221]  $ ii: int 1
[17:02:52.221]  - attr(*, "where")=List of 2
[17:02:52.221]   ..$ a :<environment: R_EmptyEnv> 
[17:02:52.221]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:52.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.221]  - attr(*, "resolved")= logi TRUE
[17:02:52.221]  - attr(*, "total_size")= num 112
[17:02:52.221]  - attr(*, "already-done")= logi TRUE
[17:02:52.224] - copied ‘a’ to environment
[17:02:52.224] - copied ‘ii’ to environment
[17:02:52.224] assign_globals() ... done
[17:02:52.225] requestCore(): workers = 2
[17:02:52.227] MulticoreFuture started
[17:02:52.227] - Launch lazy future ... done
[17:02:52.227] run() for ‘MulticoreFuture’ ... done
[17:02:52.228] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.229] getGlobalsAndPackages() ...
[17:02:52.228] List of future strategies:
[17:02:52.228] 1. sequential:
[17:02:52.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.228]    - tweaked: FALSE
[17:02:52.228]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.229] plan(): nbrOfWorkers() = 1
[17:02:52.229] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.231] plan(): Setting new future strategy stack:
[17:02:52.231] List of future strategies:
[17:02:52.231] 1. multicore:
[17:02:52.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.231]    - tweaked: FALSE
[17:02:52.231]    - call: plan(strategy)
[17:02:52.233] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.236] plan(): nbrOfWorkers() = 2
[17:02:52.236] Searching for globals ... DONE
[17:02:52.237] Resolving globals: TRUE
[17:02:52.237] Resolving any globals that are futures ...
[17:02:52.237] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.238] Resolving any globals that are futures ... DONE
[17:02:52.239] Resolving futures part of globals (recursively) ...
[17:02:52.240] resolve() on list ...
[17:02:52.240]  recursive: 99
[17:02:52.241]  length: 2
[17:02:52.241]  elements: ‘a’, ‘ii’
[17:02:52.241]  length: 1 (resolved future 1)
[17:02:52.242]  length: 0 (resolved future 2)
[17:02:52.242] resolve() on list ... DONE
[17:02:52.242] - globals: [2] ‘a’, ‘ii’
[17:02:52.242] Resolving futures part of globals (recursively) ... DONE
[17:02:52.243] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:52.243] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:52.244] - globals: [2] ‘a’, ‘ii’
[17:02:52.244] 
[17:02:52.244] getGlobalsAndPackages() ... DONE
[17:02:52.244] run() for ‘Future’ ...
[17:02:52.245] - state: ‘created’
[17:02:52.245] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.250] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.250]   - Field: ‘label’
[17:02:52.250]   - Field: ‘local’
[17:02:52.250]   - Field: ‘owner’
[17:02:52.250]   - Field: ‘envir’
[17:02:52.251]   - Field: ‘workers’
[17:02:52.251]   - Field: ‘packages’
[17:02:52.251]   - Field: ‘gc’
[17:02:52.251]   - Field: ‘job’
[17:02:52.251]   - Field: ‘conditions’
[17:02:52.251]   - Field: ‘expr’
[17:02:52.252]   - Field: ‘uuid’
[17:02:52.252]   - Field: ‘seed’
[17:02:52.252]   - Field: ‘version’
[17:02:52.252]   - Field: ‘result’
[17:02:52.252]   - Field: ‘asynchronous’
[17:02:52.252]   - Field: ‘calls’
[17:02:52.252]   - Field: ‘globals’
[17:02:52.252]   - Field: ‘stdout’
[17:02:52.253]   - Field: ‘earlySignal’
[17:02:52.253]   - Field: ‘lazy’
[17:02:52.253]   - Field: ‘state’
[17:02:52.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.253] - Launch lazy future ...
[17:02:52.254] Packages needed by the future expression (n = 0): <none>
[17:02:52.254] Packages needed by future strategies (n = 0): <none>
[17:02:52.254] {
[17:02:52.254]     {
[17:02:52.254]         {
[17:02:52.254]             ...future.startTime <- base::Sys.time()
[17:02:52.254]             {
[17:02:52.254]                 {
[17:02:52.254]                   {
[17:02:52.254]                     {
[17:02:52.254]                       base::local({
[17:02:52.254]                         has_future <- base::requireNamespace("future", 
[17:02:52.254]                           quietly = TRUE)
[17:02:52.254]                         if (has_future) {
[17:02:52.254]                           ns <- base::getNamespace("future")
[17:02:52.254]                           version <- ns[[".package"]][["version"]]
[17:02:52.254]                           if (is.null(version)) 
[17:02:52.254]                             version <- utils::packageVersion("future")
[17:02:52.254]                         }
[17:02:52.254]                         else {
[17:02:52.254]                           version <- NULL
[17:02:52.254]                         }
[17:02:52.254]                         if (!has_future || version < "1.8.0") {
[17:02:52.254]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.254]                             "", base::R.version$version.string), 
[17:02:52.254]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.254]                               "release", "version")], collapse = " "), 
[17:02:52.254]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.254]                             info)
[17:02:52.254]                           info <- base::paste(info, collapse = "; ")
[17:02:52.254]                           if (!has_future) {
[17:02:52.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.254]                               info)
[17:02:52.254]                           }
[17:02:52.254]                           else {
[17:02:52.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.254]                               info, version)
[17:02:52.254]                           }
[17:02:52.254]                           base::stop(msg)
[17:02:52.254]                         }
[17:02:52.254]                       })
[17:02:52.254]                     }
[17:02:52.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.254]                     base::options(mc.cores = 1L)
[17:02:52.254]                   }
[17:02:52.254]                   ...future.strategy.old <- future::plan("list")
[17:02:52.254]                   options(future.plan = NULL)
[17:02:52.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.254]                 }
[17:02:52.254]                 ...future.workdir <- getwd()
[17:02:52.254]             }
[17:02:52.254]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.254]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.254]         }
[17:02:52.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.254]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.254]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.254]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.254]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.254]             base::names(...future.oldOptions))
[17:02:52.254]     }
[17:02:52.254]     if (FALSE) {
[17:02:52.254]     }
[17:02:52.254]     else {
[17:02:52.254]         if (TRUE) {
[17:02:52.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.254]                 open = "w")
[17:02:52.254]         }
[17:02:52.254]         else {
[17:02:52.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.254]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.254]         }
[17:02:52.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.254]             base::sink(type = "output", split = FALSE)
[17:02:52.254]             base::close(...future.stdout)
[17:02:52.254]         }, add = TRUE)
[17:02:52.254]     }
[17:02:52.254]     ...future.frame <- base::sys.nframe()
[17:02:52.254]     ...future.conditions <- base::list()
[17:02:52.254]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.254]     if (FALSE) {
[17:02:52.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.254]     }
[17:02:52.254]     ...future.result <- base::tryCatch({
[17:02:52.254]         base::withCallingHandlers({
[17:02:52.254]             ...future.value <- base::withVisible(base::local({
[17:02:52.254]                 withCallingHandlers({
[17:02:52.254]                   {
[17:02:52.254]                     b <- a * ii
[17:02:52.254]                     a <- 0
[17:02:52.254]                     b
[17:02:52.254]                   }
[17:02:52.254]                 }, immediateCondition = function(cond) {
[17:02:52.254]                   save_rds <- function (object, pathname, ...) 
[17:02:52.254]                   {
[17:02:52.254]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.254]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.254]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.254]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.254]                         fi_tmp[["mtime"]])
[17:02:52.254]                     }
[17:02:52.254]                     tryCatch({
[17:02:52.254]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.254]                     }, error = function(ex) {
[17:02:52.254]                       msg <- conditionMessage(ex)
[17:02:52.254]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.254]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.254]                         fi_tmp[["mtime"]], msg)
[17:02:52.254]                       ex$message <- msg
[17:02:52.254]                       stop(ex)
[17:02:52.254]                     })
[17:02:52.254]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.254]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.254]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.254]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.254]                       fi <- file.info(pathname)
[17:02:52.254]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.254]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.254]                         fi[["size"]], fi[["mtime"]])
[17:02:52.254]                       stop(msg)
[17:02:52.254]                     }
[17:02:52.254]                     invisible(pathname)
[17:02:52.254]                   }
[17:02:52.254]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.254]                     rootPath = tempdir()) 
[17:02:52.254]                   {
[17:02:52.254]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.254]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.254]                       tmpdir = path, fileext = ".rds")
[17:02:52.254]                     save_rds(obj, file)
[17:02:52.254]                   }
[17:02:52.254]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.254]                   {
[17:02:52.254]                     inherits <- base::inherits
[17:02:52.254]                     invokeRestart <- base::invokeRestart
[17:02:52.254]                     is.null <- base::is.null
[17:02:52.254]                     muffled <- FALSE
[17:02:52.254]                     if (inherits(cond, "message")) {
[17:02:52.254]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.254]                       if (muffled) 
[17:02:52.254]                         invokeRestart("muffleMessage")
[17:02:52.254]                     }
[17:02:52.254]                     else if (inherits(cond, "warning")) {
[17:02:52.254]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.254]                       if (muffled) 
[17:02:52.254]                         invokeRestart("muffleWarning")
[17:02:52.254]                     }
[17:02:52.254]                     else if (inherits(cond, "condition")) {
[17:02:52.254]                       if (!is.null(pattern)) {
[17:02:52.254]                         computeRestarts <- base::computeRestarts
[17:02:52.254]                         grepl <- base::grepl
[17:02:52.254]                         restarts <- computeRestarts(cond)
[17:02:52.254]                         for (restart in restarts) {
[17:02:52.254]                           name <- restart$name
[17:02:52.254]                           if (is.null(name)) 
[17:02:52.254]                             next
[17:02:52.254]                           if (!grepl(pattern, name)) 
[17:02:52.254]                             next
[17:02:52.254]                           invokeRestart(restart)
[17:02:52.254]                           muffled <- TRUE
[17:02:52.254]                           break
[17:02:52.254]                         }
[17:02:52.254]                       }
[17:02:52.254]                     }
[17:02:52.254]                     invisible(muffled)
[17:02:52.254]                   }
[17:02:52.254]                   muffleCondition(cond)
[17:02:52.254]                 })
[17:02:52.254]             }))
[17:02:52.254]             future::FutureResult(value = ...future.value$value, 
[17:02:52.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.254]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.254]                     ...future.globalenv.names))
[17:02:52.254]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.254]         }, condition = base::local({
[17:02:52.254]             c <- base::c
[17:02:52.254]             inherits <- base::inherits
[17:02:52.254]             invokeRestart <- base::invokeRestart
[17:02:52.254]             length <- base::length
[17:02:52.254]             list <- base::list
[17:02:52.254]             seq.int <- base::seq.int
[17:02:52.254]             signalCondition <- base::signalCondition
[17:02:52.254]             sys.calls <- base::sys.calls
[17:02:52.254]             `[[` <- base::`[[`
[17:02:52.254]             `+` <- base::`+`
[17:02:52.254]             `<<-` <- base::`<<-`
[17:02:52.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.254]                   3L)]
[17:02:52.254]             }
[17:02:52.254]             function(cond) {
[17:02:52.254]                 is_error <- inherits(cond, "error")
[17:02:52.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.254]                   NULL)
[17:02:52.254]                 if (is_error) {
[17:02:52.254]                   sessionInformation <- function() {
[17:02:52.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.254]                       search = base::search(), system = base::Sys.info())
[17:02:52.254]                   }
[17:02:52.254]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.254]                     cond$call), session = sessionInformation(), 
[17:02:52.254]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.254]                   signalCondition(cond)
[17:02:52.254]                 }
[17:02:52.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.254]                 "immediateCondition"))) {
[17:02:52.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.254]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.254]                   if (TRUE && !signal) {
[17:02:52.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.254]                     {
[17:02:52.254]                       inherits <- base::inherits
[17:02:52.254]                       invokeRestart <- base::invokeRestart
[17:02:52.254]                       is.null <- base::is.null
[17:02:52.254]                       muffled <- FALSE
[17:02:52.254]                       if (inherits(cond, "message")) {
[17:02:52.254]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.254]                         if (muffled) 
[17:02:52.254]                           invokeRestart("muffleMessage")
[17:02:52.254]                       }
[17:02:52.254]                       else if (inherits(cond, "warning")) {
[17:02:52.254]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.254]                         if (muffled) 
[17:02:52.254]                           invokeRestart("muffleWarning")
[17:02:52.254]                       }
[17:02:52.254]                       else if (inherits(cond, "condition")) {
[17:02:52.254]                         if (!is.null(pattern)) {
[17:02:52.254]                           computeRestarts <- base::computeRestarts
[17:02:52.254]                           grepl <- base::grepl
[17:02:52.254]                           restarts <- computeRestarts(cond)
[17:02:52.254]                           for (restart in restarts) {
[17:02:52.254]                             name <- restart$name
[17:02:52.254]                             if (is.null(name)) 
[17:02:52.254]                               next
[17:02:52.254]                             if (!grepl(pattern, name)) 
[17:02:52.254]                               next
[17:02:52.254]                             invokeRestart(restart)
[17:02:52.254]                             muffled <- TRUE
[17:02:52.254]                             break
[17:02:52.254]                           }
[17:02:52.254]                         }
[17:02:52.254]                       }
[17:02:52.254]                       invisible(muffled)
[17:02:52.254]                     }
[17:02:52.254]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.254]                   }
[17:02:52.254]                 }
[17:02:52.254]                 else {
[17:02:52.254]                   if (TRUE) {
[17:02:52.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.254]                     {
[17:02:52.254]                       inherits <- base::inherits
[17:02:52.254]                       invokeRestart <- base::invokeRestart
[17:02:52.254]                       is.null <- base::is.null
[17:02:52.254]                       muffled <- FALSE
[17:02:52.254]                       if (inherits(cond, "message")) {
[17:02:52.254]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.254]                         if (muffled) 
[17:02:52.254]                           invokeRestart("muffleMessage")
[17:02:52.254]                       }
[17:02:52.254]                       else if (inherits(cond, "warning")) {
[17:02:52.254]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.254]                         if (muffled) 
[17:02:52.254]                           invokeRestart("muffleWarning")
[17:02:52.254]                       }
[17:02:52.254]                       else if (inherits(cond, "condition")) {
[17:02:52.254]                         if (!is.null(pattern)) {
[17:02:52.254]                           computeRestarts <- base::computeRestarts
[17:02:52.254]                           grepl <- base::grepl
[17:02:52.254]                           restarts <- computeRestarts(cond)
[17:02:52.254]                           for (restart in restarts) {
[17:02:52.254]                             name <- restart$name
[17:02:52.254]                             if (is.null(name)) 
[17:02:52.254]                               next
[17:02:52.254]                             if (!grepl(pattern, name)) 
[17:02:52.254]                               next
[17:02:52.254]                             invokeRestart(restart)
[17:02:52.254]                             muffled <- TRUE
[17:02:52.254]                             break
[17:02:52.254]                           }
[17:02:52.254]                         }
[17:02:52.254]                       }
[17:02:52.254]                       invisible(muffled)
[17:02:52.254]                     }
[17:02:52.254]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.254]                   }
[17:02:52.254]                 }
[17:02:52.254]             }
[17:02:52.254]         }))
[17:02:52.254]     }, error = function(ex) {
[17:02:52.254]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.254]                 ...future.rng), started = ...future.startTime, 
[17:02:52.254]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.254]             version = "1.8"), class = "FutureResult")
[17:02:52.254]     }, finally = {
[17:02:52.254]         if (!identical(...future.workdir, getwd())) 
[17:02:52.254]             setwd(...future.workdir)
[17:02:52.254]         {
[17:02:52.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.254]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.254]             }
[17:02:52.254]             base::options(...future.oldOptions)
[17:02:52.254]             if (.Platform$OS.type == "windows") {
[17:02:52.254]                 old_names <- names(...future.oldEnvVars)
[17:02:52.254]                 envs <- base::Sys.getenv()
[17:02:52.254]                 names <- names(envs)
[17:02:52.254]                 common <- intersect(names, old_names)
[17:02:52.254]                 added <- setdiff(names, old_names)
[17:02:52.254]                 removed <- setdiff(old_names, names)
[17:02:52.254]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.254]                   envs[common]]
[17:02:52.254]                 NAMES <- toupper(changed)
[17:02:52.254]                 args <- list()
[17:02:52.254]                 for (kk in seq_along(NAMES)) {
[17:02:52.254]                   name <- changed[[kk]]
[17:02:52.254]                   NAME <- NAMES[[kk]]
[17:02:52.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.254]                     next
[17:02:52.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.254]                 }
[17:02:52.254]                 NAMES <- toupper(added)
[17:02:52.254]                 for (kk in seq_along(NAMES)) {
[17:02:52.254]                   name <- added[[kk]]
[17:02:52.254]                   NAME <- NAMES[[kk]]
[17:02:52.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.254]                     next
[17:02:52.254]                   args[[name]] <- ""
[17:02:52.254]                 }
[17:02:52.254]                 NAMES <- toupper(removed)
[17:02:52.254]                 for (kk in seq_along(NAMES)) {
[17:02:52.254]                   name <- removed[[kk]]
[17:02:52.254]                   NAME <- NAMES[[kk]]
[17:02:52.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.254]                     next
[17:02:52.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.254]                 }
[17:02:52.254]                 if (length(args) > 0) 
[17:02:52.254]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.254]             }
[17:02:52.254]             else {
[17:02:52.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.254]             }
[17:02:52.254]             {
[17:02:52.254]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.254]                   0L) {
[17:02:52.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.254]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.254]                   base::options(opts)
[17:02:52.254]                 }
[17:02:52.254]                 {
[17:02:52.254]                   {
[17:02:52.254]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.254]                     NULL
[17:02:52.254]                   }
[17:02:52.254]                   options(future.plan = NULL)
[17:02:52.254]                   if (is.na(NA_character_)) 
[17:02:52.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.254]                     .init = FALSE)
[17:02:52.254]                 }
[17:02:52.254]             }
[17:02:52.254]         }
[17:02:52.254]     })
[17:02:52.254]     if (TRUE) {
[17:02:52.254]         base::sink(type = "output", split = FALSE)
[17:02:52.254]         if (TRUE) {
[17:02:52.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.254]         }
[17:02:52.254]         else {
[17:02:52.254]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.254]         }
[17:02:52.254]         base::close(...future.stdout)
[17:02:52.254]         ...future.stdout <- NULL
[17:02:52.254]     }
[17:02:52.254]     ...future.result$conditions <- ...future.conditions
[17:02:52.254]     ...future.result$finished <- base::Sys.time()
[17:02:52.254]     ...future.result
[17:02:52.254] }
[17:02:52.257] assign_globals() ...
[17:02:52.257] List of 2
[17:02:52.257]  $ a : num 1
[17:02:52.257]  $ ii: int 2
[17:02:52.257]  - attr(*, "where")=List of 2
[17:02:52.257]   ..$ a :<environment: R_EmptyEnv> 
[17:02:52.257]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:52.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.257]  - attr(*, "resolved")= logi TRUE
[17:02:52.257]  - attr(*, "total_size")= num 112
[17:02:52.257]  - attr(*, "already-done")= logi TRUE
[17:02:52.261] - copied ‘a’ to environment
[17:02:52.262] - copied ‘ii’ to environment
[17:02:52.262] assign_globals() ... done
[17:02:52.262] requestCore(): workers = 2
[17:02:52.264] MulticoreFuture started
[17:02:52.265] - Launch lazy future ... done
[17:02:52.265] run() for ‘MulticoreFuture’ ... done
[17:02:52.265] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.266] getGlobalsAndPackages() ...
[17:02:52.266] List of future strategies:
[17:02:52.266] 1. sequential:
[17:02:52.266]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.266]    - tweaked: FALSE
[17:02:52.266]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.267] Searching for globals...
[17:02:52.267] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.269] plan(): Setting new future strategy stack:
[17:02:52.269] List of future strategies:
[17:02:52.269] 1. multicore:
[17:02:52.269]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.269]    - tweaked: FALSE
[17:02:52.269]    - call: plan(strategy)
[17:02:52.270] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.270] Searching for globals ... DONE
[17:02:52.271] Resolving globals: TRUE
[17:02:52.271] Resolving any globals that are futures ...
[17:02:52.271] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.271] Resolving any globals that are futures ... DONE
[17:02:52.272] Resolving futures part of globals (recursively) ...
[17:02:52.272] resolve() on list ...
[17:02:52.273]  recursive: 99
[17:02:52.273]  length: 2
[17:02:52.273]  elements: ‘a’, ‘ii’
[17:02:52.273]  length: 1 (resolved future 1)
[17:02:52.273]  length: 0 (resolved future 2)
[17:02:52.273] resolve() on list ... DONE
[17:02:52.273] - globals: [2] ‘a’, ‘ii’
[17:02:52.274] Resolving futures part of globals (recursively) ... DONE
[17:02:52.274] plan(): nbrOfWorkers() = 2
[17:02:52.274] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:52.275] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:52.275] - globals: [2] ‘a’, ‘ii’
[17:02:52.275] 
[17:02:52.275] getGlobalsAndPackages() ... DONE
[17:02:52.276] run() for ‘Future’ ...
[17:02:52.276] - state: ‘created’
[17:02:52.276] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.286] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.287]   - Field: ‘label’
[17:02:52.287]   - Field: ‘local’
[17:02:52.287]   - Field: ‘owner’
[17:02:52.288]   - Field: ‘envir’
[17:02:52.288]   - Field: ‘workers’
[17:02:52.288]   - Field: ‘packages’
[17:02:52.288]   - Field: ‘gc’
[17:02:52.289]   - Field: ‘job’
[17:02:52.289]   - Field: ‘conditions’
[17:02:52.289]   - Field: ‘expr’
[17:02:52.289]   - Field: ‘uuid’
[17:02:52.289]   - Field: ‘seed’
[17:02:52.290]   - Field: ‘version’
[17:02:52.290]   - Field: ‘result’
[17:02:52.290]   - Field: ‘asynchronous’
[17:02:52.290]   - Field: ‘calls’
[17:02:52.290]   - Field: ‘globals’
[17:02:52.291]   - Field: ‘stdout’
[17:02:52.291]   - Field: ‘earlySignal’
[17:02:52.291]   - Field: ‘lazy’
[17:02:52.291]   - Field: ‘state’
[17:02:52.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.292] - Launch lazy future ...
[17:02:52.292] Packages needed by the future expression (n = 0): <none>
[17:02:52.292] Packages needed by future strategies (n = 0): <none>
[17:02:52.293] {
[17:02:52.293]     {
[17:02:52.293]         {
[17:02:52.293]             ...future.startTime <- base::Sys.time()
[17:02:52.293]             {
[17:02:52.293]                 {
[17:02:52.293]                   {
[17:02:52.293]                     {
[17:02:52.293]                       base::local({
[17:02:52.293]                         has_future <- base::requireNamespace("future", 
[17:02:52.293]                           quietly = TRUE)
[17:02:52.293]                         if (has_future) {
[17:02:52.293]                           ns <- base::getNamespace("future")
[17:02:52.293]                           version <- ns[[".package"]][["version"]]
[17:02:52.293]                           if (is.null(version)) 
[17:02:52.293]                             version <- utils::packageVersion("future")
[17:02:52.293]                         }
[17:02:52.293]                         else {
[17:02:52.293]                           version <- NULL
[17:02:52.293]                         }
[17:02:52.293]                         if (!has_future || version < "1.8.0") {
[17:02:52.293]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.293]                             "", base::R.version$version.string), 
[17:02:52.293]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.293]                               "release", "version")], collapse = " "), 
[17:02:52.293]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.293]                             info)
[17:02:52.293]                           info <- base::paste(info, collapse = "; ")
[17:02:52.293]                           if (!has_future) {
[17:02:52.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.293]                               info)
[17:02:52.293]                           }
[17:02:52.293]                           else {
[17:02:52.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.293]                               info, version)
[17:02:52.293]                           }
[17:02:52.293]                           base::stop(msg)
[17:02:52.293]                         }
[17:02:52.293]                       })
[17:02:52.293]                     }
[17:02:52.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.293]                     base::options(mc.cores = 1L)
[17:02:52.293]                   }
[17:02:52.293]                   ...future.strategy.old <- future::plan("list")
[17:02:52.293]                   options(future.plan = NULL)
[17:02:52.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.293]                 }
[17:02:52.293]                 ...future.workdir <- getwd()
[17:02:52.293]             }
[17:02:52.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.293]         }
[17:02:52.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.293]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.293]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.293]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.293]             base::names(...future.oldOptions))
[17:02:52.293]     }
[17:02:52.293]     if (FALSE) {
[17:02:52.293]     }
[17:02:52.293]     else {
[17:02:52.293]         if (TRUE) {
[17:02:52.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.293]                 open = "w")
[17:02:52.293]         }
[17:02:52.293]         else {
[17:02:52.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.293]         }
[17:02:52.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.293]             base::sink(type = "output", split = FALSE)
[17:02:52.293]             base::close(...future.stdout)
[17:02:52.293]         }, add = TRUE)
[17:02:52.293]     }
[17:02:52.293]     ...future.frame <- base::sys.nframe()
[17:02:52.293]     ...future.conditions <- base::list()
[17:02:52.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.293]     if (FALSE) {
[17:02:52.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.293]     }
[17:02:52.293]     ...future.result <- base::tryCatch({
[17:02:52.293]         base::withCallingHandlers({
[17:02:52.293]             ...future.value <- base::withVisible(base::local({
[17:02:52.293]                 withCallingHandlers({
[17:02:52.293]                   {
[17:02:52.293]                     b <- a * ii
[17:02:52.293]                     a <- 0
[17:02:52.293]                     b
[17:02:52.293]                   }
[17:02:52.293]                 }, immediateCondition = function(cond) {
[17:02:52.293]                   save_rds <- function (object, pathname, ...) 
[17:02:52.293]                   {
[17:02:52.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.293]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.293]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.293]                         fi_tmp[["mtime"]])
[17:02:52.293]                     }
[17:02:52.293]                     tryCatch({
[17:02:52.293]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.293]                     }, error = function(ex) {
[17:02:52.293]                       msg <- conditionMessage(ex)
[17:02:52.293]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.293]                         fi_tmp[["mtime"]], msg)
[17:02:52.293]                       ex$message <- msg
[17:02:52.293]                       stop(ex)
[17:02:52.293]                     })
[17:02:52.293]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.293]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.293]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.293]                       fi <- file.info(pathname)
[17:02:52.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.293]                         fi[["size"]], fi[["mtime"]])
[17:02:52.293]                       stop(msg)
[17:02:52.293]                     }
[17:02:52.293]                     invisible(pathname)
[17:02:52.293]                   }
[17:02:52.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.293]                     rootPath = tempdir()) 
[17:02:52.293]                   {
[17:02:52.293]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.293]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.293]                       tmpdir = path, fileext = ".rds")
[17:02:52.293]                     save_rds(obj, file)
[17:02:52.293]                   }
[17:02:52.293]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.293]                   {
[17:02:52.293]                     inherits <- base::inherits
[17:02:52.293]                     invokeRestart <- base::invokeRestart
[17:02:52.293]                     is.null <- base::is.null
[17:02:52.293]                     muffled <- FALSE
[17:02:52.293]                     if (inherits(cond, "message")) {
[17:02:52.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.293]                       if (muffled) 
[17:02:52.293]                         invokeRestart("muffleMessage")
[17:02:52.293]                     }
[17:02:52.293]                     else if (inherits(cond, "warning")) {
[17:02:52.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.293]                       if (muffled) 
[17:02:52.293]                         invokeRestart("muffleWarning")
[17:02:52.293]                     }
[17:02:52.293]                     else if (inherits(cond, "condition")) {
[17:02:52.293]                       if (!is.null(pattern)) {
[17:02:52.293]                         computeRestarts <- base::computeRestarts
[17:02:52.293]                         grepl <- base::grepl
[17:02:52.293]                         restarts <- computeRestarts(cond)
[17:02:52.293]                         for (restart in restarts) {
[17:02:52.293]                           name <- restart$name
[17:02:52.293]                           if (is.null(name)) 
[17:02:52.293]                             next
[17:02:52.293]                           if (!grepl(pattern, name)) 
[17:02:52.293]                             next
[17:02:52.293]                           invokeRestart(restart)
[17:02:52.293]                           muffled <- TRUE
[17:02:52.293]                           break
[17:02:52.293]                         }
[17:02:52.293]                       }
[17:02:52.293]                     }
[17:02:52.293]                     invisible(muffled)
[17:02:52.293]                   }
[17:02:52.293]                   muffleCondition(cond)
[17:02:52.293]                 })
[17:02:52.293]             }))
[17:02:52.293]             future::FutureResult(value = ...future.value$value, 
[17:02:52.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.293]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.293]                     ...future.globalenv.names))
[17:02:52.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.293]         }, condition = base::local({
[17:02:52.293]             c <- base::c
[17:02:52.293]             inherits <- base::inherits
[17:02:52.293]             invokeRestart <- base::invokeRestart
[17:02:52.293]             length <- base::length
[17:02:52.293]             list <- base::list
[17:02:52.293]             seq.int <- base::seq.int
[17:02:52.293]             signalCondition <- base::signalCondition
[17:02:52.293]             sys.calls <- base::sys.calls
[17:02:52.293]             `[[` <- base::`[[`
[17:02:52.293]             `+` <- base::`+`
[17:02:52.293]             `<<-` <- base::`<<-`
[17:02:52.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.293]                   3L)]
[17:02:52.293]             }
[17:02:52.293]             function(cond) {
[17:02:52.293]                 is_error <- inherits(cond, "error")
[17:02:52.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.293]                   NULL)
[17:02:52.293]                 if (is_error) {
[17:02:52.293]                   sessionInformation <- function() {
[17:02:52.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.293]                       search = base::search(), system = base::Sys.info())
[17:02:52.293]                   }
[17:02:52.293]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.293]                     cond$call), session = sessionInformation(), 
[17:02:52.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.293]                   signalCondition(cond)
[17:02:52.293]                 }
[17:02:52.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.293]                 "immediateCondition"))) {
[17:02:52.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.293]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.293]                   if (TRUE && !signal) {
[17:02:52.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.293]                     {
[17:02:52.293]                       inherits <- base::inherits
[17:02:52.293]                       invokeRestart <- base::invokeRestart
[17:02:52.293]                       is.null <- base::is.null
[17:02:52.293]                       muffled <- FALSE
[17:02:52.293]                       if (inherits(cond, "message")) {
[17:02:52.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.293]                         if (muffled) 
[17:02:52.293]                           invokeRestart("muffleMessage")
[17:02:52.293]                       }
[17:02:52.293]                       else if (inherits(cond, "warning")) {
[17:02:52.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.293]                         if (muffled) 
[17:02:52.293]                           invokeRestart("muffleWarning")
[17:02:52.293]                       }
[17:02:52.293]                       else if (inherits(cond, "condition")) {
[17:02:52.293]                         if (!is.null(pattern)) {
[17:02:52.293]                           computeRestarts <- base::computeRestarts
[17:02:52.293]                           grepl <- base::grepl
[17:02:52.293]                           restarts <- computeRestarts(cond)
[17:02:52.293]                           for (restart in restarts) {
[17:02:52.293]                             name <- restart$name
[17:02:52.293]                             if (is.null(name)) 
[17:02:52.293]                               next
[17:02:52.293]                             if (!grepl(pattern, name)) 
[17:02:52.293]                               next
[17:02:52.293]                             invokeRestart(restart)
[17:02:52.293]                             muffled <- TRUE
[17:02:52.293]                             break
[17:02:52.293]                           }
[17:02:52.293]                         }
[17:02:52.293]                       }
[17:02:52.293]                       invisible(muffled)
[17:02:52.293]                     }
[17:02:52.293]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.293]                   }
[17:02:52.293]                 }
[17:02:52.293]                 else {
[17:02:52.293]                   if (TRUE) {
[17:02:52.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.293]                     {
[17:02:52.293]                       inherits <- base::inherits
[17:02:52.293]                       invokeRestart <- base::invokeRestart
[17:02:52.293]                       is.null <- base::is.null
[17:02:52.293]                       muffled <- FALSE
[17:02:52.293]                       if (inherits(cond, "message")) {
[17:02:52.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.293]                         if (muffled) 
[17:02:52.293]                           invokeRestart("muffleMessage")
[17:02:52.293]                       }
[17:02:52.293]                       else if (inherits(cond, "warning")) {
[17:02:52.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.293]                         if (muffled) 
[17:02:52.293]                           invokeRestart("muffleWarning")
[17:02:52.293]                       }
[17:02:52.293]                       else if (inherits(cond, "condition")) {
[17:02:52.293]                         if (!is.null(pattern)) {
[17:02:52.293]                           computeRestarts <- base::computeRestarts
[17:02:52.293]                           grepl <- base::grepl
[17:02:52.293]                           restarts <- computeRestarts(cond)
[17:02:52.293]                           for (restart in restarts) {
[17:02:52.293]                             name <- restart$name
[17:02:52.293]                             if (is.null(name)) 
[17:02:52.293]                               next
[17:02:52.293]                             if (!grepl(pattern, name)) 
[17:02:52.293]                               next
[17:02:52.293]                             invokeRestart(restart)
[17:02:52.293]                             muffled <- TRUE
[17:02:52.293]                             break
[17:02:52.293]                           }
[17:02:52.293]                         }
[17:02:52.293]                       }
[17:02:52.293]                       invisible(muffled)
[17:02:52.293]                     }
[17:02:52.293]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.293]                   }
[17:02:52.293]                 }
[17:02:52.293]             }
[17:02:52.293]         }))
[17:02:52.293]     }, error = function(ex) {
[17:02:52.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.293]                 ...future.rng), started = ...future.startTime, 
[17:02:52.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.293]             version = "1.8"), class = "FutureResult")
[17:02:52.293]     }, finally = {
[17:02:52.293]         if (!identical(...future.workdir, getwd())) 
[17:02:52.293]             setwd(...future.workdir)
[17:02:52.293]         {
[17:02:52.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.293]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.293]             }
[17:02:52.293]             base::options(...future.oldOptions)
[17:02:52.293]             if (.Platform$OS.type == "windows") {
[17:02:52.293]                 old_names <- names(...future.oldEnvVars)
[17:02:52.293]                 envs <- base::Sys.getenv()
[17:02:52.293]                 names <- names(envs)
[17:02:52.293]                 common <- intersect(names, old_names)
[17:02:52.293]                 added <- setdiff(names, old_names)
[17:02:52.293]                 removed <- setdiff(old_names, names)
[17:02:52.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.293]                   envs[common]]
[17:02:52.293]                 NAMES <- toupper(changed)
[17:02:52.293]                 args <- list()
[17:02:52.293]                 for (kk in seq_along(NAMES)) {
[17:02:52.293]                   name <- changed[[kk]]
[17:02:52.293]                   NAME <- NAMES[[kk]]
[17:02:52.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.293]                     next
[17:02:52.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.293]                 }
[17:02:52.293]                 NAMES <- toupper(added)
[17:02:52.293]                 for (kk in seq_along(NAMES)) {
[17:02:52.293]                   name <- added[[kk]]
[17:02:52.293]                   NAME <- NAMES[[kk]]
[17:02:52.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.293]                     next
[17:02:52.293]                   args[[name]] <- ""
[17:02:52.293]                 }
[17:02:52.293]                 NAMES <- toupper(removed)
[17:02:52.293]                 for (kk in seq_along(NAMES)) {
[17:02:52.293]                   name <- removed[[kk]]
[17:02:52.293]                   NAME <- NAMES[[kk]]
[17:02:52.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.293]                     next
[17:02:52.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.293]                 }
[17:02:52.293]                 if (length(args) > 0) 
[17:02:52.293]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.293]             }
[17:02:52.293]             else {
[17:02:52.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.293]             }
[17:02:52.293]             {
[17:02:52.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.293]                   0L) {
[17:02:52.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.293]                   base::options(opts)
[17:02:52.293]                 }
[17:02:52.293]                 {
[17:02:52.293]                   {
[17:02:52.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.293]                     NULL
[17:02:52.293]                   }
[17:02:52.293]                   options(future.plan = NULL)
[17:02:52.293]                   if (is.na(NA_character_)) 
[17:02:52.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.293]                     .init = FALSE)
[17:02:52.293]                 }
[17:02:52.293]             }
[17:02:52.293]         }
[17:02:52.293]     })
[17:02:52.293]     if (TRUE) {
[17:02:52.293]         base::sink(type = "output", split = FALSE)
[17:02:52.293]         if (TRUE) {
[17:02:52.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.293]         }
[17:02:52.293]         else {
[17:02:52.293]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.293]         }
[17:02:52.293]         base::close(...future.stdout)
[17:02:52.293]         ...future.stdout <- NULL
[17:02:52.293]     }
[17:02:52.293]     ...future.result$conditions <- ...future.conditions
[17:02:52.293]     ...future.result$finished <- base::Sys.time()
[17:02:52.293]     ...future.result
[17:02:52.293] }
[17:02:52.296] assign_globals() ...
[17:02:52.296] List of 2
[17:02:52.296]  $ a : num 1
[17:02:52.296]  $ ii: int 3
[17:02:52.296]  - attr(*, "where")=List of 2
[17:02:52.296]   ..$ a :<environment: R_EmptyEnv> 
[17:02:52.296]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:52.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.296]  - attr(*, "resolved")= logi TRUE
[17:02:52.296]  - attr(*, "total_size")= num 112
[17:02:52.296]  - attr(*, "already-done")= logi TRUE
[17:02:52.300] - copied ‘a’ to environment
[17:02:52.300] - copied ‘ii’ to environment
[17:02:52.301] assign_globals() ... done
[17:02:52.301] requestCore(): workers = 2
[17:02:52.301] Poll #1 (0): usedCores() = 2, workers = 2
[17:02:52.329] result() for MulticoreFuture ...
[17:02:52.330] result() for MulticoreFuture ...
[17:02:52.330] result() for MulticoreFuture ... done
[17:02:52.330] result() for MulticoreFuture ... done
[17:02:52.330] result() for MulticoreFuture ...
[17:02:52.330] result() for MulticoreFuture ... done
[17:02:52.333] MulticoreFuture started
[17:02:52.333] - Launch lazy future ... done
[17:02:52.334] run() for ‘MulticoreFuture’ ... done
[17:02:52.334] plan(): Setting new future strategy stack:
[17:02:52.335] result() for MulticoreFuture ...
[17:02:52.335] result() for MulticoreFuture ... done
[17:02:52.334] List of future strategies:
[17:02:52.334] 1. sequential:
[17:02:52.334]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.334]    - tweaked: FALSE
[17:02:52.334]    - call: NULL
[17:02:52.336] result() for MulticoreFuture ...
[17:02:52.336] plan(): nbrOfWorkers() = 1
[17:02:52.336] result() for MulticoreFuture ... done
[17:02:52.337] result() for MulticoreFuture ...
[17:02:52.338] result() for MulticoreFuture ...
[17:02:52.339] result() for MulticoreFuture ... done
[17:02:52.339] result() for MulticoreFuture ... done
[17:02:52.339] plan(): Setting new future strategy stack:
[17:02:52.339] result() for MulticoreFuture ...
[17:02:52.340] result() for MulticoreFuture ... done
[17:02:52.339] List of future strategies:
[17:02:52.339] 1. multicore:
[17:02:52.339]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.339]    - tweaked: FALSE
[17:02:52.339]    - call: plan(strategy)
[17:02:52.340] result() for MulticoreFuture ...
[17:02:52.346] plan(): nbrOfWorkers() = 2
[17:02:52.347] result() for MulticoreFuture ...
[17:02:52.347] result() for MulticoreFuture ... done
[17:02:52.348] result() for MulticoreFuture ... done
[17:02:52.348] result() for MulticoreFuture ...
[17:02:52.348] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.350] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.350] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.353] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.353] Searching for globals ... DONE
[17:02:52.354] Resolving globals: TRUE
[17:02:52.354] Resolving any globals that are futures ...
[17:02:52.354] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.354] Resolving any globals that are futures ... DONE
[17:02:52.354] Resolving futures part of globals (recursively) ...
[17:02:52.355] resolve() on list ...
[17:02:52.355]  recursive: 99
[17:02:52.355]  length: 2
[17:02:52.355]  elements: ‘a’, ‘ii’
[17:02:52.355]  length: 1 (resolved future 1)
[17:02:52.355]  length: 0 (resolved future 2)
[17:02:52.356] resolve() on list ... DONE
[17:02:52.356] - globals: [2] ‘a’, ‘ii’
[17:02:52.356] Resolving futures part of globals (recursively) ... DONE
[17:02:52.356] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:52.356] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:52.357] - globals: [2] ‘a’, ‘ii’
[17:02:52.357] 
[17:02:52.357] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.358] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.358] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.360] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.360] Searching for globals ... DONE
[17:02:52.360] Resolving globals: TRUE
[17:02:52.360] Resolving any globals that are futures ...
[17:02:52.360] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.360] Resolving any globals that are futures ... DONE
[17:02:52.361] Resolving futures part of globals (recursively) ...
[17:02:52.361] resolve() on list ...
[17:02:52.361]  recursive: 99
[17:02:52.361]  length: 2
[17:02:52.361]  elements: ‘a’, ‘ii’
[17:02:52.362]  length: 1 (resolved future 1)
[17:02:52.362]  length: 0 (resolved future 2)
[17:02:52.362] resolve() on list ... DONE
[17:02:52.362] - globals: [2] ‘a’, ‘ii’
[17:02:52.362] Resolving futures part of globals (recursively) ... DONE
[17:02:52.362] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:52.363] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:52.363] - globals: [2] ‘a’, ‘ii’
[17:02:52.363] 
[17:02:52.363] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.364] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.364] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.366] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.366] Searching for globals ... DONE
[17:02:52.366] Resolving globals: TRUE
[17:02:52.366] Resolving any globals that are futures ...
[17:02:52.366] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:52.367] Resolving any globals that are futures ... DONE
[17:02:52.367] Resolving futures part of globals (recursively) ...
[17:02:52.367] resolve() on list ...
[17:02:52.367]  recursive: 99
[17:02:52.367]  length: 2
[17:02:52.367]  elements: ‘a’, ‘ii’
[17:02:52.368]  length: 1 (resolved future 1)
[17:02:52.368]  length: 0 (resolved future 2)
[17:02:52.368] resolve() on list ... DONE
[17:02:52.368] - globals: [2] ‘a’, ‘ii’
[17:02:52.368] Resolving futures part of globals (recursively) ... DONE
[17:02:52.368] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:52.369] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:52.369] - globals: [2] ‘a’, ‘ii’
[17:02:52.369] 
[17:02:52.369] getGlobalsAndPackages() ... DONE
[17:02:52.369] run() for ‘Future’ ...
[17:02:52.369] - state: ‘created’
[17:02:52.370] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.374] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.374]   - Field: ‘label’
[17:02:52.374]   - Field: ‘local’
[17:02:52.374]   - Field: ‘owner’
[17:02:52.374]   - Field: ‘envir’
[17:02:52.376]   - Field: ‘workers’
[17:02:52.376]   - Field: ‘packages’
[17:02:52.377]   - Field: ‘gc’
[17:02:52.377]   - Field: ‘job’
[17:02:52.377]   - Field: ‘conditions’
[17:02:52.377]   - Field: ‘expr’
[17:02:52.377]   - Field: ‘uuid’
[17:02:52.377]   - Field: ‘seed’
[17:02:52.377]   - Field: ‘version’
[17:02:52.377]   - Field: ‘result’
[17:02:52.377]   - Field: ‘asynchronous’
[17:02:52.378]   - Field: ‘calls’
[17:02:52.378]   - Field: ‘globals’
[17:02:52.378]   - Field: ‘stdout’
[17:02:52.378]   - Field: ‘earlySignal’
[17:02:52.378]   - Field: ‘lazy’
[17:02:52.378]   - Field: ‘state’
[17:02:52.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.378] - Launch lazy future ...
[17:02:52.379] Packages needed by the future expression (n = 0): <none>
[17:02:52.379] Packages needed by future strategies (n = 0): <none>
[17:02:52.379] {
[17:02:52.379]     {
[17:02:52.379]         {
[17:02:52.379]             ...future.startTime <- base::Sys.time()
[17:02:52.379]             {
[17:02:52.379]                 {
[17:02:52.379]                   {
[17:02:52.379]                     {
[17:02:52.379]                       base::local({
[17:02:52.379]                         has_future <- base::requireNamespace("future", 
[17:02:52.379]                           quietly = TRUE)
[17:02:52.379]                         if (has_future) {
[17:02:52.379]                           ns <- base::getNamespace("future")
[17:02:52.379]                           version <- ns[[".package"]][["version"]]
[17:02:52.379]                           if (is.null(version)) 
[17:02:52.379]                             version <- utils::packageVersion("future")
[17:02:52.379]                         }
[17:02:52.379]                         else {
[17:02:52.379]                           version <- NULL
[17:02:52.379]                         }
[17:02:52.379]                         if (!has_future || version < "1.8.0") {
[17:02:52.379]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.379]                             "", base::R.version$version.string), 
[17:02:52.379]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.379]                               "release", "version")], collapse = " "), 
[17:02:52.379]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.379]                             info)
[17:02:52.379]                           info <- base::paste(info, collapse = "; ")
[17:02:52.379]                           if (!has_future) {
[17:02:52.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.379]                               info)
[17:02:52.379]                           }
[17:02:52.379]                           else {
[17:02:52.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.379]                               info, version)
[17:02:52.379]                           }
[17:02:52.379]                           base::stop(msg)
[17:02:52.379]                         }
[17:02:52.379]                       })
[17:02:52.379]                     }
[17:02:52.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.379]                     base::options(mc.cores = 1L)
[17:02:52.379]                   }
[17:02:52.379]                   ...future.strategy.old <- future::plan("list")
[17:02:52.379]                   options(future.plan = NULL)
[17:02:52.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.379]                 }
[17:02:52.379]                 ...future.workdir <- getwd()
[17:02:52.379]             }
[17:02:52.379]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.379]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.379]         }
[17:02:52.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.379]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.379]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.379]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.379]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.379]             base::names(...future.oldOptions))
[17:02:52.379]     }
[17:02:52.379]     if (FALSE) {
[17:02:52.379]     }
[17:02:52.379]     else {
[17:02:52.379]         if (TRUE) {
[17:02:52.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.379]                 open = "w")
[17:02:52.379]         }
[17:02:52.379]         else {
[17:02:52.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.379]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.379]         }
[17:02:52.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.379]             base::sink(type = "output", split = FALSE)
[17:02:52.379]             base::close(...future.stdout)
[17:02:52.379]         }, add = TRUE)
[17:02:52.379]     }
[17:02:52.379]     ...future.frame <- base::sys.nframe()
[17:02:52.379]     ...future.conditions <- base::list()
[17:02:52.379]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.379]     if (FALSE) {
[17:02:52.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.379]     }
[17:02:52.379]     ...future.result <- base::tryCatch({
[17:02:52.379]         base::withCallingHandlers({
[17:02:52.379]             ...future.value <- base::withVisible(base::local({
[17:02:52.379]                 withCallingHandlers({
[17:02:52.379]                   {
[17:02:52.379]                     b <- a * ii
[17:02:52.379]                     a <- 0
[17:02:52.379]                     b
[17:02:52.379]                   }
[17:02:52.379]                 }, immediateCondition = function(cond) {
[17:02:52.379]                   save_rds <- function (object, pathname, ...) 
[17:02:52.379]                   {
[17:02:52.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.379]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.379]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.379]                         fi_tmp[["mtime"]])
[17:02:52.379]                     }
[17:02:52.379]                     tryCatch({
[17:02:52.379]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.379]                     }, error = function(ex) {
[17:02:52.379]                       msg <- conditionMessage(ex)
[17:02:52.379]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.379]                         fi_tmp[["mtime"]], msg)
[17:02:52.379]                       ex$message <- msg
[17:02:52.379]                       stop(ex)
[17:02:52.379]                     })
[17:02:52.379]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.379]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.379]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.379]                       fi <- file.info(pathname)
[17:02:52.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.379]                         fi[["size"]], fi[["mtime"]])
[17:02:52.379]                       stop(msg)
[17:02:52.379]                     }
[17:02:52.379]                     invisible(pathname)
[17:02:52.379]                   }
[17:02:52.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.379]                     rootPath = tempdir()) 
[17:02:52.379]                   {
[17:02:52.379]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.379]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.379]                       tmpdir = path, fileext = ".rds")
[17:02:52.379]                     save_rds(obj, file)
[17:02:52.379]                   }
[17:02:52.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.379]                   {
[17:02:52.379]                     inherits <- base::inherits
[17:02:52.379]                     invokeRestart <- base::invokeRestart
[17:02:52.379]                     is.null <- base::is.null
[17:02:52.379]                     muffled <- FALSE
[17:02:52.379]                     if (inherits(cond, "message")) {
[17:02:52.379]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.379]                       if (muffled) 
[17:02:52.379]                         invokeRestart("muffleMessage")
[17:02:52.379]                     }
[17:02:52.379]                     else if (inherits(cond, "warning")) {
[17:02:52.379]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.379]                       if (muffled) 
[17:02:52.379]                         invokeRestart("muffleWarning")
[17:02:52.379]                     }
[17:02:52.379]                     else if (inherits(cond, "condition")) {
[17:02:52.379]                       if (!is.null(pattern)) {
[17:02:52.379]                         computeRestarts <- base::computeRestarts
[17:02:52.379]                         grepl <- base::grepl
[17:02:52.379]                         restarts <- computeRestarts(cond)
[17:02:52.379]                         for (restart in restarts) {
[17:02:52.379]                           name <- restart$name
[17:02:52.379]                           if (is.null(name)) 
[17:02:52.379]                             next
[17:02:52.379]                           if (!grepl(pattern, name)) 
[17:02:52.379]                             next
[17:02:52.379]                           invokeRestart(restart)
[17:02:52.379]                           muffled <- TRUE
[17:02:52.379]                           break
[17:02:52.379]                         }
[17:02:52.379]                       }
[17:02:52.379]                     }
[17:02:52.379]                     invisible(muffled)
[17:02:52.379]                   }
[17:02:52.379]                   muffleCondition(cond)
[17:02:52.379]                 })
[17:02:52.379]             }))
[17:02:52.379]             future::FutureResult(value = ...future.value$value, 
[17:02:52.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.379]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.379]                     ...future.globalenv.names))
[17:02:52.379]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.379]         }, condition = base::local({
[17:02:52.379]             c <- base::c
[17:02:52.379]             inherits <- base::inherits
[17:02:52.379]             invokeRestart <- base::invokeRestart
[17:02:52.379]             length <- base::length
[17:02:52.379]             list <- base::list
[17:02:52.379]             seq.int <- base::seq.int
[17:02:52.379]             signalCondition <- base::signalCondition
[17:02:52.379]             sys.calls <- base::sys.calls
[17:02:52.379]             `[[` <- base::`[[`
[17:02:52.379]             `+` <- base::`+`
[17:02:52.379]             `<<-` <- base::`<<-`
[17:02:52.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.379]                   3L)]
[17:02:52.379]             }
[17:02:52.379]             function(cond) {
[17:02:52.379]                 is_error <- inherits(cond, "error")
[17:02:52.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.379]                   NULL)
[17:02:52.379]                 if (is_error) {
[17:02:52.379]                   sessionInformation <- function() {
[17:02:52.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.379]                       search = base::search(), system = base::Sys.info())
[17:02:52.379]                   }
[17:02:52.379]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.379]                     cond$call), session = sessionInformation(), 
[17:02:52.379]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.379]                   signalCondition(cond)
[17:02:52.379]                 }
[17:02:52.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.379]                 "immediateCondition"))) {
[17:02:52.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.379]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.379]                   if (TRUE && !signal) {
[17:02:52.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.379]                     {
[17:02:52.379]                       inherits <- base::inherits
[17:02:52.379]                       invokeRestart <- base::invokeRestart
[17:02:52.379]                       is.null <- base::is.null
[17:02:52.379]                       muffled <- FALSE
[17:02:52.379]                       if (inherits(cond, "message")) {
[17:02:52.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.379]                         if (muffled) 
[17:02:52.379]                           invokeRestart("muffleMessage")
[17:02:52.379]                       }
[17:02:52.379]                       else if (inherits(cond, "warning")) {
[17:02:52.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.379]                         if (muffled) 
[17:02:52.379]                           invokeRestart("muffleWarning")
[17:02:52.379]                       }
[17:02:52.379]                       else if (inherits(cond, "condition")) {
[17:02:52.379]                         if (!is.null(pattern)) {
[17:02:52.379]                           computeRestarts <- base::computeRestarts
[17:02:52.379]                           grepl <- base::grepl
[17:02:52.379]                           restarts <- computeRestarts(cond)
[17:02:52.379]                           for (restart in restarts) {
[17:02:52.379]                             name <- restart$name
[17:02:52.379]                             if (is.null(name)) 
[17:02:52.379]                               next
[17:02:52.379]                             if (!grepl(pattern, name)) 
[17:02:52.379]                               next
[17:02:52.379]                             invokeRestart(restart)
[17:02:52.379]                             muffled <- TRUE
[17:02:52.379]                             break
[17:02:52.379]                           }
[17:02:52.379]                         }
[17:02:52.379]                       }
[17:02:52.379]                       invisible(muffled)
[17:02:52.379]                     }
[17:02:52.379]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.379]                   }
[17:02:52.379]                 }
[17:02:52.379]                 else {
[17:02:52.379]                   if (TRUE) {
[17:02:52.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.379]                     {
[17:02:52.379]                       inherits <- base::inherits
[17:02:52.379]                       invokeRestart <- base::invokeRestart
[17:02:52.379]                       is.null <- base::is.null
[17:02:52.379]                       muffled <- FALSE
[17:02:52.379]                       if (inherits(cond, "message")) {
[17:02:52.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.379]                         if (muffled) 
[17:02:52.379]                           invokeRestart("muffleMessage")
[17:02:52.379]                       }
[17:02:52.379]                       else if (inherits(cond, "warning")) {
[17:02:52.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.379]                         if (muffled) 
[17:02:52.379]                           invokeRestart("muffleWarning")
[17:02:52.379]                       }
[17:02:52.379]                       else if (inherits(cond, "condition")) {
[17:02:52.379]                         if (!is.null(pattern)) {
[17:02:52.379]                           computeRestarts <- base::computeRestarts
[17:02:52.379]                           grepl <- base::grepl
[17:02:52.379]                           restarts <- computeRestarts(cond)
[17:02:52.379]                           for (restart in restarts) {
[17:02:52.379]                             name <- restart$name
[17:02:52.379]                             if (is.null(name)) 
[17:02:52.379]                               next
[17:02:52.379]                             if (!grepl(pattern, name)) 
[17:02:52.379]                               next
[17:02:52.379]                             invokeRestart(restart)
[17:02:52.379]                             muffled <- TRUE
[17:02:52.379]                             break
[17:02:52.379]                           }
[17:02:52.379]                         }
[17:02:52.379]                       }
[17:02:52.379]                       invisible(muffled)
[17:02:52.379]                     }
[17:02:52.379]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.379]                   }
[17:02:52.379]                 }
[17:02:52.379]             }
[17:02:52.379]         }))
[17:02:52.379]     }, error = function(ex) {
[17:02:52.379]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.379]                 ...future.rng), started = ...future.startTime, 
[17:02:52.379]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.379]             version = "1.8"), class = "FutureResult")
[17:02:52.379]     }, finally = {
[17:02:52.379]         if (!identical(...future.workdir, getwd())) 
[17:02:52.379]             setwd(...future.workdir)
[17:02:52.379]         {
[17:02:52.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.379]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.379]             }
[17:02:52.379]             base::options(...future.oldOptions)
[17:02:52.379]             if (.Platform$OS.type == "windows") {
[17:02:52.379]                 old_names <- names(...future.oldEnvVars)
[17:02:52.379]                 envs <- base::Sys.getenv()
[17:02:52.379]                 names <- names(envs)
[17:02:52.379]                 common <- intersect(names, old_names)
[17:02:52.379]                 added <- setdiff(names, old_names)
[17:02:52.379]                 removed <- setdiff(old_names, names)
[17:02:52.379]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.379]                   envs[common]]
[17:02:52.379]                 NAMES <- toupper(changed)
[17:02:52.379]                 args <- list()
[17:02:52.379]                 for (kk in seq_along(NAMES)) {
[17:02:52.379]                   name <- changed[[kk]]
[17:02:52.379]                   NAME <- NAMES[[kk]]
[17:02:52.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.379]                     next
[17:02:52.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.379]                 }
[17:02:52.379]                 NAMES <- toupper(added)
[17:02:52.379]                 for (kk in seq_along(NAMES)) {
[17:02:52.379]                   name <- added[[kk]]
[17:02:52.379]                   NAME <- NAMES[[kk]]
[17:02:52.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.379]                     next
[17:02:52.379]                   args[[name]] <- ""
[17:02:52.379]                 }
[17:02:52.379]                 NAMES <- toupper(removed)
[17:02:52.379]                 for (kk in seq_along(NAMES)) {
[17:02:52.379]                   name <- removed[[kk]]
[17:02:52.379]                   NAME <- NAMES[[kk]]
[17:02:52.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.379]                     next
[17:02:52.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.379]                 }
[17:02:52.379]                 if (length(args) > 0) 
[17:02:52.379]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.379]             }
[17:02:52.379]             else {
[17:02:52.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.379]             }
[17:02:52.379]             {
[17:02:52.379]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.379]                   0L) {
[17:02:52.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.379]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.379]                   base::options(opts)
[17:02:52.379]                 }
[17:02:52.379]                 {
[17:02:52.379]                   {
[17:02:52.379]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.379]                     NULL
[17:02:52.379]                   }
[17:02:52.379]                   options(future.plan = NULL)
[17:02:52.379]                   if (is.na(NA_character_)) 
[17:02:52.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.379]                     .init = FALSE)
[17:02:52.379]                 }
[17:02:52.379]             }
[17:02:52.379]         }
[17:02:52.379]     })
[17:02:52.379]     if (TRUE) {
[17:02:52.379]         base::sink(type = "output", split = FALSE)
[17:02:52.379]         if (TRUE) {
[17:02:52.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.379]         }
[17:02:52.379]         else {
[17:02:52.379]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.379]         }
[17:02:52.379]         base::close(...future.stdout)
[17:02:52.379]         ...future.stdout <- NULL
[17:02:52.379]     }
[17:02:52.379]     ...future.result$conditions <- ...future.conditions
[17:02:52.379]     ...future.result$finished <- base::Sys.time()
[17:02:52.379]     ...future.result
[17:02:52.379] }
[17:02:52.382] assign_globals() ...
[17:02:52.382] List of 2
[17:02:52.382]  $ a : num 1
[17:02:52.382]  $ ii: int 1
[17:02:52.382]  - attr(*, "where")=List of 2
[17:02:52.382]   ..$ a :<environment: R_EmptyEnv> 
[17:02:52.382]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:52.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.382]  - attr(*, "resolved")= logi TRUE
[17:02:52.382]  - attr(*, "total_size")= num 112
[17:02:52.382]  - attr(*, "already-done")= logi TRUE
[17:02:52.386] - copied ‘a’ to environment
[17:02:52.386] - copied ‘ii’ to environment
[17:02:52.386] assign_globals() ... done
[17:02:52.386] requestCore(): workers = 2
[17:02:52.388] MulticoreFuture started
[17:02:52.389] - Launch lazy future ... done
[17:02:52.389] run() for ‘MulticoreFuture’ ... done
[17:02:52.389] plan(): Setting new future strategy stack:
[17:02:52.390] result() for MulticoreFuture ...
[17:02:52.390] List of future strategies:
[17:02:52.390] 1. sequential:
[17:02:52.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.390]    - tweaked: FALSE
[17:02:52.390]    - call: NULL
[17:02:52.391] plan(): nbrOfWorkers() = 1
[17:02:52.394] plan(): Setting new future strategy stack:
[17:02:52.394] List of future strategies:
[17:02:52.394] 1. multicore:
[17:02:52.394]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.394]    - tweaked: FALSE
[17:02:52.394]    - call: plan(strategy)
[17:02:52.400] plan(): nbrOfWorkers() = 2
[17:02:52.401] result() for MulticoreFuture ...
[17:02:52.401] result() for MulticoreFuture ... done
[17:02:52.401] result() for MulticoreFuture ... done
[17:02:52.401] result() for MulticoreFuture ...
[17:02:52.401] result() for MulticoreFuture ... done
[17:02:52.402] run() for ‘Future’ ...
[17:02:52.402] - state: ‘created’
[17:02:52.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.407]   - Field: ‘label’
[17:02:52.407]   - Field: ‘local’
[17:02:52.407]   - Field: ‘owner’
[17:02:52.407]   - Field: ‘envir’
[17:02:52.407]   - Field: ‘workers’
[17:02:52.407]   - Field: ‘packages’
[17:02:52.407]   - Field: ‘gc’
[17:02:52.408]   - Field: ‘job’
[17:02:52.408]   - Field: ‘conditions’
[17:02:52.408]   - Field: ‘expr’
[17:02:52.408]   - Field: ‘uuid’
[17:02:52.408]   - Field: ‘seed’
[17:02:52.408]   - Field: ‘version’
[17:02:52.408]   - Field: ‘result’
[17:02:52.408]   - Field: ‘asynchronous’
[17:02:52.409]   - Field: ‘calls’
[17:02:52.409]   - Field: ‘globals’
[17:02:52.409]   - Field: ‘stdout’
[17:02:52.409]   - Field: ‘earlySignal’
[17:02:52.409]   - Field: ‘lazy’
[17:02:52.409]   - Field: ‘state’
[17:02:52.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.409] - Launch lazy future ...
[17:02:52.410] Packages needed by the future expression (n = 0): <none>
[17:02:52.410] Packages needed by future strategies (n = 0): <none>
[17:02:52.410] {
[17:02:52.410]     {
[17:02:52.410]         {
[17:02:52.410]             ...future.startTime <- base::Sys.time()
[17:02:52.410]             {
[17:02:52.410]                 {
[17:02:52.410]                   {
[17:02:52.410]                     {
[17:02:52.410]                       base::local({
[17:02:52.410]                         has_future <- base::requireNamespace("future", 
[17:02:52.410]                           quietly = TRUE)
[17:02:52.410]                         if (has_future) {
[17:02:52.410]                           ns <- base::getNamespace("future")
[17:02:52.410]                           version <- ns[[".package"]][["version"]]
[17:02:52.410]                           if (is.null(version)) 
[17:02:52.410]                             version <- utils::packageVersion("future")
[17:02:52.410]                         }
[17:02:52.410]                         else {
[17:02:52.410]                           version <- NULL
[17:02:52.410]                         }
[17:02:52.410]                         if (!has_future || version < "1.8.0") {
[17:02:52.410]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.410]                             "", base::R.version$version.string), 
[17:02:52.410]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.410]                               "release", "version")], collapse = " "), 
[17:02:52.410]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.410]                             info)
[17:02:52.410]                           info <- base::paste(info, collapse = "; ")
[17:02:52.410]                           if (!has_future) {
[17:02:52.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.410]                               info)
[17:02:52.410]                           }
[17:02:52.410]                           else {
[17:02:52.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.410]                               info, version)
[17:02:52.410]                           }
[17:02:52.410]                           base::stop(msg)
[17:02:52.410]                         }
[17:02:52.410]                       })
[17:02:52.410]                     }
[17:02:52.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.410]                     base::options(mc.cores = 1L)
[17:02:52.410]                   }
[17:02:52.410]                   ...future.strategy.old <- future::plan("list")
[17:02:52.410]                   options(future.plan = NULL)
[17:02:52.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.410]                 }
[17:02:52.410]                 ...future.workdir <- getwd()
[17:02:52.410]             }
[17:02:52.410]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.410]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.410]         }
[17:02:52.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.410]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.410]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.410]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.410]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.410]             base::names(...future.oldOptions))
[17:02:52.410]     }
[17:02:52.410]     if (FALSE) {
[17:02:52.410]     }
[17:02:52.410]     else {
[17:02:52.410]         if (TRUE) {
[17:02:52.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.410]                 open = "w")
[17:02:52.410]         }
[17:02:52.410]         else {
[17:02:52.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.410]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.410]         }
[17:02:52.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.410]             base::sink(type = "output", split = FALSE)
[17:02:52.410]             base::close(...future.stdout)
[17:02:52.410]         }, add = TRUE)
[17:02:52.410]     }
[17:02:52.410]     ...future.frame <- base::sys.nframe()
[17:02:52.410]     ...future.conditions <- base::list()
[17:02:52.410]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.410]     if (FALSE) {
[17:02:52.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.410]     }
[17:02:52.410]     ...future.result <- base::tryCatch({
[17:02:52.410]         base::withCallingHandlers({
[17:02:52.410]             ...future.value <- base::withVisible(base::local({
[17:02:52.410]                 withCallingHandlers({
[17:02:52.410]                   {
[17:02:52.410]                     b <- a * ii
[17:02:52.410]                     a <- 0
[17:02:52.410]                     b
[17:02:52.410]                   }
[17:02:52.410]                 }, immediateCondition = function(cond) {
[17:02:52.410]                   save_rds <- function (object, pathname, ...) 
[17:02:52.410]                   {
[17:02:52.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.410]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.410]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.410]                         fi_tmp[["mtime"]])
[17:02:52.410]                     }
[17:02:52.410]                     tryCatch({
[17:02:52.410]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.410]                     }, error = function(ex) {
[17:02:52.410]                       msg <- conditionMessage(ex)
[17:02:52.410]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.410]                         fi_tmp[["mtime"]], msg)
[17:02:52.410]                       ex$message <- msg
[17:02:52.410]                       stop(ex)
[17:02:52.410]                     })
[17:02:52.410]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.410]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.410]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.410]                       fi <- file.info(pathname)
[17:02:52.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.410]                         fi[["size"]], fi[["mtime"]])
[17:02:52.410]                       stop(msg)
[17:02:52.410]                     }
[17:02:52.410]                     invisible(pathname)
[17:02:52.410]                   }
[17:02:52.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.410]                     rootPath = tempdir()) 
[17:02:52.410]                   {
[17:02:52.410]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.410]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.410]                       tmpdir = path, fileext = ".rds")
[17:02:52.410]                     save_rds(obj, file)
[17:02:52.410]                   }
[17:02:52.410]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.410]                   {
[17:02:52.410]                     inherits <- base::inherits
[17:02:52.410]                     invokeRestart <- base::invokeRestart
[17:02:52.410]                     is.null <- base::is.null
[17:02:52.410]                     muffled <- FALSE
[17:02:52.410]                     if (inherits(cond, "message")) {
[17:02:52.410]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.410]                       if (muffled) 
[17:02:52.410]                         invokeRestart("muffleMessage")
[17:02:52.410]                     }
[17:02:52.410]                     else if (inherits(cond, "warning")) {
[17:02:52.410]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.410]                       if (muffled) 
[17:02:52.410]                         invokeRestart("muffleWarning")
[17:02:52.410]                     }
[17:02:52.410]                     else if (inherits(cond, "condition")) {
[17:02:52.410]                       if (!is.null(pattern)) {
[17:02:52.410]                         computeRestarts <- base::computeRestarts
[17:02:52.410]                         grepl <- base::grepl
[17:02:52.410]                         restarts <- computeRestarts(cond)
[17:02:52.410]                         for (restart in restarts) {
[17:02:52.410]                           name <- restart$name
[17:02:52.410]                           if (is.null(name)) 
[17:02:52.410]                             next
[17:02:52.410]                           if (!grepl(pattern, name)) 
[17:02:52.410]                             next
[17:02:52.410]                           invokeRestart(restart)
[17:02:52.410]                           muffled <- TRUE
[17:02:52.410]                           break
[17:02:52.410]                         }
[17:02:52.410]                       }
[17:02:52.410]                     }
[17:02:52.410]                     invisible(muffled)
[17:02:52.410]                   }
[17:02:52.410]                   muffleCondition(cond)
[17:02:52.410]                 })
[17:02:52.410]             }))
[17:02:52.410]             future::FutureResult(value = ...future.value$value, 
[17:02:52.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.410]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.410]                     ...future.globalenv.names))
[17:02:52.410]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.410]         }, condition = base::local({
[17:02:52.410]             c <- base::c
[17:02:52.410]             inherits <- base::inherits
[17:02:52.410]             invokeRestart <- base::invokeRestart
[17:02:52.410]             length <- base::length
[17:02:52.410]             list <- base::list
[17:02:52.410]             seq.int <- base::seq.int
[17:02:52.410]             signalCondition <- base::signalCondition
[17:02:52.410]             sys.calls <- base::sys.calls
[17:02:52.410]             `[[` <- base::`[[`
[17:02:52.410]             `+` <- base::`+`
[17:02:52.410]             `<<-` <- base::`<<-`
[17:02:52.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.410]                   3L)]
[17:02:52.410]             }
[17:02:52.410]             function(cond) {
[17:02:52.410]                 is_error <- inherits(cond, "error")
[17:02:52.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.410]                   NULL)
[17:02:52.410]                 if (is_error) {
[17:02:52.410]                   sessionInformation <- function() {
[17:02:52.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.410]                       search = base::search(), system = base::Sys.info())
[17:02:52.410]                   }
[17:02:52.410]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.410]                     cond$call), session = sessionInformation(), 
[17:02:52.410]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.410]                   signalCondition(cond)
[17:02:52.410]                 }
[17:02:52.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.410]                 "immediateCondition"))) {
[17:02:52.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.410]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.410]                   if (TRUE && !signal) {
[17:02:52.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.410]                     {
[17:02:52.410]                       inherits <- base::inherits
[17:02:52.410]                       invokeRestart <- base::invokeRestart
[17:02:52.410]                       is.null <- base::is.null
[17:02:52.410]                       muffled <- FALSE
[17:02:52.410]                       if (inherits(cond, "message")) {
[17:02:52.410]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.410]                         if (muffled) 
[17:02:52.410]                           invokeRestart("muffleMessage")
[17:02:52.410]                       }
[17:02:52.410]                       else if (inherits(cond, "warning")) {
[17:02:52.410]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.410]                         if (muffled) 
[17:02:52.410]                           invokeRestart("muffleWarning")
[17:02:52.410]                       }
[17:02:52.410]                       else if (inherits(cond, "condition")) {
[17:02:52.410]                         if (!is.null(pattern)) {
[17:02:52.410]                           computeRestarts <- base::computeRestarts
[17:02:52.410]                           grepl <- base::grepl
[17:02:52.410]                           restarts <- computeRestarts(cond)
[17:02:52.410]                           for (restart in restarts) {
[17:02:52.410]                             name <- restart$name
[17:02:52.410]                             if (is.null(name)) 
[17:02:52.410]                               next
[17:02:52.410]                             if (!grepl(pattern, name)) 
[17:02:52.410]                               next
[17:02:52.410]                             invokeRestart(restart)
[17:02:52.410]                             muffled <- TRUE
[17:02:52.410]                             break
[17:02:52.410]                           }
[17:02:52.410]                         }
[17:02:52.410]                       }
[17:02:52.410]                       invisible(muffled)
[17:02:52.410]                     }
[17:02:52.410]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.410]                   }
[17:02:52.410]                 }
[17:02:52.410]                 else {
[17:02:52.410]                   if (TRUE) {
[17:02:52.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.410]                     {
[17:02:52.410]                       inherits <- base::inherits
[17:02:52.410]                       invokeRestart <- base::invokeRestart
[17:02:52.410]                       is.null <- base::is.null
[17:02:52.410]                       muffled <- FALSE
[17:02:52.410]                       if (inherits(cond, "message")) {
[17:02:52.410]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.410]                         if (muffled) 
[17:02:52.410]                           invokeRestart("muffleMessage")
[17:02:52.410]                       }
[17:02:52.410]                       else if (inherits(cond, "warning")) {
[17:02:52.410]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.410]                         if (muffled) 
[17:02:52.410]                           invokeRestart("muffleWarning")
[17:02:52.410]                       }
[17:02:52.410]                       else if (inherits(cond, "condition")) {
[17:02:52.410]                         if (!is.null(pattern)) {
[17:02:52.410]                           computeRestarts <- base::computeRestarts
[17:02:52.410]                           grepl <- base::grepl
[17:02:52.410]                           restarts <- computeRestarts(cond)
[17:02:52.410]                           for (restart in restarts) {
[17:02:52.410]                             name <- restart$name
[17:02:52.410]                             if (is.null(name)) 
[17:02:52.410]                               next
[17:02:52.410]                             if (!grepl(pattern, name)) 
[17:02:52.410]                               next
[17:02:52.410]                             invokeRestart(restart)
[17:02:52.410]                             muffled <- TRUE
[17:02:52.410]                             break
[17:02:52.410]                           }
[17:02:52.410]                         }
[17:02:52.410]                       }
[17:02:52.410]                       invisible(muffled)
[17:02:52.410]                     }
[17:02:52.410]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.410]                   }
[17:02:52.410]                 }
[17:02:52.410]             }
[17:02:52.410]         }))
[17:02:52.410]     }, error = function(ex) {
[17:02:52.410]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.410]                 ...future.rng), started = ...future.startTime, 
[17:02:52.410]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.410]             version = "1.8"), class = "FutureResult")
[17:02:52.410]     }, finally = {
[17:02:52.410]         if (!identical(...future.workdir, getwd())) 
[17:02:52.410]             setwd(...future.workdir)
[17:02:52.410]         {
[17:02:52.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.410]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.410]             }
[17:02:52.410]             base::options(...future.oldOptions)
[17:02:52.410]             if (.Platform$OS.type == "windows") {
[17:02:52.410]                 old_names <- names(...future.oldEnvVars)
[17:02:52.410]                 envs <- base::Sys.getenv()
[17:02:52.410]                 names <- names(envs)
[17:02:52.410]                 common <- intersect(names, old_names)
[17:02:52.410]                 added <- setdiff(names, old_names)
[17:02:52.410]                 removed <- setdiff(old_names, names)
[17:02:52.410]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.410]                   envs[common]]
[17:02:52.410]                 NAMES <- toupper(changed)
[17:02:52.410]                 args <- list()
[17:02:52.410]                 for (kk in seq_along(NAMES)) {
[17:02:52.410]                   name <- changed[[kk]]
[17:02:52.410]                   NAME <- NAMES[[kk]]
[17:02:52.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.410]                     next
[17:02:52.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.410]                 }
[17:02:52.410]                 NAMES <- toupper(added)
[17:02:52.410]                 for (kk in seq_along(NAMES)) {
[17:02:52.410]                   name <- added[[kk]]
[17:02:52.410]                   NAME <- NAMES[[kk]]
[17:02:52.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.410]                     next
[17:02:52.410]                   args[[name]] <- ""
[17:02:52.410]                 }
[17:02:52.410]                 NAMES <- toupper(removed)
[17:02:52.410]                 for (kk in seq_along(NAMES)) {
[17:02:52.410]                   name <- removed[[kk]]
[17:02:52.410]                   NAME <- NAMES[[kk]]
[17:02:52.410]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.410]                     next
[17:02:52.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.410]                 }
[17:02:52.410]                 if (length(args) > 0) 
[17:02:52.410]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.410]             }
[17:02:52.410]             else {
[17:02:52.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.410]             }
[17:02:52.410]             {
[17:02:52.410]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.410]                   0L) {
[17:02:52.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.410]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.410]                   base::options(opts)
[17:02:52.410]                 }
[17:02:52.410]                 {
[17:02:52.410]                   {
[17:02:52.410]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.410]                     NULL
[17:02:52.410]                   }
[17:02:52.410]                   options(future.plan = NULL)
[17:02:52.410]                   if (is.na(NA_character_)) 
[17:02:52.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.410]                     .init = FALSE)
[17:02:52.410]                 }
[17:02:52.410]             }
[17:02:52.410]         }
[17:02:52.410]     })
[17:02:52.410]     if (TRUE) {
[17:02:52.410]         base::sink(type = "output", split = FALSE)
[17:02:52.410]         if (TRUE) {
[17:02:52.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.410]         }
[17:02:52.410]         else {
[17:02:52.410]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.410]         }
[17:02:52.410]         base::close(...future.stdout)
[17:02:52.410]         ...future.stdout <- NULL
[17:02:52.410]     }
[17:02:52.410]     ...future.result$conditions <- ...future.conditions
[17:02:52.410]     ...future.result$finished <- base::Sys.time()
[17:02:52.410]     ...future.result
[17:02:52.410] }
[17:02:52.413] assign_globals() ...
[17:02:52.413] List of 2
[17:02:52.413]  $ a : num 1
[17:02:52.413]  $ ii: int 2
[17:02:52.413]  - attr(*, "where")=List of 2
[17:02:52.413]   ..$ a :<environment: R_EmptyEnv> 
[17:02:52.413]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:52.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.413]  - attr(*, "resolved")= logi TRUE
[17:02:52.413]  - attr(*, "total_size")= num 112
[17:02:52.413]  - attr(*, "already-done")= logi TRUE
[17:02:52.417] - copied ‘a’ to environment
[17:02:52.417] - copied ‘ii’ to environment
[17:02:52.417] assign_globals() ... done
[17:02:52.418] requestCore(): workers = 2
[17:02:52.420] MulticoreFuture started
[17:02:52.420] - Launch lazy future ... done
[17:02:52.420] run() for ‘MulticoreFuture’ ... done
[17:02:52.420] result() for MulticoreFuture ...
[17:02:52.421] plan(): Setting new future strategy stack:
[17:02:52.421] List of future strategies:
[17:02:52.421] 1. sequential:
[17:02:52.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.421]    - tweaked: FALSE
[17:02:52.421]    - call: NULL
[17:02:52.422] plan(): nbrOfWorkers() = 1
[17:02:52.424] plan(): Setting new future strategy stack:
[17:02:52.425] List of future strategies:
[17:02:52.425] 1. multicore:
[17:02:52.425]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.425]    - tweaked: FALSE
[17:02:52.425]    - call: plan(strategy)
[17:02:52.430] plan(): nbrOfWorkers() = 2
[17:02:52.431] result() for MulticoreFuture ...
[17:02:52.431] result() for MulticoreFuture ... done
[17:02:52.431] result() for MulticoreFuture ... done
[17:02:52.431] result() for MulticoreFuture ...
[17:02:52.431] result() for MulticoreFuture ... done
[17:02:52.432] run() for ‘Future’ ...
[17:02:52.432] - state: ‘created’
[17:02:52.432] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.437]   - Field: ‘label’
[17:02:52.437]   - Field: ‘local’
[17:02:52.437]   - Field: ‘owner’
[17:02:52.437]   - Field: ‘envir’
[17:02:52.437]   - Field: ‘workers’
[17:02:52.437]   - Field: ‘packages’
[17:02:52.437]   - Field: ‘gc’
[17:02:52.438]   - Field: ‘job’
[17:02:52.438]   - Field: ‘conditions’
[17:02:52.438]   - Field: ‘expr’
[17:02:52.438]   - Field: ‘uuid’
[17:02:52.438]   - Field: ‘seed’
[17:02:52.438]   - Field: ‘version’
[17:02:52.438]   - Field: ‘result’
[17:02:52.438]   - Field: ‘asynchronous’
[17:02:52.438]   - Field: ‘calls’
[17:02:52.439]   - Field: ‘globals’
[17:02:52.439]   - Field: ‘stdout’
[17:02:52.439]   - Field: ‘earlySignal’
[17:02:52.439]   - Field: ‘lazy’
[17:02:52.439]   - Field: ‘state’
[17:02:52.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.439] - Launch lazy future ...
[17:02:52.440] Packages needed by the future expression (n = 0): <none>
[17:02:52.440] Packages needed by future strategies (n = 0): <none>
[17:02:52.440] {
[17:02:52.440]     {
[17:02:52.440]         {
[17:02:52.440]             ...future.startTime <- base::Sys.time()
[17:02:52.440]             {
[17:02:52.440]                 {
[17:02:52.440]                   {
[17:02:52.440]                     {
[17:02:52.440]                       base::local({
[17:02:52.440]                         has_future <- base::requireNamespace("future", 
[17:02:52.440]                           quietly = TRUE)
[17:02:52.440]                         if (has_future) {
[17:02:52.440]                           ns <- base::getNamespace("future")
[17:02:52.440]                           version <- ns[[".package"]][["version"]]
[17:02:52.440]                           if (is.null(version)) 
[17:02:52.440]                             version <- utils::packageVersion("future")
[17:02:52.440]                         }
[17:02:52.440]                         else {
[17:02:52.440]                           version <- NULL
[17:02:52.440]                         }
[17:02:52.440]                         if (!has_future || version < "1.8.0") {
[17:02:52.440]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.440]                             "", base::R.version$version.string), 
[17:02:52.440]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.440]                               "release", "version")], collapse = " "), 
[17:02:52.440]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.440]                             info)
[17:02:52.440]                           info <- base::paste(info, collapse = "; ")
[17:02:52.440]                           if (!has_future) {
[17:02:52.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.440]                               info)
[17:02:52.440]                           }
[17:02:52.440]                           else {
[17:02:52.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.440]                               info, version)
[17:02:52.440]                           }
[17:02:52.440]                           base::stop(msg)
[17:02:52.440]                         }
[17:02:52.440]                       })
[17:02:52.440]                     }
[17:02:52.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.440]                     base::options(mc.cores = 1L)
[17:02:52.440]                   }
[17:02:52.440]                   ...future.strategy.old <- future::plan("list")
[17:02:52.440]                   options(future.plan = NULL)
[17:02:52.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.440]                 }
[17:02:52.440]                 ...future.workdir <- getwd()
[17:02:52.440]             }
[17:02:52.440]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.440]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.440]         }
[17:02:52.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.440]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.440]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.440]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.440]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.440]             base::names(...future.oldOptions))
[17:02:52.440]     }
[17:02:52.440]     if (FALSE) {
[17:02:52.440]     }
[17:02:52.440]     else {
[17:02:52.440]         if (TRUE) {
[17:02:52.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.440]                 open = "w")
[17:02:52.440]         }
[17:02:52.440]         else {
[17:02:52.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.440]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.440]         }
[17:02:52.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.440]             base::sink(type = "output", split = FALSE)
[17:02:52.440]             base::close(...future.stdout)
[17:02:52.440]         }, add = TRUE)
[17:02:52.440]     }
[17:02:52.440]     ...future.frame <- base::sys.nframe()
[17:02:52.440]     ...future.conditions <- base::list()
[17:02:52.440]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.440]     if (FALSE) {
[17:02:52.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.440]     }
[17:02:52.440]     ...future.result <- base::tryCatch({
[17:02:52.440]         base::withCallingHandlers({
[17:02:52.440]             ...future.value <- base::withVisible(base::local({
[17:02:52.440]                 withCallingHandlers({
[17:02:52.440]                   {
[17:02:52.440]                     b <- a * ii
[17:02:52.440]                     a <- 0
[17:02:52.440]                     b
[17:02:52.440]                   }
[17:02:52.440]                 }, immediateCondition = function(cond) {
[17:02:52.440]                   save_rds <- function (object, pathname, ...) 
[17:02:52.440]                   {
[17:02:52.440]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.440]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.440]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.440]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.440]                         fi_tmp[["mtime"]])
[17:02:52.440]                     }
[17:02:52.440]                     tryCatch({
[17:02:52.440]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.440]                     }, error = function(ex) {
[17:02:52.440]                       msg <- conditionMessage(ex)
[17:02:52.440]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.440]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.440]                         fi_tmp[["mtime"]], msg)
[17:02:52.440]                       ex$message <- msg
[17:02:52.440]                       stop(ex)
[17:02:52.440]                     })
[17:02:52.440]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.440]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.440]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.440]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.440]                       fi <- file.info(pathname)
[17:02:52.440]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.440]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.440]                         fi[["size"]], fi[["mtime"]])
[17:02:52.440]                       stop(msg)
[17:02:52.440]                     }
[17:02:52.440]                     invisible(pathname)
[17:02:52.440]                   }
[17:02:52.440]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.440]                     rootPath = tempdir()) 
[17:02:52.440]                   {
[17:02:52.440]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.440]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.440]                       tmpdir = path, fileext = ".rds")
[17:02:52.440]                     save_rds(obj, file)
[17:02:52.440]                   }
[17:02:52.440]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.440]                   {
[17:02:52.440]                     inherits <- base::inherits
[17:02:52.440]                     invokeRestart <- base::invokeRestart
[17:02:52.440]                     is.null <- base::is.null
[17:02:52.440]                     muffled <- FALSE
[17:02:52.440]                     if (inherits(cond, "message")) {
[17:02:52.440]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.440]                       if (muffled) 
[17:02:52.440]                         invokeRestart("muffleMessage")
[17:02:52.440]                     }
[17:02:52.440]                     else if (inherits(cond, "warning")) {
[17:02:52.440]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.440]                       if (muffled) 
[17:02:52.440]                         invokeRestart("muffleWarning")
[17:02:52.440]                     }
[17:02:52.440]                     else if (inherits(cond, "condition")) {
[17:02:52.440]                       if (!is.null(pattern)) {
[17:02:52.440]                         computeRestarts <- base::computeRestarts
[17:02:52.440]                         grepl <- base::grepl
[17:02:52.440]                         restarts <- computeRestarts(cond)
[17:02:52.440]                         for (restart in restarts) {
[17:02:52.440]                           name <- restart$name
[17:02:52.440]                           if (is.null(name)) 
[17:02:52.440]                             next
[17:02:52.440]                           if (!grepl(pattern, name)) 
[17:02:52.440]                             next
[17:02:52.440]                           invokeRestart(restart)
[17:02:52.440]                           muffled <- TRUE
[17:02:52.440]                           break
[17:02:52.440]                         }
[17:02:52.440]                       }
[17:02:52.440]                     }
[17:02:52.440]                     invisible(muffled)
[17:02:52.440]                   }
[17:02:52.440]                   muffleCondition(cond)
[17:02:52.440]                 })
[17:02:52.440]             }))
[17:02:52.440]             future::FutureResult(value = ...future.value$value, 
[17:02:52.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.440]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.440]                     ...future.globalenv.names))
[17:02:52.440]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.440]         }, condition = base::local({
[17:02:52.440]             c <- base::c
[17:02:52.440]             inherits <- base::inherits
[17:02:52.440]             invokeRestart <- base::invokeRestart
[17:02:52.440]             length <- base::length
[17:02:52.440]             list <- base::list
[17:02:52.440]             seq.int <- base::seq.int
[17:02:52.440]             signalCondition <- base::signalCondition
[17:02:52.440]             sys.calls <- base::sys.calls
[17:02:52.440]             `[[` <- base::`[[`
[17:02:52.440]             `+` <- base::`+`
[17:02:52.440]             `<<-` <- base::`<<-`
[17:02:52.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.440]                   3L)]
[17:02:52.440]             }
[17:02:52.440]             function(cond) {
[17:02:52.440]                 is_error <- inherits(cond, "error")
[17:02:52.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.440]                   NULL)
[17:02:52.440]                 if (is_error) {
[17:02:52.440]                   sessionInformation <- function() {
[17:02:52.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.440]                       search = base::search(), system = base::Sys.info())
[17:02:52.440]                   }
[17:02:52.440]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.440]                     cond$call), session = sessionInformation(), 
[17:02:52.440]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.440]                   signalCondition(cond)
[17:02:52.440]                 }
[17:02:52.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.440]                 "immediateCondition"))) {
[17:02:52.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.440]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.440]                   if (TRUE && !signal) {
[17:02:52.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.440]                     {
[17:02:52.440]                       inherits <- base::inherits
[17:02:52.440]                       invokeRestart <- base::invokeRestart
[17:02:52.440]                       is.null <- base::is.null
[17:02:52.440]                       muffled <- FALSE
[17:02:52.440]                       if (inherits(cond, "message")) {
[17:02:52.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.440]                         if (muffled) 
[17:02:52.440]                           invokeRestart("muffleMessage")
[17:02:52.440]                       }
[17:02:52.440]                       else if (inherits(cond, "warning")) {
[17:02:52.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.440]                         if (muffled) 
[17:02:52.440]                           invokeRestart("muffleWarning")
[17:02:52.440]                       }
[17:02:52.440]                       else if (inherits(cond, "condition")) {
[17:02:52.440]                         if (!is.null(pattern)) {
[17:02:52.440]                           computeRestarts <- base::computeRestarts
[17:02:52.440]                           grepl <- base::grepl
[17:02:52.440]                           restarts <- computeRestarts(cond)
[17:02:52.440]                           for (restart in restarts) {
[17:02:52.440]                             name <- restart$name
[17:02:52.440]                             if (is.null(name)) 
[17:02:52.440]                               next
[17:02:52.440]                             if (!grepl(pattern, name)) 
[17:02:52.440]                               next
[17:02:52.440]                             invokeRestart(restart)
[17:02:52.440]                             muffled <- TRUE
[17:02:52.440]                             break
[17:02:52.440]                           }
[17:02:52.440]                         }
[17:02:52.440]                       }
[17:02:52.440]                       invisible(muffled)
[17:02:52.440]                     }
[17:02:52.440]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.440]                   }
[17:02:52.440]                 }
[17:02:52.440]                 else {
[17:02:52.440]                   if (TRUE) {
[17:02:52.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.440]                     {
[17:02:52.440]                       inherits <- base::inherits
[17:02:52.440]                       invokeRestart <- base::invokeRestart
[17:02:52.440]                       is.null <- base::is.null
[17:02:52.440]                       muffled <- FALSE
[17:02:52.440]                       if (inherits(cond, "message")) {
[17:02:52.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.440]                         if (muffled) 
[17:02:52.440]                           invokeRestart("muffleMessage")
[17:02:52.440]                       }
[17:02:52.440]                       else if (inherits(cond, "warning")) {
[17:02:52.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.440]                         if (muffled) 
[17:02:52.440]                           invokeRestart("muffleWarning")
[17:02:52.440]                       }
[17:02:52.440]                       else if (inherits(cond, "condition")) {
[17:02:52.440]                         if (!is.null(pattern)) {
[17:02:52.440]                           computeRestarts <- base::computeRestarts
[17:02:52.440]                           grepl <- base::grepl
[17:02:52.440]                           restarts <- computeRestarts(cond)
[17:02:52.440]                           for (restart in restarts) {
[17:02:52.440]                             name <- restart$name
[17:02:52.440]                             if (is.null(name)) 
[17:02:52.440]                               next
[17:02:52.440]                             if (!grepl(pattern, name)) 
[17:02:52.440]                               next
[17:02:52.440]                             invokeRestart(restart)
[17:02:52.440]                             muffled <- TRUE
[17:02:52.440]                             break
[17:02:52.440]                           }
[17:02:52.440]                         }
[17:02:52.440]                       }
[17:02:52.440]                       invisible(muffled)
[17:02:52.440]                     }
[17:02:52.440]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.440]                   }
[17:02:52.440]                 }
[17:02:52.440]             }
[17:02:52.440]         }))
[17:02:52.440]     }, error = function(ex) {
[17:02:52.440]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.440]                 ...future.rng), started = ...future.startTime, 
[17:02:52.440]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.440]             version = "1.8"), class = "FutureResult")
[17:02:52.440]     }, finally = {
[17:02:52.440]         if (!identical(...future.workdir, getwd())) 
[17:02:52.440]             setwd(...future.workdir)
[17:02:52.440]         {
[17:02:52.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.440]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.440]             }
[17:02:52.440]             base::options(...future.oldOptions)
[17:02:52.440]             if (.Platform$OS.type == "windows") {
[17:02:52.440]                 old_names <- names(...future.oldEnvVars)
[17:02:52.440]                 envs <- base::Sys.getenv()
[17:02:52.440]                 names <- names(envs)
[17:02:52.440]                 common <- intersect(names, old_names)
[17:02:52.440]                 added <- setdiff(names, old_names)
[17:02:52.440]                 removed <- setdiff(old_names, names)
[17:02:52.440]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.440]                   envs[common]]
[17:02:52.440]                 NAMES <- toupper(changed)
[17:02:52.440]                 args <- list()
[17:02:52.440]                 for (kk in seq_along(NAMES)) {
[17:02:52.440]                   name <- changed[[kk]]
[17:02:52.440]                   NAME <- NAMES[[kk]]
[17:02:52.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.440]                     next
[17:02:52.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.440]                 }
[17:02:52.440]                 NAMES <- toupper(added)
[17:02:52.440]                 for (kk in seq_along(NAMES)) {
[17:02:52.440]                   name <- added[[kk]]
[17:02:52.440]                   NAME <- NAMES[[kk]]
[17:02:52.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.440]                     next
[17:02:52.440]                   args[[name]] <- ""
[17:02:52.440]                 }
[17:02:52.440]                 NAMES <- toupper(removed)
[17:02:52.440]                 for (kk in seq_along(NAMES)) {
[17:02:52.440]                   name <- removed[[kk]]
[17:02:52.440]                   NAME <- NAMES[[kk]]
[17:02:52.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.440]                     next
[17:02:52.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.440]                 }
[17:02:52.440]                 if (length(args) > 0) 
[17:02:52.440]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.440]             }
[17:02:52.440]             else {
[17:02:52.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.440]             }
[17:02:52.440]             {
[17:02:52.440]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.440]                   0L) {
[17:02:52.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.440]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.440]                   base::options(opts)
[17:02:52.440]                 }
[17:02:52.440]                 {
[17:02:52.440]                   {
[17:02:52.440]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.440]                     NULL
[17:02:52.440]                   }
[17:02:52.440]                   options(future.plan = NULL)
[17:02:52.440]                   if (is.na(NA_character_)) 
[17:02:52.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.440]                     .init = FALSE)
[17:02:52.440]                 }
[17:02:52.440]             }
[17:02:52.440]         }
[17:02:52.440]     })
[17:02:52.440]     if (TRUE) {
[17:02:52.440]         base::sink(type = "output", split = FALSE)
[17:02:52.440]         if (TRUE) {
[17:02:52.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.440]         }
[17:02:52.440]         else {
[17:02:52.440]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.440]         }
[17:02:52.440]         base::close(...future.stdout)
[17:02:52.440]         ...future.stdout <- NULL
[17:02:52.440]     }
[17:02:52.440]     ...future.result$conditions <- ...future.conditions
[17:02:52.440]     ...future.result$finished <- base::Sys.time()
[17:02:52.440]     ...future.result
[17:02:52.440] }
[17:02:52.443] assign_globals() ...
[17:02:52.443] List of 2
[17:02:52.443]  $ a : num 1
[17:02:52.443]  $ ii: int 3
[17:02:52.443]  - attr(*, "where")=List of 2
[17:02:52.443]   ..$ a :<environment: R_EmptyEnv> 
[17:02:52.443]   ..$ ii:<environment: R_EmptyEnv> 
[17:02:52.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.443]  - attr(*, "resolved")= logi TRUE
[17:02:52.443]  - attr(*, "total_size")= num 112
[17:02:52.443]  - attr(*, "already-done")= logi TRUE
[17:02:52.450] - copied ‘a’ to environment
[17:02:52.450] - copied ‘ii’ to environment
[17:02:52.451] assign_globals() ... done
[17:02:52.451] requestCore(): workers = 2
[17:02:52.453] MulticoreFuture started
[17:02:52.453] - Launch lazy future ... done
[17:02:52.454] run() for ‘MulticoreFuture’ ... done
[17:02:52.454] plan(): Setting new future strategy stack:
[17:02:52.454] result() for MulticoreFuture ...
[17:02:52.454] List of future strategies:
[17:02:52.454] 1. sequential:
[17:02:52.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.454]    - tweaked: FALSE
[17:02:52.454]    - call: NULL
[17:02:52.456] plan(): nbrOfWorkers() = 1
[17:02:52.459] plan(): Setting new future strategy stack:
[17:02:52.459] List of future strategies:
[17:02:52.459] 1. multicore:
[17:02:52.459]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.459]    - tweaked: FALSE
[17:02:52.459]    - call: plan(strategy)
[17:02:52.467] plan(): nbrOfWorkers() = 2
[17:02:52.468] result() for MulticoreFuture ...
[17:02:52.468] result() for MulticoreFuture ... done
[17:02:52.468] result() for MulticoreFuture ... done
[17:02:52.469] result() for MulticoreFuture ...
[17:02:52.469] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.470] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.470] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.471] 
[17:02:52.471] Searching for globals ... DONE
[17:02:52.471] - globals: [0] <none>
[17:02:52.472] getGlobalsAndPackages() ... DONE
[17:02:52.472] run() for ‘Future’ ...
[17:02:52.472] - state: ‘created’
[17:02:52.472] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.477]   - Field: ‘label’
[17:02:52.477]   - Field: ‘local’
[17:02:52.477]   - Field: ‘owner’
[17:02:52.478]   - Field: ‘envir’
[17:02:52.478]   - Field: ‘workers’
[17:02:52.478]   - Field: ‘packages’
[17:02:52.478]   - Field: ‘gc’
[17:02:52.478]   - Field: ‘job’
[17:02:52.478]   - Field: ‘conditions’
[17:02:52.478]   - Field: ‘expr’
[17:02:52.478]   - Field: ‘uuid’
[17:02:52.479]   - Field: ‘seed’
[17:02:52.479]   - Field: ‘version’
[17:02:52.479]   - Field: ‘result’
[17:02:52.479]   - Field: ‘asynchronous’
[17:02:52.479]   - Field: ‘calls’
[17:02:52.479]   - Field: ‘globals’
[17:02:52.479]   - Field: ‘stdout’
[17:02:52.479]   - Field: ‘earlySignal’
[17:02:52.479]   - Field: ‘lazy’
[17:02:52.480]   - Field: ‘state’
[17:02:52.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.480] - Launch lazy future ...
[17:02:52.480] Packages needed by the future expression (n = 0): <none>
[17:02:52.480] Packages needed by future strategies (n = 0): <none>
[17:02:52.481] {
[17:02:52.481]     {
[17:02:52.481]         {
[17:02:52.481]             ...future.startTime <- base::Sys.time()
[17:02:52.481]             {
[17:02:52.481]                 {
[17:02:52.481]                   {
[17:02:52.481]                     {
[17:02:52.481]                       base::local({
[17:02:52.481]                         has_future <- base::requireNamespace("future", 
[17:02:52.481]                           quietly = TRUE)
[17:02:52.481]                         if (has_future) {
[17:02:52.481]                           ns <- base::getNamespace("future")
[17:02:52.481]                           version <- ns[[".package"]][["version"]]
[17:02:52.481]                           if (is.null(version)) 
[17:02:52.481]                             version <- utils::packageVersion("future")
[17:02:52.481]                         }
[17:02:52.481]                         else {
[17:02:52.481]                           version <- NULL
[17:02:52.481]                         }
[17:02:52.481]                         if (!has_future || version < "1.8.0") {
[17:02:52.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.481]                             "", base::R.version$version.string), 
[17:02:52.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.481]                               "release", "version")], collapse = " "), 
[17:02:52.481]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.481]                             info)
[17:02:52.481]                           info <- base::paste(info, collapse = "; ")
[17:02:52.481]                           if (!has_future) {
[17:02:52.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.481]                               info)
[17:02:52.481]                           }
[17:02:52.481]                           else {
[17:02:52.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.481]                               info, version)
[17:02:52.481]                           }
[17:02:52.481]                           base::stop(msg)
[17:02:52.481]                         }
[17:02:52.481]                       })
[17:02:52.481]                     }
[17:02:52.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.481]                     base::options(mc.cores = 1L)
[17:02:52.481]                   }
[17:02:52.481]                   ...future.strategy.old <- future::plan("list")
[17:02:52.481]                   options(future.plan = NULL)
[17:02:52.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.481]                 }
[17:02:52.481]                 ...future.workdir <- getwd()
[17:02:52.481]             }
[17:02:52.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.481]         }
[17:02:52.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.481]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.481]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.481]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.481]             base::names(...future.oldOptions))
[17:02:52.481]     }
[17:02:52.481]     if (FALSE) {
[17:02:52.481]     }
[17:02:52.481]     else {
[17:02:52.481]         if (TRUE) {
[17:02:52.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.481]                 open = "w")
[17:02:52.481]         }
[17:02:52.481]         else {
[17:02:52.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.481]         }
[17:02:52.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.481]             base::sink(type = "output", split = FALSE)
[17:02:52.481]             base::close(...future.stdout)
[17:02:52.481]         }, add = TRUE)
[17:02:52.481]     }
[17:02:52.481]     ...future.frame <- base::sys.nframe()
[17:02:52.481]     ...future.conditions <- base::list()
[17:02:52.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.481]     if (FALSE) {
[17:02:52.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.481]     }
[17:02:52.481]     ...future.result <- base::tryCatch({
[17:02:52.481]         base::withCallingHandlers({
[17:02:52.481]             ...future.value <- base::withVisible(base::local({
[17:02:52.481]                 withCallingHandlers({
[17:02:52.481]                   1
[17:02:52.481]                 }, immediateCondition = function(cond) {
[17:02:52.481]                   save_rds <- function (object, pathname, ...) 
[17:02:52.481]                   {
[17:02:52.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.481]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.481]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.481]                         fi_tmp[["mtime"]])
[17:02:52.481]                     }
[17:02:52.481]                     tryCatch({
[17:02:52.481]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.481]                     }, error = function(ex) {
[17:02:52.481]                       msg <- conditionMessage(ex)
[17:02:52.481]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.481]                         fi_tmp[["mtime"]], msg)
[17:02:52.481]                       ex$message <- msg
[17:02:52.481]                       stop(ex)
[17:02:52.481]                     })
[17:02:52.481]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.481]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.481]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.481]                       fi <- file.info(pathname)
[17:02:52.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.481]                         fi[["size"]], fi[["mtime"]])
[17:02:52.481]                       stop(msg)
[17:02:52.481]                     }
[17:02:52.481]                     invisible(pathname)
[17:02:52.481]                   }
[17:02:52.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.481]                     rootPath = tempdir()) 
[17:02:52.481]                   {
[17:02:52.481]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.481]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.481]                       tmpdir = path, fileext = ".rds")
[17:02:52.481]                     save_rds(obj, file)
[17:02:52.481]                   }
[17:02:52.481]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.481]                   {
[17:02:52.481]                     inherits <- base::inherits
[17:02:52.481]                     invokeRestart <- base::invokeRestart
[17:02:52.481]                     is.null <- base::is.null
[17:02:52.481]                     muffled <- FALSE
[17:02:52.481]                     if (inherits(cond, "message")) {
[17:02:52.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.481]                       if (muffled) 
[17:02:52.481]                         invokeRestart("muffleMessage")
[17:02:52.481]                     }
[17:02:52.481]                     else if (inherits(cond, "warning")) {
[17:02:52.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.481]                       if (muffled) 
[17:02:52.481]                         invokeRestart("muffleWarning")
[17:02:52.481]                     }
[17:02:52.481]                     else if (inherits(cond, "condition")) {
[17:02:52.481]                       if (!is.null(pattern)) {
[17:02:52.481]                         computeRestarts <- base::computeRestarts
[17:02:52.481]                         grepl <- base::grepl
[17:02:52.481]                         restarts <- computeRestarts(cond)
[17:02:52.481]                         for (restart in restarts) {
[17:02:52.481]                           name <- restart$name
[17:02:52.481]                           if (is.null(name)) 
[17:02:52.481]                             next
[17:02:52.481]                           if (!grepl(pattern, name)) 
[17:02:52.481]                             next
[17:02:52.481]                           invokeRestart(restart)
[17:02:52.481]                           muffled <- TRUE
[17:02:52.481]                           break
[17:02:52.481]                         }
[17:02:52.481]                       }
[17:02:52.481]                     }
[17:02:52.481]                     invisible(muffled)
[17:02:52.481]                   }
[17:02:52.481]                   muffleCondition(cond)
[17:02:52.481]                 })
[17:02:52.481]             }))
[17:02:52.481]             future::FutureResult(value = ...future.value$value, 
[17:02:52.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.481]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.481]                     ...future.globalenv.names))
[17:02:52.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.481]         }, condition = base::local({
[17:02:52.481]             c <- base::c
[17:02:52.481]             inherits <- base::inherits
[17:02:52.481]             invokeRestart <- base::invokeRestart
[17:02:52.481]             length <- base::length
[17:02:52.481]             list <- base::list
[17:02:52.481]             seq.int <- base::seq.int
[17:02:52.481]             signalCondition <- base::signalCondition
[17:02:52.481]             sys.calls <- base::sys.calls
[17:02:52.481]             `[[` <- base::`[[`
[17:02:52.481]             `+` <- base::`+`
[17:02:52.481]             `<<-` <- base::`<<-`
[17:02:52.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.481]                   3L)]
[17:02:52.481]             }
[17:02:52.481]             function(cond) {
[17:02:52.481]                 is_error <- inherits(cond, "error")
[17:02:52.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.481]                   NULL)
[17:02:52.481]                 if (is_error) {
[17:02:52.481]                   sessionInformation <- function() {
[17:02:52.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.481]                       search = base::search(), system = base::Sys.info())
[17:02:52.481]                   }
[17:02:52.481]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.481]                     cond$call), session = sessionInformation(), 
[17:02:52.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.481]                   signalCondition(cond)
[17:02:52.481]                 }
[17:02:52.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.481]                 "immediateCondition"))) {
[17:02:52.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.481]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.481]                   if (TRUE && !signal) {
[17:02:52.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.481]                     {
[17:02:52.481]                       inherits <- base::inherits
[17:02:52.481]                       invokeRestart <- base::invokeRestart
[17:02:52.481]                       is.null <- base::is.null
[17:02:52.481]                       muffled <- FALSE
[17:02:52.481]                       if (inherits(cond, "message")) {
[17:02:52.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.481]                         if (muffled) 
[17:02:52.481]                           invokeRestart("muffleMessage")
[17:02:52.481]                       }
[17:02:52.481]                       else if (inherits(cond, "warning")) {
[17:02:52.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.481]                         if (muffled) 
[17:02:52.481]                           invokeRestart("muffleWarning")
[17:02:52.481]                       }
[17:02:52.481]                       else if (inherits(cond, "condition")) {
[17:02:52.481]                         if (!is.null(pattern)) {
[17:02:52.481]                           computeRestarts <- base::computeRestarts
[17:02:52.481]                           grepl <- base::grepl
[17:02:52.481]                           restarts <- computeRestarts(cond)
[17:02:52.481]                           for (restart in restarts) {
[17:02:52.481]                             name <- restart$name
[17:02:52.481]                             if (is.null(name)) 
[17:02:52.481]                               next
[17:02:52.481]                             if (!grepl(pattern, name)) 
[17:02:52.481]                               next
[17:02:52.481]                             invokeRestart(restart)
[17:02:52.481]                             muffled <- TRUE
[17:02:52.481]                             break
[17:02:52.481]                           }
[17:02:52.481]                         }
[17:02:52.481]                       }
[17:02:52.481]                       invisible(muffled)
[17:02:52.481]                     }
[17:02:52.481]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.481]                   }
[17:02:52.481]                 }
[17:02:52.481]                 else {
[17:02:52.481]                   if (TRUE) {
[17:02:52.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.481]                     {
[17:02:52.481]                       inherits <- base::inherits
[17:02:52.481]                       invokeRestart <- base::invokeRestart
[17:02:52.481]                       is.null <- base::is.null
[17:02:52.481]                       muffled <- FALSE
[17:02:52.481]                       if (inherits(cond, "message")) {
[17:02:52.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.481]                         if (muffled) 
[17:02:52.481]                           invokeRestart("muffleMessage")
[17:02:52.481]                       }
[17:02:52.481]                       else if (inherits(cond, "warning")) {
[17:02:52.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.481]                         if (muffled) 
[17:02:52.481]                           invokeRestart("muffleWarning")
[17:02:52.481]                       }
[17:02:52.481]                       else if (inherits(cond, "condition")) {
[17:02:52.481]                         if (!is.null(pattern)) {
[17:02:52.481]                           computeRestarts <- base::computeRestarts
[17:02:52.481]                           grepl <- base::grepl
[17:02:52.481]                           restarts <- computeRestarts(cond)
[17:02:52.481]                           for (restart in restarts) {
[17:02:52.481]                             name <- restart$name
[17:02:52.481]                             if (is.null(name)) 
[17:02:52.481]                               next
[17:02:52.481]                             if (!grepl(pattern, name)) 
[17:02:52.481]                               next
[17:02:52.481]                             invokeRestart(restart)
[17:02:52.481]                             muffled <- TRUE
[17:02:52.481]                             break
[17:02:52.481]                           }
[17:02:52.481]                         }
[17:02:52.481]                       }
[17:02:52.481]                       invisible(muffled)
[17:02:52.481]                     }
[17:02:52.481]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.481]                   }
[17:02:52.481]                 }
[17:02:52.481]             }
[17:02:52.481]         }))
[17:02:52.481]     }, error = function(ex) {
[17:02:52.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.481]                 ...future.rng), started = ...future.startTime, 
[17:02:52.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.481]             version = "1.8"), class = "FutureResult")
[17:02:52.481]     }, finally = {
[17:02:52.481]         if (!identical(...future.workdir, getwd())) 
[17:02:52.481]             setwd(...future.workdir)
[17:02:52.481]         {
[17:02:52.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.481]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.481]             }
[17:02:52.481]             base::options(...future.oldOptions)
[17:02:52.481]             if (.Platform$OS.type == "windows") {
[17:02:52.481]                 old_names <- names(...future.oldEnvVars)
[17:02:52.481]                 envs <- base::Sys.getenv()
[17:02:52.481]                 names <- names(envs)
[17:02:52.481]                 common <- intersect(names, old_names)
[17:02:52.481]                 added <- setdiff(names, old_names)
[17:02:52.481]                 removed <- setdiff(old_names, names)
[17:02:52.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.481]                   envs[common]]
[17:02:52.481]                 NAMES <- toupper(changed)
[17:02:52.481]                 args <- list()
[17:02:52.481]                 for (kk in seq_along(NAMES)) {
[17:02:52.481]                   name <- changed[[kk]]
[17:02:52.481]                   NAME <- NAMES[[kk]]
[17:02:52.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.481]                     next
[17:02:52.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.481]                 }
[17:02:52.481]                 NAMES <- toupper(added)
[17:02:52.481]                 for (kk in seq_along(NAMES)) {
[17:02:52.481]                   name <- added[[kk]]
[17:02:52.481]                   NAME <- NAMES[[kk]]
[17:02:52.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.481]                     next
[17:02:52.481]                   args[[name]] <- ""
[17:02:52.481]                 }
[17:02:52.481]                 NAMES <- toupper(removed)
[17:02:52.481]                 for (kk in seq_along(NAMES)) {
[17:02:52.481]                   name <- removed[[kk]]
[17:02:52.481]                   NAME <- NAMES[[kk]]
[17:02:52.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.481]                     next
[17:02:52.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.481]                 }
[17:02:52.481]                 if (length(args) > 0) 
[17:02:52.481]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.481]             }
[17:02:52.481]             else {
[17:02:52.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.481]             }
[17:02:52.481]             {
[17:02:52.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.481]                   0L) {
[17:02:52.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.481]                   base::options(opts)
[17:02:52.481]                 }
[17:02:52.481]                 {
[17:02:52.481]                   {
[17:02:52.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.481]                     NULL
[17:02:52.481]                   }
[17:02:52.481]                   options(future.plan = NULL)
[17:02:52.481]                   if (is.na(NA_character_)) 
[17:02:52.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.481]                     .init = FALSE)
[17:02:52.481]                 }
[17:02:52.481]             }
[17:02:52.481]         }
[17:02:52.481]     })
[17:02:52.481]     if (TRUE) {
[17:02:52.481]         base::sink(type = "output", split = FALSE)
[17:02:52.481]         if (TRUE) {
[17:02:52.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.481]         }
[17:02:52.481]         else {
[17:02:52.481]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.481]         }
[17:02:52.481]         base::close(...future.stdout)
[17:02:52.481]         ...future.stdout <- NULL
[17:02:52.481]     }
[17:02:52.481]     ...future.result$conditions <- ...future.conditions
[17:02:52.481]     ...future.result$finished <- base::Sys.time()
[17:02:52.481]     ...future.result
[17:02:52.481] }
[17:02:52.484] requestCore(): workers = 2
[17:02:52.486] MulticoreFuture started
[17:02:52.486] - Launch lazy future ... done
[17:02:52.486] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.487] plan(): Setting new future strategy stack:
[17:02:52.487] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.487] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.487] List of future strategies:
[17:02:52.487] 1. sequential:
[17:02:52.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.487]    - tweaked: FALSE
[17:02:52.487]    - call: NULL
[17:02:52.488] plan(): nbrOfWorkers() = 1
[17:02:52.489] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:52.489] Searching for globals ... DONE
[17:02:52.490] Resolving globals: TRUE
[17:02:52.490] Resolving any globals that are futures ...
[17:02:52.490] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:52.490] Resolving any globals that are futures ... DONE
[17:02:52.490] plan(): Setting new future strategy stack:
[17:02:52.491] Resolving futures part of globals (recursively) ...
[17:02:52.490] List of future strategies:
[17:02:52.490] 1. multicore:
[17:02:52.490]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.490]    - tweaked: FALSE
[17:02:52.490]    - call: plan(strategy)
[17:02:52.491] resolve() on list ...
[17:02:52.491]  recursive: 99
[17:02:52.492]  length: 1
[17:02:52.492]  elements: ‘a’
[17:02:52.495] plan(): nbrOfWorkers() = 2
[17:02:52.496] Future #1
[17:02:52.496] result() for MulticoreFuture ...
[17:02:52.497] result() for MulticoreFuture ...
[17:02:52.497] result() for MulticoreFuture ... done
[17:02:52.497] result() for MulticoreFuture ... done
[17:02:52.498] result() for MulticoreFuture ...
[17:02:52.498] result() for MulticoreFuture ... done
[17:02:52.498] A MulticoreFuture was resolved
[17:02:52.498]  length: 0 (resolved future 1)
[17:02:52.498] resolve() on list ... DONE
[17:02:52.498] - globals: [1] ‘a’
[17:02:52.498] Resolving futures part of globals (recursively) ... DONE
[17:02:52.501] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[17:02:52.502] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:52.502] - globals: [1] ‘a’
[17:02:52.502] - packages: [1] ‘future’
[17:02:52.502] getGlobalsAndPackages() ... DONE
[17:02:52.502] run() for ‘Future’ ...
[17:02:52.503] - state: ‘created’
[17:02:52.503] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.507] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.508]   - Field: ‘label’
[17:02:52.508]   - Field: ‘local’
[17:02:52.508]   - Field: ‘owner’
[17:02:52.508]   - Field: ‘envir’
[17:02:52.508]   - Field: ‘workers’
[17:02:52.508]   - Field: ‘packages’
[17:02:52.508]   - Field: ‘gc’
[17:02:52.508]   - Field: ‘job’
[17:02:52.509]   - Field: ‘conditions’
[17:02:52.509]   - Field: ‘expr’
[17:02:52.509]   - Field: ‘uuid’
[17:02:52.509]   - Field: ‘seed’
[17:02:52.509]   - Field: ‘version’
[17:02:52.509]   - Field: ‘result’
[17:02:52.509]   - Field: ‘asynchronous’
[17:02:52.509]   - Field: ‘calls’
[17:02:52.509]   - Field: ‘globals’
[17:02:52.510]   - Field: ‘stdout’
[17:02:52.510]   - Field: ‘earlySignal’
[17:02:52.510]   - Field: ‘lazy’
[17:02:52.510]   - Field: ‘state’
[17:02:52.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.510] - Launch lazy future ...
[17:02:52.510] Packages needed by the future expression (n = 1): ‘future’
[17:02:52.511] Packages needed by future strategies (n = 0): <none>
[17:02:52.511] {
[17:02:52.511]     {
[17:02:52.511]         {
[17:02:52.511]             ...future.startTime <- base::Sys.time()
[17:02:52.511]             {
[17:02:52.511]                 {
[17:02:52.511]                   {
[17:02:52.511]                     {
[17:02:52.511]                       {
[17:02:52.511]                         base::local({
[17:02:52.511]                           has_future <- base::requireNamespace("future", 
[17:02:52.511]                             quietly = TRUE)
[17:02:52.511]                           if (has_future) {
[17:02:52.511]                             ns <- base::getNamespace("future")
[17:02:52.511]                             version <- ns[[".package"]][["version"]]
[17:02:52.511]                             if (is.null(version)) 
[17:02:52.511]                               version <- utils::packageVersion("future")
[17:02:52.511]                           }
[17:02:52.511]                           else {
[17:02:52.511]                             version <- NULL
[17:02:52.511]                           }
[17:02:52.511]                           if (!has_future || version < "1.8.0") {
[17:02:52.511]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.511]                               "", base::R.version$version.string), 
[17:02:52.511]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:52.511]                                 base::R.version$platform, 8 * 
[17:02:52.511]                                   base::.Machine$sizeof.pointer), 
[17:02:52.511]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.511]                                 "release", "version")], collapse = " "), 
[17:02:52.511]                               hostname = base::Sys.info()[["nodename"]])
[17:02:52.511]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.511]                               info)
[17:02:52.511]                             info <- base::paste(info, collapse = "; ")
[17:02:52.511]                             if (!has_future) {
[17:02:52.511]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.511]                                 info)
[17:02:52.511]                             }
[17:02:52.511]                             else {
[17:02:52.511]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.511]                                 info, version)
[17:02:52.511]                             }
[17:02:52.511]                             base::stop(msg)
[17:02:52.511]                           }
[17:02:52.511]                         })
[17:02:52.511]                       }
[17:02:52.511]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.511]                       base::options(mc.cores = 1L)
[17:02:52.511]                     }
[17:02:52.511]                     base::local({
[17:02:52.511]                       for (pkg in "future") {
[17:02:52.511]                         base::loadNamespace(pkg)
[17:02:52.511]                         base::library(pkg, character.only = TRUE)
[17:02:52.511]                       }
[17:02:52.511]                     })
[17:02:52.511]                   }
[17:02:52.511]                   ...future.strategy.old <- future::plan("list")
[17:02:52.511]                   options(future.plan = NULL)
[17:02:52.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.511]                 }
[17:02:52.511]                 ...future.workdir <- getwd()
[17:02:52.511]             }
[17:02:52.511]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.511]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.511]         }
[17:02:52.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.511]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.511]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.511]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.511]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.511]             base::names(...future.oldOptions))
[17:02:52.511]     }
[17:02:52.511]     if (FALSE) {
[17:02:52.511]     }
[17:02:52.511]     else {
[17:02:52.511]         if (TRUE) {
[17:02:52.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.511]                 open = "w")
[17:02:52.511]         }
[17:02:52.511]         else {
[17:02:52.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.511]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.511]         }
[17:02:52.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.511]             base::sink(type = "output", split = FALSE)
[17:02:52.511]             base::close(...future.stdout)
[17:02:52.511]         }, add = TRUE)
[17:02:52.511]     }
[17:02:52.511]     ...future.frame <- base::sys.nframe()
[17:02:52.511]     ...future.conditions <- base::list()
[17:02:52.511]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.511]     if (FALSE) {
[17:02:52.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.511]     }
[17:02:52.511]     ...future.result <- base::tryCatch({
[17:02:52.511]         base::withCallingHandlers({
[17:02:52.511]             ...future.value <- base::withVisible(base::local({
[17:02:52.511]                 withCallingHandlers({
[17:02:52.511]                   value(a) + 1
[17:02:52.511]                 }, immediateCondition = function(cond) {
[17:02:52.511]                   save_rds <- function (object, pathname, ...) 
[17:02:52.511]                   {
[17:02:52.511]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.511]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.511]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.511]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.511]                         fi_tmp[["mtime"]])
[17:02:52.511]                     }
[17:02:52.511]                     tryCatch({
[17:02:52.511]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.511]                     }, error = function(ex) {
[17:02:52.511]                       msg <- conditionMessage(ex)
[17:02:52.511]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.511]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.511]                         fi_tmp[["mtime"]], msg)
[17:02:52.511]                       ex$message <- msg
[17:02:52.511]                       stop(ex)
[17:02:52.511]                     })
[17:02:52.511]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.511]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.511]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.511]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.511]                       fi <- file.info(pathname)
[17:02:52.511]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.511]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.511]                         fi[["size"]], fi[["mtime"]])
[17:02:52.511]                       stop(msg)
[17:02:52.511]                     }
[17:02:52.511]                     invisible(pathname)
[17:02:52.511]                   }
[17:02:52.511]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.511]                     rootPath = tempdir()) 
[17:02:52.511]                   {
[17:02:52.511]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.511]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.511]                       tmpdir = path, fileext = ".rds")
[17:02:52.511]                     save_rds(obj, file)
[17:02:52.511]                   }
[17:02:52.511]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.511]                   {
[17:02:52.511]                     inherits <- base::inherits
[17:02:52.511]                     invokeRestart <- base::invokeRestart
[17:02:52.511]                     is.null <- base::is.null
[17:02:52.511]                     muffled <- FALSE
[17:02:52.511]                     if (inherits(cond, "message")) {
[17:02:52.511]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.511]                       if (muffled) 
[17:02:52.511]                         invokeRestart("muffleMessage")
[17:02:52.511]                     }
[17:02:52.511]                     else if (inherits(cond, "warning")) {
[17:02:52.511]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.511]                       if (muffled) 
[17:02:52.511]                         invokeRestart("muffleWarning")
[17:02:52.511]                     }
[17:02:52.511]                     else if (inherits(cond, "condition")) {
[17:02:52.511]                       if (!is.null(pattern)) {
[17:02:52.511]                         computeRestarts <- base::computeRestarts
[17:02:52.511]                         grepl <- base::grepl
[17:02:52.511]                         restarts <- computeRestarts(cond)
[17:02:52.511]                         for (restart in restarts) {
[17:02:52.511]                           name <- restart$name
[17:02:52.511]                           if (is.null(name)) 
[17:02:52.511]                             next
[17:02:52.511]                           if (!grepl(pattern, name)) 
[17:02:52.511]                             next
[17:02:52.511]                           invokeRestart(restart)
[17:02:52.511]                           muffled <- TRUE
[17:02:52.511]                           break
[17:02:52.511]                         }
[17:02:52.511]                       }
[17:02:52.511]                     }
[17:02:52.511]                     invisible(muffled)
[17:02:52.511]                   }
[17:02:52.511]                   muffleCondition(cond)
[17:02:52.511]                 })
[17:02:52.511]             }))
[17:02:52.511]             future::FutureResult(value = ...future.value$value, 
[17:02:52.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.511]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.511]                     ...future.globalenv.names))
[17:02:52.511]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.511]         }, condition = base::local({
[17:02:52.511]             c <- base::c
[17:02:52.511]             inherits <- base::inherits
[17:02:52.511]             invokeRestart <- base::invokeRestart
[17:02:52.511]             length <- base::length
[17:02:52.511]             list <- base::list
[17:02:52.511]             seq.int <- base::seq.int
[17:02:52.511]             signalCondition <- base::signalCondition
[17:02:52.511]             sys.calls <- base::sys.calls
[17:02:52.511]             `[[` <- base::`[[`
[17:02:52.511]             `+` <- base::`+`
[17:02:52.511]             `<<-` <- base::`<<-`
[17:02:52.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.511]                   3L)]
[17:02:52.511]             }
[17:02:52.511]             function(cond) {
[17:02:52.511]                 is_error <- inherits(cond, "error")
[17:02:52.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.511]                   NULL)
[17:02:52.511]                 if (is_error) {
[17:02:52.511]                   sessionInformation <- function() {
[17:02:52.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.511]                       search = base::search(), system = base::Sys.info())
[17:02:52.511]                   }
[17:02:52.511]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.511]                     cond$call), session = sessionInformation(), 
[17:02:52.511]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.511]                   signalCondition(cond)
[17:02:52.511]                 }
[17:02:52.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.511]                 "immediateCondition"))) {
[17:02:52.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.511]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.511]                   if (TRUE && !signal) {
[17:02:52.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.511]                     {
[17:02:52.511]                       inherits <- base::inherits
[17:02:52.511]                       invokeRestart <- base::invokeRestart
[17:02:52.511]                       is.null <- base::is.null
[17:02:52.511]                       muffled <- FALSE
[17:02:52.511]                       if (inherits(cond, "message")) {
[17:02:52.511]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.511]                         if (muffled) 
[17:02:52.511]                           invokeRestart("muffleMessage")
[17:02:52.511]                       }
[17:02:52.511]                       else if (inherits(cond, "warning")) {
[17:02:52.511]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.511]                         if (muffled) 
[17:02:52.511]                           invokeRestart("muffleWarning")
[17:02:52.511]                       }
[17:02:52.511]                       else if (inherits(cond, "condition")) {
[17:02:52.511]                         if (!is.null(pattern)) {
[17:02:52.511]                           computeRestarts <- base::computeRestarts
[17:02:52.511]                           grepl <- base::grepl
[17:02:52.511]                           restarts <- computeRestarts(cond)
[17:02:52.511]                           for (restart in restarts) {
[17:02:52.511]                             name <- restart$name
[17:02:52.511]                             if (is.null(name)) 
[17:02:52.511]                               next
[17:02:52.511]                             if (!grepl(pattern, name)) 
[17:02:52.511]                               next
[17:02:52.511]                             invokeRestart(restart)
[17:02:52.511]                             muffled <- TRUE
[17:02:52.511]                             break
[17:02:52.511]                           }
[17:02:52.511]                         }
[17:02:52.511]                       }
[17:02:52.511]                       invisible(muffled)
[17:02:52.511]                     }
[17:02:52.511]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.511]                   }
[17:02:52.511]                 }
[17:02:52.511]                 else {
[17:02:52.511]                   if (TRUE) {
[17:02:52.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.511]                     {
[17:02:52.511]                       inherits <- base::inherits
[17:02:52.511]                       invokeRestart <- base::invokeRestart
[17:02:52.511]                       is.null <- base::is.null
[17:02:52.511]                       muffled <- FALSE
[17:02:52.511]                       if (inherits(cond, "message")) {
[17:02:52.511]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.511]                         if (muffled) 
[17:02:52.511]                           invokeRestart("muffleMessage")
[17:02:52.511]                       }
[17:02:52.511]                       else if (inherits(cond, "warning")) {
[17:02:52.511]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.511]                         if (muffled) 
[17:02:52.511]                           invokeRestart("muffleWarning")
[17:02:52.511]                       }
[17:02:52.511]                       else if (inherits(cond, "condition")) {
[17:02:52.511]                         if (!is.null(pattern)) {
[17:02:52.511]                           computeRestarts <- base::computeRestarts
[17:02:52.511]                           grepl <- base::grepl
[17:02:52.511]                           restarts <- computeRestarts(cond)
[17:02:52.511]                           for (restart in restarts) {
[17:02:52.511]                             name <- restart$name
[17:02:52.511]                             if (is.null(name)) 
[17:02:52.511]                               next
[17:02:52.511]                             if (!grepl(pattern, name)) 
[17:02:52.511]                               next
[17:02:52.511]                             invokeRestart(restart)
[17:02:52.511]                             muffled <- TRUE
[17:02:52.511]                             break
[17:02:52.511]                           }
[17:02:52.511]                         }
[17:02:52.511]                       }
[17:02:52.511]                       invisible(muffled)
[17:02:52.511]                     }
[17:02:52.511]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.511]                   }
[17:02:52.511]                 }
[17:02:52.511]             }
[17:02:52.511]         }))
[17:02:52.511]     }, error = function(ex) {
[17:02:52.511]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.511]                 ...future.rng), started = ...future.startTime, 
[17:02:52.511]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.511]             version = "1.8"), class = "FutureResult")
[17:02:52.511]     }, finally = {
[17:02:52.511]         if (!identical(...future.workdir, getwd())) 
[17:02:52.511]             setwd(...future.workdir)
[17:02:52.511]         {
[17:02:52.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.511]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.511]             }
[17:02:52.511]             base::options(...future.oldOptions)
[17:02:52.511]             if (.Platform$OS.type == "windows") {
[17:02:52.511]                 old_names <- names(...future.oldEnvVars)
[17:02:52.511]                 envs <- base::Sys.getenv()
[17:02:52.511]                 names <- names(envs)
[17:02:52.511]                 common <- intersect(names, old_names)
[17:02:52.511]                 added <- setdiff(names, old_names)
[17:02:52.511]                 removed <- setdiff(old_names, names)
[17:02:52.511]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.511]                   envs[common]]
[17:02:52.511]                 NAMES <- toupper(changed)
[17:02:52.511]                 args <- list()
[17:02:52.511]                 for (kk in seq_along(NAMES)) {
[17:02:52.511]                   name <- changed[[kk]]
[17:02:52.511]                   NAME <- NAMES[[kk]]
[17:02:52.511]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.511]                     next
[17:02:52.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.511]                 }
[17:02:52.511]                 NAMES <- toupper(added)
[17:02:52.511]                 for (kk in seq_along(NAMES)) {
[17:02:52.511]                   name <- added[[kk]]
[17:02:52.511]                   NAME <- NAMES[[kk]]
[17:02:52.511]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.511]                     next
[17:02:52.511]                   args[[name]] <- ""
[17:02:52.511]                 }
[17:02:52.511]                 NAMES <- toupper(removed)
[17:02:52.511]                 for (kk in seq_along(NAMES)) {
[17:02:52.511]                   name <- removed[[kk]]
[17:02:52.511]                   NAME <- NAMES[[kk]]
[17:02:52.511]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.511]                     next
[17:02:52.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.511]                 }
[17:02:52.511]                 if (length(args) > 0) 
[17:02:52.511]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.511]             }
[17:02:52.511]             else {
[17:02:52.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.511]             }
[17:02:52.511]             {
[17:02:52.511]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.511]                   0L) {
[17:02:52.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.511]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.511]                   base::options(opts)
[17:02:52.511]                 }
[17:02:52.511]                 {
[17:02:52.511]                   {
[17:02:52.511]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.511]                     NULL
[17:02:52.511]                   }
[17:02:52.511]                   options(future.plan = NULL)
[17:02:52.511]                   if (is.na(NA_character_)) 
[17:02:52.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.511]                     .init = FALSE)
[17:02:52.511]                 }
[17:02:52.511]             }
[17:02:52.511]         }
[17:02:52.511]     })
[17:02:52.511]     if (TRUE) {
[17:02:52.511]         base::sink(type = "output", split = FALSE)
[17:02:52.511]         if (TRUE) {
[17:02:52.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.511]         }
[17:02:52.511]         else {
[17:02:52.511]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.511]         }
[17:02:52.511]         base::close(...future.stdout)
[17:02:52.511]         ...future.stdout <- NULL
[17:02:52.511]     }
[17:02:52.511]     ...future.result$conditions <- ...future.conditions
[17:02:52.511]     ...future.result$finished <- base::Sys.time()
[17:02:52.511]     ...future.result
[17:02:52.511] }
[17:02:52.516] assign_globals() ...
[17:02:52.517] List of 1
[17:02:52.517]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f6ec6968> 
[17:02:52.517]  - attr(*, "where")=List of 1
[17:02:52.517]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.517]  - attr(*, "resolved")= logi TRUE
[17:02:52.517]  - attr(*, "total_size")= num 1647480
[17:02:52.517]  - attr(*, "already-done")= logi TRUE
[17:02:52.520] - copied ‘a’ to environment
[17:02:52.520] assign_globals() ... done
[17:02:52.520] requestCore(): workers = 2
[17:02:52.522] MulticoreFuture started
[17:02:52.523] - Launch lazy future ... done
[17:02:52.523] run() for ‘MulticoreFuture’ ... done
[17:02:52.523] result() for MulticoreFuture ...
[17:02:52.524] plan(): Setting new future strategy stack:
[17:02:52.524] List of future strategies:
[17:02:52.524] 1. sequential:
[17:02:52.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.524]    - tweaked: FALSE
[17:02:52.524]    - call: NULL
[17:02:52.526] plan(): nbrOfWorkers() = 1
[17:02:52.531] plan(): Setting new future strategy stack:
[17:02:52.532] List of future strategies:
[17:02:52.532] 1. multicore:
[17:02:52.532]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.532]    - tweaked: FALSE
[17:02:52.532]    - call: plan(strategy)
[17:02:52.538] plan(): nbrOfWorkers() = 2
[17:02:52.539] result() for MulticoreFuture ...
[17:02:52.539] result() for MulticoreFuture ... done
[17:02:52.540] signalConditions() ...
[17:02:52.540]  - include = ‘immediateCondition’
[17:02:52.540]  - exclude = 
[17:02:52.540]  - resignal = FALSE
[17:02:52.541]  - Number of conditions: 4
[17:02:52.541] signalConditions() ... done
[17:02:52.541] result() for MulticoreFuture ... done
[17:02:52.541] result() for MulticoreFuture ...
[17:02:52.542] result() for MulticoreFuture ... done
[17:02:52.542] signalConditions() ...
[17:02:52.542]  - include = ‘immediateCondition’
[17:02:52.542]  - exclude = 
[17:02:52.543]  - resignal = FALSE
[17:02:52.543]  - Number of conditions: 4
[17:02:52.543] signalConditions() ... done
[17:02:52.543] Future state: ‘finished’
[17:02:52.543] result() for MulticoreFuture ...
[17:02:52.544] result() for MulticoreFuture ... done
[17:02:52.544] signalConditions() ...
[17:02:52.544]  - include = ‘condition’
[17:02:52.544]  - exclude = ‘immediateCondition’
[17:02:52.544]  - resignal = TRUE
[17:02:52.544]  - Number of conditions: 4
[17:02:52.544]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.528] result() for MulticoreFuture ...
[17:02:52.545]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.529] result() for MulticoreFuture ... done
[17:02:52.545]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.529] result() for MulticoreFuture ...
[17:02:52.545]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.529] result() for MulticoreFuture ... done
[17:02:52.545] signalConditions() ... done
value(b) = 2
[17:02:52.545] result() for MulticoreFuture ...
[17:02:52.546] result() for MulticoreFuture ... done
[17:02:52.546] result() for MulticoreFuture ...
[17:02:52.546] result() for MulticoreFuture ... done
[17:02:52.546] signalConditions() ...
[17:02:52.546]  - include = ‘immediateCondition’
[17:02:52.546]  - exclude = 
[17:02:52.546]  - resignal = FALSE
[17:02:52.546]  - Number of conditions: 4
[17:02:52.547] signalConditions() ... done
[17:02:52.547] Future state: ‘finished’
[17:02:52.547] result() for MulticoreFuture ...
[17:02:52.547] result() for MulticoreFuture ... done
[17:02:52.547] signalConditions() ...
[17:02:52.547]  - include = ‘condition’
[17:02:52.547]  - exclude = ‘immediateCondition’
[17:02:52.547]  - resignal = TRUE
[17:02:52.548]  - Number of conditions: 4
[17:02:52.548]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.528] result() for MulticoreFuture ...
[17:02:52.548]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.529] result() for MulticoreFuture ... done
[17:02:52.548]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.529] result() for MulticoreFuture ...
[17:02:52.548]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.529] result() for MulticoreFuture ... done
[17:02:52.548] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.549] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.549] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.549] 
[17:02:52.549] Searching for globals ... DONE
[17:02:52.550] - globals: [0] <none>
[17:02:52.550] getGlobalsAndPackages() ... DONE
[17:02:52.550] run() for ‘Future’ ...
[17:02:52.550] - state: ‘created’
[17:02:52.550] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.555]   - Field: ‘label’
[17:02:52.555]   - Field: ‘local’
[17:02:52.556]   - Field: ‘owner’
[17:02:52.556]   - Field: ‘envir’
[17:02:52.556]   - Field: ‘workers’
[17:02:52.556]   - Field: ‘packages’
[17:02:52.556]   - Field: ‘gc’
[17:02:52.556]   - Field: ‘job’
[17:02:52.556]   - Field: ‘conditions’
[17:02:52.556]   - Field: ‘expr’
[17:02:52.557]   - Field: ‘uuid’
[17:02:52.557]   - Field: ‘seed’
[17:02:52.557]   - Field: ‘version’
[17:02:52.557]   - Field: ‘result’
[17:02:52.557]   - Field: ‘asynchronous’
[17:02:52.557]   - Field: ‘calls’
[17:02:52.557]   - Field: ‘globals’
[17:02:52.557]   - Field: ‘stdout’
[17:02:52.557]   - Field: ‘earlySignal’
[17:02:52.558]   - Field: ‘lazy’
[17:02:52.558]   - Field: ‘state’
[17:02:52.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.558] - Launch lazy future ...
[17:02:52.558] Packages needed by the future expression (n = 0): <none>
[17:02:52.558] Packages needed by future strategies (n = 0): <none>
[17:02:52.559] {
[17:02:52.559]     {
[17:02:52.559]         {
[17:02:52.559]             ...future.startTime <- base::Sys.time()
[17:02:52.559]             {
[17:02:52.559]                 {
[17:02:52.559]                   {
[17:02:52.559]                     {
[17:02:52.559]                       base::local({
[17:02:52.559]                         has_future <- base::requireNamespace("future", 
[17:02:52.559]                           quietly = TRUE)
[17:02:52.559]                         if (has_future) {
[17:02:52.559]                           ns <- base::getNamespace("future")
[17:02:52.559]                           version <- ns[[".package"]][["version"]]
[17:02:52.559]                           if (is.null(version)) 
[17:02:52.559]                             version <- utils::packageVersion("future")
[17:02:52.559]                         }
[17:02:52.559]                         else {
[17:02:52.559]                           version <- NULL
[17:02:52.559]                         }
[17:02:52.559]                         if (!has_future || version < "1.8.0") {
[17:02:52.559]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.559]                             "", base::R.version$version.string), 
[17:02:52.559]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.559]                               "release", "version")], collapse = " "), 
[17:02:52.559]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.559]                             info)
[17:02:52.559]                           info <- base::paste(info, collapse = "; ")
[17:02:52.559]                           if (!has_future) {
[17:02:52.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.559]                               info)
[17:02:52.559]                           }
[17:02:52.559]                           else {
[17:02:52.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.559]                               info, version)
[17:02:52.559]                           }
[17:02:52.559]                           base::stop(msg)
[17:02:52.559]                         }
[17:02:52.559]                       })
[17:02:52.559]                     }
[17:02:52.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.559]                     base::options(mc.cores = 1L)
[17:02:52.559]                   }
[17:02:52.559]                   ...future.strategy.old <- future::plan("list")
[17:02:52.559]                   options(future.plan = NULL)
[17:02:52.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.559]                 }
[17:02:52.559]                 ...future.workdir <- getwd()
[17:02:52.559]             }
[17:02:52.559]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.559]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.559]         }
[17:02:52.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.559]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.559]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.559]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.559]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.559]             base::names(...future.oldOptions))
[17:02:52.559]     }
[17:02:52.559]     if (FALSE) {
[17:02:52.559]     }
[17:02:52.559]     else {
[17:02:52.559]         if (TRUE) {
[17:02:52.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.559]                 open = "w")
[17:02:52.559]         }
[17:02:52.559]         else {
[17:02:52.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.559]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.559]         }
[17:02:52.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.559]             base::sink(type = "output", split = FALSE)
[17:02:52.559]             base::close(...future.stdout)
[17:02:52.559]         }, add = TRUE)
[17:02:52.559]     }
[17:02:52.559]     ...future.frame <- base::sys.nframe()
[17:02:52.559]     ...future.conditions <- base::list()
[17:02:52.559]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.559]     if (FALSE) {
[17:02:52.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.559]     }
[17:02:52.559]     ...future.result <- base::tryCatch({
[17:02:52.559]         base::withCallingHandlers({
[17:02:52.559]             ...future.value <- base::withVisible(base::local({
[17:02:52.559]                 withCallingHandlers({
[17:02:52.559]                   1
[17:02:52.559]                 }, immediateCondition = function(cond) {
[17:02:52.559]                   save_rds <- function (object, pathname, ...) 
[17:02:52.559]                   {
[17:02:52.559]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.559]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.559]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.559]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.559]                         fi_tmp[["mtime"]])
[17:02:52.559]                     }
[17:02:52.559]                     tryCatch({
[17:02:52.559]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.559]                     }, error = function(ex) {
[17:02:52.559]                       msg <- conditionMessage(ex)
[17:02:52.559]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.559]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.559]                         fi_tmp[["mtime"]], msg)
[17:02:52.559]                       ex$message <- msg
[17:02:52.559]                       stop(ex)
[17:02:52.559]                     })
[17:02:52.559]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.559]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.559]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.559]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.559]                       fi <- file.info(pathname)
[17:02:52.559]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.559]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.559]                         fi[["size"]], fi[["mtime"]])
[17:02:52.559]                       stop(msg)
[17:02:52.559]                     }
[17:02:52.559]                     invisible(pathname)
[17:02:52.559]                   }
[17:02:52.559]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.559]                     rootPath = tempdir()) 
[17:02:52.559]                   {
[17:02:52.559]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.559]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.559]                       tmpdir = path, fileext = ".rds")
[17:02:52.559]                     save_rds(obj, file)
[17:02:52.559]                   }
[17:02:52.559]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.559]                   {
[17:02:52.559]                     inherits <- base::inherits
[17:02:52.559]                     invokeRestart <- base::invokeRestart
[17:02:52.559]                     is.null <- base::is.null
[17:02:52.559]                     muffled <- FALSE
[17:02:52.559]                     if (inherits(cond, "message")) {
[17:02:52.559]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.559]                       if (muffled) 
[17:02:52.559]                         invokeRestart("muffleMessage")
[17:02:52.559]                     }
[17:02:52.559]                     else if (inherits(cond, "warning")) {
[17:02:52.559]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.559]                       if (muffled) 
[17:02:52.559]                         invokeRestart("muffleWarning")
[17:02:52.559]                     }
[17:02:52.559]                     else if (inherits(cond, "condition")) {
[17:02:52.559]                       if (!is.null(pattern)) {
[17:02:52.559]                         computeRestarts <- base::computeRestarts
[17:02:52.559]                         grepl <- base::grepl
[17:02:52.559]                         restarts <- computeRestarts(cond)
[17:02:52.559]                         for (restart in restarts) {
[17:02:52.559]                           name <- restart$name
[17:02:52.559]                           if (is.null(name)) 
[17:02:52.559]                             next
[17:02:52.559]                           if (!grepl(pattern, name)) 
[17:02:52.559]                             next
[17:02:52.559]                           invokeRestart(restart)
[17:02:52.559]                           muffled <- TRUE
[17:02:52.559]                           break
[17:02:52.559]                         }
[17:02:52.559]                       }
[17:02:52.559]                     }
[17:02:52.559]                     invisible(muffled)
[17:02:52.559]                   }
[17:02:52.559]                   muffleCondition(cond)
[17:02:52.559]                 })
[17:02:52.559]             }))
[17:02:52.559]             future::FutureResult(value = ...future.value$value, 
[17:02:52.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.559]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.559]                     ...future.globalenv.names))
[17:02:52.559]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.559]         }, condition = base::local({
[17:02:52.559]             c <- base::c
[17:02:52.559]             inherits <- base::inherits
[17:02:52.559]             invokeRestart <- base::invokeRestart
[17:02:52.559]             length <- base::length
[17:02:52.559]             list <- base::list
[17:02:52.559]             seq.int <- base::seq.int
[17:02:52.559]             signalCondition <- base::signalCondition
[17:02:52.559]             sys.calls <- base::sys.calls
[17:02:52.559]             `[[` <- base::`[[`
[17:02:52.559]             `+` <- base::`+`
[17:02:52.559]             `<<-` <- base::`<<-`
[17:02:52.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.559]                   3L)]
[17:02:52.559]             }
[17:02:52.559]             function(cond) {
[17:02:52.559]                 is_error <- inherits(cond, "error")
[17:02:52.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.559]                   NULL)
[17:02:52.559]                 if (is_error) {
[17:02:52.559]                   sessionInformation <- function() {
[17:02:52.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.559]                       search = base::search(), system = base::Sys.info())
[17:02:52.559]                   }
[17:02:52.559]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.559]                     cond$call), session = sessionInformation(), 
[17:02:52.559]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.559]                   signalCondition(cond)
[17:02:52.559]                 }
[17:02:52.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.559]                 "immediateCondition"))) {
[17:02:52.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.559]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.559]                   if (TRUE && !signal) {
[17:02:52.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.559]                     {
[17:02:52.559]                       inherits <- base::inherits
[17:02:52.559]                       invokeRestart <- base::invokeRestart
[17:02:52.559]                       is.null <- base::is.null
[17:02:52.559]                       muffled <- FALSE
[17:02:52.559]                       if (inherits(cond, "message")) {
[17:02:52.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.559]                         if (muffled) 
[17:02:52.559]                           invokeRestart("muffleMessage")
[17:02:52.559]                       }
[17:02:52.559]                       else if (inherits(cond, "warning")) {
[17:02:52.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.559]                         if (muffled) 
[17:02:52.559]                           invokeRestart("muffleWarning")
[17:02:52.559]                       }
[17:02:52.559]                       else if (inherits(cond, "condition")) {
[17:02:52.559]                         if (!is.null(pattern)) {
[17:02:52.559]                           computeRestarts <- base::computeRestarts
[17:02:52.559]                           grepl <- base::grepl
[17:02:52.559]                           restarts <- computeRestarts(cond)
[17:02:52.559]                           for (restart in restarts) {
[17:02:52.559]                             name <- restart$name
[17:02:52.559]                             if (is.null(name)) 
[17:02:52.559]                               next
[17:02:52.559]                             if (!grepl(pattern, name)) 
[17:02:52.559]                               next
[17:02:52.559]                             invokeRestart(restart)
[17:02:52.559]                             muffled <- TRUE
[17:02:52.559]                             break
[17:02:52.559]                           }
[17:02:52.559]                         }
[17:02:52.559]                       }
[17:02:52.559]                       invisible(muffled)
[17:02:52.559]                     }
[17:02:52.559]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.559]                   }
[17:02:52.559]                 }
[17:02:52.559]                 else {
[17:02:52.559]                   if (TRUE) {
[17:02:52.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.559]                     {
[17:02:52.559]                       inherits <- base::inherits
[17:02:52.559]                       invokeRestart <- base::invokeRestart
[17:02:52.559]                       is.null <- base::is.null
[17:02:52.559]                       muffled <- FALSE
[17:02:52.559]                       if (inherits(cond, "message")) {
[17:02:52.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.559]                         if (muffled) 
[17:02:52.559]                           invokeRestart("muffleMessage")
[17:02:52.559]                       }
[17:02:52.559]                       else if (inherits(cond, "warning")) {
[17:02:52.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.559]                         if (muffled) 
[17:02:52.559]                           invokeRestart("muffleWarning")
[17:02:52.559]                       }
[17:02:52.559]                       else if (inherits(cond, "condition")) {
[17:02:52.559]                         if (!is.null(pattern)) {
[17:02:52.559]                           computeRestarts <- base::computeRestarts
[17:02:52.559]                           grepl <- base::grepl
[17:02:52.559]                           restarts <- computeRestarts(cond)
[17:02:52.559]                           for (restart in restarts) {
[17:02:52.559]                             name <- restart$name
[17:02:52.559]                             if (is.null(name)) 
[17:02:52.559]                               next
[17:02:52.559]                             if (!grepl(pattern, name)) 
[17:02:52.559]                               next
[17:02:52.559]                             invokeRestart(restart)
[17:02:52.559]                             muffled <- TRUE
[17:02:52.559]                             break
[17:02:52.559]                           }
[17:02:52.559]                         }
[17:02:52.559]                       }
[17:02:52.559]                       invisible(muffled)
[17:02:52.559]                     }
[17:02:52.559]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.559]                   }
[17:02:52.559]                 }
[17:02:52.559]             }
[17:02:52.559]         }))
[17:02:52.559]     }, error = function(ex) {
[17:02:52.559]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.559]                 ...future.rng), started = ...future.startTime, 
[17:02:52.559]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.559]             version = "1.8"), class = "FutureResult")
[17:02:52.559]     }, finally = {
[17:02:52.559]         if (!identical(...future.workdir, getwd())) 
[17:02:52.559]             setwd(...future.workdir)
[17:02:52.559]         {
[17:02:52.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.559]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.559]             }
[17:02:52.559]             base::options(...future.oldOptions)
[17:02:52.559]             if (.Platform$OS.type == "windows") {
[17:02:52.559]                 old_names <- names(...future.oldEnvVars)
[17:02:52.559]                 envs <- base::Sys.getenv()
[17:02:52.559]                 names <- names(envs)
[17:02:52.559]                 common <- intersect(names, old_names)
[17:02:52.559]                 added <- setdiff(names, old_names)
[17:02:52.559]                 removed <- setdiff(old_names, names)
[17:02:52.559]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.559]                   envs[common]]
[17:02:52.559]                 NAMES <- toupper(changed)
[17:02:52.559]                 args <- list()
[17:02:52.559]                 for (kk in seq_along(NAMES)) {
[17:02:52.559]                   name <- changed[[kk]]
[17:02:52.559]                   NAME <- NAMES[[kk]]
[17:02:52.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.559]                     next
[17:02:52.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.559]                 }
[17:02:52.559]                 NAMES <- toupper(added)
[17:02:52.559]                 for (kk in seq_along(NAMES)) {
[17:02:52.559]                   name <- added[[kk]]
[17:02:52.559]                   NAME <- NAMES[[kk]]
[17:02:52.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.559]                     next
[17:02:52.559]                   args[[name]] <- ""
[17:02:52.559]                 }
[17:02:52.559]                 NAMES <- toupper(removed)
[17:02:52.559]                 for (kk in seq_along(NAMES)) {
[17:02:52.559]                   name <- removed[[kk]]
[17:02:52.559]                   NAME <- NAMES[[kk]]
[17:02:52.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.559]                     next
[17:02:52.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.559]                 }
[17:02:52.559]                 if (length(args) > 0) 
[17:02:52.559]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.559]             }
[17:02:52.559]             else {
[17:02:52.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.559]             }
[17:02:52.559]             {
[17:02:52.559]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.559]                   0L) {
[17:02:52.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.559]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.559]                   base::options(opts)
[17:02:52.559]                 }
[17:02:52.559]                 {
[17:02:52.559]                   {
[17:02:52.559]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.559]                     NULL
[17:02:52.559]                   }
[17:02:52.559]                   options(future.plan = NULL)
[17:02:52.559]                   if (is.na(NA_character_)) 
[17:02:52.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.559]                     .init = FALSE)
[17:02:52.559]                 }
[17:02:52.559]             }
[17:02:52.559]         }
[17:02:52.559]     })
[17:02:52.559]     if (TRUE) {
[17:02:52.559]         base::sink(type = "output", split = FALSE)
[17:02:52.559]         if (TRUE) {
[17:02:52.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.559]         }
[17:02:52.559]         else {
[17:02:52.559]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.559]         }
[17:02:52.559]         base::close(...future.stdout)
[17:02:52.559]         ...future.stdout <- NULL
[17:02:52.559]     }
[17:02:52.559]     ...future.result$conditions <- ...future.conditions
[17:02:52.559]     ...future.result$finished <- base::Sys.time()
[17:02:52.559]     ...future.result
[17:02:52.559] }
[17:02:52.562] requestCore(): workers = 2
[17:02:52.564] MulticoreFuture started
[17:02:52.564] - Launch lazy future ... done
[17:02:52.564] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.565] getGlobalsAndPackages() ...
[17:02:52.565] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.565] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.565] List of future strategies:
[17:02:52.565] 1. sequential:
[17:02:52.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.565]    - tweaked: FALSE
[17:02:52.565]    - call: NULL
[17:02:52.566] plan(): nbrOfWorkers() = 1
[17:02:52.567] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:52.567] Searching for globals ... DONE
[17:02:52.568] Resolving globals: TRUE
[17:02:52.568] Resolving any globals that are futures ...
[17:02:52.568] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:52.568] Resolving any globals that are futures ... DONE
[17:02:52.568] plan(): Setting new future strategy stack:
[17:02:52.569] Resolving futures part of globals (recursively) ...
[17:02:52.569] List of future strategies:
[17:02:52.569] 1. multicore:
[17:02:52.569]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.569]    - tweaked: FALSE
[17:02:52.569]    - call: plan(strategy)
[17:02:52.569] resolve() on list ...
[17:02:52.570]  recursive: 99
[17:02:52.570]  length: 1
[17:02:52.570]  elements: ‘a’
[17:02:52.573] plan(): nbrOfWorkers() = 2
[17:02:52.574] Future #1
[17:02:52.574] result() for MulticoreFuture ...
[17:02:52.575] result() for MulticoreFuture ...
[17:02:52.575] result() for MulticoreFuture ... done
[17:02:52.576] result() for MulticoreFuture ... done
[17:02:52.576] result() for MulticoreFuture ...
[17:02:52.576] result() for MulticoreFuture ... done
[17:02:52.576] A MulticoreFuture was resolved
[17:02:52.576]  length: 0 (resolved future 1)
[17:02:52.576] resolve() on list ... DONE
[17:02:52.577] - globals: [1] ‘a’
[17:02:52.577] Resolving futures part of globals (recursively) ... DONE
[17:02:52.579] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[17:02:52.580] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:52.580] - globals: [1] ‘a’
[17:02:52.580] - packages: [1] ‘future’
[17:02:52.580] getGlobalsAndPackages() ... DONE
[17:02:52.584] run() for ‘Future’ ...
[17:02:52.584] - state: ‘created’
[17:02:52.584] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.589]   - Field: ‘label’
[17:02:52.589]   - Field: ‘local’
[17:02:52.589]   - Field: ‘owner’
[17:02:52.589]   - Field: ‘envir’
[17:02:52.590]   - Field: ‘workers’
[17:02:52.590]   - Field: ‘packages’
[17:02:52.590]   - Field: ‘gc’
[17:02:52.590]   - Field: ‘job’
[17:02:52.590]   - Field: ‘conditions’
[17:02:52.590]   - Field: ‘expr’
[17:02:52.590]   - Field: ‘uuid’
[17:02:52.590]   - Field: ‘seed’
[17:02:52.591]   - Field: ‘version’
[17:02:52.591]   - Field: ‘result’
[17:02:52.591]   - Field: ‘asynchronous’
[17:02:52.591]   - Field: ‘calls’
[17:02:52.591]   - Field: ‘globals’
[17:02:52.591]   - Field: ‘stdout’
[17:02:52.591]   - Field: ‘earlySignal’
[17:02:52.592]   - Field: ‘lazy’
[17:02:52.592]   - Field: ‘state’
[17:02:52.592] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.592] - Launch lazy future ...
[17:02:52.592] Packages needed by the future expression (n = 1): ‘future’
[17:02:52.593] Packages needed by future strategies (n = 0): <none>
[17:02:52.593] {
[17:02:52.593]     {
[17:02:52.593]         {
[17:02:52.593]             ...future.startTime <- base::Sys.time()
[17:02:52.593]             {
[17:02:52.593]                 {
[17:02:52.593]                   {
[17:02:52.593]                     {
[17:02:52.593]                       {
[17:02:52.593]                         base::local({
[17:02:52.593]                           has_future <- base::requireNamespace("future", 
[17:02:52.593]                             quietly = TRUE)
[17:02:52.593]                           if (has_future) {
[17:02:52.593]                             ns <- base::getNamespace("future")
[17:02:52.593]                             version <- ns[[".package"]][["version"]]
[17:02:52.593]                             if (is.null(version)) 
[17:02:52.593]                               version <- utils::packageVersion("future")
[17:02:52.593]                           }
[17:02:52.593]                           else {
[17:02:52.593]                             version <- NULL
[17:02:52.593]                           }
[17:02:52.593]                           if (!has_future || version < "1.8.0") {
[17:02:52.593]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.593]                               "", base::R.version$version.string), 
[17:02:52.593]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:52.593]                                 base::R.version$platform, 8 * 
[17:02:52.593]                                   base::.Machine$sizeof.pointer), 
[17:02:52.593]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.593]                                 "release", "version")], collapse = " "), 
[17:02:52.593]                               hostname = base::Sys.info()[["nodename"]])
[17:02:52.593]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.593]                               info)
[17:02:52.593]                             info <- base::paste(info, collapse = "; ")
[17:02:52.593]                             if (!has_future) {
[17:02:52.593]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.593]                                 info)
[17:02:52.593]                             }
[17:02:52.593]                             else {
[17:02:52.593]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.593]                                 info, version)
[17:02:52.593]                             }
[17:02:52.593]                             base::stop(msg)
[17:02:52.593]                           }
[17:02:52.593]                         })
[17:02:52.593]                       }
[17:02:52.593]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.593]                       base::options(mc.cores = 1L)
[17:02:52.593]                     }
[17:02:52.593]                     base::local({
[17:02:52.593]                       for (pkg in "future") {
[17:02:52.593]                         base::loadNamespace(pkg)
[17:02:52.593]                         base::library(pkg, character.only = TRUE)
[17:02:52.593]                       }
[17:02:52.593]                     })
[17:02:52.593]                   }
[17:02:52.593]                   ...future.strategy.old <- future::plan("list")
[17:02:52.593]                   options(future.plan = NULL)
[17:02:52.593]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.593]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.593]                 }
[17:02:52.593]                 ...future.workdir <- getwd()
[17:02:52.593]             }
[17:02:52.593]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.593]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.593]         }
[17:02:52.593]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.593]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.593]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.593]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.593]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.593]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.593]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.593]             base::names(...future.oldOptions))
[17:02:52.593]     }
[17:02:52.593]     if (FALSE) {
[17:02:52.593]     }
[17:02:52.593]     else {
[17:02:52.593]         if (TRUE) {
[17:02:52.593]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.593]                 open = "w")
[17:02:52.593]         }
[17:02:52.593]         else {
[17:02:52.593]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.593]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.593]         }
[17:02:52.593]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.593]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.593]             base::sink(type = "output", split = FALSE)
[17:02:52.593]             base::close(...future.stdout)
[17:02:52.593]         }, add = TRUE)
[17:02:52.593]     }
[17:02:52.593]     ...future.frame <- base::sys.nframe()
[17:02:52.593]     ...future.conditions <- base::list()
[17:02:52.593]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.593]     if (FALSE) {
[17:02:52.593]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.593]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.593]     }
[17:02:52.593]     ...future.result <- base::tryCatch({
[17:02:52.593]         base::withCallingHandlers({
[17:02:52.593]             ...future.value <- base::withVisible(base::local({
[17:02:52.593]                 withCallingHandlers({
[17:02:52.593]                   value(a) + 1
[17:02:52.593]                 }, immediateCondition = function(cond) {
[17:02:52.593]                   save_rds <- function (object, pathname, ...) 
[17:02:52.593]                   {
[17:02:52.593]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.593]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.593]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.593]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.593]                         fi_tmp[["mtime"]])
[17:02:52.593]                     }
[17:02:52.593]                     tryCatch({
[17:02:52.593]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.593]                     }, error = function(ex) {
[17:02:52.593]                       msg <- conditionMessage(ex)
[17:02:52.593]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.593]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.593]                         fi_tmp[["mtime"]], msg)
[17:02:52.593]                       ex$message <- msg
[17:02:52.593]                       stop(ex)
[17:02:52.593]                     })
[17:02:52.593]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.593]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.593]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.593]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.593]                       fi <- file.info(pathname)
[17:02:52.593]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.593]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.593]                         fi[["size"]], fi[["mtime"]])
[17:02:52.593]                       stop(msg)
[17:02:52.593]                     }
[17:02:52.593]                     invisible(pathname)
[17:02:52.593]                   }
[17:02:52.593]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.593]                     rootPath = tempdir()) 
[17:02:52.593]                   {
[17:02:52.593]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.593]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.593]                       tmpdir = path, fileext = ".rds")
[17:02:52.593]                     save_rds(obj, file)
[17:02:52.593]                   }
[17:02:52.593]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.593]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.593]                   {
[17:02:52.593]                     inherits <- base::inherits
[17:02:52.593]                     invokeRestart <- base::invokeRestart
[17:02:52.593]                     is.null <- base::is.null
[17:02:52.593]                     muffled <- FALSE
[17:02:52.593]                     if (inherits(cond, "message")) {
[17:02:52.593]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.593]                       if (muffled) 
[17:02:52.593]                         invokeRestart("muffleMessage")
[17:02:52.593]                     }
[17:02:52.593]                     else if (inherits(cond, "warning")) {
[17:02:52.593]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.593]                       if (muffled) 
[17:02:52.593]                         invokeRestart("muffleWarning")
[17:02:52.593]                     }
[17:02:52.593]                     else if (inherits(cond, "condition")) {
[17:02:52.593]                       if (!is.null(pattern)) {
[17:02:52.593]                         computeRestarts <- base::computeRestarts
[17:02:52.593]                         grepl <- base::grepl
[17:02:52.593]                         restarts <- computeRestarts(cond)
[17:02:52.593]                         for (restart in restarts) {
[17:02:52.593]                           name <- restart$name
[17:02:52.593]                           if (is.null(name)) 
[17:02:52.593]                             next
[17:02:52.593]                           if (!grepl(pattern, name)) 
[17:02:52.593]                             next
[17:02:52.593]                           invokeRestart(restart)
[17:02:52.593]                           muffled <- TRUE
[17:02:52.593]                           break
[17:02:52.593]                         }
[17:02:52.593]                       }
[17:02:52.593]                     }
[17:02:52.593]                     invisible(muffled)
[17:02:52.593]                   }
[17:02:52.593]                   muffleCondition(cond)
[17:02:52.593]                 })
[17:02:52.593]             }))
[17:02:52.593]             future::FutureResult(value = ...future.value$value, 
[17:02:52.593]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.593]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.593]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.593]                     ...future.globalenv.names))
[17:02:52.593]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.593]         }, condition = base::local({
[17:02:52.593]             c <- base::c
[17:02:52.593]             inherits <- base::inherits
[17:02:52.593]             invokeRestart <- base::invokeRestart
[17:02:52.593]             length <- base::length
[17:02:52.593]             list <- base::list
[17:02:52.593]             seq.int <- base::seq.int
[17:02:52.593]             signalCondition <- base::signalCondition
[17:02:52.593]             sys.calls <- base::sys.calls
[17:02:52.593]             `[[` <- base::`[[`
[17:02:52.593]             `+` <- base::`+`
[17:02:52.593]             `<<-` <- base::`<<-`
[17:02:52.593]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.593]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.593]                   3L)]
[17:02:52.593]             }
[17:02:52.593]             function(cond) {
[17:02:52.593]                 is_error <- inherits(cond, "error")
[17:02:52.593]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.593]                   NULL)
[17:02:52.593]                 if (is_error) {
[17:02:52.593]                   sessionInformation <- function() {
[17:02:52.593]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.593]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.593]                       search = base::search(), system = base::Sys.info())
[17:02:52.593]                   }
[17:02:52.593]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.593]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.593]                     cond$call), session = sessionInformation(), 
[17:02:52.593]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.593]                   signalCondition(cond)
[17:02:52.593]                 }
[17:02:52.593]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.593]                 "immediateCondition"))) {
[17:02:52.593]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.593]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.593]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.593]                   if (TRUE && !signal) {
[17:02:52.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.593]                     {
[17:02:52.593]                       inherits <- base::inherits
[17:02:52.593]                       invokeRestart <- base::invokeRestart
[17:02:52.593]                       is.null <- base::is.null
[17:02:52.593]                       muffled <- FALSE
[17:02:52.593]                       if (inherits(cond, "message")) {
[17:02:52.593]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.593]                         if (muffled) 
[17:02:52.593]                           invokeRestart("muffleMessage")
[17:02:52.593]                       }
[17:02:52.593]                       else if (inherits(cond, "warning")) {
[17:02:52.593]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.593]                         if (muffled) 
[17:02:52.593]                           invokeRestart("muffleWarning")
[17:02:52.593]                       }
[17:02:52.593]                       else if (inherits(cond, "condition")) {
[17:02:52.593]                         if (!is.null(pattern)) {
[17:02:52.593]                           computeRestarts <- base::computeRestarts
[17:02:52.593]                           grepl <- base::grepl
[17:02:52.593]                           restarts <- computeRestarts(cond)
[17:02:52.593]                           for (restart in restarts) {
[17:02:52.593]                             name <- restart$name
[17:02:52.593]                             if (is.null(name)) 
[17:02:52.593]                               next
[17:02:52.593]                             if (!grepl(pattern, name)) 
[17:02:52.593]                               next
[17:02:52.593]                             invokeRestart(restart)
[17:02:52.593]                             muffled <- TRUE
[17:02:52.593]                             break
[17:02:52.593]                           }
[17:02:52.593]                         }
[17:02:52.593]                       }
[17:02:52.593]                       invisible(muffled)
[17:02:52.593]                     }
[17:02:52.593]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.593]                   }
[17:02:52.593]                 }
[17:02:52.593]                 else {
[17:02:52.593]                   if (TRUE) {
[17:02:52.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.593]                     {
[17:02:52.593]                       inherits <- base::inherits
[17:02:52.593]                       invokeRestart <- base::invokeRestart
[17:02:52.593]                       is.null <- base::is.null
[17:02:52.593]                       muffled <- FALSE
[17:02:52.593]                       if (inherits(cond, "message")) {
[17:02:52.593]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.593]                         if (muffled) 
[17:02:52.593]                           invokeRestart("muffleMessage")
[17:02:52.593]                       }
[17:02:52.593]                       else if (inherits(cond, "warning")) {
[17:02:52.593]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.593]                         if (muffled) 
[17:02:52.593]                           invokeRestart("muffleWarning")
[17:02:52.593]                       }
[17:02:52.593]                       else if (inherits(cond, "condition")) {
[17:02:52.593]                         if (!is.null(pattern)) {
[17:02:52.593]                           computeRestarts <- base::computeRestarts
[17:02:52.593]                           grepl <- base::grepl
[17:02:52.593]                           restarts <- computeRestarts(cond)
[17:02:52.593]                           for (restart in restarts) {
[17:02:52.593]                             name <- restart$name
[17:02:52.593]                             if (is.null(name)) 
[17:02:52.593]                               next
[17:02:52.593]                             if (!grepl(pattern, name)) 
[17:02:52.593]                               next
[17:02:52.593]                             invokeRestart(restart)
[17:02:52.593]                             muffled <- TRUE
[17:02:52.593]                             break
[17:02:52.593]                           }
[17:02:52.593]                         }
[17:02:52.593]                       }
[17:02:52.593]                       invisible(muffled)
[17:02:52.593]                     }
[17:02:52.593]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.593]                   }
[17:02:52.593]                 }
[17:02:52.593]             }
[17:02:52.593]         }))
[17:02:52.593]     }, error = function(ex) {
[17:02:52.593]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.593]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.593]                 ...future.rng), started = ...future.startTime, 
[17:02:52.593]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.593]             version = "1.8"), class = "FutureResult")
[17:02:52.593]     }, finally = {
[17:02:52.593]         if (!identical(...future.workdir, getwd())) 
[17:02:52.593]             setwd(...future.workdir)
[17:02:52.593]         {
[17:02:52.593]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.593]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.593]             }
[17:02:52.593]             base::options(...future.oldOptions)
[17:02:52.593]             if (.Platform$OS.type == "windows") {
[17:02:52.593]                 old_names <- names(...future.oldEnvVars)
[17:02:52.593]                 envs <- base::Sys.getenv()
[17:02:52.593]                 names <- names(envs)
[17:02:52.593]                 common <- intersect(names, old_names)
[17:02:52.593]                 added <- setdiff(names, old_names)
[17:02:52.593]                 removed <- setdiff(old_names, names)
[17:02:52.593]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.593]                   envs[common]]
[17:02:52.593]                 NAMES <- toupper(changed)
[17:02:52.593]                 args <- list()
[17:02:52.593]                 for (kk in seq_along(NAMES)) {
[17:02:52.593]                   name <- changed[[kk]]
[17:02:52.593]                   NAME <- NAMES[[kk]]
[17:02:52.593]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.593]                     next
[17:02:52.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.593]                 }
[17:02:52.593]                 NAMES <- toupper(added)
[17:02:52.593]                 for (kk in seq_along(NAMES)) {
[17:02:52.593]                   name <- added[[kk]]
[17:02:52.593]                   NAME <- NAMES[[kk]]
[17:02:52.593]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.593]                     next
[17:02:52.593]                   args[[name]] <- ""
[17:02:52.593]                 }
[17:02:52.593]                 NAMES <- toupper(removed)
[17:02:52.593]                 for (kk in seq_along(NAMES)) {
[17:02:52.593]                   name <- removed[[kk]]
[17:02:52.593]                   NAME <- NAMES[[kk]]
[17:02:52.593]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.593]                     next
[17:02:52.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.593]                 }
[17:02:52.593]                 if (length(args) > 0) 
[17:02:52.593]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.593]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.593]             }
[17:02:52.593]             else {
[17:02:52.593]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.593]             }
[17:02:52.593]             {
[17:02:52.593]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.593]                   0L) {
[17:02:52.593]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.593]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.593]                   base::options(opts)
[17:02:52.593]                 }
[17:02:52.593]                 {
[17:02:52.593]                   {
[17:02:52.593]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.593]                     NULL
[17:02:52.593]                   }
[17:02:52.593]                   options(future.plan = NULL)
[17:02:52.593]                   if (is.na(NA_character_)) 
[17:02:52.593]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.593]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.593]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.593]                     .init = FALSE)
[17:02:52.593]                 }
[17:02:52.593]             }
[17:02:52.593]         }
[17:02:52.593]     })
[17:02:52.593]     if (TRUE) {
[17:02:52.593]         base::sink(type = "output", split = FALSE)
[17:02:52.593]         if (TRUE) {
[17:02:52.593]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.593]         }
[17:02:52.593]         else {
[17:02:52.593]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.593]         }
[17:02:52.593]         base::close(...future.stdout)
[17:02:52.593]         ...future.stdout <- NULL
[17:02:52.593]     }
[17:02:52.593]     ...future.result$conditions <- ...future.conditions
[17:02:52.593]     ...future.result$finished <- base::Sys.time()
[17:02:52.593]     ...future.result
[17:02:52.593] }
[17:02:52.596] assign_globals() ...
[17:02:52.596] List of 1
[17:02:52.596]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f4887ad8> 
[17:02:52.596]  - attr(*, "where")=List of 1
[17:02:52.596]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.596]  - attr(*, "resolved")= logi TRUE
[17:02:52.596]  - attr(*, "total_size")= num 1647480
[17:02:52.596]  - attr(*, "already-done")= logi TRUE
[17:02:52.599] - copied ‘a’ to environment
[17:02:52.599] assign_globals() ... done
[17:02:52.600] requestCore(): workers = 2
[17:02:52.602] MulticoreFuture started
[17:02:52.602] - Launch lazy future ... done
[17:02:52.603] run() for ‘MulticoreFuture’ ... done
[17:02:52.603] result() for MulticoreFuture ...
[17:02:52.604] plan(): Setting new future strategy stack:
[17:02:52.604] List of future strategies:
[17:02:52.604] 1. sequential:
[17:02:52.604]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.604]    - tweaked: FALSE
[17:02:52.604]    - call: NULL
[17:02:52.605] plan(): nbrOfWorkers() = 1
[17:02:52.609] plan(): Setting new future strategy stack:
[17:02:52.609] List of future strategies:
[17:02:52.609] 1. multicore:
[17:02:52.609]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.609]    - tweaked: FALSE
[17:02:52.609]    - call: plan(strategy)
[17:02:52.614] plan(): nbrOfWorkers() = 2
[17:02:52.615] result() for MulticoreFuture ...
[17:02:52.616] result() for MulticoreFuture ... done
[17:02:52.616] signalConditions() ...
[17:02:52.616]  - include = ‘immediateCondition’
[17:02:52.616]  - exclude = 
[17:02:52.616]  - resignal = FALSE
[17:02:52.616]  - Number of conditions: 4
[17:02:52.617] signalConditions() ... done
[17:02:52.617] result() for MulticoreFuture ... done
[17:02:52.617] result() for MulticoreFuture ...
[17:02:52.617] result() for MulticoreFuture ... done
[17:02:52.617] signalConditions() ...
[17:02:52.618]  - include = ‘immediateCondition’
[17:02:52.618]  - exclude = 
[17:02:52.618]  - resignal = FALSE
[17:02:52.618]  - Number of conditions: 4
[17:02:52.618] signalConditions() ... done
[17:02:52.618] Future state: ‘finished’
[17:02:52.619] result() for MulticoreFuture ...
[17:02:52.619] result() for MulticoreFuture ... done
[17:02:52.619] signalConditions() ...
[17:02:52.619]  - include = ‘condition’
[17:02:52.619]  - exclude = ‘immediateCondition’
[17:02:52.619]  - resignal = TRUE
[17:02:52.619]  - Number of conditions: 4
[17:02:52.619]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.606] result() for MulticoreFuture ...
[17:02:52.620]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.607] result() for MulticoreFuture ... done
[17:02:52.620]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.607] result() for MulticoreFuture ...
[17:02:52.620]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.607] result() for MulticoreFuture ... done
[17:02:52.620] signalConditions() ... done
value(b) = 2
[17:02:52.620] result() for MulticoreFuture ...
[17:02:52.620] result() for MulticoreFuture ... done
[17:02:52.621] result() for MulticoreFuture ...
[17:02:52.621] result() for MulticoreFuture ... done
[17:02:52.621] signalConditions() ...
[17:02:52.621]  - include = ‘immediateCondition’
[17:02:52.621]  - exclude = 
[17:02:52.621]  - resignal = FALSE
[17:02:52.621]  - Number of conditions: 4
[17:02:52.621] signalConditions() ... done
[17:02:52.621] Future state: ‘finished’
[17:02:52.622] result() for MulticoreFuture ...
[17:02:52.622] result() for MulticoreFuture ... done
[17:02:52.622] signalConditions() ...
[17:02:52.622]  - include = ‘condition’
[17:02:52.622]  - exclude = ‘immediateCondition’
[17:02:52.622]  - resignal = TRUE
[17:02:52.622]  - Number of conditions: 4
[17:02:52.622]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.606] result() for MulticoreFuture ...
[17:02:52.623]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.607] result() for MulticoreFuture ... done
[17:02:52.623]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.607] result() for MulticoreFuture ...
[17:02:52.623]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.607] result() for MulticoreFuture ... done
[17:02:52.623] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.623] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.624] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.624] 
[17:02:52.624] Searching for globals ... DONE
[17:02:52.624] - globals: [0] <none>
[17:02:52.625] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.625] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.625] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.626] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:52.626] Searching for globals ... DONE
[17:02:52.627] Resolving globals: TRUE
[17:02:52.627] Resolving any globals that are futures ...
[17:02:52.627] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:52.627] Resolving any globals that are futures ... DONE
[17:02:52.627] Resolving futures part of globals (recursively) ...
[17:02:52.628] resolve() on list ...
[17:02:52.628]  recursive: 99
[17:02:52.628]  length: 1
[17:02:52.628]  elements: ‘a’
[17:02:52.628] run() for ‘Future’ ...
[17:02:52.628] - state: ‘created’
[17:02:52.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.633]   - Field: ‘label’
[17:02:52.633]   - Field: ‘local’
[17:02:52.633]   - Field: ‘owner’
[17:02:52.634]   - Field: ‘envir’
[17:02:52.634]   - Field: ‘workers’
[17:02:52.634]   - Field: ‘packages’
[17:02:52.634]   - Field: ‘gc’
[17:02:52.634]   - Field: ‘job’
[17:02:52.634]   - Field: ‘conditions’
[17:02:52.634]   - Field: ‘expr’
[17:02:52.634]   - Field: ‘uuid’
[17:02:52.634]   - Field: ‘seed’
[17:02:52.635]   - Field: ‘version’
[17:02:52.635]   - Field: ‘result’
[17:02:52.635]   - Field: ‘asynchronous’
[17:02:52.635]   - Field: ‘calls’
[17:02:52.635]   - Field: ‘globals’
[17:02:52.635]   - Field: ‘stdout’
[17:02:52.635]   - Field: ‘earlySignal’
[17:02:52.635]   - Field: ‘lazy’
[17:02:52.636]   - Field: ‘state’
[17:02:52.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.636] - Launch lazy future ...
[17:02:52.636] Packages needed by the future expression (n = 0): <none>
[17:02:52.636] Packages needed by future strategies (n = 0): <none>
[17:02:52.637] {
[17:02:52.637]     {
[17:02:52.637]         {
[17:02:52.637]             ...future.startTime <- base::Sys.time()
[17:02:52.637]             {
[17:02:52.637]                 {
[17:02:52.637]                   {
[17:02:52.637]                     {
[17:02:52.637]                       base::local({
[17:02:52.637]                         has_future <- base::requireNamespace("future", 
[17:02:52.637]                           quietly = TRUE)
[17:02:52.637]                         if (has_future) {
[17:02:52.637]                           ns <- base::getNamespace("future")
[17:02:52.637]                           version <- ns[[".package"]][["version"]]
[17:02:52.637]                           if (is.null(version)) 
[17:02:52.637]                             version <- utils::packageVersion("future")
[17:02:52.637]                         }
[17:02:52.637]                         else {
[17:02:52.637]                           version <- NULL
[17:02:52.637]                         }
[17:02:52.637]                         if (!has_future || version < "1.8.0") {
[17:02:52.637]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.637]                             "", base::R.version$version.string), 
[17:02:52.637]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.637]                               "release", "version")], collapse = " "), 
[17:02:52.637]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.637]                             info)
[17:02:52.637]                           info <- base::paste(info, collapse = "; ")
[17:02:52.637]                           if (!has_future) {
[17:02:52.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.637]                               info)
[17:02:52.637]                           }
[17:02:52.637]                           else {
[17:02:52.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.637]                               info, version)
[17:02:52.637]                           }
[17:02:52.637]                           base::stop(msg)
[17:02:52.637]                         }
[17:02:52.637]                       })
[17:02:52.637]                     }
[17:02:52.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.637]                     base::options(mc.cores = 1L)
[17:02:52.637]                   }
[17:02:52.637]                   ...future.strategy.old <- future::plan("list")
[17:02:52.637]                   options(future.plan = NULL)
[17:02:52.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.637]                 }
[17:02:52.637]                 ...future.workdir <- getwd()
[17:02:52.637]             }
[17:02:52.637]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.637]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.637]         }
[17:02:52.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.637]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.637]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.637]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.637]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.637]             base::names(...future.oldOptions))
[17:02:52.637]     }
[17:02:52.637]     if (FALSE) {
[17:02:52.637]     }
[17:02:52.637]     else {
[17:02:52.637]         if (TRUE) {
[17:02:52.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.637]                 open = "w")
[17:02:52.637]         }
[17:02:52.637]         else {
[17:02:52.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.637]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.637]         }
[17:02:52.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.637]             base::sink(type = "output", split = FALSE)
[17:02:52.637]             base::close(...future.stdout)
[17:02:52.637]         }, add = TRUE)
[17:02:52.637]     }
[17:02:52.637]     ...future.frame <- base::sys.nframe()
[17:02:52.637]     ...future.conditions <- base::list()
[17:02:52.637]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.637]     if (FALSE) {
[17:02:52.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.637]     }
[17:02:52.637]     ...future.result <- base::tryCatch({
[17:02:52.637]         base::withCallingHandlers({
[17:02:52.637]             ...future.value <- base::withVisible(base::local({
[17:02:52.637]                 withCallingHandlers({
[17:02:52.637]                   1
[17:02:52.637]                 }, immediateCondition = function(cond) {
[17:02:52.637]                   save_rds <- function (object, pathname, ...) 
[17:02:52.637]                   {
[17:02:52.637]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.637]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.637]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.637]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.637]                         fi_tmp[["mtime"]])
[17:02:52.637]                     }
[17:02:52.637]                     tryCatch({
[17:02:52.637]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.637]                     }, error = function(ex) {
[17:02:52.637]                       msg <- conditionMessage(ex)
[17:02:52.637]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.637]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.637]                         fi_tmp[["mtime"]], msg)
[17:02:52.637]                       ex$message <- msg
[17:02:52.637]                       stop(ex)
[17:02:52.637]                     })
[17:02:52.637]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.637]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.637]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.637]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.637]                       fi <- file.info(pathname)
[17:02:52.637]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.637]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.637]                         fi[["size"]], fi[["mtime"]])
[17:02:52.637]                       stop(msg)
[17:02:52.637]                     }
[17:02:52.637]                     invisible(pathname)
[17:02:52.637]                   }
[17:02:52.637]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.637]                     rootPath = tempdir()) 
[17:02:52.637]                   {
[17:02:52.637]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.637]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.637]                       tmpdir = path, fileext = ".rds")
[17:02:52.637]                     save_rds(obj, file)
[17:02:52.637]                   }
[17:02:52.637]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.637]                   {
[17:02:52.637]                     inherits <- base::inherits
[17:02:52.637]                     invokeRestart <- base::invokeRestart
[17:02:52.637]                     is.null <- base::is.null
[17:02:52.637]                     muffled <- FALSE
[17:02:52.637]                     if (inherits(cond, "message")) {
[17:02:52.637]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.637]                       if (muffled) 
[17:02:52.637]                         invokeRestart("muffleMessage")
[17:02:52.637]                     }
[17:02:52.637]                     else if (inherits(cond, "warning")) {
[17:02:52.637]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.637]                       if (muffled) 
[17:02:52.637]                         invokeRestart("muffleWarning")
[17:02:52.637]                     }
[17:02:52.637]                     else if (inherits(cond, "condition")) {
[17:02:52.637]                       if (!is.null(pattern)) {
[17:02:52.637]                         computeRestarts <- base::computeRestarts
[17:02:52.637]                         grepl <- base::grepl
[17:02:52.637]                         restarts <- computeRestarts(cond)
[17:02:52.637]                         for (restart in restarts) {
[17:02:52.637]                           name <- restart$name
[17:02:52.637]                           if (is.null(name)) 
[17:02:52.637]                             next
[17:02:52.637]                           if (!grepl(pattern, name)) 
[17:02:52.637]                             next
[17:02:52.637]                           invokeRestart(restart)
[17:02:52.637]                           muffled <- TRUE
[17:02:52.637]                           break
[17:02:52.637]                         }
[17:02:52.637]                       }
[17:02:52.637]                     }
[17:02:52.637]                     invisible(muffled)
[17:02:52.637]                   }
[17:02:52.637]                   muffleCondition(cond)
[17:02:52.637]                 })
[17:02:52.637]             }))
[17:02:52.637]             future::FutureResult(value = ...future.value$value, 
[17:02:52.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.637]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.637]                     ...future.globalenv.names))
[17:02:52.637]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.637]         }, condition = base::local({
[17:02:52.637]             c <- base::c
[17:02:52.637]             inherits <- base::inherits
[17:02:52.637]             invokeRestart <- base::invokeRestart
[17:02:52.637]             length <- base::length
[17:02:52.637]             list <- base::list
[17:02:52.637]             seq.int <- base::seq.int
[17:02:52.637]             signalCondition <- base::signalCondition
[17:02:52.637]             sys.calls <- base::sys.calls
[17:02:52.637]             `[[` <- base::`[[`
[17:02:52.637]             `+` <- base::`+`
[17:02:52.637]             `<<-` <- base::`<<-`
[17:02:52.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.637]                   3L)]
[17:02:52.637]             }
[17:02:52.637]             function(cond) {
[17:02:52.637]                 is_error <- inherits(cond, "error")
[17:02:52.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.637]                   NULL)
[17:02:52.637]                 if (is_error) {
[17:02:52.637]                   sessionInformation <- function() {
[17:02:52.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.637]                       search = base::search(), system = base::Sys.info())
[17:02:52.637]                   }
[17:02:52.637]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.637]                     cond$call), session = sessionInformation(), 
[17:02:52.637]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.637]                   signalCondition(cond)
[17:02:52.637]                 }
[17:02:52.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.637]                 "immediateCondition"))) {
[17:02:52.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.637]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.637]                   if (TRUE && !signal) {
[17:02:52.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.637]                     {
[17:02:52.637]                       inherits <- base::inherits
[17:02:52.637]                       invokeRestart <- base::invokeRestart
[17:02:52.637]                       is.null <- base::is.null
[17:02:52.637]                       muffled <- FALSE
[17:02:52.637]                       if (inherits(cond, "message")) {
[17:02:52.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.637]                         if (muffled) 
[17:02:52.637]                           invokeRestart("muffleMessage")
[17:02:52.637]                       }
[17:02:52.637]                       else if (inherits(cond, "warning")) {
[17:02:52.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.637]                         if (muffled) 
[17:02:52.637]                           invokeRestart("muffleWarning")
[17:02:52.637]                       }
[17:02:52.637]                       else if (inherits(cond, "condition")) {
[17:02:52.637]                         if (!is.null(pattern)) {
[17:02:52.637]                           computeRestarts <- base::computeRestarts
[17:02:52.637]                           grepl <- base::grepl
[17:02:52.637]                           restarts <- computeRestarts(cond)
[17:02:52.637]                           for (restart in restarts) {
[17:02:52.637]                             name <- restart$name
[17:02:52.637]                             if (is.null(name)) 
[17:02:52.637]                               next
[17:02:52.637]                             if (!grepl(pattern, name)) 
[17:02:52.637]                               next
[17:02:52.637]                             invokeRestart(restart)
[17:02:52.637]                             muffled <- TRUE
[17:02:52.637]                             break
[17:02:52.637]                           }
[17:02:52.637]                         }
[17:02:52.637]                       }
[17:02:52.637]                       invisible(muffled)
[17:02:52.637]                     }
[17:02:52.637]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.637]                   }
[17:02:52.637]                 }
[17:02:52.637]                 else {
[17:02:52.637]                   if (TRUE) {
[17:02:52.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.637]                     {
[17:02:52.637]                       inherits <- base::inherits
[17:02:52.637]                       invokeRestart <- base::invokeRestart
[17:02:52.637]                       is.null <- base::is.null
[17:02:52.637]                       muffled <- FALSE
[17:02:52.637]                       if (inherits(cond, "message")) {
[17:02:52.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.637]                         if (muffled) 
[17:02:52.637]                           invokeRestart("muffleMessage")
[17:02:52.637]                       }
[17:02:52.637]                       else if (inherits(cond, "warning")) {
[17:02:52.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.637]                         if (muffled) 
[17:02:52.637]                           invokeRestart("muffleWarning")
[17:02:52.637]                       }
[17:02:52.637]                       else if (inherits(cond, "condition")) {
[17:02:52.637]                         if (!is.null(pattern)) {
[17:02:52.637]                           computeRestarts <- base::computeRestarts
[17:02:52.637]                           grepl <- base::grepl
[17:02:52.637]                           restarts <- computeRestarts(cond)
[17:02:52.637]                           for (restart in restarts) {
[17:02:52.637]                             name <- restart$name
[17:02:52.637]                             if (is.null(name)) 
[17:02:52.637]                               next
[17:02:52.637]                             if (!grepl(pattern, name)) 
[17:02:52.637]                               next
[17:02:52.637]                             invokeRestart(restart)
[17:02:52.637]                             muffled <- TRUE
[17:02:52.637]                             break
[17:02:52.637]                           }
[17:02:52.637]                         }
[17:02:52.637]                       }
[17:02:52.637]                       invisible(muffled)
[17:02:52.637]                     }
[17:02:52.637]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.637]                   }
[17:02:52.637]                 }
[17:02:52.637]             }
[17:02:52.637]         }))
[17:02:52.637]     }, error = function(ex) {
[17:02:52.637]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.637]                 ...future.rng), started = ...future.startTime, 
[17:02:52.637]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.637]             version = "1.8"), class = "FutureResult")
[17:02:52.637]     }, finally = {
[17:02:52.637]         if (!identical(...future.workdir, getwd())) 
[17:02:52.637]             setwd(...future.workdir)
[17:02:52.637]         {
[17:02:52.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.637]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.637]             }
[17:02:52.637]             base::options(...future.oldOptions)
[17:02:52.637]             if (.Platform$OS.type == "windows") {
[17:02:52.637]                 old_names <- names(...future.oldEnvVars)
[17:02:52.637]                 envs <- base::Sys.getenv()
[17:02:52.637]                 names <- names(envs)
[17:02:52.637]                 common <- intersect(names, old_names)
[17:02:52.637]                 added <- setdiff(names, old_names)
[17:02:52.637]                 removed <- setdiff(old_names, names)
[17:02:52.637]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.637]                   envs[common]]
[17:02:52.637]                 NAMES <- toupper(changed)
[17:02:52.637]                 args <- list()
[17:02:52.637]                 for (kk in seq_along(NAMES)) {
[17:02:52.637]                   name <- changed[[kk]]
[17:02:52.637]                   NAME <- NAMES[[kk]]
[17:02:52.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.637]                     next
[17:02:52.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.637]                 }
[17:02:52.637]                 NAMES <- toupper(added)
[17:02:52.637]                 for (kk in seq_along(NAMES)) {
[17:02:52.637]                   name <- added[[kk]]
[17:02:52.637]                   NAME <- NAMES[[kk]]
[17:02:52.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.637]                     next
[17:02:52.637]                   args[[name]] <- ""
[17:02:52.637]                 }
[17:02:52.637]                 NAMES <- toupper(removed)
[17:02:52.637]                 for (kk in seq_along(NAMES)) {
[17:02:52.637]                   name <- removed[[kk]]
[17:02:52.637]                   NAME <- NAMES[[kk]]
[17:02:52.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.637]                     next
[17:02:52.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.637]                 }
[17:02:52.637]                 if (length(args) > 0) 
[17:02:52.637]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.637]             }
[17:02:52.637]             else {
[17:02:52.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.637]             }
[17:02:52.637]             {
[17:02:52.637]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.637]                   0L) {
[17:02:52.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.637]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.637]                   base::options(opts)
[17:02:52.637]                 }
[17:02:52.637]                 {
[17:02:52.637]                   {
[17:02:52.637]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.637]                     NULL
[17:02:52.637]                   }
[17:02:52.637]                   options(future.plan = NULL)
[17:02:52.637]                   if (is.na(NA_character_)) 
[17:02:52.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.637]                     .init = FALSE)
[17:02:52.637]                 }
[17:02:52.637]             }
[17:02:52.637]         }
[17:02:52.637]     })
[17:02:52.637]     if (TRUE) {
[17:02:52.637]         base::sink(type = "output", split = FALSE)
[17:02:52.637]         if (TRUE) {
[17:02:52.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.637]         }
[17:02:52.637]         else {
[17:02:52.637]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.637]         }
[17:02:52.637]         base::close(...future.stdout)
[17:02:52.637]         ...future.stdout <- NULL
[17:02:52.637]     }
[17:02:52.637]     ...future.result$conditions <- ...future.conditions
[17:02:52.637]     ...future.result$finished <- base::Sys.time()
[17:02:52.637]     ...future.result
[17:02:52.637] }
[17:02:52.642] requestCore(): workers = 2
[17:02:52.644] MulticoreFuture started
[17:02:52.644] - Launch lazy future ... done
[17:02:52.645] run() for ‘MulticoreFuture’ ... done
[17:02:52.645] plan(): Setting new future strategy stack:
[17:02:52.645] List of future strategies:
[17:02:52.645] 1. sequential:
[17:02:52.645]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.645]    - tweaked: FALSE
[17:02:52.645]    - call: NULL
[17:02:52.647] plan(): nbrOfWorkers() = 1
[17:02:52.649] plan(): Setting new future strategy stack:
[17:02:52.649] List of future strategies:
[17:02:52.649] 1. multicore:
[17:02:52.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.649]    - tweaked: FALSE
[17:02:52.649]    - call: plan(strategy)
[17:02:52.655] plan(): nbrOfWorkers() = 2
[17:02:52.666] Future #1
[17:02:52.666] result() for MulticoreFuture ...
[17:02:52.667] result() for MulticoreFuture ...
[17:02:52.667] result() for MulticoreFuture ... done
[17:02:52.668] result() for MulticoreFuture ... done
[17:02:52.668] result() for MulticoreFuture ...
[17:02:52.668] result() for MulticoreFuture ... done
[17:02:52.668] A MulticoreFuture was resolved
[17:02:52.668]  length: 0 (resolved future 1)
[17:02:52.668] resolve() on list ... DONE
[17:02:52.669] - globals: [1] ‘a’
[17:02:52.669] Resolving futures part of globals (recursively) ... DONE
[17:02:52.673] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[17:02:52.674] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:52.674] - globals: [1] ‘a’
[17:02:52.674] - packages: [1] ‘future’
[17:02:52.674] getGlobalsAndPackages() ... DONE
[17:02:52.675] run() for ‘Future’ ...
[17:02:52.675] - state: ‘created’
[17:02:52.675] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.680] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.680]   - Field: ‘label’
[17:02:52.680]   - Field: ‘local’
[17:02:52.680]   - Field: ‘owner’
[17:02:52.680]   - Field: ‘envir’
[17:02:52.680]   - Field: ‘workers’
[17:02:52.681]   - Field: ‘packages’
[17:02:52.681]   - Field: ‘gc’
[17:02:52.681]   - Field: ‘job’
[17:02:52.681]   - Field: ‘conditions’
[17:02:52.681]   - Field: ‘expr’
[17:02:52.681]   - Field: ‘uuid’
[17:02:52.681]   - Field: ‘seed’
[17:02:52.681]   - Field: ‘version’
[17:02:52.681]   - Field: ‘result’
[17:02:52.682]   - Field: ‘asynchronous’
[17:02:52.682]   - Field: ‘calls’
[17:02:52.682]   - Field: ‘globals’
[17:02:52.682]   - Field: ‘stdout’
[17:02:52.682]   - Field: ‘earlySignal’
[17:02:52.682]   - Field: ‘lazy’
[17:02:52.682]   - Field: ‘state’
[17:02:52.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.682] - Launch lazy future ...
[17:02:52.683] Packages needed by the future expression (n = 1): ‘future’
[17:02:52.683] Packages needed by future strategies (n = 0): <none>
[17:02:52.683] {
[17:02:52.683]     {
[17:02:52.683]         {
[17:02:52.683]             ...future.startTime <- base::Sys.time()
[17:02:52.683]             {
[17:02:52.683]                 {
[17:02:52.683]                   {
[17:02:52.683]                     {
[17:02:52.683]                       {
[17:02:52.683]                         base::local({
[17:02:52.683]                           has_future <- base::requireNamespace("future", 
[17:02:52.683]                             quietly = TRUE)
[17:02:52.683]                           if (has_future) {
[17:02:52.683]                             ns <- base::getNamespace("future")
[17:02:52.683]                             version <- ns[[".package"]][["version"]]
[17:02:52.683]                             if (is.null(version)) 
[17:02:52.683]                               version <- utils::packageVersion("future")
[17:02:52.683]                           }
[17:02:52.683]                           else {
[17:02:52.683]                             version <- NULL
[17:02:52.683]                           }
[17:02:52.683]                           if (!has_future || version < "1.8.0") {
[17:02:52.683]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.683]                               "", base::R.version$version.string), 
[17:02:52.683]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:52.683]                                 base::R.version$platform, 8 * 
[17:02:52.683]                                   base::.Machine$sizeof.pointer), 
[17:02:52.683]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.683]                                 "release", "version")], collapse = " "), 
[17:02:52.683]                               hostname = base::Sys.info()[["nodename"]])
[17:02:52.683]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.683]                               info)
[17:02:52.683]                             info <- base::paste(info, collapse = "; ")
[17:02:52.683]                             if (!has_future) {
[17:02:52.683]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.683]                                 info)
[17:02:52.683]                             }
[17:02:52.683]                             else {
[17:02:52.683]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.683]                                 info, version)
[17:02:52.683]                             }
[17:02:52.683]                             base::stop(msg)
[17:02:52.683]                           }
[17:02:52.683]                         })
[17:02:52.683]                       }
[17:02:52.683]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.683]                       base::options(mc.cores = 1L)
[17:02:52.683]                     }
[17:02:52.683]                     base::local({
[17:02:52.683]                       for (pkg in "future") {
[17:02:52.683]                         base::loadNamespace(pkg)
[17:02:52.683]                         base::library(pkg, character.only = TRUE)
[17:02:52.683]                       }
[17:02:52.683]                     })
[17:02:52.683]                   }
[17:02:52.683]                   ...future.strategy.old <- future::plan("list")
[17:02:52.683]                   options(future.plan = NULL)
[17:02:52.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.683]                 }
[17:02:52.683]                 ...future.workdir <- getwd()
[17:02:52.683]             }
[17:02:52.683]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.683]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.683]         }
[17:02:52.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.683]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.683]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.683]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.683]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.683]             base::names(...future.oldOptions))
[17:02:52.683]     }
[17:02:52.683]     if (FALSE) {
[17:02:52.683]     }
[17:02:52.683]     else {
[17:02:52.683]         if (TRUE) {
[17:02:52.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.683]                 open = "w")
[17:02:52.683]         }
[17:02:52.683]         else {
[17:02:52.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.683]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.683]         }
[17:02:52.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.683]             base::sink(type = "output", split = FALSE)
[17:02:52.683]             base::close(...future.stdout)
[17:02:52.683]         }, add = TRUE)
[17:02:52.683]     }
[17:02:52.683]     ...future.frame <- base::sys.nframe()
[17:02:52.683]     ...future.conditions <- base::list()
[17:02:52.683]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.683]     if (FALSE) {
[17:02:52.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.683]     }
[17:02:52.683]     ...future.result <- base::tryCatch({
[17:02:52.683]         base::withCallingHandlers({
[17:02:52.683]             ...future.value <- base::withVisible(base::local({
[17:02:52.683]                 withCallingHandlers({
[17:02:52.683]                   value(a) + 1
[17:02:52.683]                 }, immediateCondition = function(cond) {
[17:02:52.683]                   save_rds <- function (object, pathname, ...) 
[17:02:52.683]                   {
[17:02:52.683]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.683]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.683]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.683]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.683]                         fi_tmp[["mtime"]])
[17:02:52.683]                     }
[17:02:52.683]                     tryCatch({
[17:02:52.683]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.683]                     }, error = function(ex) {
[17:02:52.683]                       msg <- conditionMessage(ex)
[17:02:52.683]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.683]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.683]                         fi_tmp[["mtime"]], msg)
[17:02:52.683]                       ex$message <- msg
[17:02:52.683]                       stop(ex)
[17:02:52.683]                     })
[17:02:52.683]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.683]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.683]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.683]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.683]                       fi <- file.info(pathname)
[17:02:52.683]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.683]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.683]                         fi[["size"]], fi[["mtime"]])
[17:02:52.683]                       stop(msg)
[17:02:52.683]                     }
[17:02:52.683]                     invisible(pathname)
[17:02:52.683]                   }
[17:02:52.683]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.683]                     rootPath = tempdir()) 
[17:02:52.683]                   {
[17:02:52.683]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.683]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.683]                       tmpdir = path, fileext = ".rds")
[17:02:52.683]                     save_rds(obj, file)
[17:02:52.683]                   }
[17:02:52.683]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.683]                   {
[17:02:52.683]                     inherits <- base::inherits
[17:02:52.683]                     invokeRestart <- base::invokeRestart
[17:02:52.683]                     is.null <- base::is.null
[17:02:52.683]                     muffled <- FALSE
[17:02:52.683]                     if (inherits(cond, "message")) {
[17:02:52.683]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.683]                       if (muffled) 
[17:02:52.683]                         invokeRestart("muffleMessage")
[17:02:52.683]                     }
[17:02:52.683]                     else if (inherits(cond, "warning")) {
[17:02:52.683]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.683]                       if (muffled) 
[17:02:52.683]                         invokeRestart("muffleWarning")
[17:02:52.683]                     }
[17:02:52.683]                     else if (inherits(cond, "condition")) {
[17:02:52.683]                       if (!is.null(pattern)) {
[17:02:52.683]                         computeRestarts <- base::computeRestarts
[17:02:52.683]                         grepl <- base::grepl
[17:02:52.683]                         restarts <- computeRestarts(cond)
[17:02:52.683]                         for (restart in restarts) {
[17:02:52.683]                           name <- restart$name
[17:02:52.683]                           if (is.null(name)) 
[17:02:52.683]                             next
[17:02:52.683]                           if (!grepl(pattern, name)) 
[17:02:52.683]                             next
[17:02:52.683]                           invokeRestart(restart)
[17:02:52.683]                           muffled <- TRUE
[17:02:52.683]                           break
[17:02:52.683]                         }
[17:02:52.683]                       }
[17:02:52.683]                     }
[17:02:52.683]                     invisible(muffled)
[17:02:52.683]                   }
[17:02:52.683]                   muffleCondition(cond)
[17:02:52.683]                 })
[17:02:52.683]             }))
[17:02:52.683]             future::FutureResult(value = ...future.value$value, 
[17:02:52.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.683]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.683]                     ...future.globalenv.names))
[17:02:52.683]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.683]         }, condition = base::local({
[17:02:52.683]             c <- base::c
[17:02:52.683]             inherits <- base::inherits
[17:02:52.683]             invokeRestart <- base::invokeRestart
[17:02:52.683]             length <- base::length
[17:02:52.683]             list <- base::list
[17:02:52.683]             seq.int <- base::seq.int
[17:02:52.683]             signalCondition <- base::signalCondition
[17:02:52.683]             sys.calls <- base::sys.calls
[17:02:52.683]             `[[` <- base::`[[`
[17:02:52.683]             `+` <- base::`+`
[17:02:52.683]             `<<-` <- base::`<<-`
[17:02:52.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.683]                   3L)]
[17:02:52.683]             }
[17:02:52.683]             function(cond) {
[17:02:52.683]                 is_error <- inherits(cond, "error")
[17:02:52.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.683]                   NULL)
[17:02:52.683]                 if (is_error) {
[17:02:52.683]                   sessionInformation <- function() {
[17:02:52.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.683]                       search = base::search(), system = base::Sys.info())
[17:02:52.683]                   }
[17:02:52.683]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.683]                     cond$call), session = sessionInformation(), 
[17:02:52.683]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.683]                   signalCondition(cond)
[17:02:52.683]                 }
[17:02:52.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.683]                 "immediateCondition"))) {
[17:02:52.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.683]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.683]                   if (TRUE && !signal) {
[17:02:52.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.683]                     {
[17:02:52.683]                       inherits <- base::inherits
[17:02:52.683]                       invokeRestart <- base::invokeRestart
[17:02:52.683]                       is.null <- base::is.null
[17:02:52.683]                       muffled <- FALSE
[17:02:52.683]                       if (inherits(cond, "message")) {
[17:02:52.683]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.683]                         if (muffled) 
[17:02:52.683]                           invokeRestart("muffleMessage")
[17:02:52.683]                       }
[17:02:52.683]                       else if (inherits(cond, "warning")) {
[17:02:52.683]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.683]                         if (muffled) 
[17:02:52.683]                           invokeRestart("muffleWarning")
[17:02:52.683]                       }
[17:02:52.683]                       else if (inherits(cond, "condition")) {
[17:02:52.683]                         if (!is.null(pattern)) {
[17:02:52.683]                           computeRestarts <- base::computeRestarts
[17:02:52.683]                           grepl <- base::grepl
[17:02:52.683]                           restarts <- computeRestarts(cond)
[17:02:52.683]                           for (restart in restarts) {
[17:02:52.683]                             name <- restart$name
[17:02:52.683]                             if (is.null(name)) 
[17:02:52.683]                               next
[17:02:52.683]                             if (!grepl(pattern, name)) 
[17:02:52.683]                               next
[17:02:52.683]                             invokeRestart(restart)
[17:02:52.683]                             muffled <- TRUE
[17:02:52.683]                             break
[17:02:52.683]                           }
[17:02:52.683]                         }
[17:02:52.683]                       }
[17:02:52.683]                       invisible(muffled)
[17:02:52.683]                     }
[17:02:52.683]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.683]                   }
[17:02:52.683]                 }
[17:02:52.683]                 else {
[17:02:52.683]                   if (TRUE) {
[17:02:52.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.683]                     {
[17:02:52.683]                       inherits <- base::inherits
[17:02:52.683]                       invokeRestart <- base::invokeRestart
[17:02:52.683]                       is.null <- base::is.null
[17:02:52.683]                       muffled <- FALSE
[17:02:52.683]                       if (inherits(cond, "message")) {
[17:02:52.683]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.683]                         if (muffled) 
[17:02:52.683]                           invokeRestart("muffleMessage")
[17:02:52.683]                       }
[17:02:52.683]                       else if (inherits(cond, "warning")) {
[17:02:52.683]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.683]                         if (muffled) 
[17:02:52.683]                           invokeRestart("muffleWarning")
[17:02:52.683]                       }
[17:02:52.683]                       else if (inherits(cond, "condition")) {
[17:02:52.683]                         if (!is.null(pattern)) {
[17:02:52.683]                           computeRestarts <- base::computeRestarts
[17:02:52.683]                           grepl <- base::grepl
[17:02:52.683]                           restarts <- computeRestarts(cond)
[17:02:52.683]                           for (restart in restarts) {
[17:02:52.683]                             name <- restart$name
[17:02:52.683]                             if (is.null(name)) 
[17:02:52.683]                               next
[17:02:52.683]                             if (!grepl(pattern, name)) 
[17:02:52.683]                               next
[17:02:52.683]                             invokeRestart(restart)
[17:02:52.683]                             muffled <- TRUE
[17:02:52.683]                             break
[17:02:52.683]                           }
[17:02:52.683]                         }
[17:02:52.683]                       }
[17:02:52.683]                       invisible(muffled)
[17:02:52.683]                     }
[17:02:52.683]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.683]                   }
[17:02:52.683]                 }
[17:02:52.683]             }
[17:02:52.683]         }))
[17:02:52.683]     }, error = function(ex) {
[17:02:52.683]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.683]                 ...future.rng), started = ...future.startTime, 
[17:02:52.683]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.683]             version = "1.8"), class = "FutureResult")
[17:02:52.683]     }, finally = {
[17:02:52.683]         if (!identical(...future.workdir, getwd())) 
[17:02:52.683]             setwd(...future.workdir)
[17:02:52.683]         {
[17:02:52.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.683]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.683]             }
[17:02:52.683]             base::options(...future.oldOptions)
[17:02:52.683]             if (.Platform$OS.type == "windows") {
[17:02:52.683]                 old_names <- names(...future.oldEnvVars)
[17:02:52.683]                 envs <- base::Sys.getenv()
[17:02:52.683]                 names <- names(envs)
[17:02:52.683]                 common <- intersect(names, old_names)
[17:02:52.683]                 added <- setdiff(names, old_names)
[17:02:52.683]                 removed <- setdiff(old_names, names)
[17:02:52.683]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.683]                   envs[common]]
[17:02:52.683]                 NAMES <- toupper(changed)
[17:02:52.683]                 args <- list()
[17:02:52.683]                 for (kk in seq_along(NAMES)) {
[17:02:52.683]                   name <- changed[[kk]]
[17:02:52.683]                   NAME <- NAMES[[kk]]
[17:02:52.683]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.683]                     next
[17:02:52.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.683]                 }
[17:02:52.683]                 NAMES <- toupper(added)
[17:02:52.683]                 for (kk in seq_along(NAMES)) {
[17:02:52.683]                   name <- added[[kk]]
[17:02:52.683]                   NAME <- NAMES[[kk]]
[17:02:52.683]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.683]                     next
[17:02:52.683]                   args[[name]] <- ""
[17:02:52.683]                 }
[17:02:52.683]                 NAMES <- toupper(removed)
[17:02:52.683]                 for (kk in seq_along(NAMES)) {
[17:02:52.683]                   name <- removed[[kk]]
[17:02:52.683]                   NAME <- NAMES[[kk]]
[17:02:52.683]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.683]                     next
[17:02:52.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.683]                 }
[17:02:52.683]                 if (length(args) > 0) 
[17:02:52.683]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.683]             }
[17:02:52.683]             else {
[17:02:52.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.683]             }
[17:02:52.683]             {
[17:02:52.683]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.683]                   0L) {
[17:02:52.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.683]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.683]                   base::options(opts)
[17:02:52.683]                 }
[17:02:52.683]                 {
[17:02:52.683]                   {
[17:02:52.683]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.683]                     NULL
[17:02:52.683]                   }
[17:02:52.683]                   options(future.plan = NULL)
[17:02:52.683]                   if (is.na(NA_character_)) 
[17:02:52.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.683]                     .init = FALSE)
[17:02:52.683]                 }
[17:02:52.683]             }
[17:02:52.683]         }
[17:02:52.683]     })
[17:02:52.683]     if (TRUE) {
[17:02:52.683]         base::sink(type = "output", split = FALSE)
[17:02:52.683]         if (TRUE) {
[17:02:52.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.683]         }
[17:02:52.683]         else {
[17:02:52.683]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.683]         }
[17:02:52.683]         base::close(...future.stdout)
[17:02:52.683]         ...future.stdout <- NULL
[17:02:52.683]     }
[17:02:52.683]     ...future.result$conditions <- ...future.conditions
[17:02:52.683]     ...future.result$finished <- base::Sys.time()
[17:02:52.683]     ...future.result
[17:02:52.683] }
[17:02:52.686] assign_globals() ...
[17:02:52.686] List of 1
[17:02:52.686]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f62d7ce8> 
[17:02:52.686]  - attr(*, "where")=List of 1
[17:02:52.686]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.686]  - attr(*, "resolved")= logi TRUE
[17:02:52.686]  - attr(*, "total_size")= num 1647648
[17:02:52.686]  - attr(*, "already-done")= logi TRUE
[17:02:52.689] - copied ‘a’ to environment
[17:02:52.689] assign_globals() ... done
[17:02:52.690] requestCore(): workers = 2
[17:02:52.692] MulticoreFuture started
[17:02:52.692] - Launch lazy future ... done
[17:02:52.693] run() for ‘MulticoreFuture’ ... done
[17:02:52.693] result() for MulticoreFuture ...
[17:02:52.693] plan(): Setting new future strategy stack:
[17:02:52.694] List of future strategies:
[17:02:52.694] 1. sequential:
[17:02:52.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.694]    - tweaked: FALSE
[17:02:52.694]    - call: NULL
[17:02:52.695] plan(): nbrOfWorkers() = 1
[17:02:52.698] plan(): Setting new future strategy stack:
[17:02:52.698] List of future strategies:
[17:02:52.698] 1. multicore:
[17:02:52.698]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.698]    - tweaked: FALSE
[17:02:52.698]    - call: plan(strategy)
[17:02:52.704] plan(): nbrOfWorkers() = 2
[17:02:52.705] result() for MulticoreFuture ...
[17:02:52.705] result() for MulticoreFuture ... done
[17:02:52.705] signalConditions() ...
[17:02:52.705]  - include = ‘immediateCondition’
[17:02:52.705]  - exclude = 
[17:02:52.706]  - resignal = FALSE
[17:02:52.706]  - Number of conditions: 4
[17:02:52.706] signalConditions() ... done
[17:02:52.706] result() for MulticoreFuture ... done
[17:02:52.706] result() for MulticoreFuture ...
[17:02:52.707] result() for MulticoreFuture ... done
[17:02:52.707] signalConditions() ...
[17:02:52.707]  - include = ‘immediateCondition’
[17:02:52.707]  - exclude = 
[17:02:52.707]  - resignal = FALSE
[17:02:52.707]  - Number of conditions: 4
[17:02:52.708] signalConditions() ... done
[17:02:52.708] Future state: ‘finished’
[17:02:52.708] result() for MulticoreFuture ...
[17:02:52.708] result() for MulticoreFuture ... done
[17:02:52.708] signalConditions() ...
[17:02:52.708]  - include = ‘condition’
[17:02:52.708]  - exclude = ‘immediateCondition’
[17:02:52.708]  - resignal = TRUE
[17:02:52.709]  - Number of conditions: 4
[17:02:52.709]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.696] result() for MulticoreFuture ...
[17:02:52.709]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.696] result() for MulticoreFuture ... done
[17:02:52.709]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.697] result() for MulticoreFuture ...
[17:02:52.709]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.697] result() for MulticoreFuture ... done
[17:02:52.709] signalConditions() ... done
value(b) = 2
[17:02:52.710] result() for MulticoreFuture ...
[17:02:52.710] result() for MulticoreFuture ... done
[17:02:52.710] result() for MulticoreFuture ...
[17:02:52.710] result() for MulticoreFuture ... done
[17:02:52.710] signalConditions() ...
[17:02:52.710]  - include = ‘immediateCondition’
[17:02:52.710]  - exclude = 
[17:02:52.710]  - resignal = FALSE
[17:02:52.710]  - Number of conditions: 4
[17:02:52.711] signalConditions() ... done
[17:02:52.711] Future state: ‘finished’
[17:02:52.711] result() for MulticoreFuture ...
[17:02:52.711] result() for MulticoreFuture ... done
[17:02:52.711] signalConditions() ...
[17:02:52.711]  - include = ‘condition’
[17:02:52.711]  - exclude = ‘immediateCondition’
[17:02:52.711]  - resignal = TRUE
[17:02:52.712]  - Number of conditions: 4
[17:02:52.712]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.696] result() for MulticoreFuture ...
[17:02:52.712]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.696] result() for MulticoreFuture ... done
[17:02:52.712]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.697] result() for MulticoreFuture ...
[17:02:52.712]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.697] result() for MulticoreFuture ... done
[17:02:52.712] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.713] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.713] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.714] 
[17:02:52.714] Searching for globals ... DONE
[17:02:52.714] - globals: [0] <none>
[17:02:52.714] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.714] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.715] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.716] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:52.716] Searching for globals ... DONE
[17:02:52.716] Resolving globals: TRUE
[17:02:52.716] Resolving any globals that are futures ...
[17:02:52.716] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:52.719] Resolving any globals that are futures ... DONE
[17:02:52.720] Resolving futures part of globals (recursively) ...
[17:02:52.720] resolve() on list ...
[17:02:52.720]  recursive: 99
[17:02:52.720]  length: 1
[17:02:52.720]  elements: ‘a’
[17:02:52.721] run() for ‘Future’ ...
[17:02:52.721] - state: ‘created’
[17:02:52.721] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.725] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.726]   - Field: ‘label’
[17:02:52.726]   - Field: ‘local’
[17:02:52.726]   - Field: ‘owner’
[17:02:52.726]   - Field: ‘envir’
[17:02:52.726]   - Field: ‘workers’
[17:02:52.726]   - Field: ‘packages’
[17:02:52.726]   - Field: ‘gc’
[17:02:52.726]   - Field: ‘job’
[17:02:52.727]   - Field: ‘conditions’
[17:02:52.727]   - Field: ‘expr’
[17:02:52.727]   - Field: ‘uuid’
[17:02:52.727]   - Field: ‘seed’
[17:02:52.727]   - Field: ‘version’
[17:02:52.727]   - Field: ‘result’
[17:02:52.727]   - Field: ‘asynchronous’
[17:02:52.728]   - Field: ‘calls’
[17:02:52.728]   - Field: ‘globals’
[17:02:52.728]   - Field: ‘stdout’
[17:02:52.728]   - Field: ‘earlySignal’
[17:02:52.728]   - Field: ‘lazy’
[17:02:52.728]   - Field: ‘state’
[17:02:52.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.729] - Launch lazy future ...
[17:02:52.729] Packages needed by the future expression (n = 0): <none>
[17:02:52.729] Packages needed by future strategies (n = 0): <none>
[17:02:52.730] {
[17:02:52.730]     {
[17:02:52.730]         {
[17:02:52.730]             ...future.startTime <- base::Sys.time()
[17:02:52.730]             {
[17:02:52.730]                 {
[17:02:52.730]                   {
[17:02:52.730]                     {
[17:02:52.730]                       base::local({
[17:02:52.730]                         has_future <- base::requireNamespace("future", 
[17:02:52.730]                           quietly = TRUE)
[17:02:52.730]                         if (has_future) {
[17:02:52.730]                           ns <- base::getNamespace("future")
[17:02:52.730]                           version <- ns[[".package"]][["version"]]
[17:02:52.730]                           if (is.null(version)) 
[17:02:52.730]                             version <- utils::packageVersion("future")
[17:02:52.730]                         }
[17:02:52.730]                         else {
[17:02:52.730]                           version <- NULL
[17:02:52.730]                         }
[17:02:52.730]                         if (!has_future || version < "1.8.0") {
[17:02:52.730]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.730]                             "", base::R.version$version.string), 
[17:02:52.730]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.730]                               "release", "version")], collapse = " "), 
[17:02:52.730]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.730]                             info)
[17:02:52.730]                           info <- base::paste(info, collapse = "; ")
[17:02:52.730]                           if (!has_future) {
[17:02:52.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.730]                               info)
[17:02:52.730]                           }
[17:02:52.730]                           else {
[17:02:52.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.730]                               info, version)
[17:02:52.730]                           }
[17:02:52.730]                           base::stop(msg)
[17:02:52.730]                         }
[17:02:52.730]                       })
[17:02:52.730]                     }
[17:02:52.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.730]                     base::options(mc.cores = 1L)
[17:02:52.730]                   }
[17:02:52.730]                   ...future.strategy.old <- future::plan("list")
[17:02:52.730]                   options(future.plan = NULL)
[17:02:52.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.730]                 }
[17:02:52.730]                 ...future.workdir <- getwd()
[17:02:52.730]             }
[17:02:52.730]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.730]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.730]         }
[17:02:52.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.730]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.730]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.730]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.730]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.730]             base::names(...future.oldOptions))
[17:02:52.730]     }
[17:02:52.730]     if (FALSE) {
[17:02:52.730]     }
[17:02:52.730]     else {
[17:02:52.730]         if (TRUE) {
[17:02:52.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.730]                 open = "w")
[17:02:52.730]         }
[17:02:52.730]         else {
[17:02:52.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.730]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.730]         }
[17:02:52.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.730]             base::sink(type = "output", split = FALSE)
[17:02:52.730]             base::close(...future.stdout)
[17:02:52.730]         }, add = TRUE)
[17:02:52.730]     }
[17:02:52.730]     ...future.frame <- base::sys.nframe()
[17:02:52.730]     ...future.conditions <- base::list()
[17:02:52.730]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.730]     if (FALSE) {
[17:02:52.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.730]     }
[17:02:52.730]     ...future.result <- base::tryCatch({
[17:02:52.730]         base::withCallingHandlers({
[17:02:52.730]             ...future.value <- base::withVisible(base::local({
[17:02:52.730]                 withCallingHandlers({
[17:02:52.730]                   1
[17:02:52.730]                 }, immediateCondition = function(cond) {
[17:02:52.730]                   save_rds <- function (object, pathname, ...) 
[17:02:52.730]                   {
[17:02:52.730]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.730]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.730]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.730]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.730]                         fi_tmp[["mtime"]])
[17:02:52.730]                     }
[17:02:52.730]                     tryCatch({
[17:02:52.730]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.730]                     }, error = function(ex) {
[17:02:52.730]                       msg <- conditionMessage(ex)
[17:02:52.730]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.730]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.730]                         fi_tmp[["mtime"]], msg)
[17:02:52.730]                       ex$message <- msg
[17:02:52.730]                       stop(ex)
[17:02:52.730]                     })
[17:02:52.730]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.730]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.730]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.730]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.730]                       fi <- file.info(pathname)
[17:02:52.730]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.730]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.730]                         fi[["size"]], fi[["mtime"]])
[17:02:52.730]                       stop(msg)
[17:02:52.730]                     }
[17:02:52.730]                     invisible(pathname)
[17:02:52.730]                   }
[17:02:52.730]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.730]                     rootPath = tempdir()) 
[17:02:52.730]                   {
[17:02:52.730]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.730]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.730]                       tmpdir = path, fileext = ".rds")
[17:02:52.730]                     save_rds(obj, file)
[17:02:52.730]                   }
[17:02:52.730]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.730]                   {
[17:02:52.730]                     inherits <- base::inherits
[17:02:52.730]                     invokeRestart <- base::invokeRestart
[17:02:52.730]                     is.null <- base::is.null
[17:02:52.730]                     muffled <- FALSE
[17:02:52.730]                     if (inherits(cond, "message")) {
[17:02:52.730]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.730]                       if (muffled) 
[17:02:52.730]                         invokeRestart("muffleMessage")
[17:02:52.730]                     }
[17:02:52.730]                     else if (inherits(cond, "warning")) {
[17:02:52.730]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.730]                       if (muffled) 
[17:02:52.730]                         invokeRestart("muffleWarning")
[17:02:52.730]                     }
[17:02:52.730]                     else if (inherits(cond, "condition")) {
[17:02:52.730]                       if (!is.null(pattern)) {
[17:02:52.730]                         computeRestarts <- base::computeRestarts
[17:02:52.730]                         grepl <- base::grepl
[17:02:52.730]                         restarts <- computeRestarts(cond)
[17:02:52.730]                         for (restart in restarts) {
[17:02:52.730]                           name <- restart$name
[17:02:52.730]                           if (is.null(name)) 
[17:02:52.730]                             next
[17:02:52.730]                           if (!grepl(pattern, name)) 
[17:02:52.730]                             next
[17:02:52.730]                           invokeRestart(restart)
[17:02:52.730]                           muffled <- TRUE
[17:02:52.730]                           break
[17:02:52.730]                         }
[17:02:52.730]                       }
[17:02:52.730]                     }
[17:02:52.730]                     invisible(muffled)
[17:02:52.730]                   }
[17:02:52.730]                   muffleCondition(cond)
[17:02:52.730]                 })
[17:02:52.730]             }))
[17:02:52.730]             future::FutureResult(value = ...future.value$value, 
[17:02:52.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.730]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.730]                     ...future.globalenv.names))
[17:02:52.730]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.730]         }, condition = base::local({
[17:02:52.730]             c <- base::c
[17:02:52.730]             inherits <- base::inherits
[17:02:52.730]             invokeRestart <- base::invokeRestart
[17:02:52.730]             length <- base::length
[17:02:52.730]             list <- base::list
[17:02:52.730]             seq.int <- base::seq.int
[17:02:52.730]             signalCondition <- base::signalCondition
[17:02:52.730]             sys.calls <- base::sys.calls
[17:02:52.730]             `[[` <- base::`[[`
[17:02:52.730]             `+` <- base::`+`
[17:02:52.730]             `<<-` <- base::`<<-`
[17:02:52.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.730]                   3L)]
[17:02:52.730]             }
[17:02:52.730]             function(cond) {
[17:02:52.730]                 is_error <- inherits(cond, "error")
[17:02:52.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.730]                   NULL)
[17:02:52.730]                 if (is_error) {
[17:02:52.730]                   sessionInformation <- function() {
[17:02:52.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.730]                       search = base::search(), system = base::Sys.info())
[17:02:52.730]                   }
[17:02:52.730]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.730]                     cond$call), session = sessionInformation(), 
[17:02:52.730]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.730]                   signalCondition(cond)
[17:02:52.730]                 }
[17:02:52.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.730]                 "immediateCondition"))) {
[17:02:52.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.730]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.730]                   if (TRUE && !signal) {
[17:02:52.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.730]                     {
[17:02:52.730]                       inherits <- base::inherits
[17:02:52.730]                       invokeRestart <- base::invokeRestart
[17:02:52.730]                       is.null <- base::is.null
[17:02:52.730]                       muffled <- FALSE
[17:02:52.730]                       if (inherits(cond, "message")) {
[17:02:52.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.730]                         if (muffled) 
[17:02:52.730]                           invokeRestart("muffleMessage")
[17:02:52.730]                       }
[17:02:52.730]                       else if (inherits(cond, "warning")) {
[17:02:52.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.730]                         if (muffled) 
[17:02:52.730]                           invokeRestart("muffleWarning")
[17:02:52.730]                       }
[17:02:52.730]                       else if (inherits(cond, "condition")) {
[17:02:52.730]                         if (!is.null(pattern)) {
[17:02:52.730]                           computeRestarts <- base::computeRestarts
[17:02:52.730]                           grepl <- base::grepl
[17:02:52.730]                           restarts <- computeRestarts(cond)
[17:02:52.730]                           for (restart in restarts) {
[17:02:52.730]                             name <- restart$name
[17:02:52.730]                             if (is.null(name)) 
[17:02:52.730]                               next
[17:02:52.730]                             if (!grepl(pattern, name)) 
[17:02:52.730]                               next
[17:02:52.730]                             invokeRestart(restart)
[17:02:52.730]                             muffled <- TRUE
[17:02:52.730]                             break
[17:02:52.730]                           }
[17:02:52.730]                         }
[17:02:52.730]                       }
[17:02:52.730]                       invisible(muffled)
[17:02:52.730]                     }
[17:02:52.730]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.730]                   }
[17:02:52.730]                 }
[17:02:52.730]                 else {
[17:02:52.730]                   if (TRUE) {
[17:02:52.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.730]                     {
[17:02:52.730]                       inherits <- base::inherits
[17:02:52.730]                       invokeRestart <- base::invokeRestart
[17:02:52.730]                       is.null <- base::is.null
[17:02:52.730]                       muffled <- FALSE
[17:02:52.730]                       if (inherits(cond, "message")) {
[17:02:52.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.730]                         if (muffled) 
[17:02:52.730]                           invokeRestart("muffleMessage")
[17:02:52.730]                       }
[17:02:52.730]                       else if (inherits(cond, "warning")) {
[17:02:52.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.730]                         if (muffled) 
[17:02:52.730]                           invokeRestart("muffleWarning")
[17:02:52.730]                       }
[17:02:52.730]                       else if (inherits(cond, "condition")) {
[17:02:52.730]                         if (!is.null(pattern)) {
[17:02:52.730]                           computeRestarts <- base::computeRestarts
[17:02:52.730]                           grepl <- base::grepl
[17:02:52.730]                           restarts <- computeRestarts(cond)
[17:02:52.730]                           for (restart in restarts) {
[17:02:52.730]                             name <- restart$name
[17:02:52.730]                             if (is.null(name)) 
[17:02:52.730]                               next
[17:02:52.730]                             if (!grepl(pattern, name)) 
[17:02:52.730]                               next
[17:02:52.730]                             invokeRestart(restart)
[17:02:52.730]                             muffled <- TRUE
[17:02:52.730]                             break
[17:02:52.730]                           }
[17:02:52.730]                         }
[17:02:52.730]                       }
[17:02:52.730]                       invisible(muffled)
[17:02:52.730]                     }
[17:02:52.730]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.730]                   }
[17:02:52.730]                 }
[17:02:52.730]             }
[17:02:52.730]         }))
[17:02:52.730]     }, error = function(ex) {
[17:02:52.730]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.730]                 ...future.rng), started = ...future.startTime, 
[17:02:52.730]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.730]             version = "1.8"), class = "FutureResult")
[17:02:52.730]     }, finally = {
[17:02:52.730]         if (!identical(...future.workdir, getwd())) 
[17:02:52.730]             setwd(...future.workdir)
[17:02:52.730]         {
[17:02:52.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.730]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.730]             }
[17:02:52.730]             base::options(...future.oldOptions)
[17:02:52.730]             if (.Platform$OS.type == "windows") {
[17:02:52.730]                 old_names <- names(...future.oldEnvVars)
[17:02:52.730]                 envs <- base::Sys.getenv()
[17:02:52.730]                 names <- names(envs)
[17:02:52.730]                 common <- intersect(names, old_names)
[17:02:52.730]                 added <- setdiff(names, old_names)
[17:02:52.730]                 removed <- setdiff(old_names, names)
[17:02:52.730]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.730]                   envs[common]]
[17:02:52.730]                 NAMES <- toupper(changed)
[17:02:52.730]                 args <- list()
[17:02:52.730]                 for (kk in seq_along(NAMES)) {
[17:02:52.730]                   name <- changed[[kk]]
[17:02:52.730]                   NAME <- NAMES[[kk]]
[17:02:52.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.730]                     next
[17:02:52.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.730]                 }
[17:02:52.730]                 NAMES <- toupper(added)
[17:02:52.730]                 for (kk in seq_along(NAMES)) {
[17:02:52.730]                   name <- added[[kk]]
[17:02:52.730]                   NAME <- NAMES[[kk]]
[17:02:52.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.730]                     next
[17:02:52.730]                   args[[name]] <- ""
[17:02:52.730]                 }
[17:02:52.730]                 NAMES <- toupper(removed)
[17:02:52.730]                 for (kk in seq_along(NAMES)) {
[17:02:52.730]                   name <- removed[[kk]]
[17:02:52.730]                   NAME <- NAMES[[kk]]
[17:02:52.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.730]                     next
[17:02:52.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.730]                 }
[17:02:52.730]                 if (length(args) > 0) 
[17:02:52.730]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.730]             }
[17:02:52.730]             else {
[17:02:52.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.730]             }
[17:02:52.730]             {
[17:02:52.730]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.730]                   0L) {
[17:02:52.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.730]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.730]                   base::options(opts)
[17:02:52.730]                 }
[17:02:52.730]                 {
[17:02:52.730]                   {
[17:02:52.730]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.730]                     NULL
[17:02:52.730]                   }
[17:02:52.730]                   options(future.plan = NULL)
[17:02:52.730]                   if (is.na(NA_character_)) 
[17:02:52.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.730]                     .init = FALSE)
[17:02:52.730]                 }
[17:02:52.730]             }
[17:02:52.730]         }
[17:02:52.730]     })
[17:02:52.730]     if (TRUE) {
[17:02:52.730]         base::sink(type = "output", split = FALSE)
[17:02:52.730]         if (TRUE) {
[17:02:52.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.730]         }
[17:02:52.730]         else {
[17:02:52.730]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.730]         }
[17:02:52.730]         base::close(...future.stdout)
[17:02:52.730]         ...future.stdout <- NULL
[17:02:52.730]     }
[17:02:52.730]     ...future.result$conditions <- ...future.conditions
[17:02:52.730]     ...future.result$finished <- base::Sys.time()
[17:02:52.730]     ...future.result
[17:02:52.730] }
[17:02:52.732] requestCore(): workers = 2
[17:02:52.734] MulticoreFuture started
[17:02:52.735] - Launch lazy future ... done
[17:02:52.735] run() for ‘MulticoreFuture’ ... done
[17:02:52.736] plan(): Setting new future strategy stack:
[17:02:52.736] List of future strategies:
[17:02:52.736] 1. sequential:
[17:02:52.736]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.736]    - tweaked: FALSE
[17:02:52.736]    - call: NULL
[17:02:52.737] plan(): nbrOfWorkers() = 1
[17:02:52.740] plan(): Setting new future strategy stack:
[17:02:52.740] List of future strategies:
[17:02:52.740] 1. multicore:
[17:02:52.740]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.740]    - tweaked: FALSE
[17:02:52.740]    - call: plan(strategy)
[17:02:52.747] plan(): nbrOfWorkers() = 2
[17:02:52.757] Future #1
[17:02:52.757] result() for MulticoreFuture ...
[17:02:52.758] result() for MulticoreFuture ...
[17:02:52.758] result() for MulticoreFuture ... done
[17:02:52.758] result() for MulticoreFuture ... done
[17:02:52.759] result() for MulticoreFuture ...
[17:02:52.759] result() for MulticoreFuture ... done
[17:02:52.759] A MulticoreFuture was resolved
[17:02:52.759]  length: 0 (resolved future 1)
[17:02:52.759] resolve() on list ... DONE
[17:02:52.759] - globals: [1] ‘a’
[17:02:52.760] Resolving futures part of globals (recursively) ... DONE
[17:02:52.762] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[17:02:52.763] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:52.763] - globals: [1] ‘a’
[17:02:52.763] - packages: [1] ‘future’
[17:02:52.764] getGlobalsAndPackages() ... DONE
[17:02:52.764] run() for ‘Future’ ...
[17:02:52.764] - state: ‘created’
[17:02:52.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.769]   - Field: ‘label’
[17:02:52.769]   - Field: ‘local’
[17:02:52.769]   - Field: ‘owner’
[17:02:52.770]   - Field: ‘envir’
[17:02:52.770]   - Field: ‘workers’
[17:02:52.770]   - Field: ‘packages’
[17:02:52.770]   - Field: ‘gc’
[17:02:52.770]   - Field: ‘job’
[17:02:52.770]   - Field: ‘conditions’
[17:02:52.770]   - Field: ‘expr’
[17:02:52.770]   - Field: ‘uuid’
[17:02:52.770]   - Field: ‘seed’
[17:02:52.771]   - Field: ‘version’
[17:02:52.771]   - Field: ‘result’
[17:02:52.771]   - Field: ‘asynchronous’
[17:02:52.771]   - Field: ‘calls’
[17:02:52.771]   - Field: ‘globals’
[17:02:52.771]   - Field: ‘stdout’
[17:02:52.771]   - Field: ‘earlySignal’
[17:02:52.771]   - Field: ‘lazy’
[17:02:52.772]   - Field: ‘state’
[17:02:52.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.772] - Launch lazy future ...
[17:02:52.772] Packages needed by the future expression (n = 1): ‘future’
[17:02:52.772] Packages needed by future strategies (n = 0): <none>
[17:02:52.773] {
[17:02:52.773]     {
[17:02:52.773]         {
[17:02:52.773]             ...future.startTime <- base::Sys.time()
[17:02:52.773]             {
[17:02:52.773]                 {
[17:02:52.773]                   {
[17:02:52.773]                     {
[17:02:52.773]                       {
[17:02:52.773]                         base::local({
[17:02:52.773]                           has_future <- base::requireNamespace("future", 
[17:02:52.773]                             quietly = TRUE)
[17:02:52.773]                           if (has_future) {
[17:02:52.773]                             ns <- base::getNamespace("future")
[17:02:52.773]                             version <- ns[[".package"]][["version"]]
[17:02:52.773]                             if (is.null(version)) 
[17:02:52.773]                               version <- utils::packageVersion("future")
[17:02:52.773]                           }
[17:02:52.773]                           else {
[17:02:52.773]                             version <- NULL
[17:02:52.773]                           }
[17:02:52.773]                           if (!has_future || version < "1.8.0") {
[17:02:52.773]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.773]                               "", base::R.version$version.string), 
[17:02:52.773]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:52.773]                                 base::R.version$platform, 8 * 
[17:02:52.773]                                   base::.Machine$sizeof.pointer), 
[17:02:52.773]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.773]                                 "release", "version")], collapse = " "), 
[17:02:52.773]                               hostname = base::Sys.info()[["nodename"]])
[17:02:52.773]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.773]                               info)
[17:02:52.773]                             info <- base::paste(info, collapse = "; ")
[17:02:52.773]                             if (!has_future) {
[17:02:52.773]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.773]                                 info)
[17:02:52.773]                             }
[17:02:52.773]                             else {
[17:02:52.773]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.773]                                 info, version)
[17:02:52.773]                             }
[17:02:52.773]                             base::stop(msg)
[17:02:52.773]                           }
[17:02:52.773]                         })
[17:02:52.773]                       }
[17:02:52.773]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.773]                       base::options(mc.cores = 1L)
[17:02:52.773]                     }
[17:02:52.773]                     base::local({
[17:02:52.773]                       for (pkg in "future") {
[17:02:52.773]                         base::loadNamespace(pkg)
[17:02:52.773]                         base::library(pkg, character.only = TRUE)
[17:02:52.773]                       }
[17:02:52.773]                     })
[17:02:52.773]                   }
[17:02:52.773]                   ...future.strategy.old <- future::plan("list")
[17:02:52.773]                   options(future.plan = NULL)
[17:02:52.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.773]                 }
[17:02:52.773]                 ...future.workdir <- getwd()
[17:02:52.773]             }
[17:02:52.773]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.773]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.773]         }
[17:02:52.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.773]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.773]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.773]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.773]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.773]             base::names(...future.oldOptions))
[17:02:52.773]     }
[17:02:52.773]     if (FALSE) {
[17:02:52.773]     }
[17:02:52.773]     else {
[17:02:52.773]         if (TRUE) {
[17:02:52.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.773]                 open = "w")
[17:02:52.773]         }
[17:02:52.773]         else {
[17:02:52.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.773]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.773]         }
[17:02:52.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.773]             base::sink(type = "output", split = FALSE)
[17:02:52.773]             base::close(...future.stdout)
[17:02:52.773]         }, add = TRUE)
[17:02:52.773]     }
[17:02:52.773]     ...future.frame <- base::sys.nframe()
[17:02:52.773]     ...future.conditions <- base::list()
[17:02:52.773]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.773]     if (FALSE) {
[17:02:52.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.773]     }
[17:02:52.773]     ...future.result <- base::tryCatch({
[17:02:52.773]         base::withCallingHandlers({
[17:02:52.773]             ...future.value <- base::withVisible(base::local({
[17:02:52.773]                 withCallingHandlers({
[17:02:52.773]                   value(a) + 1
[17:02:52.773]                 }, immediateCondition = function(cond) {
[17:02:52.773]                   save_rds <- function (object, pathname, ...) 
[17:02:52.773]                   {
[17:02:52.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.773]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.773]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.773]                         fi_tmp[["mtime"]])
[17:02:52.773]                     }
[17:02:52.773]                     tryCatch({
[17:02:52.773]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.773]                     }, error = function(ex) {
[17:02:52.773]                       msg <- conditionMessage(ex)
[17:02:52.773]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.773]                         fi_tmp[["mtime"]], msg)
[17:02:52.773]                       ex$message <- msg
[17:02:52.773]                       stop(ex)
[17:02:52.773]                     })
[17:02:52.773]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.773]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.773]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.773]                       fi <- file.info(pathname)
[17:02:52.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.773]                         fi[["size"]], fi[["mtime"]])
[17:02:52.773]                       stop(msg)
[17:02:52.773]                     }
[17:02:52.773]                     invisible(pathname)
[17:02:52.773]                   }
[17:02:52.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.773]                     rootPath = tempdir()) 
[17:02:52.773]                   {
[17:02:52.773]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.773]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.773]                       tmpdir = path, fileext = ".rds")
[17:02:52.773]                     save_rds(obj, file)
[17:02:52.773]                   }
[17:02:52.773]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.773]                   {
[17:02:52.773]                     inherits <- base::inherits
[17:02:52.773]                     invokeRestart <- base::invokeRestart
[17:02:52.773]                     is.null <- base::is.null
[17:02:52.773]                     muffled <- FALSE
[17:02:52.773]                     if (inherits(cond, "message")) {
[17:02:52.773]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.773]                       if (muffled) 
[17:02:52.773]                         invokeRestart("muffleMessage")
[17:02:52.773]                     }
[17:02:52.773]                     else if (inherits(cond, "warning")) {
[17:02:52.773]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.773]                       if (muffled) 
[17:02:52.773]                         invokeRestart("muffleWarning")
[17:02:52.773]                     }
[17:02:52.773]                     else if (inherits(cond, "condition")) {
[17:02:52.773]                       if (!is.null(pattern)) {
[17:02:52.773]                         computeRestarts <- base::computeRestarts
[17:02:52.773]                         grepl <- base::grepl
[17:02:52.773]                         restarts <- computeRestarts(cond)
[17:02:52.773]                         for (restart in restarts) {
[17:02:52.773]                           name <- restart$name
[17:02:52.773]                           if (is.null(name)) 
[17:02:52.773]                             next
[17:02:52.773]                           if (!grepl(pattern, name)) 
[17:02:52.773]                             next
[17:02:52.773]                           invokeRestart(restart)
[17:02:52.773]                           muffled <- TRUE
[17:02:52.773]                           break
[17:02:52.773]                         }
[17:02:52.773]                       }
[17:02:52.773]                     }
[17:02:52.773]                     invisible(muffled)
[17:02:52.773]                   }
[17:02:52.773]                   muffleCondition(cond)
[17:02:52.773]                 })
[17:02:52.773]             }))
[17:02:52.773]             future::FutureResult(value = ...future.value$value, 
[17:02:52.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.773]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.773]                     ...future.globalenv.names))
[17:02:52.773]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.773]         }, condition = base::local({
[17:02:52.773]             c <- base::c
[17:02:52.773]             inherits <- base::inherits
[17:02:52.773]             invokeRestart <- base::invokeRestart
[17:02:52.773]             length <- base::length
[17:02:52.773]             list <- base::list
[17:02:52.773]             seq.int <- base::seq.int
[17:02:52.773]             signalCondition <- base::signalCondition
[17:02:52.773]             sys.calls <- base::sys.calls
[17:02:52.773]             `[[` <- base::`[[`
[17:02:52.773]             `+` <- base::`+`
[17:02:52.773]             `<<-` <- base::`<<-`
[17:02:52.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.773]                   3L)]
[17:02:52.773]             }
[17:02:52.773]             function(cond) {
[17:02:52.773]                 is_error <- inherits(cond, "error")
[17:02:52.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.773]                   NULL)
[17:02:52.773]                 if (is_error) {
[17:02:52.773]                   sessionInformation <- function() {
[17:02:52.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.773]                       search = base::search(), system = base::Sys.info())
[17:02:52.773]                   }
[17:02:52.773]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.773]                     cond$call), session = sessionInformation(), 
[17:02:52.773]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.773]                   signalCondition(cond)
[17:02:52.773]                 }
[17:02:52.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.773]                 "immediateCondition"))) {
[17:02:52.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.773]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.773]                   if (TRUE && !signal) {
[17:02:52.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.773]                     {
[17:02:52.773]                       inherits <- base::inherits
[17:02:52.773]                       invokeRestart <- base::invokeRestart
[17:02:52.773]                       is.null <- base::is.null
[17:02:52.773]                       muffled <- FALSE
[17:02:52.773]                       if (inherits(cond, "message")) {
[17:02:52.773]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.773]                         if (muffled) 
[17:02:52.773]                           invokeRestart("muffleMessage")
[17:02:52.773]                       }
[17:02:52.773]                       else if (inherits(cond, "warning")) {
[17:02:52.773]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.773]                         if (muffled) 
[17:02:52.773]                           invokeRestart("muffleWarning")
[17:02:52.773]                       }
[17:02:52.773]                       else if (inherits(cond, "condition")) {
[17:02:52.773]                         if (!is.null(pattern)) {
[17:02:52.773]                           computeRestarts <- base::computeRestarts
[17:02:52.773]                           grepl <- base::grepl
[17:02:52.773]                           restarts <- computeRestarts(cond)
[17:02:52.773]                           for (restart in restarts) {
[17:02:52.773]                             name <- restart$name
[17:02:52.773]                             if (is.null(name)) 
[17:02:52.773]                               next
[17:02:52.773]                             if (!grepl(pattern, name)) 
[17:02:52.773]                               next
[17:02:52.773]                             invokeRestart(restart)
[17:02:52.773]                             muffled <- TRUE
[17:02:52.773]                             break
[17:02:52.773]                           }
[17:02:52.773]                         }
[17:02:52.773]                       }
[17:02:52.773]                       invisible(muffled)
[17:02:52.773]                     }
[17:02:52.773]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.773]                   }
[17:02:52.773]                 }
[17:02:52.773]                 else {
[17:02:52.773]                   if (TRUE) {
[17:02:52.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.773]                     {
[17:02:52.773]                       inherits <- base::inherits
[17:02:52.773]                       invokeRestart <- base::invokeRestart
[17:02:52.773]                       is.null <- base::is.null
[17:02:52.773]                       muffled <- FALSE
[17:02:52.773]                       if (inherits(cond, "message")) {
[17:02:52.773]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.773]                         if (muffled) 
[17:02:52.773]                           invokeRestart("muffleMessage")
[17:02:52.773]                       }
[17:02:52.773]                       else if (inherits(cond, "warning")) {
[17:02:52.773]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.773]                         if (muffled) 
[17:02:52.773]                           invokeRestart("muffleWarning")
[17:02:52.773]                       }
[17:02:52.773]                       else if (inherits(cond, "condition")) {
[17:02:52.773]                         if (!is.null(pattern)) {
[17:02:52.773]                           computeRestarts <- base::computeRestarts
[17:02:52.773]                           grepl <- base::grepl
[17:02:52.773]                           restarts <- computeRestarts(cond)
[17:02:52.773]                           for (restart in restarts) {
[17:02:52.773]                             name <- restart$name
[17:02:52.773]                             if (is.null(name)) 
[17:02:52.773]                               next
[17:02:52.773]                             if (!grepl(pattern, name)) 
[17:02:52.773]                               next
[17:02:52.773]                             invokeRestart(restart)
[17:02:52.773]                             muffled <- TRUE
[17:02:52.773]                             break
[17:02:52.773]                           }
[17:02:52.773]                         }
[17:02:52.773]                       }
[17:02:52.773]                       invisible(muffled)
[17:02:52.773]                     }
[17:02:52.773]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.773]                   }
[17:02:52.773]                 }
[17:02:52.773]             }
[17:02:52.773]         }))
[17:02:52.773]     }, error = function(ex) {
[17:02:52.773]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.773]                 ...future.rng), started = ...future.startTime, 
[17:02:52.773]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.773]             version = "1.8"), class = "FutureResult")
[17:02:52.773]     }, finally = {
[17:02:52.773]         if (!identical(...future.workdir, getwd())) 
[17:02:52.773]             setwd(...future.workdir)
[17:02:52.773]         {
[17:02:52.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.773]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.773]             }
[17:02:52.773]             base::options(...future.oldOptions)
[17:02:52.773]             if (.Platform$OS.type == "windows") {
[17:02:52.773]                 old_names <- names(...future.oldEnvVars)
[17:02:52.773]                 envs <- base::Sys.getenv()
[17:02:52.773]                 names <- names(envs)
[17:02:52.773]                 common <- intersect(names, old_names)
[17:02:52.773]                 added <- setdiff(names, old_names)
[17:02:52.773]                 removed <- setdiff(old_names, names)
[17:02:52.773]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.773]                   envs[common]]
[17:02:52.773]                 NAMES <- toupper(changed)
[17:02:52.773]                 args <- list()
[17:02:52.773]                 for (kk in seq_along(NAMES)) {
[17:02:52.773]                   name <- changed[[kk]]
[17:02:52.773]                   NAME <- NAMES[[kk]]
[17:02:52.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.773]                     next
[17:02:52.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.773]                 }
[17:02:52.773]                 NAMES <- toupper(added)
[17:02:52.773]                 for (kk in seq_along(NAMES)) {
[17:02:52.773]                   name <- added[[kk]]
[17:02:52.773]                   NAME <- NAMES[[kk]]
[17:02:52.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.773]                     next
[17:02:52.773]                   args[[name]] <- ""
[17:02:52.773]                 }
[17:02:52.773]                 NAMES <- toupper(removed)
[17:02:52.773]                 for (kk in seq_along(NAMES)) {
[17:02:52.773]                   name <- removed[[kk]]
[17:02:52.773]                   NAME <- NAMES[[kk]]
[17:02:52.773]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.773]                     next
[17:02:52.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.773]                 }
[17:02:52.773]                 if (length(args) > 0) 
[17:02:52.773]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.773]             }
[17:02:52.773]             else {
[17:02:52.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.773]             }
[17:02:52.773]             {
[17:02:52.773]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.773]                   0L) {
[17:02:52.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.773]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.773]                   base::options(opts)
[17:02:52.773]                 }
[17:02:52.773]                 {
[17:02:52.773]                   {
[17:02:52.773]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.773]                     NULL
[17:02:52.773]                   }
[17:02:52.773]                   options(future.plan = NULL)
[17:02:52.773]                   if (is.na(NA_character_)) 
[17:02:52.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.773]                     .init = FALSE)
[17:02:52.773]                 }
[17:02:52.773]             }
[17:02:52.773]         }
[17:02:52.773]     })
[17:02:52.773]     if (TRUE) {
[17:02:52.773]         base::sink(type = "output", split = FALSE)
[17:02:52.773]         if (TRUE) {
[17:02:52.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.773]         }
[17:02:52.773]         else {
[17:02:52.773]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.773]         }
[17:02:52.773]         base::close(...future.stdout)
[17:02:52.773]         ...future.stdout <- NULL
[17:02:52.773]     }
[17:02:52.773]     ...future.result$conditions <- ...future.conditions
[17:02:52.773]     ...future.result$finished <- base::Sys.time()
[17:02:52.773]     ...future.result
[17:02:52.773] }
[17:02:52.776] assign_globals() ...
[17:02:52.776] List of 1
[17:02:52.776]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c8f6b4a658> 
[17:02:52.776]  - attr(*, "where")=List of 1
[17:02:52.776]   ..$ a:<environment: R_EmptyEnv> 
[17:02:52.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.776]  - attr(*, "resolved")= logi TRUE
[17:02:52.776]  - attr(*, "total_size")= num 1647648
[17:02:52.776]  - attr(*, "already-done")= logi TRUE
[17:02:52.779] - copied ‘a’ to environment
[17:02:52.779] assign_globals() ... done
[17:02:52.779] requestCore(): workers = 2
[17:02:52.781] MulticoreFuture started
[17:02:52.782] - Launch lazy future ... done
[17:02:52.782] run() for ‘MulticoreFuture’ ... done
[17:02:52.782] result() for MulticoreFuture ...
[17:02:52.783] plan(): Setting new future strategy stack:
[17:02:52.783] List of future strategies:
[17:02:52.783] 1. sequential:
[17:02:52.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.783]    - tweaked: FALSE
[17:02:52.783]    - call: NULL
[17:02:52.784] plan(): nbrOfWorkers() = 1
[17:02:52.788] plan(): Setting new future strategy stack:
[17:02:52.788] List of future strategies:
[17:02:52.788] 1. multicore:
[17:02:52.788]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.788]    - tweaked: FALSE
[17:02:52.788]    - call: plan(strategy)
[17:02:52.799] plan(): nbrOfWorkers() = 2
[17:02:52.800] result() for MulticoreFuture ...
[17:02:52.800] result() for MulticoreFuture ... done
[17:02:52.801] signalConditions() ...
[17:02:52.801]  - include = ‘immediateCondition’
[17:02:52.801]  - exclude = 
[17:02:52.801]  - resignal = FALSE
[17:02:52.801]  - Number of conditions: 4
[17:02:52.801] signalConditions() ... done
[17:02:52.802] result() for MulticoreFuture ... done
[17:02:52.802] result() for MulticoreFuture ...
[17:02:52.802] result() for MulticoreFuture ... done
[17:02:52.802] signalConditions() ...
[17:02:52.802]  - include = ‘immediateCondition’
[17:02:52.802]  - exclude = 
[17:02:52.803]  - resignal = FALSE
[17:02:52.803]  - Number of conditions: 4
[17:02:52.803] signalConditions() ... done
[17:02:52.803] Future state: ‘finished’
[17:02:52.803] result() for MulticoreFuture ...
[17:02:52.804] result() for MulticoreFuture ... done
[17:02:52.804] signalConditions() ...
[17:02:52.804]  - include = ‘condition’
[17:02:52.804]  - exclude = ‘immediateCondition’
[17:02:52.804]  - resignal = TRUE
[17:02:52.804]  - Number of conditions: 4
[17:02:52.804]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.786] result() for MulticoreFuture ...
[17:02:52.807]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.786] result() for MulticoreFuture ... done
[17:02:52.808]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.786] result() for MulticoreFuture ...
[17:02:52.808]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.787] result() for MulticoreFuture ... done
[17:02:52.808] signalConditions() ... done
value(b) = 2
[17:02:52.808] result() for MulticoreFuture ...
[17:02:52.809] result() for MulticoreFuture ... done
[17:02:52.809] result() for MulticoreFuture ...
[17:02:52.809] result() for MulticoreFuture ... done
[17:02:52.809] signalConditions() ...
[17:02:52.809]  - include = ‘immediateCondition’
[17:02:52.809]  - exclude = 
[17:02:52.809]  - resignal = FALSE
[17:02:52.809]  - Number of conditions: 4
[17:02:52.810] signalConditions() ... done
[17:02:52.810] Future state: ‘finished’
[17:02:52.810] result() for MulticoreFuture ...
[17:02:52.810] result() for MulticoreFuture ... done
[17:02:52.810] signalConditions() ...
[17:02:52.810]  - include = ‘condition’
[17:02:52.810]  - exclude = ‘immediateCondition’
[17:02:52.810]  - resignal = TRUE
[17:02:52.811]  - Number of conditions: 4
[17:02:52.811]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.786] result() for MulticoreFuture ...
[17:02:52.811]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.786] result() for MulticoreFuture ... done
[17:02:52.811]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.786] result() for MulticoreFuture ...
[17:02:52.811]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:02:52.787] result() for MulticoreFuture ... done
[17:02:52.811] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.812] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.812] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.813] - globals found: [2] ‘{’, ‘pkg’
[17:02:52.814] Searching for globals ... DONE
[17:02:52.814] Resolving globals: TRUE
[17:02:52.814] Resolving any globals that are futures ...
[17:02:52.814] - globals: [2] ‘{’, ‘pkg’
[17:02:52.814] Resolving any globals that are futures ... DONE
[17:02:52.815] Resolving futures part of globals (recursively) ...
[17:02:52.815] resolve() on list ...
[17:02:52.815]  recursive: 99
[17:02:52.816]  length: 1
[17:02:52.816]  elements: ‘pkg’
[17:02:52.816]  length: 0 (resolved future 1)
[17:02:52.816] resolve() on list ... DONE
[17:02:52.816] - globals: [1] ‘pkg’
[17:02:52.816] Resolving futures part of globals (recursively) ... DONE
[17:02:52.816] The total size of the 1 globals is 112 bytes (112 bytes)
[17:02:52.817] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:02:52.817] - globals: [1] ‘pkg’
[17:02:52.817] 
[17:02:52.817] getGlobalsAndPackages() ... DONE
[17:02:52.818] Packages needed by the future expression (n = 0): <none>
[17:02:52.818] Packages needed by future strategies (n = 0): <none>
[17:02:52.818] {
[17:02:52.818]     {
[17:02:52.818]         {
[17:02:52.818]             ...future.startTime <- base::Sys.time()
[17:02:52.818]             {
[17:02:52.818]                 {
[17:02:52.818]                   {
[17:02:52.818]                     base::local({
[17:02:52.818]                       has_future <- base::requireNamespace("future", 
[17:02:52.818]                         quietly = TRUE)
[17:02:52.818]                       if (has_future) {
[17:02:52.818]                         ns <- base::getNamespace("future")
[17:02:52.818]                         version <- ns[[".package"]][["version"]]
[17:02:52.818]                         if (is.null(version)) 
[17:02:52.818]                           version <- utils::packageVersion("future")
[17:02:52.818]                       }
[17:02:52.818]                       else {
[17:02:52.818]                         version <- NULL
[17:02:52.818]                       }
[17:02:52.818]                       if (!has_future || version < "1.8.0") {
[17:02:52.818]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.818]                           "", base::R.version$version.string), 
[17:02:52.818]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:52.818]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.818]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.818]                             "release", "version")], collapse = " "), 
[17:02:52.818]                           hostname = base::Sys.info()[["nodename"]])
[17:02:52.818]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.818]                           info)
[17:02:52.818]                         info <- base::paste(info, collapse = "; ")
[17:02:52.818]                         if (!has_future) {
[17:02:52.818]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.818]                             info)
[17:02:52.818]                         }
[17:02:52.818]                         else {
[17:02:52.818]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.818]                             info, version)
[17:02:52.818]                         }
[17:02:52.818]                         base::stop(msg)
[17:02:52.818]                       }
[17:02:52.818]                     })
[17:02:52.818]                   }
[17:02:52.818]                   ...future.strategy.old <- future::plan("list")
[17:02:52.818]                   options(future.plan = NULL)
[17:02:52.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.818]                 }
[17:02:52.818]                 ...future.workdir <- getwd()
[17:02:52.818]             }
[17:02:52.818]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.818]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.818]         }
[17:02:52.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.818]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.818]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.818]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.818]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.818]             base::names(...future.oldOptions))
[17:02:52.818]     }
[17:02:52.818]     if (FALSE) {
[17:02:52.818]     }
[17:02:52.818]     else {
[17:02:52.818]         if (TRUE) {
[17:02:52.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.818]                 open = "w")
[17:02:52.818]         }
[17:02:52.818]         else {
[17:02:52.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.818]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.818]         }
[17:02:52.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.818]             base::sink(type = "output", split = FALSE)
[17:02:52.818]             base::close(...future.stdout)
[17:02:52.818]         }, add = TRUE)
[17:02:52.818]     }
[17:02:52.818]     ...future.frame <- base::sys.nframe()
[17:02:52.818]     ...future.conditions <- base::list()
[17:02:52.818]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.818]     if (FALSE) {
[17:02:52.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.818]     }
[17:02:52.818]     ...future.result <- base::tryCatch({
[17:02:52.818]         base::withCallingHandlers({
[17:02:52.818]             ...future.value <- base::withVisible(base::local({
[17:02:52.818]                 pkg
[17:02:52.818]             }))
[17:02:52.818]             future::FutureResult(value = ...future.value$value, 
[17:02:52.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.818]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.818]                     ...future.globalenv.names))
[17:02:52.818]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.818]         }, condition = base::local({
[17:02:52.818]             c <- base::c
[17:02:52.818]             inherits <- base::inherits
[17:02:52.818]             invokeRestart <- base::invokeRestart
[17:02:52.818]             length <- base::length
[17:02:52.818]             list <- base::list
[17:02:52.818]             seq.int <- base::seq.int
[17:02:52.818]             signalCondition <- base::signalCondition
[17:02:52.818]             sys.calls <- base::sys.calls
[17:02:52.818]             `[[` <- base::`[[`
[17:02:52.818]             `+` <- base::`+`
[17:02:52.818]             `<<-` <- base::`<<-`
[17:02:52.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.818]                   3L)]
[17:02:52.818]             }
[17:02:52.818]             function(cond) {
[17:02:52.818]                 is_error <- inherits(cond, "error")
[17:02:52.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.818]                   NULL)
[17:02:52.818]                 if (is_error) {
[17:02:52.818]                   sessionInformation <- function() {
[17:02:52.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.818]                       search = base::search(), system = base::Sys.info())
[17:02:52.818]                   }
[17:02:52.818]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.818]                     cond$call), session = sessionInformation(), 
[17:02:52.818]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.818]                   signalCondition(cond)
[17:02:52.818]                 }
[17:02:52.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.818]                 "immediateCondition"))) {
[17:02:52.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.818]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.818]                   if (TRUE && !signal) {
[17:02:52.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.818]                     {
[17:02:52.818]                       inherits <- base::inherits
[17:02:52.818]                       invokeRestart <- base::invokeRestart
[17:02:52.818]                       is.null <- base::is.null
[17:02:52.818]                       muffled <- FALSE
[17:02:52.818]                       if (inherits(cond, "message")) {
[17:02:52.818]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.818]                         if (muffled) 
[17:02:52.818]                           invokeRestart("muffleMessage")
[17:02:52.818]                       }
[17:02:52.818]                       else if (inherits(cond, "warning")) {
[17:02:52.818]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.818]                         if (muffled) 
[17:02:52.818]                           invokeRestart("muffleWarning")
[17:02:52.818]                       }
[17:02:52.818]                       else if (inherits(cond, "condition")) {
[17:02:52.818]                         if (!is.null(pattern)) {
[17:02:52.818]                           computeRestarts <- base::computeRestarts
[17:02:52.818]                           grepl <- base::grepl
[17:02:52.818]                           restarts <- computeRestarts(cond)
[17:02:52.818]                           for (restart in restarts) {
[17:02:52.818]                             name <- restart$name
[17:02:52.818]                             if (is.null(name)) 
[17:02:52.818]                               next
[17:02:52.818]                             if (!grepl(pattern, name)) 
[17:02:52.818]                               next
[17:02:52.818]                             invokeRestart(restart)
[17:02:52.818]                             muffled <- TRUE
[17:02:52.818]                             break
[17:02:52.818]                           }
[17:02:52.818]                         }
[17:02:52.818]                       }
[17:02:52.818]                       invisible(muffled)
[17:02:52.818]                     }
[17:02:52.818]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.818]                   }
[17:02:52.818]                 }
[17:02:52.818]                 else {
[17:02:52.818]                   if (TRUE) {
[17:02:52.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.818]                     {
[17:02:52.818]                       inherits <- base::inherits
[17:02:52.818]                       invokeRestart <- base::invokeRestart
[17:02:52.818]                       is.null <- base::is.null
[17:02:52.818]                       muffled <- FALSE
[17:02:52.818]                       if (inherits(cond, "message")) {
[17:02:52.818]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.818]                         if (muffled) 
[17:02:52.818]                           invokeRestart("muffleMessage")
[17:02:52.818]                       }
[17:02:52.818]                       else if (inherits(cond, "warning")) {
[17:02:52.818]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.818]                         if (muffled) 
[17:02:52.818]                           invokeRestart("muffleWarning")
[17:02:52.818]                       }
[17:02:52.818]                       else if (inherits(cond, "condition")) {
[17:02:52.818]                         if (!is.null(pattern)) {
[17:02:52.818]                           computeRestarts <- base::computeRestarts
[17:02:52.818]                           grepl <- base::grepl
[17:02:52.818]                           restarts <- computeRestarts(cond)
[17:02:52.818]                           for (restart in restarts) {
[17:02:52.818]                             name <- restart$name
[17:02:52.818]                             if (is.null(name)) 
[17:02:52.818]                               next
[17:02:52.818]                             if (!grepl(pattern, name)) 
[17:02:52.818]                               next
[17:02:52.818]                             invokeRestart(restart)
[17:02:52.818]                             muffled <- TRUE
[17:02:52.818]                             break
[17:02:52.818]                           }
[17:02:52.818]                         }
[17:02:52.818]                       }
[17:02:52.818]                       invisible(muffled)
[17:02:52.818]                     }
[17:02:52.818]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.818]                   }
[17:02:52.818]                 }
[17:02:52.818]             }
[17:02:52.818]         }))
[17:02:52.818]     }, error = function(ex) {
[17:02:52.818]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.818]                 ...future.rng), started = ...future.startTime, 
[17:02:52.818]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.818]             version = "1.8"), class = "FutureResult")
[17:02:52.818]     }, finally = {
[17:02:52.818]         if (!identical(...future.workdir, getwd())) 
[17:02:52.818]             setwd(...future.workdir)
[17:02:52.818]         {
[17:02:52.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.818]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.818]             }
[17:02:52.818]             base::options(...future.oldOptions)
[17:02:52.818]             if (.Platform$OS.type == "windows") {
[17:02:52.818]                 old_names <- names(...future.oldEnvVars)
[17:02:52.818]                 envs <- base::Sys.getenv()
[17:02:52.818]                 names <- names(envs)
[17:02:52.818]                 common <- intersect(names, old_names)
[17:02:52.818]                 added <- setdiff(names, old_names)
[17:02:52.818]                 removed <- setdiff(old_names, names)
[17:02:52.818]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.818]                   envs[common]]
[17:02:52.818]                 NAMES <- toupper(changed)
[17:02:52.818]                 args <- list()
[17:02:52.818]                 for (kk in seq_along(NAMES)) {
[17:02:52.818]                   name <- changed[[kk]]
[17:02:52.818]                   NAME <- NAMES[[kk]]
[17:02:52.818]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.818]                     next
[17:02:52.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.818]                 }
[17:02:52.818]                 NAMES <- toupper(added)
[17:02:52.818]                 for (kk in seq_along(NAMES)) {
[17:02:52.818]                   name <- added[[kk]]
[17:02:52.818]                   NAME <- NAMES[[kk]]
[17:02:52.818]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.818]                     next
[17:02:52.818]                   args[[name]] <- ""
[17:02:52.818]                 }
[17:02:52.818]                 NAMES <- toupper(removed)
[17:02:52.818]                 for (kk in seq_along(NAMES)) {
[17:02:52.818]                   name <- removed[[kk]]
[17:02:52.818]                   NAME <- NAMES[[kk]]
[17:02:52.818]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.818]                     next
[17:02:52.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.818]                 }
[17:02:52.818]                 if (length(args) > 0) 
[17:02:52.818]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.818]             }
[17:02:52.818]             else {
[17:02:52.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.818]             }
[17:02:52.818]             {
[17:02:52.818]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.818]                   0L) {
[17:02:52.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.818]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.818]                   base::options(opts)
[17:02:52.818]                 }
[17:02:52.818]                 {
[17:02:52.818]                   {
[17:02:52.818]                     NULL
[17:02:52.818]                     RNGkind("Mersenne-Twister")
[17:02:52.818]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:52.818]                       inherits = FALSE)
[17:02:52.818]                   }
[17:02:52.818]                   options(future.plan = NULL)
[17:02:52.818]                   if (is.na(NA_character_)) 
[17:02:52.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.818]                     .init = FALSE)
[17:02:52.818]                 }
[17:02:52.818]             }
[17:02:52.818]         }
[17:02:52.818]     })
[17:02:52.818]     if (TRUE) {
[17:02:52.818]         base::sink(type = "output", split = FALSE)
[17:02:52.818]         if (TRUE) {
[17:02:52.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.818]         }
[17:02:52.818]         else {
[17:02:52.818]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.818]         }
[17:02:52.818]         base::close(...future.stdout)
[17:02:52.818]         ...future.stdout <- NULL
[17:02:52.818]     }
[17:02:52.818]     ...future.result$conditions <- ...future.conditions
[17:02:52.818]     ...future.result$finished <- base::Sys.time()
[17:02:52.818]     ...future.result
[17:02:52.818] }
[17:02:52.820] assign_globals() ...
[17:02:52.820] List of 1
[17:02:52.820]  $ pkg: chr "foo"
[17:02:52.820]  - attr(*, "where")=List of 1
[17:02:52.820]   ..$ pkg:<environment: R_EmptyEnv> 
[17:02:52.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.820]  - attr(*, "resolved")= logi TRUE
[17:02:52.820]  - attr(*, "total_size")= num 112
[17:02:52.823] - copied ‘pkg’ to environment
[17:02:52.823] assign_globals() ... done
[17:02:52.823] plan(): Setting new future strategy stack:
[17:02:52.823] List of future strategies:
[17:02:52.823] 1. sequential:
[17:02:52.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.823]    - tweaked: FALSE
[17:02:52.823]    - call: NULL
[17:02:52.824] plan(): nbrOfWorkers() = 1
[17:02:52.825] plan(): Setting new future strategy stack:
[17:02:52.825] List of future strategies:
[17:02:52.825] 1. multicore:
[17:02:52.825]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.825]    - tweaked: FALSE
[17:02:52.825]    - call: plan(strategy)
[17:02:52.829] plan(): nbrOfWorkers() = 2
[17:02:52.829] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.830] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.830] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.833] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:02:52.833] Searching for globals ... DONE
[17:02:52.833] Resolving globals: TRUE
[17:02:52.833] Resolving any globals that are futures ...
[17:02:52.833] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:02:52.833] Resolving any globals that are futures ... DONE
[17:02:52.833] 
[17:02:52.834] 
[17:02:52.834] getGlobalsAndPackages() ... DONE
[17:02:52.834] run() for ‘Future’ ...
[17:02:52.834] - state: ‘created’
[17:02:52.834] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.838] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.838]   - Field: ‘label’
[17:02:52.838]   - Field: ‘local’
[17:02:52.838]   - Field: ‘owner’
[17:02:52.839]   - Field: ‘envir’
[17:02:52.839]   - Field: ‘workers’
[17:02:52.839]   - Field: ‘packages’
[17:02:52.839]   - Field: ‘gc’
[17:02:52.839]   - Field: ‘job’
[17:02:52.839]   - Field: ‘conditions’
[17:02:52.839]   - Field: ‘expr’
[17:02:52.839]   - Field: ‘uuid’
[17:02:52.839]   - Field: ‘seed’
[17:02:52.839]   - Field: ‘version’
[17:02:52.840]   - Field: ‘result’
[17:02:52.840]   - Field: ‘asynchronous’
[17:02:52.840]   - Field: ‘calls’
[17:02:52.840]   - Field: ‘globals’
[17:02:52.840]   - Field: ‘stdout’
[17:02:52.840]   - Field: ‘earlySignal’
[17:02:52.840]   - Field: ‘lazy’
[17:02:52.840]   - Field: ‘state’
[17:02:52.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.840] - Launch lazy future ...
[17:02:52.841] Packages needed by the future expression (n = 0): <none>
[17:02:52.841] Packages needed by future strategies (n = 0): <none>
[17:02:52.841] {
[17:02:52.841]     {
[17:02:52.841]         {
[17:02:52.841]             ...future.startTime <- base::Sys.time()
[17:02:52.841]             {
[17:02:52.841]                 {
[17:02:52.841]                   {
[17:02:52.841]                     {
[17:02:52.841]                       base::local({
[17:02:52.841]                         has_future <- base::requireNamespace("future", 
[17:02:52.841]                           quietly = TRUE)
[17:02:52.841]                         if (has_future) {
[17:02:52.841]                           ns <- base::getNamespace("future")
[17:02:52.841]                           version <- ns[[".package"]][["version"]]
[17:02:52.841]                           if (is.null(version)) 
[17:02:52.841]                             version <- utils::packageVersion("future")
[17:02:52.841]                         }
[17:02:52.841]                         else {
[17:02:52.841]                           version <- NULL
[17:02:52.841]                         }
[17:02:52.841]                         if (!has_future || version < "1.8.0") {
[17:02:52.841]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.841]                             "", base::R.version$version.string), 
[17:02:52.841]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.841]                               "release", "version")], collapse = " "), 
[17:02:52.841]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.841]                             info)
[17:02:52.841]                           info <- base::paste(info, collapse = "; ")
[17:02:52.841]                           if (!has_future) {
[17:02:52.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.841]                               info)
[17:02:52.841]                           }
[17:02:52.841]                           else {
[17:02:52.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.841]                               info, version)
[17:02:52.841]                           }
[17:02:52.841]                           base::stop(msg)
[17:02:52.841]                         }
[17:02:52.841]                       })
[17:02:52.841]                     }
[17:02:52.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.841]                     base::options(mc.cores = 1L)
[17:02:52.841]                   }
[17:02:52.841]                   ...future.strategy.old <- future::plan("list")
[17:02:52.841]                   options(future.plan = NULL)
[17:02:52.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.841]                 }
[17:02:52.841]                 ...future.workdir <- getwd()
[17:02:52.841]             }
[17:02:52.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.841]         }
[17:02:52.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.841]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.841]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.841]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.841]             base::names(...future.oldOptions))
[17:02:52.841]     }
[17:02:52.841]     if (FALSE) {
[17:02:52.841]     }
[17:02:52.841]     else {
[17:02:52.841]         if (TRUE) {
[17:02:52.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.841]                 open = "w")
[17:02:52.841]         }
[17:02:52.841]         else {
[17:02:52.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.841]         }
[17:02:52.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.841]             base::sink(type = "output", split = FALSE)
[17:02:52.841]             base::close(...future.stdout)
[17:02:52.841]         }, add = TRUE)
[17:02:52.841]     }
[17:02:52.841]     ...future.frame <- base::sys.nframe()
[17:02:52.841]     ...future.conditions <- base::list()
[17:02:52.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.841]     if (FALSE) {
[17:02:52.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.841]     }
[17:02:52.841]     ...future.result <- base::tryCatch({
[17:02:52.841]         base::withCallingHandlers({
[17:02:52.841]             ...future.value <- base::withVisible(base::local({
[17:02:52.841]                 withCallingHandlers({
[17:02:52.841]                   {
[17:02:52.841]                     x <- 0
[17:02:52.841]                     x <- x + 1
[17:02:52.841]                     x
[17:02:52.841]                   }
[17:02:52.841]                 }, immediateCondition = function(cond) {
[17:02:52.841]                   save_rds <- function (object, pathname, ...) 
[17:02:52.841]                   {
[17:02:52.841]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.841]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.841]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.841]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.841]                         fi_tmp[["mtime"]])
[17:02:52.841]                     }
[17:02:52.841]                     tryCatch({
[17:02:52.841]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.841]                     }, error = function(ex) {
[17:02:52.841]                       msg <- conditionMessage(ex)
[17:02:52.841]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.841]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.841]                         fi_tmp[["mtime"]], msg)
[17:02:52.841]                       ex$message <- msg
[17:02:52.841]                       stop(ex)
[17:02:52.841]                     })
[17:02:52.841]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.841]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.841]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.841]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.841]                       fi <- file.info(pathname)
[17:02:52.841]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.841]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.841]                         fi[["size"]], fi[["mtime"]])
[17:02:52.841]                       stop(msg)
[17:02:52.841]                     }
[17:02:52.841]                     invisible(pathname)
[17:02:52.841]                   }
[17:02:52.841]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.841]                     rootPath = tempdir()) 
[17:02:52.841]                   {
[17:02:52.841]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.841]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.841]                       tmpdir = path, fileext = ".rds")
[17:02:52.841]                     save_rds(obj, file)
[17:02:52.841]                   }
[17:02:52.841]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.841]                   {
[17:02:52.841]                     inherits <- base::inherits
[17:02:52.841]                     invokeRestart <- base::invokeRestart
[17:02:52.841]                     is.null <- base::is.null
[17:02:52.841]                     muffled <- FALSE
[17:02:52.841]                     if (inherits(cond, "message")) {
[17:02:52.841]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.841]                       if (muffled) 
[17:02:52.841]                         invokeRestart("muffleMessage")
[17:02:52.841]                     }
[17:02:52.841]                     else if (inherits(cond, "warning")) {
[17:02:52.841]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.841]                       if (muffled) 
[17:02:52.841]                         invokeRestart("muffleWarning")
[17:02:52.841]                     }
[17:02:52.841]                     else if (inherits(cond, "condition")) {
[17:02:52.841]                       if (!is.null(pattern)) {
[17:02:52.841]                         computeRestarts <- base::computeRestarts
[17:02:52.841]                         grepl <- base::grepl
[17:02:52.841]                         restarts <- computeRestarts(cond)
[17:02:52.841]                         for (restart in restarts) {
[17:02:52.841]                           name <- restart$name
[17:02:52.841]                           if (is.null(name)) 
[17:02:52.841]                             next
[17:02:52.841]                           if (!grepl(pattern, name)) 
[17:02:52.841]                             next
[17:02:52.841]                           invokeRestart(restart)
[17:02:52.841]                           muffled <- TRUE
[17:02:52.841]                           break
[17:02:52.841]                         }
[17:02:52.841]                       }
[17:02:52.841]                     }
[17:02:52.841]                     invisible(muffled)
[17:02:52.841]                   }
[17:02:52.841]                   muffleCondition(cond)
[17:02:52.841]                 })
[17:02:52.841]             }))
[17:02:52.841]             future::FutureResult(value = ...future.value$value, 
[17:02:52.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.841]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.841]                     ...future.globalenv.names))
[17:02:52.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.841]         }, condition = base::local({
[17:02:52.841]             c <- base::c
[17:02:52.841]             inherits <- base::inherits
[17:02:52.841]             invokeRestart <- base::invokeRestart
[17:02:52.841]             length <- base::length
[17:02:52.841]             list <- base::list
[17:02:52.841]             seq.int <- base::seq.int
[17:02:52.841]             signalCondition <- base::signalCondition
[17:02:52.841]             sys.calls <- base::sys.calls
[17:02:52.841]             `[[` <- base::`[[`
[17:02:52.841]             `+` <- base::`+`
[17:02:52.841]             `<<-` <- base::`<<-`
[17:02:52.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.841]                   3L)]
[17:02:52.841]             }
[17:02:52.841]             function(cond) {
[17:02:52.841]                 is_error <- inherits(cond, "error")
[17:02:52.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.841]                   NULL)
[17:02:52.841]                 if (is_error) {
[17:02:52.841]                   sessionInformation <- function() {
[17:02:52.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.841]                       search = base::search(), system = base::Sys.info())
[17:02:52.841]                   }
[17:02:52.841]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.841]                     cond$call), session = sessionInformation(), 
[17:02:52.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.841]                   signalCondition(cond)
[17:02:52.841]                 }
[17:02:52.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.841]                 "immediateCondition"))) {
[17:02:52.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.841]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.841]                   if (TRUE && !signal) {
[17:02:52.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.841]                     {
[17:02:52.841]                       inherits <- base::inherits
[17:02:52.841]                       invokeRestart <- base::invokeRestart
[17:02:52.841]                       is.null <- base::is.null
[17:02:52.841]                       muffled <- FALSE
[17:02:52.841]                       if (inherits(cond, "message")) {
[17:02:52.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.841]                         if (muffled) 
[17:02:52.841]                           invokeRestart("muffleMessage")
[17:02:52.841]                       }
[17:02:52.841]                       else if (inherits(cond, "warning")) {
[17:02:52.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.841]                         if (muffled) 
[17:02:52.841]                           invokeRestart("muffleWarning")
[17:02:52.841]                       }
[17:02:52.841]                       else if (inherits(cond, "condition")) {
[17:02:52.841]                         if (!is.null(pattern)) {
[17:02:52.841]                           computeRestarts <- base::computeRestarts
[17:02:52.841]                           grepl <- base::grepl
[17:02:52.841]                           restarts <- computeRestarts(cond)
[17:02:52.841]                           for (restart in restarts) {
[17:02:52.841]                             name <- restart$name
[17:02:52.841]                             if (is.null(name)) 
[17:02:52.841]                               next
[17:02:52.841]                             if (!grepl(pattern, name)) 
[17:02:52.841]                               next
[17:02:52.841]                             invokeRestart(restart)
[17:02:52.841]                             muffled <- TRUE
[17:02:52.841]                             break
[17:02:52.841]                           }
[17:02:52.841]                         }
[17:02:52.841]                       }
[17:02:52.841]                       invisible(muffled)
[17:02:52.841]                     }
[17:02:52.841]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.841]                   }
[17:02:52.841]                 }
[17:02:52.841]                 else {
[17:02:52.841]                   if (TRUE) {
[17:02:52.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.841]                     {
[17:02:52.841]                       inherits <- base::inherits
[17:02:52.841]                       invokeRestart <- base::invokeRestart
[17:02:52.841]                       is.null <- base::is.null
[17:02:52.841]                       muffled <- FALSE
[17:02:52.841]                       if (inherits(cond, "message")) {
[17:02:52.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.841]                         if (muffled) 
[17:02:52.841]                           invokeRestart("muffleMessage")
[17:02:52.841]                       }
[17:02:52.841]                       else if (inherits(cond, "warning")) {
[17:02:52.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.841]                         if (muffled) 
[17:02:52.841]                           invokeRestart("muffleWarning")
[17:02:52.841]                       }
[17:02:52.841]                       else if (inherits(cond, "condition")) {
[17:02:52.841]                         if (!is.null(pattern)) {
[17:02:52.841]                           computeRestarts <- base::computeRestarts
[17:02:52.841]                           grepl <- base::grepl
[17:02:52.841]                           restarts <- computeRestarts(cond)
[17:02:52.841]                           for (restart in restarts) {
[17:02:52.841]                             name <- restart$name
[17:02:52.841]                             if (is.null(name)) 
[17:02:52.841]                               next
[17:02:52.841]                             if (!grepl(pattern, name)) 
[17:02:52.841]                               next
[17:02:52.841]                             invokeRestart(restart)
[17:02:52.841]                             muffled <- TRUE
[17:02:52.841]                             break
[17:02:52.841]                           }
[17:02:52.841]                         }
[17:02:52.841]                       }
[17:02:52.841]                       invisible(muffled)
[17:02:52.841]                     }
[17:02:52.841]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.841]                   }
[17:02:52.841]                 }
[17:02:52.841]             }
[17:02:52.841]         }))
[17:02:52.841]     }, error = function(ex) {
[17:02:52.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.841]                 ...future.rng), started = ...future.startTime, 
[17:02:52.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.841]             version = "1.8"), class = "FutureResult")
[17:02:52.841]     }, finally = {
[17:02:52.841]         if (!identical(...future.workdir, getwd())) 
[17:02:52.841]             setwd(...future.workdir)
[17:02:52.841]         {
[17:02:52.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.841]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.841]             }
[17:02:52.841]             base::options(...future.oldOptions)
[17:02:52.841]             if (.Platform$OS.type == "windows") {
[17:02:52.841]                 old_names <- names(...future.oldEnvVars)
[17:02:52.841]                 envs <- base::Sys.getenv()
[17:02:52.841]                 names <- names(envs)
[17:02:52.841]                 common <- intersect(names, old_names)
[17:02:52.841]                 added <- setdiff(names, old_names)
[17:02:52.841]                 removed <- setdiff(old_names, names)
[17:02:52.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.841]                   envs[common]]
[17:02:52.841]                 NAMES <- toupper(changed)
[17:02:52.841]                 args <- list()
[17:02:52.841]                 for (kk in seq_along(NAMES)) {
[17:02:52.841]                   name <- changed[[kk]]
[17:02:52.841]                   NAME <- NAMES[[kk]]
[17:02:52.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.841]                     next
[17:02:52.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.841]                 }
[17:02:52.841]                 NAMES <- toupper(added)
[17:02:52.841]                 for (kk in seq_along(NAMES)) {
[17:02:52.841]                   name <- added[[kk]]
[17:02:52.841]                   NAME <- NAMES[[kk]]
[17:02:52.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.841]                     next
[17:02:52.841]                   args[[name]] <- ""
[17:02:52.841]                 }
[17:02:52.841]                 NAMES <- toupper(removed)
[17:02:52.841]                 for (kk in seq_along(NAMES)) {
[17:02:52.841]                   name <- removed[[kk]]
[17:02:52.841]                   NAME <- NAMES[[kk]]
[17:02:52.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.841]                     next
[17:02:52.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.841]                 }
[17:02:52.841]                 if (length(args) > 0) 
[17:02:52.841]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.841]             }
[17:02:52.841]             else {
[17:02:52.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.841]             }
[17:02:52.841]             {
[17:02:52.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.841]                   0L) {
[17:02:52.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.841]                   base::options(opts)
[17:02:52.841]                 }
[17:02:52.841]                 {
[17:02:52.841]                   {
[17:02:52.841]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.841]                     NULL
[17:02:52.841]                   }
[17:02:52.841]                   options(future.plan = NULL)
[17:02:52.841]                   if (is.na(NA_character_)) 
[17:02:52.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.841]                     .init = FALSE)
[17:02:52.841]                 }
[17:02:52.841]             }
[17:02:52.841]         }
[17:02:52.841]     })
[17:02:52.841]     if (TRUE) {
[17:02:52.841]         base::sink(type = "output", split = FALSE)
[17:02:52.841]         if (TRUE) {
[17:02:52.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.841]         }
[17:02:52.841]         else {
[17:02:52.841]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.841]         }
[17:02:52.841]         base::close(...future.stdout)
[17:02:52.841]         ...future.stdout <- NULL
[17:02:52.841]     }
[17:02:52.841]     ...future.result$conditions <- ...future.conditions
[17:02:52.841]     ...future.result$finished <- base::Sys.time()
[17:02:52.841]     ...future.result
[17:02:52.841] }
[17:02:52.844] requestCore(): workers = 2
[17:02:52.846] MulticoreFuture started
[17:02:52.846] - Launch lazy future ... done
[17:02:52.846] run() for ‘MulticoreFuture’ ... done
[17:02:52.847] plan(): Setting new future strategy stack:
[17:02:52.847] result() for MulticoreFuture ...
[17:02:52.847] List of future strategies:
[17:02:52.847] 1. sequential:
[17:02:52.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.847]    - tweaked: FALSE
[17:02:52.847]    - call: NULL
[17:02:52.853] plan(): nbrOfWorkers() = 1
[17:02:52.855] plan(): Setting new future strategy stack:
[17:02:52.856] List of future strategies:
[17:02:52.856] 1. multicore:
[17:02:52.856]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.856]    - tweaked: FALSE
[17:02:52.856]    - call: plan(strategy)
[17:02:52.861] plan(): nbrOfWorkers() = 2
[17:02:52.862] result() for MulticoreFuture ...
[17:02:52.862] result() for MulticoreFuture ... done
[17:02:52.862] result() for MulticoreFuture ... done
[17:02:52.863] result() for MulticoreFuture ...
[17:02:52.863] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.863] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.864] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.866] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:02:52.866] Searching for globals ... DONE
[17:02:52.866] Resolving globals: TRUE
[17:02:52.867] Resolving any globals that are futures ...
[17:02:52.867] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:02:52.867] Resolving any globals that are futures ... DONE
[17:02:52.868] Resolving futures part of globals (recursively) ...
[17:02:52.868] resolve() on list ...
[17:02:52.868]  recursive: 99
[17:02:52.868]  length: 1
[17:02:52.868]  elements: ‘x’
[17:02:52.869]  length: 0 (resolved future 1)
[17:02:52.869] resolve() on list ... DONE
[17:02:52.869] - globals: [1] ‘x’
[17:02:52.869] Resolving futures part of globals (recursively) ... DONE
[17:02:52.869] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:52.870] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:02:52.870] - globals: [1] ‘x’
[17:02:52.870] 
[17:02:52.870] getGlobalsAndPackages() ... DONE
[17:02:52.871] run() for ‘Future’ ...
[17:02:52.871] - state: ‘created’
[17:02:52.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.876] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.876]   - Field: ‘label’
[17:02:52.876]   - Field: ‘local’
[17:02:52.876]   - Field: ‘owner’
[17:02:52.877]   - Field: ‘envir’
[17:02:52.877]   - Field: ‘workers’
[17:02:52.877]   - Field: ‘packages’
[17:02:52.877]   - Field: ‘gc’
[17:02:52.877]   - Field: ‘job’
[17:02:52.877]   - Field: ‘conditions’
[17:02:52.877]   - Field: ‘expr’
[17:02:52.877]   - Field: ‘uuid’
[17:02:52.878]   - Field: ‘seed’
[17:02:52.878]   - Field: ‘version’
[17:02:52.878]   - Field: ‘result’
[17:02:52.878]   - Field: ‘asynchronous’
[17:02:52.878]   - Field: ‘calls’
[17:02:52.878]   - Field: ‘globals’
[17:02:52.878]   - Field: ‘stdout’
[17:02:52.878]   - Field: ‘earlySignal’
[17:02:52.878]   - Field: ‘lazy’
[17:02:52.878]   - Field: ‘state’
[17:02:52.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.879] - Launch lazy future ...
[17:02:52.879] Packages needed by the future expression (n = 0): <none>
[17:02:52.879] Packages needed by future strategies (n = 0): <none>
[17:02:52.880] {
[17:02:52.880]     {
[17:02:52.880]         {
[17:02:52.880]             ...future.startTime <- base::Sys.time()
[17:02:52.880]             {
[17:02:52.880]                 {
[17:02:52.880]                   {
[17:02:52.880]                     {
[17:02:52.880]                       base::local({
[17:02:52.880]                         has_future <- base::requireNamespace("future", 
[17:02:52.880]                           quietly = TRUE)
[17:02:52.880]                         if (has_future) {
[17:02:52.880]                           ns <- base::getNamespace("future")
[17:02:52.880]                           version <- ns[[".package"]][["version"]]
[17:02:52.880]                           if (is.null(version)) 
[17:02:52.880]                             version <- utils::packageVersion("future")
[17:02:52.880]                         }
[17:02:52.880]                         else {
[17:02:52.880]                           version <- NULL
[17:02:52.880]                         }
[17:02:52.880]                         if (!has_future || version < "1.8.0") {
[17:02:52.880]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.880]                             "", base::R.version$version.string), 
[17:02:52.880]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.880]                               "release", "version")], collapse = " "), 
[17:02:52.880]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.880]                             info)
[17:02:52.880]                           info <- base::paste(info, collapse = "; ")
[17:02:52.880]                           if (!has_future) {
[17:02:52.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.880]                               info)
[17:02:52.880]                           }
[17:02:52.880]                           else {
[17:02:52.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.880]                               info, version)
[17:02:52.880]                           }
[17:02:52.880]                           base::stop(msg)
[17:02:52.880]                         }
[17:02:52.880]                       })
[17:02:52.880]                     }
[17:02:52.880]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.880]                     base::options(mc.cores = 1L)
[17:02:52.880]                   }
[17:02:52.880]                   ...future.strategy.old <- future::plan("list")
[17:02:52.880]                   options(future.plan = NULL)
[17:02:52.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.880]                 }
[17:02:52.880]                 ...future.workdir <- getwd()
[17:02:52.880]             }
[17:02:52.880]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.880]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.880]         }
[17:02:52.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.880]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.880]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.880]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.880]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.880]             base::names(...future.oldOptions))
[17:02:52.880]     }
[17:02:52.880]     if (FALSE) {
[17:02:52.880]     }
[17:02:52.880]     else {
[17:02:52.880]         if (TRUE) {
[17:02:52.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.880]                 open = "w")
[17:02:52.880]         }
[17:02:52.880]         else {
[17:02:52.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.880]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.880]         }
[17:02:52.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.880]             base::sink(type = "output", split = FALSE)
[17:02:52.880]             base::close(...future.stdout)
[17:02:52.880]         }, add = TRUE)
[17:02:52.880]     }
[17:02:52.880]     ...future.frame <- base::sys.nframe()
[17:02:52.880]     ...future.conditions <- base::list()
[17:02:52.880]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.880]     if (FALSE) {
[17:02:52.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.880]     }
[17:02:52.880]     ...future.result <- base::tryCatch({
[17:02:52.880]         base::withCallingHandlers({
[17:02:52.880]             ...future.value <- base::withVisible(base::local({
[17:02:52.880]                 withCallingHandlers({
[17:02:52.880]                   {
[17:02:52.880]                     x <- x + 1
[17:02:52.880]                     x
[17:02:52.880]                   }
[17:02:52.880]                 }, immediateCondition = function(cond) {
[17:02:52.880]                   save_rds <- function (object, pathname, ...) 
[17:02:52.880]                   {
[17:02:52.880]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.880]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.880]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.880]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.880]                         fi_tmp[["mtime"]])
[17:02:52.880]                     }
[17:02:52.880]                     tryCatch({
[17:02:52.880]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.880]                     }, error = function(ex) {
[17:02:52.880]                       msg <- conditionMessage(ex)
[17:02:52.880]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.880]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.880]                         fi_tmp[["mtime"]], msg)
[17:02:52.880]                       ex$message <- msg
[17:02:52.880]                       stop(ex)
[17:02:52.880]                     })
[17:02:52.880]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.880]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.880]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.880]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.880]                       fi <- file.info(pathname)
[17:02:52.880]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.880]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.880]                         fi[["size"]], fi[["mtime"]])
[17:02:52.880]                       stop(msg)
[17:02:52.880]                     }
[17:02:52.880]                     invisible(pathname)
[17:02:52.880]                   }
[17:02:52.880]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.880]                     rootPath = tempdir()) 
[17:02:52.880]                   {
[17:02:52.880]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.880]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.880]                       tmpdir = path, fileext = ".rds")
[17:02:52.880]                     save_rds(obj, file)
[17:02:52.880]                   }
[17:02:52.880]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.880]                   {
[17:02:52.880]                     inherits <- base::inherits
[17:02:52.880]                     invokeRestart <- base::invokeRestart
[17:02:52.880]                     is.null <- base::is.null
[17:02:52.880]                     muffled <- FALSE
[17:02:52.880]                     if (inherits(cond, "message")) {
[17:02:52.880]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.880]                       if (muffled) 
[17:02:52.880]                         invokeRestart("muffleMessage")
[17:02:52.880]                     }
[17:02:52.880]                     else if (inherits(cond, "warning")) {
[17:02:52.880]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.880]                       if (muffled) 
[17:02:52.880]                         invokeRestart("muffleWarning")
[17:02:52.880]                     }
[17:02:52.880]                     else if (inherits(cond, "condition")) {
[17:02:52.880]                       if (!is.null(pattern)) {
[17:02:52.880]                         computeRestarts <- base::computeRestarts
[17:02:52.880]                         grepl <- base::grepl
[17:02:52.880]                         restarts <- computeRestarts(cond)
[17:02:52.880]                         for (restart in restarts) {
[17:02:52.880]                           name <- restart$name
[17:02:52.880]                           if (is.null(name)) 
[17:02:52.880]                             next
[17:02:52.880]                           if (!grepl(pattern, name)) 
[17:02:52.880]                             next
[17:02:52.880]                           invokeRestart(restart)
[17:02:52.880]                           muffled <- TRUE
[17:02:52.880]                           break
[17:02:52.880]                         }
[17:02:52.880]                       }
[17:02:52.880]                     }
[17:02:52.880]                     invisible(muffled)
[17:02:52.880]                   }
[17:02:52.880]                   muffleCondition(cond)
[17:02:52.880]                 })
[17:02:52.880]             }))
[17:02:52.880]             future::FutureResult(value = ...future.value$value, 
[17:02:52.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.880]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.880]                     ...future.globalenv.names))
[17:02:52.880]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.880]         }, condition = base::local({
[17:02:52.880]             c <- base::c
[17:02:52.880]             inherits <- base::inherits
[17:02:52.880]             invokeRestart <- base::invokeRestart
[17:02:52.880]             length <- base::length
[17:02:52.880]             list <- base::list
[17:02:52.880]             seq.int <- base::seq.int
[17:02:52.880]             signalCondition <- base::signalCondition
[17:02:52.880]             sys.calls <- base::sys.calls
[17:02:52.880]             `[[` <- base::`[[`
[17:02:52.880]             `+` <- base::`+`
[17:02:52.880]             `<<-` <- base::`<<-`
[17:02:52.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.880]                   3L)]
[17:02:52.880]             }
[17:02:52.880]             function(cond) {
[17:02:52.880]                 is_error <- inherits(cond, "error")
[17:02:52.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.880]                   NULL)
[17:02:52.880]                 if (is_error) {
[17:02:52.880]                   sessionInformation <- function() {
[17:02:52.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.880]                       search = base::search(), system = base::Sys.info())
[17:02:52.880]                   }
[17:02:52.880]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.880]                     cond$call), session = sessionInformation(), 
[17:02:52.880]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.880]                   signalCondition(cond)
[17:02:52.880]                 }
[17:02:52.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.880]                 "immediateCondition"))) {
[17:02:52.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.880]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.880]                   if (TRUE && !signal) {
[17:02:52.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.880]                     {
[17:02:52.880]                       inherits <- base::inherits
[17:02:52.880]                       invokeRestart <- base::invokeRestart
[17:02:52.880]                       is.null <- base::is.null
[17:02:52.880]                       muffled <- FALSE
[17:02:52.880]                       if (inherits(cond, "message")) {
[17:02:52.880]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.880]                         if (muffled) 
[17:02:52.880]                           invokeRestart("muffleMessage")
[17:02:52.880]                       }
[17:02:52.880]                       else if (inherits(cond, "warning")) {
[17:02:52.880]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.880]                         if (muffled) 
[17:02:52.880]                           invokeRestart("muffleWarning")
[17:02:52.880]                       }
[17:02:52.880]                       else if (inherits(cond, "condition")) {
[17:02:52.880]                         if (!is.null(pattern)) {
[17:02:52.880]                           computeRestarts <- base::computeRestarts
[17:02:52.880]                           grepl <- base::grepl
[17:02:52.880]                           restarts <- computeRestarts(cond)
[17:02:52.880]                           for (restart in restarts) {
[17:02:52.880]                             name <- restart$name
[17:02:52.880]                             if (is.null(name)) 
[17:02:52.880]                               next
[17:02:52.880]                             if (!grepl(pattern, name)) 
[17:02:52.880]                               next
[17:02:52.880]                             invokeRestart(restart)
[17:02:52.880]                             muffled <- TRUE
[17:02:52.880]                             break
[17:02:52.880]                           }
[17:02:52.880]                         }
[17:02:52.880]                       }
[17:02:52.880]                       invisible(muffled)
[17:02:52.880]                     }
[17:02:52.880]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.880]                   }
[17:02:52.880]                 }
[17:02:52.880]                 else {
[17:02:52.880]                   if (TRUE) {
[17:02:52.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.880]                     {
[17:02:52.880]                       inherits <- base::inherits
[17:02:52.880]                       invokeRestart <- base::invokeRestart
[17:02:52.880]                       is.null <- base::is.null
[17:02:52.880]                       muffled <- FALSE
[17:02:52.880]                       if (inherits(cond, "message")) {
[17:02:52.880]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.880]                         if (muffled) 
[17:02:52.880]                           invokeRestart("muffleMessage")
[17:02:52.880]                       }
[17:02:52.880]                       else if (inherits(cond, "warning")) {
[17:02:52.880]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.880]                         if (muffled) 
[17:02:52.880]                           invokeRestart("muffleWarning")
[17:02:52.880]                       }
[17:02:52.880]                       else if (inherits(cond, "condition")) {
[17:02:52.880]                         if (!is.null(pattern)) {
[17:02:52.880]                           computeRestarts <- base::computeRestarts
[17:02:52.880]                           grepl <- base::grepl
[17:02:52.880]                           restarts <- computeRestarts(cond)
[17:02:52.880]                           for (restart in restarts) {
[17:02:52.880]                             name <- restart$name
[17:02:52.880]                             if (is.null(name)) 
[17:02:52.880]                               next
[17:02:52.880]                             if (!grepl(pattern, name)) 
[17:02:52.880]                               next
[17:02:52.880]                             invokeRestart(restart)
[17:02:52.880]                             muffled <- TRUE
[17:02:52.880]                             break
[17:02:52.880]                           }
[17:02:52.880]                         }
[17:02:52.880]                       }
[17:02:52.880]                       invisible(muffled)
[17:02:52.880]                     }
[17:02:52.880]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.880]                   }
[17:02:52.880]                 }
[17:02:52.880]             }
[17:02:52.880]         }))
[17:02:52.880]     }, error = function(ex) {
[17:02:52.880]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.880]                 ...future.rng), started = ...future.startTime, 
[17:02:52.880]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.880]             version = "1.8"), class = "FutureResult")
[17:02:52.880]     }, finally = {
[17:02:52.880]         if (!identical(...future.workdir, getwd())) 
[17:02:52.880]             setwd(...future.workdir)
[17:02:52.880]         {
[17:02:52.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.880]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.880]             }
[17:02:52.880]             base::options(...future.oldOptions)
[17:02:52.880]             if (.Platform$OS.type == "windows") {
[17:02:52.880]                 old_names <- names(...future.oldEnvVars)
[17:02:52.880]                 envs <- base::Sys.getenv()
[17:02:52.880]                 names <- names(envs)
[17:02:52.880]                 common <- intersect(names, old_names)
[17:02:52.880]                 added <- setdiff(names, old_names)
[17:02:52.880]                 removed <- setdiff(old_names, names)
[17:02:52.880]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.880]                   envs[common]]
[17:02:52.880]                 NAMES <- toupper(changed)
[17:02:52.880]                 args <- list()
[17:02:52.880]                 for (kk in seq_along(NAMES)) {
[17:02:52.880]                   name <- changed[[kk]]
[17:02:52.880]                   NAME <- NAMES[[kk]]
[17:02:52.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.880]                     next
[17:02:52.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.880]                 }
[17:02:52.880]                 NAMES <- toupper(added)
[17:02:52.880]                 for (kk in seq_along(NAMES)) {
[17:02:52.880]                   name <- added[[kk]]
[17:02:52.880]                   NAME <- NAMES[[kk]]
[17:02:52.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.880]                     next
[17:02:52.880]                   args[[name]] <- ""
[17:02:52.880]                 }
[17:02:52.880]                 NAMES <- toupper(removed)
[17:02:52.880]                 for (kk in seq_along(NAMES)) {
[17:02:52.880]                   name <- removed[[kk]]
[17:02:52.880]                   NAME <- NAMES[[kk]]
[17:02:52.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.880]                     next
[17:02:52.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.880]                 }
[17:02:52.880]                 if (length(args) > 0) 
[17:02:52.880]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.880]             }
[17:02:52.880]             else {
[17:02:52.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.880]             }
[17:02:52.880]             {
[17:02:52.880]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.880]                   0L) {
[17:02:52.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.880]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.880]                   base::options(opts)
[17:02:52.880]                 }
[17:02:52.880]                 {
[17:02:52.880]                   {
[17:02:52.880]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.880]                     NULL
[17:02:52.880]                   }
[17:02:52.880]                   options(future.plan = NULL)
[17:02:52.880]                   if (is.na(NA_character_)) 
[17:02:52.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.880]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.880]                     .init = FALSE)
[17:02:52.880]                 }
[17:02:52.880]             }
[17:02:52.880]         }
[17:02:52.880]     })
[17:02:52.880]     if (TRUE) {
[17:02:52.880]         base::sink(type = "output", split = FALSE)
[17:02:52.880]         if (TRUE) {
[17:02:52.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.880]         }
[17:02:52.880]         else {
[17:02:52.880]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.880]         }
[17:02:52.880]         base::close(...future.stdout)
[17:02:52.880]         ...future.stdout <- NULL
[17:02:52.880]     }
[17:02:52.880]     ...future.result$conditions <- ...future.conditions
[17:02:52.880]     ...future.result$finished <- base::Sys.time()
[17:02:52.880]     ...future.result
[17:02:52.880] }
[17:02:52.882] assign_globals() ...
[17:02:52.882] List of 1
[17:02:52.882]  $ x: num 1
[17:02:52.882]  - attr(*, "where")=List of 1
[17:02:52.882]   ..$ x:<environment: R_EmptyEnv> 
[17:02:52.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.882]  - attr(*, "resolved")= logi TRUE
[17:02:52.882]  - attr(*, "total_size")= num 56
[17:02:52.882]  - attr(*, "already-done")= logi TRUE
[17:02:52.885] - copied ‘x’ to environment
[17:02:52.885] assign_globals() ... done
[17:02:52.885] requestCore(): workers = 2
[17:02:52.888] MulticoreFuture started
[17:02:52.888] - Launch lazy future ... done
[17:02:52.888] run() for ‘MulticoreFuture’ ... done
[17:02:52.889] result() for MulticoreFuture ...
[17:02:52.889] plan(): Setting new future strategy stack:
[17:02:52.889] List of future strategies:
[17:02:52.889] 1. sequential:
[17:02:52.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.889]    - tweaked: FALSE
[17:02:52.889]    - call: NULL
[17:02:52.890] plan(): nbrOfWorkers() = 1
[17:02:52.892] plan(): Setting new future strategy stack:
[17:02:52.892] List of future strategies:
[17:02:52.892] 1. multicore:
[17:02:52.892]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.892]    - tweaked: FALSE
[17:02:52.892]    - call: plan(strategy)
[17:02:52.898] plan(): nbrOfWorkers() = 2
[17:02:52.899] result() for MulticoreFuture ...
[17:02:52.899] result() for MulticoreFuture ... done
[17:02:52.899] result() for MulticoreFuture ... done
[17:02:52.899] result() for MulticoreFuture ...
[17:02:52.899] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.900] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.900] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:52.903] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:02:52.903] Searching for globals ... DONE
[17:02:52.903] Resolving globals: TRUE
[17:02:52.903] Resolving any globals that are futures ...
[17:02:52.903] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:02:52.903] Resolving any globals that are futures ... DONE
[17:02:52.904] Resolving futures part of globals (recursively) ...
[17:02:52.904] resolve() on list ...
[17:02:52.904]  recursive: 99
[17:02:52.904]  length: 1
[17:02:52.905]  elements: ‘x’
[17:02:52.905]  length: 0 (resolved future 1)
[17:02:52.905] resolve() on list ... DONE
[17:02:52.905] - globals: [1] ‘x’
[17:02:52.905] Resolving futures part of globals (recursively) ... DONE
[17:02:52.905] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:02:52.906] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:02:52.906] - globals: [1] ‘x’
[17:02:52.906] 
[17:02:52.906] getGlobalsAndPackages() ... DONE
[17:02:52.907] run() for ‘Future’ ...
[17:02:52.907] - state: ‘created’
[17:02:52.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:52.911] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:52.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:52.912]   - Field: ‘label’
[17:02:52.912]   - Field: ‘local’
[17:02:52.912]   - Field: ‘owner’
[17:02:52.912]   - Field: ‘envir’
[17:02:52.912]   - Field: ‘workers’
[17:02:52.913]   - Field: ‘packages’
[17:02:52.913]   - Field: ‘gc’
[17:02:52.913]   - Field: ‘job’
[17:02:52.916]   - Field: ‘conditions’
[17:02:52.916]   - Field: ‘expr’
[17:02:52.916]   - Field: ‘uuid’
[17:02:52.916]   - Field: ‘seed’
[17:02:52.916]   - Field: ‘version’
[17:02:52.917]   - Field: ‘result’
[17:02:52.917]   - Field: ‘asynchronous’
[17:02:52.917]   - Field: ‘calls’
[17:02:52.917]   - Field: ‘globals’
[17:02:52.917]   - Field: ‘stdout’
[17:02:52.917]   - Field: ‘earlySignal’
[17:02:52.917]   - Field: ‘lazy’
[17:02:52.917]   - Field: ‘state’
[17:02:52.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:52.918] - Launch lazy future ...
[17:02:52.918] Packages needed by the future expression (n = 0): <none>
[17:02:52.918] Packages needed by future strategies (n = 0): <none>
[17:02:52.919] {
[17:02:52.919]     {
[17:02:52.919]         {
[17:02:52.919]             ...future.startTime <- base::Sys.time()
[17:02:52.919]             {
[17:02:52.919]                 {
[17:02:52.919]                   {
[17:02:52.919]                     {
[17:02:52.919]                       base::local({
[17:02:52.919]                         has_future <- base::requireNamespace("future", 
[17:02:52.919]                           quietly = TRUE)
[17:02:52.919]                         if (has_future) {
[17:02:52.919]                           ns <- base::getNamespace("future")
[17:02:52.919]                           version <- ns[[".package"]][["version"]]
[17:02:52.919]                           if (is.null(version)) 
[17:02:52.919]                             version <- utils::packageVersion("future")
[17:02:52.919]                         }
[17:02:52.919]                         else {
[17:02:52.919]                           version <- NULL
[17:02:52.919]                         }
[17:02:52.919]                         if (!has_future || version < "1.8.0") {
[17:02:52.919]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:52.919]                             "", base::R.version$version.string), 
[17:02:52.919]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:52.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:52.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:52.919]                               "release", "version")], collapse = " "), 
[17:02:52.919]                             hostname = base::Sys.info()[["nodename"]])
[17:02:52.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:52.919]                             info)
[17:02:52.919]                           info <- base::paste(info, collapse = "; ")
[17:02:52.919]                           if (!has_future) {
[17:02:52.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:52.919]                               info)
[17:02:52.919]                           }
[17:02:52.919]                           else {
[17:02:52.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:52.919]                               info, version)
[17:02:52.919]                           }
[17:02:52.919]                           base::stop(msg)
[17:02:52.919]                         }
[17:02:52.919]                       })
[17:02:52.919]                     }
[17:02:52.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:52.919]                     base::options(mc.cores = 1L)
[17:02:52.919]                   }
[17:02:52.919]                   ...future.strategy.old <- future::plan("list")
[17:02:52.919]                   options(future.plan = NULL)
[17:02:52.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:52.919]                 }
[17:02:52.919]                 ...future.workdir <- getwd()
[17:02:52.919]             }
[17:02:52.919]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:52.919]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:52.919]         }
[17:02:52.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:52.919]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:52.919]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:52.919]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:52.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:52.919]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:52.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:52.919]             base::names(...future.oldOptions))
[17:02:52.919]     }
[17:02:52.919]     if (FALSE) {
[17:02:52.919]     }
[17:02:52.919]     else {
[17:02:52.919]         if (TRUE) {
[17:02:52.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:52.919]                 open = "w")
[17:02:52.919]         }
[17:02:52.919]         else {
[17:02:52.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:52.919]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:52.919]         }
[17:02:52.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:52.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:52.919]             base::sink(type = "output", split = FALSE)
[17:02:52.919]             base::close(...future.stdout)
[17:02:52.919]         }, add = TRUE)
[17:02:52.919]     }
[17:02:52.919]     ...future.frame <- base::sys.nframe()
[17:02:52.919]     ...future.conditions <- base::list()
[17:02:52.919]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:52.919]     if (FALSE) {
[17:02:52.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:52.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:52.919]     }
[17:02:52.919]     ...future.result <- base::tryCatch({
[17:02:52.919]         base::withCallingHandlers({
[17:02:52.919]             ...future.value <- base::withVisible(base::local({
[17:02:52.919]                 withCallingHandlers({
[17:02:52.919]                   {
[17:02:52.919]                     x <- x()
[17:02:52.919]                     x
[17:02:52.919]                   }
[17:02:52.919]                 }, immediateCondition = function(cond) {
[17:02:52.919]                   save_rds <- function (object, pathname, ...) 
[17:02:52.919]                   {
[17:02:52.919]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:52.919]                     if (file_test("-f", pathname_tmp)) {
[17:02:52.919]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.919]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:52.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.919]                         fi_tmp[["mtime"]])
[17:02:52.919]                     }
[17:02:52.919]                     tryCatch({
[17:02:52.919]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:52.919]                     }, error = function(ex) {
[17:02:52.919]                       msg <- conditionMessage(ex)
[17:02:52.919]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.919]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:52.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.919]                         fi_tmp[["mtime"]], msg)
[17:02:52.919]                       ex$message <- msg
[17:02:52.919]                       stop(ex)
[17:02:52.919]                     })
[17:02:52.919]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:52.919]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:52.919]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:52.919]                       fi_tmp <- file.info(pathname_tmp)
[17:02:52.919]                       fi <- file.info(pathname)
[17:02:52.919]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:52.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:52.919]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:52.919]                         fi[["size"]], fi[["mtime"]])
[17:02:52.919]                       stop(msg)
[17:02:52.919]                     }
[17:02:52.919]                     invisible(pathname)
[17:02:52.919]                   }
[17:02:52.919]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:52.919]                     rootPath = tempdir()) 
[17:02:52.919]                   {
[17:02:52.919]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:52.919]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:52.919]                       tmpdir = path, fileext = ".rds")
[17:02:52.919]                     save_rds(obj, file)
[17:02:52.919]                   }
[17:02:52.919]                   saveImmediateCondition(cond, path = "/tmp/RtmpgD0Rfa/.future/immediateConditions")
[17:02:52.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.919]                   {
[17:02:52.919]                     inherits <- base::inherits
[17:02:52.919]                     invokeRestart <- base::invokeRestart
[17:02:52.919]                     is.null <- base::is.null
[17:02:52.919]                     muffled <- FALSE
[17:02:52.919]                     if (inherits(cond, "message")) {
[17:02:52.919]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:52.919]                       if (muffled) 
[17:02:52.919]                         invokeRestart("muffleMessage")
[17:02:52.919]                     }
[17:02:52.919]                     else if (inherits(cond, "warning")) {
[17:02:52.919]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:52.919]                       if (muffled) 
[17:02:52.919]                         invokeRestart("muffleWarning")
[17:02:52.919]                     }
[17:02:52.919]                     else if (inherits(cond, "condition")) {
[17:02:52.919]                       if (!is.null(pattern)) {
[17:02:52.919]                         computeRestarts <- base::computeRestarts
[17:02:52.919]                         grepl <- base::grepl
[17:02:52.919]                         restarts <- computeRestarts(cond)
[17:02:52.919]                         for (restart in restarts) {
[17:02:52.919]                           name <- restart$name
[17:02:52.919]                           if (is.null(name)) 
[17:02:52.919]                             next
[17:02:52.919]                           if (!grepl(pattern, name)) 
[17:02:52.919]                             next
[17:02:52.919]                           invokeRestart(restart)
[17:02:52.919]                           muffled <- TRUE
[17:02:52.919]                           break
[17:02:52.919]                         }
[17:02:52.919]                       }
[17:02:52.919]                     }
[17:02:52.919]                     invisible(muffled)
[17:02:52.919]                   }
[17:02:52.919]                   muffleCondition(cond)
[17:02:52.919]                 })
[17:02:52.919]             }))
[17:02:52.919]             future::FutureResult(value = ...future.value$value, 
[17:02:52.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.919]                   ...future.rng), globalenv = if (FALSE) 
[17:02:52.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:52.919]                     ...future.globalenv.names))
[17:02:52.919]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:52.919]         }, condition = base::local({
[17:02:52.919]             c <- base::c
[17:02:52.919]             inherits <- base::inherits
[17:02:52.919]             invokeRestart <- base::invokeRestart
[17:02:52.919]             length <- base::length
[17:02:52.919]             list <- base::list
[17:02:52.919]             seq.int <- base::seq.int
[17:02:52.919]             signalCondition <- base::signalCondition
[17:02:52.919]             sys.calls <- base::sys.calls
[17:02:52.919]             `[[` <- base::`[[`
[17:02:52.919]             `+` <- base::`+`
[17:02:52.919]             `<<-` <- base::`<<-`
[17:02:52.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:52.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:52.919]                   3L)]
[17:02:52.919]             }
[17:02:52.919]             function(cond) {
[17:02:52.919]                 is_error <- inherits(cond, "error")
[17:02:52.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:52.919]                   NULL)
[17:02:52.919]                 if (is_error) {
[17:02:52.919]                   sessionInformation <- function() {
[17:02:52.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:52.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:52.919]                       search = base::search(), system = base::Sys.info())
[17:02:52.919]                   }
[17:02:52.919]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:52.919]                     cond$call), session = sessionInformation(), 
[17:02:52.919]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:52.919]                   signalCondition(cond)
[17:02:52.919]                 }
[17:02:52.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:52.919]                 "immediateCondition"))) {
[17:02:52.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:52.919]                   ...future.conditions[[length(...future.conditions) + 
[17:02:52.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:52.919]                   if (TRUE && !signal) {
[17:02:52.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.919]                     {
[17:02:52.919]                       inherits <- base::inherits
[17:02:52.919]                       invokeRestart <- base::invokeRestart
[17:02:52.919]                       is.null <- base::is.null
[17:02:52.919]                       muffled <- FALSE
[17:02:52.919]                       if (inherits(cond, "message")) {
[17:02:52.919]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.919]                         if (muffled) 
[17:02:52.919]                           invokeRestart("muffleMessage")
[17:02:52.919]                       }
[17:02:52.919]                       else if (inherits(cond, "warning")) {
[17:02:52.919]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.919]                         if (muffled) 
[17:02:52.919]                           invokeRestart("muffleWarning")
[17:02:52.919]                       }
[17:02:52.919]                       else if (inherits(cond, "condition")) {
[17:02:52.919]                         if (!is.null(pattern)) {
[17:02:52.919]                           computeRestarts <- base::computeRestarts
[17:02:52.919]                           grepl <- base::grepl
[17:02:52.919]                           restarts <- computeRestarts(cond)
[17:02:52.919]                           for (restart in restarts) {
[17:02:52.919]                             name <- restart$name
[17:02:52.919]                             if (is.null(name)) 
[17:02:52.919]                               next
[17:02:52.919]                             if (!grepl(pattern, name)) 
[17:02:52.919]                               next
[17:02:52.919]                             invokeRestart(restart)
[17:02:52.919]                             muffled <- TRUE
[17:02:52.919]                             break
[17:02:52.919]                           }
[17:02:52.919]                         }
[17:02:52.919]                       }
[17:02:52.919]                       invisible(muffled)
[17:02:52.919]                     }
[17:02:52.919]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.919]                   }
[17:02:52.919]                 }
[17:02:52.919]                 else {
[17:02:52.919]                   if (TRUE) {
[17:02:52.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:52.919]                     {
[17:02:52.919]                       inherits <- base::inherits
[17:02:52.919]                       invokeRestart <- base::invokeRestart
[17:02:52.919]                       is.null <- base::is.null
[17:02:52.919]                       muffled <- FALSE
[17:02:52.919]                       if (inherits(cond, "message")) {
[17:02:52.919]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:52.919]                         if (muffled) 
[17:02:52.919]                           invokeRestart("muffleMessage")
[17:02:52.919]                       }
[17:02:52.919]                       else if (inherits(cond, "warning")) {
[17:02:52.919]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:52.919]                         if (muffled) 
[17:02:52.919]                           invokeRestart("muffleWarning")
[17:02:52.919]                       }
[17:02:52.919]                       else if (inherits(cond, "condition")) {
[17:02:52.919]                         if (!is.null(pattern)) {
[17:02:52.919]                           computeRestarts <- base::computeRestarts
[17:02:52.919]                           grepl <- base::grepl
[17:02:52.919]                           restarts <- computeRestarts(cond)
[17:02:52.919]                           for (restart in restarts) {
[17:02:52.919]                             name <- restart$name
[17:02:52.919]                             if (is.null(name)) 
[17:02:52.919]                               next
[17:02:52.919]                             if (!grepl(pattern, name)) 
[17:02:52.919]                               next
[17:02:52.919]                             invokeRestart(restart)
[17:02:52.919]                             muffled <- TRUE
[17:02:52.919]                             break
[17:02:52.919]                           }
[17:02:52.919]                         }
[17:02:52.919]                       }
[17:02:52.919]                       invisible(muffled)
[17:02:52.919]                     }
[17:02:52.919]                     muffleCondition(cond, pattern = "^muffle")
[17:02:52.919]                   }
[17:02:52.919]                 }
[17:02:52.919]             }
[17:02:52.919]         }))
[17:02:52.919]     }, error = function(ex) {
[17:02:52.919]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:52.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:52.919]                 ...future.rng), started = ...future.startTime, 
[17:02:52.919]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:52.919]             version = "1.8"), class = "FutureResult")
[17:02:52.919]     }, finally = {
[17:02:52.919]         if (!identical(...future.workdir, getwd())) 
[17:02:52.919]             setwd(...future.workdir)
[17:02:52.919]         {
[17:02:52.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:52.919]                 ...future.oldOptions$nwarnings <- NULL
[17:02:52.919]             }
[17:02:52.919]             base::options(...future.oldOptions)
[17:02:52.919]             if (.Platform$OS.type == "windows") {
[17:02:52.919]                 old_names <- names(...future.oldEnvVars)
[17:02:52.919]                 envs <- base::Sys.getenv()
[17:02:52.919]                 names <- names(envs)
[17:02:52.919]                 common <- intersect(names, old_names)
[17:02:52.919]                 added <- setdiff(names, old_names)
[17:02:52.919]                 removed <- setdiff(old_names, names)
[17:02:52.919]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:52.919]                   envs[common]]
[17:02:52.919]                 NAMES <- toupper(changed)
[17:02:52.919]                 args <- list()
[17:02:52.919]                 for (kk in seq_along(NAMES)) {
[17:02:52.919]                   name <- changed[[kk]]
[17:02:52.919]                   NAME <- NAMES[[kk]]
[17:02:52.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.919]                     next
[17:02:52.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.919]                 }
[17:02:52.919]                 NAMES <- toupper(added)
[17:02:52.919]                 for (kk in seq_along(NAMES)) {
[17:02:52.919]                   name <- added[[kk]]
[17:02:52.919]                   NAME <- NAMES[[kk]]
[17:02:52.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.919]                     next
[17:02:52.919]                   args[[name]] <- ""
[17:02:52.919]                 }
[17:02:52.919]                 NAMES <- toupper(removed)
[17:02:52.919]                 for (kk in seq_along(NAMES)) {
[17:02:52.919]                   name <- removed[[kk]]
[17:02:52.919]                   NAME <- NAMES[[kk]]
[17:02:52.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:52.919]                     next
[17:02:52.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:52.919]                 }
[17:02:52.919]                 if (length(args) > 0) 
[17:02:52.919]                   base::do.call(base::Sys.setenv, args = args)
[17:02:52.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:52.919]             }
[17:02:52.919]             else {
[17:02:52.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:52.919]             }
[17:02:52.919]             {
[17:02:52.919]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:52.919]                   0L) {
[17:02:52.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:52.919]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:52.919]                   base::options(opts)
[17:02:52.919]                 }
[17:02:52.919]                 {
[17:02:52.919]                   {
[17:02:52.919]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:52.919]                     NULL
[17:02:52.919]                   }
[17:02:52.919]                   options(future.plan = NULL)
[17:02:52.919]                   if (is.na(NA_character_)) 
[17:02:52.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:52.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:52.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:52.919]                     .init = FALSE)
[17:02:52.919]                 }
[17:02:52.919]             }
[17:02:52.919]         }
[17:02:52.919]     })
[17:02:52.919]     if (TRUE) {
[17:02:52.919]         base::sink(type = "output", split = FALSE)
[17:02:52.919]         if (TRUE) {
[17:02:52.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:52.919]         }
[17:02:52.919]         else {
[17:02:52.919]             ...future.result["stdout"] <- base::list(NULL)
[17:02:52.919]         }
[17:02:52.919]         base::close(...future.stdout)
[17:02:52.919]         ...future.stdout <- NULL
[17:02:52.919]     }
[17:02:52.919]     ...future.result$conditions <- ...future.conditions
[17:02:52.919]     ...future.result$finished <- base::Sys.time()
[17:02:52.919]     ...future.result
[17:02:52.919] }
[17:02:52.921] assign_globals() ...
[17:02:52.921] List of 1
[17:02:52.921]  $ x:function ()  
[17:02:52.921]  - attr(*, "where")=List of 1
[17:02:52.921]   ..$ x:<environment: R_EmptyEnv> 
[17:02:52.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:52.921]  - attr(*, "resolved")= logi TRUE
[17:02:52.921]  - attr(*, "total_size")= num 1032
[17:02:52.921]  - attr(*, "already-done")= logi TRUE
[17:02:52.925] - reassign environment for ‘x’
[17:02:52.925] - copied ‘x’ to environment
[17:02:52.925] assign_globals() ... done
[17:02:52.925] requestCore(): workers = 2
[17:02:52.928] MulticoreFuture started
[17:02:52.929] - Launch lazy future ... done
[17:02:52.929] run() for ‘MulticoreFuture’ ... done
[17:02:52.929] plan(): Setting new future strategy stack:
[17:02:52.929] result() for MulticoreFuture ...
[17:02:52.929] List of future strategies:
[17:02:52.929] 1. sequential:
[17:02:52.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:52.929]    - tweaked: FALSE
[17:02:52.929]    - call: NULL
[17:02:52.931] plan(): nbrOfWorkers() = 1
[17:02:52.933] plan(): Setting new future strategy stack:
[17:02:52.934] List of future strategies:
[17:02:52.934] 1. multicore:
[17:02:52.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:52.934]    - tweaked: FALSE
[17:02:52.934]    - call: plan(strategy)
[17:02:52.939] plan(): nbrOfWorkers() = 2
[17:02:52.940] result() for MulticoreFuture ...
[17:02:52.940] result() for MulticoreFuture ... done
[17:02:52.941] result() for MulticoreFuture ... done
[17:02:52.941] result() for MulticoreFuture ...
[17:02:52.941] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[17:02:52.942] plan(): Setting new future strategy stack:
[17:02:52.942] List of future strategies:
[17:02:52.942] 1. multisession:
[17:02:52.942]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:52.942]    - tweaked: FALSE
[17:02:52.942]    - call: plan(strategy)
[17:02:52.943] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:02:52.943] multisession:
[17:02:52.943] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:52.943] - tweaked: FALSE
[17:02:52.943] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:52.950] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:52.950] Not searching for globals
[17:02:52.951] - globals: [0] <none>
[17:02:52.951] getGlobalsAndPackages() ... DONE
[17:02:52.951] [local output] makeClusterPSOCK() ...
[17:02:53.000] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:02:53.001] [local output] Base port: 11606
[17:02:53.001] [local output] Getting setup options for 2 cluster nodes ...
[17:02:53.001] [local output]  - Node 1 of 2 ...
[17:02:53.002] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:53.002] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpgD0Rfa/worker.rank=1.parallelly.parent=44741.aec566d7f259.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpgD0Rfa/worker.rank=1.parallelly.parent=44741.aec566d7f259.pid")'’
[17:02:53.194] - Possible to infer worker's PID: TRUE
[17:02:53.194] [local output] Rscript port: 11606

[17:02:53.194] [local output]  - Node 2 of 2 ...
[17:02:53.195] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:53.195] [local output] Rscript port: 11606

[17:02:53.196] [local output] Getting setup options for 2 cluster nodes ... done
[17:02:53.196] [local output]  - Parallel setup requested for some PSOCK nodes
[17:02:53.196] [local output] Setting up PSOCK nodes in parallel
[17:02:53.196] List of 36
[17:02:53.196]  $ worker          : chr "localhost"
[17:02:53.196]   ..- attr(*, "localhost")= logi TRUE
[17:02:53.196]  $ master          : chr "localhost"
[17:02:53.196]  $ port            : int 11606
[17:02:53.196]  $ connectTimeout  : num 120
[17:02:53.196]  $ timeout         : num 2592000
[17:02:53.196]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:02:53.196]  $ homogeneous     : logi TRUE
[17:02:53.196]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:02:53.196]  $ rscript_envs    : NULL
[17:02:53.196]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:53.196]  $ rscript_startup : NULL
[17:02:53.196]  $ rscript_sh      : chr "sh"
[17:02:53.196]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:53.196]  $ methods         : logi TRUE
[17:02:53.196]  $ socketOptions   : chr "no-delay"
[17:02:53.196]  $ useXDR          : logi FALSE
[17:02:53.196]  $ outfile         : chr "/dev/null"
[17:02:53.196]  $ renice          : int NA
[17:02:53.196]  $ rshcmd          : NULL
[17:02:53.196]  $ user            : chr(0) 
[17:02:53.196]  $ revtunnel       : logi FALSE
[17:02:53.196]  $ rshlogfile      : NULL
[17:02:53.196]  $ rshopts         : chr(0) 
[17:02:53.196]  $ rank            : int 1
[17:02:53.196]  $ manual          : logi FALSE
[17:02:53.196]  $ dryrun          : logi FALSE
[17:02:53.196]  $ quiet           : logi FALSE
[17:02:53.196]  $ setup_strategy  : chr "parallel"
[17:02:53.196]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:53.196]  $ pidfile         : chr "/tmp/RtmpgD0Rfa/worker.rank=1.parallelly.parent=44741.aec566d7f259.pid"
[17:02:53.196]  $ rshcmd_label    : NULL
[17:02:53.196]  $ rsh_call        : NULL
[17:02:53.196]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:53.196]  $ localMachine    : logi TRUE
[17:02:53.196]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:02:53.196]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:02:53.196]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:02:53.196]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:02:53.196]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:02:53.196]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:02:53.196]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:02:53.196]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:02:53.196]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:02:53.196]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:02:53.196]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:02:53.196]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:02:53.196]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:02:53.196]  $ arguments       :List of 28
[17:02:53.196]   ..$ worker          : chr "localhost"
[17:02:53.196]   ..$ master          : NULL
[17:02:53.196]   ..$ port            : int 11606
[17:02:53.196]   ..$ connectTimeout  : num 120
[17:02:53.196]   ..$ timeout         : num 2592000
[17:02:53.196]   ..$ rscript         : NULL
[17:02:53.196]   ..$ homogeneous     : NULL
[17:02:53.196]   ..$ rscript_args    : NULL
[17:02:53.196]   ..$ rscript_envs    : NULL
[17:02:53.196]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:53.196]   ..$ rscript_startup : NULL
[17:02:53.196]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:02:53.196]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:53.196]   ..$ methods         : logi TRUE
[17:02:53.196]   ..$ socketOptions   : chr "no-delay"
[17:02:53.196]   ..$ useXDR          : logi FALSE
[17:02:53.196]   ..$ outfile         : chr "/dev/null"
[17:02:53.196]   ..$ renice          : int NA
[17:02:53.196]   ..$ rshcmd          : NULL
[17:02:53.196]   ..$ user            : NULL
[17:02:53.196]   ..$ revtunnel       : logi NA
[17:02:53.196]   ..$ rshlogfile      : NULL
[17:02:53.196]   ..$ rshopts         : NULL
[17:02:53.196]   ..$ rank            : int 1
[17:02:53.196]   ..$ manual          : logi FALSE
[17:02:53.196]   ..$ dryrun          : logi FALSE
[17:02:53.196]   ..$ quiet           : logi FALSE
[17:02:53.196]   ..$ setup_strategy  : chr "parallel"
[17:02:53.196]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:02:53.213] [local output] System call to launch all workers:
[17:02:53.213] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpgD0Rfa/worker.rank=1.parallelly.parent=44741.aec566d7f259.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11606 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:02:53.214] [local output] Starting PSOCK main server
[17:02:53.219] [local output] Workers launched
[17:02:53.219] [local output] Waiting for workers to connect back
[17:02:53.220]  - [local output] 0 workers out of 2 ready
[17:02:53.470]  - [local output] 0 workers out of 2 ready
[17:02:53.470]  - [local output] 1 workers out of 2 ready
[17:02:53.470]  - [local output] 2 workers out of 2 ready
[17:02:53.471] [local output] Launching of workers completed
[17:02:53.471] [local output] Collecting session information from workers
[17:02:53.472] [local output]  - Worker #1 of 2
[17:02:53.472] [local output]  - Worker #2 of 2
[17:02:53.472] [local output] makeClusterPSOCK() ... done
[17:02:53.484] Packages needed by the future expression (n = 0): <none>
[17:02:53.484] Packages needed by future strategies (n = 0): <none>
[17:02:53.484] {
[17:02:53.484]     {
[17:02:53.484]         {
[17:02:53.484]             ...future.startTime <- base::Sys.time()
[17:02:53.484]             {
[17:02:53.484]                 {
[17:02:53.484]                   {
[17:02:53.484]                     {
[17:02:53.484]                       base::local({
[17:02:53.484]                         has_future <- base::requireNamespace("future", 
[17:02:53.484]                           quietly = TRUE)
[17:02:53.484]                         if (has_future) {
[17:02:53.484]                           ns <- base::getNamespace("future")
[17:02:53.484]                           version <- ns[[".package"]][["version"]]
[17:02:53.484]                           if (is.null(version)) 
[17:02:53.484]                             version <- utils::packageVersion("future")
[17:02:53.484]                         }
[17:02:53.484]                         else {
[17:02:53.484]                           version <- NULL
[17:02:53.484]                         }
[17:02:53.484]                         if (!has_future || version < "1.8.0") {
[17:02:53.484]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.484]                             "", base::R.version$version.string), 
[17:02:53.484]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.484]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.484]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.484]                               "release", "version")], collapse = " "), 
[17:02:53.484]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.484]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.484]                             info)
[17:02:53.484]                           info <- base::paste(info, collapse = "; ")
[17:02:53.484]                           if (!has_future) {
[17:02:53.484]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.484]                               info)
[17:02:53.484]                           }
[17:02:53.484]                           else {
[17:02:53.484]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.484]                               info, version)
[17:02:53.484]                           }
[17:02:53.484]                           base::stop(msg)
[17:02:53.484]                         }
[17:02:53.484]                       })
[17:02:53.484]                     }
[17:02:53.484]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.484]                     base::options(mc.cores = 1L)
[17:02:53.484]                   }
[17:02:53.484]                   ...future.strategy.old <- future::plan("list")
[17:02:53.484]                   options(future.plan = NULL)
[17:02:53.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.484]                 }
[17:02:53.484]                 ...future.workdir <- getwd()
[17:02:53.484]             }
[17:02:53.484]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.484]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.484]         }
[17:02:53.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.484]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:53.484]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.484]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.484]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.484]             base::names(...future.oldOptions))
[17:02:53.484]     }
[17:02:53.484]     if (FALSE) {
[17:02:53.484]     }
[17:02:53.484]     else {
[17:02:53.484]         if (TRUE) {
[17:02:53.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.484]                 open = "w")
[17:02:53.484]         }
[17:02:53.484]         else {
[17:02:53.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.484]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.484]         }
[17:02:53.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.484]             base::sink(type = "output", split = FALSE)
[17:02:53.484]             base::close(...future.stdout)
[17:02:53.484]         }, add = TRUE)
[17:02:53.484]     }
[17:02:53.484]     ...future.frame <- base::sys.nframe()
[17:02:53.484]     ...future.conditions <- base::list()
[17:02:53.484]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.484]     if (FALSE) {
[17:02:53.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.484]     }
[17:02:53.484]     ...future.result <- base::tryCatch({
[17:02:53.484]         base::withCallingHandlers({
[17:02:53.484]             ...future.value <- base::withVisible(base::local({
[17:02:53.484]                 ...future.makeSendCondition <- base::local({
[17:02:53.484]                   sendCondition <- NULL
[17:02:53.484]                   function(frame = 1L) {
[17:02:53.484]                     if (is.function(sendCondition)) 
[17:02:53.484]                       return(sendCondition)
[17:02:53.484]                     ns <- getNamespace("parallel")
[17:02:53.484]                     if (exists("sendData", mode = "function", 
[17:02:53.484]                       envir = ns)) {
[17:02:53.484]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.484]                         envir = ns)
[17:02:53.484]                       envir <- sys.frame(frame)
[17:02:53.484]                       master <- NULL
[17:02:53.484]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.484]                         !identical(envir, emptyenv())) {
[17:02:53.484]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.484]                           inherits = FALSE)) {
[17:02:53.484]                           master <- get("master", mode = "list", 
[17:02:53.484]                             envir = envir, inherits = FALSE)
[17:02:53.484]                           if (inherits(master, c("SOCKnode", 
[17:02:53.484]                             "SOCK0node"))) {
[17:02:53.484]                             sendCondition <<- function(cond) {
[17:02:53.484]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.484]                                 success = TRUE)
[17:02:53.484]                               parallel_sendData(master, data)
[17:02:53.484]                             }
[17:02:53.484]                             return(sendCondition)
[17:02:53.484]                           }
[17:02:53.484]                         }
[17:02:53.484]                         frame <- frame + 1L
[17:02:53.484]                         envir <- sys.frame(frame)
[17:02:53.484]                       }
[17:02:53.484]                     }
[17:02:53.484]                     sendCondition <<- function(cond) NULL
[17:02:53.484]                   }
[17:02:53.484]                 })
[17:02:53.484]                 withCallingHandlers({
[17:02:53.484]                   NA
[17:02:53.484]                 }, immediateCondition = function(cond) {
[17:02:53.484]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.484]                   sendCondition(cond)
[17:02:53.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.484]                   {
[17:02:53.484]                     inherits <- base::inherits
[17:02:53.484]                     invokeRestart <- base::invokeRestart
[17:02:53.484]                     is.null <- base::is.null
[17:02:53.484]                     muffled <- FALSE
[17:02:53.484]                     if (inherits(cond, "message")) {
[17:02:53.484]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.484]                       if (muffled) 
[17:02:53.484]                         invokeRestart("muffleMessage")
[17:02:53.484]                     }
[17:02:53.484]                     else if (inherits(cond, "warning")) {
[17:02:53.484]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.484]                       if (muffled) 
[17:02:53.484]                         invokeRestart("muffleWarning")
[17:02:53.484]                     }
[17:02:53.484]                     else if (inherits(cond, "condition")) {
[17:02:53.484]                       if (!is.null(pattern)) {
[17:02:53.484]                         computeRestarts <- base::computeRestarts
[17:02:53.484]                         grepl <- base::grepl
[17:02:53.484]                         restarts <- computeRestarts(cond)
[17:02:53.484]                         for (restart in restarts) {
[17:02:53.484]                           name <- restart$name
[17:02:53.484]                           if (is.null(name)) 
[17:02:53.484]                             next
[17:02:53.484]                           if (!grepl(pattern, name)) 
[17:02:53.484]                             next
[17:02:53.484]                           invokeRestart(restart)
[17:02:53.484]                           muffled <- TRUE
[17:02:53.484]                           break
[17:02:53.484]                         }
[17:02:53.484]                       }
[17:02:53.484]                     }
[17:02:53.484]                     invisible(muffled)
[17:02:53.484]                   }
[17:02:53.484]                   muffleCondition(cond)
[17:02:53.484]                 })
[17:02:53.484]             }))
[17:02:53.484]             future::FutureResult(value = ...future.value$value, 
[17:02:53.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.484]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.484]                     ...future.globalenv.names))
[17:02:53.484]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.484]         }, condition = base::local({
[17:02:53.484]             c <- base::c
[17:02:53.484]             inherits <- base::inherits
[17:02:53.484]             invokeRestart <- base::invokeRestart
[17:02:53.484]             length <- base::length
[17:02:53.484]             list <- base::list
[17:02:53.484]             seq.int <- base::seq.int
[17:02:53.484]             signalCondition <- base::signalCondition
[17:02:53.484]             sys.calls <- base::sys.calls
[17:02:53.484]             `[[` <- base::`[[`
[17:02:53.484]             `+` <- base::`+`
[17:02:53.484]             `<<-` <- base::`<<-`
[17:02:53.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.484]                   3L)]
[17:02:53.484]             }
[17:02:53.484]             function(cond) {
[17:02:53.484]                 is_error <- inherits(cond, "error")
[17:02:53.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.484]                   NULL)
[17:02:53.484]                 if (is_error) {
[17:02:53.484]                   sessionInformation <- function() {
[17:02:53.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.484]                       search = base::search(), system = base::Sys.info())
[17:02:53.484]                   }
[17:02:53.484]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.484]                     cond$call), session = sessionInformation(), 
[17:02:53.484]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.484]                   signalCondition(cond)
[17:02:53.484]                 }
[17:02:53.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.484]                 "immediateCondition"))) {
[17:02:53.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.484]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.484]                   if (TRUE && !signal) {
[17:02:53.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.484]                     {
[17:02:53.484]                       inherits <- base::inherits
[17:02:53.484]                       invokeRestart <- base::invokeRestart
[17:02:53.484]                       is.null <- base::is.null
[17:02:53.484]                       muffled <- FALSE
[17:02:53.484]                       if (inherits(cond, "message")) {
[17:02:53.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.484]                         if (muffled) 
[17:02:53.484]                           invokeRestart("muffleMessage")
[17:02:53.484]                       }
[17:02:53.484]                       else if (inherits(cond, "warning")) {
[17:02:53.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.484]                         if (muffled) 
[17:02:53.484]                           invokeRestart("muffleWarning")
[17:02:53.484]                       }
[17:02:53.484]                       else if (inherits(cond, "condition")) {
[17:02:53.484]                         if (!is.null(pattern)) {
[17:02:53.484]                           computeRestarts <- base::computeRestarts
[17:02:53.484]                           grepl <- base::grepl
[17:02:53.484]                           restarts <- computeRestarts(cond)
[17:02:53.484]                           for (restart in restarts) {
[17:02:53.484]                             name <- restart$name
[17:02:53.484]                             if (is.null(name)) 
[17:02:53.484]                               next
[17:02:53.484]                             if (!grepl(pattern, name)) 
[17:02:53.484]                               next
[17:02:53.484]                             invokeRestart(restart)
[17:02:53.484]                             muffled <- TRUE
[17:02:53.484]                             break
[17:02:53.484]                           }
[17:02:53.484]                         }
[17:02:53.484]                       }
[17:02:53.484]                       invisible(muffled)
[17:02:53.484]                     }
[17:02:53.484]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.484]                   }
[17:02:53.484]                 }
[17:02:53.484]                 else {
[17:02:53.484]                   if (TRUE) {
[17:02:53.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.484]                     {
[17:02:53.484]                       inherits <- base::inherits
[17:02:53.484]                       invokeRestart <- base::invokeRestart
[17:02:53.484]                       is.null <- base::is.null
[17:02:53.484]                       muffled <- FALSE
[17:02:53.484]                       if (inherits(cond, "message")) {
[17:02:53.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.484]                         if (muffled) 
[17:02:53.484]                           invokeRestart("muffleMessage")
[17:02:53.484]                       }
[17:02:53.484]                       else if (inherits(cond, "warning")) {
[17:02:53.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.484]                         if (muffled) 
[17:02:53.484]                           invokeRestart("muffleWarning")
[17:02:53.484]                       }
[17:02:53.484]                       else if (inherits(cond, "condition")) {
[17:02:53.484]                         if (!is.null(pattern)) {
[17:02:53.484]                           computeRestarts <- base::computeRestarts
[17:02:53.484]                           grepl <- base::grepl
[17:02:53.484]                           restarts <- computeRestarts(cond)
[17:02:53.484]                           for (restart in restarts) {
[17:02:53.484]                             name <- restart$name
[17:02:53.484]                             if (is.null(name)) 
[17:02:53.484]                               next
[17:02:53.484]                             if (!grepl(pattern, name)) 
[17:02:53.484]                               next
[17:02:53.484]                             invokeRestart(restart)
[17:02:53.484]                             muffled <- TRUE
[17:02:53.484]                             break
[17:02:53.484]                           }
[17:02:53.484]                         }
[17:02:53.484]                       }
[17:02:53.484]                       invisible(muffled)
[17:02:53.484]                     }
[17:02:53.484]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.484]                   }
[17:02:53.484]                 }
[17:02:53.484]             }
[17:02:53.484]         }))
[17:02:53.484]     }, error = function(ex) {
[17:02:53.484]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.484]                 ...future.rng), started = ...future.startTime, 
[17:02:53.484]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.484]             version = "1.8"), class = "FutureResult")
[17:02:53.484]     }, finally = {
[17:02:53.484]         if (!identical(...future.workdir, getwd())) 
[17:02:53.484]             setwd(...future.workdir)
[17:02:53.484]         {
[17:02:53.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.484]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.484]             }
[17:02:53.484]             base::options(...future.oldOptions)
[17:02:53.484]             if (.Platform$OS.type == "windows") {
[17:02:53.484]                 old_names <- names(...future.oldEnvVars)
[17:02:53.484]                 envs <- base::Sys.getenv()
[17:02:53.484]                 names <- names(envs)
[17:02:53.484]                 common <- intersect(names, old_names)
[17:02:53.484]                 added <- setdiff(names, old_names)
[17:02:53.484]                 removed <- setdiff(old_names, names)
[17:02:53.484]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.484]                   envs[common]]
[17:02:53.484]                 NAMES <- toupper(changed)
[17:02:53.484]                 args <- list()
[17:02:53.484]                 for (kk in seq_along(NAMES)) {
[17:02:53.484]                   name <- changed[[kk]]
[17:02:53.484]                   NAME <- NAMES[[kk]]
[17:02:53.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.484]                     next
[17:02:53.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.484]                 }
[17:02:53.484]                 NAMES <- toupper(added)
[17:02:53.484]                 for (kk in seq_along(NAMES)) {
[17:02:53.484]                   name <- added[[kk]]
[17:02:53.484]                   NAME <- NAMES[[kk]]
[17:02:53.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.484]                     next
[17:02:53.484]                   args[[name]] <- ""
[17:02:53.484]                 }
[17:02:53.484]                 NAMES <- toupper(removed)
[17:02:53.484]                 for (kk in seq_along(NAMES)) {
[17:02:53.484]                   name <- removed[[kk]]
[17:02:53.484]                   NAME <- NAMES[[kk]]
[17:02:53.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.484]                     next
[17:02:53.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.484]                 }
[17:02:53.484]                 if (length(args) > 0) 
[17:02:53.484]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.484]             }
[17:02:53.484]             else {
[17:02:53.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.484]             }
[17:02:53.484]             {
[17:02:53.484]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.484]                   0L) {
[17:02:53.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.484]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.484]                   base::options(opts)
[17:02:53.484]                 }
[17:02:53.484]                 {
[17:02:53.484]                   {
[17:02:53.484]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.484]                     NULL
[17:02:53.484]                   }
[17:02:53.484]                   options(future.plan = NULL)
[17:02:53.484]                   if (is.na(NA_character_)) 
[17:02:53.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.484]                     .init = FALSE)
[17:02:53.484]                 }
[17:02:53.484]             }
[17:02:53.484]         }
[17:02:53.484]     })
[17:02:53.484]     if (TRUE) {
[17:02:53.484]         base::sink(type = "output", split = FALSE)
[17:02:53.484]         if (TRUE) {
[17:02:53.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.484]         }
[17:02:53.484]         else {
[17:02:53.484]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.484]         }
[17:02:53.484]         base::close(...future.stdout)
[17:02:53.484]         ...future.stdout <- NULL
[17:02:53.484]     }
[17:02:53.484]     ...future.result$conditions <- ...future.conditions
[17:02:53.484]     ...future.result$finished <- base::Sys.time()
[17:02:53.484]     ...future.result
[17:02:53.484] }
[17:02:53.538] MultisessionFuture started
[17:02:53.538] result() for ClusterFuture ...
[17:02:53.539] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.539] - Validating connection of MultisessionFuture
[17:02:53.572] - received message: FutureResult
[17:02:53.572] - Received FutureResult
[17:02:53.572] - Erased future from FutureRegistry
[17:02:53.572] result() for ClusterFuture ...
[17:02:53.572] - result already collected: FutureResult
[17:02:53.572] result() for ClusterFuture ... done
[17:02:53.572] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.573] result() for ClusterFuture ... done
[17:02:53.573] result() for ClusterFuture ...
[17:02:53.573] - result already collected: FutureResult
[17:02:53.573] result() for ClusterFuture ... done
[17:02:53.573] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:02:53.577] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.578] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.578] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.580] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:02:53.580] Searching for globals ... DONE
[17:02:53.580] Resolving globals: TRUE
[17:02:53.580] Resolving any globals that are futures ...
[17:02:53.580] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:02:53.580] Resolving any globals that are futures ... DONE
[17:02:53.581] 
[17:02:53.581] 
[17:02:53.581] getGlobalsAndPackages() ... DONE
[17:02:53.581] run() for ‘Future’ ...
[17:02:53.581] - state: ‘created’
[17:02:53.582] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.596] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.596]   - Field: ‘node’
[17:02:53.596]   - Field: ‘label’
[17:02:53.596]   - Field: ‘local’
[17:02:53.597]   - Field: ‘owner’
[17:02:53.597]   - Field: ‘envir’
[17:02:53.597]   - Field: ‘workers’
[17:02:53.597]   - Field: ‘packages’
[17:02:53.597]   - Field: ‘gc’
[17:02:53.597]   - Field: ‘conditions’
[17:02:53.597]   - Field: ‘persistent’
[17:02:53.597]   - Field: ‘expr’
[17:02:53.597]   - Field: ‘uuid’
[17:02:53.597]   - Field: ‘seed’
[17:02:53.598]   - Field: ‘version’
[17:02:53.598]   - Field: ‘result’
[17:02:53.598]   - Field: ‘asynchronous’
[17:02:53.598]   - Field: ‘calls’
[17:02:53.598]   - Field: ‘globals’
[17:02:53.598]   - Field: ‘stdout’
[17:02:53.598]   - Field: ‘earlySignal’
[17:02:53.598]   - Field: ‘lazy’
[17:02:53.599]   - Field: ‘state’
[17:02:53.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.599] - Launch lazy future ...
[17:02:53.599] Packages needed by the future expression (n = 0): <none>
[17:02:53.599] Packages needed by future strategies (n = 0): <none>
[17:02:53.600] {
[17:02:53.600]     {
[17:02:53.600]         {
[17:02:53.600]             ...future.startTime <- base::Sys.time()
[17:02:53.600]             {
[17:02:53.600]                 {
[17:02:53.600]                   {
[17:02:53.600]                     {
[17:02:53.600]                       base::local({
[17:02:53.600]                         has_future <- base::requireNamespace("future", 
[17:02:53.600]                           quietly = TRUE)
[17:02:53.600]                         if (has_future) {
[17:02:53.600]                           ns <- base::getNamespace("future")
[17:02:53.600]                           version <- ns[[".package"]][["version"]]
[17:02:53.600]                           if (is.null(version)) 
[17:02:53.600]                             version <- utils::packageVersion("future")
[17:02:53.600]                         }
[17:02:53.600]                         else {
[17:02:53.600]                           version <- NULL
[17:02:53.600]                         }
[17:02:53.600]                         if (!has_future || version < "1.8.0") {
[17:02:53.600]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.600]                             "", base::R.version$version.string), 
[17:02:53.600]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.600]                               "release", "version")], collapse = " "), 
[17:02:53.600]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.600]                             info)
[17:02:53.600]                           info <- base::paste(info, collapse = "; ")
[17:02:53.600]                           if (!has_future) {
[17:02:53.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.600]                               info)
[17:02:53.600]                           }
[17:02:53.600]                           else {
[17:02:53.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.600]                               info, version)
[17:02:53.600]                           }
[17:02:53.600]                           base::stop(msg)
[17:02:53.600]                         }
[17:02:53.600]                       })
[17:02:53.600]                     }
[17:02:53.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.600]                     base::options(mc.cores = 1L)
[17:02:53.600]                   }
[17:02:53.600]                   ...future.strategy.old <- future::plan("list")
[17:02:53.600]                   options(future.plan = NULL)
[17:02:53.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.600]                 }
[17:02:53.600]                 ...future.workdir <- getwd()
[17:02:53.600]             }
[17:02:53.600]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.600]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.600]         }
[17:02:53.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.600]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.600]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.600]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.600]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.600]             base::names(...future.oldOptions))
[17:02:53.600]     }
[17:02:53.600]     if (FALSE) {
[17:02:53.600]     }
[17:02:53.600]     else {
[17:02:53.600]         if (TRUE) {
[17:02:53.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.600]                 open = "w")
[17:02:53.600]         }
[17:02:53.600]         else {
[17:02:53.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.600]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.600]         }
[17:02:53.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.600]             base::sink(type = "output", split = FALSE)
[17:02:53.600]             base::close(...future.stdout)
[17:02:53.600]         }, add = TRUE)
[17:02:53.600]     }
[17:02:53.600]     ...future.frame <- base::sys.nframe()
[17:02:53.600]     ...future.conditions <- base::list()
[17:02:53.600]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.600]     if (FALSE) {
[17:02:53.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.600]     }
[17:02:53.600]     ...future.result <- base::tryCatch({
[17:02:53.600]         base::withCallingHandlers({
[17:02:53.600]             ...future.value <- base::withVisible(base::local({
[17:02:53.600]                 ...future.makeSendCondition <- base::local({
[17:02:53.600]                   sendCondition <- NULL
[17:02:53.600]                   function(frame = 1L) {
[17:02:53.600]                     if (is.function(sendCondition)) 
[17:02:53.600]                       return(sendCondition)
[17:02:53.600]                     ns <- getNamespace("parallel")
[17:02:53.600]                     if (exists("sendData", mode = "function", 
[17:02:53.600]                       envir = ns)) {
[17:02:53.600]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.600]                         envir = ns)
[17:02:53.600]                       envir <- sys.frame(frame)
[17:02:53.600]                       master <- NULL
[17:02:53.600]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.600]                         !identical(envir, emptyenv())) {
[17:02:53.600]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.600]                           inherits = FALSE)) {
[17:02:53.600]                           master <- get("master", mode = "list", 
[17:02:53.600]                             envir = envir, inherits = FALSE)
[17:02:53.600]                           if (inherits(master, c("SOCKnode", 
[17:02:53.600]                             "SOCK0node"))) {
[17:02:53.600]                             sendCondition <<- function(cond) {
[17:02:53.600]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.600]                                 success = TRUE)
[17:02:53.600]                               parallel_sendData(master, data)
[17:02:53.600]                             }
[17:02:53.600]                             return(sendCondition)
[17:02:53.600]                           }
[17:02:53.600]                         }
[17:02:53.600]                         frame <- frame + 1L
[17:02:53.600]                         envir <- sys.frame(frame)
[17:02:53.600]                       }
[17:02:53.600]                     }
[17:02:53.600]                     sendCondition <<- function(cond) NULL
[17:02:53.600]                   }
[17:02:53.600]                 })
[17:02:53.600]                 withCallingHandlers({
[17:02:53.600]                   {
[17:02:53.600]                     b <- a
[17:02:53.600]                     a <- 2
[17:02:53.600]                     a * b
[17:02:53.600]                   }
[17:02:53.600]                 }, immediateCondition = function(cond) {
[17:02:53.600]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.600]                   sendCondition(cond)
[17:02:53.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.600]                   {
[17:02:53.600]                     inherits <- base::inherits
[17:02:53.600]                     invokeRestart <- base::invokeRestart
[17:02:53.600]                     is.null <- base::is.null
[17:02:53.600]                     muffled <- FALSE
[17:02:53.600]                     if (inherits(cond, "message")) {
[17:02:53.600]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.600]                       if (muffled) 
[17:02:53.600]                         invokeRestart("muffleMessage")
[17:02:53.600]                     }
[17:02:53.600]                     else if (inherits(cond, "warning")) {
[17:02:53.600]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.600]                       if (muffled) 
[17:02:53.600]                         invokeRestart("muffleWarning")
[17:02:53.600]                     }
[17:02:53.600]                     else if (inherits(cond, "condition")) {
[17:02:53.600]                       if (!is.null(pattern)) {
[17:02:53.600]                         computeRestarts <- base::computeRestarts
[17:02:53.600]                         grepl <- base::grepl
[17:02:53.600]                         restarts <- computeRestarts(cond)
[17:02:53.600]                         for (restart in restarts) {
[17:02:53.600]                           name <- restart$name
[17:02:53.600]                           if (is.null(name)) 
[17:02:53.600]                             next
[17:02:53.600]                           if (!grepl(pattern, name)) 
[17:02:53.600]                             next
[17:02:53.600]                           invokeRestart(restart)
[17:02:53.600]                           muffled <- TRUE
[17:02:53.600]                           break
[17:02:53.600]                         }
[17:02:53.600]                       }
[17:02:53.600]                     }
[17:02:53.600]                     invisible(muffled)
[17:02:53.600]                   }
[17:02:53.600]                   muffleCondition(cond)
[17:02:53.600]                 })
[17:02:53.600]             }))
[17:02:53.600]             future::FutureResult(value = ...future.value$value, 
[17:02:53.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.600]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.600]                     ...future.globalenv.names))
[17:02:53.600]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.600]         }, condition = base::local({
[17:02:53.600]             c <- base::c
[17:02:53.600]             inherits <- base::inherits
[17:02:53.600]             invokeRestart <- base::invokeRestart
[17:02:53.600]             length <- base::length
[17:02:53.600]             list <- base::list
[17:02:53.600]             seq.int <- base::seq.int
[17:02:53.600]             signalCondition <- base::signalCondition
[17:02:53.600]             sys.calls <- base::sys.calls
[17:02:53.600]             `[[` <- base::`[[`
[17:02:53.600]             `+` <- base::`+`
[17:02:53.600]             `<<-` <- base::`<<-`
[17:02:53.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.600]                   3L)]
[17:02:53.600]             }
[17:02:53.600]             function(cond) {
[17:02:53.600]                 is_error <- inherits(cond, "error")
[17:02:53.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.600]                   NULL)
[17:02:53.600]                 if (is_error) {
[17:02:53.600]                   sessionInformation <- function() {
[17:02:53.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.600]                       search = base::search(), system = base::Sys.info())
[17:02:53.600]                   }
[17:02:53.600]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.600]                     cond$call), session = sessionInformation(), 
[17:02:53.600]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.600]                   signalCondition(cond)
[17:02:53.600]                 }
[17:02:53.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.600]                 "immediateCondition"))) {
[17:02:53.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.600]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.600]                   if (TRUE && !signal) {
[17:02:53.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.600]                     {
[17:02:53.600]                       inherits <- base::inherits
[17:02:53.600]                       invokeRestart <- base::invokeRestart
[17:02:53.600]                       is.null <- base::is.null
[17:02:53.600]                       muffled <- FALSE
[17:02:53.600]                       if (inherits(cond, "message")) {
[17:02:53.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.600]                         if (muffled) 
[17:02:53.600]                           invokeRestart("muffleMessage")
[17:02:53.600]                       }
[17:02:53.600]                       else if (inherits(cond, "warning")) {
[17:02:53.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.600]                         if (muffled) 
[17:02:53.600]                           invokeRestart("muffleWarning")
[17:02:53.600]                       }
[17:02:53.600]                       else if (inherits(cond, "condition")) {
[17:02:53.600]                         if (!is.null(pattern)) {
[17:02:53.600]                           computeRestarts <- base::computeRestarts
[17:02:53.600]                           grepl <- base::grepl
[17:02:53.600]                           restarts <- computeRestarts(cond)
[17:02:53.600]                           for (restart in restarts) {
[17:02:53.600]                             name <- restart$name
[17:02:53.600]                             if (is.null(name)) 
[17:02:53.600]                               next
[17:02:53.600]                             if (!grepl(pattern, name)) 
[17:02:53.600]                               next
[17:02:53.600]                             invokeRestart(restart)
[17:02:53.600]                             muffled <- TRUE
[17:02:53.600]                             break
[17:02:53.600]                           }
[17:02:53.600]                         }
[17:02:53.600]                       }
[17:02:53.600]                       invisible(muffled)
[17:02:53.600]                     }
[17:02:53.600]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.600]                   }
[17:02:53.600]                 }
[17:02:53.600]                 else {
[17:02:53.600]                   if (TRUE) {
[17:02:53.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.600]                     {
[17:02:53.600]                       inherits <- base::inherits
[17:02:53.600]                       invokeRestart <- base::invokeRestart
[17:02:53.600]                       is.null <- base::is.null
[17:02:53.600]                       muffled <- FALSE
[17:02:53.600]                       if (inherits(cond, "message")) {
[17:02:53.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.600]                         if (muffled) 
[17:02:53.600]                           invokeRestart("muffleMessage")
[17:02:53.600]                       }
[17:02:53.600]                       else if (inherits(cond, "warning")) {
[17:02:53.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.600]                         if (muffled) 
[17:02:53.600]                           invokeRestart("muffleWarning")
[17:02:53.600]                       }
[17:02:53.600]                       else if (inherits(cond, "condition")) {
[17:02:53.600]                         if (!is.null(pattern)) {
[17:02:53.600]                           computeRestarts <- base::computeRestarts
[17:02:53.600]                           grepl <- base::grepl
[17:02:53.600]                           restarts <- computeRestarts(cond)
[17:02:53.600]                           for (restart in restarts) {
[17:02:53.600]                             name <- restart$name
[17:02:53.600]                             if (is.null(name)) 
[17:02:53.600]                               next
[17:02:53.600]                             if (!grepl(pattern, name)) 
[17:02:53.600]                               next
[17:02:53.600]                             invokeRestart(restart)
[17:02:53.600]                             muffled <- TRUE
[17:02:53.600]                             break
[17:02:53.600]                           }
[17:02:53.600]                         }
[17:02:53.600]                       }
[17:02:53.600]                       invisible(muffled)
[17:02:53.600]                     }
[17:02:53.600]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.600]                   }
[17:02:53.600]                 }
[17:02:53.600]             }
[17:02:53.600]         }))
[17:02:53.600]     }, error = function(ex) {
[17:02:53.600]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.600]                 ...future.rng), started = ...future.startTime, 
[17:02:53.600]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.600]             version = "1.8"), class = "FutureResult")
[17:02:53.600]     }, finally = {
[17:02:53.600]         if (!identical(...future.workdir, getwd())) 
[17:02:53.600]             setwd(...future.workdir)
[17:02:53.600]         {
[17:02:53.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.600]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.600]             }
[17:02:53.600]             base::options(...future.oldOptions)
[17:02:53.600]             if (.Platform$OS.type == "windows") {
[17:02:53.600]                 old_names <- names(...future.oldEnvVars)
[17:02:53.600]                 envs <- base::Sys.getenv()
[17:02:53.600]                 names <- names(envs)
[17:02:53.600]                 common <- intersect(names, old_names)
[17:02:53.600]                 added <- setdiff(names, old_names)
[17:02:53.600]                 removed <- setdiff(old_names, names)
[17:02:53.600]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.600]                   envs[common]]
[17:02:53.600]                 NAMES <- toupper(changed)
[17:02:53.600]                 args <- list()
[17:02:53.600]                 for (kk in seq_along(NAMES)) {
[17:02:53.600]                   name <- changed[[kk]]
[17:02:53.600]                   NAME <- NAMES[[kk]]
[17:02:53.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.600]                     next
[17:02:53.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.600]                 }
[17:02:53.600]                 NAMES <- toupper(added)
[17:02:53.600]                 for (kk in seq_along(NAMES)) {
[17:02:53.600]                   name <- added[[kk]]
[17:02:53.600]                   NAME <- NAMES[[kk]]
[17:02:53.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.600]                     next
[17:02:53.600]                   args[[name]] <- ""
[17:02:53.600]                 }
[17:02:53.600]                 NAMES <- toupper(removed)
[17:02:53.600]                 for (kk in seq_along(NAMES)) {
[17:02:53.600]                   name <- removed[[kk]]
[17:02:53.600]                   NAME <- NAMES[[kk]]
[17:02:53.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.600]                     next
[17:02:53.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.600]                 }
[17:02:53.600]                 if (length(args) > 0) 
[17:02:53.600]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.600]             }
[17:02:53.600]             else {
[17:02:53.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.600]             }
[17:02:53.600]             {
[17:02:53.600]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.600]                   0L) {
[17:02:53.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.600]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.600]                   base::options(opts)
[17:02:53.600]                 }
[17:02:53.600]                 {
[17:02:53.600]                   {
[17:02:53.600]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.600]                     NULL
[17:02:53.600]                   }
[17:02:53.600]                   options(future.plan = NULL)
[17:02:53.600]                   if (is.na(NA_character_)) 
[17:02:53.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.600]                     .init = FALSE)
[17:02:53.600]                 }
[17:02:53.600]             }
[17:02:53.600]         }
[17:02:53.600]     })
[17:02:53.600]     if (TRUE) {
[17:02:53.600]         base::sink(type = "output", split = FALSE)
[17:02:53.600]         if (TRUE) {
[17:02:53.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.600]         }
[17:02:53.600]         else {
[17:02:53.600]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.600]         }
[17:02:53.600]         base::close(...future.stdout)
[17:02:53.600]         ...future.stdout <- NULL
[17:02:53.600]     }
[17:02:53.600]     ...future.result$conditions <- ...future.conditions
[17:02:53.600]     ...future.result$finished <- base::Sys.time()
[17:02:53.600]     ...future.result
[17:02:53.600] }
[17:02:53.603] MultisessionFuture started
[17:02:53.603] - Launch lazy future ... done
[17:02:53.603] run() for ‘MultisessionFuture’ ... done
[17:02:53.604] result() for ClusterFuture ...
[17:02:53.604] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.604] - Validating connection of MultisessionFuture
[17:02:53.606] - received message: FutureResult
[17:02:53.606] - Received FutureResult
[17:02:53.606] - Erased future from FutureRegistry
[17:02:53.606] result() for ClusterFuture ...
[17:02:53.607] - result already collected: FutureResult
[17:02:53.607] result() for ClusterFuture ... done
[17:02:53.607] signalConditions() ...
[17:02:53.607]  - include = ‘immediateCondition’
[17:02:53.607]  - exclude = 
[17:02:53.607]  - resignal = FALSE
[17:02:53.607]  - Number of conditions: 1
[17:02:53.607] signalConditions() ... done
[17:02:53.607] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.608] result() for ClusterFuture ... done
[17:02:53.608] result() for ClusterFuture ...
[17:02:53.608] - result already collected: FutureResult
[17:02:53.608] result() for ClusterFuture ... done
[17:02:53.608] signalConditions() ...
[17:02:53.608]  - include = ‘immediateCondition’
[17:02:53.608]  - exclude = 
[17:02:53.608]  - resignal = FALSE
[17:02:53.608]  - Number of conditions: 1
[17:02:53.609] signalConditions() ... done
[17:02:53.609] Future state: ‘finished’
[17:02:53.609] result() for ClusterFuture ...
[17:02:53.609] - result already collected: FutureResult
[17:02:53.609] result() for ClusterFuture ... done
[17:02:53.609] signalConditions() ...
[17:02:53.609]  - include = ‘condition’
[17:02:53.609]  - exclude = ‘immediateCondition’
[17:02:53.609]  - resignal = TRUE
[17:02:53.610]  - Number of conditions: 1
[17:02:53.610]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:53.610] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.626] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.626] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.628] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:02:53.628] Searching for globals ... DONE
[17:02:53.628] Resolving globals: TRUE
[17:02:53.629] Resolving any globals that are futures ...
[17:02:53.629] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:02:53.629] Resolving any globals that are futures ... DONE
[17:02:53.629] 
[17:02:53.629] 
[17:02:53.629] getGlobalsAndPackages() ... DONE
[17:02:53.630] run() for ‘Future’ ...
[17:02:53.630] - state: ‘created’
[17:02:53.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.645] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.646]   - Field: ‘node’
[17:02:53.646]   - Field: ‘label’
[17:02:53.646]   - Field: ‘local’
[17:02:53.646]   - Field: ‘owner’
[17:02:53.646]   - Field: ‘envir’
[17:02:53.646]   - Field: ‘workers’
[17:02:53.646]   - Field: ‘packages’
[17:02:53.646]   - Field: ‘gc’
[17:02:53.646]   - Field: ‘conditions’
[17:02:53.647]   - Field: ‘persistent’
[17:02:53.647]   - Field: ‘expr’
[17:02:53.647]   - Field: ‘uuid’
[17:02:53.647]   - Field: ‘seed’
[17:02:53.647]   - Field: ‘version’
[17:02:53.647]   - Field: ‘result’
[17:02:53.647]   - Field: ‘asynchronous’
[17:02:53.647]   - Field: ‘calls’
[17:02:53.648]   - Field: ‘globals’
[17:02:53.648]   - Field: ‘stdout’
[17:02:53.648]   - Field: ‘earlySignal’
[17:02:53.648]   - Field: ‘lazy’
[17:02:53.648]   - Field: ‘state’
[17:02:53.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.648] - Launch lazy future ...
[17:02:53.649] Packages needed by the future expression (n = 0): <none>
[17:02:53.649] Packages needed by future strategies (n = 0): <none>
[17:02:53.649] {
[17:02:53.649]     {
[17:02:53.649]         {
[17:02:53.649]             ...future.startTime <- base::Sys.time()
[17:02:53.649]             {
[17:02:53.649]                 {
[17:02:53.649]                   {
[17:02:53.649]                     {
[17:02:53.649]                       base::local({
[17:02:53.649]                         has_future <- base::requireNamespace("future", 
[17:02:53.649]                           quietly = TRUE)
[17:02:53.649]                         if (has_future) {
[17:02:53.649]                           ns <- base::getNamespace("future")
[17:02:53.649]                           version <- ns[[".package"]][["version"]]
[17:02:53.649]                           if (is.null(version)) 
[17:02:53.649]                             version <- utils::packageVersion("future")
[17:02:53.649]                         }
[17:02:53.649]                         else {
[17:02:53.649]                           version <- NULL
[17:02:53.649]                         }
[17:02:53.649]                         if (!has_future || version < "1.8.0") {
[17:02:53.649]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.649]                             "", base::R.version$version.string), 
[17:02:53.649]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.649]                               "release", "version")], collapse = " "), 
[17:02:53.649]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.649]                             info)
[17:02:53.649]                           info <- base::paste(info, collapse = "; ")
[17:02:53.649]                           if (!has_future) {
[17:02:53.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.649]                               info)
[17:02:53.649]                           }
[17:02:53.649]                           else {
[17:02:53.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.649]                               info, version)
[17:02:53.649]                           }
[17:02:53.649]                           base::stop(msg)
[17:02:53.649]                         }
[17:02:53.649]                       })
[17:02:53.649]                     }
[17:02:53.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.649]                     base::options(mc.cores = 1L)
[17:02:53.649]                   }
[17:02:53.649]                   ...future.strategy.old <- future::plan("list")
[17:02:53.649]                   options(future.plan = NULL)
[17:02:53.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.649]                 }
[17:02:53.649]                 ...future.workdir <- getwd()
[17:02:53.649]             }
[17:02:53.649]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.649]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.649]         }
[17:02:53.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.649]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.649]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.649]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.649]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.649]             base::names(...future.oldOptions))
[17:02:53.649]     }
[17:02:53.649]     if (FALSE) {
[17:02:53.649]     }
[17:02:53.649]     else {
[17:02:53.649]         if (TRUE) {
[17:02:53.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.649]                 open = "w")
[17:02:53.649]         }
[17:02:53.649]         else {
[17:02:53.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.649]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.649]         }
[17:02:53.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.649]             base::sink(type = "output", split = FALSE)
[17:02:53.649]             base::close(...future.stdout)
[17:02:53.649]         }, add = TRUE)
[17:02:53.649]     }
[17:02:53.649]     ...future.frame <- base::sys.nframe()
[17:02:53.649]     ...future.conditions <- base::list()
[17:02:53.649]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.649]     if (FALSE) {
[17:02:53.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.649]     }
[17:02:53.649]     ...future.result <- base::tryCatch({
[17:02:53.649]         base::withCallingHandlers({
[17:02:53.649]             ...future.value <- base::withVisible(base::local({
[17:02:53.649]                 ...future.makeSendCondition <- base::local({
[17:02:53.649]                   sendCondition <- NULL
[17:02:53.649]                   function(frame = 1L) {
[17:02:53.649]                     if (is.function(sendCondition)) 
[17:02:53.649]                       return(sendCondition)
[17:02:53.649]                     ns <- getNamespace("parallel")
[17:02:53.649]                     if (exists("sendData", mode = "function", 
[17:02:53.649]                       envir = ns)) {
[17:02:53.649]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.649]                         envir = ns)
[17:02:53.649]                       envir <- sys.frame(frame)
[17:02:53.649]                       master <- NULL
[17:02:53.649]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.649]                         !identical(envir, emptyenv())) {
[17:02:53.649]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.649]                           inherits = FALSE)) {
[17:02:53.649]                           master <- get("master", mode = "list", 
[17:02:53.649]                             envir = envir, inherits = FALSE)
[17:02:53.649]                           if (inherits(master, c("SOCKnode", 
[17:02:53.649]                             "SOCK0node"))) {
[17:02:53.649]                             sendCondition <<- function(cond) {
[17:02:53.649]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.649]                                 success = TRUE)
[17:02:53.649]                               parallel_sendData(master, data)
[17:02:53.649]                             }
[17:02:53.649]                             return(sendCondition)
[17:02:53.649]                           }
[17:02:53.649]                         }
[17:02:53.649]                         frame <- frame + 1L
[17:02:53.649]                         envir <- sys.frame(frame)
[17:02:53.649]                       }
[17:02:53.649]                     }
[17:02:53.649]                     sendCondition <<- function(cond) NULL
[17:02:53.649]                   }
[17:02:53.649]                 })
[17:02:53.649]                 withCallingHandlers({
[17:02:53.649]                   {
[17:02:53.649]                     b <- a
[17:02:53.649]                     a <- 2
[17:02:53.649]                     a * b
[17:02:53.649]                   }
[17:02:53.649]                 }, immediateCondition = function(cond) {
[17:02:53.649]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.649]                   sendCondition(cond)
[17:02:53.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.649]                   {
[17:02:53.649]                     inherits <- base::inherits
[17:02:53.649]                     invokeRestart <- base::invokeRestart
[17:02:53.649]                     is.null <- base::is.null
[17:02:53.649]                     muffled <- FALSE
[17:02:53.649]                     if (inherits(cond, "message")) {
[17:02:53.649]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.649]                       if (muffled) 
[17:02:53.649]                         invokeRestart("muffleMessage")
[17:02:53.649]                     }
[17:02:53.649]                     else if (inherits(cond, "warning")) {
[17:02:53.649]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.649]                       if (muffled) 
[17:02:53.649]                         invokeRestart("muffleWarning")
[17:02:53.649]                     }
[17:02:53.649]                     else if (inherits(cond, "condition")) {
[17:02:53.649]                       if (!is.null(pattern)) {
[17:02:53.649]                         computeRestarts <- base::computeRestarts
[17:02:53.649]                         grepl <- base::grepl
[17:02:53.649]                         restarts <- computeRestarts(cond)
[17:02:53.649]                         for (restart in restarts) {
[17:02:53.649]                           name <- restart$name
[17:02:53.649]                           if (is.null(name)) 
[17:02:53.649]                             next
[17:02:53.649]                           if (!grepl(pattern, name)) 
[17:02:53.649]                             next
[17:02:53.649]                           invokeRestart(restart)
[17:02:53.649]                           muffled <- TRUE
[17:02:53.649]                           break
[17:02:53.649]                         }
[17:02:53.649]                       }
[17:02:53.649]                     }
[17:02:53.649]                     invisible(muffled)
[17:02:53.649]                   }
[17:02:53.649]                   muffleCondition(cond)
[17:02:53.649]                 })
[17:02:53.649]             }))
[17:02:53.649]             future::FutureResult(value = ...future.value$value, 
[17:02:53.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.649]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.649]                     ...future.globalenv.names))
[17:02:53.649]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.649]         }, condition = base::local({
[17:02:53.649]             c <- base::c
[17:02:53.649]             inherits <- base::inherits
[17:02:53.649]             invokeRestart <- base::invokeRestart
[17:02:53.649]             length <- base::length
[17:02:53.649]             list <- base::list
[17:02:53.649]             seq.int <- base::seq.int
[17:02:53.649]             signalCondition <- base::signalCondition
[17:02:53.649]             sys.calls <- base::sys.calls
[17:02:53.649]             `[[` <- base::`[[`
[17:02:53.649]             `+` <- base::`+`
[17:02:53.649]             `<<-` <- base::`<<-`
[17:02:53.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.649]                   3L)]
[17:02:53.649]             }
[17:02:53.649]             function(cond) {
[17:02:53.649]                 is_error <- inherits(cond, "error")
[17:02:53.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.649]                   NULL)
[17:02:53.649]                 if (is_error) {
[17:02:53.649]                   sessionInformation <- function() {
[17:02:53.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.649]                       search = base::search(), system = base::Sys.info())
[17:02:53.649]                   }
[17:02:53.649]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.649]                     cond$call), session = sessionInformation(), 
[17:02:53.649]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.649]                   signalCondition(cond)
[17:02:53.649]                 }
[17:02:53.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.649]                 "immediateCondition"))) {
[17:02:53.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.649]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.649]                   if (TRUE && !signal) {
[17:02:53.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.649]                     {
[17:02:53.649]                       inherits <- base::inherits
[17:02:53.649]                       invokeRestart <- base::invokeRestart
[17:02:53.649]                       is.null <- base::is.null
[17:02:53.649]                       muffled <- FALSE
[17:02:53.649]                       if (inherits(cond, "message")) {
[17:02:53.649]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.649]                         if (muffled) 
[17:02:53.649]                           invokeRestart("muffleMessage")
[17:02:53.649]                       }
[17:02:53.649]                       else if (inherits(cond, "warning")) {
[17:02:53.649]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.649]                         if (muffled) 
[17:02:53.649]                           invokeRestart("muffleWarning")
[17:02:53.649]                       }
[17:02:53.649]                       else if (inherits(cond, "condition")) {
[17:02:53.649]                         if (!is.null(pattern)) {
[17:02:53.649]                           computeRestarts <- base::computeRestarts
[17:02:53.649]                           grepl <- base::grepl
[17:02:53.649]                           restarts <- computeRestarts(cond)
[17:02:53.649]                           for (restart in restarts) {
[17:02:53.649]                             name <- restart$name
[17:02:53.649]                             if (is.null(name)) 
[17:02:53.649]                               next
[17:02:53.649]                             if (!grepl(pattern, name)) 
[17:02:53.649]                               next
[17:02:53.649]                             invokeRestart(restart)
[17:02:53.649]                             muffled <- TRUE
[17:02:53.649]                             break
[17:02:53.649]                           }
[17:02:53.649]                         }
[17:02:53.649]                       }
[17:02:53.649]                       invisible(muffled)
[17:02:53.649]                     }
[17:02:53.649]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.649]                   }
[17:02:53.649]                 }
[17:02:53.649]                 else {
[17:02:53.649]                   if (TRUE) {
[17:02:53.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.649]                     {
[17:02:53.649]                       inherits <- base::inherits
[17:02:53.649]                       invokeRestart <- base::invokeRestart
[17:02:53.649]                       is.null <- base::is.null
[17:02:53.649]                       muffled <- FALSE
[17:02:53.649]                       if (inherits(cond, "message")) {
[17:02:53.649]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.649]                         if (muffled) 
[17:02:53.649]                           invokeRestart("muffleMessage")
[17:02:53.649]                       }
[17:02:53.649]                       else if (inherits(cond, "warning")) {
[17:02:53.649]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.649]                         if (muffled) 
[17:02:53.649]                           invokeRestart("muffleWarning")
[17:02:53.649]                       }
[17:02:53.649]                       else if (inherits(cond, "condition")) {
[17:02:53.649]                         if (!is.null(pattern)) {
[17:02:53.649]                           computeRestarts <- base::computeRestarts
[17:02:53.649]                           grepl <- base::grepl
[17:02:53.649]                           restarts <- computeRestarts(cond)
[17:02:53.649]                           for (restart in restarts) {
[17:02:53.649]                             name <- restart$name
[17:02:53.649]                             if (is.null(name)) 
[17:02:53.649]                               next
[17:02:53.649]                             if (!grepl(pattern, name)) 
[17:02:53.649]                               next
[17:02:53.649]                             invokeRestart(restart)
[17:02:53.649]                             muffled <- TRUE
[17:02:53.649]                             break
[17:02:53.649]                           }
[17:02:53.649]                         }
[17:02:53.649]                       }
[17:02:53.649]                       invisible(muffled)
[17:02:53.649]                     }
[17:02:53.649]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.649]                   }
[17:02:53.649]                 }
[17:02:53.649]             }
[17:02:53.649]         }))
[17:02:53.649]     }, error = function(ex) {
[17:02:53.649]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.649]                 ...future.rng), started = ...future.startTime, 
[17:02:53.649]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.649]             version = "1.8"), class = "FutureResult")
[17:02:53.649]     }, finally = {
[17:02:53.649]         if (!identical(...future.workdir, getwd())) 
[17:02:53.649]             setwd(...future.workdir)
[17:02:53.649]         {
[17:02:53.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.649]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.649]             }
[17:02:53.649]             base::options(...future.oldOptions)
[17:02:53.649]             if (.Platform$OS.type == "windows") {
[17:02:53.649]                 old_names <- names(...future.oldEnvVars)
[17:02:53.649]                 envs <- base::Sys.getenv()
[17:02:53.649]                 names <- names(envs)
[17:02:53.649]                 common <- intersect(names, old_names)
[17:02:53.649]                 added <- setdiff(names, old_names)
[17:02:53.649]                 removed <- setdiff(old_names, names)
[17:02:53.649]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.649]                   envs[common]]
[17:02:53.649]                 NAMES <- toupper(changed)
[17:02:53.649]                 args <- list()
[17:02:53.649]                 for (kk in seq_along(NAMES)) {
[17:02:53.649]                   name <- changed[[kk]]
[17:02:53.649]                   NAME <- NAMES[[kk]]
[17:02:53.649]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.649]                     next
[17:02:53.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.649]                 }
[17:02:53.649]                 NAMES <- toupper(added)
[17:02:53.649]                 for (kk in seq_along(NAMES)) {
[17:02:53.649]                   name <- added[[kk]]
[17:02:53.649]                   NAME <- NAMES[[kk]]
[17:02:53.649]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.649]                     next
[17:02:53.649]                   args[[name]] <- ""
[17:02:53.649]                 }
[17:02:53.649]                 NAMES <- toupper(removed)
[17:02:53.649]                 for (kk in seq_along(NAMES)) {
[17:02:53.649]                   name <- removed[[kk]]
[17:02:53.649]                   NAME <- NAMES[[kk]]
[17:02:53.649]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.649]                     next
[17:02:53.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.649]                 }
[17:02:53.649]                 if (length(args) > 0) 
[17:02:53.649]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.649]             }
[17:02:53.649]             else {
[17:02:53.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.649]             }
[17:02:53.649]             {
[17:02:53.649]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.649]                   0L) {
[17:02:53.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.649]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.649]                   base::options(opts)
[17:02:53.649]                 }
[17:02:53.649]                 {
[17:02:53.649]                   {
[17:02:53.649]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.649]                     NULL
[17:02:53.649]                   }
[17:02:53.649]                   options(future.plan = NULL)
[17:02:53.649]                   if (is.na(NA_character_)) 
[17:02:53.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.649]                     .init = FALSE)
[17:02:53.649]                 }
[17:02:53.649]             }
[17:02:53.649]         }
[17:02:53.649]     })
[17:02:53.649]     if (TRUE) {
[17:02:53.649]         base::sink(type = "output", split = FALSE)
[17:02:53.649]         if (TRUE) {
[17:02:53.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.649]         }
[17:02:53.649]         else {
[17:02:53.649]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.649]         }
[17:02:53.649]         base::close(...future.stdout)
[17:02:53.649]         ...future.stdout <- NULL
[17:02:53.649]     }
[17:02:53.649]     ...future.result$conditions <- ...future.conditions
[17:02:53.649]     ...future.result$finished <- base::Sys.time()
[17:02:53.649]     ...future.result
[17:02:53.649] }
[17:02:53.653] MultisessionFuture started
[17:02:53.653] - Launch lazy future ... done
[17:02:53.653] run() for ‘MultisessionFuture’ ... done
[17:02:53.653] result() for ClusterFuture ...
[17:02:53.653] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.653] - Validating connection of MultisessionFuture
[17:02:53.658] - received message: FutureResult
[17:02:53.659] - Received FutureResult
[17:02:53.661] - Erased future from FutureRegistry
[17:02:53.661] result() for ClusterFuture ...
[17:02:53.661] - result already collected: FutureResult
[17:02:53.661] result() for ClusterFuture ... done
[17:02:53.661] signalConditions() ...
[17:02:53.662]  - include = ‘immediateCondition’
[17:02:53.662]  - exclude = 
[17:02:53.662]  - resignal = FALSE
[17:02:53.662]  - Number of conditions: 1
[17:02:53.662] signalConditions() ... done
[17:02:53.662] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.662] result() for ClusterFuture ... done
[17:02:53.662] result() for ClusterFuture ...
[17:02:53.662] - result already collected: FutureResult
[17:02:53.662] result() for ClusterFuture ... done
[17:02:53.662] signalConditions() ...
[17:02:53.662]  - include = ‘immediateCondition’
[17:02:53.663]  - exclude = 
[17:02:53.663]  - resignal = FALSE
[17:02:53.663]  - Number of conditions: 1
[17:02:53.663] signalConditions() ... done
[17:02:53.663] Future state: ‘finished’
[17:02:53.663] result() for ClusterFuture ...
[17:02:53.663] - result already collected: FutureResult
[17:02:53.663] result() for ClusterFuture ... done
[17:02:53.663] signalConditions() ...
[17:02:53.663]  - include = ‘condition’
[17:02:53.663]  - exclude = ‘immediateCondition’
[17:02:53.664]  - resignal = TRUE
[17:02:53.664]  - Number of conditions: 1
[17:02:53.664]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:53.664] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.678] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.678] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.679] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.679] Searching for globals ... DONE
[17:02:53.680] Resolving globals: TRUE
[17:02:53.680] Resolving any globals that are futures ...
[17:02:53.680] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.680] Resolving any globals that are futures ... DONE
[17:02:53.680] Resolving futures part of globals (recursively) ...
[17:02:53.680] resolve() on list ...
[17:02:53.680]  recursive: 99
[17:02:53.681]  length: 1
[17:02:53.681]  elements: ‘ii’
[17:02:53.681]  length: 0 (resolved future 1)
[17:02:53.681] resolve() on list ... DONE
[17:02:53.681] - globals: [1] ‘ii’
[17:02:53.681] Resolving futures part of globals (recursively) ... DONE
[17:02:53.681] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:53.682] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:53.682] - globals: [1] ‘ii’
[17:02:53.682] 
[17:02:53.682] getGlobalsAndPackages() ... DONE
[17:02:53.682] run() for ‘Future’ ...
[17:02:53.682] - state: ‘created’
[17:02:53.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.697]   - Field: ‘node’
[17:02:53.697]   - Field: ‘label’
[17:02:53.697]   - Field: ‘local’
[17:02:53.697]   - Field: ‘owner’
[17:02:53.697]   - Field: ‘envir’
[17:02:53.697]   - Field: ‘workers’
[17:02:53.697]   - Field: ‘packages’
[17:02:53.697]   - Field: ‘gc’
[17:02:53.697]   - Field: ‘conditions’
[17:02:53.698]   - Field: ‘persistent’
[17:02:53.698]   - Field: ‘expr’
[17:02:53.698]   - Field: ‘uuid’
[17:02:53.698]   - Field: ‘seed’
[17:02:53.698]   - Field: ‘version’
[17:02:53.698]   - Field: ‘result’
[17:02:53.698]   - Field: ‘asynchronous’
[17:02:53.698]   - Field: ‘calls’
[17:02:53.698]   - Field: ‘globals’
[17:02:53.698]   - Field: ‘stdout’
[17:02:53.698]   - Field: ‘earlySignal’
[17:02:53.699]   - Field: ‘lazy’
[17:02:53.699]   - Field: ‘state’
[17:02:53.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.699] - Launch lazy future ...
[17:02:53.699] Packages needed by the future expression (n = 0): <none>
[17:02:53.699] Packages needed by future strategies (n = 0): <none>
[17:02:53.700] {
[17:02:53.700]     {
[17:02:53.700]         {
[17:02:53.700]             ...future.startTime <- base::Sys.time()
[17:02:53.700]             {
[17:02:53.700]                 {
[17:02:53.700]                   {
[17:02:53.700]                     {
[17:02:53.700]                       base::local({
[17:02:53.700]                         has_future <- base::requireNamespace("future", 
[17:02:53.700]                           quietly = TRUE)
[17:02:53.700]                         if (has_future) {
[17:02:53.700]                           ns <- base::getNamespace("future")
[17:02:53.700]                           version <- ns[[".package"]][["version"]]
[17:02:53.700]                           if (is.null(version)) 
[17:02:53.700]                             version <- utils::packageVersion("future")
[17:02:53.700]                         }
[17:02:53.700]                         else {
[17:02:53.700]                           version <- NULL
[17:02:53.700]                         }
[17:02:53.700]                         if (!has_future || version < "1.8.0") {
[17:02:53.700]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.700]                             "", base::R.version$version.string), 
[17:02:53.700]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.700]                               "release", "version")], collapse = " "), 
[17:02:53.700]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.700]                             info)
[17:02:53.700]                           info <- base::paste(info, collapse = "; ")
[17:02:53.700]                           if (!has_future) {
[17:02:53.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.700]                               info)
[17:02:53.700]                           }
[17:02:53.700]                           else {
[17:02:53.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.700]                               info, version)
[17:02:53.700]                           }
[17:02:53.700]                           base::stop(msg)
[17:02:53.700]                         }
[17:02:53.700]                       })
[17:02:53.700]                     }
[17:02:53.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.700]                     base::options(mc.cores = 1L)
[17:02:53.700]                   }
[17:02:53.700]                   ...future.strategy.old <- future::plan("list")
[17:02:53.700]                   options(future.plan = NULL)
[17:02:53.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.700]                 }
[17:02:53.700]                 ...future.workdir <- getwd()
[17:02:53.700]             }
[17:02:53.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.700]         }
[17:02:53.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.700]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.700]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.700]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.700]             base::names(...future.oldOptions))
[17:02:53.700]     }
[17:02:53.700]     if (FALSE) {
[17:02:53.700]     }
[17:02:53.700]     else {
[17:02:53.700]         if (TRUE) {
[17:02:53.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.700]                 open = "w")
[17:02:53.700]         }
[17:02:53.700]         else {
[17:02:53.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.700]         }
[17:02:53.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.700]             base::sink(type = "output", split = FALSE)
[17:02:53.700]             base::close(...future.stdout)
[17:02:53.700]         }, add = TRUE)
[17:02:53.700]     }
[17:02:53.700]     ...future.frame <- base::sys.nframe()
[17:02:53.700]     ...future.conditions <- base::list()
[17:02:53.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.700]     if (FALSE) {
[17:02:53.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.700]     }
[17:02:53.700]     ...future.result <- base::tryCatch({
[17:02:53.700]         base::withCallingHandlers({
[17:02:53.700]             ...future.value <- base::withVisible(base::local({
[17:02:53.700]                 ...future.makeSendCondition <- base::local({
[17:02:53.700]                   sendCondition <- NULL
[17:02:53.700]                   function(frame = 1L) {
[17:02:53.700]                     if (is.function(sendCondition)) 
[17:02:53.700]                       return(sendCondition)
[17:02:53.700]                     ns <- getNamespace("parallel")
[17:02:53.700]                     if (exists("sendData", mode = "function", 
[17:02:53.700]                       envir = ns)) {
[17:02:53.700]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.700]                         envir = ns)
[17:02:53.700]                       envir <- sys.frame(frame)
[17:02:53.700]                       master <- NULL
[17:02:53.700]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.700]                         !identical(envir, emptyenv())) {
[17:02:53.700]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.700]                           inherits = FALSE)) {
[17:02:53.700]                           master <- get("master", mode = "list", 
[17:02:53.700]                             envir = envir, inherits = FALSE)
[17:02:53.700]                           if (inherits(master, c("SOCKnode", 
[17:02:53.700]                             "SOCK0node"))) {
[17:02:53.700]                             sendCondition <<- function(cond) {
[17:02:53.700]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.700]                                 success = TRUE)
[17:02:53.700]                               parallel_sendData(master, data)
[17:02:53.700]                             }
[17:02:53.700]                             return(sendCondition)
[17:02:53.700]                           }
[17:02:53.700]                         }
[17:02:53.700]                         frame <- frame + 1L
[17:02:53.700]                         envir <- sys.frame(frame)
[17:02:53.700]                       }
[17:02:53.700]                     }
[17:02:53.700]                     sendCondition <<- function(cond) NULL
[17:02:53.700]                   }
[17:02:53.700]                 })
[17:02:53.700]                 withCallingHandlers({
[17:02:53.700]                   {
[17:02:53.700]                     b <- a * ii
[17:02:53.700]                     a <- 0
[17:02:53.700]                     b
[17:02:53.700]                   }
[17:02:53.700]                 }, immediateCondition = function(cond) {
[17:02:53.700]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.700]                   sendCondition(cond)
[17:02:53.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.700]                   {
[17:02:53.700]                     inherits <- base::inherits
[17:02:53.700]                     invokeRestart <- base::invokeRestart
[17:02:53.700]                     is.null <- base::is.null
[17:02:53.700]                     muffled <- FALSE
[17:02:53.700]                     if (inherits(cond, "message")) {
[17:02:53.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.700]                       if (muffled) 
[17:02:53.700]                         invokeRestart("muffleMessage")
[17:02:53.700]                     }
[17:02:53.700]                     else if (inherits(cond, "warning")) {
[17:02:53.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.700]                       if (muffled) 
[17:02:53.700]                         invokeRestart("muffleWarning")
[17:02:53.700]                     }
[17:02:53.700]                     else if (inherits(cond, "condition")) {
[17:02:53.700]                       if (!is.null(pattern)) {
[17:02:53.700]                         computeRestarts <- base::computeRestarts
[17:02:53.700]                         grepl <- base::grepl
[17:02:53.700]                         restarts <- computeRestarts(cond)
[17:02:53.700]                         for (restart in restarts) {
[17:02:53.700]                           name <- restart$name
[17:02:53.700]                           if (is.null(name)) 
[17:02:53.700]                             next
[17:02:53.700]                           if (!grepl(pattern, name)) 
[17:02:53.700]                             next
[17:02:53.700]                           invokeRestart(restart)
[17:02:53.700]                           muffled <- TRUE
[17:02:53.700]                           break
[17:02:53.700]                         }
[17:02:53.700]                       }
[17:02:53.700]                     }
[17:02:53.700]                     invisible(muffled)
[17:02:53.700]                   }
[17:02:53.700]                   muffleCondition(cond)
[17:02:53.700]                 })
[17:02:53.700]             }))
[17:02:53.700]             future::FutureResult(value = ...future.value$value, 
[17:02:53.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.700]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.700]                     ...future.globalenv.names))
[17:02:53.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.700]         }, condition = base::local({
[17:02:53.700]             c <- base::c
[17:02:53.700]             inherits <- base::inherits
[17:02:53.700]             invokeRestart <- base::invokeRestart
[17:02:53.700]             length <- base::length
[17:02:53.700]             list <- base::list
[17:02:53.700]             seq.int <- base::seq.int
[17:02:53.700]             signalCondition <- base::signalCondition
[17:02:53.700]             sys.calls <- base::sys.calls
[17:02:53.700]             `[[` <- base::`[[`
[17:02:53.700]             `+` <- base::`+`
[17:02:53.700]             `<<-` <- base::`<<-`
[17:02:53.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.700]                   3L)]
[17:02:53.700]             }
[17:02:53.700]             function(cond) {
[17:02:53.700]                 is_error <- inherits(cond, "error")
[17:02:53.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.700]                   NULL)
[17:02:53.700]                 if (is_error) {
[17:02:53.700]                   sessionInformation <- function() {
[17:02:53.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.700]                       search = base::search(), system = base::Sys.info())
[17:02:53.700]                   }
[17:02:53.700]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.700]                     cond$call), session = sessionInformation(), 
[17:02:53.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.700]                   signalCondition(cond)
[17:02:53.700]                 }
[17:02:53.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.700]                 "immediateCondition"))) {
[17:02:53.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.700]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.700]                   if (TRUE && !signal) {
[17:02:53.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.700]                     {
[17:02:53.700]                       inherits <- base::inherits
[17:02:53.700]                       invokeRestart <- base::invokeRestart
[17:02:53.700]                       is.null <- base::is.null
[17:02:53.700]                       muffled <- FALSE
[17:02:53.700]                       if (inherits(cond, "message")) {
[17:02:53.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.700]                         if (muffled) 
[17:02:53.700]                           invokeRestart("muffleMessage")
[17:02:53.700]                       }
[17:02:53.700]                       else if (inherits(cond, "warning")) {
[17:02:53.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.700]                         if (muffled) 
[17:02:53.700]                           invokeRestart("muffleWarning")
[17:02:53.700]                       }
[17:02:53.700]                       else if (inherits(cond, "condition")) {
[17:02:53.700]                         if (!is.null(pattern)) {
[17:02:53.700]                           computeRestarts <- base::computeRestarts
[17:02:53.700]                           grepl <- base::grepl
[17:02:53.700]                           restarts <- computeRestarts(cond)
[17:02:53.700]                           for (restart in restarts) {
[17:02:53.700]                             name <- restart$name
[17:02:53.700]                             if (is.null(name)) 
[17:02:53.700]                               next
[17:02:53.700]                             if (!grepl(pattern, name)) 
[17:02:53.700]                               next
[17:02:53.700]                             invokeRestart(restart)
[17:02:53.700]                             muffled <- TRUE
[17:02:53.700]                             break
[17:02:53.700]                           }
[17:02:53.700]                         }
[17:02:53.700]                       }
[17:02:53.700]                       invisible(muffled)
[17:02:53.700]                     }
[17:02:53.700]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.700]                   }
[17:02:53.700]                 }
[17:02:53.700]                 else {
[17:02:53.700]                   if (TRUE) {
[17:02:53.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.700]                     {
[17:02:53.700]                       inherits <- base::inherits
[17:02:53.700]                       invokeRestart <- base::invokeRestart
[17:02:53.700]                       is.null <- base::is.null
[17:02:53.700]                       muffled <- FALSE
[17:02:53.700]                       if (inherits(cond, "message")) {
[17:02:53.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.700]                         if (muffled) 
[17:02:53.700]                           invokeRestart("muffleMessage")
[17:02:53.700]                       }
[17:02:53.700]                       else if (inherits(cond, "warning")) {
[17:02:53.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.700]                         if (muffled) 
[17:02:53.700]                           invokeRestart("muffleWarning")
[17:02:53.700]                       }
[17:02:53.700]                       else if (inherits(cond, "condition")) {
[17:02:53.700]                         if (!is.null(pattern)) {
[17:02:53.700]                           computeRestarts <- base::computeRestarts
[17:02:53.700]                           grepl <- base::grepl
[17:02:53.700]                           restarts <- computeRestarts(cond)
[17:02:53.700]                           for (restart in restarts) {
[17:02:53.700]                             name <- restart$name
[17:02:53.700]                             if (is.null(name)) 
[17:02:53.700]                               next
[17:02:53.700]                             if (!grepl(pattern, name)) 
[17:02:53.700]                               next
[17:02:53.700]                             invokeRestart(restart)
[17:02:53.700]                             muffled <- TRUE
[17:02:53.700]                             break
[17:02:53.700]                           }
[17:02:53.700]                         }
[17:02:53.700]                       }
[17:02:53.700]                       invisible(muffled)
[17:02:53.700]                     }
[17:02:53.700]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.700]                   }
[17:02:53.700]                 }
[17:02:53.700]             }
[17:02:53.700]         }))
[17:02:53.700]     }, error = function(ex) {
[17:02:53.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.700]                 ...future.rng), started = ...future.startTime, 
[17:02:53.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.700]             version = "1.8"), class = "FutureResult")
[17:02:53.700]     }, finally = {
[17:02:53.700]         if (!identical(...future.workdir, getwd())) 
[17:02:53.700]             setwd(...future.workdir)
[17:02:53.700]         {
[17:02:53.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.700]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.700]             }
[17:02:53.700]             base::options(...future.oldOptions)
[17:02:53.700]             if (.Platform$OS.type == "windows") {
[17:02:53.700]                 old_names <- names(...future.oldEnvVars)
[17:02:53.700]                 envs <- base::Sys.getenv()
[17:02:53.700]                 names <- names(envs)
[17:02:53.700]                 common <- intersect(names, old_names)
[17:02:53.700]                 added <- setdiff(names, old_names)
[17:02:53.700]                 removed <- setdiff(old_names, names)
[17:02:53.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.700]                   envs[common]]
[17:02:53.700]                 NAMES <- toupper(changed)
[17:02:53.700]                 args <- list()
[17:02:53.700]                 for (kk in seq_along(NAMES)) {
[17:02:53.700]                   name <- changed[[kk]]
[17:02:53.700]                   NAME <- NAMES[[kk]]
[17:02:53.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.700]                     next
[17:02:53.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.700]                 }
[17:02:53.700]                 NAMES <- toupper(added)
[17:02:53.700]                 for (kk in seq_along(NAMES)) {
[17:02:53.700]                   name <- added[[kk]]
[17:02:53.700]                   NAME <- NAMES[[kk]]
[17:02:53.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.700]                     next
[17:02:53.700]                   args[[name]] <- ""
[17:02:53.700]                 }
[17:02:53.700]                 NAMES <- toupper(removed)
[17:02:53.700]                 for (kk in seq_along(NAMES)) {
[17:02:53.700]                   name <- removed[[kk]]
[17:02:53.700]                   NAME <- NAMES[[kk]]
[17:02:53.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.700]                     next
[17:02:53.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.700]                 }
[17:02:53.700]                 if (length(args) > 0) 
[17:02:53.700]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.700]             }
[17:02:53.700]             else {
[17:02:53.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.700]             }
[17:02:53.700]             {
[17:02:53.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.700]                   0L) {
[17:02:53.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.700]                   base::options(opts)
[17:02:53.700]                 }
[17:02:53.700]                 {
[17:02:53.700]                   {
[17:02:53.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.700]                     NULL
[17:02:53.700]                   }
[17:02:53.700]                   options(future.plan = NULL)
[17:02:53.700]                   if (is.na(NA_character_)) 
[17:02:53.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.700]                     .init = FALSE)
[17:02:53.700]                 }
[17:02:53.700]             }
[17:02:53.700]         }
[17:02:53.700]     })
[17:02:53.700]     if (TRUE) {
[17:02:53.700]         base::sink(type = "output", split = FALSE)
[17:02:53.700]         if (TRUE) {
[17:02:53.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.700]         }
[17:02:53.700]         else {
[17:02:53.700]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.700]         }
[17:02:53.700]         base::close(...future.stdout)
[17:02:53.700]         ...future.stdout <- NULL
[17:02:53.700]     }
[17:02:53.700]     ...future.result$conditions <- ...future.conditions
[17:02:53.700]     ...future.result$finished <- base::Sys.time()
[17:02:53.700]     ...future.result
[17:02:53.700] }
[17:02:53.703] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:02:53.703] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:02:53.703] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:02:53.703] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:02:53.704] MultisessionFuture started
[17:02:53.704] - Launch lazy future ... done
[17:02:53.704] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.704] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.705] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.706] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.706] Searching for globals ... DONE
[17:02:53.706] Resolving globals: TRUE
[17:02:53.706] Resolving any globals that are futures ...
[17:02:53.707] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.707] Resolving any globals that are futures ... DONE
[17:02:53.707] Resolving futures part of globals (recursively) ...
[17:02:53.707] resolve() on list ...
[17:02:53.707]  recursive: 99
[17:02:53.707]  length: 1
[17:02:53.708]  elements: ‘ii’
[17:02:53.708]  length: 0 (resolved future 1)
[17:02:53.708] resolve() on list ... DONE
[17:02:53.708] - globals: [1] ‘ii’
[17:02:53.708] Resolving futures part of globals (recursively) ... DONE
[17:02:53.708] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:53.708] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:53.709] - globals: [1] ‘ii’
[17:02:53.709] 
[17:02:53.709] getGlobalsAndPackages() ... DONE
[17:02:53.709] run() for ‘Future’ ...
[17:02:53.709] - state: ‘created’
[17:02:53.709] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.724]   - Field: ‘node’
[17:02:53.724]   - Field: ‘label’
[17:02:53.724]   - Field: ‘local’
[17:02:53.724]   - Field: ‘owner’
[17:02:53.724]   - Field: ‘envir’
[17:02:53.724]   - Field: ‘workers’
[17:02:53.724]   - Field: ‘packages’
[17:02:53.724]   - Field: ‘gc’
[17:02:53.724]   - Field: ‘conditions’
[17:02:53.725]   - Field: ‘persistent’
[17:02:53.725]   - Field: ‘expr’
[17:02:53.725]   - Field: ‘uuid’
[17:02:53.725]   - Field: ‘seed’
[17:02:53.725]   - Field: ‘version’
[17:02:53.725]   - Field: ‘result’
[17:02:53.725]   - Field: ‘asynchronous’
[17:02:53.725]   - Field: ‘calls’
[17:02:53.725]   - Field: ‘globals’
[17:02:53.725]   - Field: ‘stdout’
[17:02:53.725]   - Field: ‘earlySignal’
[17:02:53.726]   - Field: ‘lazy’
[17:02:53.726]   - Field: ‘state’
[17:02:53.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.726] - Launch lazy future ...
[17:02:53.726] Packages needed by the future expression (n = 0): <none>
[17:02:53.726] Packages needed by future strategies (n = 0): <none>
[17:02:53.727] {
[17:02:53.727]     {
[17:02:53.727]         {
[17:02:53.727]             ...future.startTime <- base::Sys.time()
[17:02:53.727]             {
[17:02:53.727]                 {
[17:02:53.727]                   {
[17:02:53.727]                     {
[17:02:53.727]                       base::local({
[17:02:53.727]                         has_future <- base::requireNamespace("future", 
[17:02:53.727]                           quietly = TRUE)
[17:02:53.727]                         if (has_future) {
[17:02:53.727]                           ns <- base::getNamespace("future")
[17:02:53.727]                           version <- ns[[".package"]][["version"]]
[17:02:53.727]                           if (is.null(version)) 
[17:02:53.727]                             version <- utils::packageVersion("future")
[17:02:53.727]                         }
[17:02:53.727]                         else {
[17:02:53.727]                           version <- NULL
[17:02:53.727]                         }
[17:02:53.727]                         if (!has_future || version < "1.8.0") {
[17:02:53.727]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.727]                             "", base::R.version$version.string), 
[17:02:53.727]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.727]                               "release", "version")], collapse = " "), 
[17:02:53.727]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.727]                             info)
[17:02:53.727]                           info <- base::paste(info, collapse = "; ")
[17:02:53.727]                           if (!has_future) {
[17:02:53.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.727]                               info)
[17:02:53.727]                           }
[17:02:53.727]                           else {
[17:02:53.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.727]                               info, version)
[17:02:53.727]                           }
[17:02:53.727]                           base::stop(msg)
[17:02:53.727]                         }
[17:02:53.727]                       })
[17:02:53.727]                     }
[17:02:53.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.727]                     base::options(mc.cores = 1L)
[17:02:53.727]                   }
[17:02:53.727]                   ...future.strategy.old <- future::plan("list")
[17:02:53.727]                   options(future.plan = NULL)
[17:02:53.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.727]                 }
[17:02:53.727]                 ...future.workdir <- getwd()
[17:02:53.727]             }
[17:02:53.727]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.727]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.727]         }
[17:02:53.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.727]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.727]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.727]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.727]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.727]             base::names(...future.oldOptions))
[17:02:53.727]     }
[17:02:53.727]     if (FALSE) {
[17:02:53.727]     }
[17:02:53.727]     else {
[17:02:53.727]         if (TRUE) {
[17:02:53.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.727]                 open = "w")
[17:02:53.727]         }
[17:02:53.727]         else {
[17:02:53.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.727]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.727]         }
[17:02:53.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.727]             base::sink(type = "output", split = FALSE)
[17:02:53.727]             base::close(...future.stdout)
[17:02:53.727]         }, add = TRUE)
[17:02:53.727]     }
[17:02:53.727]     ...future.frame <- base::sys.nframe()
[17:02:53.727]     ...future.conditions <- base::list()
[17:02:53.727]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.727]     if (FALSE) {
[17:02:53.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.727]     }
[17:02:53.727]     ...future.result <- base::tryCatch({
[17:02:53.727]         base::withCallingHandlers({
[17:02:53.727]             ...future.value <- base::withVisible(base::local({
[17:02:53.727]                 ...future.makeSendCondition <- base::local({
[17:02:53.727]                   sendCondition <- NULL
[17:02:53.727]                   function(frame = 1L) {
[17:02:53.727]                     if (is.function(sendCondition)) 
[17:02:53.727]                       return(sendCondition)
[17:02:53.727]                     ns <- getNamespace("parallel")
[17:02:53.727]                     if (exists("sendData", mode = "function", 
[17:02:53.727]                       envir = ns)) {
[17:02:53.727]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.727]                         envir = ns)
[17:02:53.727]                       envir <- sys.frame(frame)
[17:02:53.727]                       master <- NULL
[17:02:53.727]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.727]                         !identical(envir, emptyenv())) {
[17:02:53.727]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.727]                           inherits = FALSE)) {
[17:02:53.727]                           master <- get("master", mode = "list", 
[17:02:53.727]                             envir = envir, inherits = FALSE)
[17:02:53.727]                           if (inherits(master, c("SOCKnode", 
[17:02:53.727]                             "SOCK0node"))) {
[17:02:53.727]                             sendCondition <<- function(cond) {
[17:02:53.727]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.727]                                 success = TRUE)
[17:02:53.727]                               parallel_sendData(master, data)
[17:02:53.727]                             }
[17:02:53.727]                             return(sendCondition)
[17:02:53.727]                           }
[17:02:53.727]                         }
[17:02:53.727]                         frame <- frame + 1L
[17:02:53.727]                         envir <- sys.frame(frame)
[17:02:53.727]                       }
[17:02:53.727]                     }
[17:02:53.727]                     sendCondition <<- function(cond) NULL
[17:02:53.727]                   }
[17:02:53.727]                 })
[17:02:53.727]                 withCallingHandlers({
[17:02:53.727]                   {
[17:02:53.727]                     b <- a * ii
[17:02:53.727]                     a <- 0
[17:02:53.727]                     b
[17:02:53.727]                   }
[17:02:53.727]                 }, immediateCondition = function(cond) {
[17:02:53.727]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.727]                   sendCondition(cond)
[17:02:53.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.727]                   {
[17:02:53.727]                     inherits <- base::inherits
[17:02:53.727]                     invokeRestart <- base::invokeRestart
[17:02:53.727]                     is.null <- base::is.null
[17:02:53.727]                     muffled <- FALSE
[17:02:53.727]                     if (inherits(cond, "message")) {
[17:02:53.727]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.727]                       if (muffled) 
[17:02:53.727]                         invokeRestart("muffleMessage")
[17:02:53.727]                     }
[17:02:53.727]                     else if (inherits(cond, "warning")) {
[17:02:53.727]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.727]                       if (muffled) 
[17:02:53.727]                         invokeRestart("muffleWarning")
[17:02:53.727]                     }
[17:02:53.727]                     else if (inherits(cond, "condition")) {
[17:02:53.727]                       if (!is.null(pattern)) {
[17:02:53.727]                         computeRestarts <- base::computeRestarts
[17:02:53.727]                         grepl <- base::grepl
[17:02:53.727]                         restarts <- computeRestarts(cond)
[17:02:53.727]                         for (restart in restarts) {
[17:02:53.727]                           name <- restart$name
[17:02:53.727]                           if (is.null(name)) 
[17:02:53.727]                             next
[17:02:53.727]                           if (!grepl(pattern, name)) 
[17:02:53.727]                             next
[17:02:53.727]                           invokeRestart(restart)
[17:02:53.727]                           muffled <- TRUE
[17:02:53.727]                           break
[17:02:53.727]                         }
[17:02:53.727]                       }
[17:02:53.727]                     }
[17:02:53.727]                     invisible(muffled)
[17:02:53.727]                   }
[17:02:53.727]                   muffleCondition(cond)
[17:02:53.727]                 })
[17:02:53.727]             }))
[17:02:53.727]             future::FutureResult(value = ...future.value$value, 
[17:02:53.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.727]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.727]                     ...future.globalenv.names))
[17:02:53.727]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.727]         }, condition = base::local({
[17:02:53.727]             c <- base::c
[17:02:53.727]             inherits <- base::inherits
[17:02:53.727]             invokeRestart <- base::invokeRestart
[17:02:53.727]             length <- base::length
[17:02:53.727]             list <- base::list
[17:02:53.727]             seq.int <- base::seq.int
[17:02:53.727]             signalCondition <- base::signalCondition
[17:02:53.727]             sys.calls <- base::sys.calls
[17:02:53.727]             `[[` <- base::`[[`
[17:02:53.727]             `+` <- base::`+`
[17:02:53.727]             `<<-` <- base::`<<-`
[17:02:53.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.727]                   3L)]
[17:02:53.727]             }
[17:02:53.727]             function(cond) {
[17:02:53.727]                 is_error <- inherits(cond, "error")
[17:02:53.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.727]                   NULL)
[17:02:53.727]                 if (is_error) {
[17:02:53.727]                   sessionInformation <- function() {
[17:02:53.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.727]                       search = base::search(), system = base::Sys.info())
[17:02:53.727]                   }
[17:02:53.727]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.727]                     cond$call), session = sessionInformation(), 
[17:02:53.727]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.727]                   signalCondition(cond)
[17:02:53.727]                 }
[17:02:53.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.727]                 "immediateCondition"))) {
[17:02:53.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.727]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.727]                   if (TRUE && !signal) {
[17:02:53.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.727]                     {
[17:02:53.727]                       inherits <- base::inherits
[17:02:53.727]                       invokeRestart <- base::invokeRestart
[17:02:53.727]                       is.null <- base::is.null
[17:02:53.727]                       muffled <- FALSE
[17:02:53.727]                       if (inherits(cond, "message")) {
[17:02:53.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.727]                         if (muffled) 
[17:02:53.727]                           invokeRestart("muffleMessage")
[17:02:53.727]                       }
[17:02:53.727]                       else if (inherits(cond, "warning")) {
[17:02:53.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.727]                         if (muffled) 
[17:02:53.727]                           invokeRestart("muffleWarning")
[17:02:53.727]                       }
[17:02:53.727]                       else if (inherits(cond, "condition")) {
[17:02:53.727]                         if (!is.null(pattern)) {
[17:02:53.727]                           computeRestarts <- base::computeRestarts
[17:02:53.727]                           grepl <- base::grepl
[17:02:53.727]                           restarts <- computeRestarts(cond)
[17:02:53.727]                           for (restart in restarts) {
[17:02:53.727]                             name <- restart$name
[17:02:53.727]                             if (is.null(name)) 
[17:02:53.727]                               next
[17:02:53.727]                             if (!grepl(pattern, name)) 
[17:02:53.727]                               next
[17:02:53.727]                             invokeRestart(restart)
[17:02:53.727]                             muffled <- TRUE
[17:02:53.727]                             break
[17:02:53.727]                           }
[17:02:53.727]                         }
[17:02:53.727]                       }
[17:02:53.727]                       invisible(muffled)
[17:02:53.727]                     }
[17:02:53.727]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.727]                   }
[17:02:53.727]                 }
[17:02:53.727]                 else {
[17:02:53.727]                   if (TRUE) {
[17:02:53.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.727]                     {
[17:02:53.727]                       inherits <- base::inherits
[17:02:53.727]                       invokeRestart <- base::invokeRestart
[17:02:53.727]                       is.null <- base::is.null
[17:02:53.727]                       muffled <- FALSE
[17:02:53.727]                       if (inherits(cond, "message")) {
[17:02:53.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.727]                         if (muffled) 
[17:02:53.727]                           invokeRestart("muffleMessage")
[17:02:53.727]                       }
[17:02:53.727]                       else if (inherits(cond, "warning")) {
[17:02:53.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.727]                         if (muffled) 
[17:02:53.727]                           invokeRestart("muffleWarning")
[17:02:53.727]                       }
[17:02:53.727]                       else if (inherits(cond, "condition")) {
[17:02:53.727]                         if (!is.null(pattern)) {
[17:02:53.727]                           computeRestarts <- base::computeRestarts
[17:02:53.727]                           grepl <- base::grepl
[17:02:53.727]                           restarts <- computeRestarts(cond)
[17:02:53.727]                           for (restart in restarts) {
[17:02:53.727]                             name <- restart$name
[17:02:53.727]                             if (is.null(name)) 
[17:02:53.727]                               next
[17:02:53.727]                             if (!grepl(pattern, name)) 
[17:02:53.727]                               next
[17:02:53.727]                             invokeRestart(restart)
[17:02:53.727]                             muffled <- TRUE
[17:02:53.727]                             break
[17:02:53.727]                           }
[17:02:53.727]                         }
[17:02:53.727]                       }
[17:02:53.727]                       invisible(muffled)
[17:02:53.727]                     }
[17:02:53.727]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.727]                   }
[17:02:53.727]                 }
[17:02:53.727]             }
[17:02:53.727]         }))
[17:02:53.727]     }, error = function(ex) {
[17:02:53.727]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.727]                 ...future.rng), started = ...future.startTime, 
[17:02:53.727]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.727]             version = "1.8"), class = "FutureResult")
[17:02:53.727]     }, finally = {
[17:02:53.727]         if (!identical(...future.workdir, getwd())) 
[17:02:53.727]             setwd(...future.workdir)
[17:02:53.727]         {
[17:02:53.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.727]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.727]             }
[17:02:53.727]             base::options(...future.oldOptions)
[17:02:53.727]             if (.Platform$OS.type == "windows") {
[17:02:53.727]                 old_names <- names(...future.oldEnvVars)
[17:02:53.727]                 envs <- base::Sys.getenv()
[17:02:53.727]                 names <- names(envs)
[17:02:53.727]                 common <- intersect(names, old_names)
[17:02:53.727]                 added <- setdiff(names, old_names)
[17:02:53.727]                 removed <- setdiff(old_names, names)
[17:02:53.727]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.727]                   envs[common]]
[17:02:53.727]                 NAMES <- toupper(changed)
[17:02:53.727]                 args <- list()
[17:02:53.727]                 for (kk in seq_along(NAMES)) {
[17:02:53.727]                   name <- changed[[kk]]
[17:02:53.727]                   NAME <- NAMES[[kk]]
[17:02:53.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.727]                     next
[17:02:53.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.727]                 }
[17:02:53.727]                 NAMES <- toupper(added)
[17:02:53.727]                 for (kk in seq_along(NAMES)) {
[17:02:53.727]                   name <- added[[kk]]
[17:02:53.727]                   NAME <- NAMES[[kk]]
[17:02:53.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.727]                     next
[17:02:53.727]                   args[[name]] <- ""
[17:02:53.727]                 }
[17:02:53.727]                 NAMES <- toupper(removed)
[17:02:53.727]                 for (kk in seq_along(NAMES)) {
[17:02:53.727]                   name <- removed[[kk]]
[17:02:53.727]                   NAME <- NAMES[[kk]]
[17:02:53.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.727]                     next
[17:02:53.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.727]                 }
[17:02:53.727]                 if (length(args) > 0) 
[17:02:53.727]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.727]             }
[17:02:53.727]             else {
[17:02:53.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.727]             }
[17:02:53.727]             {
[17:02:53.727]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.727]                   0L) {
[17:02:53.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.727]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.727]                   base::options(opts)
[17:02:53.727]                 }
[17:02:53.727]                 {
[17:02:53.727]                   {
[17:02:53.727]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.727]                     NULL
[17:02:53.727]                   }
[17:02:53.727]                   options(future.plan = NULL)
[17:02:53.727]                   if (is.na(NA_character_)) 
[17:02:53.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.727]                     .init = FALSE)
[17:02:53.727]                 }
[17:02:53.727]             }
[17:02:53.727]         }
[17:02:53.727]     })
[17:02:53.727]     if (TRUE) {
[17:02:53.727]         base::sink(type = "output", split = FALSE)
[17:02:53.727]         if (TRUE) {
[17:02:53.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.727]         }
[17:02:53.727]         else {
[17:02:53.727]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.727]         }
[17:02:53.727]         base::close(...future.stdout)
[17:02:53.727]         ...future.stdout <- NULL
[17:02:53.727]     }
[17:02:53.727]     ...future.result$conditions <- ...future.conditions
[17:02:53.727]     ...future.result$finished <- base::Sys.time()
[17:02:53.727]     ...future.result
[17:02:53.727] }
[17:02:53.780] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:02:53.780] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:02:53.781] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:02:53.781] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:02:53.781] MultisessionFuture started
[17:02:53.781] - Launch lazy future ... done
[17:02:53.781] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.782] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.782] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.784] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.784] Searching for globals ... DONE
[17:02:53.784] Resolving globals: TRUE
[17:02:53.784] Resolving any globals that are futures ...
[17:02:53.784] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.784] Resolving any globals that are futures ... DONE
[17:02:53.785] Resolving futures part of globals (recursively) ...
[17:02:53.785] resolve() on list ...
[17:02:53.785]  recursive: 99
[17:02:53.785]  length: 1
[17:02:53.785]  elements: ‘ii’
[17:02:53.785]  length: 0 (resolved future 1)
[17:02:53.785] resolve() on list ... DONE
[17:02:53.785] - globals: [1] ‘ii’
[17:02:53.785] Resolving futures part of globals (recursively) ... DONE
[17:02:53.786] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:53.786] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:53.786] - globals: [1] ‘ii’
[17:02:53.786] 
[17:02:53.786] getGlobalsAndPackages() ... DONE
[17:02:53.787] run() for ‘Future’ ...
[17:02:53.787] - state: ‘created’
[17:02:53.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.801] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.801]   - Field: ‘node’
[17:02:53.801]   - Field: ‘label’
[17:02:53.801]   - Field: ‘local’
[17:02:53.801]   - Field: ‘owner’
[17:02:53.801]   - Field: ‘envir’
[17:02:53.801]   - Field: ‘workers’
[17:02:53.801]   - Field: ‘packages’
[17:02:53.802]   - Field: ‘gc’
[17:02:53.802]   - Field: ‘conditions’
[17:02:53.802]   - Field: ‘persistent’
[17:02:53.802]   - Field: ‘expr’
[17:02:53.802]   - Field: ‘uuid’
[17:02:53.802]   - Field: ‘seed’
[17:02:53.802]   - Field: ‘version’
[17:02:53.802]   - Field: ‘result’
[17:02:53.802]   - Field: ‘asynchronous’
[17:02:53.802]   - Field: ‘calls’
[17:02:53.802]   - Field: ‘globals’
[17:02:53.803]   - Field: ‘stdout’
[17:02:53.803]   - Field: ‘earlySignal’
[17:02:53.803]   - Field: ‘lazy’
[17:02:53.803]   - Field: ‘state’
[17:02:53.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.803] - Launch lazy future ...
[17:02:53.803] Packages needed by the future expression (n = 0): <none>
[17:02:53.803] Packages needed by future strategies (n = 0): <none>
[17:02:53.804] {
[17:02:53.804]     {
[17:02:53.804]         {
[17:02:53.804]             ...future.startTime <- base::Sys.time()
[17:02:53.804]             {
[17:02:53.804]                 {
[17:02:53.804]                   {
[17:02:53.804]                     {
[17:02:53.804]                       base::local({
[17:02:53.804]                         has_future <- base::requireNamespace("future", 
[17:02:53.804]                           quietly = TRUE)
[17:02:53.804]                         if (has_future) {
[17:02:53.804]                           ns <- base::getNamespace("future")
[17:02:53.804]                           version <- ns[[".package"]][["version"]]
[17:02:53.804]                           if (is.null(version)) 
[17:02:53.804]                             version <- utils::packageVersion("future")
[17:02:53.804]                         }
[17:02:53.804]                         else {
[17:02:53.804]                           version <- NULL
[17:02:53.804]                         }
[17:02:53.804]                         if (!has_future || version < "1.8.0") {
[17:02:53.804]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.804]                             "", base::R.version$version.string), 
[17:02:53.804]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.804]                               "release", "version")], collapse = " "), 
[17:02:53.804]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.804]                             info)
[17:02:53.804]                           info <- base::paste(info, collapse = "; ")
[17:02:53.804]                           if (!has_future) {
[17:02:53.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.804]                               info)
[17:02:53.804]                           }
[17:02:53.804]                           else {
[17:02:53.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.804]                               info, version)
[17:02:53.804]                           }
[17:02:53.804]                           base::stop(msg)
[17:02:53.804]                         }
[17:02:53.804]                       })
[17:02:53.804]                     }
[17:02:53.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.804]                     base::options(mc.cores = 1L)
[17:02:53.804]                   }
[17:02:53.804]                   ...future.strategy.old <- future::plan("list")
[17:02:53.804]                   options(future.plan = NULL)
[17:02:53.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.804]                 }
[17:02:53.804]                 ...future.workdir <- getwd()
[17:02:53.804]             }
[17:02:53.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.804]         }
[17:02:53.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.804]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.804]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.804]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.804]             base::names(...future.oldOptions))
[17:02:53.804]     }
[17:02:53.804]     if (FALSE) {
[17:02:53.804]     }
[17:02:53.804]     else {
[17:02:53.804]         if (TRUE) {
[17:02:53.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.804]                 open = "w")
[17:02:53.804]         }
[17:02:53.804]         else {
[17:02:53.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.804]         }
[17:02:53.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.804]             base::sink(type = "output", split = FALSE)
[17:02:53.804]             base::close(...future.stdout)
[17:02:53.804]         }, add = TRUE)
[17:02:53.804]     }
[17:02:53.804]     ...future.frame <- base::sys.nframe()
[17:02:53.804]     ...future.conditions <- base::list()
[17:02:53.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.804]     if (FALSE) {
[17:02:53.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.804]     }
[17:02:53.804]     ...future.result <- base::tryCatch({
[17:02:53.804]         base::withCallingHandlers({
[17:02:53.804]             ...future.value <- base::withVisible(base::local({
[17:02:53.804]                 ...future.makeSendCondition <- base::local({
[17:02:53.804]                   sendCondition <- NULL
[17:02:53.804]                   function(frame = 1L) {
[17:02:53.804]                     if (is.function(sendCondition)) 
[17:02:53.804]                       return(sendCondition)
[17:02:53.804]                     ns <- getNamespace("parallel")
[17:02:53.804]                     if (exists("sendData", mode = "function", 
[17:02:53.804]                       envir = ns)) {
[17:02:53.804]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.804]                         envir = ns)
[17:02:53.804]                       envir <- sys.frame(frame)
[17:02:53.804]                       master <- NULL
[17:02:53.804]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.804]                         !identical(envir, emptyenv())) {
[17:02:53.804]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.804]                           inherits = FALSE)) {
[17:02:53.804]                           master <- get("master", mode = "list", 
[17:02:53.804]                             envir = envir, inherits = FALSE)
[17:02:53.804]                           if (inherits(master, c("SOCKnode", 
[17:02:53.804]                             "SOCK0node"))) {
[17:02:53.804]                             sendCondition <<- function(cond) {
[17:02:53.804]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.804]                                 success = TRUE)
[17:02:53.804]                               parallel_sendData(master, data)
[17:02:53.804]                             }
[17:02:53.804]                             return(sendCondition)
[17:02:53.804]                           }
[17:02:53.804]                         }
[17:02:53.804]                         frame <- frame + 1L
[17:02:53.804]                         envir <- sys.frame(frame)
[17:02:53.804]                       }
[17:02:53.804]                     }
[17:02:53.804]                     sendCondition <<- function(cond) NULL
[17:02:53.804]                   }
[17:02:53.804]                 })
[17:02:53.804]                 withCallingHandlers({
[17:02:53.804]                   {
[17:02:53.804]                     b <- a * ii
[17:02:53.804]                     a <- 0
[17:02:53.804]                     b
[17:02:53.804]                   }
[17:02:53.804]                 }, immediateCondition = function(cond) {
[17:02:53.804]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.804]                   sendCondition(cond)
[17:02:53.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.804]                   {
[17:02:53.804]                     inherits <- base::inherits
[17:02:53.804]                     invokeRestart <- base::invokeRestart
[17:02:53.804]                     is.null <- base::is.null
[17:02:53.804]                     muffled <- FALSE
[17:02:53.804]                     if (inherits(cond, "message")) {
[17:02:53.804]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.804]                       if (muffled) 
[17:02:53.804]                         invokeRestart("muffleMessage")
[17:02:53.804]                     }
[17:02:53.804]                     else if (inherits(cond, "warning")) {
[17:02:53.804]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.804]                       if (muffled) 
[17:02:53.804]                         invokeRestart("muffleWarning")
[17:02:53.804]                     }
[17:02:53.804]                     else if (inherits(cond, "condition")) {
[17:02:53.804]                       if (!is.null(pattern)) {
[17:02:53.804]                         computeRestarts <- base::computeRestarts
[17:02:53.804]                         grepl <- base::grepl
[17:02:53.804]                         restarts <- computeRestarts(cond)
[17:02:53.804]                         for (restart in restarts) {
[17:02:53.804]                           name <- restart$name
[17:02:53.804]                           if (is.null(name)) 
[17:02:53.804]                             next
[17:02:53.804]                           if (!grepl(pattern, name)) 
[17:02:53.804]                             next
[17:02:53.804]                           invokeRestart(restart)
[17:02:53.804]                           muffled <- TRUE
[17:02:53.804]                           break
[17:02:53.804]                         }
[17:02:53.804]                       }
[17:02:53.804]                     }
[17:02:53.804]                     invisible(muffled)
[17:02:53.804]                   }
[17:02:53.804]                   muffleCondition(cond)
[17:02:53.804]                 })
[17:02:53.804]             }))
[17:02:53.804]             future::FutureResult(value = ...future.value$value, 
[17:02:53.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.804]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.804]                     ...future.globalenv.names))
[17:02:53.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.804]         }, condition = base::local({
[17:02:53.804]             c <- base::c
[17:02:53.804]             inherits <- base::inherits
[17:02:53.804]             invokeRestart <- base::invokeRestart
[17:02:53.804]             length <- base::length
[17:02:53.804]             list <- base::list
[17:02:53.804]             seq.int <- base::seq.int
[17:02:53.804]             signalCondition <- base::signalCondition
[17:02:53.804]             sys.calls <- base::sys.calls
[17:02:53.804]             `[[` <- base::`[[`
[17:02:53.804]             `+` <- base::`+`
[17:02:53.804]             `<<-` <- base::`<<-`
[17:02:53.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.804]                   3L)]
[17:02:53.804]             }
[17:02:53.804]             function(cond) {
[17:02:53.804]                 is_error <- inherits(cond, "error")
[17:02:53.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.804]                   NULL)
[17:02:53.804]                 if (is_error) {
[17:02:53.804]                   sessionInformation <- function() {
[17:02:53.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.804]                       search = base::search(), system = base::Sys.info())
[17:02:53.804]                   }
[17:02:53.804]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.804]                     cond$call), session = sessionInformation(), 
[17:02:53.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.804]                   signalCondition(cond)
[17:02:53.804]                 }
[17:02:53.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.804]                 "immediateCondition"))) {
[17:02:53.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.804]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.804]                   if (TRUE && !signal) {
[17:02:53.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.804]                     {
[17:02:53.804]                       inherits <- base::inherits
[17:02:53.804]                       invokeRestart <- base::invokeRestart
[17:02:53.804]                       is.null <- base::is.null
[17:02:53.804]                       muffled <- FALSE
[17:02:53.804]                       if (inherits(cond, "message")) {
[17:02:53.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.804]                         if (muffled) 
[17:02:53.804]                           invokeRestart("muffleMessage")
[17:02:53.804]                       }
[17:02:53.804]                       else if (inherits(cond, "warning")) {
[17:02:53.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.804]                         if (muffled) 
[17:02:53.804]                           invokeRestart("muffleWarning")
[17:02:53.804]                       }
[17:02:53.804]                       else if (inherits(cond, "condition")) {
[17:02:53.804]                         if (!is.null(pattern)) {
[17:02:53.804]                           computeRestarts <- base::computeRestarts
[17:02:53.804]                           grepl <- base::grepl
[17:02:53.804]                           restarts <- computeRestarts(cond)
[17:02:53.804]                           for (restart in restarts) {
[17:02:53.804]                             name <- restart$name
[17:02:53.804]                             if (is.null(name)) 
[17:02:53.804]                               next
[17:02:53.804]                             if (!grepl(pattern, name)) 
[17:02:53.804]                               next
[17:02:53.804]                             invokeRestart(restart)
[17:02:53.804]                             muffled <- TRUE
[17:02:53.804]                             break
[17:02:53.804]                           }
[17:02:53.804]                         }
[17:02:53.804]                       }
[17:02:53.804]                       invisible(muffled)
[17:02:53.804]                     }
[17:02:53.804]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.804]                   }
[17:02:53.804]                 }
[17:02:53.804]                 else {
[17:02:53.804]                   if (TRUE) {
[17:02:53.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.804]                     {
[17:02:53.804]                       inherits <- base::inherits
[17:02:53.804]                       invokeRestart <- base::invokeRestart
[17:02:53.804]                       is.null <- base::is.null
[17:02:53.804]                       muffled <- FALSE
[17:02:53.804]                       if (inherits(cond, "message")) {
[17:02:53.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.804]                         if (muffled) 
[17:02:53.804]                           invokeRestart("muffleMessage")
[17:02:53.804]                       }
[17:02:53.804]                       else if (inherits(cond, "warning")) {
[17:02:53.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.804]                         if (muffled) 
[17:02:53.804]                           invokeRestart("muffleWarning")
[17:02:53.804]                       }
[17:02:53.804]                       else if (inherits(cond, "condition")) {
[17:02:53.804]                         if (!is.null(pattern)) {
[17:02:53.804]                           computeRestarts <- base::computeRestarts
[17:02:53.804]                           grepl <- base::grepl
[17:02:53.804]                           restarts <- computeRestarts(cond)
[17:02:53.804]                           for (restart in restarts) {
[17:02:53.804]                             name <- restart$name
[17:02:53.804]                             if (is.null(name)) 
[17:02:53.804]                               next
[17:02:53.804]                             if (!grepl(pattern, name)) 
[17:02:53.804]                               next
[17:02:53.804]                             invokeRestart(restart)
[17:02:53.804]                             muffled <- TRUE
[17:02:53.804]                             break
[17:02:53.804]                           }
[17:02:53.804]                         }
[17:02:53.804]                       }
[17:02:53.804]                       invisible(muffled)
[17:02:53.804]                     }
[17:02:53.804]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.804]                   }
[17:02:53.804]                 }
[17:02:53.804]             }
[17:02:53.804]         }))
[17:02:53.804]     }, error = function(ex) {
[17:02:53.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.804]                 ...future.rng), started = ...future.startTime, 
[17:02:53.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.804]             version = "1.8"), class = "FutureResult")
[17:02:53.804]     }, finally = {
[17:02:53.804]         if (!identical(...future.workdir, getwd())) 
[17:02:53.804]             setwd(...future.workdir)
[17:02:53.804]         {
[17:02:53.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.804]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.804]             }
[17:02:53.804]             base::options(...future.oldOptions)
[17:02:53.804]             if (.Platform$OS.type == "windows") {
[17:02:53.804]                 old_names <- names(...future.oldEnvVars)
[17:02:53.804]                 envs <- base::Sys.getenv()
[17:02:53.804]                 names <- names(envs)
[17:02:53.804]                 common <- intersect(names, old_names)
[17:02:53.804]                 added <- setdiff(names, old_names)
[17:02:53.804]                 removed <- setdiff(old_names, names)
[17:02:53.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.804]                   envs[common]]
[17:02:53.804]                 NAMES <- toupper(changed)
[17:02:53.804]                 args <- list()
[17:02:53.804]                 for (kk in seq_along(NAMES)) {
[17:02:53.804]                   name <- changed[[kk]]
[17:02:53.804]                   NAME <- NAMES[[kk]]
[17:02:53.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.804]                     next
[17:02:53.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.804]                 }
[17:02:53.804]                 NAMES <- toupper(added)
[17:02:53.804]                 for (kk in seq_along(NAMES)) {
[17:02:53.804]                   name <- added[[kk]]
[17:02:53.804]                   NAME <- NAMES[[kk]]
[17:02:53.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.804]                     next
[17:02:53.804]                   args[[name]] <- ""
[17:02:53.804]                 }
[17:02:53.804]                 NAMES <- toupper(removed)
[17:02:53.804]                 for (kk in seq_along(NAMES)) {
[17:02:53.804]                   name <- removed[[kk]]
[17:02:53.804]                   NAME <- NAMES[[kk]]
[17:02:53.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.804]                     next
[17:02:53.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.804]                 }
[17:02:53.804]                 if (length(args) > 0) 
[17:02:53.804]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.804]             }
[17:02:53.804]             else {
[17:02:53.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.804]             }
[17:02:53.804]             {
[17:02:53.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.804]                   0L) {
[17:02:53.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.804]                   base::options(opts)
[17:02:53.804]                 }
[17:02:53.804]                 {
[17:02:53.804]                   {
[17:02:53.804]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.804]                     NULL
[17:02:53.804]                   }
[17:02:53.804]                   options(future.plan = NULL)
[17:02:53.804]                   if (is.na(NA_character_)) 
[17:02:53.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.804]                     .init = FALSE)
[17:02:53.804]                 }
[17:02:53.804]             }
[17:02:53.804]         }
[17:02:53.804]     })
[17:02:53.804]     if (TRUE) {
[17:02:53.804]         base::sink(type = "output", split = FALSE)
[17:02:53.804]         if (TRUE) {
[17:02:53.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.804]         }
[17:02:53.804]         else {
[17:02:53.804]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.804]         }
[17:02:53.804]         base::close(...future.stdout)
[17:02:53.804]         ...future.stdout <- NULL
[17:02:53.804]     }
[17:02:53.804]     ...future.result$conditions <- ...future.conditions
[17:02:53.804]     ...future.result$finished <- base::Sys.time()
[17:02:53.804]     ...future.result
[17:02:53.804] }
[17:02:53.806] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:53.817] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.817] - Validating connection of MultisessionFuture
[17:02:53.818] - received message: FutureResult
[17:02:53.818] - Received FutureResult
[17:02:53.818] - Erased future from FutureRegistry
[17:02:53.818] result() for ClusterFuture ...
[17:02:53.818] - result already collected: FutureResult
[17:02:53.818] result() for ClusterFuture ... done
[17:02:53.818] signalConditions() ...
[17:02:53.818]  - include = ‘immediateCondition’
[17:02:53.818]  - exclude = 
[17:02:53.818]  - resignal = FALSE
[17:02:53.819]  - Number of conditions: 1
[17:02:53.819] signalConditions() ... done
[17:02:53.819] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.819] result() for ClusterFuture ...
[17:02:53.819] - result already collected: FutureResult
[17:02:53.819] result() for ClusterFuture ... done
[17:02:53.819] result() for ClusterFuture ...
[17:02:53.819] - result already collected: FutureResult
[17:02:53.819] result() for ClusterFuture ... done
[17:02:53.819] signalConditions() ...
[17:02:53.819]  - include = ‘immediateCondition’
[17:02:53.820]  - exclude = 
[17:02:53.820]  - resignal = FALSE
[17:02:53.820]  - Number of conditions: 1
[17:02:53.820] signalConditions() ... done
[17:02:53.820] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:02:53.821] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:02:53.821] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:02:53.821] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:02:53.822] MultisessionFuture started
[17:02:53.822] - Launch lazy future ... done
[17:02:53.822] run() for ‘MultisessionFuture’ ... done
[17:02:53.822] result() for ClusterFuture ...
[17:02:53.822] - result already collected: FutureResult
[17:02:53.822] result() for ClusterFuture ... done
[17:02:53.822] result() for ClusterFuture ...
[17:02:53.822] - result already collected: FutureResult
[17:02:53.822] result() for ClusterFuture ... done
[17:02:53.823] signalConditions() ...
[17:02:53.823]  - include = ‘immediateCondition’
[17:02:53.823]  - exclude = 
[17:02:53.823]  - resignal = FALSE
[17:02:53.823]  - Number of conditions: 1
[17:02:53.823] signalConditions() ... done
[17:02:53.823] Future state: ‘finished’
[17:02:53.823] result() for ClusterFuture ...
[17:02:53.823] - result already collected: FutureResult
[17:02:53.823] result() for ClusterFuture ... done
[17:02:53.823] signalConditions() ...
[17:02:53.824]  - include = ‘condition’
[17:02:53.824]  - exclude = ‘immediateCondition’
[17:02:53.824]  - resignal = TRUE
[17:02:53.824]  - Number of conditions: 1
[17:02:53.824]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:53.824] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.839] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.839] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.841] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.841] Searching for globals ... DONE
[17:02:53.841] Resolving globals: TRUE
[17:02:53.841] Resolving any globals that are futures ...
[17:02:53.841] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.841] Resolving any globals that are futures ... DONE
[17:02:53.841] Resolving futures part of globals (recursively) ...
[17:02:53.842] resolve() on list ...
[17:02:53.842]  recursive: 99
[17:02:53.842]  length: 1
[17:02:53.842]  elements: ‘ii’
[17:02:53.842]  length: 0 (resolved future 1)
[17:02:53.842] resolve() on list ... DONE
[17:02:53.842] - globals: [1] ‘ii’
[17:02:53.842] Resolving futures part of globals (recursively) ... DONE
[17:02:53.842] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:53.843] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:53.843] - globals: [1] ‘ii’
[17:02:53.843] 
[17:02:53.843] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.844] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.844] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.845] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.845] Searching for globals ... DONE
[17:02:53.845] Resolving globals: TRUE
[17:02:53.845] Resolving any globals that are futures ...
[17:02:53.845] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.846] Resolving any globals that are futures ... DONE
[17:02:53.846] Resolving futures part of globals (recursively) ...
[17:02:53.846] resolve() on list ...
[17:02:53.846]  recursive: 99
[17:02:53.846]  length: 1
[17:02:53.846]  elements: ‘ii’
[17:02:53.846]  length: 0 (resolved future 1)
[17:02:53.847] resolve() on list ... DONE
[17:02:53.847] - globals: [1] ‘ii’
[17:02:53.847] Resolving futures part of globals (recursively) ... DONE
[17:02:53.847] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:53.847] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:53.847] - globals: [1] ‘ii’
[17:02:53.847] 
[17:02:53.848] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.848] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.848] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.849] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.850] Searching for globals ... DONE
[17:02:53.850] Resolving globals: TRUE
[17:02:53.850] Resolving any globals that are futures ...
[17:02:53.850] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:02:53.850] Resolving any globals that are futures ... DONE
[17:02:53.850] Resolving futures part of globals (recursively) ...
[17:02:53.850] resolve() on list ...
[17:02:53.851]  recursive: 99
[17:02:53.851]  length: 1
[17:02:53.851]  elements: ‘ii’
[17:02:53.851]  length: 0 (resolved future 1)
[17:02:53.851] resolve() on list ... DONE
[17:02:53.851] - globals: [1] ‘ii’
[17:02:53.851] Resolving futures part of globals (recursively) ... DONE
[17:02:53.851] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:53.852] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:02:53.852] - globals: [1] ‘ii’
[17:02:53.852] 
[17:02:53.852] getGlobalsAndPackages() ... DONE
[17:02:53.852] run() for ‘Future’ ...
[17:02:53.852] - state: ‘created’
[17:02:53.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.868]   - Field: ‘node’
[17:02:53.869]   - Field: ‘label’
[17:02:53.869]   - Field: ‘local’
[17:02:53.869]   - Field: ‘owner’
[17:02:53.869]   - Field: ‘envir’
[17:02:53.869]   - Field: ‘workers’
[17:02:53.869]   - Field: ‘packages’
[17:02:53.869]   - Field: ‘gc’
[17:02:53.869]   - Field: ‘conditions’
[17:02:53.869]   - Field: ‘persistent’
[17:02:53.869]   - Field: ‘expr’
[17:02:53.869]   - Field: ‘uuid’
[17:02:53.870]   - Field: ‘seed’
[17:02:53.870]   - Field: ‘version’
[17:02:53.870]   - Field: ‘result’
[17:02:53.870]   - Field: ‘asynchronous’
[17:02:53.870]   - Field: ‘calls’
[17:02:53.870]   - Field: ‘globals’
[17:02:53.870]   - Field: ‘stdout’
[17:02:53.870]   - Field: ‘earlySignal’
[17:02:53.870]   - Field: ‘lazy’
[17:02:53.870]   - Field: ‘state’
[17:02:53.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.871] - Launch lazy future ...
[17:02:53.871] Packages needed by the future expression (n = 0): <none>
[17:02:53.871] Packages needed by future strategies (n = 0): <none>
[17:02:53.871] {
[17:02:53.871]     {
[17:02:53.871]         {
[17:02:53.871]             ...future.startTime <- base::Sys.time()
[17:02:53.871]             {
[17:02:53.871]                 {
[17:02:53.871]                   {
[17:02:53.871]                     {
[17:02:53.871]                       base::local({
[17:02:53.871]                         has_future <- base::requireNamespace("future", 
[17:02:53.871]                           quietly = TRUE)
[17:02:53.871]                         if (has_future) {
[17:02:53.871]                           ns <- base::getNamespace("future")
[17:02:53.871]                           version <- ns[[".package"]][["version"]]
[17:02:53.871]                           if (is.null(version)) 
[17:02:53.871]                             version <- utils::packageVersion("future")
[17:02:53.871]                         }
[17:02:53.871]                         else {
[17:02:53.871]                           version <- NULL
[17:02:53.871]                         }
[17:02:53.871]                         if (!has_future || version < "1.8.0") {
[17:02:53.871]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.871]                             "", base::R.version$version.string), 
[17:02:53.871]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.871]                               "release", "version")], collapse = " "), 
[17:02:53.871]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.871]                             info)
[17:02:53.871]                           info <- base::paste(info, collapse = "; ")
[17:02:53.871]                           if (!has_future) {
[17:02:53.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.871]                               info)
[17:02:53.871]                           }
[17:02:53.871]                           else {
[17:02:53.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.871]                               info, version)
[17:02:53.871]                           }
[17:02:53.871]                           base::stop(msg)
[17:02:53.871]                         }
[17:02:53.871]                       })
[17:02:53.871]                     }
[17:02:53.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.871]                     base::options(mc.cores = 1L)
[17:02:53.871]                   }
[17:02:53.871]                   ...future.strategy.old <- future::plan("list")
[17:02:53.871]                   options(future.plan = NULL)
[17:02:53.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.871]                 }
[17:02:53.871]                 ...future.workdir <- getwd()
[17:02:53.871]             }
[17:02:53.871]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.871]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.871]         }
[17:02:53.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.871]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.871]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.871]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.871]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.871]             base::names(...future.oldOptions))
[17:02:53.871]     }
[17:02:53.871]     if (FALSE) {
[17:02:53.871]     }
[17:02:53.871]     else {
[17:02:53.871]         if (TRUE) {
[17:02:53.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.871]                 open = "w")
[17:02:53.871]         }
[17:02:53.871]         else {
[17:02:53.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.871]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.871]         }
[17:02:53.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.871]             base::sink(type = "output", split = FALSE)
[17:02:53.871]             base::close(...future.stdout)
[17:02:53.871]         }, add = TRUE)
[17:02:53.871]     }
[17:02:53.871]     ...future.frame <- base::sys.nframe()
[17:02:53.871]     ...future.conditions <- base::list()
[17:02:53.871]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.871]     if (FALSE) {
[17:02:53.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.871]     }
[17:02:53.871]     ...future.result <- base::tryCatch({
[17:02:53.871]         base::withCallingHandlers({
[17:02:53.871]             ...future.value <- base::withVisible(base::local({
[17:02:53.871]                 ...future.makeSendCondition <- base::local({
[17:02:53.871]                   sendCondition <- NULL
[17:02:53.871]                   function(frame = 1L) {
[17:02:53.871]                     if (is.function(sendCondition)) 
[17:02:53.871]                       return(sendCondition)
[17:02:53.871]                     ns <- getNamespace("parallel")
[17:02:53.871]                     if (exists("sendData", mode = "function", 
[17:02:53.871]                       envir = ns)) {
[17:02:53.871]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.871]                         envir = ns)
[17:02:53.871]                       envir <- sys.frame(frame)
[17:02:53.871]                       master <- NULL
[17:02:53.871]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.871]                         !identical(envir, emptyenv())) {
[17:02:53.871]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.871]                           inherits = FALSE)) {
[17:02:53.871]                           master <- get("master", mode = "list", 
[17:02:53.871]                             envir = envir, inherits = FALSE)
[17:02:53.871]                           if (inherits(master, c("SOCKnode", 
[17:02:53.871]                             "SOCK0node"))) {
[17:02:53.871]                             sendCondition <<- function(cond) {
[17:02:53.871]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.871]                                 success = TRUE)
[17:02:53.871]                               parallel_sendData(master, data)
[17:02:53.871]                             }
[17:02:53.871]                             return(sendCondition)
[17:02:53.871]                           }
[17:02:53.871]                         }
[17:02:53.871]                         frame <- frame + 1L
[17:02:53.871]                         envir <- sys.frame(frame)
[17:02:53.871]                       }
[17:02:53.871]                     }
[17:02:53.871]                     sendCondition <<- function(cond) NULL
[17:02:53.871]                   }
[17:02:53.871]                 })
[17:02:53.871]                 withCallingHandlers({
[17:02:53.871]                   {
[17:02:53.871]                     b <- a * ii
[17:02:53.871]                     a <- 0
[17:02:53.871]                     b
[17:02:53.871]                   }
[17:02:53.871]                 }, immediateCondition = function(cond) {
[17:02:53.871]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.871]                   sendCondition(cond)
[17:02:53.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.871]                   {
[17:02:53.871]                     inherits <- base::inherits
[17:02:53.871]                     invokeRestart <- base::invokeRestart
[17:02:53.871]                     is.null <- base::is.null
[17:02:53.871]                     muffled <- FALSE
[17:02:53.871]                     if (inherits(cond, "message")) {
[17:02:53.871]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.871]                       if (muffled) 
[17:02:53.871]                         invokeRestart("muffleMessage")
[17:02:53.871]                     }
[17:02:53.871]                     else if (inherits(cond, "warning")) {
[17:02:53.871]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.871]                       if (muffled) 
[17:02:53.871]                         invokeRestart("muffleWarning")
[17:02:53.871]                     }
[17:02:53.871]                     else if (inherits(cond, "condition")) {
[17:02:53.871]                       if (!is.null(pattern)) {
[17:02:53.871]                         computeRestarts <- base::computeRestarts
[17:02:53.871]                         grepl <- base::grepl
[17:02:53.871]                         restarts <- computeRestarts(cond)
[17:02:53.871]                         for (restart in restarts) {
[17:02:53.871]                           name <- restart$name
[17:02:53.871]                           if (is.null(name)) 
[17:02:53.871]                             next
[17:02:53.871]                           if (!grepl(pattern, name)) 
[17:02:53.871]                             next
[17:02:53.871]                           invokeRestart(restart)
[17:02:53.871]                           muffled <- TRUE
[17:02:53.871]                           break
[17:02:53.871]                         }
[17:02:53.871]                       }
[17:02:53.871]                     }
[17:02:53.871]                     invisible(muffled)
[17:02:53.871]                   }
[17:02:53.871]                   muffleCondition(cond)
[17:02:53.871]                 })
[17:02:53.871]             }))
[17:02:53.871]             future::FutureResult(value = ...future.value$value, 
[17:02:53.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.871]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.871]                     ...future.globalenv.names))
[17:02:53.871]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.871]         }, condition = base::local({
[17:02:53.871]             c <- base::c
[17:02:53.871]             inherits <- base::inherits
[17:02:53.871]             invokeRestart <- base::invokeRestart
[17:02:53.871]             length <- base::length
[17:02:53.871]             list <- base::list
[17:02:53.871]             seq.int <- base::seq.int
[17:02:53.871]             signalCondition <- base::signalCondition
[17:02:53.871]             sys.calls <- base::sys.calls
[17:02:53.871]             `[[` <- base::`[[`
[17:02:53.871]             `+` <- base::`+`
[17:02:53.871]             `<<-` <- base::`<<-`
[17:02:53.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.871]                   3L)]
[17:02:53.871]             }
[17:02:53.871]             function(cond) {
[17:02:53.871]                 is_error <- inherits(cond, "error")
[17:02:53.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.871]                   NULL)
[17:02:53.871]                 if (is_error) {
[17:02:53.871]                   sessionInformation <- function() {
[17:02:53.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.871]                       search = base::search(), system = base::Sys.info())
[17:02:53.871]                   }
[17:02:53.871]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.871]                     cond$call), session = sessionInformation(), 
[17:02:53.871]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.871]                   signalCondition(cond)
[17:02:53.871]                 }
[17:02:53.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.871]                 "immediateCondition"))) {
[17:02:53.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.871]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.871]                   if (TRUE && !signal) {
[17:02:53.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.871]                     {
[17:02:53.871]                       inherits <- base::inherits
[17:02:53.871]                       invokeRestart <- base::invokeRestart
[17:02:53.871]                       is.null <- base::is.null
[17:02:53.871]                       muffled <- FALSE
[17:02:53.871]                       if (inherits(cond, "message")) {
[17:02:53.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.871]                         if (muffled) 
[17:02:53.871]                           invokeRestart("muffleMessage")
[17:02:53.871]                       }
[17:02:53.871]                       else if (inherits(cond, "warning")) {
[17:02:53.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.871]                         if (muffled) 
[17:02:53.871]                           invokeRestart("muffleWarning")
[17:02:53.871]                       }
[17:02:53.871]                       else if (inherits(cond, "condition")) {
[17:02:53.871]                         if (!is.null(pattern)) {
[17:02:53.871]                           computeRestarts <- base::computeRestarts
[17:02:53.871]                           grepl <- base::grepl
[17:02:53.871]                           restarts <- computeRestarts(cond)
[17:02:53.871]                           for (restart in restarts) {
[17:02:53.871]                             name <- restart$name
[17:02:53.871]                             if (is.null(name)) 
[17:02:53.871]                               next
[17:02:53.871]                             if (!grepl(pattern, name)) 
[17:02:53.871]                               next
[17:02:53.871]                             invokeRestart(restart)
[17:02:53.871]                             muffled <- TRUE
[17:02:53.871]                             break
[17:02:53.871]                           }
[17:02:53.871]                         }
[17:02:53.871]                       }
[17:02:53.871]                       invisible(muffled)
[17:02:53.871]                     }
[17:02:53.871]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.871]                   }
[17:02:53.871]                 }
[17:02:53.871]                 else {
[17:02:53.871]                   if (TRUE) {
[17:02:53.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.871]                     {
[17:02:53.871]                       inherits <- base::inherits
[17:02:53.871]                       invokeRestart <- base::invokeRestart
[17:02:53.871]                       is.null <- base::is.null
[17:02:53.871]                       muffled <- FALSE
[17:02:53.871]                       if (inherits(cond, "message")) {
[17:02:53.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.871]                         if (muffled) 
[17:02:53.871]                           invokeRestart("muffleMessage")
[17:02:53.871]                       }
[17:02:53.871]                       else if (inherits(cond, "warning")) {
[17:02:53.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.871]                         if (muffled) 
[17:02:53.871]                           invokeRestart("muffleWarning")
[17:02:53.871]                       }
[17:02:53.871]                       else if (inherits(cond, "condition")) {
[17:02:53.871]                         if (!is.null(pattern)) {
[17:02:53.871]                           computeRestarts <- base::computeRestarts
[17:02:53.871]                           grepl <- base::grepl
[17:02:53.871]                           restarts <- computeRestarts(cond)
[17:02:53.871]                           for (restart in restarts) {
[17:02:53.871]                             name <- restart$name
[17:02:53.871]                             if (is.null(name)) 
[17:02:53.871]                               next
[17:02:53.871]                             if (!grepl(pattern, name)) 
[17:02:53.871]                               next
[17:02:53.871]                             invokeRestart(restart)
[17:02:53.871]                             muffled <- TRUE
[17:02:53.871]                             break
[17:02:53.871]                           }
[17:02:53.871]                         }
[17:02:53.871]                       }
[17:02:53.871]                       invisible(muffled)
[17:02:53.871]                     }
[17:02:53.871]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.871]                   }
[17:02:53.871]                 }
[17:02:53.871]             }
[17:02:53.871]         }))
[17:02:53.871]     }, error = function(ex) {
[17:02:53.871]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.871]                 ...future.rng), started = ...future.startTime, 
[17:02:53.871]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.871]             version = "1.8"), class = "FutureResult")
[17:02:53.871]     }, finally = {
[17:02:53.871]         if (!identical(...future.workdir, getwd())) 
[17:02:53.871]             setwd(...future.workdir)
[17:02:53.871]         {
[17:02:53.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.871]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.871]             }
[17:02:53.871]             base::options(...future.oldOptions)
[17:02:53.871]             if (.Platform$OS.type == "windows") {
[17:02:53.871]                 old_names <- names(...future.oldEnvVars)
[17:02:53.871]                 envs <- base::Sys.getenv()
[17:02:53.871]                 names <- names(envs)
[17:02:53.871]                 common <- intersect(names, old_names)
[17:02:53.871]                 added <- setdiff(names, old_names)
[17:02:53.871]                 removed <- setdiff(old_names, names)
[17:02:53.871]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.871]                   envs[common]]
[17:02:53.871]                 NAMES <- toupper(changed)
[17:02:53.871]                 args <- list()
[17:02:53.871]                 for (kk in seq_along(NAMES)) {
[17:02:53.871]                   name <- changed[[kk]]
[17:02:53.871]                   NAME <- NAMES[[kk]]
[17:02:53.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.871]                     next
[17:02:53.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.871]                 }
[17:02:53.871]                 NAMES <- toupper(added)
[17:02:53.871]                 for (kk in seq_along(NAMES)) {
[17:02:53.871]                   name <- added[[kk]]
[17:02:53.871]                   NAME <- NAMES[[kk]]
[17:02:53.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.871]                     next
[17:02:53.871]                   args[[name]] <- ""
[17:02:53.871]                 }
[17:02:53.871]                 NAMES <- toupper(removed)
[17:02:53.871]                 for (kk in seq_along(NAMES)) {
[17:02:53.871]                   name <- removed[[kk]]
[17:02:53.871]                   NAME <- NAMES[[kk]]
[17:02:53.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.871]                     next
[17:02:53.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.871]                 }
[17:02:53.871]                 if (length(args) > 0) 
[17:02:53.871]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.871]             }
[17:02:53.871]             else {
[17:02:53.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.871]             }
[17:02:53.871]             {
[17:02:53.871]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.871]                   0L) {
[17:02:53.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.871]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.871]                   base::options(opts)
[17:02:53.871]                 }
[17:02:53.871]                 {
[17:02:53.871]                   {
[17:02:53.871]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.871]                     NULL
[17:02:53.871]                   }
[17:02:53.871]                   options(future.plan = NULL)
[17:02:53.871]                   if (is.na(NA_character_)) 
[17:02:53.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.871]                     .init = FALSE)
[17:02:53.871]                 }
[17:02:53.871]             }
[17:02:53.871]         }
[17:02:53.871]     })
[17:02:53.871]     if (TRUE) {
[17:02:53.871]         base::sink(type = "output", split = FALSE)
[17:02:53.871]         if (TRUE) {
[17:02:53.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.871]         }
[17:02:53.871]         else {
[17:02:53.871]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.871]         }
[17:02:53.871]         base::close(...future.stdout)
[17:02:53.871]         ...future.stdout <- NULL
[17:02:53.871]     }
[17:02:53.871]     ...future.result$conditions <- ...future.conditions
[17:02:53.871]     ...future.result$finished <- base::Sys.time()
[17:02:53.871]     ...future.result
[17:02:53.871] }
[17:02:53.874] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:53.884] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.884] - Validating connection of MultisessionFuture
[17:02:53.885] - received message: FutureResult
[17:02:53.885] - Received FutureResult
[17:02:53.885] - Erased future from FutureRegistry
[17:02:53.885] result() for ClusterFuture ...
[17:02:53.885] - result already collected: FutureResult
[17:02:53.885] result() for ClusterFuture ... done
[17:02:53.886] signalConditions() ...
[17:02:53.886]  - include = ‘immediateCondition’
[17:02:53.886]  - exclude = 
[17:02:53.886]  - resignal = FALSE
[17:02:53.886]  - Number of conditions: 1
[17:02:53.886] signalConditions() ... done
[17:02:53.886] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.886] result() for ClusterFuture ...
[17:02:53.886] - result already collected: FutureResult
[17:02:53.886] result() for ClusterFuture ... done
[17:02:53.886] result() for ClusterFuture ...
[17:02:53.886] - result already collected: FutureResult
[17:02:53.887] result() for ClusterFuture ... done
[17:02:53.887] signalConditions() ...
[17:02:53.887]  - include = ‘immediateCondition’
[17:02:53.887]  - exclude = 
[17:02:53.887]  - resignal = FALSE
[17:02:53.887]  - Number of conditions: 1
[17:02:53.887] signalConditions() ... done
[17:02:53.888] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:02:53.888] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:02:53.888] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:02:53.889] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:02:53.889] MultisessionFuture started
[17:02:53.889] - Launch lazy future ... done
[17:02:53.889] run() for ‘MultisessionFuture’ ... done
[17:02:53.889] result() for ClusterFuture ...
[17:02:53.889] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.889] - Validating connection of MultisessionFuture
[17:02:53.891] - received message: FutureResult
[17:02:53.891] - Received FutureResult
[17:02:53.891] - Erased future from FutureRegistry
[17:02:53.891] result() for ClusterFuture ...
[17:02:53.892] - result already collected: FutureResult
[17:02:53.892] result() for ClusterFuture ... done
[17:02:53.892] signalConditions() ...
[17:02:53.892]  - include = ‘immediateCondition’
[17:02:53.892]  - exclude = 
[17:02:53.892]  - resignal = FALSE
[17:02:53.892]  - Number of conditions: 1
[17:02:53.892] signalConditions() ... done
[17:02:53.892] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.892] result() for ClusterFuture ... done
[17:02:53.892] result() for ClusterFuture ...
[17:02:53.893] - result already collected: FutureResult
[17:02:53.893] result() for ClusterFuture ... done
[17:02:53.893] signalConditions() ...
[17:02:53.893]  - include = ‘immediateCondition’
[17:02:53.893]  - exclude = 
[17:02:53.893]  - resignal = FALSE
[17:02:53.893]  - Number of conditions: 1
[17:02:53.893] signalConditions() ... done
[17:02:53.893] Future state: ‘finished’
[17:02:53.893] result() for ClusterFuture ...
[17:02:53.893] - result already collected: FutureResult
[17:02:53.894] result() for ClusterFuture ... done
[17:02:53.894] signalConditions() ...
[17:02:53.894]  - include = ‘condition’
[17:02:53.894]  - exclude = ‘immediateCondition’
[17:02:53.894]  - resignal = TRUE
[17:02:53.894]  - Number of conditions: 1
[17:02:53.894]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:02:53.894] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "48b61fc2246e" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-11-25 17:02:53"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.908] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.908] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.909] 
[17:02:53.909] Searching for globals ... DONE
[17:02:53.909] - globals: [0] <none>
[17:02:53.909] getGlobalsAndPackages() ... DONE
[17:02:53.909] run() for ‘Future’ ...
[17:02:53.909] - state: ‘created’
[17:02:53.909] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.925]   - Field: ‘node’
[17:02:53.925]   - Field: ‘label’
[17:02:53.925]   - Field: ‘local’
[17:02:53.925]   - Field: ‘owner’
[17:02:53.925]   - Field: ‘envir’
[17:02:53.925]   - Field: ‘workers’
[17:02:53.925]   - Field: ‘packages’
[17:02:53.926]   - Field: ‘gc’
[17:02:53.926]   - Field: ‘conditions’
[17:02:53.926]   - Field: ‘persistent’
[17:02:53.926]   - Field: ‘expr’
[17:02:53.926]   - Field: ‘uuid’
[17:02:53.926]   - Field: ‘seed’
[17:02:53.927]   - Field: ‘version’
[17:02:53.927]   - Field: ‘result’
[17:02:53.927]   - Field: ‘asynchronous’
[17:02:53.927]   - Field: ‘calls’
[17:02:53.927]   - Field: ‘globals’
[17:02:53.927]   - Field: ‘stdout’
[17:02:53.927]   - Field: ‘earlySignal’
[17:02:53.927]   - Field: ‘lazy’
[17:02:53.927]   - Field: ‘state’
[17:02:53.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.928] - Launch lazy future ...
[17:02:53.928] Packages needed by the future expression (n = 0): <none>
[17:02:53.928] Packages needed by future strategies (n = 0): <none>
[17:02:53.928] {
[17:02:53.928]     {
[17:02:53.928]         {
[17:02:53.928]             ...future.startTime <- base::Sys.time()
[17:02:53.928]             {
[17:02:53.928]                 {
[17:02:53.928]                   {
[17:02:53.928]                     {
[17:02:53.928]                       base::local({
[17:02:53.928]                         has_future <- base::requireNamespace("future", 
[17:02:53.928]                           quietly = TRUE)
[17:02:53.928]                         if (has_future) {
[17:02:53.928]                           ns <- base::getNamespace("future")
[17:02:53.928]                           version <- ns[[".package"]][["version"]]
[17:02:53.928]                           if (is.null(version)) 
[17:02:53.928]                             version <- utils::packageVersion("future")
[17:02:53.928]                         }
[17:02:53.928]                         else {
[17:02:53.928]                           version <- NULL
[17:02:53.928]                         }
[17:02:53.928]                         if (!has_future || version < "1.8.0") {
[17:02:53.928]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.928]                             "", base::R.version$version.string), 
[17:02:53.928]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:53.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:53.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.928]                               "release", "version")], collapse = " "), 
[17:02:53.928]                             hostname = base::Sys.info()[["nodename"]])
[17:02:53.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.928]                             info)
[17:02:53.928]                           info <- base::paste(info, collapse = "; ")
[17:02:53.928]                           if (!has_future) {
[17:02:53.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.928]                               info)
[17:02:53.928]                           }
[17:02:53.928]                           else {
[17:02:53.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.928]                               info, version)
[17:02:53.928]                           }
[17:02:53.928]                           base::stop(msg)
[17:02:53.928]                         }
[17:02:53.928]                       })
[17:02:53.928]                     }
[17:02:53.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.928]                     base::options(mc.cores = 1L)
[17:02:53.928]                   }
[17:02:53.928]                   ...future.strategy.old <- future::plan("list")
[17:02:53.928]                   options(future.plan = NULL)
[17:02:53.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.928]                 }
[17:02:53.928]                 ...future.workdir <- getwd()
[17:02:53.928]             }
[17:02:53.928]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.928]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.928]         }
[17:02:53.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.928]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.928]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.928]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.928]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.928]             base::names(...future.oldOptions))
[17:02:53.928]     }
[17:02:53.928]     if (FALSE) {
[17:02:53.928]     }
[17:02:53.928]     else {
[17:02:53.928]         if (TRUE) {
[17:02:53.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.928]                 open = "w")
[17:02:53.928]         }
[17:02:53.928]         else {
[17:02:53.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.928]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.928]         }
[17:02:53.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.928]             base::sink(type = "output", split = FALSE)
[17:02:53.928]             base::close(...future.stdout)
[17:02:53.928]         }, add = TRUE)
[17:02:53.928]     }
[17:02:53.928]     ...future.frame <- base::sys.nframe()
[17:02:53.928]     ...future.conditions <- base::list()
[17:02:53.928]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.928]     if (FALSE) {
[17:02:53.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.928]     }
[17:02:53.928]     ...future.result <- base::tryCatch({
[17:02:53.928]         base::withCallingHandlers({
[17:02:53.928]             ...future.value <- base::withVisible(base::local({
[17:02:53.928]                 ...future.makeSendCondition <- base::local({
[17:02:53.928]                   sendCondition <- NULL
[17:02:53.928]                   function(frame = 1L) {
[17:02:53.928]                     if (is.function(sendCondition)) 
[17:02:53.928]                       return(sendCondition)
[17:02:53.928]                     ns <- getNamespace("parallel")
[17:02:53.928]                     if (exists("sendData", mode = "function", 
[17:02:53.928]                       envir = ns)) {
[17:02:53.928]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.928]                         envir = ns)
[17:02:53.928]                       envir <- sys.frame(frame)
[17:02:53.928]                       master <- NULL
[17:02:53.928]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.928]                         !identical(envir, emptyenv())) {
[17:02:53.928]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.928]                           inherits = FALSE)) {
[17:02:53.928]                           master <- get("master", mode = "list", 
[17:02:53.928]                             envir = envir, inherits = FALSE)
[17:02:53.928]                           if (inherits(master, c("SOCKnode", 
[17:02:53.928]                             "SOCK0node"))) {
[17:02:53.928]                             sendCondition <<- function(cond) {
[17:02:53.928]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.928]                                 success = TRUE)
[17:02:53.928]                               parallel_sendData(master, data)
[17:02:53.928]                             }
[17:02:53.928]                             return(sendCondition)
[17:02:53.928]                           }
[17:02:53.928]                         }
[17:02:53.928]                         frame <- frame + 1L
[17:02:53.928]                         envir <- sys.frame(frame)
[17:02:53.928]                       }
[17:02:53.928]                     }
[17:02:53.928]                     sendCondition <<- function(cond) NULL
[17:02:53.928]                   }
[17:02:53.928]                 })
[17:02:53.928]                 withCallingHandlers({
[17:02:53.928]                   1
[17:02:53.928]                 }, immediateCondition = function(cond) {
[17:02:53.928]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.928]                   sendCondition(cond)
[17:02:53.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.928]                   {
[17:02:53.928]                     inherits <- base::inherits
[17:02:53.928]                     invokeRestart <- base::invokeRestart
[17:02:53.928]                     is.null <- base::is.null
[17:02:53.928]                     muffled <- FALSE
[17:02:53.928]                     if (inherits(cond, "message")) {
[17:02:53.928]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.928]                       if (muffled) 
[17:02:53.928]                         invokeRestart("muffleMessage")
[17:02:53.928]                     }
[17:02:53.928]                     else if (inherits(cond, "warning")) {
[17:02:53.928]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.928]                       if (muffled) 
[17:02:53.928]                         invokeRestart("muffleWarning")
[17:02:53.928]                     }
[17:02:53.928]                     else if (inherits(cond, "condition")) {
[17:02:53.928]                       if (!is.null(pattern)) {
[17:02:53.928]                         computeRestarts <- base::computeRestarts
[17:02:53.928]                         grepl <- base::grepl
[17:02:53.928]                         restarts <- computeRestarts(cond)
[17:02:53.928]                         for (restart in restarts) {
[17:02:53.928]                           name <- restart$name
[17:02:53.928]                           if (is.null(name)) 
[17:02:53.928]                             next
[17:02:53.928]                           if (!grepl(pattern, name)) 
[17:02:53.928]                             next
[17:02:53.928]                           invokeRestart(restart)
[17:02:53.928]                           muffled <- TRUE
[17:02:53.928]                           break
[17:02:53.928]                         }
[17:02:53.928]                       }
[17:02:53.928]                     }
[17:02:53.928]                     invisible(muffled)
[17:02:53.928]                   }
[17:02:53.928]                   muffleCondition(cond)
[17:02:53.928]                 })
[17:02:53.928]             }))
[17:02:53.928]             future::FutureResult(value = ...future.value$value, 
[17:02:53.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.928]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.928]                     ...future.globalenv.names))
[17:02:53.928]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.928]         }, condition = base::local({
[17:02:53.928]             c <- base::c
[17:02:53.928]             inherits <- base::inherits
[17:02:53.928]             invokeRestart <- base::invokeRestart
[17:02:53.928]             length <- base::length
[17:02:53.928]             list <- base::list
[17:02:53.928]             seq.int <- base::seq.int
[17:02:53.928]             signalCondition <- base::signalCondition
[17:02:53.928]             sys.calls <- base::sys.calls
[17:02:53.928]             `[[` <- base::`[[`
[17:02:53.928]             `+` <- base::`+`
[17:02:53.928]             `<<-` <- base::`<<-`
[17:02:53.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.928]                   3L)]
[17:02:53.928]             }
[17:02:53.928]             function(cond) {
[17:02:53.928]                 is_error <- inherits(cond, "error")
[17:02:53.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.928]                   NULL)
[17:02:53.928]                 if (is_error) {
[17:02:53.928]                   sessionInformation <- function() {
[17:02:53.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.928]                       search = base::search(), system = base::Sys.info())
[17:02:53.928]                   }
[17:02:53.928]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.928]                     cond$call), session = sessionInformation(), 
[17:02:53.928]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.928]                   signalCondition(cond)
[17:02:53.928]                 }
[17:02:53.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.928]                 "immediateCondition"))) {
[17:02:53.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.928]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.928]                   if (TRUE && !signal) {
[17:02:53.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.928]                     {
[17:02:53.928]                       inherits <- base::inherits
[17:02:53.928]                       invokeRestart <- base::invokeRestart
[17:02:53.928]                       is.null <- base::is.null
[17:02:53.928]                       muffled <- FALSE
[17:02:53.928]                       if (inherits(cond, "message")) {
[17:02:53.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.928]                         if (muffled) 
[17:02:53.928]                           invokeRestart("muffleMessage")
[17:02:53.928]                       }
[17:02:53.928]                       else if (inherits(cond, "warning")) {
[17:02:53.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.928]                         if (muffled) 
[17:02:53.928]                           invokeRestart("muffleWarning")
[17:02:53.928]                       }
[17:02:53.928]                       else if (inherits(cond, "condition")) {
[17:02:53.928]                         if (!is.null(pattern)) {
[17:02:53.928]                           computeRestarts <- base::computeRestarts
[17:02:53.928]                           grepl <- base::grepl
[17:02:53.928]                           restarts <- computeRestarts(cond)
[17:02:53.928]                           for (restart in restarts) {
[17:02:53.928]                             name <- restart$name
[17:02:53.928]                             if (is.null(name)) 
[17:02:53.928]                               next
[17:02:53.928]                             if (!grepl(pattern, name)) 
[17:02:53.928]                               next
[17:02:53.928]                             invokeRestart(restart)
[17:02:53.928]                             muffled <- TRUE
[17:02:53.928]                             break
[17:02:53.928]                           }
[17:02:53.928]                         }
[17:02:53.928]                       }
[17:02:53.928]                       invisible(muffled)
[17:02:53.928]                     }
[17:02:53.928]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.928]                   }
[17:02:53.928]                 }
[17:02:53.928]                 else {
[17:02:53.928]                   if (TRUE) {
[17:02:53.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.928]                     {
[17:02:53.928]                       inherits <- base::inherits
[17:02:53.928]                       invokeRestart <- base::invokeRestart
[17:02:53.928]                       is.null <- base::is.null
[17:02:53.928]                       muffled <- FALSE
[17:02:53.928]                       if (inherits(cond, "message")) {
[17:02:53.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.928]                         if (muffled) 
[17:02:53.928]                           invokeRestart("muffleMessage")
[17:02:53.928]                       }
[17:02:53.928]                       else if (inherits(cond, "warning")) {
[17:02:53.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.928]                         if (muffled) 
[17:02:53.928]                           invokeRestart("muffleWarning")
[17:02:53.928]                       }
[17:02:53.928]                       else if (inherits(cond, "condition")) {
[17:02:53.928]                         if (!is.null(pattern)) {
[17:02:53.928]                           computeRestarts <- base::computeRestarts
[17:02:53.928]                           grepl <- base::grepl
[17:02:53.928]                           restarts <- computeRestarts(cond)
[17:02:53.928]                           for (restart in restarts) {
[17:02:53.928]                             name <- restart$name
[17:02:53.928]                             if (is.null(name)) 
[17:02:53.928]                               next
[17:02:53.928]                             if (!grepl(pattern, name)) 
[17:02:53.928]                               next
[17:02:53.928]                             invokeRestart(restart)
[17:02:53.928]                             muffled <- TRUE
[17:02:53.928]                             break
[17:02:53.928]                           }
[17:02:53.928]                         }
[17:02:53.928]                       }
[17:02:53.928]                       invisible(muffled)
[17:02:53.928]                     }
[17:02:53.928]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.928]                   }
[17:02:53.928]                 }
[17:02:53.928]             }
[17:02:53.928]         }))
[17:02:53.928]     }, error = function(ex) {
[17:02:53.928]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.928]                 ...future.rng), started = ...future.startTime, 
[17:02:53.928]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.928]             version = "1.8"), class = "FutureResult")
[17:02:53.928]     }, finally = {
[17:02:53.928]         if (!identical(...future.workdir, getwd())) 
[17:02:53.928]             setwd(...future.workdir)
[17:02:53.928]         {
[17:02:53.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.928]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.928]             }
[17:02:53.928]             base::options(...future.oldOptions)
[17:02:53.928]             if (.Platform$OS.type == "windows") {
[17:02:53.928]                 old_names <- names(...future.oldEnvVars)
[17:02:53.928]                 envs <- base::Sys.getenv()
[17:02:53.928]                 names <- names(envs)
[17:02:53.928]                 common <- intersect(names, old_names)
[17:02:53.928]                 added <- setdiff(names, old_names)
[17:02:53.928]                 removed <- setdiff(old_names, names)
[17:02:53.928]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.928]                   envs[common]]
[17:02:53.928]                 NAMES <- toupper(changed)
[17:02:53.928]                 args <- list()
[17:02:53.928]                 for (kk in seq_along(NAMES)) {
[17:02:53.928]                   name <- changed[[kk]]
[17:02:53.928]                   NAME <- NAMES[[kk]]
[17:02:53.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.928]                     next
[17:02:53.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.928]                 }
[17:02:53.928]                 NAMES <- toupper(added)
[17:02:53.928]                 for (kk in seq_along(NAMES)) {
[17:02:53.928]                   name <- added[[kk]]
[17:02:53.928]                   NAME <- NAMES[[kk]]
[17:02:53.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.928]                     next
[17:02:53.928]                   args[[name]] <- ""
[17:02:53.928]                 }
[17:02:53.928]                 NAMES <- toupper(removed)
[17:02:53.928]                 for (kk in seq_along(NAMES)) {
[17:02:53.928]                   name <- removed[[kk]]
[17:02:53.928]                   NAME <- NAMES[[kk]]
[17:02:53.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.928]                     next
[17:02:53.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.928]                 }
[17:02:53.928]                 if (length(args) > 0) 
[17:02:53.928]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.928]             }
[17:02:53.928]             else {
[17:02:53.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.928]             }
[17:02:53.928]             {
[17:02:53.928]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.928]                   0L) {
[17:02:53.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.928]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.928]                   base::options(opts)
[17:02:53.928]                 }
[17:02:53.928]                 {
[17:02:53.928]                   {
[17:02:53.928]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.928]                     NULL
[17:02:53.928]                   }
[17:02:53.928]                   options(future.plan = NULL)
[17:02:53.928]                   if (is.na(NA_character_)) 
[17:02:53.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.928]                     .init = FALSE)
[17:02:53.928]                 }
[17:02:53.928]             }
[17:02:53.928]         }
[17:02:53.928]     })
[17:02:53.928]     if (TRUE) {
[17:02:53.928]         base::sink(type = "output", split = FALSE)
[17:02:53.928]         if (TRUE) {
[17:02:53.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.928]         }
[17:02:53.928]         else {
[17:02:53.928]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.928]         }
[17:02:53.928]         base::close(...future.stdout)
[17:02:53.928]         ...future.stdout <- NULL
[17:02:53.928]     }
[17:02:53.928]     ...future.result$conditions <- ...future.conditions
[17:02:53.928]     ...future.result$finished <- base::Sys.time()
[17:02:53.928]     ...future.result
[17:02:53.928] }
[17:02:53.931] MultisessionFuture started
[17:02:53.932] - Launch lazy future ... done
[17:02:53.932] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:53.932] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:53.932] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:53.933] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:53.933] Searching for globals ... DONE
[17:02:53.933] Resolving globals: TRUE
[17:02:53.933] Resolving any globals that are futures ...
[17:02:53.934] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:53.934] Resolving any globals that are futures ... DONE
[17:02:53.934] Resolving futures part of globals (recursively) ...
[17:02:53.934] resolve() on list ...
[17:02:53.934]  recursive: 99
[17:02:53.934]  length: 1
[17:02:53.935]  elements: ‘a’
[17:02:53.937] receiveMessageFromWorker() for ClusterFuture ...
[17:02:53.937] - Validating connection of MultisessionFuture
[17:02:53.937] - received message: FutureResult
[17:02:53.937] - Received FutureResult
[17:02:53.938] - Erased future from FutureRegistry
[17:02:53.938] result() for ClusterFuture ...
[17:02:53.938] - result already collected: FutureResult
[17:02:53.938] result() for ClusterFuture ... done
[17:02:53.938] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:53.938] Future #1
[17:02:53.938] result() for ClusterFuture ...
[17:02:53.938] - result already collected: FutureResult
[17:02:53.938] result() for ClusterFuture ... done
[17:02:53.938] result() for ClusterFuture ...
[17:02:53.938] - result already collected: FutureResult
[17:02:53.939] result() for ClusterFuture ... done
[17:02:53.939] A MultisessionFuture was resolved
[17:02:53.939]  length: 0 (resolved future 1)
[17:02:53.939] resolve() on list ... DONE
[17:02:53.939] - globals: [1] ‘a’
[17:02:53.939] Resolving futures part of globals (recursively) ... DONE
[17:02:53.940] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:02:53.940] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:02:53.940] - globals: [1] ‘a’
[17:02:53.941] - packages: [1] ‘future’
[17:02:53.941] getGlobalsAndPackages() ... DONE
[17:02:53.941] run() for ‘Future’ ...
[17:02:53.941] - state: ‘created’
[17:02:53.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:53.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:53.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:53.956]   - Field: ‘node’
[17:02:53.956]   - Field: ‘label’
[17:02:53.956]   - Field: ‘local’
[17:02:53.956]   - Field: ‘owner’
[17:02:53.956]   - Field: ‘envir’
[17:02:53.956]   - Field: ‘workers’
[17:02:53.956]   - Field: ‘packages’
[17:02:53.956]   - Field: ‘gc’
[17:02:53.956]   - Field: ‘conditions’
[17:02:53.957]   - Field: ‘persistent’
[17:02:53.957]   - Field: ‘expr’
[17:02:53.957]   - Field: ‘uuid’
[17:02:53.957]   - Field: ‘seed’
[17:02:53.957]   - Field: ‘version’
[17:02:53.957]   - Field: ‘result’
[17:02:53.957]   - Field: ‘asynchronous’
[17:02:53.957]   - Field: ‘calls’
[17:02:53.957]   - Field: ‘globals’
[17:02:53.957]   - Field: ‘stdout’
[17:02:53.957]   - Field: ‘earlySignal’
[17:02:53.958]   - Field: ‘lazy’
[17:02:53.958]   - Field: ‘state’
[17:02:53.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:53.958] - Launch lazy future ...
[17:02:53.958] Packages needed by the future expression (n = 1): ‘future’
[17:02:53.958] Packages needed by future strategies (n = 0): <none>
[17:02:53.959] {
[17:02:53.959]     {
[17:02:53.959]         {
[17:02:53.959]             ...future.startTime <- base::Sys.time()
[17:02:53.959]             {
[17:02:53.959]                 {
[17:02:53.959]                   {
[17:02:53.959]                     {
[17:02:53.959]                       {
[17:02:53.959]                         base::local({
[17:02:53.959]                           has_future <- base::requireNamespace("future", 
[17:02:53.959]                             quietly = TRUE)
[17:02:53.959]                           if (has_future) {
[17:02:53.959]                             ns <- base::getNamespace("future")
[17:02:53.959]                             version <- ns[[".package"]][["version"]]
[17:02:53.959]                             if (is.null(version)) 
[17:02:53.959]                               version <- utils::packageVersion("future")
[17:02:53.959]                           }
[17:02:53.959]                           else {
[17:02:53.959]                             version <- NULL
[17:02:53.959]                           }
[17:02:53.959]                           if (!has_future || version < "1.8.0") {
[17:02:53.959]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:53.959]                               "", base::R.version$version.string), 
[17:02:53.959]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:53.959]                                 base::R.version$platform, 8 * 
[17:02:53.959]                                   base::.Machine$sizeof.pointer), 
[17:02:53.959]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:53.959]                                 "release", "version")], collapse = " "), 
[17:02:53.959]                               hostname = base::Sys.info()[["nodename"]])
[17:02:53.959]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:53.959]                               info)
[17:02:53.959]                             info <- base::paste(info, collapse = "; ")
[17:02:53.959]                             if (!has_future) {
[17:02:53.959]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:53.959]                                 info)
[17:02:53.959]                             }
[17:02:53.959]                             else {
[17:02:53.959]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:53.959]                                 info, version)
[17:02:53.959]                             }
[17:02:53.959]                             base::stop(msg)
[17:02:53.959]                           }
[17:02:53.959]                         })
[17:02:53.959]                       }
[17:02:53.959]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:53.959]                       base::options(mc.cores = 1L)
[17:02:53.959]                     }
[17:02:53.959]                     base::local({
[17:02:53.959]                       for (pkg in "future") {
[17:02:53.959]                         base::loadNamespace(pkg)
[17:02:53.959]                         base::library(pkg, character.only = TRUE)
[17:02:53.959]                       }
[17:02:53.959]                     })
[17:02:53.959]                   }
[17:02:53.959]                   ...future.strategy.old <- future::plan("list")
[17:02:53.959]                   options(future.plan = NULL)
[17:02:53.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:53.959]                 }
[17:02:53.959]                 ...future.workdir <- getwd()
[17:02:53.959]             }
[17:02:53.959]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:53.959]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:53.959]         }
[17:02:53.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:53.959]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:53.959]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:53.959]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:53.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:53.959]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:53.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:53.959]             base::names(...future.oldOptions))
[17:02:53.959]     }
[17:02:53.959]     if (FALSE) {
[17:02:53.959]     }
[17:02:53.959]     else {
[17:02:53.959]         if (TRUE) {
[17:02:53.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:53.959]                 open = "w")
[17:02:53.959]         }
[17:02:53.959]         else {
[17:02:53.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:53.959]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:53.959]         }
[17:02:53.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:53.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:53.959]             base::sink(type = "output", split = FALSE)
[17:02:53.959]             base::close(...future.stdout)
[17:02:53.959]         }, add = TRUE)
[17:02:53.959]     }
[17:02:53.959]     ...future.frame <- base::sys.nframe()
[17:02:53.959]     ...future.conditions <- base::list()
[17:02:53.959]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:53.959]     if (FALSE) {
[17:02:53.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:53.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:53.959]     }
[17:02:53.959]     ...future.result <- base::tryCatch({
[17:02:53.959]         base::withCallingHandlers({
[17:02:53.959]             ...future.value <- base::withVisible(base::local({
[17:02:53.959]                 ...future.makeSendCondition <- base::local({
[17:02:53.959]                   sendCondition <- NULL
[17:02:53.959]                   function(frame = 1L) {
[17:02:53.959]                     if (is.function(sendCondition)) 
[17:02:53.959]                       return(sendCondition)
[17:02:53.959]                     ns <- getNamespace("parallel")
[17:02:53.959]                     if (exists("sendData", mode = "function", 
[17:02:53.959]                       envir = ns)) {
[17:02:53.959]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:53.959]                         envir = ns)
[17:02:53.959]                       envir <- sys.frame(frame)
[17:02:53.959]                       master <- NULL
[17:02:53.959]                       while (!identical(envir, .GlobalEnv) && 
[17:02:53.959]                         !identical(envir, emptyenv())) {
[17:02:53.959]                         if (exists("master", mode = "list", envir = envir, 
[17:02:53.959]                           inherits = FALSE)) {
[17:02:53.959]                           master <- get("master", mode = "list", 
[17:02:53.959]                             envir = envir, inherits = FALSE)
[17:02:53.959]                           if (inherits(master, c("SOCKnode", 
[17:02:53.959]                             "SOCK0node"))) {
[17:02:53.959]                             sendCondition <<- function(cond) {
[17:02:53.959]                               data <- list(type = "VALUE", value = cond, 
[17:02:53.959]                                 success = TRUE)
[17:02:53.959]                               parallel_sendData(master, data)
[17:02:53.959]                             }
[17:02:53.959]                             return(sendCondition)
[17:02:53.959]                           }
[17:02:53.959]                         }
[17:02:53.959]                         frame <- frame + 1L
[17:02:53.959]                         envir <- sys.frame(frame)
[17:02:53.959]                       }
[17:02:53.959]                     }
[17:02:53.959]                     sendCondition <<- function(cond) NULL
[17:02:53.959]                   }
[17:02:53.959]                 })
[17:02:53.959]                 withCallingHandlers({
[17:02:53.959]                   value(a) + 1
[17:02:53.959]                 }, immediateCondition = function(cond) {
[17:02:53.959]                   sendCondition <- ...future.makeSendCondition()
[17:02:53.959]                   sendCondition(cond)
[17:02:53.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.959]                   {
[17:02:53.959]                     inherits <- base::inherits
[17:02:53.959]                     invokeRestart <- base::invokeRestart
[17:02:53.959]                     is.null <- base::is.null
[17:02:53.959]                     muffled <- FALSE
[17:02:53.959]                     if (inherits(cond, "message")) {
[17:02:53.959]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:53.959]                       if (muffled) 
[17:02:53.959]                         invokeRestart("muffleMessage")
[17:02:53.959]                     }
[17:02:53.959]                     else if (inherits(cond, "warning")) {
[17:02:53.959]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:53.959]                       if (muffled) 
[17:02:53.959]                         invokeRestart("muffleWarning")
[17:02:53.959]                     }
[17:02:53.959]                     else if (inherits(cond, "condition")) {
[17:02:53.959]                       if (!is.null(pattern)) {
[17:02:53.959]                         computeRestarts <- base::computeRestarts
[17:02:53.959]                         grepl <- base::grepl
[17:02:53.959]                         restarts <- computeRestarts(cond)
[17:02:53.959]                         for (restart in restarts) {
[17:02:53.959]                           name <- restart$name
[17:02:53.959]                           if (is.null(name)) 
[17:02:53.959]                             next
[17:02:53.959]                           if (!grepl(pattern, name)) 
[17:02:53.959]                             next
[17:02:53.959]                           invokeRestart(restart)
[17:02:53.959]                           muffled <- TRUE
[17:02:53.959]                           break
[17:02:53.959]                         }
[17:02:53.959]                       }
[17:02:53.959]                     }
[17:02:53.959]                     invisible(muffled)
[17:02:53.959]                   }
[17:02:53.959]                   muffleCondition(cond)
[17:02:53.959]                 })
[17:02:53.959]             }))
[17:02:53.959]             future::FutureResult(value = ...future.value$value, 
[17:02:53.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.959]                   ...future.rng), globalenv = if (FALSE) 
[17:02:53.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:53.959]                     ...future.globalenv.names))
[17:02:53.959]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:53.959]         }, condition = base::local({
[17:02:53.959]             c <- base::c
[17:02:53.959]             inherits <- base::inherits
[17:02:53.959]             invokeRestart <- base::invokeRestart
[17:02:53.959]             length <- base::length
[17:02:53.959]             list <- base::list
[17:02:53.959]             seq.int <- base::seq.int
[17:02:53.959]             signalCondition <- base::signalCondition
[17:02:53.959]             sys.calls <- base::sys.calls
[17:02:53.959]             `[[` <- base::`[[`
[17:02:53.959]             `+` <- base::`+`
[17:02:53.959]             `<<-` <- base::`<<-`
[17:02:53.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:53.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:53.959]                   3L)]
[17:02:53.959]             }
[17:02:53.959]             function(cond) {
[17:02:53.959]                 is_error <- inherits(cond, "error")
[17:02:53.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:53.959]                   NULL)
[17:02:53.959]                 if (is_error) {
[17:02:53.959]                   sessionInformation <- function() {
[17:02:53.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:53.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:53.959]                       search = base::search(), system = base::Sys.info())
[17:02:53.959]                   }
[17:02:53.959]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:53.959]                     cond$call), session = sessionInformation(), 
[17:02:53.959]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:53.959]                   signalCondition(cond)
[17:02:53.959]                 }
[17:02:53.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:53.959]                 "immediateCondition"))) {
[17:02:53.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:53.959]                   ...future.conditions[[length(...future.conditions) + 
[17:02:53.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:53.959]                   if (TRUE && !signal) {
[17:02:53.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.959]                     {
[17:02:53.959]                       inherits <- base::inherits
[17:02:53.959]                       invokeRestart <- base::invokeRestart
[17:02:53.959]                       is.null <- base::is.null
[17:02:53.959]                       muffled <- FALSE
[17:02:53.959]                       if (inherits(cond, "message")) {
[17:02:53.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.959]                         if (muffled) 
[17:02:53.959]                           invokeRestart("muffleMessage")
[17:02:53.959]                       }
[17:02:53.959]                       else if (inherits(cond, "warning")) {
[17:02:53.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.959]                         if (muffled) 
[17:02:53.959]                           invokeRestart("muffleWarning")
[17:02:53.959]                       }
[17:02:53.959]                       else if (inherits(cond, "condition")) {
[17:02:53.959]                         if (!is.null(pattern)) {
[17:02:53.959]                           computeRestarts <- base::computeRestarts
[17:02:53.959]                           grepl <- base::grepl
[17:02:53.959]                           restarts <- computeRestarts(cond)
[17:02:53.959]                           for (restart in restarts) {
[17:02:53.959]                             name <- restart$name
[17:02:53.959]                             if (is.null(name)) 
[17:02:53.959]                               next
[17:02:53.959]                             if (!grepl(pattern, name)) 
[17:02:53.959]                               next
[17:02:53.959]                             invokeRestart(restart)
[17:02:53.959]                             muffled <- TRUE
[17:02:53.959]                             break
[17:02:53.959]                           }
[17:02:53.959]                         }
[17:02:53.959]                       }
[17:02:53.959]                       invisible(muffled)
[17:02:53.959]                     }
[17:02:53.959]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.959]                   }
[17:02:53.959]                 }
[17:02:53.959]                 else {
[17:02:53.959]                   if (TRUE) {
[17:02:53.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:53.959]                     {
[17:02:53.959]                       inherits <- base::inherits
[17:02:53.959]                       invokeRestart <- base::invokeRestart
[17:02:53.959]                       is.null <- base::is.null
[17:02:53.959]                       muffled <- FALSE
[17:02:53.959]                       if (inherits(cond, "message")) {
[17:02:53.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:53.959]                         if (muffled) 
[17:02:53.959]                           invokeRestart("muffleMessage")
[17:02:53.959]                       }
[17:02:53.959]                       else if (inherits(cond, "warning")) {
[17:02:53.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:53.959]                         if (muffled) 
[17:02:53.959]                           invokeRestart("muffleWarning")
[17:02:53.959]                       }
[17:02:53.959]                       else if (inherits(cond, "condition")) {
[17:02:53.959]                         if (!is.null(pattern)) {
[17:02:53.959]                           computeRestarts <- base::computeRestarts
[17:02:53.959]                           grepl <- base::grepl
[17:02:53.959]                           restarts <- computeRestarts(cond)
[17:02:53.959]                           for (restart in restarts) {
[17:02:53.959]                             name <- restart$name
[17:02:53.959]                             if (is.null(name)) 
[17:02:53.959]                               next
[17:02:53.959]                             if (!grepl(pattern, name)) 
[17:02:53.959]                               next
[17:02:53.959]                             invokeRestart(restart)
[17:02:53.959]                             muffled <- TRUE
[17:02:53.959]                             break
[17:02:53.959]                           }
[17:02:53.959]                         }
[17:02:53.959]                       }
[17:02:53.959]                       invisible(muffled)
[17:02:53.959]                     }
[17:02:53.959]                     muffleCondition(cond, pattern = "^muffle")
[17:02:53.959]                   }
[17:02:53.959]                 }
[17:02:53.959]             }
[17:02:53.959]         }))
[17:02:53.959]     }, error = function(ex) {
[17:02:53.959]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:53.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:53.959]                 ...future.rng), started = ...future.startTime, 
[17:02:53.959]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:53.959]             version = "1.8"), class = "FutureResult")
[17:02:53.959]     }, finally = {
[17:02:53.959]         if (!identical(...future.workdir, getwd())) 
[17:02:53.959]             setwd(...future.workdir)
[17:02:53.959]         {
[17:02:53.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:53.959]                 ...future.oldOptions$nwarnings <- NULL
[17:02:53.959]             }
[17:02:53.959]             base::options(...future.oldOptions)
[17:02:53.959]             if (.Platform$OS.type == "windows") {
[17:02:53.959]                 old_names <- names(...future.oldEnvVars)
[17:02:53.959]                 envs <- base::Sys.getenv()
[17:02:53.959]                 names <- names(envs)
[17:02:53.959]                 common <- intersect(names, old_names)
[17:02:53.959]                 added <- setdiff(names, old_names)
[17:02:53.959]                 removed <- setdiff(old_names, names)
[17:02:53.959]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:53.959]                   envs[common]]
[17:02:53.959]                 NAMES <- toupper(changed)
[17:02:53.959]                 args <- list()
[17:02:53.959]                 for (kk in seq_along(NAMES)) {
[17:02:53.959]                   name <- changed[[kk]]
[17:02:53.959]                   NAME <- NAMES[[kk]]
[17:02:53.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.959]                     next
[17:02:53.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.959]                 }
[17:02:53.959]                 NAMES <- toupper(added)
[17:02:53.959]                 for (kk in seq_along(NAMES)) {
[17:02:53.959]                   name <- added[[kk]]
[17:02:53.959]                   NAME <- NAMES[[kk]]
[17:02:53.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.959]                     next
[17:02:53.959]                   args[[name]] <- ""
[17:02:53.959]                 }
[17:02:53.959]                 NAMES <- toupper(removed)
[17:02:53.959]                 for (kk in seq_along(NAMES)) {
[17:02:53.959]                   name <- removed[[kk]]
[17:02:53.959]                   NAME <- NAMES[[kk]]
[17:02:53.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:53.959]                     next
[17:02:53.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:53.959]                 }
[17:02:53.959]                 if (length(args) > 0) 
[17:02:53.959]                   base::do.call(base::Sys.setenv, args = args)
[17:02:53.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:53.959]             }
[17:02:53.959]             else {
[17:02:53.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:53.959]             }
[17:02:53.959]             {
[17:02:53.959]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:53.959]                   0L) {
[17:02:53.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:53.959]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:53.959]                   base::options(opts)
[17:02:53.959]                 }
[17:02:53.959]                 {
[17:02:53.959]                   {
[17:02:53.959]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:53.959]                     NULL
[17:02:53.959]                   }
[17:02:53.959]                   options(future.plan = NULL)
[17:02:53.959]                   if (is.na(NA_character_)) 
[17:02:53.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:53.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:53.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:53.959]                     .init = FALSE)
[17:02:53.959]                 }
[17:02:53.959]             }
[17:02:53.959]         }
[17:02:53.959]     })
[17:02:53.959]     if (TRUE) {
[17:02:53.959]         base::sink(type = "output", split = FALSE)
[17:02:53.959]         if (TRUE) {
[17:02:53.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:53.959]         }
[17:02:53.959]         else {
[17:02:53.959]             ...future.result["stdout"] <- base::list(NULL)
[17:02:53.959]         }
[17:02:53.959]         base::close(...future.stdout)
[17:02:53.959]         ...future.stdout <- NULL
[17:02:53.959]     }
[17:02:53.959]     ...future.result$conditions <- ...future.conditions
[17:02:53.959]     ...future.result$finished <- base::Sys.time()
[17:02:53.959]     ...future.result
[17:02:53.959] }
[17:02:53.962] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:02:53.964] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:02:54.016] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:02:54.016] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:02:54.017] MultisessionFuture started
[17:02:54.017] - Launch lazy future ... done
[17:02:54.017] run() for ‘MultisessionFuture’ ... done
[17:02:54.017] result() for ClusterFuture ...
[17:02:54.017] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.017] - Validating connection of MultisessionFuture
[17:02:54.065] - received message: FutureResult
[17:02:54.065] - Received FutureResult
[17:02:54.066] - Erased future from FutureRegistry
[17:02:54.066] result() for ClusterFuture ...
[17:02:54.066] - result already collected: FutureResult
[17:02:54.066] result() for ClusterFuture ... done
[17:02:54.066] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.066] result() for ClusterFuture ... done
[17:02:54.066] result() for ClusterFuture ...
[17:02:54.066] - result already collected: FutureResult
[17:02:54.066] result() for ClusterFuture ... done
value(b) = 2
[17:02:54.067] result() for ClusterFuture ...
[17:02:54.067] - result already collected: FutureResult
[17:02:54.067] result() for ClusterFuture ... done
[17:02:54.067] result() for ClusterFuture ...
[17:02:54.067] - result already collected: FutureResult
[17:02:54.067] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.067] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.068] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.068] 
[17:02:54.068] Searching for globals ... DONE
[17:02:54.068] - globals: [0] <none>
[17:02:54.068] getGlobalsAndPackages() ... DONE
[17:02:54.069] run() for ‘Future’ ...
[17:02:54.069] - state: ‘created’
[17:02:54.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.083]   - Field: ‘node’
[17:02:54.083]   - Field: ‘label’
[17:02:54.083]   - Field: ‘local’
[17:02:54.084]   - Field: ‘owner’
[17:02:54.084]   - Field: ‘envir’
[17:02:54.084]   - Field: ‘workers’
[17:02:54.084]   - Field: ‘packages’
[17:02:54.084]   - Field: ‘gc’
[17:02:54.084]   - Field: ‘conditions’
[17:02:54.084]   - Field: ‘persistent’
[17:02:54.084]   - Field: ‘expr’
[17:02:54.084]   - Field: ‘uuid’
[17:02:54.084]   - Field: ‘seed’
[17:02:54.084]   - Field: ‘version’
[17:02:54.085]   - Field: ‘result’
[17:02:54.085]   - Field: ‘asynchronous’
[17:02:54.085]   - Field: ‘calls’
[17:02:54.085]   - Field: ‘globals’
[17:02:54.085]   - Field: ‘stdout’
[17:02:54.085]   - Field: ‘earlySignal’
[17:02:54.085]   - Field: ‘lazy’
[17:02:54.085]   - Field: ‘state’
[17:02:54.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.085] - Launch lazy future ...
[17:02:54.086] Packages needed by the future expression (n = 0): <none>
[17:02:54.086] Packages needed by future strategies (n = 0): <none>
[17:02:54.086] {
[17:02:54.086]     {
[17:02:54.086]         {
[17:02:54.086]             ...future.startTime <- base::Sys.time()
[17:02:54.086]             {
[17:02:54.086]                 {
[17:02:54.086]                   {
[17:02:54.086]                     {
[17:02:54.086]                       base::local({
[17:02:54.086]                         has_future <- base::requireNamespace("future", 
[17:02:54.086]                           quietly = TRUE)
[17:02:54.086]                         if (has_future) {
[17:02:54.086]                           ns <- base::getNamespace("future")
[17:02:54.086]                           version <- ns[[".package"]][["version"]]
[17:02:54.086]                           if (is.null(version)) 
[17:02:54.086]                             version <- utils::packageVersion("future")
[17:02:54.086]                         }
[17:02:54.086]                         else {
[17:02:54.086]                           version <- NULL
[17:02:54.086]                         }
[17:02:54.086]                         if (!has_future || version < "1.8.0") {
[17:02:54.086]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.086]                             "", base::R.version$version.string), 
[17:02:54.086]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.086]                               "release", "version")], collapse = " "), 
[17:02:54.086]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.086]                             info)
[17:02:54.086]                           info <- base::paste(info, collapse = "; ")
[17:02:54.086]                           if (!has_future) {
[17:02:54.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.086]                               info)
[17:02:54.086]                           }
[17:02:54.086]                           else {
[17:02:54.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.086]                               info, version)
[17:02:54.086]                           }
[17:02:54.086]                           base::stop(msg)
[17:02:54.086]                         }
[17:02:54.086]                       })
[17:02:54.086]                     }
[17:02:54.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.086]                     base::options(mc.cores = 1L)
[17:02:54.086]                   }
[17:02:54.086]                   ...future.strategy.old <- future::plan("list")
[17:02:54.086]                   options(future.plan = NULL)
[17:02:54.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.086]                 }
[17:02:54.086]                 ...future.workdir <- getwd()
[17:02:54.086]             }
[17:02:54.086]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.086]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.086]         }
[17:02:54.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.086]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.086]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.086]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.086]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.086]             base::names(...future.oldOptions))
[17:02:54.086]     }
[17:02:54.086]     if (FALSE) {
[17:02:54.086]     }
[17:02:54.086]     else {
[17:02:54.086]         if (TRUE) {
[17:02:54.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.086]                 open = "w")
[17:02:54.086]         }
[17:02:54.086]         else {
[17:02:54.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.086]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.086]         }
[17:02:54.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.086]             base::sink(type = "output", split = FALSE)
[17:02:54.086]             base::close(...future.stdout)
[17:02:54.086]         }, add = TRUE)
[17:02:54.086]     }
[17:02:54.086]     ...future.frame <- base::sys.nframe()
[17:02:54.086]     ...future.conditions <- base::list()
[17:02:54.086]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.086]     if (FALSE) {
[17:02:54.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.086]     }
[17:02:54.086]     ...future.result <- base::tryCatch({
[17:02:54.086]         base::withCallingHandlers({
[17:02:54.086]             ...future.value <- base::withVisible(base::local({
[17:02:54.086]                 ...future.makeSendCondition <- base::local({
[17:02:54.086]                   sendCondition <- NULL
[17:02:54.086]                   function(frame = 1L) {
[17:02:54.086]                     if (is.function(sendCondition)) 
[17:02:54.086]                       return(sendCondition)
[17:02:54.086]                     ns <- getNamespace("parallel")
[17:02:54.086]                     if (exists("sendData", mode = "function", 
[17:02:54.086]                       envir = ns)) {
[17:02:54.086]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.086]                         envir = ns)
[17:02:54.086]                       envir <- sys.frame(frame)
[17:02:54.086]                       master <- NULL
[17:02:54.086]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.086]                         !identical(envir, emptyenv())) {
[17:02:54.086]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.086]                           inherits = FALSE)) {
[17:02:54.086]                           master <- get("master", mode = "list", 
[17:02:54.086]                             envir = envir, inherits = FALSE)
[17:02:54.086]                           if (inherits(master, c("SOCKnode", 
[17:02:54.086]                             "SOCK0node"))) {
[17:02:54.086]                             sendCondition <<- function(cond) {
[17:02:54.086]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.086]                                 success = TRUE)
[17:02:54.086]                               parallel_sendData(master, data)
[17:02:54.086]                             }
[17:02:54.086]                             return(sendCondition)
[17:02:54.086]                           }
[17:02:54.086]                         }
[17:02:54.086]                         frame <- frame + 1L
[17:02:54.086]                         envir <- sys.frame(frame)
[17:02:54.086]                       }
[17:02:54.086]                     }
[17:02:54.086]                     sendCondition <<- function(cond) NULL
[17:02:54.086]                   }
[17:02:54.086]                 })
[17:02:54.086]                 withCallingHandlers({
[17:02:54.086]                   1
[17:02:54.086]                 }, immediateCondition = function(cond) {
[17:02:54.086]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.086]                   sendCondition(cond)
[17:02:54.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.086]                   {
[17:02:54.086]                     inherits <- base::inherits
[17:02:54.086]                     invokeRestart <- base::invokeRestart
[17:02:54.086]                     is.null <- base::is.null
[17:02:54.086]                     muffled <- FALSE
[17:02:54.086]                     if (inherits(cond, "message")) {
[17:02:54.086]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.086]                       if (muffled) 
[17:02:54.086]                         invokeRestart("muffleMessage")
[17:02:54.086]                     }
[17:02:54.086]                     else if (inherits(cond, "warning")) {
[17:02:54.086]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.086]                       if (muffled) 
[17:02:54.086]                         invokeRestart("muffleWarning")
[17:02:54.086]                     }
[17:02:54.086]                     else if (inherits(cond, "condition")) {
[17:02:54.086]                       if (!is.null(pattern)) {
[17:02:54.086]                         computeRestarts <- base::computeRestarts
[17:02:54.086]                         grepl <- base::grepl
[17:02:54.086]                         restarts <- computeRestarts(cond)
[17:02:54.086]                         for (restart in restarts) {
[17:02:54.086]                           name <- restart$name
[17:02:54.086]                           if (is.null(name)) 
[17:02:54.086]                             next
[17:02:54.086]                           if (!grepl(pattern, name)) 
[17:02:54.086]                             next
[17:02:54.086]                           invokeRestart(restart)
[17:02:54.086]                           muffled <- TRUE
[17:02:54.086]                           break
[17:02:54.086]                         }
[17:02:54.086]                       }
[17:02:54.086]                     }
[17:02:54.086]                     invisible(muffled)
[17:02:54.086]                   }
[17:02:54.086]                   muffleCondition(cond)
[17:02:54.086]                 })
[17:02:54.086]             }))
[17:02:54.086]             future::FutureResult(value = ...future.value$value, 
[17:02:54.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.086]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.086]                     ...future.globalenv.names))
[17:02:54.086]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.086]         }, condition = base::local({
[17:02:54.086]             c <- base::c
[17:02:54.086]             inherits <- base::inherits
[17:02:54.086]             invokeRestart <- base::invokeRestart
[17:02:54.086]             length <- base::length
[17:02:54.086]             list <- base::list
[17:02:54.086]             seq.int <- base::seq.int
[17:02:54.086]             signalCondition <- base::signalCondition
[17:02:54.086]             sys.calls <- base::sys.calls
[17:02:54.086]             `[[` <- base::`[[`
[17:02:54.086]             `+` <- base::`+`
[17:02:54.086]             `<<-` <- base::`<<-`
[17:02:54.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.086]                   3L)]
[17:02:54.086]             }
[17:02:54.086]             function(cond) {
[17:02:54.086]                 is_error <- inherits(cond, "error")
[17:02:54.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.086]                   NULL)
[17:02:54.086]                 if (is_error) {
[17:02:54.086]                   sessionInformation <- function() {
[17:02:54.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.086]                       search = base::search(), system = base::Sys.info())
[17:02:54.086]                   }
[17:02:54.086]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.086]                     cond$call), session = sessionInformation(), 
[17:02:54.086]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.086]                   signalCondition(cond)
[17:02:54.086]                 }
[17:02:54.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.086]                 "immediateCondition"))) {
[17:02:54.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.086]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.086]                   if (TRUE && !signal) {
[17:02:54.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.086]                     {
[17:02:54.086]                       inherits <- base::inherits
[17:02:54.086]                       invokeRestart <- base::invokeRestart
[17:02:54.086]                       is.null <- base::is.null
[17:02:54.086]                       muffled <- FALSE
[17:02:54.086]                       if (inherits(cond, "message")) {
[17:02:54.086]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.086]                         if (muffled) 
[17:02:54.086]                           invokeRestart("muffleMessage")
[17:02:54.086]                       }
[17:02:54.086]                       else if (inherits(cond, "warning")) {
[17:02:54.086]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.086]                         if (muffled) 
[17:02:54.086]                           invokeRestart("muffleWarning")
[17:02:54.086]                       }
[17:02:54.086]                       else if (inherits(cond, "condition")) {
[17:02:54.086]                         if (!is.null(pattern)) {
[17:02:54.086]                           computeRestarts <- base::computeRestarts
[17:02:54.086]                           grepl <- base::grepl
[17:02:54.086]                           restarts <- computeRestarts(cond)
[17:02:54.086]                           for (restart in restarts) {
[17:02:54.086]                             name <- restart$name
[17:02:54.086]                             if (is.null(name)) 
[17:02:54.086]                               next
[17:02:54.086]                             if (!grepl(pattern, name)) 
[17:02:54.086]                               next
[17:02:54.086]                             invokeRestart(restart)
[17:02:54.086]                             muffled <- TRUE
[17:02:54.086]                             break
[17:02:54.086]                           }
[17:02:54.086]                         }
[17:02:54.086]                       }
[17:02:54.086]                       invisible(muffled)
[17:02:54.086]                     }
[17:02:54.086]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.086]                   }
[17:02:54.086]                 }
[17:02:54.086]                 else {
[17:02:54.086]                   if (TRUE) {
[17:02:54.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.086]                     {
[17:02:54.086]                       inherits <- base::inherits
[17:02:54.086]                       invokeRestart <- base::invokeRestart
[17:02:54.086]                       is.null <- base::is.null
[17:02:54.086]                       muffled <- FALSE
[17:02:54.086]                       if (inherits(cond, "message")) {
[17:02:54.086]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.086]                         if (muffled) 
[17:02:54.086]                           invokeRestart("muffleMessage")
[17:02:54.086]                       }
[17:02:54.086]                       else if (inherits(cond, "warning")) {
[17:02:54.086]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.086]                         if (muffled) 
[17:02:54.086]                           invokeRestart("muffleWarning")
[17:02:54.086]                       }
[17:02:54.086]                       else if (inherits(cond, "condition")) {
[17:02:54.086]                         if (!is.null(pattern)) {
[17:02:54.086]                           computeRestarts <- base::computeRestarts
[17:02:54.086]                           grepl <- base::grepl
[17:02:54.086]                           restarts <- computeRestarts(cond)
[17:02:54.086]                           for (restart in restarts) {
[17:02:54.086]                             name <- restart$name
[17:02:54.086]                             if (is.null(name)) 
[17:02:54.086]                               next
[17:02:54.086]                             if (!grepl(pattern, name)) 
[17:02:54.086]                               next
[17:02:54.086]                             invokeRestart(restart)
[17:02:54.086]                             muffled <- TRUE
[17:02:54.086]                             break
[17:02:54.086]                           }
[17:02:54.086]                         }
[17:02:54.086]                       }
[17:02:54.086]                       invisible(muffled)
[17:02:54.086]                     }
[17:02:54.086]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.086]                   }
[17:02:54.086]                 }
[17:02:54.086]             }
[17:02:54.086]         }))
[17:02:54.086]     }, error = function(ex) {
[17:02:54.086]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.086]                 ...future.rng), started = ...future.startTime, 
[17:02:54.086]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.086]             version = "1.8"), class = "FutureResult")
[17:02:54.086]     }, finally = {
[17:02:54.086]         if (!identical(...future.workdir, getwd())) 
[17:02:54.086]             setwd(...future.workdir)
[17:02:54.086]         {
[17:02:54.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.086]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.086]             }
[17:02:54.086]             base::options(...future.oldOptions)
[17:02:54.086]             if (.Platform$OS.type == "windows") {
[17:02:54.086]                 old_names <- names(...future.oldEnvVars)
[17:02:54.086]                 envs <- base::Sys.getenv()
[17:02:54.086]                 names <- names(envs)
[17:02:54.086]                 common <- intersect(names, old_names)
[17:02:54.086]                 added <- setdiff(names, old_names)
[17:02:54.086]                 removed <- setdiff(old_names, names)
[17:02:54.086]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.086]                   envs[common]]
[17:02:54.086]                 NAMES <- toupper(changed)
[17:02:54.086]                 args <- list()
[17:02:54.086]                 for (kk in seq_along(NAMES)) {
[17:02:54.086]                   name <- changed[[kk]]
[17:02:54.086]                   NAME <- NAMES[[kk]]
[17:02:54.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.086]                     next
[17:02:54.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.086]                 }
[17:02:54.086]                 NAMES <- toupper(added)
[17:02:54.086]                 for (kk in seq_along(NAMES)) {
[17:02:54.086]                   name <- added[[kk]]
[17:02:54.086]                   NAME <- NAMES[[kk]]
[17:02:54.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.086]                     next
[17:02:54.086]                   args[[name]] <- ""
[17:02:54.086]                 }
[17:02:54.086]                 NAMES <- toupper(removed)
[17:02:54.086]                 for (kk in seq_along(NAMES)) {
[17:02:54.086]                   name <- removed[[kk]]
[17:02:54.086]                   NAME <- NAMES[[kk]]
[17:02:54.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.086]                     next
[17:02:54.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.086]                 }
[17:02:54.086]                 if (length(args) > 0) 
[17:02:54.086]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.086]             }
[17:02:54.086]             else {
[17:02:54.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.086]             }
[17:02:54.086]             {
[17:02:54.086]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.086]                   0L) {
[17:02:54.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.086]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.086]                   base::options(opts)
[17:02:54.086]                 }
[17:02:54.086]                 {
[17:02:54.086]                   {
[17:02:54.086]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.086]                     NULL
[17:02:54.086]                   }
[17:02:54.086]                   options(future.plan = NULL)
[17:02:54.086]                   if (is.na(NA_character_)) 
[17:02:54.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.086]                     .init = FALSE)
[17:02:54.086]                 }
[17:02:54.086]             }
[17:02:54.086]         }
[17:02:54.086]     })
[17:02:54.086]     if (TRUE) {
[17:02:54.086]         base::sink(type = "output", split = FALSE)
[17:02:54.086]         if (TRUE) {
[17:02:54.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.086]         }
[17:02:54.086]         else {
[17:02:54.086]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.086]         }
[17:02:54.086]         base::close(...future.stdout)
[17:02:54.086]         ...future.stdout <- NULL
[17:02:54.086]     }
[17:02:54.086]     ...future.result$conditions <- ...future.conditions
[17:02:54.086]     ...future.result$finished <- base::Sys.time()
[17:02:54.086]     ...future.result
[17:02:54.086] }
[17:02:54.089] MultisessionFuture started
[17:02:54.089] - Launch lazy future ... done
[17:02:54.089] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.089] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.090] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.091] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:54.091] Searching for globals ... DONE
[17:02:54.091] Resolving globals: TRUE
[17:02:54.091] Resolving any globals that are futures ...
[17:02:54.091] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:54.091] Resolving any globals that are futures ... DONE
[17:02:54.091] Resolving futures part of globals (recursively) ...
[17:02:54.092] resolve() on list ...
[17:02:54.092]  recursive: 99
[17:02:54.092]  length: 1
[17:02:54.092]  elements: ‘a’
[17:02:54.134] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.134] - Validating connection of MultisessionFuture
[17:02:54.134] - received message: FutureResult
[17:02:54.134] - Received FutureResult
[17:02:54.134] - Erased future from FutureRegistry
[17:02:54.134] result() for ClusterFuture ...
[17:02:54.134] - result already collected: FutureResult
[17:02:54.135] result() for ClusterFuture ... done
[17:02:54.135] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.135] Future #1
[17:02:54.135] result() for ClusterFuture ...
[17:02:54.135] - result already collected: FutureResult
[17:02:54.135] result() for ClusterFuture ... done
[17:02:54.135] result() for ClusterFuture ...
[17:02:54.135] - result already collected: FutureResult
[17:02:54.135] result() for ClusterFuture ... done
[17:02:54.135] A MultisessionFuture was resolved
[17:02:54.136]  length: 0 (resolved future 1)
[17:02:54.136] resolve() on list ... DONE
[17:02:54.136] - globals: [1] ‘a’
[17:02:54.136] Resolving futures part of globals (recursively) ... DONE
[17:02:54.137] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:02:54.137] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:02:54.137] - globals: [1] ‘a’
[17:02:54.137] - packages: [1] ‘future’
[17:02:54.137] getGlobalsAndPackages() ... DONE
[17:02:54.138] run() for ‘Future’ ...
[17:02:54.138] - state: ‘created’
[17:02:54.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.153]   - Field: ‘node’
[17:02:54.153]   - Field: ‘label’
[17:02:54.154]   - Field: ‘local’
[17:02:54.154]   - Field: ‘owner’
[17:02:54.154]   - Field: ‘envir’
[17:02:54.154]   - Field: ‘workers’
[17:02:54.154]   - Field: ‘packages’
[17:02:54.154]   - Field: ‘gc’
[17:02:54.154]   - Field: ‘conditions’
[17:02:54.154]   - Field: ‘persistent’
[17:02:54.154]   - Field: ‘expr’
[17:02:54.154]   - Field: ‘uuid’
[17:02:54.154]   - Field: ‘seed’
[17:02:54.155]   - Field: ‘version’
[17:02:54.155]   - Field: ‘result’
[17:02:54.155]   - Field: ‘asynchronous’
[17:02:54.155]   - Field: ‘calls’
[17:02:54.155]   - Field: ‘globals’
[17:02:54.155]   - Field: ‘stdout’
[17:02:54.155]   - Field: ‘earlySignal’
[17:02:54.155]   - Field: ‘lazy’
[17:02:54.155]   - Field: ‘state’
[17:02:54.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.155] - Launch lazy future ...
[17:02:54.156] Packages needed by the future expression (n = 1): ‘future’
[17:02:54.156] Packages needed by future strategies (n = 0): <none>
[17:02:54.156] {
[17:02:54.156]     {
[17:02:54.156]         {
[17:02:54.156]             ...future.startTime <- base::Sys.time()
[17:02:54.156]             {
[17:02:54.156]                 {
[17:02:54.156]                   {
[17:02:54.156]                     {
[17:02:54.156]                       {
[17:02:54.156]                         base::local({
[17:02:54.156]                           has_future <- base::requireNamespace("future", 
[17:02:54.156]                             quietly = TRUE)
[17:02:54.156]                           if (has_future) {
[17:02:54.156]                             ns <- base::getNamespace("future")
[17:02:54.156]                             version <- ns[[".package"]][["version"]]
[17:02:54.156]                             if (is.null(version)) 
[17:02:54.156]                               version <- utils::packageVersion("future")
[17:02:54.156]                           }
[17:02:54.156]                           else {
[17:02:54.156]                             version <- NULL
[17:02:54.156]                           }
[17:02:54.156]                           if (!has_future || version < "1.8.0") {
[17:02:54.156]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.156]                               "", base::R.version$version.string), 
[17:02:54.156]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:54.156]                                 base::R.version$platform, 8 * 
[17:02:54.156]                                   base::.Machine$sizeof.pointer), 
[17:02:54.156]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.156]                                 "release", "version")], collapse = " "), 
[17:02:54.156]                               hostname = base::Sys.info()[["nodename"]])
[17:02:54.156]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.156]                               info)
[17:02:54.156]                             info <- base::paste(info, collapse = "; ")
[17:02:54.156]                             if (!has_future) {
[17:02:54.156]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.156]                                 info)
[17:02:54.156]                             }
[17:02:54.156]                             else {
[17:02:54.156]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.156]                                 info, version)
[17:02:54.156]                             }
[17:02:54.156]                             base::stop(msg)
[17:02:54.156]                           }
[17:02:54.156]                         })
[17:02:54.156]                       }
[17:02:54.156]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.156]                       base::options(mc.cores = 1L)
[17:02:54.156]                     }
[17:02:54.156]                     base::local({
[17:02:54.156]                       for (pkg in "future") {
[17:02:54.156]                         base::loadNamespace(pkg)
[17:02:54.156]                         base::library(pkg, character.only = TRUE)
[17:02:54.156]                       }
[17:02:54.156]                     })
[17:02:54.156]                   }
[17:02:54.156]                   ...future.strategy.old <- future::plan("list")
[17:02:54.156]                   options(future.plan = NULL)
[17:02:54.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.156]                 }
[17:02:54.156]                 ...future.workdir <- getwd()
[17:02:54.156]             }
[17:02:54.156]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.156]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.156]         }
[17:02:54.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.156]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.156]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.156]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.156]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.156]             base::names(...future.oldOptions))
[17:02:54.156]     }
[17:02:54.156]     if (FALSE) {
[17:02:54.156]     }
[17:02:54.156]     else {
[17:02:54.156]         if (TRUE) {
[17:02:54.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.156]                 open = "w")
[17:02:54.156]         }
[17:02:54.156]         else {
[17:02:54.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.156]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.156]         }
[17:02:54.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.156]             base::sink(type = "output", split = FALSE)
[17:02:54.156]             base::close(...future.stdout)
[17:02:54.156]         }, add = TRUE)
[17:02:54.156]     }
[17:02:54.156]     ...future.frame <- base::sys.nframe()
[17:02:54.156]     ...future.conditions <- base::list()
[17:02:54.156]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.156]     if (FALSE) {
[17:02:54.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.156]     }
[17:02:54.156]     ...future.result <- base::tryCatch({
[17:02:54.156]         base::withCallingHandlers({
[17:02:54.156]             ...future.value <- base::withVisible(base::local({
[17:02:54.156]                 ...future.makeSendCondition <- base::local({
[17:02:54.156]                   sendCondition <- NULL
[17:02:54.156]                   function(frame = 1L) {
[17:02:54.156]                     if (is.function(sendCondition)) 
[17:02:54.156]                       return(sendCondition)
[17:02:54.156]                     ns <- getNamespace("parallel")
[17:02:54.156]                     if (exists("sendData", mode = "function", 
[17:02:54.156]                       envir = ns)) {
[17:02:54.156]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.156]                         envir = ns)
[17:02:54.156]                       envir <- sys.frame(frame)
[17:02:54.156]                       master <- NULL
[17:02:54.156]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.156]                         !identical(envir, emptyenv())) {
[17:02:54.156]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.156]                           inherits = FALSE)) {
[17:02:54.156]                           master <- get("master", mode = "list", 
[17:02:54.156]                             envir = envir, inherits = FALSE)
[17:02:54.156]                           if (inherits(master, c("SOCKnode", 
[17:02:54.156]                             "SOCK0node"))) {
[17:02:54.156]                             sendCondition <<- function(cond) {
[17:02:54.156]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.156]                                 success = TRUE)
[17:02:54.156]                               parallel_sendData(master, data)
[17:02:54.156]                             }
[17:02:54.156]                             return(sendCondition)
[17:02:54.156]                           }
[17:02:54.156]                         }
[17:02:54.156]                         frame <- frame + 1L
[17:02:54.156]                         envir <- sys.frame(frame)
[17:02:54.156]                       }
[17:02:54.156]                     }
[17:02:54.156]                     sendCondition <<- function(cond) NULL
[17:02:54.156]                   }
[17:02:54.156]                 })
[17:02:54.156]                 withCallingHandlers({
[17:02:54.156]                   value(a) + 1
[17:02:54.156]                 }, immediateCondition = function(cond) {
[17:02:54.156]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.156]                   sendCondition(cond)
[17:02:54.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.156]                   {
[17:02:54.156]                     inherits <- base::inherits
[17:02:54.156]                     invokeRestart <- base::invokeRestart
[17:02:54.156]                     is.null <- base::is.null
[17:02:54.156]                     muffled <- FALSE
[17:02:54.156]                     if (inherits(cond, "message")) {
[17:02:54.156]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.156]                       if (muffled) 
[17:02:54.156]                         invokeRestart("muffleMessage")
[17:02:54.156]                     }
[17:02:54.156]                     else if (inherits(cond, "warning")) {
[17:02:54.156]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.156]                       if (muffled) 
[17:02:54.156]                         invokeRestart("muffleWarning")
[17:02:54.156]                     }
[17:02:54.156]                     else if (inherits(cond, "condition")) {
[17:02:54.156]                       if (!is.null(pattern)) {
[17:02:54.156]                         computeRestarts <- base::computeRestarts
[17:02:54.156]                         grepl <- base::grepl
[17:02:54.156]                         restarts <- computeRestarts(cond)
[17:02:54.156]                         for (restart in restarts) {
[17:02:54.156]                           name <- restart$name
[17:02:54.156]                           if (is.null(name)) 
[17:02:54.156]                             next
[17:02:54.156]                           if (!grepl(pattern, name)) 
[17:02:54.156]                             next
[17:02:54.156]                           invokeRestart(restart)
[17:02:54.156]                           muffled <- TRUE
[17:02:54.156]                           break
[17:02:54.156]                         }
[17:02:54.156]                       }
[17:02:54.156]                     }
[17:02:54.156]                     invisible(muffled)
[17:02:54.156]                   }
[17:02:54.156]                   muffleCondition(cond)
[17:02:54.156]                 })
[17:02:54.156]             }))
[17:02:54.156]             future::FutureResult(value = ...future.value$value, 
[17:02:54.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.156]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.156]                     ...future.globalenv.names))
[17:02:54.156]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.156]         }, condition = base::local({
[17:02:54.156]             c <- base::c
[17:02:54.156]             inherits <- base::inherits
[17:02:54.156]             invokeRestart <- base::invokeRestart
[17:02:54.156]             length <- base::length
[17:02:54.156]             list <- base::list
[17:02:54.156]             seq.int <- base::seq.int
[17:02:54.156]             signalCondition <- base::signalCondition
[17:02:54.156]             sys.calls <- base::sys.calls
[17:02:54.156]             `[[` <- base::`[[`
[17:02:54.156]             `+` <- base::`+`
[17:02:54.156]             `<<-` <- base::`<<-`
[17:02:54.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.156]                   3L)]
[17:02:54.156]             }
[17:02:54.156]             function(cond) {
[17:02:54.156]                 is_error <- inherits(cond, "error")
[17:02:54.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.156]                   NULL)
[17:02:54.156]                 if (is_error) {
[17:02:54.156]                   sessionInformation <- function() {
[17:02:54.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.156]                       search = base::search(), system = base::Sys.info())
[17:02:54.156]                   }
[17:02:54.156]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.156]                     cond$call), session = sessionInformation(), 
[17:02:54.156]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.156]                   signalCondition(cond)
[17:02:54.156]                 }
[17:02:54.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.156]                 "immediateCondition"))) {
[17:02:54.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.156]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.156]                   if (TRUE && !signal) {
[17:02:54.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.156]                     {
[17:02:54.156]                       inherits <- base::inherits
[17:02:54.156]                       invokeRestart <- base::invokeRestart
[17:02:54.156]                       is.null <- base::is.null
[17:02:54.156]                       muffled <- FALSE
[17:02:54.156]                       if (inherits(cond, "message")) {
[17:02:54.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.156]                         if (muffled) 
[17:02:54.156]                           invokeRestart("muffleMessage")
[17:02:54.156]                       }
[17:02:54.156]                       else if (inherits(cond, "warning")) {
[17:02:54.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.156]                         if (muffled) 
[17:02:54.156]                           invokeRestart("muffleWarning")
[17:02:54.156]                       }
[17:02:54.156]                       else if (inherits(cond, "condition")) {
[17:02:54.156]                         if (!is.null(pattern)) {
[17:02:54.156]                           computeRestarts <- base::computeRestarts
[17:02:54.156]                           grepl <- base::grepl
[17:02:54.156]                           restarts <- computeRestarts(cond)
[17:02:54.156]                           for (restart in restarts) {
[17:02:54.156]                             name <- restart$name
[17:02:54.156]                             if (is.null(name)) 
[17:02:54.156]                               next
[17:02:54.156]                             if (!grepl(pattern, name)) 
[17:02:54.156]                               next
[17:02:54.156]                             invokeRestart(restart)
[17:02:54.156]                             muffled <- TRUE
[17:02:54.156]                             break
[17:02:54.156]                           }
[17:02:54.156]                         }
[17:02:54.156]                       }
[17:02:54.156]                       invisible(muffled)
[17:02:54.156]                     }
[17:02:54.156]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.156]                   }
[17:02:54.156]                 }
[17:02:54.156]                 else {
[17:02:54.156]                   if (TRUE) {
[17:02:54.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.156]                     {
[17:02:54.156]                       inherits <- base::inherits
[17:02:54.156]                       invokeRestart <- base::invokeRestart
[17:02:54.156]                       is.null <- base::is.null
[17:02:54.156]                       muffled <- FALSE
[17:02:54.156]                       if (inherits(cond, "message")) {
[17:02:54.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.156]                         if (muffled) 
[17:02:54.156]                           invokeRestart("muffleMessage")
[17:02:54.156]                       }
[17:02:54.156]                       else if (inherits(cond, "warning")) {
[17:02:54.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.156]                         if (muffled) 
[17:02:54.156]                           invokeRestart("muffleWarning")
[17:02:54.156]                       }
[17:02:54.156]                       else if (inherits(cond, "condition")) {
[17:02:54.156]                         if (!is.null(pattern)) {
[17:02:54.156]                           computeRestarts <- base::computeRestarts
[17:02:54.156]                           grepl <- base::grepl
[17:02:54.156]                           restarts <- computeRestarts(cond)
[17:02:54.156]                           for (restart in restarts) {
[17:02:54.156]                             name <- restart$name
[17:02:54.156]                             if (is.null(name)) 
[17:02:54.156]                               next
[17:02:54.156]                             if (!grepl(pattern, name)) 
[17:02:54.156]                               next
[17:02:54.156]                             invokeRestart(restart)
[17:02:54.156]                             muffled <- TRUE
[17:02:54.156]                             break
[17:02:54.156]                           }
[17:02:54.156]                         }
[17:02:54.156]                       }
[17:02:54.156]                       invisible(muffled)
[17:02:54.156]                     }
[17:02:54.156]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.156]                   }
[17:02:54.156]                 }
[17:02:54.156]             }
[17:02:54.156]         }))
[17:02:54.156]     }, error = function(ex) {
[17:02:54.156]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.156]                 ...future.rng), started = ...future.startTime, 
[17:02:54.156]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.156]             version = "1.8"), class = "FutureResult")
[17:02:54.156]     }, finally = {
[17:02:54.156]         if (!identical(...future.workdir, getwd())) 
[17:02:54.156]             setwd(...future.workdir)
[17:02:54.156]         {
[17:02:54.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.156]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.156]             }
[17:02:54.156]             base::options(...future.oldOptions)
[17:02:54.156]             if (.Platform$OS.type == "windows") {
[17:02:54.156]                 old_names <- names(...future.oldEnvVars)
[17:02:54.156]                 envs <- base::Sys.getenv()
[17:02:54.156]                 names <- names(envs)
[17:02:54.156]                 common <- intersect(names, old_names)
[17:02:54.156]                 added <- setdiff(names, old_names)
[17:02:54.156]                 removed <- setdiff(old_names, names)
[17:02:54.156]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.156]                   envs[common]]
[17:02:54.156]                 NAMES <- toupper(changed)
[17:02:54.156]                 args <- list()
[17:02:54.156]                 for (kk in seq_along(NAMES)) {
[17:02:54.156]                   name <- changed[[kk]]
[17:02:54.156]                   NAME <- NAMES[[kk]]
[17:02:54.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.156]                     next
[17:02:54.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.156]                 }
[17:02:54.156]                 NAMES <- toupper(added)
[17:02:54.156]                 for (kk in seq_along(NAMES)) {
[17:02:54.156]                   name <- added[[kk]]
[17:02:54.156]                   NAME <- NAMES[[kk]]
[17:02:54.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.156]                     next
[17:02:54.156]                   args[[name]] <- ""
[17:02:54.156]                 }
[17:02:54.156]                 NAMES <- toupper(removed)
[17:02:54.156]                 for (kk in seq_along(NAMES)) {
[17:02:54.156]                   name <- removed[[kk]]
[17:02:54.156]                   NAME <- NAMES[[kk]]
[17:02:54.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.156]                     next
[17:02:54.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.156]                 }
[17:02:54.156]                 if (length(args) > 0) 
[17:02:54.156]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.156]             }
[17:02:54.156]             else {
[17:02:54.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.156]             }
[17:02:54.156]             {
[17:02:54.156]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.156]                   0L) {
[17:02:54.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.156]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.156]                   base::options(opts)
[17:02:54.156]                 }
[17:02:54.156]                 {
[17:02:54.156]                   {
[17:02:54.156]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.156]                     NULL
[17:02:54.156]                   }
[17:02:54.156]                   options(future.plan = NULL)
[17:02:54.156]                   if (is.na(NA_character_)) 
[17:02:54.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.156]                     .init = FALSE)
[17:02:54.156]                 }
[17:02:54.156]             }
[17:02:54.156]         }
[17:02:54.156]     })
[17:02:54.156]     if (TRUE) {
[17:02:54.156]         base::sink(type = "output", split = FALSE)
[17:02:54.156]         if (TRUE) {
[17:02:54.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.156]         }
[17:02:54.156]         else {
[17:02:54.156]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.156]         }
[17:02:54.156]         base::close(...future.stdout)
[17:02:54.156]         ...future.stdout <- NULL
[17:02:54.156]     }
[17:02:54.156]     ...future.result$conditions <- ...future.conditions
[17:02:54.156]     ...future.result$finished <- base::Sys.time()
[17:02:54.156]     ...future.result
[17:02:54.156] }
[17:02:54.159] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:02:54.160] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:02:54.212] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:02:54.212] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:02:54.213] MultisessionFuture started
[17:02:54.213] - Launch lazy future ... done
[17:02:54.213] run() for ‘MultisessionFuture’ ... done
[17:02:54.213] result() for ClusterFuture ...
[17:02:54.213] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.213] - Validating connection of MultisessionFuture
[17:02:54.258] - received message: FutureResult
[17:02:54.258] - Received FutureResult
[17:02:54.258] - Erased future from FutureRegistry
[17:02:54.258] result() for ClusterFuture ...
[17:02:54.258] - result already collected: FutureResult
[17:02:54.258] result() for ClusterFuture ... done
[17:02:54.258] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.259] result() for ClusterFuture ... done
[17:02:54.259] result() for ClusterFuture ...
[17:02:54.259] - result already collected: FutureResult
[17:02:54.259] result() for ClusterFuture ... done
value(b) = 2
[17:02:54.259] result() for ClusterFuture ...
[17:02:54.259] - result already collected: FutureResult
[17:02:54.259] result() for ClusterFuture ... done
[17:02:54.259] result() for ClusterFuture ...
[17:02:54.259] - result already collected: FutureResult
[17:02:54.259] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.260] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.260] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.261] 
[17:02:54.261] Searching for globals ... DONE
[17:02:54.261] - globals: [0] <none>
[17:02:54.261] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.261] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.261] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.262] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:54.262] Searching for globals ... DONE
[17:02:54.262] Resolving globals: TRUE
[17:02:54.263] Resolving any globals that are futures ...
[17:02:54.263] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:54.263] Resolving any globals that are futures ... DONE
[17:02:54.263] Resolving futures part of globals (recursively) ...
[17:02:54.263] resolve() on list ...
[17:02:54.263]  recursive: 99
[17:02:54.263]  length: 1
[17:02:54.264]  elements: ‘a’
[17:02:54.264] run() for ‘Future’ ...
[17:02:54.264] - state: ‘created’
[17:02:54.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.278]   - Field: ‘node’
[17:02:54.278]   - Field: ‘label’
[17:02:54.278]   - Field: ‘local’
[17:02:54.278]   - Field: ‘owner’
[17:02:54.278]   - Field: ‘envir’
[17:02:54.279]   - Field: ‘workers’
[17:02:54.279]   - Field: ‘packages’
[17:02:54.279]   - Field: ‘gc’
[17:02:54.279]   - Field: ‘conditions’
[17:02:54.279]   - Field: ‘persistent’
[17:02:54.279]   - Field: ‘expr’
[17:02:54.279]   - Field: ‘uuid’
[17:02:54.279]   - Field: ‘seed’
[17:02:54.279]   - Field: ‘version’
[17:02:54.279]   - Field: ‘result’
[17:02:54.280]   - Field: ‘asynchronous’
[17:02:54.280]   - Field: ‘calls’
[17:02:54.280]   - Field: ‘globals’
[17:02:54.280]   - Field: ‘stdout’
[17:02:54.280]   - Field: ‘earlySignal’
[17:02:54.280]   - Field: ‘lazy’
[17:02:54.280]   - Field: ‘state’
[17:02:54.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.280] - Launch lazy future ...
[17:02:54.281] Packages needed by the future expression (n = 0): <none>
[17:02:54.281] Packages needed by future strategies (n = 0): <none>
[17:02:54.281] {
[17:02:54.281]     {
[17:02:54.281]         {
[17:02:54.281]             ...future.startTime <- base::Sys.time()
[17:02:54.281]             {
[17:02:54.281]                 {
[17:02:54.281]                   {
[17:02:54.281]                     {
[17:02:54.281]                       base::local({
[17:02:54.281]                         has_future <- base::requireNamespace("future", 
[17:02:54.281]                           quietly = TRUE)
[17:02:54.281]                         if (has_future) {
[17:02:54.281]                           ns <- base::getNamespace("future")
[17:02:54.281]                           version <- ns[[".package"]][["version"]]
[17:02:54.281]                           if (is.null(version)) 
[17:02:54.281]                             version <- utils::packageVersion("future")
[17:02:54.281]                         }
[17:02:54.281]                         else {
[17:02:54.281]                           version <- NULL
[17:02:54.281]                         }
[17:02:54.281]                         if (!has_future || version < "1.8.0") {
[17:02:54.281]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.281]                             "", base::R.version$version.string), 
[17:02:54.281]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.281]                               "release", "version")], collapse = " "), 
[17:02:54.281]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.281]                             info)
[17:02:54.281]                           info <- base::paste(info, collapse = "; ")
[17:02:54.281]                           if (!has_future) {
[17:02:54.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.281]                               info)
[17:02:54.281]                           }
[17:02:54.281]                           else {
[17:02:54.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.281]                               info, version)
[17:02:54.281]                           }
[17:02:54.281]                           base::stop(msg)
[17:02:54.281]                         }
[17:02:54.281]                       })
[17:02:54.281]                     }
[17:02:54.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.281]                     base::options(mc.cores = 1L)
[17:02:54.281]                   }
[17:02:54.281]                   ...future.strategy.old <- future::plan("list")
[17:02:54.281]                   options(future.plan = NULL)
[17:02:54.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.281]                 }
[17:02:54.281]                 ...future.workdir <- getwd()
[17:02:54.281]             }
[17:02:54.281]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.281]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.281]         }
[17:02:54.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.281]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.281]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.281]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.281]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.281]             base::names(...future.oldOptions))
[17:02:54.281]     }
[17:02:54.281]     if (FALSE) {
[17:02:54.281]     }
[17:02:54.281]     else {
[17:02:54.281]         if (TRUE) {
[17:02:54.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.281]                 open = "w")
[17:02:54.281]         }
[17:02:54.281]         else {
[17:02:54.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.281]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.281]         }
[17:02:54.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.281]             base::sink(type = "output", split = FALSE)
[17:02:54.281]             base::close(...future.stdout)
[17:02:54.281]         }, add = TRUE)
[17:02:54.281]     }
[17:02:54.281]     ...future.frame <- base::sys.nframe()
[17:02:54.281]     ...future.conditions <- base::list()
[17:02:54.281]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.281]     if (FALSE) {
[17:02:54.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.281]     }
[17:02:54.281]     ...future.result <- base::tryCatch({
[17:02:54.281]         base::withCallingHandlers({
[17:02:54.281]             ...future.value <- base::withVisible(base::local({
[17:02:54.281]                 ...future.makeSendCondition <- base::local({
[17:02:54.281]                   sendCondition <- NULL
[17:02:54.281]                   function(frame = 1L) {
[17:02:54.281]                     if (is.function(sendCondition)) 
[17:02:54.281]                       return(sendCondition)
[17:02:54.281]                     ns <- getNamespace("parallel")
[17:02:54.281]                     if (exists("sendData", mode = "function", 
[17:02:54.281]                       envir = ns)) {
[17:02:54.281]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.281]                         envir = ns)
[17:02:54.281]                       envir <- sys.frame(frame)
[17:02:54.281]                       master <- NULL
[17:02:54.281]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.281]                         !identical(envir, emptyenv())) {
[17:02:54.281]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.281]                           inherits = FALSE)) {
[17:02:54.281]                           master <- get("master", mode = "list", 
[17:02:54.281]                             envir = envir, inherits = FALSE)
[17:02:54.281]                           if (inherits(master, c("SOCKnode", 
[17:02:54.281]                             "SOCK0node"))) {
[17:02:54.281]                             sendCondition <<- function(cond) {
[17:02:54.281]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.281]                                 success = TRUE)
[17:02:54.281]                               parallel_sendData(master, data)
[17:02:54.281]                             }
[17:02:54.281]                             return(sendCondition)
[17:02:54.281]                           }
[17:02:54.281]                         }
[17:02:54.281]                         frame <- frame + 1L
[17:02:54.281]                         envir <- sys.frame(frame)
[17:02:54.281]                       }
[17:02:54.281]                     }
[17:02:54.281]                     sendCondition <<- function(cond) NULL
[17:02:54.281]                   }
[17:02:54.281]                 })
[17:02:54.281]                 withCallingHandlers({
[17:02:54.281]                   1
[17:02:54.281]                 }, immediateCondition = function(cond) {
[17:02:54.281]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.281]                   sendCondition(cond)
[17:02:54.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.281]                   {
[17:02:54.281]                     inherits <- base::inherits
[17:02:54.281]                     invokeRestart <- base::invokeRestart
[17:02:54.281]                     is.null <- base::is.null
[17:02:54.281]                     muffled <- FALSE
[17:02:54.281]                     if (inherits(cond, "message")) {
[17:02:54.281]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.281]                       if (muffled) 
[17:02:54.281]                         invokeRestart("muffleMessage")
[17:02:54.281]                     }
[17:02:54.281]                     else if (inherits(cond, "warning")) {
[17:02:54.281]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.281]                       if (muffled) 
[17:02:54.281]                         invokeRestart("muffleWarning")
[17:02:54.281]                     }
[17:02:54.281]                     else if (inherits(cond, "condition")) {
[17:02:54.281]                       if (!is.null(pattern)) {
[17:02:54.281]                         computeRestarts <- base::computeRestarts
[17:02:54.281]                         grepl <- base::grepl
[17:02:54.281]                         restarts <- computeRestarts(cond)
[17:02:54.281]                         for (restart in restarts) {
[17:02:54.281]                           name <- restart$name
[17:02:54.281]                           if (is.null(name)) 
[17:02:54.281]                             next
[17:02:54.281]                           if (!grepl(pattern, name)) 
[17:02:54.281]                             next
[17:02:54.281]                           invokeRestart(restart)
[17:02:54.281]                           muffled <- TRUE
[17:02:54.281]                           break
[17:02:54.281]                         }
[17:02:54.281]                       }
[17:02:54.281]                     }
[17:02:54.281]                     invisible(muffled)
[17:02:54.281]                   }
[17:02:54.281]                   muffleCondition(cond)
[17:02:54.281]                 })
[17:02:54.281]             }))
[17:02:54.281]             future::FutureResult(value = ...future.value$value, 
[17:02:54.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.281]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.281]                     ...future.globalenv.names))
[17:02:54.281]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.281]         }, condition = base::local({
[17:02:54.281]             c <- base::c
[17:02:54.281]             inherits <- base::inherits
[17:02:54.281]             invokeRestart <- base::invokeRestart
[17:02:54.281]             length <- base::length
[17:02:54.281]             list <- base::list
[17:02:54.281]             seq.int <- base::seq.int
[17:02:54.281]             signalCondition <- base::signalCondition
[17:02:54.281]             sys.calls <- base::sys.calls
[17:02:54.281]             `[[` <- base::`[[`
[17:02:54.281]             `+` <- base::`+`
[17:02:54.281]             `<<-` <- base::`<<-`
[17:02:54.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.281]                   3L)]
[17:02:54.281]             }
[17:02:54.281]             function(cond) {
[17:02:54.281]                 is_error <- inherits(cond, "error")
[17:02:54.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.281]                   NULL)
[17:02:54.281]                 if (is_error) {
[17:02:54.281]                   sessionInformation <- function() {
[17:02:54.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.281]                       search = base::search(), system = base::Sys.info())
[17:02:54.281]                   }
[17:02:54.281]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.281]                     cond$call), session = sessionInformation(), 
[17:02:54.281]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.281]                   signalCondition(cond)
[17:02:54.281]                 }
[17:02:54.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.281]                 "immediateCondition"))) {
[17:02:54.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.281]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.281]                   if (TRUE && !signal) {
[17:02:54.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.281]                     {
[17:02:54.281]                       inherits <- base::inherits
[17:02:54.281]                       invokeRestart <- base::invokeRestart
[17:02:54.281]                       is.null <- base::is.null
[17:02:54.281]                       muffled <- FALSE
[17:02:54.281]                       if (inherits(cond, "message")) {
[17:02:54.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.281]                         if (muffled) 
[17:02:54.281]                           invokeRestart("muffleMessage")
[17:02:54.281]                       }
[17:02:54.281]                       else if (inherits(cond, "warning")) {
[17:02:54.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.281]                         if (muffled) 
[17:02:54.281]                           invokeRestart("muffleWarning")
[17:02:54.281]                       }
[17:02:54.281]                       else if (inherits(cond, "condition")) {
[17:02:54.281]                         if (!is.null(pattern)) {
[17:02:54.281]                           computeRestarts <- base::computeRestarts
[17:02:54.281]                           grepl <- base::grepl
[17:02:54.281]                           restarts <- computeRestarts(cond)
[17:02:54.281]                           for (restart in restarts) {
[17:02:54.281]                             name <- restart$name
[17:02:54.281]                             if (is.null(name)) 
[17:02:54.281]                               next
[17:02:54.281]                             if (!grepl(pattern, name)) 
[17:02:54.281]                               next
[17:02:54.281]                             invokeRestart(restart)
[17:02:54.281]                             muffled <- TRUE
[17:02:54.281]                             break
[17:02:54.281]                           }
[17:02:54.281]                         }
[17:02:54.281]                       }
[17:02:54.281]                       invisible(muffled)
[17:02:54.281]                     }
[17:02:54.281]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.281]                   }
[17:02:54.281]                 }
[17:02:54.281]                 else {
[17:02:54.281]                   if (TRUE) {
[17:02:54.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.281]                     {
[17:02:54.281]                       inherits <- base::inherits
[17:02:54.281]                       invokeRestart <- base::invokeRestart
[17:02:54.281]                       is.null <- base::is.null
[17:02:54.281]                       muffled <- FALSE
[17:02:54.281]                       if (inherits(cond, "message")) {
[17:02:54.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.281]                         if (muffled) 
[17:02:54.281]                           invokeRestart("muffleMessage")
[17:02:54.281]                       }
[17:02:54.281]                       else if (inherits(cond, "warning")) {
[17:02:54.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.281]                         if (muffled) 
[17:02:54.281]                           invokeRestart("muffleWarning")
[17:02:54.281]                       }
[17:02:54.281]                       else if (inherits(cond, "condition")) {
[17:02:54.281]                         if (!is.null(pattern)) {
[17:02:54.281]                           computeRestarts <- base::computeRestarts
[17:02:54.281]                           grepl <- base::grepl
[17:02:54.281]                           restarts <- computeRestarts(cond)
[17:02:54.281]                           for (restart in restarts) {
[17:02:54.281]                             name <- restart$name
[17:02:54.281]                             if (is.null(name)) 
[17:02:54.281]                               next
[17:02:54.281]                             if (!grepl(pattern, name)) 
[17:02:54.281]                               next
[17:02:54.281]                             invokeRestart(restart)
[17:02:54.281]                             muffled <- TRUE
[17:02:54.281]                             break
[17:02:54.281]                           }
[17:02:54.281]                         }
[17:02:54.281]                       }
[17:02:54.281]                       invisible(muffled)
[17:02:54.281]                     }
[17:02:54.281]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.281]                   }
[17:02:54.281]                 }
[17:02:54.281]             }
[17:02:54.281]         }))
[17:02:54.281]     }, error = function(ex) {
[17:02:54.281]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.281]                 ...future.rng), started = ...future.startTime, 
[17:02:54.281]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.281]             version = "1.8"), class = "FutureResult")
[17:02:54.281]     }, finally = {
[17:02:54.281]         if (!identical(...future.workdir, getwd())) 
[17:02:54.281]             setwd(...future.workdir)
[17:02:54.281]         {
[17:02:54.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.281]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.281]             }
[17:02:54.281]             base::options(...future.oldOptions)
[17:02:54.281]             if (.Platform$OS.type == "windows") {
[17:02:54.281]                 old_names <- names(...future.oldEnvVars)
[17:02:54.281]                 envs <- base::Sys.getenv()
[17:02:54.281]                 names <- names(envs)
[17:02:54.281]                 common <- intersect(names, old_names)
[17:02:54.281]                 added <- setdiff(names, old_names)
[17:02:54.281]                 removed <- setdiff(old_names, names)
[17:02:54.281]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.281]                   envs[common]]
[17:02:54.281]                 NAMES <- toupper(changed)
[17:02:54.281]                 args <- list()
[17:02:54.281]                 for (kk in seq_along(NAMES)) {
[17:02:54.281]                   name <- changed[[kk]]
[17:02:54.281]                   NAME <- NAMES[[kk]]
[17:02:54.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.281]                     next
[17:02:54.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.281]                 }
[17:02:54.281]                 NAMES <- toupper(added)
[17:02:54.281]                 for (kk in seq_along(NAMES)) {
[17:02:54.281]                   name <- added[[kk]]
[17:02:54.281]                   NAME <- NAMES[[kk]]
[17:02:54.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.281]                     next
[17:02:54.281]                   args[[name]] <- ""
[17:02:54.281]                 }
[17:02:54.281]                 NAMES <- toupper(removed)
[17:02:54.281]                 for (kk in seq_along(NAMES)) {
[17:02:54.281]                   name <- removed[[kk]]
[17:02:54.281]                   NAME <- NAMES[[kk]]
[17:02:54.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.281]                     next
[17:02:54.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.281]                 }
[17:02:54.281]                 if (length(args) > 0) 
[17:02:54.281]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.281]             }
[17:02:54.281]             else {
[17:02:54.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.281]             }
[17:02:54.281]             {
[17:02:54.281]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.281]                   0L) {
[17:02:54.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.281]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.281]                   base::options(opts)
[17:02:54.281]                 }
[17:02:54.281]                 {
[17:02:54.281]                   {
[17:02:54.281]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.281]                     NULL
[17:02:54.281]                   }
[17:02:54.281]                   options(future.plan = NULL)
[17:02:54.281]                   if (is.na(NA_character_)) 
[17:02:54.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.281]                     .init = FALSE)
[17:02:54.281]                 }
[17:02:54.281]             }
[17:02:54.281]         }
[17:02:54.281]     })
[17:02:54.281]     if (TRUE) {
[17:02:54.281]         base::sink(type = "output", split = FALSE)
[17:02:54.281]         if (TRUE) {
[17:02:54.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.281]         }
[17:02:54.281]         else {
[17:02:54.281]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.281]         }
[17:02:54.281]         base::close(...future.stdout)
[17:02:54.281]         ...future.stdout <- NULL
[17:02:54.281]     }
[17:02:54.281]     ...future.result$conditions <- ...future.conditions
[17:02:54.281]     ...future.result$finished <- base::Sys.time()
[17:02:54.281]     ...future.result
[17:02:54.281] }
[17:02:54.284] MultisessionFuture started
[17:02:54.284] - Launch lazy future ... done
[17:02:54.284] run() for ‘MultisessionFuture’ ... done
[17:02:54.329] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.329] - Validating connection of MultisessionFuture
[17:02:54.330] - received message: FutureResult
[17:02:54.330] - Received FutureResult
[17:02:54.330] - Erased future from FutureRegistry
[17:02:54.330] result() for ClusterFuture ...
[17:02:54.330] - result already collected: FutureResult
[17:02:54.330] result() for ClusterFuture ... done
[17:02:54.330] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.330] Future #1
[17:02:54.330] result() for ClusterFuture ...
[17:02:54.331] - result already collected: FutureResult
[17:02:54.331] result() for ClusterFuture ... done
[17:02:54.331] result() for ClusterFuture ...
[17:02:54.331] - result already collected: FutureResult
[17:02:54.331] result() for ClusterFuture ... done
[17:02:54.331] A MultisessionFuture was resolved
[17:02:54.331]  length: 0 (resolved future 1)
[17:02:54.331] resolve() on list ... DONE
[17:02:54.331] - globals: [1] ‘a’
[17:02:54.331] Resolving futures part of globals (recursively) ... DONE
[17:02:54.332] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:02:54.333] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:02:54.333] - globals: [1] ‘a’
[17:02:54.333] - packages: [1] ‘future’
[17:02:54.333] getGlobalsAndPackages() ... DONE
[17:02:54.333] run() for ‘Future’ ...
[17:02:54.333] - state: ‘created’
[17:02:54.334] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.348]   - Field: ‘node’
[17:02:54.348]   - Field: ‘label’
[17:02:54.348]   - Field: ‘local’
[17:02:54.348]   - Field: ‘owner’
[17:02:54.348]   - Field: ‘envir’
[17:02:54.348]   - Field: ‘workers’
[17:02:54.348]   - Field: ‘packages’
[17:02:54.349]   - Field: ‘gc’
[17:02:54.349]   - Field: ‘conditions’
[17:02:54.349]   - Field: ‘persistent’
[17:02:54.349]   - Field: ‘expr’
[17:02:54.349]   - Field: ‘uuid’
[17:02:54.349]   - Field: ‘seed’
[17:02:54.349]   - Field: ‘version’
[17:02:54.349]   - Field: ‘result’
[17:02:54.349]   - Field: ‘asynchronous’
[17:02:54.349]   - Field: ‘calls’
[17:02:54.349]   - Field: ‘globals’
[17:02:54.350]   - Field: ‘stdout’
[17:02:54.350]   - Field: ‘earlySignal’
[17:02:54.350]   - Field: ‘lazy’
[17:02:54.350]   - Field: ‘state’
[17:02:54.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.350] - Launch lazy future ...
[17:02:54.350] Packages needed by the future expression (n = 1): ‘future’
[17:02:54.350] Packages needed by future strategies (n = 0): <none>
[17:02:54.351] {
[17:02:54.351]     {
[17:02:54.351]         {
[17:02:54.351]             ...future.startTime <- base::Sys.time()
[17:02:54.351]             {
[17:02:54.351]                 {
[17:02:54.351]                   {
[17:02:54.351]                     {
[17:02:54.351]                       {
[17:02:54.351]                         base::local({
[17:02:54.351]                           has_future <- base::requireNamespace("future", 
[17:02:54.351]                             quietly = TRUE)
[17:02:54.351]                           if (has_future) {
[17:02:54.351]                             ns <- base::getNamespace("future")
[17:02:54.351]                             version <- ns[[".package"]][["version"]]
[17:02:54.351]                             if (is.null(version)) 
[17:02:54.351]                               version <- utils::packageVersion("future")
[17:02:54.351]                           }
[17:02:54.351]                           else {
[17:02:54.351]                             version <- NULL
[17:02:54.351]                           }
[17:02:54.351]                           if (!has_future || version < "1.8.0") {
[17:02:54.351]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.351]                               "", base::R.version$version.string), 
[17:02:54.351]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:54.351]                                 base::R.version$platform, 8 * 
[17:02:54.351]                                   base::.Machine$sizeof.pointer), 
[17:02:54.351]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.351]                                 "release", "version")], collapse = " "), 
[17:02:54.351]                               hostname = base::Sys.info()[["nodename"]])
[17:02:54.351]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.351]                               info)
[17:02:54.351]                             info <- base::paste(info, collapse = "; ")
[17:02:54.351]                             if (!has_future) {
[17:02:54.351]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.351]                                 info)
[17:02:54.351]                             }
[17:02:54.351]                             else {
[17:02:54.351]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.351]                                 info, version)
[17:02:54.351]                             }
[17:02:54.351]                             base::stop(msg)
[17:02:54.351]                           }
[17:02:54.351]                         })
[17:02:54.351]                       }
[17:02:54.351]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.351]                       base::options(mc.cores = 1L)
[17:02:54.351]                     }
[17:02:54.351]                     base::local({
[17:02:54.351]                       for (pkg in "future") {
[17:02:54.351]                         base::loadNamespace(pkg)
[17:02:54.351]                         base::library(pkg, character.only = TRUE)
[17:02:54.351]                       }
[17:02:54.351]                     })
[17:02:54.351]                   }
[17:02:54.351]                   ...future.strategy.old <- future::plan("list")
[17:02:54.351]                   options(future.plan = NULL)
[17:02:54.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.351]                 }
[17:02:54.351]                 ...future.workdir <- getwd()
[17:02:54.351]             }
[17:02:54.351]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.351]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.351]         }
[17:02:54.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.351]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.351]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.351]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.351]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.351]             base::names(...future.oldOptions))
[17:02:54.351]     }
[17:02:54.351]     if (FALSE) {
[17:02:54.351]     }
[17:02:54.351]     else {
[17:02:54.351]         if (TRUE) {
[17:02:54.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.351]                 open = "w")
[17:02:54.351]         }
[17:02:54.351]         else {
[17:02:54.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.351]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.351]         }
[17:02:54.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.351]             base::sink(type = "output", split = FALSE)
[17:02:54.351]             base::close(...future.stdout)
[17:02:54.351]         }, add = TRUE)
[17:02:54.351]     }
[17:02:54.351]     ...future.frame <- base::sys.nframe()
[17:02:54.351]     ...future.conditions <- base::list()
[17:02:54.351]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.351]     if (FALSE) {
[17:02:54.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.351]     }
[17:02:54.351]     ...future.result <- base::tryCatch({
[17:02:54.351]         base::withCallingHandlers({
[17:02:54.351]             ...future.value <- base::withVisible(base::local({
[17:02:54.351]                 ...future.makeSendCondition <- base::local({
[17:02:54.351]                   sendCondition <- NULL
[17:02:54.351]                   function(frame = 1L) {
[17:02:54.351]                     if (is.function(sendCondition)) 
[17:02:54.351]                       return(sendCondition)
[17:02:54.351]                     ns <- getNamespace("parallel")
[17:02:54.351]                     if (exists("sendData", mode = "function", 
[17:02:54.351]                       envir = ns)) {
[17:02:54.351]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.351]                         envir = ns)
[17:02:54.351]                       envir <- sys.frame(frame)
[17:02:54.351]                       master <- NULL
[17:02:54.351]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.351]                         !identical(envir, emptyenv())) {
[17:02:54.351]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.351]                           inherits = FALSE)) {
[17:02:54.351]                           master <- get("master", mode = "list", 
[17:02:54.351]                             envir = envir, inherits = FALSE)
[17:02:54.351]                           if (inherits(master, c("SOCKnode", 
[17:02:54.351]                             "SOCK0node"))) {
[17:02:54.351]                             sendCondition <<- function(cond) {
[17:02:54.351]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.351]                                 success = TRUE)
[17:02:54.351]                               parallel_sendData(master, data)
[17:02:54.351]                             }
[17:02:54.351]                             return(sendCondition)
[17:02:54.351]                           }
[17:02:54.351]                         }
[17:02:54.351]                         frame <- frame + 1L
[17:02:54.351]                         envir <- sys.frame(frame)
[17:02:54.351]                       }
[17:02:54.351]                     }
[17:02:54.351]                     sendCondition <<- function(cond) NULL
[17:02:54.351]                   }
[17:02:54.351]                 })
[17:02:54.351]                 withCallingHandlers({
[17:02:54.351]                   value(a) + 1
[17:02:54.351]                 }, immediateCondition = function(cond) {
[17:02:54.351]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.351]                   sendCondition(cond)
[17:02:54.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.351]                   {
[17:02:54.351]                     inherits <- base::inherits
[17:02:54.351]                     invokeRestart <- base::invokeRestart
[17:02:54.351]                     is.null <- base::is.null
[17:02:54.351]                     muffled <- FALSE
[17:02:54.351]                     if (inherits(cond, "message")) {
[17:02:54.351]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.351]                       if (muffled) 
[17:02:54.351]                         invokeRestart("muffleMessage")
[17:02:54.351]                     }
[17:02:54.351]                     else if (inherits(cond, "warning")) {
[17:02:54.351]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.351]                       if (muffled) 
[17:02:54.351]                         invokeRestart("muffleWarning")
[17:02:54.351]                     }
[17:02:54.351]                     else if (inherits(cond, "condition")) {
[17:02:54.351]                       if (!is.null(pattern)) {
[17:02:54.351]                         computeRestarts <- base::computeRestarts
[17:02:54.351]                         grepl <- base::grepl
[17:02:54.351]                         restarts <- computeRestarts(cond)
[17:02:54.351]                         for (restart in restarts) {
[17:02:54.351]                           name <- restart$name
[17:02:54.351]                           if (is.null(name)) 
[17:02:54.351]                             next
[17:02:54.351]                           if (!grepl(pattern, name)) 
[17:02:54.351]                             next
[17:02:54.351]                           invokeRestart(restart)
[17:02:54.351]                           muffled <- TRUE
[17:02:54.351]                           break
[17:02:54.351]                         }
[17:02:54.351]                       }
[17:02:54.351]                     }
[17:02:54.351]                     invisible(muffled)
[17:02:54.351]                   }
[17:02:54.351]                   muffleCondition(cond)
[17:02:54.351]                 })
[17:02:54.351]             }))
[17:02:54.351]             future::FutureResult(value = ...future.value$value, 
[17:02:54.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.351]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.351]                     ...future.globalenv.names))
[17:02:54.351]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.351]         }, condition = base::local({
[17:02:54.351]             c <- base::c
[17:02:54.351]             inherits <- base::inherits
[17:02:54.351]             invokeRestart <- base::invokeRestart
[17:02:54.351]             length <- base::length
[17:02:54.351]             list <- base::list
[17:02:54.351]             seq.int <- base::seq.int
[17:02:54.351]             signalCondition <- base::signalCondition
[17:02:54.351]             sys.calls <- base::sys.calls
[17:02:54.351]             `[[` <- base::`[[`
[17:02:54.351]             `+` <- base::`+`
[17:02:54.351]             `<<-` <- base::`<<-`
[17:02:54.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.351]                   3L)]
[17:02:54.351]             }
[17:02:54.351]             function(cond) {
[17:02:54.351]                 is_error <- inherits(cond, "error")
[17:02:54.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.351]                   NULL)
[17:02:54.351]                 if (is_error) {
[17:02:54.351]                   sessionInformation <- function() {
[17:02:54.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.351]                       search = base::search(), system = base::Sys.info())
[17:02:54.351]                   }
[17:02:54.351]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.351]                     cond$call), session = sessionInformation(), 
[17:02:54.351]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.351]                   signalCondition(cond)
[17:02:54.351]                 }
[17:02:54.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.351]                 "immediateCondition"))) {
[17:02:54.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.351]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.351]                   if (TRUE && !signal) {
[17:02:54.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.351]                     {
[17:02:54.351]                       inherits <- base::inherits
[17:02:54.351]                       invokeRestart <- base::invokeRestart
[17:02:54.351]                       is.null <- base::is.null
[17:02:54.351]                       muffled <- FALSE
[17:02:54.351]                       if (inherits(cond, "message")) {
[17:02:54.351]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.351]                         if (muffled) 
[17:02:54.351]                           invokeRestart("muffleMessage")
[17:02:54.351]                       }
[17:02:54.351]                       else if (inherits(cond, "warning")) {
[17:02:54.351]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.351]                         if (muffled) 
[17:02:54.351]                           invokeRestart("muffleWarning")
[17:02:54.351]                       }
[17:02:54.351]                       else if (inherits(cond, "condition")) {
[17:02:54.351]                         if (!is.null(pattern)) {
[17:02:54.351]                           computeRestarts <- base::computeRestarts
[17:02:54.351]                           grepl <- base::grepl
[17:02:54.351]                           restarts <- computeRestarts(cond)
[17:02:54.351]                           for (restart in restarts) {
[17:02:54.351]                             name <- restart$name
[17:02:54.351]                             if (is.null(name)) 
[17:02:54.351]                               next
[17:02:54.351]                             if (!grepl(pattern, name)) 
[17:02:54.351]                               next
[17:02:54.351]                             invokeRestart(restart)
[17:02:54.351]                             muffled <- TRUE
[17:02:54.351]                             break
[17:02:54.351]                           }
[17:02:54.351]                         }
[17:02:54.351]                       }
[17:02:54.351]                       invisible(muffled)
[17:02:54.351]                     }
[17:02:54.351]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.351]                   }
[17:02:54.351]                 }
[17:02:54.351]                 else {
[17:02:54.351]                   if (TRUE) {
[17:02:54.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.351]                     {
[17:02:54.351]                       inherits <- base::inherits
[17:02:54.351]                       invokeRestart <- base::invokeRestart
[17:02:54.351]                       is.null <- base::is.null
[17:02:54.351]                       muffled <- FALSE
[17:02:54.351]                       if (inherits(cond, "message")) {
[17:02:54.351]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.351]                         if (muffled) 
[17:02:54.351]                           invokeRestart("muffleMessage")
[17:02:54.351]                       }
[17:02:54.351]                       else if (inherits(cond, "warning")) {
[17:02:54.351]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.351]                         if (muffled) 
[17:02:54.351]                           invokeRestart("muffleWarning")
[17:02:54.351]                       }
[17:02:54.351]                       else if (inherits(cond, "condition")) {
[17:02:54.351]                         if (!is.null(pattern)) {
[17:02:54.351]                           computeRestarts <- base::computeRestarts
[17:02:54.351]                           grepl <- base::grepl
[17:02:54.351]                           restarts <- computeRestarts(cond)
[17:02:54.351]                           for (restart in restarts) {
[17:02:54.351]                             name <- restart$name
[17:02:54.351]                             if (is.null(name)) 
[17:02:54.351]                               next
[17:02:54.351]                             if (!grepl(pattern, name)) 
[17:02:54.351]                               next
[17:02:54.351]                             invokeRestart(restart)
[17:02:54.351]                             muffled <- TRUE
[17:02:54.351]                             break
[17:02:54.351]                           }
[17:02:54.351]                         }
[17:02:54.351]                       }
[17:02:54.351]                       invisible(muffled)
[17:02:54.351]                     }
[17:02:54.351]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.351]                   }
[17:02:54.351]                 }
[17:02:54.351]             }
[17:02:54.351]         }))
[17:02:54.351]     }, error = function(ex) {
[17:02:54.351]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.351]                 ...future.rng), started = ...future.startTime, 
[17:02:54.351]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.351]             version = "1.8"), class = "FutureResult")
[17:02:54.351]     }, finally = {
[17:02:54.351]         if (!identical(...future.workdir, getwd())) 
[17:02:54.351]             setwd(...future.workdir)
[17:02:54.351]         {
[17:02:54.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.351]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.351]             }
[17:02:54.351]             base::options(...future.oldOptions)
[17:02:54.351]             if (.Platform$OS.type == "windows") {
[17:02:54.351]                 old_names <- names(...future.oldEnvVars)
[17:02:54.351]                 envs <- base::Sys.getenv()
[17:02:54.351]                 names <- names(envs)
[17:02:54.351]                 common <- intersect(names, old_names)
[17:02:54.351]                 added <- setdiff(names, old_names)
[17:02:54.351]                 removed <- setdiff(old_names, names)
[17:02:54.351]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.351]                   envs[common]]
[17:02:54.351]                 NAMES <- toupper(changed)
[17:02:54.351]                 args <- list()
[17:02:54.351]                 for (kk in seq_along(NAMES)) {
[17:02:54.351]                   name <- changed[[kk]]
[17:02:54.351]                   NAME <- NAMES[[kk]]
[17:02:54.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.351]                     next
[17:02:54.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.351]                 }
[17:02:54.351]                 NAMES <- toupper(added)
[17:02:54.351]                 for (kk in seq_along(NAMES)) {
[17:02:54.351]                   name <- added[[kk]]
[17:02:54.351]                   NAME <- NAMES[[kk]]
[17:02:54.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.351]                     next
[17:02:54.351]                   args[[name]] <- ""
[17:02:54.351]                 }
[17:02:54.351]                 NAMES <- toupper(removed)
[17:02:54.351]                 for (kk in seq_along(NAMES)) {
[17:02:54.351]                   name <- removed[[kk]]
[17:02:54.351]                   NAME <- NAMES[[kk]]
[17:02:54.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.351]                     next
[17:02:54.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.351]                 }
[17:02:54.351]                 if (length(args) > 0) 
[17:02:54.351]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.351]             }
[17:02:54.351]             else {
[17:02:54.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.351]             }
[17:02:54.351]             {
[17:02:54.351]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.351]                   0L) {
[17:02:54.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.351]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.351]                   base::options(opts)
[17:02:54.351]                 }
[17:02:54.351]                 {
[17:02:54.351]                   {
[17:02:54.351]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.351]                     NULL
[17:02:54.351]                   }
[17:02:54.351]                   options(future.plan = NULL)
[17:02:54.351]                   if (is.na(NA_character_)) 
[17:02:54.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.351]                     .init = FALSE)
[17:02:54.351]                 }
[17:02:54.351]             }
[17:02:54.351]         }
[17:02:54.351]     })
[17:02:54.351]     if (TRUE) {
[17:02:54.351]         base::sink(type = "output", split = FALSE)
[17:02:54.351]         if (TRUE) {
[17:02:54.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.351]         }
[17:02:54.351]         else {
[17:02:54.351]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.351]         }
[17:02:54.351]         base::close(...future.stdout)
[17:02:54.351]         ...future.stdout <- NULL
[17:02:54.351]     }
[17:02:54.351]     ...future.result$conditions <- ...future.conditions
[17:02:54.351]     ...future.result$finished <- base::Sys.time()
[17:02:54.351]     ...future.result
[17:02:54.351] }
[17:02:54.354] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:02:54.355] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:02:54.408] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:02:54.408] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:02:54.409] MultisessionFuture started
[17:02:54.409] - Launch lazy future ... done
[17:02:54.409] run() for ‘MultisessionFuture’ ... done
[17:02:54.409] result() for ClusterFuture ...
[17:02:54.409] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.409] - Validating connection of MultisessionFuture
[17:02:54.454] - received message: FutureResult
[17:02:54.454] - Received FutureResult
[17:02:54.454] - Erased future from FutureRegistry
[17:02:54.454] result() for ClusterFuture ...
[17:02:54.454] - result already collected: FutureResult
[17:02:54.454] result() for ClusterFuture ... done
[17:02:54.454] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.454] result() for ClusterFuture ... done
[17:02:54.455] result() for ClusterFuture ...
[17:02:54.455] - result already collected: FutureResult
[17:02:54.455] result() for ClusterFuture ... done
value(b) = 2
[17:02:54.455] result() for ClusterFuture ...
[17:02:54.455] - result already collected: FutureResult
[17:02:54.455] result() for ClusterFuture ... done
[17:02:54.455] result() for ClusterFuture ...
[17:02:54.455] - result already collected: FutureResult
[17:02:54.455] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.456] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.456] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.457] 
[17:02:54.457] Searching for globals ... DONE
[17:02:54.457] - globals: [0] <none>
[17:02:54.457] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.457] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.457] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.458] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:54.458] Searching for globals ... DONE
[17:02:54.459] Resolving globals: TRUE
[17:02:54.459] Resolving any globals that are futures ...
[17:02:54.459] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:54.459] Resolving any globals that are futures ... DONE
[17:02:54.459] Resolving futures part of globals (recursively) ...
[17:02:54.459] resolve() on list ...
[17:02:54.460]  recursive: 99
[17:02:54.460]  length: 1
[17:02:54.460]  elements: ‘a’
[17:02:54.460] run() for ‘Future’ ...
[17:02:54.460] - state: ‘created’
[17:02:54.460] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.475]   - Field: ‘node’
[17:02:54.475]   - Field: ‘label’
[17:02:54.475]   - Field: ‘local’
[17:02:54.475]   - Field: ‘owner’
[17:02:54.475]   - Field: ‘envir’
[17:02:54.475]   - Field: ‘workers’
[17:02:54.476]   - Field: ‘packages’
[17:02:54.476]   - Field: ‘gc’
[17:02:54.476]   - Field: ‘conditions’
[17:02:54.476]   - Field: ‘persistent’
[17:02:54.476]   - Field: ‘expr’
[17:02:54.476]   - Field: ‘uuid’
[17:02:54.476]   - Field: ‘seed’
[17:02:54.476]   - Field: ‘version’
[17:02:54.476]   - Field: ‘result’
[17:02:54.476]   - Field: ‘asynchronous’
[17:02:54.476]   - Field: ‘calls’
[17:02:54.479]   - Field: ‘globals’
[17:02:54.479]   - Field: ‘stdout’
[17:02:54.479]   - Field: ‘earlySignal’
[17:02:54.479]   - Field: ‘lazy’
[17:02:54.479]   - Field: ‘state’
[17:02:54.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.479] - Launch lazy future ...
[17:02:54.479] Packages needed by the future expression (n = 0): <none>
[17:02:54.480] Packages needed by future strategies (n = 0): <none>
[17:02:54.480] {
[17:02:54.480]     {
[17:02:54.480]         {
[17:02:54.480]             ...future.startTime <- base::Sys.time()
[17:02:54.480]             {
[17:02:54.480]                 {
[17:02:54.480]                   {
[17:02:54.480]                     {
[17:02:54.480]                       base::local({
[17:02:54.480]                         has_future <- base::requireNamespace("future", 
[17:02:54.480]                           quietly = TRUE)
[17:02:54.480]                         if (has_future) {
[17:02:54.480]                           ns <- base::getNamespace("future")
[17:02:54.480]                           version <- ns[[".package"]][["version"]]
[17:02:54.480]                           if (is.null(version)) 
[17:02:54.480]                             version <- utils::packageVersion("future")
[17:02:54.480]                         }
[17:02:54.480]                         else {
[17:02:54.480]                           version <- NULL
[17:02:54.480]                         }
[17:02:54.480]                         if (!has_future || version < "1.8.0") {
[17:02:54.480]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.480]                             "", base::R.version$version.string), 
[17:02:54.480]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.480]                               "release", "version")], collapse = " "), 
[17:02:54.480]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.480]                             info)
[17:02:54.480]                           info <- base::paste(info, collapse = "; ")
[17:02:54.480]                           if (!has_future) {
[17:02:54.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.480]                               info)
[17:02:54.480]                           }
[17:02:54.480]                           else {
[17:02:54.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.480]                               info, version)
[17:02:54.480]                           }
[17:02:54.480]                           base::stop(msg)
[17:02:54.480]                         }
[17:02:54.480]                       })
[17:02:54.480]                     }
[17:02:54.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.480]                     base::options(mc.cores = 1L)
[17:02:54.480]                   }
[17:02:54.480]                   ...future.strategy.old <- future::plan("list")
[17:02:54.480]                   options(future.plan = NULL)
[17:02:54.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.480]                 }
[17:02:54.480]                 ...future.workdir <- getwd()
[17:02:54.480]             }
[17:02:54.480]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.480]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.480]         }
[17:02:54.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.480]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.480]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.480]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.480]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.480]             base::names(...future.oldOptions))
[17:02:54.480]     }
[17:02:54.480]     if (FALSE) {
[17:02:54.480]     }
[17:02:54.480]     else {
[17:02:54.480]         if (TRUE) {
[17:02:54.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.480]                 open = "w")
[17:02:54.480]         }
[17:02:54.480]         else {
[17:02:54.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.480]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.480]         }
[17:02:54.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.480]             base::sink(type = "output", split = FALSE)
[17:02:54.480]             base::close(...future.stdout)
[17:02:54.480]         }, add = TRUE)
[17:02:54.480]     }
[17:02:54.480]     ...future.frame <- base::sys.nframe()
[17:02:54.480]     ...future.conditions <- base::list()
[17:02:54.480]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.480]     if (FALSE) {
[17:02:54.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.480]     }
[17:02:54.480]     ...future.result <- base::tryCatch({
[17:02:54.480]         base::withCallingHandlers({
[17:02:54.480]             ...future.value <- base::withVisible(base::local({
[17:02:54.480]                 ...future.makeSendCondition <- base::local({
[17:02:54.480]                   sendCondition <- NULL
[17:02:54.480]                   function(frame = 1L) {
[17:02:54.480]                     if (is.function(sendCondition)) 
[17:02:54.480]                       return(sendCondition)
[17:02:54.480]                     ns <- getNamespace("parallel")
[17:02:54.480]                     if (exists("sendData", mode = "function", 
[17:02:54.480]                       envir = ns)) {
[17:02:54.480]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.480]                         envir = ns)
[17:02:54.480]                       envir <- sys.frame(frame)
[17:02:54.480]                       master <- NULL
[17:02:54.480]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.480]                         !identical(envir, emptyenv())) {
[17:02:54.480]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.480]                           inherits = FALSE)) {
[17:02:54.480]                           master <- get("master", mode = "list", 
[17:02:54.480]                             envir = envir, inherits = FALSE)
[17:02:54.480]                           if (inherits(master, c("SOCKnode", 
[17:02:54.480]                             "SOCK0node"))) {
[17:02:54.480]                             sendCondition <<- function(cond) {
[17:02:54.480]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.480]                                 success = TRUE)
[17:02:54.480]                               parallel_sendData(master, data)
[17:02:54.480]                             }
[17:02:54.480]                             return(sendCondition)
[17:02:54.480]                           }
[17:02:54.480]                         }
[17:02:54.480]                         frame <- frame + 1L
[17:02:54.480]                         envir <- sys.frame(frame)
[17:02:54.480]                       }
[17:02:54.480]                     }
[17:02:54.480]                     sendCondition <<- function(cond) NULL
[17:02:54.480]                   }
[17:02:54.480]                 })
[17:02:54.480]                 withCallingHandlers({
[17:02:54.480]                   1
[17:02:54.480]                 }, immediateCondition = function(cond) {
[17:02:54.480]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.480]                   sendCondition(cond)
[17:02:54.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.480]                   {
[17:02:54.480]                     inherits <- base::inherits
[17:02:54.480]                     invokeRestart <- base::invokeRestart
[17:02:54.480]                     is.null <- base::is.null
[17:02:54.480]                     muffled <- FALSE
[17:02:54.480]                     if (inherits(cond, "message")) {
[17:02:54.480]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.480]                       if (muffled) 
[17:02:54.480]                         invokeRestart("muffleMessage")
[17:02:54.480]                     }
[17:02:54.480]                     else if (inherits(cond, "warning")) {
[17:02:54.480]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.480]                       if (muffled) 
[17:02:54.480]                         invokeRestart("muffleWarning")
[17:02:54.480]                     }
[17:02:54.480]                     else if (inherits(cond, "condition")) {
[17:02:54.480]                       if (!is.null(pattern)) {
[17:02:54.480]                         computeRestarts <- base::computeRestarts
[17:02:54.480]                         grepl <- base::grepl
[17:02:54.480]                         restarts <- computeRestarts(cond)
[17:02:54.480]                         for (restart in restarts) {
[17:02:54.480]                           name <- restart$name
[17:02:54.480]                           if (is.null(name)) 
[17:02:54.480]                             next
[17:02:54.480]                           if (!grepl(pattern, name)) 
[17:02:54.480]                             next
[17:02:54.480]                           invokeRestart(restart)
[17:02:54.480]                           muffled <- TRUE
[17:02:54.480]                           break
[17:02:54.480]                         }
[17:02:54.480]                       }
[17:02:54.480]                     }
[17:02:54.480]                     invisible(muffled)
[17:02:54.480]                   }
[17:02:54.480]                   muffleCondition(cond)
[17:02:54.480]                 })
[17:02:54.480]             }))
[17:02:54.480]             future::FutureResult(value = ...future.value$value, 
[17:02:54.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.480]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.480]                     ...future.globalenv.names))
[17:02:54.480]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.480]         }, condition = base::local({
[17:02:54.480]             c <- base::c
[17:02:54.480]             inherits <- base::inherits
[17:02:54.480]             invokeRestart <- base::invokeRestart
[17:02:54.480]             length <- base::length
[17:02:54.480]             list <- base::list
[17:02:54.480]             seq.int <- base::seq.int
[17:02:54.480]             signalCondition <- base::signalCondition
[17:02:54.480]             sys.calls <- base::sys.calls
[17:02:54.480]             `[[` <- base::`[[`
[17:02:54.480]             `+` <- base::`+`
[17:02:54.480]             `<<-` <- base::`<<-`
[17:02:54.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.480]                   3L)]
[17:02:54.480]             }
[17:02:54.480]             function(cond) {
[17:02:54.480]                 is_error <- inherits(cond, "error")
[17:02:54.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.480]                   NULL)
[17:02:54.480]                 if (is_error) {
[17:02:54.480]                   sessionInformation <- function() {
[17:02:54.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.480]                       search = base::search(), system = base::Sys.info())
[17:02:54.480]                   }
[17:02:54.480]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.480]                     cond$call), session = sessionInformation(), 
[17:02:54.480]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.480]                   signalCondition(cond)
[17:02:54.480]                 }
[17:02:54.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.480]                 "immediateCondition"))) {
[17:02:54.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.480]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.480]                   if (TRUE && !signal) {
[17:02:54.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.480]                     {
[17:02:54.480]                       inherits <- base::inherits
[17:02:54.480]                       invokeRestart <- base::invokeRestart
[17:02:54.480]                       is.null <- base::is.null
[17:02:54.480]                       muffled <- FALSE
[17:02:54.480]                       if (inherits(cond, "message")) {
[17:02:54.480]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.480]                         if (muffled) 
[17:02:54.480]                           invokeRestart("muffleMessage")
[17:02:54.480]                       }
[17:02:54.480]                       else if (inherits(cond, "warning")) {
[17:02:54.480]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.480]                         if (muffled) 
[17:02:54.480]                           invokeRestart("muffleWarning")
[17:02:54.480]                       }
[17:02:54.480]                       else if (inherits(cond, "condition")) {
[17:02:54.480]                         if (!is.null(pattern)) {
[17:02:54.480]                           computeRestarts <- base::computeRestarts
[17:02:54.480]                           grepl <- base::grepl
[17:02:54.480]                           restarts <- computeRestarts(cond)
[17:02:54.480]                           for (restart in restarts) {
[17:02:54.480]                             name <- restart$name
[17:02:54.480]                             if (is.null(name)) 
[17:02:54.480]                               next
[17:02:54.480]                             if (!grepl(pattern, name)) 
[17:02:54.480]                               next
[17:02:54.480]                             invokeRestart(restart)
[17:02:54.480]                             muffled <- TRUE
[17:02:54.480]                             break
[17:02:54.480]                           }
[17:02:54.480]                         }
[17:02:54.480]                       }
[17:02:54.480]                       invisible(muffled)
[17:02:54.480]                     }
[17:02:54.480]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.480]                   }
[17:02:54.480]                 }
[17:02:54.480]                 else {
[17:02:54.480]                   if (TRUE) {
[17:02:54.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.480]                     {
[17:02:54.480]                       inherits <- base::inherits
[17:02:54.480]                       invokeRestart <- base::invokeRestart
[17:02:54.480]                       is.null <- base::is.null
[17:02:54.480]                       muffled <- FALSE
[17:02:54.480]                       if (inherits(cond, "message")) {
[17:02:54.480]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.480]                         if (muffled) 
[17:02:54.480]                           invokeRestart("muffleMessage")
[17:02:54.480]                       }
[17:02:54.480]                       else if (inherits(cond, "warning")) {
[17:02:54.480]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.480]                         if (muffled) 
[17:02:54.480]                           invokeRestart("muffleWarning")
[17:02:54.480]                       }
[17:02:54.480]                       else if (inherits(cond, "condition")) {
[17:02:54.480]                         if (!is.null(pattern)) {
[17:02:54.480]                           computeRestarts <- base::computeRestarts
[17:02:54.480]                           grepl <- base::grepl
[17:02:54.480]                           restarts <- computeRestarts(cond)
[17:02:54.480]                           for (restart in restarts) {
[17:02:54.480]                             name <- restart$name
[17:02:54.480]                             if (is.null(name)) 
[17:02:54.480]                               next
[17:02:54.480]                             if (!grepl(pattern, name)) 
[17:02:54.480]                               next
[17:02:54.480]                             invokeRestart(restart)
[17:02:54.480]                             muffled <- TRUE
[17:02:54.480]                             break
[17:02:54.480]                           }
[17:02:54.480]                         }
[17:02:54.480]                       }
[17:02:54.480]                       invisible(muffled)
[17:02:54.480]                     }
[17:02:54.480]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.480]                   }
[17:02:54.480]                 }
[17:02:54.480]             }
[17:02:54.480]         }))
[17:02:54.480]     }, error = function(ex) {
[17:02:54.480]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.480]                 ...future.rng), started = ...future.startTime, 
[17:02:54.480]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.480]             version = "1.8"), class = "FutureResult")
[17:02:54.480]     }, finally = {
[17:02:54.480]         if (!identical(...future.workdir, getwd())) 
[17:02:54.480]             setwd(...future.workdir)
[17:02:54.480]         {
[17:02:54.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.480]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.480]             }
[17:02:54.480]             base::options(...future.oldOptions)
[17:02:54.480]             if (.Platform$OS.type == "windows") {
[17:02:54.480]                 old_names <- names(...future.oldEnvVars)
[17:02:54.480]                 envs <- base::Sys.getenv()
[17:02:54.480]                 names <- names(envs)
[17:02:54.480]                 common <- intersect(names, old_names)
[17:02:54.480]                 added <- setdiff(names, old_names)
[17:02:54.480]                 removed <- setdiff(old_names, names)
[17:02:54.480]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.480]                   envs[common]]
[17:02:54.480]                 NAMES <- toupper(changed)
[17:02:54.480]                 args <- list()
[17:02:54.480]                 for (kk in seq_along(NAMES)) {
[17:02:54.480]                   name <- changed[[kk]]
[17:02:54.480]                   NAME <- NAMES[[kk]]
[17:02:54.480]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.480]                     next
[17:02:54.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.480]                 }
[17:02:54.480]                 NAMES <- toupper(added)
[17:02:54.480]                 for (kk in seq_along(NAMES)) {
[17:02:54.480]                   name <- added[[kk]]
[17:02:54.480]                   NAME <- NAMES[[kk]]
[17:02:54.480]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.480]                     next
[17:02:54.480]                   args[[name]] <- ""
[17:02:54.480]                 }
[17:02:54.480]                 NAMES <- toupper(removed)
[17:02:54.480]                 for (kk in seq_along(NAMES)) {
[17:02:54.480]                   name <- removed[[kk]]
[17:02:54.480]                   NAME <- NAMES[[kk]]
[17:02:54.480]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.480]                     next
[17:02:54.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.480]                 }
[17:02:54.480]                 if (length(args) > 0) 
[17:02:54.480]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.480]             }
[17:02:54.480]             else {
[17:02:54.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.480]             }
[17:02:54.480]             {
[17:02:54.480]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.480]                   0L) {
[17:02:54.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.480]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.480]                   base::options(opts)
[17:02:54.480]                 }
[17:02:54.480]                 {
[17:02:54.480]                   {
[17:02:54.480]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.480]                     NULL
[17:02:54.480]                   }
[17:02:54.480]                   options(future.plan = NULL)
[17:02:54.480]                   if (is.na(NA_character_)) 
[17:02:54.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.480]                     .init = FALSE)
[17:02:54.480]                 }
[17:02:54.480]             }
[17:02:54.480]         }
[17:02:54.480]     })
[17:02:54.480]     if (TRUE) {
[17:02:54.480]         base::sink(type = "output", split = FALSE)
[17:02:54.480]         if (TRUE) {
[17:02:54.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.480]         }
[17:02:54.480]         else {
[17:02:54.480]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.480]         }
[17:02:54.480]         base::close(...future.stdout)
[17:02:54.480]         ...future.stdout <- NULL
[17:02:54.480]     }
[17:02:54.480]     ...future.result$conditions <- ...future.conditions
[17:02:54.480]     ...future.result$finished <- base::Sys.time()
[17:02:54.480]     ...future.result
[17:02:54.480] }
[17:02:54.483] MultisessionFuture started
[17:02:54.483] - Launch lazy future ... done
[17:02:54.483] run() for ‘MultisessionFuture’ ... done
[17:02:54.525] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.525] - Validating connection of MultisessionFuture
[17:02:54.526] - received message: FutureResult
[17:02:54.526] - Received FutureResult
[17:02:54.526] - Erased future from FutureRegistry
[17:02:54.526] result() for ClusterFuture ...
[17:02:54.526] - result already collected: FutureResult
[17:02:54.526] result() for ClusterFuture ... done
[17:02:54.526] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.526] Future #1
[17:02:54.526] result() for ClusterFuture ...
[17:02:54.527] - result already collected: FutureResult
[17:02:54.527] result() for ClusterFuture ... done
[17:02:54.527] result() for ClusterFuture ...
[17:02:54.527] - result already collected: FutureResult
[17:02:54.527] result() for ClusterFuture ... done
[17:02:54.527] A MultisessionFuture was resolved
[17:02:54.527]  length: 0 (resolved future 1)
[17:02:54.527] resolve() on list ... DONE
[17:02:54.527] - globals: [1] ‘a’
[17:02:54.528] Resolving futures part of globals (recursively) ... DONE
[17:02:54.528] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:02:54.529] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:02:54.529] - globals: [1] ‘a’
[17:02:54.529] - packages: [1] ‘future’
[17:02:54.529] getGlobalsAndPackages() ... DONE
[17:02:54.529] run() for ‘Future’ ...
[17:02:54.530] - state: ‘created’
[17:02:54.530] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.544] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.545]   - Field: ‘node’
[17:02:54.545]   - Field: ‘label’
[17:02:54.545]   - Field: ‘local’
[17:02:54.545]   - Field: ‘owner’
[17:02:54.545]   - Field: ‘envir’
[17:02:54.545]   - Field: ‘workers’
[17:02:54.545]   - Field: ‘packages’
[17:02:54.545]   - Field: ‘gc’
[17:02:54.545]   - Field: ‘conditions’
[17:02:54.546]   - Field: ‘persistent’
[17:02:54.546]   - Field: ‘expr’
[17:02:54.546]   - Field: ‘uuid’
[17:02:54.546]   - Field: ‘seed’
[17:02:54.546]   - Field: ‘version’
[17:02:54.546]   - Field: ‘result’
[17:02:54.546]   - Field: ‘asynchronous’
[17:02:54.546]   - Field: ‘calls’
[17:02:54.546]   - Field: ‘globals’
[17:02:54.546]   - Field: ‘stdout’
[17:02:54.546]   - Field: ‘earlySignal’
[17:02:54.547]   - Field: ‘lazy’
[17:02:54.547]   - Field: ‘state’
[17:02:54.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.547] - Launch lazy future ...
[17:02:54.547] Packages needed by the future expression (n = 1): ‘future’
[17:02:54.547] Packages needed by future strategies (n = 0): <none>
[17:02:54.548] {
[17:02:54.548]     {
[17:02:54.548]         {
[17:02:54.548]             ...future.startTime <- base::Sys.time()
[17:02:54.548]             {
[17:02:54.548]                 {
[17:02:54.548]                   {
[17:02:54.548]                     {
[17:02:54.548]                       {
[17:02:54.548]                         base::local({
[17:02:54.548]                           has_future <- base::requireNamespace("future", 
[17:02:54.548]                             quietly = TRUE)
[17:02:54.548]                           if (has_future) {
[17:02:54.548]                             ns <- base::getNamespace("future")
[17:02:54.548]                             version <- ns[[".package"]][["version"]]
[17:02:54.548]                             if (is.null(version)) 
[17:02:54.548]                               version <- utils::packageVersion("future")
[17:02:54.548]                           }
[17:02:54.548]                           else {
[17:02:54.548]                             version <- NULL
[17:02:54.548]                           }
[17:02:54.548]                           if (!has_future || version < "1.8.0") {
[17:02:54.548]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.548]                               "", base::R.version$version.string), 
[17:02:54.548]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:54.548]                                 base::R.version$platform, 8 * 
[17:02:54.548]                                   base::.Machine$sizeof.pointer), 
[17:02:54.548]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.548]                                 "release", "version")], collapse = " "), 
[17:02:54.548]                               hostname = base::Sys.info()[["nodename"]])
[17:02:54.548]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.548]                               info)
[17:02:54.548]                             info <- base::paste(info, collapse = "; ")
[17:02:54.548]                             if (!has_future) {
[17:02:54.548]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.548]                                 info)
[17:02:54.548]                             }
[17:02:54.548]                             else {
[17:02:54.548]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.548]                                 info, version)
[17:02:54.548]                             }
[17:02:54.548]                             base::stop(msg)
[17:02:54.548]                           }
[17:02:54.548]                         })
[17:02:54.548]                       }
[17:02:54.548]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.548]                       base::options(mc.cores = 1L)
[17:02:54.548]                     }
[17:02:54.548]                     base::local({
[17:02:54.548]                       for (pkg in "future") {
[17:02:54.548]                         base::loadNamespace(pkg)
[17:02:54.548]                         base::library(pkg, character.only = TRUE)
[17:02:54.548]                       }
[17:02:54.548]                     })
[17:02:54.548]                   }
[17:02:54.548]                   ...future.strategy.old <- future::plan("list")
[17:02:54.548]                   options(future.plan = NULL)
[17:02:54.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.548]                 }
[17:02:54.548]                 ...future.workdir <- getwd()
[17:02:54.548]             }
[17:02:54.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.548]         }
[17:02:54.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.548]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.548]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.548]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.548]             base::names(...future.oldOptions))
[17:02:54.548]     }
[17:02:54.548]     if (FALSE) {
[17:02:54.548]     }
[17:02:54.548]     else {
[17:02:54.548]         if (TRUE) {
[17:02:54.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.548]                 open = "w")
[17:02:54.548]         }
[17:02:54.548]         else {
[17:02:54.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.548]         }
[17:02:54.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.548]             base::sink(type = "output", split = FALSE)
[17:02:54.548]             base::close(...future.stdout)
[17:02:54.548]         }, add = TRUE)
[17:02:54.548]     }
[17:02:54.548]     ...future.frame <- base::sys.nframe()
[17:02:54.548]     ...future.conditions <- base::list()
[17:02:54.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.548]     if (FALSE) {
[17:02:54.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.548]     }
[17:02:54.548]     ...future.result <- base::tryCatch({
[17:02:54.548]         base::withCallingHandlers({
[17:02:54.548]             ...future.value <- base::withVisible(base::local({
[17:02:54.548]                 ...future.makeSendCondition <- base::local({
[17:02:54.548]                   sendCondition <- NULL
[17:02:54.548]                   function(frame = 1L) {
[17:02:54.548]                     if (is.function(sendCondition)) 
[17:02:54.548]                       return(sendCondition)
[17:02:54.548]                     ns <- getNamespace("parallel")
[17:02:54.548]                     if (exists("sendData", mode = "function", 
[17:02:54.548]                       envir = ns)) {
[17:02:54.548]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.548]                         envir = ns)
[17:02:54.548]                       envir <- sys.frame(frame)
[17:02:54.548]                       master <- NULL
[17:02:54.548]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.548]                         !identical(envir, emptyenv())) {
[17:02:54.548]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.548]                           inherits = FALSE)) {
[17:02:54.548]                           master <- get("master", mode = "list", 
[17:02:54.548]                             envir = envir, inherits = FALSE)
[17:02:54.548]                           if (inherits(master, c("SOCKnode", 
[17:02:54.548]                             "SOCK0node"))) {
[17:02:54.548]                             sendCondition <<- function(cond) {
[17:02:54.548]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.548]                                 success = TRUE)
[17:02:54.548]                               parallel_sendData(master, data)
[17:02:54.548]                             }
[17:02:54.548]                             return(sendCondition)
[17:02:54.548]                           }
[17:02:54.548]                         }
[17:02:54.548]                         frame <- frame + 1L
[17:02:54.548]                         envir <- sys.frame(frame)
[17:02:54.548]                       }
[17:02:54.548]                     }
[17:02:54.548]                     sendCondition <<- function(cond) NULL
[17:02:54.548]                   }
[17:02:54.548]                 })
[17:02:54.548]                 withCallingHandlers({
[17:02:54.548]                   value(a) + 1
[17:02:54.548]                 }, immediateCondition = function(cond) {
[17:02:54.548]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.548]                   sendCondition(cond)
[17:02:54.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.548]                   {
[17:02:54.548]                     inherits <- base::inherits
[17:02:54.548]                     invokeRestart <- base::invokeRestart
[17:02:54.548]                     is.null <- base::is.null
[17:02:54.548]                     muffled <- FALSE
[17:02:54.548]                     if (inherits(cond, "message")) {
[17:02:54.548]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.548]                       if (muffled) 
[17:02:54.548]                         invokeRestart("muffleMessage")
[17:02:54.548]                     }
[17:02:54.548]                     else if (inherits(cond, "warning")) {
[17:02:54.548]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.548]                       if (muffled) 
[17:02:54.548]                         invokeRestart("muffleWarning")
[17:02:54.548]                     }
[17:02:54.548]                     else if (inherits(cond, "condition")) {
[17:02:54.548]                       if (!is.null(pattern)) {
[17:02:54.548]                         computeRestarts <- base::computeRestarts
[17:02:54.548]                         grepl <- base::grepl
[17:02:54.548]                         restarts <- computeRestarts(cond)
[17:02:54.548]                         for (restart in restarts) {
[17:02:54.548]                           name <- restart$name
[17:02:54.548]                           if (is.null(name)) 
[17:02:54.548]                             next
[17:02:54.548]                           if (!grepl(pattern, name)) 
[17:02:54.548]                             next
[17:02:54.548]                           invokeRestart(restart)
[17:02:54.548]                           muffled <- TRUE
[17:02:54.548]                           break
[17:02:54.548]                         }
[17:02:54.548]                       }
[17:02:54.548]                     }
[17:02:54.548]                     invisible(muffled)
[17:02:54.548]                   }
[17:02:54.548]                   muffleCondition(cond)
[17:02:54.548]                 })
[17:02:54.548]             }))
[17:02:54.548]             future::FutureResult(value = ...future.value$value, 
[17:02:54.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.548]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.548]                     ...future.globalenv.names))
[17:02:54.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.548]         }, condition = base::local({
[17:02:54.548]             c <- base::c
[17:02:54.548]             inherits <- base::inherits
[17:02:54.548]             invokeRestart <- base::invokeRestart
[17:02:54.548]             length <- base::length
[17:02:54.548]             list <- base::list
[17:02:54.548]             seq.int <- base::seq.int
[17:02:54.548]             signalCondition <- base::signalCondition
[17:02:54.548]             sys.calls <- base::sys.calls
[17:02:54.548]             `[[` <- base::`[[`
[17:02:54.548]             `+` <- base::`+`
[17:02:54.548]             `<<-` <- base::`<<-`
[17:02:54.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.548]                   3L)]
[17:02:54.548]             }
[17:02:54.548]             function(cond) {
[17:02:54.548]                 is_error <- inherits(cond, "error")
[17:02:54.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.548]                   NULL)
[17:02:54.548]                 if (is_error) {
[17:02:54.548]                   sessionInformation <- function() {
[17:02:54.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.548]                       search = base::search(), system = base::Sys.info())
[17:02:54.548]                   }
[17:02:54.548]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.548]                     cond$call), session = sessionInformation(), 
[17:02:54.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.548]                   signalCondition(cond)
[17:02:54.548]                 }
[17:02:54.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.548]                 "immediateCondition"))) {
[17:02:54.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.548]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.548]                   if (TRUE && !signal) {
[17:02:54.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.548]                     {
[17:02:54.548]                       inherits <- base::inherits
[17:02:54.548]                       invokeRestart <- base::invokeRestart
[17:02:54.548]                       is.null <- base::is.null
[17:02:54.548]                       muffled <- FALSE
[17:02:54.548]                       if (inherits(cond, "message")) {
[17:02:54.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.548]                         if (muffled) 
[17:02:54.548]                           invokeRestart("muffleMessage")
[17:02:54.548]                       }
[17:02:54.548]                       else if (inherits(cond, "warning")) {
[17:02:54.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.548]                         if (muffled) 
[17:02:54.548]                           invokeRestart("muffleWarning")
[17:02:54.548]                       }
[17:02:54.548]                       else if (inherits(cond, "condition")) {
[17:02:54.548]                         if (!is.null(pattern)) {
[17:02:54.548]                           computeRestarts <- base::computeRestarts
[17:02:54.548]                           grepl <- base::grepl
[17:02:54.548]                           restarts <- computeRestarts(cond)
[17:02:54.548]                           for (restart in restarts) {
[17:02:54.548]                             name <- restart$name
[17:02:54.548]                             if (is.null(name)) 
[17:02:54.548]                               next
[17:02:54.548]                             if (!grepl(pattern, name)) 
[17:02:54.548]                               next
[17:02:54.548]                             invokeRestart(restart)
[17:02:54.548]                             muffled <- TRUE
[17:02:54.548]                             break
[17:02:54.548]                           }
[17:02:54.548]                         }
[17:02:54.548]                       }
[17:02:54.548]                       invisible(muffled)
[17:02:54.548]                     }
[17:02:54.548]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.548]                   }
[17:02:54.548]                 }
[17:02:54.548]                 else {
[17:02:54.548]                   if (TRUE) {
[17:02:54.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.548]                     {
[17:02:54.548]                       inherits <- base::inherits
[17:02:54.548]                       invokeRestart <- base::invokeRestart
[17:02:54.548]                       is.null <- base::is.null
[17:02:54.548]                       muffled <- FALSE
[17:02:54.548]                       if (inherits(cond, "message")) {
[17:02:54.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.548]                         if (muffled) 
[17:02:54.548]                           invokeRestart("muffleMessage")
[17:02:54.548]                       }
[17:02:54.548]                       else if (inherits(cond, "warning")) {
[17:02:54.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.548]                         if (muffled) 
[17:02:54.548]                           invokeRestart("muffleWarning")
[17:02:54.548]                       }
[17:02:54.548]                       else if (inherits(cond, "condition")) {
[17:02:54.548]                         if (!is.null(pattern)) {
[17:02:54.548]                           computeRestarts <- base::computeRestarts
[17:02:54.548]                           grepl <- base::grepl
[17:02:54.548]                           restarts <- computeRestarts(cond)
[17:02:54.548]                           for (restart in restarts) {
[17:02:54.548]                             name <- restart$name
[17:02:54.548]                             if (is.null(name)) 
[17:02:54.548]                               next
[17:02:54.548]                             if (!grepl(pattern, name)) 
[17:02:54.548]                               next
[17:02:54.548]                             invokeRestart(restart)
[17:02:54.548]                             muffled <- TRUE
[17:02:54.548]                             break
[17:02:54.548]                           }
[17:02:54.548]                         }
[17:02:54.548]                       }
[17:02:54.548]                       invisible(muffled)
[17:02:54.548]                     }
[17:02:54.548]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.548]                   }
[17:02:54.548]                 }
[17:02:54.548]             }
[17:02:54.548]         }))
[17:02:54.548]     }, error = function(ex) {
[17:02:54.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.548]                 ...future.rng), started = ...future.startTime, 
[17:02:54.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.548]             version = "1.8"), class = "FutureResult")
[17:02:54.548]     }, finally = {
[17:02:54.548]         if (!identical(...future.workdir, getwd())) 
[17:02:54.548]             setwd(...future.workdir)
[17:02:54.548]         {
[17:02:54.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.548]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.548]             }
[17:02:54.548]             base::options(...future.oldOptions)
[17:02:54.548]             if (.Platform$OS.type == "windows") {
[17:02:54.548]                 old_names <- names(...future.oldEnvVars)
[17:02:54.548]                 envs <- base::Sys.getenv()
[17:02:54.548]                 names <- names(envs)
[17:02:54.548]                 common <- intersect(names, old_names)
[17:02:54.548]                 added <- setdiff(names, old_names)
[17:02:54.548]                 removed <- setdiff(old_names, names)
[17:02:54.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.548]                   envs[common]]
[17:02:54.548]                 NAMES <- toupper(changed)
[17:02:54.548]                 args <- list()
[17:02:54.548]                 for (kk in seq_along(NAMES)) {
[17:02:54.548]                   name <- changed[[kk]]
[17:02:54.548]                   NAME <- NAMES[[kk]]
[17:02:54.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.548]                     next
[17:02:54.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.548]                 }
[17:02:54.548]                 NAMES <- toupper(added)
[17:02:54.548]                 for (kk in seq_along(NAMES)) {
[17:02:54.548]                   name <- added[[kk]]
[17:02:54.548]                   NAME <- NAMES[[kk]]
[17:02:54.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.548]                     next
[17:02:54.548]                   args[[name]] <- ""
[17:02:54.548]                 }
[17:02:54.548]                 NAMES <- toupper(removed)
[17:02:54.548]                 for (kk in seq_along(NAMES)) {
[17:02:54.548]                   name <- removed[[kk]]
[17:02:54.548]                   NAME <- NAMES[[kk]]
[17:02:54.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.548]                     next
[17:02:54.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.548]                 }
[17:02:54.548]                 if (length(args) > 0) 
[17:02:54.548]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.548]             }
[17:02:54.548]             else {
[17:02:54.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.548]             }
[17:02:54.548]             {
[17:02:54.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.548]                   0L) {
[17:02:54.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.548]                   base::options(opts)
[17:02:54.548]                 }
[17:02:54.548]                 {
[17:02:54.548]                   {
[17:02:54.548]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.548]                     NULL
[17:02:54.548]                   }
[17:02:54.548]                   options(future.plan = NULL)
[17:02:54.548]                   if (is.na(NA_character_)) 
[17:02:54.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.548]                     .init = FALSE)
[17:02:54.548]                 }
[17:02:54.548]             }
[17:02:54.548]         }
[17:02:54.548]     })
[17:02:54.548]     if (TRUE) {
[17:02:54.548]         base::sink(type = "output", split = FALSE)
[17:02:54.548]         if (TRUE) {
[17:02:54.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.548]         }
[17:02:54.548]         else {
[17:02:54.548]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.548]         }
[17:02:54.548]         base::close(...future.stdout)
[17:02:54.548]         ...future.stdout <- NULL
[17:02:54.548]     }
[17:02:54.548]     ...future.result$conditions <- ...future.conditions
[17:02:54.548]     ...future.result$finished <- base::Sys.time()
[17:02:54.548]     ...future.result
[17:02:54.548] }
[17:02:54.550] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:02:54.551] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:02:54.604] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:02:54.604] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:02:54.605] MultisessionFuture started
[17:02:54.605] - Launch lazy future ... done
[17:02:54.605] run() for ‘MultisessionFuture’ ... done
[17:02:54.605] result() for ClusterFuture ...
[17:02:54.605] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.605] - Validating connection of MultisessionFuture
[17:02:54.650] - received message: FutureResult
[17:02:54.650] - Received FutureResult
[17:02:54.650] - Erased future from FutureRegistry
[17:02:54.650] result() for ClusterFuture ...
[17:02:54.650] - result already collected: FutureResult
[17:02:54.650] result() for ClusterFuture ... done
[17:02:54.651] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.651] result() for ClusterFuture ... done
[17:02:54.651] result() for ClusterFuture ...
[17:02:54.651] - result already collected: FutureResult
[17:02:54.651] result() for ClusterFuture ... done
value(b) = 2
[17:02:54.651] result() for ClusterFuture ...
[17:02:54.651] - result already collected: FutureResult
[17:02:54.651] result() for ClusterFuture ... done
[17:02:54.651] result() for ClusterFuture ...
[17:02:54.652] - result already collected: FutureResult
[17:02:54.652] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.652] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.652] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:02:54.653] - globals found: [2] ‘{’, ‘pkg’
[17:02:54.653] Searching for globals ... DONE
[17:02:54.653] Resolving globals: TRUE
[17:02:54.653] Resolving any globals that are futures ...
[17:02:54.653] - globals: [2] ‘{’, ‘pkg’
[17:02:54.653] Resolving any globals that are futures ... DONE
[17:02:54.654] Resolving futures part of globals (recursively) ...
[17:02:54.654] resolve() on list ...
[17:02:54.654]  recursive: 99
[17:02:54.654]  length: 1
[17:02:54.654]  elements: ‘pkg’
[17:02:54.654]  length: 0 (resolved future 1)
[17:02:54.654] resolve() on list ... DONE
[17:02:54.655] - globals: [1] ‘pkg’
[17:02:54.655] Resolving futures part of globals (recursively) ... DONE
[17:02:54.655] The total size of the 1 globals is 112 bytes (112 bytes)
[17:02:54.655] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:02:54.655] - globals: [1] ‘pkg’
[17:02:54.655] 
[17:02:54.656] getGlobalsAndPackages() ... DONE
[17:02:54.656] Packages needed by the future expression (n = 0): <none>
[17:02:54.656] Packages needed by future strategies (n = 0): <none>
[17:02:54.656] {
[17:02:54.656]     {
[17:02:54.656]         {
[17:02:54.656]             ...future.startTime <- base::Sys.time()
[17:02:54.656]             {
[17:02:54.656]                 {
[17:02:54.656]                   {
[17:02:54.656]                     base::local({
[17:02:54.656]                       has_future <- base::requireNamespace("future", 
[17:02:54.656]                         quietly = TRUE)
[17:02:54.656]                       if (has_future) {
[17:02:54.656]                         ns <- base::getNamespace("future")
[17:02:54.656]                         version <- ns[[".package"]][["version"]]
[17:02:54.656]                         if (is.null(version)) 
[17:02:54.656]                           version <- utils::packageVersion("future")
[17:02:54.656]                       }
[17:02:54.656]                       else {
[17:02:54.656]                         version <- NULL
[17:02:54.656]                       }
[17:02:54.656]                       if (!has_future || version < "1.8.0") {
[17:02:54.656]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.656]                           "", base::R.version$version.string), 
[17:02:54.656]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:54.656]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.656]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.656]                             "release", "version")], collapse = " "), 
[17:02:54.656]                           hostname = base::Sys.info()[["nodename"]])
[17:02:54.656]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.656]                           info)
[17:02:54.656]                         info <- base::paste(info, collapse = "; ")
[17:02:54.656]                         if (!has_future) {
[17:02:54.656]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.656]                             info)
[17:02:54.656]                         }
[17:02:54.656]                         else {
[17:02:54.656]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.656]                             info, version)
[17:02:54.656]                         }
[17:02:54.656]                         base::stop(msg)
[17:02:54.656]                       }
[17:02:54.656]                     })
[17:02:54.656]                   }
[17:02:54.656]                   ...future.strategy.old <- future::plan("list")
[17:02:54.656]                   options(future.plan = NULL)
[17:02:54.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.656]                 }
[17:02:54.656]                 ...future.workdir <- getwd()
[17:02:54.656]             }
[17:02:54.656]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.656]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.656]         }
[17:02:54.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.656]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:02:54.656]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.656]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.656]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.656]             base::names(...future.oldOptions))
[17:02:54.656]     }
[17:02:54.656]     if (FALSE) {
[17:02:54.656]     }
[17:02:54.656]     else {
[17:02:54.656]         if (TRUE) {
[17:02:54.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.656]                 open = "w")
[17:02:54.656]         }
[17:02:54.656]         else {
[17:02:54.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.656]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.656]         }
[17:02:54.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.656]             base::sink(type = "output", split = FALSE)
[17:02:54.656]             base::close(...future.stdout)
[17:02:54.656]         }, add = TRUE)
[17:02:54.656]     }
[17:02:54.656]     ...future.frame <- base::sys.nframe()
[17:02:54.656]     ...future.conditions <- base::list()
[17:02:54.656]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.656]     if (FALSE) {
[17:02:54.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.656]     }
[17:02:54.656]     ...future.result <- base::tryCatch({
[17:02:54.656]         base::withCallingHandlers({
[17:02:54.656]             ...future.value <- base::withVisible(base::local({
[17:02:54.656]                 pkg
[17:02:54.656]             }))
[17:02:54.656]             future::FutureResult(value = ...future.value$value, 
[17:02:54.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.656]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.656]                     ...future.globalenv.names))
[17:02:54.656]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.656]         }, condition = base::local({
[17:02:54.656]             c <- base::c
[17:02:54.656]             inherits <- base::inherits
[17:02:54.656]             invokeRestart <- base::invokeRestart
[17:02:54.656]             length <- base::length
[17:02:54.656]             list <- base::list
[17:02:54.656]             seq.int <- base::seq.int
[17:02:54.656]             signalCondition <- base::signalCondition
[17:02:54.656]             sys.calls <- base::sys.calls
[17:02:54.656]             `[[` <- base::`[[`
[17:02:54.656]             `+` <- base::`+`
[17:02:54.656]             `<<-` <- base::`<<-`
[17:02:54.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.656]                   3L)]
[17:02:54.656]             }
[17:02:54.656]             function(cond) {
[17:02:54.656]                 is_error <- inherits(cond, "error")
[17:02:54.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.656]                   NULL)
[17:02:54.656]                 if (is_error) {
[17:02:54.656]                   sessionInformation <- function() {
[17:02:54.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.656]                       search = base::search(), system = base::Sys.info())
[17:02:54.656]                   }
[17:02:54.656]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.656]                     cond$call), session = sessionInformation(), 
[17:02:54.656]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.656]                   signalCondition(cond)
[17:02:54.656]                 }
[17:02:54.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.656]                 "immediateCondition"))) {
[17:02:54.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.656]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.656]                   if (TRUE && !signal) {
[17:02:54.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.656]                     {
[17:02:54.656]                       inherits <- base::inherits
[17:02:54.656]                       invokeRestart <- base::invokeRestart
[17:02:54.656]                       is.null <- base::is.null
[17:02:54.656]                       muffled <- FALSE
[17:02:54.656]                       if (inherits(cond, "message")) {
[17:02:54.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.656]                         if (muffled) 
[17:02:54.656]                           invokeRestart("muffleMessage")
[17:02:54.656]                       }
[17:02:54.656]                       else if (inherits(cond, "warning")) {
[17:02:54.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.656]                         if (muffled) 
[17:02:54.656]                           invokeRestart("muffleWarning")
[17:02:54.656]                       }
[17:02:54.656]                       else if (inherits(cond, "condition")) {
[17:02:54.656]                         if (!is.null(pattern)) {
[17:02:54.656]                           computeRestarts <- base::computeRestarts
[17:02:54.656]                           grepl <- base::grepl
[17:02:54.656]                           restarts <- computeRestarts(cond)
[17:02:54.656]                           for (restart in restarts) {
[17:02:54.656]                             name <- restart$name
[17:02:54.656]                             if (is.null(name)) 
[17:02:54.656]                               next
[17:02:54.656]                             if (!grepl(pattern, name)) 
[17:02:54.656]                               next
[17:02:54.656]                             invokeRestart(restart)
[17:02:54.656]                             muffled <- TRUE
[17:02:54.656]                             break
[17:02:54.656]                           }
[17:02:54.656]                         }
[17:02:54.656]                       }
[17:02:54.656]                       invisible(muffled)
[17:02:54.656]                     }
[17:02:54.656]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.656]                   }
[17:02:54.656]                 }
[17:02:54.656]                 else {
[17:02:54.656]                   if (TRUE) {
[17:02:54.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.656]                     {
[17:02:54.656]                       inherits <- base::inherits
[17:02:54.656]                       invokeRestart <- base::invokeRestart
[17:02:54.656]                       is.null <- base::is.null
[17:02:54.656]                       muffled <- FALSE
[17:02:54.656]                       if (inherits(cond, "message")) {
[17:02:54.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.656]                         if (muffled) 
[17:02:54.656]                           invokeRestart("muffleMessage")
[17:02:54.656]                       }
[17:02:54.656]                       else if (inherits(cond, "warning")) {
[17:02:54.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.656]                         if (muffled) 
[17:02:54.656]                           invokeRestart("muffleWarning")
[17:02:54.656]                       }
[17:02:54.656]                       else if (inherits(cond, "condition")) {
[17:02:54.656]                         if (!is.null(pattern)) {
[17:02:54.656]                           computeRestarts <- base::computeRestarts
[17:02:54.656]                           grepl <- base::grepl
[17:02:54.656]                           restarts <- computeRestarts(cond)
[17:02:54.656]                           for (restart in restarts) {
[17:02:54.656]                             name <- restart$name
[17:02:54.656]                             if (is.null(name)) 
[17:02:54.656]                               next
[17:02:54.656]                             if (!grepl(pattern, name)) 
[17:02:54.656]                               next
[17:02:54.656]                             invokeRestart(restart)
[17:02:54.656]                             muffled <- TRUE
[17:02:54.656]                             break
[17:02:54.656]                           }
[17:02:54.656]                         }
[17:02:54.656]                       }
[17:02:54.656]                       invisible(muffled)
[17:02:54.656]                     }
[17:02:54.656]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.656]                   }
[17:02:54.656]                 }
[17:02:54.656]             }
[17:02:54.656]         }))
[17:02:54.656]     }, error = function(ex) {
[17:02:54.656]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.656]                 ...future.rng), started = ...future.startTime, 
[17:02:54.656]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.656]             version = "1.8"), class = "FutureResult")
[17:02:54.656]     }, finally = {
[17:02:54.656]         if (!identical(...future.workdir, getwd())) 
[17:02:54.656]             setwd(...future.workdir)
[17:02:54.656]         {
[17:02:54.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.656]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.656]             }
[17:02:54.656]             base::options(...future.oldOptions)
[17:02:54.656]             if (.Platform$OS.type == "windows") {
[17:02:54.656]                 old_names <- names(...future.oldEnvVars)
[17:02:54.656]                 envs <- base::Sys.getenv()
[17:02:54.656]                 names <- names(envs)
[17:02:54.656]                 common <- intersect(names, old_names)
[17:02:54.656]                 added <- setdiff(names, old_names)
[17:02:54.656]                 removed <- setdiff(old_names, names)
[17:02:54.656]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.656]                   envs[common]]
[17:02:54.656]                 NAMES <- toupper(changed)
[17:02:54.656]                 args <- list()
[17:02:54.656]                 for (kk in seq_along(NAMES)) {
[17:02:54.656]                   name <- changed[[kk]]
[17:02:54.656]                   NAME <- NAMES[[kk]]
[17:02:54.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.656]                     next
[17:02:54.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.656]                 }
[17:02:54.656]                 NAMES <- toupper(added)
[17:02:54.656]                 for (kk in seq_along(NAMES)) {
[17:02:54.656]                   name <- added[[kk]]
[17:02:54.656]                   NAME <- NAMES[[kk]]
[17:02:54.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.656]                     next
[17:02:54.656]                   args[[name]] <- ""
[17:02:54.656]                 }
[17:02:54.656]                 NAMES <- toupper(removed)
[17:02:54.656]                 for (kk in seq_along(NAMES)) {
[17:02:54.656]                   name <- removed[[kk]]
[17:02:54.656]                   NAME <- NAMES[[kk]]
[17:02:54.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.656]                     next
[17:02:54.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.656]                 }
[17:02:54.656]                 if (length(args) > 0) 
[17:02:54.656]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.656]             }
[17:02:54.656]             else {
[17:02:54.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.656]             }
[17:02:54.656]             {
[17:02:54.656]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.656]                   0L) {
[17:02:54.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.656]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.656]                   base::options(opts)
[17:02:54.656]                 }
[17:02:54.656]                 {
[17:02:54.656]                   {
[17:02:54.656]                     NULL
[17:02:54.656]                     RNGkind("Mersenne-Twister")
[17:02:54.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:54.656]                       inherits = FALSE)
[17:02:54.656]                   }
[17:02:54.656]                   options(future.plan = NULL)
[17:02:54.656]                   if (is.na(NA_character_)) 
[17:02:54.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.656]                     .init = FALSE)
[17:02:54.656]                 }
[17:02:54.656]             }
[17:02:54.656]         }
[17:02:54.656]     })
[17:02:54.656]     if (TRUE) {
[17:02:54.656]         base::sink(type = "output", split = FALSE)
[17:02:54.656]         if (TRUE) {
[17:02:54.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.656]         }
[17:02:54.656]         else {
[17:02:54.656]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.656]         }
[17:02:54.656]         base::close(...future.stdout)
[17:02:54.656]         ...future.stdout <- NULL
[17:02:54.656]     }
[17:02:54.656]     ...future.result$conditions <- ...future.conditions
[17:02:54.656]     ...future.result$finished <- base::Sys.time()
[17:02:54.656]     ...future.result
[17:02:54.656] }
[17:02:54.658] assign_globals() ...
[17:02:54.658] List of 1
[17:02:54.658]  $ pkg: chr "foo"
[17:02:54.658]  - attr(*, "where")=List of 1
[17:02:54.658]   ..$ pkg:<environment: R_EmptyEnv> 
[17:02:54.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:54.658]  - attr(*, "resolved")= logi TRUE
[17:02:54.658]  - attr(*, "total_size")= num 112
[17:02:54.660] - copied ‘pkg’ to environment
[17:02:54.660] assign_globals() ... done
[17:02:54.661] plan(): Setting new future strategy stack:
[17:02:54.661] List of future strategies:
[17:02:54.661] 1. sequential:
[17:02:54.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:54.661]    - tweaked: FALSE
[17:02:54.661]    - call: NULL
[17:02:54.661] plan(): nbrOfWorkers() = 1
[17:02:54.662] plan(): Setting new future strategy stack:
[17:02:54.662] List of future strategies:
[17:02:54.662] 1. multisession:
[17:02:54.662]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:54.662]    - tweaked: FALSE
[17:02:54.662]    - call: plan(strategy)
[17:02:54.666] plan(): nbrOfWorkers() = 2
[17:02:54.666] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.667] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.667] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.669] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:54.669] Searching for globals ... DONE
[17:02:54.669] Resolving globals: TRUE
[17:02:54.669] Resolving any globals that are futures ...
[17:02:54.669] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:54.669] Resolving any globals that are futures ... DONE
[17:02:54.670] Resolving futures part of globals (recursively) ...
[17:02:54.670] resolve() on list ...
[17:02:54.670]  recursive: 99
[17:02:54.670]  length: 1
[17:02:54.670]  elements: ‘a’
[17:02:54.670]  length: 0 (resolved future 1)
[17:02:54.670] resolve() on list ... DONE
[17:02:54.671] - globals: [1] ‘a’
[17:02:54.671] Resolving futures part of globals (recursively) ... DONE
[17:02:54.671] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:54.671] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:02:54.671] - globals: [1] ‘a’
[17:02:54.671] 
[17:02:54.672] getGlobalsAndPackages() ... DONE
[17:02:54.672] run() for ‘Future’ ...
[17:02:54.672] - state: ‘created’
[17:02:54.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.686]   - Field: ‘node’
[17:02:54.686]   - Field: ‘label’
[17:02:54.686]   - Field: ‘local’
[17:02:54.686]   - Field: ‘owner’
[17:02:54.686]   - Field: ‘envir’
[17:02:54.686]   - Field: ‘workers’
[17:02:54.687]   - Field: ‘packages’
[17:02:54.687]   - Field: ‘gc’
[17:02:54.687]   - Field: ‘conditions’
[17:02:54.687]   - Field: ‘persistent’
[17:02:54.687]   - Field: ‘expr’
[17:02:54.687]   - Field: ‘uuid’
[17:02:54.687]   - Field: ‘seed’
[17:02:54.687]   - Field: ‘version’
[17:02:54.687]   - Field: ‘result’
[17:02:54.687]   - Field: ‘asynchronous’
[17:02:54.687]   - Field: ‘calls’
[17:02:54.688]   - Field: ‘globals’
[17:02:54.688]   - Field: ‘stdout’
[17:02:54.688]   - Field: ‘earlySignal’
[17:02:54.688]   - Field: ‘lazy’
[17:02:54.688]   - Field: ‘state’
[17:02:54.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.688] - Launch lazy future ...
[17:02:54.688] Packages needed by the future expression (n = 0): <none>
[17:02:54.689] Packages needed by future strategies (n = 0): <none>
[17:02:54.689] {
[17:02:54.689]     {
[17:02:54.689]         {
[17:02:54.689]             ...future.startTime <- base::Sys.time()
[17:02:54.689]             {
[17:02:54.689]                 {
[17:02:54.689]                   {
[17:02:54.689]                     {
[17:02:54.689]                       base::local({
[17:02:54.689]                         has_future <- base::requireNamespace("future", 
[17:02:54.689]                           quietly = TRUE)
[17:02:54.689]                         if (has_future) {
[17:02:54.689]                           ns <- base::getNamespace("future")
[17:02:54.689]                           version <- ns[[".package"]][["version"]]
[17:02:54.689]                           if (is.null(version)) 
[17:02:54.689]                             version <- utils::packageVersion("future")
[17:02:54.689]                         }
[17:02:54.689]                         else {
[17:02:54.689]                           version <- NULL
[17:02:54.689]                         }
[17:02:54.689]                         if (!has_future || version < "1.8.0") {
[17:02:54.689]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.689]                             "", base::R.version$version.string), 
[17:02:54.689]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.689]                               "release", "version")], collapse = " "), 
[17:02:54.689]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.689]                             info)
[17:02:54.689]                           info <- base::paste(info, collapse = "; ")
[17:02:54.689]                           if (!has_future) {
[17:02:54.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.689]                               info)
[17:02:54.689]                           }
[17:02:54.689]                           else {
[17:02:54.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.689]                               info, version)
[17:02:54.689]                           }
[17:02:54.689]                           base::stop(msg)
[17:02:54.689]                         }
[17:02:54.689]                       })
[17:02:54.689]                     }
[17:02:54.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.689]                     base::options(mc.cores = 1L)
[17:02:54.689]                   }
[17:02:54.689]                   ...future.strategy.old <- future::plan("list")
[17:02:54.689]                   options(future.plan = NULL)
[17:02:54.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.689]                 }
[17:02:54.689]                 ...future.workdir <- getwd()
[17:02:54.689]             }
[17:02:54.689]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.689]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.689]         }
[17:02:54.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.689]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:54.689]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.689]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.689]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.689]             base::names(...future.oldOptions))
[17:02:54.689]     }
[17:02:54.689]     if (FALSE) {
[17:02:54.689]     }
[17:02:54.689]     else {
[17:02:54.689]         if (TRUE) {
[17:02:54.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.689]                 open = "w")
[17:02:54.689]         }
[17:02:54.689]         else {
[17:02:54.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.689]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.689]         }
[17:02:54.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.689]             base::sink(type = "output", split = FALSE)
[17:02:54.689]             base::close(...future.stdout)
[17:02:54.689]         }, add = TRUE)
[17:02:54.689]     }
[17:02:54.689]     ...future.frame <- base::sys.nframe()
[17:02:54.689]     ...future.conditions <- base::list()
[17:02:54.689]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.689]     if (FALSE) {
[17:02:54.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.689]     }
[17:02:54.689]     ...future.result <- base::tryCatch({
[17:02:54.689]         base::withCallingHandlers({
[17:02:54.689]             ...future.value <- base::withVisible(base::local({
[17:02:54.689]                 ...future.makeSendCondition <- base::local({
[17:02:54.689]                   sendCondition <- NULL
[17:02:54.689]                   function(frame = 1L) {
[17:02:54.689]                     if (is.function(sendCondition)) 
[17:02:54.689]                       return(sendCondition)
[17:02:54.689]                     ns <- getNamespace("parallel")
[17:02:54.689]                     if (exists("sendData", mode = "function", 
[17:02:54.689]                       envir = ns)) {
[17:02:54.689]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.689]                         envir = ns)
[17:02:54.689]                       envir <- sys.frame(frame)
[17:02:54.689]                       master <- NULL
[17:02:54.689]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.689]                         !identical(envir, emptyenv())) {
[17:02:54.689]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.689]                           inherits = FALSE)) {
[17:02:54.689]                           master <- get("master", mode = "list", 
[17:02:54.689]                             envir = envir, inherits = FALSE)
[17:02:54.689]                           if (inherits(master, c("SOCKnode", 
[17:02:54.689]                             "SOCK0node"))) {
[17:02:54.689]                             sendCondition <<- function(cond) {
[17:02:54.689]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.689]                                 success = TRUE)
[17:02:54.689]                               parallel_sendData(master, data)
[17:02:54.689]                             }
[17:02:54.689]                             return(sendCondition)
[17:02:54.689]                           }
[17:02:54.689]                         }
[17:02:54.689]                         frame <- frame + 1L
[17:02:54.689]                         envir <- sys.frame(frame)
[17:02:54.689]                       }
[17:02:54.689]                     }
[17:02:54.689]                     sendCondition <<- function(cond) NULL
[17:02:54.689]                   }
[17:02:54.689]                 })
[17:02:54.689]                 withCallingHandlers({
[17:02:54.689]                   {
[17:02:54.689]                     b <- a
[17:02:54.689]                     a <- 2
[17:02:54.689]                     a * b
[17:02:54.689]                   }
[17:02:54.689]                 }, immediateCondition = function(cond) {
[17:02:54.689]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.689]                   sendCondition(cond)
[17:02:54.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.689]                   {
[17:02:54.689]                     inherits <- base::inherits
[17:02:54.689]                     invokeRestart <- base::invokeRestart
[17:02:54.689]                     is.null <- base::is.null
[17:02:54.689]                     muffled <- FALSE
[17:02:54.689]                     if (inherits(cond, "message")) {
[17:02:54.689]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.689]                       if (muffled) 
[17:02:54.689]                         invokeRestart("muffleMessage")
[17:02:54.689]                     }
[17:02:54.689]                     else if (inherits(cond, "warning")) {
[17:02:54.689]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.689]                       if (muffled) 
[17:02:54.689]                         invokeRestart("muffleWarning")
[17:02:54.689]                     }
[17:02:54.689]                     else if (inherits(cond, "condition")) {
[17:02:54.689]                       if (!is.null(pattern)) {
[17:02:54.689]                         computeRestarts <- base::computeRestarts
[17:02:54.689]                         grepl <- base::grepl
[17:02:54.689]                         restarts <- computeRestarts(cond)
[17:02:54.689]                         for (restart in restarts) {
[17:02:54.689]                           name <- restart$name
[17:02:54.689]                           if (is.null(name)) 
[17:02:54.689]                             next
[17:02:54.689]                           if (!grepl(pattern, name)) 
[17:02:54.689]                             next
[17:02:54.689]                           invokeRestart(restart)
[17:02:54.689]                           muffled <- TRUE
[17:02:54.689]                           break
[17:02:54.689]                         }
[17:02:54.689]                       }
[17:02:54.689]                     }
[17:02:54.689]                     invisible(muffled)
[17:02:54.689]                   }
[17:02:54.689]                   muffleCondition(cond)
[17:02:54.689]                 })
[17:02:54.689]             }))
[17:02:54.689]             future::FutureResult(value = ...future.value$value, 
[17:02:54.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.689]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.689]                     ...future.globalenv.names))
[17:02:54.689]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.689]         }, condition = base::local({
[17:02:54.689]             c <- base::c
[17:02:54.689]             inherits <- base::inherits
[17:02:54.689]             invokeRestart <- base::invokeRestart
[17:02:54.689]             length <- base::length
[17:02:54.689]             list <- base::list
[17:02:54.689]             seq.int <- base::seq.int
[17:02:54.689]             signalCondition <- base::signalCondition
[17:02:54.689]             sys.calls <- base::sys.calls
[17:02:54.689]             `[[` <- base::`[[`
[17:02:54.689]             `+` <- base::`+`
[17:02:54.689]             `<<-` <- base::`<<-`
[17:02:54.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.689]                   3L)]
[17:02:54.689]             }
[17:02:54.689]             function(cond) {
[17:02:54.689]                 is_error <- inherits(cond, "error")
[17:02:54.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.689]                   NULL)
[17:02:54.689]                 if (is_error) {
[17:02:54.689]                   sessionInformation <- function() {
[17:02:54.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.689]                       search = base::search(), system = base::Sys.info())
[17:02:54.689]                   }
[17:02:54.689]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.689]                     cond$call), session = sessionInformation(), 
[17:02:54.689]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.689]                   signalCondition(cond)
[17:02:54.689]                 }
[17:02:54.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.689]                 "immediateCondition"))) {
[17:02:54.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.689]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.689]                   if (TRUE && !signal) {
[17:02:54.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.689]                     {
[17:02:54.689]                       inherits <- base::inherits
[17:02:54.689]                       invokeRestart <- base::invokeRestart
[17:02:54.689]                       is.null <- base::is.null
[17:02:54.689]                       muffled <- FALSE
[17:02:54.689]                       if (inherits(cond, "message")) {
[17:02:54.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.689]                         if (muffled) 
[17:02:54.689]                           invokeRestart("muffleMessage")
[17:02:54.689]                       }
[17:02:54.689]                       else if (inherits(cond, "warning")) {
[17:02:54.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.689]                         if (muffled) 
[17:02:54.689]                           invokeRestart("muffleWarning")
[17:02:54.689]                       }
[17:02:54.689]                       else if (inherits(cond, "condition")) {
[17:02:54.689]                         if (!is.null(pattern)) {
[17:02:54.689]                           computeRestarts <- base::computeRestarts
[17:02:54.689]                           grepl <- base::grepl
[17:02:54.689]                           restarts <- computeRestarts(cond)
[17:02:54.689]                           for (restart in restarts) {
[17:02:54.689]                             name <- restart$name
[17:02:54.689]                             if (is.null(name)) 
[17:02:54.689]                               next
[17:02:54.689]                             if (!grepl(pattern, name)) 
[17:02:54.689]                               next
[17:02:54.689]                             invokeRestart(restart)
[17:02:54.689]                             muffled <- TRUE
[17:02:54.689]                             break
[17:02:54.689]                           }
[17:02:54.689]                         }
[17:02:54.689]                       }
[17:02:54.689]                       invisible(muffled)
[17:02:54.689]                     }
[17:02:54.689]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.689]                   }
[17:02:54.689]                 }
[17:02:54.689]                 else {
[17:02:54.689]                   if (TRUE) {
[17:02:54.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.689]                     {
[17:02:54.689]                       inherits <- base::inherits
[17:02:54.689]                       invokeRestart <- base::invokeRestart
[17:02:54.689]                       is.null <- base::is.null
[17:02:54.689]                       muffled <- FALSE
[17:02:54.689]                       if (inherits(cond, "message")) {
[17:02:54.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.689]                         if (muffled) 
[17:02:54.689]                           invokeRestart("muffleMessage")
[17:02:54.689]                       }
[17:02:54.689]                       else if (inherits(cond, "warning")) {
[17:02:54.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.689]                         if (muffled) 
[17:02:54.689]                           invokeRestart("muffleWarning")
[17:02:54.689]                       }
[17:02:54.689]                       else if (inherits(cond, "condition")) {
[17:02:54.689]                         if (!is.null(pattern)) {
[17:02:54.689]                           computeRestarts <- base::computeRestarts
[17:02:54.689]                           grepl <- base::grepl
[17:02:54.689]                           restarts <- computeRestarts(cond)
[17:02:54.689]                           for (restart in restarts) {
[17:02:54.689]                             name <- restart$name
[17:02:54.689]                             if (is.null(name)) 
[17:02:54.689]                               next
[17:02:54.689]                             if (!grepl(pattern, name)) 
[17:02:54.689]                               next
[17:02:54.689]                             invokeRestart(restart)
[17:02:54.689]                             muffled <- TRUE
[17:02:54.689]                             break
[17:02:54.689]                           }
[17:02:54.689]                         }
[17:02:54.689]                       }
[17:02:54.689]                       invisible(muffled)
[17:02:54.689]                     }
[17:02:54.689]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.689]                   }
[17:02:54.689]                 }
[17:02:54.689]             }
[17:02:54.689]         }))
[17:02:54.689]     }, error = function(ex) {
[17:02:54.689]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.689]                 ...future.rng), started = ...future.startTime, 
[17:02:54.689]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.689]             version = "1.8"), class = "FutureResult")
[17:02:54.689]     }, finally = {
[17:02:54.689]         if (!identical(...future.workdir, getwd())) 
[17:02:54.689]             setwd(...future.workdir)
[17:02:54.689]         {
[17:02:54.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.689]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.689]             }
[17:02:54.689]             base::options(...future.oldOptions)
[17:02:54.689]             if (.Platform$OS.type == "windows") {
[17:02:54.689]                 old_names <- names(...future.oldEnvVars)
[17:02:54.689]                 envs <- base::Sys.getenv()
[17:02:54.689]                 names <- names(envs)
[17:02:54.689]                 common <- intersect(names, old_names)
[17:02:54.689]                 added <- setdiff(names, old_names)
[17:02:54.689]                 removed <- setdiff(old_names, names)
[17:02:54.689]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.689]                   envs[common]]
[17:02:54.689]                 NAMES <- toupper(changed)
[17:02:54.689]                 args <- list()
[17:02:54.689]                 for (kk in seq_along(NAMES)) {
[17:02:54.689]                   name <- changed[[kk]]
[17:02:54.689]                   NAME <- NAMES[[kk]]
[17:02:54.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.689]                     next
[17:02:54.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.689]                 }
[17:02:54.689]                 NAMES <- toupper(added)
[17:02:54.689]                 for (kk in seq_along(NAMES)) {
[17:02:54.689]                   name <- added[[kk]]
[17:02:54.689]                   NAME <- NAMES[[kk]]
[17:02:54.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.689]                     next
[17:02:54.689]                   args[[name]] <- ""
[17:02:54.689]                 }
[17:02:54.689]                 NAMES <- toupper(removed)
[17:02:54.689]                 for (kk in seq_along(NAMES)) {
[17:02:54.689]                   name <- removed[[kk]]
[17:02:54.689]                   NAME <- NAMES[[kk]]
[17:02:54.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.689]                     next
[17:02:54.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.689]                 }
[17:02:54.689]                 if (length(args) > 0) 
[17:02:54.689]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.689]             }
[17:02:54.689]             else {
[17:02:54.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.689]             }
[17:02:54.689]             {
[17:02:54.689]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.689]                   0L) {
[17:02:54.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.689]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.689]                   base::options(opts)
[17:02:54.689]                 }
[17:02:54.689]                 {
[17:02:54.689]                   {
[17:02:54.689]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.689]                     NULL
[17:02:54.689]                   }
[17:02:54.689]                   options(future.plan = NULL)
[17:02:54.689]                   if (is.na(NA_character_)) 
[17:02:54.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.689]                     .init = FALSE)
[17:02:54.689]                 }
[17:02:54.689]             }
[17:02:54.689]         }
[17:02:54.689]     })
[17:02:54.689]     if (TRUE) {
[17:02:54.689]         base::sink(type = "output", split = FALSE)
[17:02:54.689]         if (TRUE) {
[17:02:54.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.689]         }
[17:02:54.689]         else {
[17:02:54.689]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.689]         }
[17:02:54.689]         base::close(...future.stdout)
[17:02:54.689]         ...future.stdout <- NULL
[17:02:54.689]     }
[17:02:54.689]     ...future.result$conditions <- ...future.conditions
[17:02:54.689]     ...future.result$finished <- base::Sys.time()
[17:02:54.689]     ...future.result
[17:02:54.689] }
[17:02:54.692] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:02:54.692] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:02:54.692] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:02:54.692] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:02:54.693] MultisessionFuture started
[17:02:54.693] - Launch lazy future ... done
[17:02:54.693] run() for ‘MultisessionFuture’ ... done
[17:02:54.693] result() for ClusterFuture ...
[17:02:54.693] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.693] - Validating connection of MultisessionFuture
[17:02:54.737] - received message: FutureResult
[17:02:54.738] - Received FutureResult
[17:02:54.738] - Erased future from FutureRegistry
[17:02:54.738] result() for ClusterFuture ...
[17:02:54.738] - result already collected: FutureResult
[17:02:54.738] result() for ClusterFuture ... done
[17:02:54.738] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.738] result() for ClusterFuture ... done
[17:02:54.738] result() for ClusterFuture ...
[17:02:54.738] - result already collected: FutureResult
[17:02:54.738] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.739] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.739] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.741] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:54.741] Searching for globals ... DONE
[17:02:54.741] Resolving globals: TRUE
[17:02:54.741] Resolving any globals that are futures ...
[17:02:54.741] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:02:54.742] Resolving any globals that are futures ... DONE
[17:02:54.742] Resolving futures part of globals (recursively) ...
[17:02:54.742] resolve() on list ...
[17:02:54.742]  recursive: 99
[17:02:54.742]  length: 1
[17:02:54.742]  elements: ‘a’
[17:02:54.743]  length: 0 (resolved future 1)
[17:02:54.743] resolve() on list ... DONE
[17:02:54.743] - globals: [1] ‘a’
[17:02:54.743] Resolving futures part of globals (recursively) ... DONE
[17:02:54.743] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:54.743] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:02:54.743] - globals: [1] ‘a’
[17:02:54.744] 
[17:02:54.744] getGlobalsAndPackages() ... DONE
[17:02:54.744] run() for ‘Future’ ...
[17:02:54.744] - state: ‘created’
[17:02:54.744] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.758] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.759]   - Field: ‘node’
[17:02:54.759]   - Field: ‘label’
[17:02:54.759]   - Field: ‘local’
[17:02:54.759]   - Field: ‘owner’
[17:02:54.759]   - Field: ‘envir’
[17:02:54.759]   - Field: ‘workers’
[17:02:54.759]   - Field: ‘packages’
[17:02:54.759]   - Field: ‘gc’
[17:02:54.760]   - Field: ‘conditions’
[17:02:54.760]   - Field: ‘persistent’
[17:02:54.760]   - Field: ‘expr’
[17:02:54.760]   - Field: ‘uuid’
[17:02:54.760]   - Field: ‘seed’
[17:02:54.760]   - Field: ‘version’
[17:02:54.760]   - Field: ‘result’
[17:02:54.760]   - Field: ‘asynchronous’
[17:02:54.760]   - Field: ‘calls’
[17:02:54.760]   - Field: ‘globals’
[17:02:54.761]   - Field: ‘stdout’
[17:02:54.761]   - Field: ‘earlySignal’
[17:02:54.761]   - Field: ‘lazy’
[17:02:54.761]   - Field: ‘state’
[17:02:54.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.761] - Launch lazy future ...
[17:02:54.761] Packages needed by the future expression (n = 0): <none>
[17:02:54.761] Packages needed by future strategies (n = 0): <none>
[17:02:54.762] {
[17:02:54.762]     {
[17:02:54.762]         {
[17:02:54.762]             ...future.startTime <- base::Sys.time()
[17:02:54.762]             {
[17:02:54.762]                 {
[17:02:54.762]                   {
[17:02:54.762]                     {
[17:02:54.762]                       base::local({
[17:02:54.762]                         has_future <- base::requireNamespace("future", 
[17:02:54.762]                           quietly = TRUE)
[17:02:54.762]                         if (has_future) {
[17:02:54.762]                           ns <- base::getNamespace("future")
[17:02:54.762]                           version <- ns[[".package"]][["version"]]
[17:02:54.762]                           if (is.null(version)) 
[17:02:54.762]                             version <- utils::packageVersion("future")
[17:02:54.762]                         }
[17:02:54.762]                         else {
[17:02:54.762]                           version <- NULL
[17:02:54.762]                         }
[17:02:54.762]                         if (!has_future || version < "1.8.0") {
[17:02:54.762]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.762]                             "", base::R.version$version.string), 
[17:02:54.762]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.762]                               "release", "version")], collapse = " "), 
[17:02:54.762]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.762]                             info)
[17:02:54.762]                           info <- base::paste(info, collapse = "; ")
[17:02:54.762]                           if (!has_future) {
[17:02:54.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.762]                               info)
[17:02:54.762]                           }
[17:02:54.762]                           else {
[17:02:54.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.762]                               info, version)
[17:02:54.762]                           }
[17:02:54.762]                           base::stop(msg)
[17:02:54.762]                         }
[17:02:54.762]                       })
[17:02:54.762]                     }
[17:02:54.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.762]                     base::options(mc.cores = 1L)
[17:02:54.762]                   }
[17:02:54.762]                   ...future.strategy.old <- future::plan("list")
[17:02:54.762]                   options(future.plan = NULL)
[17:02:54.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.762]                 }
[17:02:54.762]                 ...future.workdir <- getwd()
[17:02:54.762]             }
[17:02:54.762]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.762]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.762]         }
[17:02:54.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.762]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:54.762]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.762]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.762]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.762]             base::names(...future.oldOptions))
[17:02:54.762]     }
[17:02:54.762]     if (FALSE) {
[17:02:54.762]     }
[17:02:54.762]     else {
[17:02:54.762]         if (TRUE) {
[17:02:54.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.762]                 open = "w")
[17:02:54.762]         }
[17:02:54.762]         else {
[17:02:54.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.762]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.762]         }
[17:02:54.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.762]             base::sink(type = "output", split = FALSE)
[17:02:54.762]             base::close(...future.stdout)
[17:02:54.762]         }, add = TRUE)
[17:02:54.762]     }
[17:02:54.762]     ...future.frame <- base::sys.nframe()
[17:02:54.762]     ...future.conditions <- base::list()
[17:02:54.762]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.762]     if (FALSE) {
[17:02:54.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.762]     }
[17:02:54.762]     ...future.result <- base::tryCatch({
[17:02:54.762]         base::withCallingHandlers({
[17:02:54.762]             ...future.value <- base::withVisible(base::local({
[17:02:54.762]                 ...future.makeSendCondition <- base::local({
[17:02:54.762]                   sendCondition <- NULL
[17:02:54.762]                   function(frame = 1L) {
[17:02:54.762]                     if (is.function(sendCondition)) 
[17:02:54.762]                       return(sendCondition)
[17:02:54.762]                     ns <- getNamespace("parallel")
[17:02:54.762]                     if (exists("sendData", mode = "function", 
[17:02:54.762]                       envir = ns)) {
[17:02:54.762]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.762]                         envir = ns)
[17:02:54.762]                       envir <- sys.frame(frame)
[17:02:54.762]                       master <- NULL
[17:02:54.762]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.762]                         !identical(envir, emptyenv())) {
[17:02:54.762]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.762]                           inherits = FALSE)) {
[17:02:54.762]                           master <- get("master", mode = "list", 
[17:02:54.762]                             envir = envir, inherits = FALSE)
[17:02:54.762]                           if (inherits(master, c("SOCKnode", 
[17:02:54.762]                             "SOCK0node"))) {
[17:02:54.762]                             sendCondition <<- function(cond) {
[17:02:54.762]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.762]                                 success = TRUE)
[17:02:54.762]                               parallel_sendData(master, data)
[17:02:54.762]                             }
[17:02:54.762]                             return(sendCondition)
[17:02:54.762]                           }
[17:02:54.762]                         }
[17:02:54.762]                         frame <- frame + 1L
[17:02:54.762]                         envir <- sys.frame(frame)
[17:02:54.762]                       }
[17:02:54.762]                     }
[17:02:54.762]                     sendCondition <<- function(cond) NULL
[17:02:54.762]                   }
[17:02:54.762]                 })
[17:02:54.762]                 withCallingHandlers({
[17:02:54.762]                   {
[17:02:54.762]                     b <- a
[17:02:54.762]                     a <- 2
[17:02:54.762]                     a * b
[17:02:54.762]                   }
[17:02:54.762]                 }, immediateCondition = function(cond) {
[17:02:54.762]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.762]                   sendCondition(cond)
[17:02:54.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.762]                   {
[17:02:54.762]                     inherits <- base::inherits
[17:02:54.762]                     invokeRestart <- base::invokeRestart
[17:02:54.762]                     is.null <- base::is.null
[17:02:54.762]                     muffled <- FALSE
[17:02:54.762]                     if (inherits(cond, "message")) {
[17:02:54.762]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.762]                       if (muffled) 
[17:02:54.762]                         invokeRestart("muffleMessage")
[17:02:54.762]                     }
[17:02:54.762]                     else if (inherits(cond, "warning")) {
[17:02:54.762]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.762]                       if (muffled) 
[17:02:54.762]                         invokeRestart("muffleWarning")
[17:02:54.762]                     }
[17:02:54.762]                     else if (inherits(cond, "condition")) {
[17:02:54.762]                       if (!is.null(pattern)) {
[17:02:54.762]                         computeRestarts <- base::computeRestarts
[17:02:54.762]                         grepl <- base::grepl
[17:02:54.762]                         restarts <- computeRestarts(cond)
[17:02:54.762]                         for (restart in restarts) {
[17:02:54.762]                           name <- restart$name
[17:02:54.762]                           if (is.null(name)) 
[17:02:54.762]                             next
[17:02:54.762]                           if (!grepl(pattern, name)) 
[17:02:54.762]                             next
[17:02:54.762]                           invokeRestart(restart)
[17:02:54.762]                           muffled <- TRUE
[17:02:54.762]                           break
[17:02:54.762]                         }
[17:02:54.762]                       }
[17:02:54.762]                     }
[17:02:54.762]                     invisible(muffled)
[17:02:54.762]                   }
[17:02:54.762]                   muffleCondition(cond)
[17:02:54.762]                 })
[17:02:54.762]             }))
[17:02:54.762]             future::FutureResult(value = ...future.value$value, 
[17:02:54.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.762]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.762]                     ...future.globalenv.names))
[17:02:54.762]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.762]         }, condition = base::local({
[17:02:54.762]             c <- base::c
[17:02:54.762]             inherits <- base::inherits
[17:02:54.762]             invokeRestart <- base::invokeRestart
[17:02:54.762]             length <- base::length
[17:02:54.762]             list <- base::list
[17:02:54.762]             seq.int <- base::seq.int
[17:02:54.762]             signalCondition <- base::signalCondition
[17:02:54.762]             sys.calls <- base::sys.calls
[17:02:54.762]             `[[` <- base::`[[`
[17:02:54.762]             `+` <- base::`+`
[17:02:54.762]             `<<-` <- base::`<<-`
[17:02:54.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.762]                   3L)]
[17:02:54.762]             }
[17:02:54.762]             function(cond) {
[17:02:54.762]                 is_error <- inherits(cond, "error")
[17:02:54.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.762]                   NULL)
[17:02:54.762]                 if (is_error) {
[17:02:54.762]                   sessionInformation <- function() {
[17:02:54.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.762]                       search = base::search(), system = base::Sys.info())
[17:02:54.762]                   }
[17:02:54.762]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.762]                     cond$call), session = sessionInformation(), 
[17:02:54.762]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.762]                   signalCondition(cond)
[17:02:54.762]                 }
[17:02:54.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.762]                 "immediateCondition"))) {
[17:02:54.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.762]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.762]                   if (TRUE && !signal) {
[17:02:54.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.762]                     {
[17:02:54.762]                       inherits <- base::inherits
[17:02:54.762]                       invokeRestart <- base::invokeRestart
[17:02:54.762]                       is.null <- base::is.null
[17:02:54.762]                       muffled <- FALSE
[17:02:54.762]                       if (inherits(cond, "message")) {
[17:02:54.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.762]                         if (muffled) 
[17:02:54.762]                           invokeRestart("muffleMessage")
[17:02:54.762]                       }
[17:02:54.762]                       else if (inherits(cond, "warning")) {
[17:02:54.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.762]                         if (muffled) 
[17:02:54.762]                           invokeRestart("muffleWarning")
[17:02:54.762]                       }
[17:02:54.762]                       else if (inherits(cond, "condition")) {
[17:02:54.762]                         if (!is.null(pattern)) {
[17:02:54.762]                           computeRestarts <- base::computeRestarts
[17:02:54.762]                           grepl <- base::grepl
[17:02:54.762]                           restarts <- computeRestarts(cond)
[17:02:54.762]                           for (restart in restarts) {
[17:02:54.762]                             name <- restart$name
[17:02:54.762]                             if (is.null(name)) 
[17:02:54.762]                               next
[17:02:54.762]                             if (!grepl(pattern, name)) 
[17:02:54.762]                               next
[17:02:54.762]                             invokeRestart(restart)
[17:02:54.762]                             muffled <- TRUE
[17:02:54.762]                             break
[17:02:54.762]                           }
[17:02:54.762]                         }
[17:02:54.762]                       }
[17:02:54.762]                       invisible(muffled)
[17:02:54.762]                     }
[17:02:54.762]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.762]                   }
[17:02:54.762]                 }
[17:02:54.762]                 else {
[17:02:54.762]                   if (TRUE) {
[17:02:54.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.762]                     {
[17:02:54.762]                       inherits <- base::inherits
[17:02:54.762]                       invokeRestart <- base::invokeRestart
[17:02:54.762]                       is.null <- base::is.null
[17:02:54.762]                       muffled <- FALSE
[17:02:54.762]                       if (inherits(cond, "message")) {
[17:02:54.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.762]                         if (muffled) 
[17:02:54.762]                           invokeRestart("muffleMessage")
[17:02:54.762]                       }
[17:02:54.762]                       else if (inherits(cond, "warning")) {
[17:02:54.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.762]                         if (muffled) 
[17:02:54.762]                           invokeRestart("muffleWarning")
[17:02:54.762]                       }
[17:02:54.762]                       else if (inherits(cond, "condition")) {
[17:02:54.762]                         if (!is.null(pattern)) {
[17:02:54.762]                           computeRestarts <- base::computeRestarts
[17:02:54.762]                           grepl <- base::grepl
[17:02:54.762]                           restarts <- computeRestarts(cond)
[17:02:54.762]                           for (restart in restarts) {
[17:02:54.762]                             name <- restart$name
[17:02:54.762]                             if (is.null(name)) 
[17:02:54.762]                               next
[17:02:54.762]                             if (!grepl(pattern, name)) 
[17:02:54.762]                               next
[17:02:54.762]                             invokeRestart(restart)
[17:02:54.762]                             muffled <- TRUE
[17:02:54.762]                             break
[17:02:54.762]                           }
[17:02:54.762]                         }
[17:02:54.762]                       }
[17:02:54.762]                       invisible(muffled)
[17:02:54.762]                     }
[17:02:54.762]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.762]                   }
[17:02:54.762]                 }
[17:02:54.762]             }
[17:02:54.762]         }))
[17:02:54.762]     }, error = function(ex) {
[17:02:54.762]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.762]                 ...future.rng), started = ...future.startTime, 
[17:02:54.762]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.762]             version = "1.8"), class = "FutureResult")
[17:02:54.762]     }, finally = {
[17:02:54.762]         if (!identical(...future.workdir, getwd())) 
[17:02:54.762]             setwd(...future.workdir)
[17:02:54.762]         {
[17:02:54.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.762]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.762]             }
[17:02:54.762]             base::options(...future.oldOptions)
[17:02:54.762]             if (.Platform$OS.type == "windows") {
[17:02:54.762]                 old_names <- names(...future.oldEnvVars)
[17:02:54.762]                 envs <- base::Sys.getenv()
[17:02:54.762]                 names <- names(envs)
[17:02:54.762]                 common <- intersect(names, old_names)
[17:02:54.762]                 added <- setdiff(names, old_names)
[17:02:54.762]                 removed <- setdiff(old_names, names)
[17:02:54.762]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.762]                   envs[common]]
[17:02:54.762]                 NAMES <- toupper(changed)
[17:02:54.762]                 args <- list()
[17:02:54.762]                 for (kk in seq_along(NAMES)) {
[17:02:54.762]                   name <- changed[[kk]]
[17:02:54.762]                   NAME <- NAMES[[kk]]
[17:02:54.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.762]                     next
[17:02:54.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.762]                 }
[17:02:54.762]                 NAMES <- toupper(added)
[17:02:54.762]                 for (kk in seq_along(NAMES)) {
[17:02:54.762]                   name <- added[[kk]]
[17:02:54.762]                   NAME <- NAMES[[kk]]
[17:02:54.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.762]                     next
[17:02:54.762]                   args[[name]] <- ""
[17:02:54.762]                 }
[17:02:54.762]                 NAMES <- toupper(removed)
[17:02:54.762]                 for (kk in seq_along(NAMES)) {
[17:02:54.762]                   name <- removed[[kk]]
[17:02:54.762]                   NAME <- NAMES[[kk]]
[17:02:54.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.762]                     next
[17:02:54.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.762]                 }
[17:02:54.762]                 if (length(args) > 0) 
[17:02:54.762]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.762]             }
[17:02:54.762]             else {
[17:02:54.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.762]             }
[17:02:54.762]             {
[17:02:54.762]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.762]                   0L) {
[17:02:54.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.762]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.762]                   base::options(opts)
[17:02:54.762]                 }
[17:02:54.762]                 {
[17:02:54.762]                   {
[17:02:54.762]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.762]                     NULL
[17:02:54.762]                   }
[17:02:54.762]                   options(future.plan = NULL)
[17:02:54.762]                   if (is.na(NA_character_)) 
[17:02:54.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.762]                     .init = FALSE)
[17:02:54.762]                 }
[17:02:54.762]             }
[17:02:54.762]         }
[17:02:54.762]     })
[17:02:54.762]     if (TRUE) {
[17:02:54.762]         base::sink(type = "output", split = FALSE)
[17:02:54.762]         if (TRUE) {
[17:02:54.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.762]         }
[17:02:54.762]         else {
[17:02:54.762]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.762]         }
[17:02:54.762]         base::close(...future.stdout)
[17:02:54.762]         ...future.stdout <- NULL
[17:02:54.762]     }
[17:02:54.762]     ...future.result$conditions <- ...future.conditions
[17:02:54.762]     ...future.result$finished <- base::Sys.time()
[17:02:54.762]     ...future.result
[17:02:54.762] }
[17:02:54.764] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:02:54.765] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:02:54.765] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:02:54.765] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:02:54.766] MultisessionFuture started
[17:02:54.766] - Launch lazy future ... done
[17:02:54.766] run() for ‘MultisessionFuture’ ... done
[17:02:54.766] result() for ClusterFuture ...
[17:02:54.766] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.766] - Validating connection of MultisessionFuture
[17:02:54.809] - received message: FutureResult
[17:02:54.810] - Received FutureResult
[17:02:54.810] - Erased future from FutureRegistry
[17:02:54.810] result() for ClusterFuture ...
[17:02:54.810] - result already collected: FutureResult
[17:02:54.810] result() for ClusterFuture ... done
[17:02:54.810] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.810] result() for ClusterFuture ... done
[17:02:54.810] result() for ClusterFuture ...
[17:02:54.810] - result already collected: FutureResult
[17:02:54.810] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.811] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.811] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.813] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.813] Searching for globals ... DONE
[17:02:54.813] Resolving globals: TRUE
[17:02:54.814] Resolving any globals that are futures ...
[17:02:54.814] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.814] Resolving any globals that are futures ... DONE
[17:02:54.814] Resolving futures part of globals (recursively) ...
[17:02:54.814] resolve() on list ...
[17:02:54.814]  recursive: 99
[17:02:54.815]  length: 2
[17:02:54.815]  elements: ‘a’, ‘ii’
[17:02:54.815]  length: 1 (resolved future 1)
[17:02:54.815]  length: 0 (resolved future 2)
[17:02:54.815] resolve() on list ... DONE
[17:02:54.815] - globals: [2] ‘a’, ‘ii’
[17:02:54.815] Resolving futures part of globals (recursively) ... DONE
[17:02:54.815] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:54.816] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:54.816] - globals: [2] ‘a’, ‘ii’
[17:02:54.816] 
[17:02:54.816] getGlobalsAndPackages() ... DONE
[17:02:54.816] run() for ‘Future’ ...
[17:02:54.816] - state: ‘created’
[17:02:54.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.830] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.831]   - Field: ‘node’
[17:02:54.831]   - Field: ‘label’
[17:02:54.831]   - Field: ‘local’
[17:02:54.831]   - Field: ‘owner’
[17:02:54.831]   - Field: ‘envir’
[17:02:54.831]   - Field: ‘workers’
[17:02:54.831]   - Field: ‘packages’
[17:02:54.831]   - Field: ‘gc’
[17:02:54.831]   - Field: ‘conditions’
[17:02:54.831]   - Field: ‘persistent’
[17:02:54.832]   - Field: ‘expr’
[17:02:54.832]   - Field: ‘uuid’
[17:02:54.832]   - Field: ‘seed’
[17:02:54.832]   - Field: ‘version’
[17:02:54.832]   - Field: ‘result’
[17:02:54.832]   - Field: ‘asynchronous’
[17:02:54.832]   - Field: ‘calls’
[17:02:54.832]   - Field: ‘globals’
[17:02:54.834]   - Field: ‘stdout’
[17:02:54.835]   - Field: ‘earlySignal’
[17:02:54.835]   - Field: ‘lazy’
[17:02:54.835]   - Field: ‘state’
[17:02:54.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.835] - Launch lazy future ...
[17:02:54.835] Packages needed by the future expression (n = 0): <none>
[17:02:54.835] Packages needed by future strategies (n = 0): <none>
[17:02:54.836] {
[17:02:54.836]     {
[17:02:54.836]         {
[17:02:54.836]             ...future.startTime <- base::Sys.time()
[17:02:54.836]             {
[17:02:54.836]                 {
[17:02:54.836]                   {
[17:02:54.836]                     {
[17:02:54.836]                       base::local({
[17:02:54.836]                         has_future <- base::requireNamespace("future", 
[17:02:54.836]                           quietly = TRUE)
[17:02:54.836]                         if (has_future) {
[17:02:54.836]                           ns <- base::getNamespace("future")
[17:02:54.836]                           version <- ns[[".package"]][["version"]]
[17:02:54.836]                           if (is.null(version)) 
[17:02:54.836]                             version <- utils::packageVersion("future")
[17:02:54.836]                         }
[17:02:54.836]                         else {
[17:02:54.836]                           version <- NULL
[17:02:54.836]                         }
[17:02:54.836]                         if (!has_future || version < "1.8.0") {
[17:02:54.836]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.836]                             "", base::R.version$version.string), 
[17:02:54.836]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.836]                               "release", "version")], collapse = " "), 
[17:02:54.836]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.836]                             info)
[17:02:54.836]                           info <- base::paste(info, collapse = "; ")
[17:02:54.836]                           if (!has_future) {
[17:02:54.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.836]                               info)
[17:02:54.836]                           }
[17:02:54.836]                           else {
[17:02:54.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.836]                               info, version)
[17:02:54.836]                           }
[17:02:54.836]                           base::stop(msg)
[17:02:54.836]                         }
[17:02:54.836]                       })
[17:02:54.836]                     }
[17:02:54.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.836]                     base::options(mc.cores = 1L)
[17:02:54.836]                   }
[17:02:54.836]                   ...future.strategy.old <- future::plan("list")
[17:02:54.836]                   options(future.plan = NULL)
[17:02:54.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.836]                 }
[17:02:54.836]                 ...future.workdir <- getwd()
[17:02:54.836]             }
[17:02:54.836]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.836]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.836]         }
[17:02:54.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.836]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:54.836]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.836]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.836]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.836]             base::names(...future.oldOptions))
[17:02:54.836]     }
[17:02:54.836]     if (FALSE) {
[17:02:54.836]     }
[17:02:54.836]     else {
[17:02:54.836]         if (TRUE) {
[17:02:54.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.836]                 open = "w")
[17:02:54.836]         }
[17:02:54.836]         else {
[17:02:54.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.836]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.836]         }
[17:02:54.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.836]             base::sink(type = "output", split = FALSE)
[17:02:54.836]             base::close(...future.stdout)
[17:02:54.836]         }, add = TRUE)
[17:02:54.836]     }
[17:02:54.836]     ...future.frame <- base::sys.nframe()
[17:02:54.836]     ...future.conditions <- base::list()
[17:02:54.836]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.836]     if (FALSE) {
[17:02:54.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.836]     }
[17:02:54.836]     ...future.result <- base::tryCatch({
[17:02:54.836]         base::withCallingHandlers({
[17:02:54.836]             ...future.value <- base::withVisible(base::local({
[17:02:54.836]                 ...future.makeSendCondition <- base::local({
[17:02:54.836]                   sendCondition <- NULL
[17:02:54.836]                   function(frame = 1L) {
[17:02:54.836]                     if (is.function(sendCondition)) 
[17:02:54.836]                       return(sendCondition)
[17:02:54.836]                     ns <- getNamespace("parallel")
[17:02:54.836]                     if (exists("sendData", mode = "function", 
[17:02:54.836]                       envir = ns)) {
[17:02:54.836]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.836]                         envir = ns)
[17:02:54.836]                       envir <- sys.frame(frame)
[17:02:54.836]                       master <- NULL
[17:02:54.836]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.836]                         !identical(envir, emptyenv())) {
[17:02:54.836]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.836]                           inherits = FALSE)) {
[17:02:54.836]                           master <- get("master", mode = "list", 
[17:02:54.836]                             envir = envir, inherits = FALSE)
[17:02:54.836]                           if (inherits(master, c("SOCKnode", 
[17:02:54.836]                             "SOCK0node"))) {
[17:02:54.836]                             sendCondition <<- function(cond) {
[17:02:54.836]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.836]                                 success = TRUE)
[17:02:54.836]                               parallel_sendData(master, data)
[17:02:54.836]                             }
[17:02:54.836]                             return(sendCondition)
[17:02:54.836]                           }
[17:02:54.836]                         }
[17:02:54.836]                         frame <- frame + 1L
[17:02:54.836]                         envir <- sys.frame(frame)
[17:02:54.836]                       }
[17:02:54.836]                     }
[17:02:54.836]                     sendCondition <<- function(cond) NULL
[17:02:54.836]                   }
[17:02:54.836]                 })
[17:02:54.836]                 withCallingHandlers({
[17:02:54.836]                   {
[17:02:54.836]                     b <- a * ii
[17:02:54.836]                     a <- 0
[17:02:54.836]                     b
[17:02:54.836]                   }
[17:02:54.836]                 }, immediateCondition = function(cond) {
[17:02:54.836]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.836]                   sendCondition(cond)
[17:02:54.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.836]                   {
[17:02:54.836]                     inherits <- base::inherits
[17:02:54.836]                     invokeRestart <- base::invokeRestart
[17:02:54.836]                     is.null <- base::is.null
[17:02:54.836]                     muffled <- FALSE
[17:02:54.836]                     if (inherits(cond, "message")) {
[17:02:54.836]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.836]                       if (muffled) 
[17:02:54.836]                         invokeRestart("muffleMessage")
[17:02:54.836]                     }
[17:02:54.836]                     else if (inherits(cond, "warning")) {
[17:02:54.836]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.836]                       if (muffled) 
[17:02:54.836]                         invokeRestart("muffleWarning")
[17:02:54.836]                     }
[17:02:54.836]                     else if (inherits(cond, "condition")) {
[17:02:54.836]                       if (!is.null(pattern)) {
[17:02:54.836]                         computeRestarts <- base::computeRestarts
[17:02:54.836]                         grepl <- base::grepl
[17:02:54.836]                         restarts <- computeRestarts(cond)
[17:02:54.836]                         for (restart in restarts) {
[17:02:54.836]                           name <- restart$name
[17:02:54.836]                           if (is.null(name)) 
[17:02:54.836]                             next
[17:02:54.836]                           if (!grepl(pattern, name)) 
[17:02:54.836]                             next
[17:02:54.836]                           invokeRestart(restart)
[17:02:54.836]                           muffled <- TRUE
[17:02:54.836]                           break
[17:02:54.836]                         }
[17:02:54.836]                       }
[17:02:54.836]                     }
[17:02:54.836]                     invisible(muffled)
[17:02:54.836]                   }
[17:02:54.836]                   muffleCondition(cond)
[17:02:54.836]                 })
[17:02:54.836]             }))
[17:02:54.836]             future::FutureResult(value = ...future.value$value, 
[17:02:54.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.836]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.836]                     ...future.globalenv.names))
[17:02:54.836]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.836]         }, condition = base::local({
[17:02:54.836]             c <- base::c
[17:02:54.836]             inherits <- base::inherits
[17:02:54.836]             invokeRestart <- base::invokeRestart
[17:02:54.836]             length <- base::length
[17:02:54.836]             list <- base::list
[17:02:54.836]             seq.int <- base::seq.int
[17:02:54.836]             signalCondition <- base::signalCondition
[17:02:54.836]             sys.calls <- base::sys.calls
[17:02:54.836]             `[[` <- base::`[[`
[17:02:54.836]             `+` <- base::`+`
[17:02:54.836]             `<<-` <- base::`<<-`
[17:02:54.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.836]                   3L)]
[17:02:54.836]             }
[17:02:54.836]             function(cond) {
[17:02:54.836]                 is_error <- inherits(cond, "error")
[17:02:54.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.836]                   NULL)
[17:02:54.836]                 if (is_error) {
[17:02:54.836]                   sessionInformation <- function() {
[17:02:54.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.836]                       search = base::search(), system = base::Sys.info())
[17:02:54.836]                   }
[17:02:54.836]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.836]                     cond$call), session = sessionInformation(), 
[17:02:54.836]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.836]                   signalCondition(cond)
[17:02:54.836]                 }
[17:02:54.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.836]                 "immediateCondition"))) {
[17:02:54.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.836]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.836]                   if (TRUE && !signal) {
[17:02:54.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.836]                     {
[17:02:54.836]                       inherits <- base::inherits
[17:02:54.836]                       invokeRestart <- base::invokeRestart
[17:02:54.836]                       is.null <- base::is.null
[17:02:54.836]                       muffled <- FALSE
[17:02:54.836]                       if (inherits(cond, "message")) {
[17:02:54.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.836]                         if (muffled) 
[17:02:54.836]                           invokeRestart("muffleMessage")
[17:02:54.836]                       }
[17:02:54.836]                       else if (inherits(cond, "warning")) {
[17:02:54.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.836]                         if (muffled) 
[17:02:54.836]                           invokeRestart("muffleWarning")
[17:02:54.836]                       }
[17:02:54.836]                       else if (inherits(cond, "condition")) {
[17:02:54.836]                         if (!is.null(pattern)) {
[17:02:54.836]                           computeRestarts <- base::computeRestarts
[17:02:54.836]                           grepl <- base::grepl
[17:02:54.836]                           restarts <- computeRestarts(cond)
[17:02:54.836]                           for (restart in restarts) {
[17:02:54.836]                             name <- restart$name
[17:02:54.836]                             if (is.null(name)) 
[17:02:54.836]                               next
[17:02:54.836]                             if (!grepl(pattern, name)) 
[17:02:54.836]                               next
[17:02:54.836]                             invokeRestart(restart)
[17:02:54.836]                             muffled <- TRUE
[17:02:54.836]                             break
[17:02:54.836]                           }
[17:02:54.836]                         }
[17:02:54.836]                       }
[17:02:54.836]                       invisible(muffled)
[17:02:54.836]                     }
[17:02:54.836]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.836]                   }
[17:02:54.836]                 }
[17:02:54.836]                 else {
[17:02:54.836]                   if (TRUE) {
[17:02:54.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.836]                     {
[17:02:54.836]                       inherits <- base::inherits
[17:02:54.836]                       invokeRestart <- base::invokeRestart
[17:02:54.836]                       is.null <- base::is.null
[17:02:54.836]                       muffled <- FALSE
[17:02:54.836]                       if (inherits(cond, "message")) {
[17:02:54.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.836]                         if (muffled) 
[17:02:54.836]                           invokeRestart("muffleMessage")
[17:02:54.836]                       }
[17:02:54.836]                       else if (inherits(cond, "warning")) {
[17:02:54.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.836]                         if (muffled) 
[17:02:54.836]                           invokeRestart("muffleWarning")
[17:02:54.836]                       }
[17:02:54.836]                       else if (inherits(cond, "condition")) {
[17:02:54.836]                         if (!is.null(pattern)) {
[17:02:54.836]                           computeRestarts <- base::computeRestarts
[17:02:54.836]                           grepl <- base::grepl
[17:02:54.836]                           restarts <- computeRestarts(cond)
[17:02:54.836]                           for (restart in restarts) {
[17:02:54.836]                             name <- restart$name
[17:02:54.836]                             if (is.null(name)) 
[17:02:54.836]                               next
[17:02:54.836]                             if (!grepl(pattern, name)) 
[17:02:54.836]                               next
[17:02:54.836]                             invokeRestart(restart)
[17:02:54.836]                             muffled <- TRUE
[17:02:54.836]                             break
[17:02:54.836]                           }
[17:02:54.836]                         }
[17:02:54.836]                       }
[17:02:54.836]                       invisible(muffled)
[17:02:54.836]                     }
[17:02:54.836]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.836]                   }
[17:02:54.836]                 }
[17:02:54.836]             }
[17:02:54.836]         }))
[17:02:54.836]     }, error = function(ex) {
[17:02:54.836]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.836]                 ...future.rng), started = ...future.startTime, 
[17:02:54.836]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.836]             version = "1.8"), class = "FutureResult")
[17:02:54.836]     }, finally = {
[17:02:54.836]         if (!identical(...future.workdir, getwd())) 
[17:02:54.836]             setwd(...future.workdir)
[17:02:54.836]         {
[17:02:54.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.836]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.836]             }
[17:02:54.836]             base::options(...future.oldOptions)
[17:02:54.836]             if (.Platform$OS.type == "windows") {
[17:02:54.836]                 old_names <- names(...future.oldEnvVars)
[17:02:54.836]                 envs <- base::Sys.getenv()
[17:02:54.836]                 names <- names(envs)
[17:02:54.836]                 common <- intersect(names, old_names)
[17:02:54.836]                 added <- setdiff(names, old_names)
[17:02:54.836]                 removed <- setdiff(old_names, names)
[17:02:54.836]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.836]                   envs[common]]
[17:02:54.836]                 NAMES <- toupper(changed)
[17:02:54.836]                 args <- list()
[17:02:54.836]                 for (kk in seq_along(NAMES)) {
[17:02:54.836]                   name <- changed[[kk]]
[17:02:54.836]                   NAME <- NAMES[[kk]]
[17:02:54.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.836]                     next
[17:02:54.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.836]                 }
[17:02:54.836]                 NAMES <- toupper(added)
[17:02:54.836]                 for (kk in seq_along(NAMES)) {
[17:02:54.836]                   name <- added[[kk]]
[17:02:54.836]                   NAME <- NAMES[[kk]]
[17:02:54.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.836]                     next
[17:02:54.836]                   args[[name]] <- ""
[17:02:54.836]                 }
[17:02:54.836]                 NAMES <- toupper(removed)
[17:02:54.836]                 for (kk in seq_along(NAMES)) {
[17:02:54.836]                   name <- removed[[kk]]
[17:02:54.836]                   NAME <- NAMES[[kk]]
[17:02:54.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.836]                     next
[17:02:54.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.836]                 }
[17:02:54.836]                 if (length(args) > 0) 
[17:02:54.836]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.836]             }
[17:02:54.836]             else {
[17:02:54.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.836]             }
[17:02:54.836]             {
[17:02:54.836]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.836]                   0L) {
[17:02:54.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.836]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.836]                   base::options(opts)
[17:02:54.836]                 }
[17:02:54.836]                 {
[17:02:54.836]                   {
[17:02:54.836]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.836]                     NULL
[17:02:54.836]                   }
[17:02:54.836]                   options(future.plan = NULL)
[17:02:54.836]                   if (is.na(NA_character_)) 
[17:02:54.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.836]                     .init = FALSE)
[17:02:54.836]                 }
[17:02:54.836]             }
[17:02:54.836]         }
[17:02:54.836]     })
[17:02:54.836]     if (TRUE) {
[17:02:54.836]         base::sink(type = "output", split = FALSE)
[17:02:54.836]         if (TRUE) {
[17:02:54.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.836]         }
[17:02:54.836]         else {
[17:02:54.836]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.836]         }
[17:02:54.836]         base::close(...future.stdout)
[17:02:54.836]         ...future.stdout <- NULL
[17:02:54.836]     }
[17:02:54.836]     ...future.result$conditions <- ...future.conditions
[17:02:54.836]     ...future.result$finished <- base::Sys.time()
[17:02:54.836]     ...future.result
[17:02:54.836] }
[17:02:54.838] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:02:54.839] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:02:54.839] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:02:54.839] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:02:54.839] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:02:54.839] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:02:54.840] MultisessionFuture started
[17:02:54.840] - Launch lazy future ... done
[17:02:54.840] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.841] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.841] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.843] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.843] Searching for globals ... DONE
[17:02:54.843] Resolving globals: TRUE
[17:02:54.843] Resolving any globals that are futures ...
[17:02:54.843] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.843] Resolving any globals that are futures ... DONE
[17:02:54.843] Resolving futures part of globals (recursively) ...
[17:02:54.844] resolve() on list ...
[17:02:54.844]  recursive: 99
[17:02:54.844]  length: 2
[17:02:54.844]  elements: ‘a’, ‘ii’
[17:02:54.844]  length: 1 (resolved future 1)
[17:02:54.844]  length: 0 (resolved future 2)
[17:02:54.844] resolve() on list ... DONE
[17:02:54.844] - globals: [2] ‘a’, ‘ii’
[17:02:54.844] Resolving futures part of globals (recursively) ... DONE
[17:02:54.845] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:54.845] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:54.845] - globals: [2] ‘a’, ‘ii’
[17:02:54.845] 
[17:02:54.845] getGlobalsAndPackages() ... DONE
[17:02:54.846] run() for ‘Future’ ...
[17:02:54.846] - state: ‘created’
[17:02:54.846] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.860] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.860]   - Field: ‘node’
[17:02:54.860]   - Field: ‘label’
[17:02:54.860]   - Field: ‘local’
[17:02:54.860]   - Field: ‘owner’
[17:02:54.860]   - Field: ‘envir’
[17:02:54.860]   - Field: ‘workers’
[17:02:54.860]   - Field: ‘packages’
[17:02:54.860]   - Field: ‘gc’
[17:02:54.861]   - Field: ‘conditions’
[17:02:54.861]   - Field: ‘persistent’
[17:02:54.861]   - Field: ‘expr’
[17:02:54.861]   - Field: ‘uuid’
[17:02:54.861]   - Field: ‘seed’
[17:02:54.861]   - Field: ‘version’
[17:02:54.861]   - Field: ‘result’
[17:02:54.861]   - Field: ‘asynchronous’
[17:02:54.861]   - Field: ‘calls’
[17:02:54.861]   - Field: ‘globals’
[17:02:54.861]   - Field: ‘stdout’
[17:02:54.862]   - Field: ‘earlySignal’
[17:02:54.862]   - Field: ‘lazy’
[17:02:54.862]   - Field: ‘state’
[17:02:54.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.862] - Launch lazy future ...
[17:02:54.862] Packages needed by the future expression (n = 0): <none>
[17:02:54.862] Packages needed by future strategies (n = 0): <none>
[17:02:54.863] {
[17:02:54.863]     {
[17:02:54.863]         {
[17:02:54.863]             ...future.startTime <- base::Sys.time()
[17:02:54.863]             {
[17:02:54.863]                 {
[17:02:54.863]                   {
[17:02:54.863]                     {
[17:02:54.863]                       base::local({
[17:02:54.863]                         has_future <- base::requireNamespace("future", 
[17:02:54.863]                           quietly = TRUE)
[17:02:54.863]                         if (has_future) {
[17:02:54.863]                           ns <- base::getNamespace("future")
[17:02:54.863]                           version <- ns[[".package"]][["version"]]
[17:02:54.863]                           if (is.null(version)) 
[17:02:54.863]                             version <- utils::packageVersion("future")
[17:02:54.863]                         }
[17:02:54.863]                         else {
[17:02:54.863]                           version <- NULL
[17:02:54.863]                         }
[17:02:54.863]                         if (!has_future || version < "1.8.0") {
[17:02:54.863]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.863]                             "", base::R.version$version.string), 
[17:02:54.863]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.863]                               "release", "version")], collapse = " "), 
[17:02:54.863]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.863]                             info)
[17:02:54.863]                           info <- base::paste(info, collapse = "; ")
[17:02:54.863]                           if (!has_future) {
[17:02:54.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.863]                               info)
[17:02:54.863]                           }
[17:02:54.863]                           else {
[17:02:54.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.863]                               info, version)
[17:02:54.863]                           }
[17:02:54.863]                           base::stop(msg)
[17:02:54.863]                         }
[17:02:54.863]                       })
[17:02:54.863]                     }
[17:02:54.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.863]                     base::options(mc.cores = 1L)
[17:02:54.863]                   }
[17:02:54.863]                   ...future.strategy.old <- future::plan("list")
[17:02:54.863]                   options(future.plan = NULL)
[17:02:54.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.863]                 }
[17:02:54.863]                 ...future.workdir <- getwd()
[17:02:54.863]             }
[17:02:54.863]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.863]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.863]         }
[17:02:54.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.863]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:54.863]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.863]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.863]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.863]             base::names(...future.oldOptions))
[17:02:54.863]     }
[17:02:54.863]     if (FALSE) {
[17:02:54.863]     }
[17:02:54.863]     else {
[17:02:54.863]         if (TRUE) {
[17:02:54.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.863]                 open = "w")
[17:02:54.863]         }
[17:02:54.863]         else {
[17:02:54.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.863]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.863]         }
[17:02:54.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.863]             base::sink(type = "output", split = FALSE)
[17:02:54.863]             base::close(...future.stdout)
[17:02:54.863]         }, add = TRUE)
[17:02:54.863]     }
[17:02:54.863]     ...future.frame <- base::sys.nframe()
[17:02:54.863]     ...future.conditions <- base::list()
[17:02:54.863]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.863]     if (FALSE) {
[17:02:54.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.863]     }
[17:02:54.863]     ...future.result <- base::tryCatch({
[17:02:54.863]         base::withCallingHandlers({
[17:02:54.863]             ...future.value <- base::withVisible(base::local({
[17:02:54.863]                 ...future.makeSendCondition <- base::local({
[17:02:54.863]                   sendCondition <- NULL
[17:02:54.863]                   function(frame = 1L) {
[17:02:54.863]                     if (is.function(sendCondition)) 
[17:02:54.863]                       return(sendCondition)
[17:02:54.863]                     ns <- getNamespace("parallel")
[17:02:54.863]                     if (exists("sendData", mode = "function", 
[17:02:54.863]                       envir = ns)) {
[17:02:54.863]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.863]                         envir = ns)
[17:02:54.863]                       envir <- sys.frame(frame)
[17:02:54.863]                       master <- NULL
[17:02:54.863]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.863]                         !identical(envir, emptyenv())) {
[17:02:54.863]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.863]                           inherits = FALSE)) {
[17:02:54.863]                           master <- get("master", mode = "list", 
[17:02:54.863]                             envir = envir, inherits = FALSE)
[17:02:54.863]                           if (inherits(master, c("SOCKnode", 
[17:02:54.863]                             "SOCK0node"))) {
[17:02:54.863]                             sendCondition <<- function(cond) {
[17:02:54.863]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.863]                                 success = TRUE)
[17:02:54.863]                               parallel_sendData(master, data)
[17:02:54.863]                             }
[17:02:54.863]                             return(sendCondition)
[17:02:54.863]                           }
[17:02:54.863]                         }
[17:02:54.863]                         frame <- frame + 1L
[17:02:54.863]                         envir <- sys.frame(frame)
[17:02:54.863]                       }
[17:02:54.863]                     }
[17:02:54.863]                     sendCondition <<- function(cond) NULL
[17:02:54.863]                   }
[17:02:54.863]                 })
[17:02:54.863]                 withCallingHandlers({
[17:02:54.863]                   {
[17:02:54.863]                     b <- a * ii
[17:02:54.863]                     a <- 0
[17:02:54.863]                     b
[17:02:54.863]                   }
[17:02:54.863]                 }, immediateCondition = function(cond) {
[17:02:54.863]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.863]                   sendCondition(cond)
[17:02:54.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.863]                   {
[17:02:54.863]                     inherits <- base::inherits
[17:02:54.863]                     invokeRestart <- base::invokeRestart
[17:02:54.863]                     is.null <- base::is.null
[17:02:54.863]                     muffled <- FALSE
[17:02:54.863]                     if (inherits(cond, "message")) {
[17:02:54.863]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.863]                       if (muffled) 
[17:02:54.863]                         invokeRestart("muffleMessage")
[17:02:54.863]                     }
[17:02:54.863]                     else if (inherits(cond, "warning")) {
[17:02:54.863]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.863]                       if (muffled) 
[17:02:54.863]                         invokeRestart("muffleWarning")
[17:02:54.863]                     }
[17:02:54.863]                     else if (inherits(cond, "condition")) {
[17:02:54.863]                       if (!is.null(pattern)) {
[17:02:54.863]                         computeRestarts <- base::computeRestarts
[17:02:54.863]                         grepl <- base::grepl
[17:02:54.863]                         restarts <- computeRestarts(cond)
[17:02:54.863]                         for (restart in restarts) {
[17:02:54.863]                           name <- restart$name
[17:02:54.863]                           if (is.null(name)) 
[17:02:54.863]                             next
[17:02:54.863]                           if (!grepl(pattern, name)) 
[17:02:54.863]                             next
[17:02:54.863]                           invokeRestart(restart)
[17:02:54.863]                           muffled <- TRUE
[17:02:54.863]                           break
[17:02:54.863]                         }
[17:02:54.863]                       }
[17:02:54.863]                     }
[17:02:54.863]                     invisible(muffled)
[17:02:54.863]                   }
[17:02:54.863]                   muffleCondition(cond)
[17:02:54.863]                 })
[17:02:54.863]             }))
[17:02:54.863]             future::FutureResult(value = ...future.value$value, 
[17:02:54.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.863]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.863]                     ...future.globalenv.names))
[17:02:54.863]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.863]         }, condition = base::local({
[17:02:54.863]             c <- base::c
[17:02:54.863]             inherits <- base::inherits
[17:02:54.863]             invokeRestart <- base::invokeRestart
[17:02:54.863]             length <- base::length
[17:02:54.863]             list <- base::list
[17:02:54.863]             seq.int <- base::seq.int
[17:02:54.863]             signalCondition <- base::signalCondition
[17:02:54.863]             sys.calls <- base::sys.calls
[17:02:54.863]             `[[` <- base::`[[`
[17:02:54.863]             `+` <- base::`+`
[17:02:54.863]             `<<-` <- base::`<<-`
[17:02:54.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.863]                   3L)]
[17:02:54.863]             }
[17:02:54.863]             function(cond) {
[17:02:54.863]                 is_error <- inherits(cond, "error")
[17:02:54.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.863]                   NULL)
[17:02:54.863]                 if (is_error) {
[17:02:54.863]                   sessionInformation <- function() {
[17:02:54.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.863]                       search = base::search(), system = base::Sys.info())
[17:02:54.863]                   }
[17:02:54.863]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.863]                     cond$call), session = sessionInformation(), 
[17:02:54.863]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.863]                   signalCondition(cond)
[17:02:54.863]                 }
[17:02:54.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.863]                 "immediateCondition"))) {
[17:02:54.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.863]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.863]                   if (TRUE && !signal) {
[17:02:54.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.863]                     {
[17:02:54.863]                       inherits <- base::inherits
[17:02:54.863]                       invokeRestart <- base::invokeRestart
[17:02:54.863]                       is.null <- base::is.null
[17:02:54.863]                       muffled <- FALSE
[17:02:54.863]                       if (inherits(cond, "message")) {
[17:02:54.863]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.863]                         if (muffled) 
[17:02:54.863]                           invokeRestart("muffleMessage")
[17:02:54.863]                       }
[17:02:54.863]                       else if (inherits(cond, "warning")) {
[17:02:54.863]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.863]                         if (muffled) 
[17:02:54.863]                           invokeRestart("muffleWarning")
[17:02:54.863]                       }
[17:02:54.863]                       else if (inherits(cond, "condition")) {
[17:02:54.863]                         if (!is.null(pattern)) {
[17:02:54.863]                           computeRestarts <- base::computeRestarts
[17:02:54.863]                           grepl <- base::grepl
[17:02:54.863]                           restarts <- computeRestarts(cond)
[17:02:54.863]                           for (restart in restarts) {
[17:02:54.863]                             name <- restart$name
[17:02:54.863]                             if (is.null(name)) 
[17:02:54.863]                               next
[17:02:54.863]                             if (!grepl(pattern, name)) 
[17:02:54.863]                               next
[17:02:54.863]                             invokeRestart(restart)
[17:02:54.863]                             muffled <- TRUE
[17:02:54.863]                             break
[17:02:54.863]                           }
[17:02:54.863]                         }
[17:02:54.863]                       }
[17:02:54.863]                       invisible(muffled)
[17:02:54.863]                     }
[17:02:54.863]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.863]                   }
[17:02:54.863]                 }
[17:02:54.863]                 else {
[17:02:54.863]                   if (TRUE) {
[17:02:54.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.863]                     {
[17:02:54.863]                       inherits <- base::inherits
[17:02:54.863]                       invokeRestart <- base::invokeRestart
[17:02:54.863]                       is.null <- base::is.null
[17:02:54.863]                       muffled <- FALSE
[17:02:54.863]                       if (inherits(cond, "message")) {
[17:02:54.863]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.863]                         if (muffled) 
[17:02:54.863]                           invokeRestart("muffleMessage")
[17:02:54.863]                       }
[17:02:54.863]                       else if (inherits(cond, "warning")) {
[17:02:54.863]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.863]                         if (muffled) 
[17:02:54.863]                           invokeRestart("muffleWarning")
[17:02:54.863]                       }
[17:02:54.863]                       else if (inherits(cond, "condition")) {
[17:02:54.863]                         if (!is.null(pattern)) {
[17:02:54.863]                           computeRestarts <- base::computeRestarts
[17:02:54.863]                           grepl <- base::grepl
[17:02:54.863]                           restarts <- computeRestarts(cond)
[17:02:54.863]                           for (restart in restarts) {
[17:02:54.863]                             name <- restart$name
[17:02:54.863]                             if (is.null(name)) 
[17:02:54.863]                               next
[17:02:54.863]                             if (!grepl(pattern, name)) 
[17:02:54.863]                               next
[17:02:54.863]                             invokeRestart(restart)
[17:02:54.863]                             muffled <- TRUE
[17:02:54.863]                             break
[17:02:54.863]                           }
[17:02:54.863]                         }
[17:02:54.863]                       }
[17:02:54.863]                       invisible(muffled)
[17:02:54.863]                     }
[17:02:54.863]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.863]                   }
[17:02:54.863]                 }
[17:02:54.863]             }
[17:02:54.863]         }))
[17:02:54.863]     }, error = function(ex) {
[17:02:54.863]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.863]                 ...future.rng), started = ...future.startTime, 
[17:02:54.863]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.863]             version = "1.8"), class = "FutureResult")
[17:02:54.863]     }, finally = {
[17:02:54.863]         if (!identical(...future.workdir, getwd())) 
[17:02:54.863]             setwd(...future.workdir)
[17:02:54.863]         {
[17:02:54.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.863]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.863]             }
[17:02:54.863]             base::options(...future.oldOptions)
[17:02:54.863]             if (.Platform$OS.type == "windows") {
[17:02:54.863]                 old_names <- names(...future.oldEnvVars)
[17:02:54.863]                 envs <- base::Sys.getenv()
[17:02:54.863]                 names <- names(envs)
[17:02:54.863]                 common <- intersect(names, old_names)
[17:02:54.863]                 added <- setdiff(names, old_names)
[17:02:54.863]                 removed <- setdiff(old_names, names)
[17:02:54.863]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.863]                   envs[common]]
[17:02:54.863]                 NAMES <- toupper(changed)
[17:02:54.863]                 args <- list()
[17:02:54.863]                 for (kk in seq_along(NAMES)) {
[17:02:54.863]                   name <- changed[[kk]]
[17:02:54.863]                   NAME <- NAMES[[kk]]
[17:02:54.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.863]                     next
[17:02:54.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.863]                 }
[17:02:54.863]                 NAMES <- toupper(added)
[17:02:54.863]                 for (kk in seq_along(NAMES)) {
[17:02:54.863]                   name <- added[[kk]]
[17:02:54.863]                   NAME <- NAMES[[kk]]
[17:02:54.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.863]                     next
[17:02:54.863]                   args[[name]] <- ""
[17:02:54.863]                 }
[17:02:54.863]                 NAMES <- toupper(removed)
[17:02:54.863]                 for (kk in seq_along(NAMES)) {
[17:02:54.863]                   name <- removed[[kk]]
[17:02:54.863]                   NAME <- NAMES[[kk]]
[17:02:54.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.863]                     next
[17:02:54.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.863]                 }
[17:02:54.863]                 if (length(args) > 0) 
[17:02:54.863]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.863]             }
[17:02:54.863]             else {
[17:02:54.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.863]             }
[17:02:54.863]             {
[17:02:54.863]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.863]                   0L) {
[17:02:54.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.863]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.863]                   base::options(opts)
[17:02:54.863]                 }
[17:02:54.863]                 {
[17:02:54.863]                   {
[17:02:54.863]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.863]                     NULL
[17:02:54.863]                   }
[17:02:54.863]                   options(future.plan = NULL)
[17:02:54.863]                   if (is.na(NA_character_)) 
[17:02:54.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.863]                     .init = FALSE)
[17:02:54.863]                 }
[17:02:54.863]             }
[17:02:54.863]         }
[17:02:54.863]     })
[17:02:54.863]     if (TRUE) {
[17:02:54.863]         base::sink(type = "output", split = FALSE)
[17:02:54.863]         if (TRUE) {
[17:02:54.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.863]         }
[17:02:54.863]         else {
[17:02:54.863]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.863]         }
[17:02:54.863]         base::close(...future.stdout)
[17:02:54.863]         ...future.stdout <- NULL
[17:02:54.863]     }
[17:02:54.863]     ...future.result$conditions <- ...future.conditions
[17:02:54.863]     ...future.result$finished <- base::Sys.time()
[17:02:54.863]     ...future.result
[17:02:54.863] }
[17:02:54.865] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:54.876] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.876] - Validating connection of MultisessionFuture
[17:02:54.876] - received message: FutureResult
[17:02:54.876] - Received FutureResult
[17:02:54.876] - Erased future from FutureRegistry
[17:02:54.877] result() for ClusterFuture ...
[17:02:54.877] - result already collected: FutureResult
[17:02:54.877] result() for ClusterFuture ... done
[17:02:54.877] signalConditions() ...
[17:02:54.877]  - include = ‘immediateCondition’
[17:02:54.877]  - exclude = 
[17:02:54.877]  - resignal = FALSE
[17:02:54.877]  - Number of conditions: 1
[17:02:54.877] signalConditions() ... done
[17:02:54.877] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.878] result() for ClusterFuture ...
[17:02:54.878] - result already collected: FutureResult
[17:02:54.878] result() for ClusterFuture ... done
[17:02:54.878] result() for ClusterFuture ...
[17:02:54.878] - result already collected: FutureResult
[17:02:54.878] result() for ClusterFuture ... done
[17:02:54.878] signalConditions() ...
[17:02:54.878]  - include = ‘immediateCondition’
[17:02:54.878]  - exclude = 
[17:02:54.878]  - resignal = FALSE
[17:02:54.878]  - Number of conditions: 1
[17:02:54.878] signalConditions() ... done
[17:02:54.879] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:02:54.879] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:02:54.880] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:02:54.880] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:02:54.880] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:02:54.880] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:02:54.881] MultisessionFuture started
[17:02:54.881] - Launch lazy future ... done
[17:02:54.881] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.881] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.882] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.884] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.884] Searching for globals ... DONE
[17:02:54.884] Resolving globals: TRUE
[17:02:54.884] Resolving any globals that are futures ...
[17:02:54.884] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.884] Resolving any globals that are futures ... DONE
[17:02:54.885] Resolving futures part of globals (recursively) ...
[17:02:54.885] resolve() on list ...
[17:02:54.886]  recursive: 99
[17:02:54.886]  length: 2
[17:02:54.886]  elements: ‘a’, ‘ii’
[17:02:54.886]  length: 1 (resolved future 1)
[17:02:54.886]  length: 0 (resolved future 2)
[17:02:54.886] resolve() on list ... DONE
[17:02:54.886] - globals: [2] ‘a’, ‘ii’
[17:02:54.886] Resolving futures part of globals (recursively) ... DONE
[17:02:54.887] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:54.887] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:54.887] - globals: [2] ‘a’, ‘ii’
[17:02:54.887] 
[17:02:54.887] getGlobalsAndPackages() ... DONE
[17:02:54.888] run() for ‘Future’ ...
[17:02:54.888] - state: ‘created’
[17:02:54.888] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.902] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.902]   - Field: ‘node’
[17:02:54.902]   - Field: ‘label’
[17:02:54.902]   - Field: ‘local’
[17:02:54.902]   - Field: ‘owner’
[17:02:54.902]   - Field: ‘envir’
[17:02:54.902]   - Field: ‘workers’
[17:02:54.903]   - Field: ‘packages’
[17:02:54.903]   - Field: ‘gc’
[17:02:54.903]   - Field: ‘conditions’
[17:02:54.903]   - Field: ‘persistent’
[17:02:54.903]   - Field: ‘expr’
[17:02:54.903]   - Field: ‘uuid’
[17:02:54.903]   - Field: ‘seed’
[17:02:54.903]   - Field: ‘version’
[17:02:54.903]   - Field: ‘result’
[17:02:54.903]   - Field: ‘asynchronous’
[17:02:54.904]   - Field: ‘calls’
[17:02:54.904]   - Field: ‘globals’
[17:02:54.904]   - Field: ‘stdout’
[17:02:54.904]   - Field: ‘earlySignal’
[17:02:54.904]   - Field: ‘lazy’
[17:02:54.904]   - Field: ‘state’
[17:02:54.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:54.904] - Launch lazy future ...
[17:02:54.904] Packages needed by the future expression (n = 0): <none>
[17:02:54.905] Packages needed by future strategies (n = 0): <none>
[17:02:54.905] {
[17:02:54.905]     {
[17:02:54.905]         {
[17:02:54.905]             ...future.startTime <- base::Sys.time()
[17:02:54.905]             {
[17:02:54.905]                 {
[17:02:54.905]                   {
[17:02:54.905]                     {
[17:02:54.905]                       base::local({
[17:02:54.905]                         has_future <- base::requireNamespace("future", 
[17:02:54.905]                           quietly = TRUE)
[17:02:54.905]                         if (has_future) {
[17:02:54.905]                           ns <- base::getNamespace("future")
[17:02:54.905]                           version <- ns[[".package"]][["version"]]
[17:02:54.905]                           if (is.null(version)) 
[17:02:54.905]                             version <- utils::packageVersion("future")
[17:02:54.905]                         }
[17:02:54.905]                         else {
[17:02:54.905]                           version <- NULL
[17:02:54.905]                         }
[17:02:54.905]                         if (!has_future || version < "1.8.0") {
[17:02:54.905]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:54.905]                             "", base::R.version$version.string), 
[17:02:54.905]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:54.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:54.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:54.905]                               "release", "version")], collapse = " "), 
[17:02:54.905]                             hostname = base::Sys.info()[["nodename"]])
[17:02:54.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:54.905]                             info)
[17:02:54.905]                           info <- base::paste(info, collapse = "; ")
[17:02:54.905]                           if (!has_future) {
[17:02:54.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:54.905]                               info)
[17:02:54.905]                           }
[17:02:54.905]                           else {
[17:02:54.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:54.905]                               info, version)
[17:02:54.905]                           }
[17:02:54.905]                           base::stop(msg)
[17:02:54.905]                         }
[17:02:54.905]                       })
[17:02:54.905]                     }
[17:02:54.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:54.905]                     base::options(mc.cores = 1L)
[17:02:54.905]                   }
[17:02:54.905]                   ...future.strategy.old <- future::plan("list")
[17:02:54.905]                   options(future.plan = NULL)
[17:02:54.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:54.905]                 }
[17:02:54.905]                 ...future.workdir <- getwd()
[17:02:54.905]             }
[17:02:54.905]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:54.905]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:54.905]         }
[17:02:54.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:54.905]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:54.905]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:54.905]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:54.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:54.905]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:54.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:54.905]             base::names(...future.oldOptions))
[17:02:54.905]     }
[17:02:54.905]     if (FALSE) {
[17:02:54.905]     }
[17:02:54.905]     else {
[17:02:54.905]         if (TRUE) {
[17:02:54.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:54.905]                 open = "w")
[17:02:54.905]         }
[17:02:54.905]         else {
[17:02:54.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:54.905]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:54.905]         }
[17:02:54.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:54.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:54.905]             base::sink(type = "output", split = FALSE)
[17:02:54.905]             base::close(...future.stdout)
[17:02:54.905]         }, add = TRUE)
[17:02:54.905]     }
[17:02:54.905]     ...future.frame <- base::sys.nframe()
[17:02:54.905]     ...future.conditions <- base::list()
[17:02:54.905]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:54.905]     if (FALSE) {
[17:02:54.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:54.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:54.905]     }
[17:02:54.905]     ...future.result <- base::tryCatch({
[17:02:54.905]         base::withCallingHandlers({
[17:02:54.905]             ...future.value <- base::withVisible(base::local({
[17:02:54.905]                 ...future.makeSendCondition <- base::local({
[17:02:54.905]                   sendCondition <- NULL
[17:02:54.905]                   function(frame = 1L) {
[17:02:54.905]                     if (is.function(sendCondition)) 
[17:02:54.905]                       return(sendCondition)
[17:02:54.905]                     ns <- getNamespace("parallel")
[17:02:54.905]                     if (exists("sendData", mode = "function", 
[17:02:54.905]                       envir = ns)) {
[17:02:54.905]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:54.905]                         envir = ns)
[17:02:54.905]                       envir <- sys.frame(frame)
[17:02:54.905]                       master <- NULL
[17:02:54.905]                       while (!identical(envir, .GlobalEnv) && 
[17:02:54.905]                         !identical(envir, emptyenv())) {
[17:02:54.905]                         if (exists("master", mode = "list", envir = envir, 
[17:02:54.905]                           inherits = FALSE)) {
[17:02:54.905]                           master <- get("master", mode = "list", 
[17:02:54.905]                             envir = envir, inherits = FALSE)
[17:02:54.905]                           if (inherits(master, c("SOCKnode", 
[17:02:54.905]                             "SOCK0node"))) {
[17:02:54.905]                             sendCondition <<- function(cond) {
[17:02:54.905]                               data <- list(type = "VALUE", value = cond, 
[17:02:54.905]                                 success = TRUE)
[17:02:54.905]                               parallel_sendData(master, data)
[17:02:54.905]                             }
[17:02:54.905]                             return(sendCondition)
[17:02:54.905]                           }
[17:02:54.905]                         }
[17:02:54.905]                         frame <- frame + 1L
[17:02:54.905]                         envir <- sys.frame(frame)
[17:02:54.905]                       }
[17:02:54.905]                     }
[17:02:54.905]                     sendCondition <<- function(cond) NULL
[17:02:54.905]                   }
[17:02:54.905]                 })
[17:02:54.905]                 withCallingHandlers({
[17:02:54.905]                   {
[17:02:54.905]                     b <- a * ii
[17:02:54.905]                     a <- 0
[17:02:54.905]                     b
[17:02:54.905]                   }
[17:02:54.905]                 }, immediateCondition = function(cond) {
[17:02:54.905]                   sendCondition <- ...future.makeSendCondition()
[17:02:54.905]                   sendCondition(cond)
[17:02:54.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.905]                   {
[17:02:54.905]                     inherits <- base::inherits
[17:02:54.905]                     invokeRestart <- base::invokeRestart
[17:02:54.905]                     is.null <- base::is.null
[17:02:54.905]                     muffled <- FALSE
[17:02:54.905]                     if (inherits(cond, "message")) {
[17:02:54.905]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:54.905]                       if (muffled) 
[17:02:54.905]                         invokeRestart("muffleMessage")
[17:02:54.905]                     }
[17:02:54.905]                     else if (inherits(cond, "warning")) {
[17:02:54.905]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:54.905]                       if (muffled) 
[17:02:54.905]                         invokeRestart("muffleWarning")
[17:02:54.905]                     }
[17:02:54.905]                     else if (inherits(cond, "condition")) {
[17:02:54.905]                       if (!is.null(pattern)) {
[17:02:54.905]                         computeRestarts <- base::computeRestarts
[17:02:54.905]                         grepl <- base::grepl
[17:02:54.905]                         restarts <- computeRestarts(cond)
[17:02:54.905]                         for (restart in restarts) {
[17:02:54.905]                           name <- restart$name
[17:02:54.905]                           if (is.null(name)) 
[17:02:54.905]                             next
[17:02:54.905]                           if (!grepl(pattern, name)) 
[17:02:54.905]                             next
[17:02:54.905]                           invokeRestart(restart)
[17:02:54.905]                           muffled <- TRUE
[17:02:54.905]                           break
[17:02:54.905]                         }
[17:02:54.905]                       }
[17:02:54.905]                     }
[17:02:54.905]                     invisible(muffled)
[17:02:54.905]                   }
[17:02:54.905]                   muffleCondition(cond)
[17:02:54.905]                 })
[17:02:54.905]             }))
[17:02:54.905]             future::FutureResult(value = ...future.value$value, 
[17:02:54.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.905]                   ...future.rng), globalenv = if (FALSE) 
[17:02:54.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:54.905]                     ...future.globalenv.names))
[17:02:54.905]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:54.905]         }, condition = base::local({
[17:02:54.905]             c <- base::c
[17:02:54.905]             inherits <- base::inherits
[17:02:54.905]             invokeRestart <- base::invokeRestart
[17:02:54.905]             length <- base::length
[17:02:54.905]             list <- base::list
[17:02:54.905]             seq.int <- base::seq.int
[17:02:54.905]             signalCondition <- base::signalCondition
[17:02:54.905]             sys.calls <- base::sys.calls
[17:02:54.905]             `[[` <- base::`[[`
[17:02:54.905]             `+` <- base::`+`
[17:02:54.905]             `<<-` <- base::`<<-`
[17:02:54.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:54.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:54.905]                   3L)]
[17:02:54.905]             }
[17:02:54.905]             function(cond) {
[17:02:54.905]                 is_error <- inherits(cond, "error")
[17:02:54.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:54.905]                   NULL)
[17:02:54.905]                 if (is_error) {
[17:02:54.905]                   sessionInformation <- function() {
[17:02:54.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:54.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:54.905]                       search = base::search(), system = base::Sys.info())
[17:02:54.905]                   }
[17:02:54.905]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:54.905]                     cond$call), session = sessionInformation(), 
[17:02:54.905]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:54.905]                   signalCondition(cond)
[17:02:54.905]                 }
[17:02:54.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:54.905]                 "immediateCondition"))) {
[17:02:54.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:54.905]                   ...future.conditions[[length(...future.conditions) + 
[17:02:54.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:54.905]                   if (TRUE && !signal) {
[17:02:54.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.905]                     {
[17:02:54.905]                       inherits <- base::inherits
[17:02:54.905]                       invokeRestart <- base::invokeRestart
[17:02:54.905]                       is.null <- base::is.null
[17:02:54.905]                       muffled <- FALSE
[17:02:54.905]                       if (inherits(cond, "message")) {
[17:02:54.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.905]                         if (muffled) 
[17:02:54.905]                           invokeRestart("muffleMessage")
[17:02:54.905]                       }
[17:02:54.905]                       else if (inherits(cond, "warning")) {
[17:02:54.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.905]                         if (muffled) 
[17:02:54.905]                           invokeRestart("muffleWarning")
[17:02:54.905]                       }
[17:02:54.905]                       else if (inherits(cond, "condition")) {
[17:02:54.905]                         if (!is.null(pattern)) {
[17:02:54.905]                           computeRestarts <- base::computeRestarts
[17:02:54.905]                           grepl <- base::grepl
[17:02:54.905]                           restarts <- computeRestarts(cond)
[17:02:54.905]                           for (restart in restarts) {
[17:02:54.905]                             name <- restart$name
[17:02:54.905]                             if (is.null(name)) 
[17:02:54.905]                               next
[17:02:54.905]                             if (!grepl(pattern, name)) 
[17:02:54.905]                               next
[17:02:54.905]                             invokeRestart(restart)
[17:02:54.905]                             muffled <- TRUE
[17:02:54.905]                             break
[17:02:54.905]                           }
[17:02:54.905]                         }
[17:02:54.905]                       }
[17:02:54.905]                       invisible(muffled)
[17:02:54.905]                     }
[17:02:54.905]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.905]                   }
[17:02:54.905]                 }
[17:02:54.905]                 else {
[17:02:54.905]                   if (TRUE) {
[17:02:54.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:54.905]                     {
[17:02:54.905]                       inherits <- base::inherits
[17:02:54.905]                       invokeRestart <- base::invokeRestart
[17:02:54.905]                       is.null <- base::is.null
[17:02:54.905]                       muffled <- FALSE
[17:02:54.905]                       if (inherits(cond, "message")) {
[17:02:54.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:54.905]                         if (muffled) 
[17:02:54.905]                           invokeRestart("muffleMessage")
[17:02:54.905]                       }
[17:02:54.905]                       else if (inherits(cond, "warning")) {
[17:02:54.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:54.905]                         if (muffled) 
[17:02:54.905]                           invokeRestart("muffleWarning")
[17:02:54.905]                       }
[17:02:54.905]                       else if (inherits(cond, "condition")) {
[17:02:54.905]                         if (!is.null(pattern)) {
[17:02:54.905]                           computeRestarts <- base::computeRestarts
[17:02:54.905]                           grepl <- base::grepl
[17:02:54.905]                           restarts <- computeRestarts(cond)
[17:02:54.905]                           for (restart in restarts) {
[17:02:54.905]                             name <- restart$name
[17:02:54.905]                             if (is.null(name)) 
[17:02:54.905]                               next
[17:02:54.905]                             if (!grepl(pattern, name)) 
[17:02:54.905]                               next
[17:02:54.905]                             invokeRestart(restart)
[17:02:54.905]                             muffled <- TRUE
[17:02:54.905]                             break
[17:02:54.905]                           }
[17:02:54.905]                         }
[17:02:54.905]                       }
[17:02:54.905]                       invisible(muffled)
[17:02:54.905]                     }
[17:02:54.905]                     muffleCondition(cond, pattern = "^muffle")
[17:02:54.905]                   }
[17:02:54.905]                 }
[17:02:54.905]             }
[17:02:54.905]         }))
[17:02:54.905]     }, error = function(ex) {
[17:02:54.905]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:54.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:54.905]                 ...future.rng), started = ...future.startTime, 
[17:02:54.905]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:54.905]             version = "1.8"), class = "FutureResult")
[17:02:54.905]     }, finally = {
[17:02:54.905]         if (!identical(...future.workdir, getwd())) 
[17:02:54.905]             setwd(...future.workdir)
[17:02:54.905]         {
[17:02:54.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:54.905]                 ...future.oldOptions$nwarnings <- NULL
[17:02:54.905]             }
[17:02:54.905]             base::options(...future.oldOptions)
[17:02:54.905]             if (.Platform$OS.type == "windows") {
[17:02:54.905]                 old_names <- names(...future.oldEnvVars)
[17:02:54.905]                 envs <- base::Sys.getenv()
[17:02:54.905]                 names <- names(envs)
[17:02:54.905]                 common <- intersect(names, old_names)
[17:02:54.905]                 added <- setdiff(names, old_names)
[17:02:54.905]                 removed <- setdiff(old_names, names)
[17:02:54.905]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:54.905]                   envs[common]]
[17:02:54.905]                 NAMES <- toupper(changed)
[17:02:54.905]                 args <- list()
[17:02:54.905]                 for (kk in seq_along(NAMES)) {
[17:02:54.905]                   name <- changed[[kk]]
[17:02:54.905]                   NAME <- NAMES[[kk]]
[17:02:54.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.905]                     next
[17:02:54.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.905]                 }
[17:02:54.905]                 NAMES <- toupper(added)
[17:02:54.905]                 for (kk in seq_along(NAMES)) {
[17:02:54.905]                   name <- added[[kk]]
[17:02:54.905]                   NAME <- NAMES[[kk]]
[17:02:54.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.905]                     next
[17:02:54.905]                   args[[name]] <- ""
[17:02:54.905]                 }
[17:02:54.905]                 NAMES <- toupper(removed)
[17:02:54.905]                 for (kk in seq_along(NAMES)) {
[17:02:54.905]                   name <- removed[[kk]]
[17:02:54.905]                   NAME <- NAMES[[kk]]
[17:02:54.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:54.905]                     next
[17:02:54.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:54.905]                 }
[17:02:54.905]                 if (length(args) > 0) 
[17:02:54.905]                   base::do.call(base::Sys.setenv, args = args)
[17:02:54.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:54.905]             }
[17:02:54.905]             else {
[17:02:54.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:54.905]             }
[17:02:54.905]             {
[17:02:54.905]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:54.905]                   0L) {
[17:02:54.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:54.905]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:54.905]                   base::options(opts)
[17:02:54.905]                 }
[17:02:54.905]                 {
[17:02:54.905]                   {
[17:02:54.905]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:54.905]                     NULL
[17:02:54.905]                   }
[17:02:54.905]                   options(future.plan = NULL)
[17:02:54.905]                   if (is.na(NA_character_)) 
[17:02:54.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:54.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:54.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:54.905]                     .init = FALSE)
[17:02:54.905]                 }
[17:02:54.905]             }
[17:02:54.905]         }
[17:02:54.905]     })
[17:02:54.905]     if (TRUE) {
[17:02:54.905]         base::sink(type = "output", split = FALSE)
[17:02:54.905]         if (TRUE) {
[17:02:54.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:54.905]         }
[17:02:54.905]         else {
[17:02:54.905]             ...future.result["stdout"] <- base::list(NULL)
[17:02:54.905]         }
[17:02:54.905]         base::close(...future.stdout)
[17:02:54.905]         ...future.stdout <- NULL
[17:02:54.905]     }
[17:02:54.905]     ...future.result$conditions <- ...future.conditions
[17:02:54.905]     ...future.result$finished <- base::Sys.time()
[17:02:54.905]     ...future.result
[17:02:54.905] }
[17:02:54.907] Poll #1 (0): usedNodes() = 2, workers = 2
[17:02:54.918] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.918] - Validating connection of MultisessionFuture
[17:02:54.918] - received message: FutureResult
[17:02:54.918] - Received FutureResult
[17:02:54.918] - Erased future from FutureRegistry
[17:02:54.918] result() for ClusterFuture ...
[17:02:54.919] - result already collected: FutureResult
[17:02:54.919] result() for ClusterFuture ... done
[17:02:54.919] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.919] result() for ClusterFuture ...
[17:02:54.919] - result already collected: FutureResult
[17:02:54.919] result() for ClusterFuture ... done
[17:02:54.919] result() for ClusterFuture ...
[17:02:54.919] - result already collected: FutureResult
[17:02:54.919] result() for ClusterFuture ... done
[17:02:54.920] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:02:54.920] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:02:54.920] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:02:54.921] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:02:54.921] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:02:54.921] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:02:54.922] MultisessionFuture started
[17:02:54.922] - Launch lazy future ... done
[17:02:54.922] run() for ‘MultisessionFuture’ ... done
[17:02:54.922] result() for ClusterFuture ...
[17:02:54.922] - result already collected: FutureResult
[17:02:54.922] result() for ClusterFuture ... done
[17:02:54.922] result() for ClusterFuture ...
[17:02:54.922] - result already collected: FutureResult
[17:02:54.922] result() for ClusterFuture ... done
[17:02:54.923] result() for ClusterFuture ...
[17:02:54.923] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.923] - Validating connection of MultisessionFuture
[17:02:54.923] - received message: FutureResult
[17:02:54.923] - Received FutureResult
[17:02:54.923] - Erased future from FutureRegistry
[17:02:54.923] result() for ClusterFuture ...
[17:02:54.923] - result already collected: FutureResult
[17:02:54.923] result() for ClusterFuture ... done
[17:02:54.924] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.924] result() for ClusterFuture ... done
[17:02:54.924] result() for ClusterFuture ...
[17:02:54.924] - result already collected: FutureResult
[17:02:54.924] result() for ClusterFuture ... done
[17:02:54.924] result() for ClusterFuture ...
[17:02:54.924] receiveMessageFromWorker() for ClusterFuture ...
[17:02:54.924] - Validating connection of MultisessionFuture
[17:02:54.965] - received message: FutureResult
[17:02:54.966] - Received FutureResult
[17:02:54.966] - Erased future from FutureRegistry
[17:02:54.966] result() for ClusterFuture ...
[17:02:54.966] - result already collected: FutureResult
[17:02:54.966] result() for ClusterFuture ... done
[17:02:54.966] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:54.966] result() for ClusterFuture ... done
[17:02:54.966] result() for ClusterFuture ...
[17:02:54.966] - result already collected: FutureResult
[17:02:54.966] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.967] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.967] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.969] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.969] Searching for globals ... DONE
[17:02:54.970] Resolving globals: TRUE
[17:02:54.970] Resolving any globals that are futures ...
[17:02:54.970] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.970] Resolving any globals that are futures ... DONE
[17:02:54.970] Resolving futures part of globals (recursively) ...
[17:02:54.970] resolve() on list ...
[17:02:54.970]  recursive: 99
[17:02:54.971]  length: 2
[17:02:54.971]  elements: ‘a’, ‘ii’
[17:02:54.971]  length: 1 (resolved future 1)
[17:02:54.971]  length: 0 (resolved future 2)
[17:02:54.971] resolve() on list ... DONE
[17:02:54.971] - globals: [2] ‘a’, ‘ii’
[17:02:54.971] Resolving futures part of globals (recursively) ... DONE
[17:02:54.971] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:54.972] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:54.972] - globals: [2] ‘a’, ‘ii’
[17:02:54.972] 
[17:02:54.972] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.973] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.973] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.975] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.975] Searching for globals ... DONE
[17:02:54.975] Resolving globals: TRUE
[17:02:54.975] Resolving any globals that are futures ...
[17:02:54.975] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.975] Resolving any globals that are futures ... DONE
[17:02:54.975] Resolving futures part of globals (recursively) ...
[17:02:54.976] resolve() on list ...
[17:02:54.976]  recursive: 99
[17:02:54.976]  length: 2
[17:02:54.976]  elements: ‘a’, ‘ii’
[17:02:54.976]  length: 1 (resolved future 1)
[17:02:54.976]  length: 0 (resolved future 2)
[17:02:54.976] resolve() on list ... DONE
[17:02:54.976] - globals: [2] ‘a’, ‘ii’
[17:02:54.976] Resolving futures part of globals (recursively) ... DONE
[17:02:54.977] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:54.977] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:54.977] - globals: [2] ‘a’, ‘ii’
[17:02:54.977] 
[17:02:54.977] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:54.978] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:54.978] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:54.980] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.980] Searching for globals ... DONE
[17:02:54.980] Resolving globals: TRUE
[17:02:54.980] Resolving any globals that are futures ...
[17:02:54.980] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:02:54.980] Resolving any globals that are futures ... DONE
[17:02:54.981] Resolving futures part of globals (recursively) ...
[17:02:54.981] resolve() on list ...
[17:02:54.981]  recursive: 99
[17:02:54.981]  length: 2
[17:02:54.981]  elements: ‘a’, ‘ii’
[17:02:54.981]  length: 1 (resolved future 1)
[17:02:54.981]  length: 0 (resolved future 2)
[17:02:54.981] resolve() on list ... DONE
[17:02:54.981] - globals: [2] ‘a’, ‘ii’
[17:02:54.982] Resolving futures part of globals (recursively) ... DONE
[17:02:54.982] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:54.982] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:02:54.982] - globals: [2] ‘a’, ‘ii’
[17:02:54.982] 
[17:02:54.982] getGlobalsAndPackages() ... DONE
[17:02:54.983] run() for ‘Future’ ...
[17:02:54.983] - state: ‘created’
[17:02:54.983] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:54.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:54.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:54.997]   - Field: ‘node’
[17:02:54.998]   - Field: ‘label’
[17:02:54.998]   - Field: ‘local’
[17:02:54.998]   - Field: ‘owner’
[17:02:54.998]   - Field: ‘envir’
[17:02:54.998]   - Field: ‘workers’
[17:02:54.998]   - Field: ‘packages’
[17:02:54.998]   - Field: ‘gc’
[17:02:54.998]   - Field: ‘conditions’
[17:02:54.998]   - Field: ‘persistent’
[17:02:54.998]   - Field: ‘expr’
[17:02:54.998]   - Field: ‘uuid’
[17:02:54.999]   - Field: ‘seed’
[17:02:54.999]   - Field: ‘version’
[17:02:54.999]   - Field: ‘result’
[17:02:54.999]   - Field: ‘asynchronous’
[17:02:54.999]   - Field: ‘calls’
[17:02:54.999]   - Field: ‘globals’
[17:02:54.999]   - Field: ‘stdout’
[17:02:54.999]   - Field: ‘earlySignal’
[17:02:54.999]   - Field: ‘lazy’
[17:02:54.999]   - Field: ‘state’
[17:02:55.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.000] - Launch lazy future ...
[17:02:55.000] Packages needed by the future expression (n = 0): <none>
[17:02:55.000] Packages needed by future strategies (n = 0): <none>
[17:02:55.000] {
[17:02:55.000]     {
[17:02:55.000]         {
[17:02:55.000]             ...future.startTime <- base::Sys.time()
[17:02:55.000]             {
[17:02:55.000]                 {
[17:02:55.000]                   {
[17:02:55.000]                     {
[17:02:55.000]                       base::local({
[17:02:55.000]                         has_future <- base::requireNamespace("future", 
[17:02:55.000]                           quietly = TRUE)
[17:02:55.000]                         if (has_future) {
[17:02:55.000]                           ns <- base::getNamespace("future")
[17:02:55.000]                           version <- ns[[".package"]][["version"]]
[17:02:55.000]                           if (is.null(version)) 
[17:02:55.000]                             version <- utils::packageVersion("future")
[17:02:55.000]                         }
[17:02:55.000]                         else {
[17:02:55.000]                           version <- NULL
[17:02:55.000]                         }
[17:02:55.000]                         if (!has_future || version < "1.8.0") {
[17:02:55.000]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.000]                             "", base::R.version$version.string), 
[17:02:55.000]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.000]                               "release", "version")], collapse = " "), 
[17:02:55.000]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.000]                             info)
[17:02:55.000]                           info <- base::paste(info, collapse = "; ")
[17:02:55.000]                           if (!has_future) {
[17:02:55.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.000]                               info)
[17:02:55.000]                           }
[17:02:55.000]                           else {
[17:02:55.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.000]                               info, version)
[17:02:55.000]                           }
[17:02:55.000]                           base::stop(msg)
[17:02:55.000]                         }
[17:02:55.000]                       })
[17:02:55.000]                     }
[17:02:55.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.000]                     base::options(mc.cores = 1L)
[17:02:55.000]                   }
[17:02:55.000]                   ...future.strategy.old <- future::plan("list")
[17:02:55.000]                   options(future.plan = NULL)
[17:02:55.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.000]                 }
[17:02:55.000]                 ...future.workdir <- getwd()
[17:02:55.000]             }
[17:02:55.000]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.000]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.000]         }
[17:02:55.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.000]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.000]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.000]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.000]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.000]             base::names(...future.oldOptions))
[17:02:55.000]     }
[17:02:55.000]     if (FALSE) {
[17:02:55.000]     }
[17:02:55.000]     else {
[17:02:55.000]         if (TRUE) {
[17:02:55.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.000]                 open = "w")
[17:02:55.000]         }
[17:02:55.000]         else {
[17:02:55.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.000]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.000]         }
[17:02:55.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.000]             base::sink(type = "output", split = FALSE)
[17:02:55.000]             base::close(...future.stdout)
[17:02:55.000]         }, add = TRUE)
[17:02:55.000]     }
[17:02:55.000]     ...future.frame <- base::sys.nframe()
[17:02:55.000]     ...future.conditions <- base::list()
[17:02:55.000]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.000]     if (FALSE) {
[17:02:55.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.000]     }
[17:02:55.000]     ...future.result <- base::tryCatch({
[17:02:55.000]         base::withCallingHandlers({
[17:02:55.000]             ...future.value <- base::withVisible(base::local({
[17:02:55.000]                 ...future.makeSendCondition <- base::local({
[17:02:55.000]                   sendCondition <- NULL
[17:02:55.000]                   function(frame = 1L) {
[17:02:55.000]                     if (is.function(sendCondition)) 
[17:02:55.000]                       return(sendCondition)
[17:02:55.000]                     ns <- getNamespace("parallel")
[17:02:55.000]                     if (exists("sendData", mode = "function", 
[17:02:55.000]                       envir = ns)) {
[17:02:55.000]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.000]                         envir = ns)
[17:02:55.000]                       envir <- sys.frame(frame)
[17:02:55.000]                       master <- NULL
[17:02:55.000]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.000]                         !identical(envir, emptyenv())) {
[17:02:55.000]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.000]                           inherits = FALSE)) {
[17:02:55.000]                           master <- get("master", mode = "list", 
[17:02:55.000]                             envir = envir, inherits = FALSE)
[17:02:55.000]                           if (inherits(master, c("SOCKnode", 
[17:02:55.000]                             "SOCK0node"))) {
[17:02:55.000]                             sendCondition <<- function(cond) {
[17:02:55.000]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.000]                                 success = TRUE)
[17:02:55.000]                               parallel_sendData(master, data)
[17:02:55.000]                             }
[17:02:55.000]                             return(sendCondition)
[17:02:55.000]                           }
[17:02:55.000]                         }
[17:02:55.000]                         frame <- frame + 1L
[17:02:55.000]                         envir <- sys.frame(frame)
[17:02:55.000]                       }
[17:02:55.000]                     }
[17:02:55.000]                     sendCondition <<- function(cond) NULL
[17:02:55.000]                   }
[17:02:55.000]                 })
[17:02:55.000]                 withCallingHandlers({
[17:02:55.000]                   {
[17:02:55.000]                     b <- a * ii
[17:02:55.000]                     a <- 0
[17:02:55.000]                     b
[17:02:55.000]                   }
[17:02:55.000]                 }, immediateCondition = function(cond) {
[17:02:55.000]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.000]                   sendCondition(cond)
[17:02:55.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.000]                   {
[17:02:55.000]                     inherits <- base::inherits
[17:02:55.000]                     invokeRestart <- base::invokeRestart
[17:02:55.000]                     is.null <- base::is.null
[17:02:55.000]                     muffled <- FALSE
[17:02:55.000]                     if (inherits(cond, "message")) {
[17:02:55.000]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.000]                       if (muffled) 
[17:02:55.000]                         invokeRestart("muffleMessage")
[17:02:55.000]                     }
[17:02:55.000]                     else if (inherits(cond, "warning")) {
[17:02:55.000]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.000]                       if (muffled) 
[17:02:55.000]                         invokeRestart("muffleWarning")
[17:02:55.000]                     }
[17:02:55.000]                     else if (inherits(cond, "condition")) {
[17:02:55.000]                       if (!is.null(pattern)) {
[17:02:55.000]                         computeRestarts <- base::computeRestarts
[17:02:55.000]                         grepl <- base::grepl
[17:02:55.000]                         restarts <- computeRestarts(cond)
[17:02:55.000]                         for (restart in restarts) {
[17:02:55.000]                           name <- restart$name
[17:02:55.000]                           if (is.null(name)) 
[17:02:55.000]                             next
[17:02:55.000]                           if (!grepl(pattern, name)) 
[17:02:55.000]                             next
[17:02:55.000]                           invokeRestart(restart)
[17:02:55.000]                           muffled <- TRUE
[17:02:55.000]                           break
[17:02:55.000]                         }
[17:02:55.000]                       }
[17:02:55.000]                     }
[17:02:55.000]                     invisible(muffled)
[17:02:55.000]                   }
[17:02:55.000]                   muffleCondition(cond)
[17:02:55.000]                 })
[17:02:55.000]             }))
[17:02:55.000]             future::FutureResult(value = ...future.value$value, 
[17:02:55.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.000]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.000]                     ...future.globalenv.names))
[17:02:55.000]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.000]         }, condition = base::local({
[17:02:55.000]             c <- base::c
[17:02:55.000]             inherits <- base::inherits
[17:02:55.000]             invokeRestart <- base::invokeRestart
[17:02:55.000]             length <- base::length
[17:02:55.000]             list <- base::list
[17:02:55.000]             seq.int <- base::seq.int
[17:02:55.000]             signalCondition <- base::signalCondition
[17:02:55.000]             sys.calls <- base::sys.calls
[17:02:55.000]             `[[` <- base::`[[`
[17:02:55.000]             `+` <- base::`+`
[17:02:55.000]             `<<-` <- base::`<<-`
[17:02:55.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.000]                   3L)]
[17:02:55.000]             }
[17:02:55.000]             function(cond) {
[17:02:55.000]                 is_error <- inherits(cond, "error")
[17:02:55.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.000]                   NULL)
[17:02:55.000]                 if (is_error) {
[17:02:55.000]                   sessionInformation <- function() {
[17:02:55.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.000]                       search = base::search(), system = base::Sys.info())
[17:02:55.000]                   }
[17:02:55.000]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.000]                     cond$call), session = sessionInformation(), 
[17:02:55.000]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.000]                   signalCondition(cond)
[17:02:55.000]                 }
[17:02:55.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.000]                 "immediateCondition"))) {
[17:02:55.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.000]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.000]                   if (TRUE && !signal) {
[17:02:55.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.000]                     {
[17:02:55.000]                       inherits <- base::inherits
[17:02:55.000]                       invokeRestart <- base::invokeRestart
[17:02:55.000]                       is.null <- base::is.null
[17:02:55.000]                       muffled <- FALSE
[17:02:55.000]                       if (inherits(cond, "message")) {
[17:02:55.000]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.000]                         if (muffled) 
[17:02:55.000]                           invokeRestart("muffleMessage")
[17:02:55.000]                       }
[17:02:55.000]                       else if (inherits(cond, "warning")) {
[17:02:55.000]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.000]                         if (muffled) 
[17:02:55.000]                           invokeRestart("muffleWarning")
[17:02:55.000]                       }
[17:02:55.000]                       else if (inherits(cond, "condition")) {
[17:02:55.000]                         if (!is.null(pattern)) {
[17:02:55.000]                           computeRestarts <- base::computeRestarts
[17:02:55.000]                           grepl <- base::grepl
[17:02:55.000]                           restarts <- computeRestarts(cond)
[17:02:55.000]                           for (restart in restarts) {
[17:02:55.000]                             name <- restart$name
[17:02:55.000]                             if (is.null(name)) 
[17:02:55.000]                               next
[17:02:55.000]                             if (!grepl(pattern, name)) 
[17:02:55.000]                               next
[17:02:55.000]                             invokeRestart(restart)
[17:02:55.000]                             muffled <- TRUE
[17:02:55.000]                             break
[17:02:55.000]                           }
[17:02:55.000]                         }
[17:02:55.000]                       }
[17:02:55.000]                       invisible(muffled)
[17:02:55.000]                     }
[17:02:55.000]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.000]                   }
[17:02:55.000]                 }
[17:02:55.000]                 else {
[17:02:55.000]                   if (TRUE) {
[17:02:55.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.000]                     {
[17:02:55.000]                       inherits <- base::inherits
[17:02:55.000]                       invokeRestart <- base::invokeRestart
[17:02:55.000]                       is.null <- base::is.null
[17:02:55.000]                       muffled <- FALSE
[17:02:55.000]                       if (inherits(cond, "message")) {
[17:02:55.000]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.000]                         if (muffled) 
[17:02:55.000]                           invokeRestart("muffleMessage")
[17:02:55.000]                       }
[17:02:55.000]                       else if (inherits(cond, "warning")) {
[17:02:55.000]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.000]                         if (muffled) 
[17:02:55.000]                           invokeRestart("muffleWarning")
[17:02:55.000]                       }
[17:02:55.000]                       else if (inherits(cond, "condition")) {
[17:02:55.000]                         if (!is.null(pattern)) {
[17:02:55.000]                           computeRestarts <- base::computeRestarts
[17:02:55.000]                           grepl <- base::grepl
[17:02:55.000]                           restarts <- computeRestarts(cond)
[17:02:55.000]                           for (restart in restarts) {
[17:02:55.000]                             name <- restart$name
[17:02:55.000]                             if (is.null(name)) 
[17:02:55.000]                               next
[17:02:55.000]                             if (!grepl(pattern, name)) 
[17:02:55.000]                               next
[17:02:55.000]                             invokeRestart(restart)
[17:02:55.000]                             muffled <- TRUE
[17:02:55.000]                             break
[17:02:55.000]                           }
[17:02:55.000]                         }
[17:02:55.000]                       }
[17:02:55.000]                       invisible(muffled)
[17:02:55.000]                     }
[17:02:55.000]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.000]                   }
[17:02:55.000]                 }
[17:02:55.000]             }
[17:02:55.000]         }))
[17:02:55.000]     }, error = function(ex) {
[17:02:55.000]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.000]                 ...future.rng), started = ...future.startTime, 
[17:02:55.000]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.000]             version = "1.8"), class = "FutureResult")
[17:02:55.000]     }, finally = {
[17:02:55.000]         if (!identical(...future.workdir, getwd())) 
[17:02:55.000]             setwd(...future.workdir)
[17:02:55.000]         {
[17:02:55.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.000]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.000]             }
[17:02:55.000]             base::options(...future.oldOptions)
[17:02:55.000]             if (.Platform$OS.type == "windows") {
[17:02:55.000]                 old_names <- names(...future.oldEnvVars)
[17:02:55.000]                 envs <- base::Sys.getenv()
[17:02:55.000]                 names <- names(envs)
[17:02:55.000]                 common <- intersect(names, old_names)
[17:02:55.000]                 added <- setdiff(names, old_names)
[17:02:55.000]                 removed <- setdiff(old_names, names)
[17:02:55.000]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.000]                   envs[common]]
[17:02:55.000]                 NAMES <- toupper(changed)
[17:02:55.000]                 args <- list()
[17:02:55.000]                 for (kk in seq_along(NAMES)) {
[17:02:55.000]                   name <- changed[[kk]]
[17:02:55.000]                   NAME <- NAMES[[kk]]
[17:02:55.000]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.000]                     next
[17:02:55.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.000]                 }
[17:02:55.000]                 NAMES <- toupper(added)
[17:02:55.000]                 for (kk in seq_along(NAMES)) {
[17:02:55.000]                   name <- added[[kk]]
[17:02:55.000]                   NAME <- NAMES[[kk]]
[17:02:55.000]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.000]                     next
[17:02:55.000]                   args[[name]] <- ""
[17:02:55.000]                 }
[17:02:55.000]                 NAMES <- toupper(removed)
[17:02:55.000]                 for (kk in seq_along(NAMES)) {
[17:02:55.000]                   name <- removed[[kk]]
[17:02:55.000]                   NAME <- NAMES[[kk]]
[17:02:55.000]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.000]                     next
[17:02:55.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.000]                 }
[17:02:55.000]                 if (length(args) > 0) 
[17:02:55.000]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.000]             }
[17:02:55.000]             else {
[17:02:55.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.000]             }
[17:02:55.000]             {
[17:02:55.000]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.000]                   0L) {
[17:02:55.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.000]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.000]                   base::options(opts)
[17:02:55.000]                 }
[17:02:55.000]                 {
[17:02:55.000]                   {
[17:02:55.000]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.000]                     NULL
[17:02:55.000]                   }
[17:02:55.000]                   options(future.plan = NULL)
[17:02:55.000]                   if (is.na(NA_character_)) 
[17:02:55.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.000]                     .init = FALSE)
[17:02:55.000]                 }
[17:02:55.000]             }
[17:02:55.000]         }
[17:02:55.000]     })
[17:02:55.000]     if (TRUE) {
[17:02:55.000]         base::sink(type = "output", split = FALSE)
[17:02:55.000]         if (TRUE) {
[17:02:55.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.000]         }
[17:02:55.000]         else {
[17:02:55.000]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.000]         }
[17:02:55.000]         base::close(...future.stdout)
[17:02:55.000]         ...future.stdout <- NULL
[17:02:55.000]     }
[17:02:55.000]     ...future.result$conditions <- ...future.conditions
[17:02:55.000]     ...future.result$finished <- base::Sys.time()
[17:02:55.000]     ...future.result
[17:02:55.000] }
[17:02:55.003] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:02:55.003] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:02:55.004] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.004] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:02:55.004] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.004] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:02:55.005] MultisessionFuture started
[17:02:55.005] - Launch lazy future ... done
[17:02:55.005] run() for ‘MultisessionFuture’ ... done
[17:02:55.005] result() for ClusterFuture ...
[17:02:55.005] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.005] - Validating connection of MultisessionFuture
[17:02:55.006] - received message: FutureResult
[17:02:55.006] - Received FutureResult
[17:02:55.007] - Erased future from FutureRegistry
[17:02:55.007] result() for ClusterFuture ...
[17:02:55.007] - result already collected: FutureResult
[17:02:55.007] result() for ClusterFuture ... done
[17:02:55.007] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.007] result() for ClusterFuture ... done
[17:02:55.007] result() for ClusterFuture ...
[17:02:55.007] - result already collected: FutureResult
[17:02:55.007] result() for ClusterFuture ... done
[17:02:55.007] run() for ‘Future’ ...
[17:02:55.007] - state: ‘created’
[17:02:55.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.024]   - Field: ‘node’
[17:02:55.025]   - Field: ‘label’
[17:02:55.025]   - Field: ‘local’
[17:02:55.025]   - Field: ‘owner’
[17:02:55.025]   - Field: ‘envir’
[17:02:55.025]   - Field: ‘workers’
[17:02:55.025]   - Field: ‘packages’
[17:02:55.025]   - Field: ‘gc’
[17:02:55.025]   - Field: ‘conditions’
[17:02:55.025]   - Field: ‘persistent’
[17:02:55.025]   - Field: ‘expr’
[17:02:55.025]   - Field: ‘uuid’
[17:02:55.026]   - Field: ‘seed’
[17:02:55.026]   - Field: ‘version’
[17:02:55.026]   - Field: ‘result’
[17:02:55.026]   - Field: ‘asynchronous’
[17:02:55.026]   - Field: ‘calls’
[17:02:55.026]   - Field: ‘globals’
[17:02:55.026]   - Field: ‘stdout’
[17:02:55.026]   - Field: ‘earlySignal’
[17:02:55.026]   - Field: ‘lazy’
[17:02:55.026]   - Field: ‘state’
[17:02:55.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.027] - Launch lazy future ...
[17:02:55.027] Packages needed by the future expression (n = 0): <none>
[17:02:55.027] Packages needed by future strategies (n = 0): <none>
[17:02:55.027] {
[17:02:55.027]     {
[17:02:55.027]         {
[17:02:55.027]             ...future.startTime <- base::Sys.time()
[17:02:55.027]             {
[17:02:55.027]                 {
[17:02:55.027]                   {
[17:02:55.027]                     {
[17:02:55.027]                       base::local({
[17:02:55.027]                         has_future <- base::requireNamespace("future", 
[17:02:55.027]                           quietly = TRUE)
[17:02:55.027]                         if (has_future) {
[17:02:55.027]                           ns <- base::getNamespace("future")
[17:02:55.027]                           version <- ns[[".package"]][["version"]]
[17:02:55.027]                           if (is.null(version)) 
[17:02:55.027]                             version <- utils::packageVersion("future")
[17:02:55.027]                         }
[17:02:55.027]                         else {
[17:02:55.027]                           version <- NULL
[17:02:55.027]                         }
[17:02:55.027]                         if (!has_future || version < "1.8.0") {
[17:02:55.027]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.027]                             "", base::R.version$version.string), 
[17:02:55.027]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.027]                               "release", "version")], collapse = " "), 
[17:02:55.027]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.027]                             info)
[17:02:55.027]                           info <- base::paste(info, collapse = "; ")
[17:02:55.027]                           if (!has_future) {
[17:02:55.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.027]                               info)
[17:02:55.027]                           }
[17:02:55.027]                           else {
[17:02:55.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.027]                               info, version)
[17:02:55.027]                           }
[17:02:55.027]                           base::stop(msg)
[17:02:55.027]                         }
[17:02:55.027]                       })
[17:02:55.027]                     }
[17:02:55.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.027]                     base::options(mc.cores = 1L)
[17:02:55.027]                   }
[17:02:55.027]                   ...future.strategy.old <- future::plan("list")
[17:02:55.027]                   options(future.plan = NULL)
[17:02:55.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.027]                 }
[17:02:55.027]                 ...future.workdir <- getwd()
[17:02:55.027]             }
[17:02:55.027]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.027]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.027]         }
[17:02:55.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.027]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.027]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.027]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.027]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.027]             base::names(...future.oldOptions))
[17:02:55.027]     }
[17:02:55.027]     if (FALSE) {
[17:02:55.027]     }
[17:02:55.027]     else {
[17:02:55.027]         if (TRUE) {
[17:02:55.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.027]                 open = "w")
[17:02:55.027]         }
[17:02:55.027]         else {
[17:02:55.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.027]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.027]         }
[17:02:55.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.027]             base::sink(type = "output", split = FALSE)
[17:02:55.027]             base::close(...future.stdout)
[17:02:55.027]         }, add = TRUE)
[17:02:55.027]     }
[17:02:55.027]     ...future.frame <- base::sys.nframe()
[17:02:55.027]     ...future.conditions <- base::list()
[17:02:55.027]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.027]     if (FALSE) {
[17:02:55.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.027]     }
[17:02:55.027]     ...future.result <- base::tryCatch({
[17:02:55.027]         base::withCallingHandlers({
[17:02:55.027]             ...future.value <- base::withVisible(base::local({
[17:02:55.027]                 ...future.makeSendCondition <- base::local({
[17:02:55.027]                   sendCondition <- NULL
[17:02:55.027]                   function(frame = 1L) {
[17:02:55.027]                     if (is.function(sendCondition)) 
[17:02:55.027]                       return(sendCondition)
[17:02:55.027]                     ns <- getNamespace("parallel")
[17:02:55.027]                     if (exists("sendData", mode = "function", 
[17:02:55.027]                       envir = ns)) {
[17:02:55.027]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.027]                         envir = ns)
[17:02:55.027]                       envir <- sys.frame(frame)
[17:02:55.027]                       master <- NULL
[17:02:55.027]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.027]                         !identical(envir, emptyenv())) {
[17:02:55.027]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.027]                           inherits = FALSE)) {
[17:02:55.027]                           master <- get("master", mode = "list", 
[17:02:55.027]                             envir = envir, inherits = FALSE)
[17:02:55.027]                           if (inherits(master, c("SOCKnode", 
[17:02:55.027]                             "SOCK0node"))) {
[17:02:55.027]                             sendCondition <<- function(cond) {
[17:02:55.027]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.027]                                 success = TRUE)
[17:02:55.027]                               parallel_sendData(master, data)
[17:02:55.027]                             }
[17:02:55.027]                             return(sendCondition)
[17:02:55.027]                           }
[17:02:55.027]                         }
[17:02:55.027]                         frame <- frame + 1L
[17:02:55.027]                         envir <- sys.frame(frame)
[17:02:55.027]                       }
[17:02:55.027]                     }
[17:02:55.027]                     sendCondition <<- function(cond) NULL
[17:02:55.027]                   }
[17:02:55.027]                 })
[17:02:55.027]                 withCallingHandlers({
[17:02:55.027]                   {
[17:02:55.027]                     b <- a * ii
[17:02:55.027]                     a <- 0
[17:02:55.027]                     b
[17:02:55.027]                   }
[17:02:55.027]                 }, immediateCondition = function(cond) {
[17:02:55.027]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.027]                   sendCondition(cond)
[17:02:55.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.027]                   {
[17:02:55.027]                     inherits <- base::inherits
[17:02:55.027]                     invokeRestart <- base::invokeRestart
[17:02:55.027]                     is.null <- base::is.null
[17:02:55.027]                     muffled <- FALSE
[17:02:55.027]                     if (inherits(cond, "message")) {
[17:02:55.027]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.027]                       if (muffled) 
[17:02:55.027]                         invokeRestart("muffleMessage")
[17:02:55.027]                     }
[17:02:55.027]                     else if (inherits(cond, "warning")) {
[17:02:55.027]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.027]                       if (muffled) 
[17:02:55.027]                         invokeRestart("muffleWarning")
[17:02:55.027]                     }
[17:02:55.027]                     else if (inherits(cond, "condition")) {
[17:02:55.027]                       if (!is.null(pattern)) {
[17:02:55.027]                         computeRestarts <- base::computeRestarts
[17:02:55.027]                         grepl <- base::grepl
[17:02:55.027]                         restarts <- computeRestarts(cond)
[17:02:55.027]                         for (restart in restarts) {
[17:02:55.027]                           name <- restart$name
[17:02:55.027]                           if (is.null(name)) 
[17:02:55.027]                             next
[17:02:55.027]                           if (!grepl(pattern, name)) 
[17:02:55.027]                             next
[17:02:55.027]                           invokeRestart(restart)
[17:02:55.027]                           muffled <- TRUE
[17:02:55.027]                           break
[17:02:55.027]                         }
[17:02:55.027]                       }
[17:02:55.027]                     }
[17:02:55.027]                     invisible(muffled)
[17:02:55.027]                   }
[17:02:55.027]                   muffleCondition(cond)
[17:02:55.027]                 })
[17:02:55.027]             }))
[17:02:55.027]             future::FutureResult(value = ...future.value$value, 
[17:02:55.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.027]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.027]                     ...future.globalenv.names))
[17:02:55.027]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.027]         }, condition = base::local({
[17:02:55.027]             c <- base::c
[17:02:55.027]             inherits <- base::inherits
[17:02:55.027]             invokeRestart <- base::invokeRestart
[17:02:55.027]             length <- base::length
[17:02:55.027]             list <- base::list
[17:02:55.027]             seq.int <- base::seq.int
[17:02:55.027]             signalCondition <- base::signalCondition
[17:02:55.027]             sys.calls <- base::sys.calls
[17:02:55.027]             `[[` <- base::`[[`
[17:02:55.027]             `+` <- base::`+`
[17:02:55.027]             `<<-` <- base::`<<-`
[17:02:55.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.027]                   3L)]
[17:02:55.027]             }
[17:02:55.027]             function(cond) {
[17:02:55.027]                 is_error <- inherits(cond, "error")
[17:02:55.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.027]                   NULL)
[17:02:55.027]                 if (is_error) {
[17:02:55.027]                   sessionInformation <- function() {
[17:02:55.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.027]                       search = base::search(), system = base::Sys.info())
[17:02:55.027]                   }
[17:02:55.027]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.027]                     cond$call), session = sessionInformation(), 
[17:02:55.027]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.027]                   signalCondition(cond)
[17:02:55.027]                 }
[17:02:55.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.027]                 "immediateCondition"))) {
[17:02:55.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.027]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.027]                   if (TRUE && !signal) {
[17:02:55.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.027]                     {
[17:02:55.027]                       inherits <- base::inherits
[17:02:55.027]                       invokeRestart <- base::invokeRestart
[17:02:55.027]                       is.null <- base::is.null
[17:02:55.027]                       muffled <- FALSE
[17:02:55.027]                       if (inherits(cond, "message")) {
[17:02:55.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.027]                         if (muffled) 
[17:02:55.027]                           invokeRestart("muffleMessage")
[17:02:55.027]                       }
[17:02:55.027]                       else if (inherits(cond, "warning")) {
[17:02:55.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.027]                         if (muffled) 
[17:02:55.027]                           invokeRestart("muffleWarning")
[17:02:55.027]                       }
[17:02:55.027]                       else if (inherits(cond, "condition")) {
[17:02:55.027]                         if (!is.null(pattern)) {
[17:02:55.027]                           computeRestarts <- base::computeRestarts
[17:02:55.027]                           grepl <- base::grepl
[17:02:55.027]                           restarts <- computeRestarts(cond)
[17:02:55.027]                           for (restart in restarts) {
[17:02:55.027]                             name <- restart$name
[17:02:55.027]                             if (is.null(name)) 
[17:02:55.027]                               next
[17:02:55.027]                             if (!grepl(pattern, name)) 
[17:02:55.027]                               next
[17:02:55.027]                             invokeRestart(restart)
[17:02:55.027]                             muffled <- TRUE
[17:02:55.027]                             break
[17:02:55.027]                           }
[17:02:55.027]                         }
[17:02:55.027]                       }
[17:02:55.027]                       invisible(muffled)
[17:02:55.027]                     }
[17:02:55.027]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.027]                   }
[17:02:55.027]                 }
[17:02:55.027]                 else {
[17:02:55.027]                   if (TRUE) {
[17:02:55.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.027]                     {
[17:02:55.027]                       inherits <- base::inherits
[17:02:55.027]                       invokeRestart <- base::invokeRestart
[17:02:55.027]                       is.null <- base::is.null
[17:02:55.027]                       muffled <- FALSE
[17:02:55.027]                       if (inherits(cond, "message")) {
[17:02:55.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.027]                         if (muffled) 
[17:02:55.027]                           invokeRestart("muffleMessage")
[17:02:55.027]                       }
[17:02:55.027]                       else if (inherits(cond, "warning")) {
[17:02:55.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.027]                         if (muffled) 
[17:02:55.027]                           invokeRestart("muffleWarning")
[17:02:55.027]                       }
[17:02:55.027]                       else if (inherits(cond, "condition")) {
[17:02:55.027]                         if (!is.null(pattern)) {
[17:02:55.027]                           computeRestarts <- base::computeRestarts
[17:02:55.027]                           grepl <- base::grepl
[17:02:55.027]                           restarts <- computeRestarts(cond)
[17:02:55.027]                           for (restart in restarts) {
[17:02:55.027]                             name <- restart$name
[17:02:55.027]                             if (is.null(name)) 
[17:02:55.027]                               next
[17:02:55.027]                             if (!grepl(pattern, name)) 
[17:02:55.027]                               next
[17:02:55.027]                             invokeRestart(restart)
[17:02:55.027]                             muffled <- TRUE
[17:02:55.027]                             break
[17:02:55.027]                           }
[17:02:55.027]                         }
[17:02:55.027]                       }
[17:02:55.027]                       invisible(muffled)
[17:02:55.027]                     }
[17:02:55.027]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.027]                   }
[17:02:55.027]                 }
[17:02:55.027]             }
[17:02:55.027]         }))
[17:02:55.027]     }, error = function(ex) {
[17:02:55.027]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.027]                 ...future.rng), started = ...future.startTime, 
[17:02:55.027]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.027]             version = "1.8"), class = "FutureResult")
[17:02:55.027]     }, finally = {
[17:02:55.027]         if (!identical(...future.workdir, getwd())) 
[17:02:55.027]             setwd(...future.workdir)
[17:02:55.027]         {
[17:02:55.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.027]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.027]             }
[17:02:55.027]             base::options(...future.oldOptions)
[17:02:55.027]             if (.Platform$OS.type == "windows") {
[17:02:55.027]                 old_names <- names(...future.oldEnvVars)
[17:02:55.027]                 envs <- base::Sys.getenv()
[17:02:55.027]                 names <- names(envs)
[17:02:55.027]                 common <- intersect(names, old_names)
[17:02:55.027]                 added <- setdiff(names, old_names)
[17:02:55.027]                 removed <- setdiff(old_names, names)
[17:02:55.027]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.027]                   envs[common]]
[17:02:55.027]                 NAMES <- toupper(changed)
[17:02:55.027]                 args <- list()
[17:02:55.027]                 for (kk in seq_along(NAMES)) {
[17:02:55.027]                   name <- changed[[kk]]
[17:02:55.027]                   NAME <- NAMES[[kk]]
[17:02:55.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.027]                     next
[17:02:55.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.027]                 }
[17:02:55.027]                 NAMES <- toupper(added)
[17:02:55.027]                 for (kk in seq_along(NAMES)) {
[17:02:55.027]                   name <- added[[kk]]
[17:02:55.027]                   NAME <- NAMES[[kk]]
[17:02:55.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.027]                     next
[17:02:55.027]                   args[[name]] <- ""
[17:02:55.027]                 }
[17:02:55.027]                 NAMES <- toupper(removed)
[17:02:55.027]                 for (kk in seq_along(NAMES)) {
[17:02:55.027]                   name <- removed[[kk]]
[17:02:55.027]                   NAME <- NAMES[[kk]]
[17:02:55.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.027]                     next
[17:02:55.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.027]                 }
[17:02:55.027]                 if (length(args) > 0) 
[17:02:55.027]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.027]             }
[17:02:55.027]             else {
[17:02:55.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.027]             }
[17:02:55.027]             {
[17:02:55.027]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.027]                   0L) {
[17:02:55.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.027]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.027]                   base::options(opts)
[17:02:55.027]                 }
[17:02:55.027]                 {
[17:02:55.027]                   {
[17:02:55.027]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.027]                     NULL
[17:02:55.027]                   }
[17:02:55.027]                   options(future.plan = NULL)
[17:02:55.027]                   if (is.na(NA_character_)) 
[17:02:55.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.027]                     .init = FALSE)
[17:02:55.027]                 }
[17:02:55.027]             }
[17:02:55.027]         }
[17:02:55.027]     })
[17:02:55.027]     if (TRUE) {
[17:02:55.027]         base::sink(type = "output", split = FALSE)
[17:02:55.027]         if (TRUE) {
[17:02:55.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.027]         }
[17:02:55.027]         else {
[17:02:55.027]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.027]         }
[17:02:55.027]         base::close(...future.stdout)
[17:02:55.027]         ...future.stdout <- NULL
[17:02:55.027]     }
[17:02:55.027]     ...future.result$conditions <- ...future.conditions
[17:02:55.027]     ...future.result$finished <- base::Sys.time()
[17:02:55.027]     ...future.result
[17:02:55.027] }
[17:02:55.030] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:02:55.030] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:02:55.031] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.031] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:02:55.031] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.031] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:02:55.032] MultisessionFuture started
[17:02:55.032] - Launch lazy future ... done
[17:02:55.032] run() for ‘MultisessionFuture’ ... done
[17:02:55.032] result() for ClusterFuture ...
[17:02:55.032] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.032] - Validating connection of MultisessionFuture
[17:02:55.033] - received message: FutureResult
[17:02:55.033] - Received FutureResult
[17:02:55.033] - Erased future from FutureRegistry
[17:02:55.033] result() for ClusterFuture ...
[17:02:55.034] - result already collected: FutureResult
[17:02:55.034] result() for ClusterFuture ... done
[17:02:55.034] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.034] result() for ClusterFuture ... done
[17:02:55.034] result() for ClusterFuture ...
[17:02:55.034] - result already collected: FutureResult
[17:02:55.034] result() for ClusterFuture ... done
[17:02:55.034] run() for ‘Future’ ...
[17:02:55.034] - state: ‘created’
[17:02:55.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.049] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.049]   - Field: ‘node’
[17:02:55.049]   - Field: ‘label’
[17:02:55.050]   - Field: ‘local’
[17:02:55.050]   - Field: ‘owner’
[17:02:55.050]   - Field: ‘envir’
[17:02:55.050]   - Field: ‘workers’
[17:02:55.050]   - Field: ‘packages’
[17:02:55.050]   - Field: ‘gc’
[17:02:55.050]   - Field: ‘conditions’
[17:02:55.050]   - Field: ‘persistent’
[17:02:55.050]   - Field: ‘expr’
[17:02:55.050]   - Field: ‘uuid’
[17:02:55.051]   - Field: ‘seed’
[17:02:55.051]   - Field: ‘version’
[17:02:55.051]   - Field: ‘result’
[17:02:55.051]   - Field: ‘asynchronous’
[17:02:55.051]   - Field: ‘calls’
[17:02:55.051]   - Field: ‘globals’
[17:02:55.051]   - Field: ‘stdout’
[17:02:55.051]   - Field: ‘earlySignal’
[17:02:55.051]   - Field: ‘lazy’
[17:02:55.051]   - Field: ‘state’
[17:02:55.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.052] - Launch lazy future ...
[17:02:55.052] Packages needed by the future expression (n = 0): <none>
[17:02:55.052] Packages needed by future strategies (n = 0): <none>
[17:02:55.052] {
[17:02:55.052]     {
[17:02:55.052]         {
[17:02:55.052]             ...future.startTime <- base::Sys.time()
[17:02:55.052]             {
[17:02:55.052]                 {
[17:02:55.052]                   {
[17:02:55.052]                     {
[17:02:55.052]                       base::local({
[17:02:55.052]                         has_future <- base::requireNamespace("future", 
[17:02:55.052]                           quietly = TRUE)
[17:02:55.052]                         if (has_future) {
[17:02:55.052]                           ns <- base::getNamespace("future")
[17:02:55.052]                           version <- ns[[".package"]][["version"]]
[17:02:55.052]                           if (is.null(version)) 
[17:02:55.052]                             version <- utils::packageVersion("future")
[17:02:55.052]                         }
[17:02:55.052]                         else {
[17:02:55.052]                           version <- NULL
[17:02:55.052]                         }
[17:02:55.052]                         if (!has_future || version < "1.8.0") {
[17:02:55.052]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.052]                             "", base::R.version$version.string), 
[17:02:55.052]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.052]                               "release", "version")], collapse = " "), 
[17:02:55.052]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.052]                             info)
[17:02:55.052]                           info <- base::paste(info, collapse = "; ")
[17:02:55.052]                           if (!has_future) {
[17:02:55.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.052]                               info)
[17:02:55.052]                           }
[17:02:55.052]                           else {
[17:02:55.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.052]                               info, version)
[17:02:55.052]                           }
[17:02:55.052]                           base::stop(msg)
[17:02:55.052]                         }
[17:02:55.052]                       })
[17:02:55.052]                     }
[17:02:55.052]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.052]                     base::options(mc.cores = 1L)
[17:02:55.052]                   }
[17:02:55.052]                   ...future.strategy.old <- future::plan("list")
[17:02:55.052]                   options(future.plan = NULL)
[17:02:55.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.052]                 }
[17:02:55.052]                 ...future.workdir <- getwd()
[17:02:55.052]             }
[17:02:55.052]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.052]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.052]         }
[17:02:55.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.052]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.052]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.052]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.052]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.052]             base::names(...future.oldOptions))
[17:02:55.052]     }
[17:02:55.052]     if (FALSE) {
[17:02:55.052]     }
[17:02:55.052]     else {
[17:02:55.052]         if (TRUE) {
[17:02:55.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.052]                 open = "w")
[17:02:55.052]         }
[17:02:55.052]         else {
[17:02:55.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.052]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.052]         }
[17:02:55.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.052]             base::sink(type = "output", split = FALSE)
[17:02:55.052]             base::close(...future.stdout)
[17:02:55.052]         }, add = TRUE)
[17:02:55.052]     }
[17:02:55.052]     ...future.frame <- base::sys.nframe()
[17:02:55.052]     ...future.conditions <- base::list()
[17:02:55.052]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.052]     if (FALSE) {
[17:02:55.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.052]     }
[17:02:55.052]     ...future.result <- base::tryCatch({
[17:02:55.052]         base::withCallingHandlers({
[17:02:55.052]             ...future.value <- base::withVisible(base::local({
[17:02:55.052]                 ...future.makeSendCondition <- base::local({
[17:02:55.052]                   sendCondition <- NULL
[17:02:55.052]                   function(frame = 1L) {
[17:02:55.052]                     if (is.function(sendCondition)) 
[17:02:55.052]                       return(sendCondition)
[17:02:55.052]                     ns <- getNamespace("parallel")
[17:02:55.052]                     if (exists("sendData", mode = "function", 
[17:02:55.052]                       envir = ns)) {
[17:02:55.052]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.052]                         envir = ns)
[17:02:55.052]                       envir <- sys.frame(frame)
[17:02:55.052]                       master <- NULL
[17:02:55.052]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.052]                         !identical(envir, emptyenv())) {
[17:02:55.052]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.052]                           inherits = FALSE)) {
[17:02:55.052]                           master <- get("master", mode = "list", 
[17:02:55.052]                             envir = envir, inherits = FALSE)
[17:02:55.052]                           if (inherits(master, c("SOCKnode", 
[17:02:55.052]                             "SOCK0node"))) {
[17:02:55.052]                             sendCondition <<- function(cond) {
[17:02:55.052]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.052]                                 success = TRUE)
[17:02:55.052]                               parallel_sendData(master, data)
[17:02:55.052]                             }
[17:02:55.052]                             return(sendCondition)
[17:02:55.052]                           }
[17:02:55.052]                         }
[17:02:55.052]                         frame <- frame + 1L
[17:02:55.052]                         envir <- sys.frame(frame)
[17:02:55.052]                       }
[17:02:55.052]                     }
[17:02:55.052]                     sendCondition <<- function(cond) NULL
[17:02:55.052]                   }
[17:02:55.052]                 })
[17:02:55.052]                 withCallingHandlers({
[17:02:55.052]                   {
[17:02:55.052]                     b <- a * ii
[17:02:55.052]                     a <- 0
[17:02:55.052]                     b
[17:02:55.052]                   }
[17:02:55.052]                 }, immediateCondition = function(cond) {
[17:02:55.052]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.052]                   sendCondition(cond)
[17:02:55.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.052]                   {
[17:02:55.052]                     inherits <- base::inherits
[17:02:55.052]                     invokeRestart <- base::invokeRestart
[17:02:55.052]                     is.null <- base::is.null
[17:02:55.052]                     muffled <- FALSE
[17:02:55.052]                     if (inherits(cond, "message")) {
[17:02:55.052]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.052]                       if (muffled) 
[17:02:55.052]                         invokeRestart("muffleMessage")
[17:02:55.052]                     }
[17:02:55.052]                     else if (inherits(cond, "warning")) {
[17:02:55.052]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.052]                       if (muffled) 
[17:02:55.052]                         invokeRestart("muffleWarning")
[17:02:55.052]                     }
[17:02:55.052]                     else if (inherits(cond, "condition")) {
[17:02:55.052]                       if (!is.null(pattern)) {
[17:02:55.052]                         computeRestarts <- base::computeRestarts
[17:02:55.052]                         grepl <- base::grepl
[17:02:55.052]                         restarts <- computeRestarts(cond)
[17:02:55.052]                         for (restart in restarts) {
[17:02:55.052]                           name <- restart$name
[17:02:55.052]                           if (is.null(name)) 
[17:02:55.052]                             next
[17:02:55.052]                           if (!grepl(pattern, name)) 
[17:02:55.052]                             next
[17:02:55.052]                           invokeRestart(restart)
[17:02:55.052]                           muffled <- TRUE
[17:02:55.052]                           break
[17:02:55.052]                         }
[17:02:55.052]                       }
[17:02:55.052]                     }
[17:02:55.052]                     invisible(muffled)
[17:02:55.052]                   }
[17:02:55.052]                   muffleCondition(cond)
[17:02:55.052]                 })
[17:02:55.052]             }))
[17:02:55.052]             future::FutureResult(value = ...future.value$value, 
[17:02:55.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.052]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.052]                     ...future.globalenv.names))
[17:02:55.052]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.052]         }, condition = base::local({
[17:02:55.052]             c <- base::c
[17:02:55.052]             inherits <- base::inherits
[17:02:55.052]             invokeRestart <- base::invokeRestart
[17:02:55.052]             length <- base::length
[17:02:55.052]             list <- base::list
[17:02:55.052]             seq.int <- base::seq.int
[17:02:55.052]             signalCondition <- base::signalCondition
[17:02:55.052]             sys.calls <- base::sys.calls
[17:02:55.052]             `[[` <- base::`[[`
[17:02:55.052]             `+` <- base::`+`
[17:02:55.052]             `<<-` <- base::`<<-`
[17:02:55.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.052]                   3L)]
[17:02:55.052]             }
[17:02:55.052]             function(cond) {
[17:02:55.052]                 is_error <- inherits(cond, "error")
[17:02:55.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.052]                   NULL)
[17:02:55.052]                 if (is_error) {
[17:02:55.052]                   sessionInformation <- function() {
[17:02:55.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.052]                       search = base::search(), system = base::Sys.info())
[17:02:55.052]                   }
[17:02:55.052]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.052]                     cond$call), session = sessionInformation(), 
[17:02:55.052]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.052]                   signalCondition(cond)
[17:02:55.052]                 }
[17:02:55.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.052]                 "immediateCondition"))) {
[17:02:55.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.052]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.052]                   if (TRUE && !signal) {
[17:02:55.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.052]                     {
[17:02:55.052]                       inherits <- base::inherits
[17:02:55.052]                       invokeRestart <- base::invokeRestart
[17:02:55.052]                       is.null <- base::is.null
[17:02:55.052]                       muffled <- FALSE
[17:02:55.052]                       if (inherits(cond, "message")) {
[17:02:55.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.052]                         if (muffled) 
[17:02:55.052]                           invokeRestart("muffleMessage")
[17:02:55.052]                       }
[17:02:55.052]                       else if (inherits(cond, "warning")) {
[17:02:55.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.052]                         if (muffled) 
[17:02:55.052]                           invokeRestart("muffleWarning")
[17:02:55.052]                       }
[17:02:55.052]                       else if (inherits(cond, "condition")) {
[17:02:55.052]                         if (!is.null(pattern)) {
[17:02:55.052]                           computeRestarts <- base::computeRestarts
[17:02:55.052]                           grepl <- base::grepl
[17:02:55.052]                           restarts <- computeRestarts(cond)
[17:02:55.052]                           for (restart in restarts) {
[17:02:55.052]                             name <- restart$name
[17:02:55.052]                             if (is.null(name)) 
[17:02:55.052]                               next
[17:02:55.052]                             if (!grepl(pattern, name)) 
[17:02:55.052]                               next
[17:02:55.052]                             invokeRestart(restart)
[17:02:55.052]                             muffled <- TRUE
[17:02:55.052]                             break
[17:02:55.052]                           }
[17:02:55.052]                         }
[17:02:55.052]                       }
[17:02:55.052]                       invisible(muffled)
[17:02:55.052]                     }
[17:02:55.052]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.052]                   }
[17:02:55.052]                 }
[17:02:55.052]                 else {
[17:02:55.052]                   if (TRUE) {
[17:02:55.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.052]                     {
[17:02:55.052]                       inherits <- base::inherits
[17:02:55.052]                       invokeRestart <- base::invokeRestart
[17:02:55.052]                       is.null <- base::is.null
[17:02:55.052]                       muffled <- FALSE
[17:02:55.052]                       if (inherits(cond, "message")) {
[17:02:55.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.052]                         if (muffled) 
[17:02:55.052]                           invokeRestart("muffleMessage")
[17:02:55.052]                       }
[17:02:55.052]                       else if (inherits(cond, "warning")) {
[17:02:55.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.052]                         if (muffled) 
[17:02:55.052]                           invokeRestart("muffleWarning")
[17:02:55.052]                       }
[17:02:55.052]                       else if (inherits(cond, "condition")) {
[17:02:55.052]                         if (!is.null(pattern)) {
[17:02:55.052]                           computeRestarts <- base::computeRestarts
[17:02:55.052]                           grepl <- base::grepl
[17:02:55.052]                           restarts <- computeRestarts(cond)
[17:02:55.052]                           for (restart in restarts) {
[17:02:55.052]                             name <- restart$name
[17:02:55.052]                             if (is.null(name)) 
[17:02:55.052]                               next
[17:02:55.052]                             if (!grepl(pattern, name)) 
[17:02:55.052]                               next
[17:02:55.052]                             invokeRestart(restart)
[17:02:55.052]                             muffled <- TRUE
[17:02:55.052]                             break
[17:02:55.052]                           }
[17:02:55.052]                         }
[17:02:55.052]                       }
[17:02:55.052]                       invisible(muffled)
[17:02:55.052]                     }
[17:02:55.052]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.052]                   }
[17:02:55.052]                 }
[17:02:55.052]             }
[17:02:55.052]         }))
[17:02:55.052]     }, error = function(ex) {
[17:02:55.052]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.052]                 ...future.rng), started = ...future.startTime, 
[17:02:55.052]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.052]             version = "1.8"), class = "FutureResult")
[17:02:55.052]     }, finally = {
[17:02:55.052]         if (!identical(...future.workdir, getwd())) 
[17:02:55.052]             setwd(...future.workdir)
[17:02:55.052]         {
[17:02:55.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.052]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.052]             }
[17:02:55.052]             base::options(...future.oldOptions)
[17:02:55.052]             if (.Platform$OS.type == "windows") {
[17:02:55.052]                 old_names <- names(...future.oldEnvVars)
[17:02:55.052]                 envs <- base::Sys.getenv()
[17:02:55.052]                 names <- names(envs)
[17:02:55.052]                 common <- intersect(names, old_names)
[17:02:55.052]                 added <- setdiff(names, old_names)
[17:02:55.052]                 removed <- setdiff(old_names, names)
[17:02:55.052]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.052]                   envs[common]]
[17:02:55.052]                 NAMES <- toupper(changed)
[17:02:55.052]                 args <- list()
[17:02:55.052]                 for (kk in seq_along(NAMES)) {
[17:02:55.052]                   name <- changed[[kk]]
[17:02:55.052]                   NAME <- NAMES[[kk]]
[17:02:55.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.052]                     next
[17:02:55.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.052]                 }
[17:02:55.052]                 NAMES <- toupper(added)
[17:02:55.052]                 for (kk in seq_along(NAMES)) {
[17:02:55.052]                   name <- added[[kk]]
[17:02:55.052]                   NAME <- NAMES[[kk]]
[17:02:55.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.052]                     next
[17:02:55.052]                   args[[name]] <- ""
[17:02:55.052]                 }
[17:02:55.052]                 NAMES <- toupper(removed)
[17:02:55.052]                 for (kk in seq_along(NAMES)) {
[17:02:55.052]                   name <- removed[[kk]]
[17:02:55.052]                   NAME <- NAMES[[kk]]
[17:02:55.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.052]                     next
[17:02:55.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.052]                 }
[17:02:55.052]                 if (length(args) > 0) 
[17:02:55.052]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.052]             }
[17:02:55.052]             else {
[17:02:55.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.052]             }
[17:02:55.052]             {
[17:02:55.052]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.052]                   0L) {
[17:02:55.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.052]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.052]                   base::options(opts)
[17:02:55.052]                 }
[17:02:55.052]                 {
[17:02:55.052]                   {
[17:02:55.052]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.052]                     NULL
[17:02:55.052]                   }
[17:02:55.052]                   options(future.plan = NULL)
[17:02:55.052]                   if (is.na(NA_character_)) 
[17:02:55.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.052]                     .init = FALSE)
[17:02:55.052]                 }
[17:02:55.052]             }
[17:02:55.052]         }
[17:02:55.052]     })
[17:02:55.052]     if (TRUE) {
[17:02:55.052]         base::sink(type = "output", split = FALSE)
[17:02:55.052]         if (TRUE) {
[17:02:55.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.052]         }
[17:02:55.052]         else {
[17:02:55.052]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.052]         }
[17:02:55.052]         base::close(...future.stdout)
[17:02:55.052]         ...future.stdout <- NULL
[17:02:55.052]     }
[17:02:55.052]     ...future.result$conditions <- ...future.conditions
[17:02:55.052]     ...future.result$finished <- base::Sys.time()
[17:02:55.052]     ...future.result
[17:02:55.052] }
[17:02:55.055] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:02:55.055] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:02:55.056] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.056] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:02:55.056] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.056] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:02:55.057] MultisessionFuture started
[17:02:55.057] - Launch lazy future ... done
[17:02:55.057] run() for ‘MultisessionFuture’ ... done
[17:02:55.057] result() for ClusterFuture ...
[17:02:55.057] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.057] - Validating connection of MultisessionFuture
[17:02:55.058] - received message: FutureResult
[17:02:55.058] - Received FutureResult
[17:02:55.058] - Erased future from FutureRegistry
[17:02:55.059] result() for ClusterFuture ...
[17:02:55.059] - result already collected: FutureResult
[17:02:55.059] result() for ClusterFuture ... done
[17:02:55.059] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.059] result() for ClusterFuture ... done
[17:02:55.059] result() for ClusterFuture ...
[17:02:55.059] - result already collected: FutureResult
[17:02:55.059] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.060] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.060] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.060] 
[17:02:55.060] Searching for globals ... DONE
[17:02:55.060] - globals: [0] <none>
[17:02:55.061] getGlobalsAndPackages() ... DONE
[17:02:55.061] run() for ‘Future’ ...
[17:02:55.061] - state: ‘created’
[17:02:55.061] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.076] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.077]   - Field: ‘node’
[17:02:55.077]   - Field: ‘label’
[17:02:55.077]   - Field: ‘local’
[17:02:55.077]   - Field: ‘owner’
[17:02:55.077]   - Field: ‘envir’
[17:02:55.077]   - Field: ‘workers’
[17:02:55.077]   - Field: ‘packages’
[17:02:55.077]   - Field: ‘gc’
[17:02:55.077]   - Field: ‘conditions’
[17:02:55.077]   - Field: ‘persistent’
[17:02:55.077]   - Field: ‘expr’
[17:02:55.078]   - Field: ‘uuid’
[17:02:55.078]   - Field: ‘seed’
[17:02:55.078]   - Field: ‘version’
[17:02:55.078]   - Field: ‘result’
[17:02:55.078]   - Field: ‘asynchronous’
[17:02:55.078]   - Field: ‘calls’
[17:02:55.078]   - Field: ‘globals’
[17:02:55.078]   - Field: ‘stdout’
[17:02:55.078]   - Field: ‘earlySignal’
[17:02:55.078]   - Field: ‘lazy’
[17:02:55.078]   - Field: ‘state’
[17:02:55.079] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.079] - Launch lazy future ...
[17:02:55.079] Packages needed by the future expression (n = 0): <none>
[17:02:55.079] Packages needed by future strategies (n = 0): <none>
[17:02:55.080] {
[17:02:55.080]     {
[17:02:55.080]         {
[17:02:55.080]             ...future.startTime <- base::Sys.time()
[17:02:55.080]             {
[17:02:55.080]                 {
[17:02:55.080]                   {
[17:02:55.080]                     {
[17:02:55.080]                       base::local({
[17:02:55.080]                         has_future <- base::requireNamespace("future", 
[17:02:55.080]                           quietly = TRUE)
[17:02:55.080]                         if (has_future) {
[17:02:55.080]                           ns <- base::getNamespace("future")
[17:02:55.080]                           version <- ns[[".package"]][["version"]]
[17:02:55.080]                           if (is.null(version)) 
[17:02:55.080]                             version <- utils::packageVersion("future")
[17:02:55.080]                         }
[17:02:55.080]                         else {
[17:02:55.080]                           version <- NULL
[17:02:55.080]                         }
[17:02:55.080]                         if (!has_future || version < "1.8.0") {
[17:02:55.080]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.080]                             "", base::R.version$version.string), 
[17:02:55.080]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.080]                               "release", "version")], collapse = " "), 
[17:02:55.080]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.080]                             info)
[17:02:55.080]                           info <- base::paste(info, collapse = "; ")
[17:02:55.080]                           if (!has_future) {
[17:02:55.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.080]                               info)
[17:02:55.080]                           }
[17:02:55.080]                           else {
[17:02:55.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.080]                               info, version)
[17:02:55.080]                           }
[17:02:55.080]                           base::stop(msg)
[17:02:55.080]                         }
[17:02:55.080]                       })
[17:02:55.080]                     }
[17:02:55.080]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.080]                     base::options(mc.cores = 1L)
[17:02:55.080]                   }
[17:02:55.080]                   ...future.strategy.old <- future::plan("list")
[17:02:55.080]                   options(future.plan = NULL)
[17:02:55.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.080]                 }
[17:02:55.080]                 ...future.workdir <- getwd()
[17:02:55.080]             }
[17:02:55.080]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.080]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.080]         }
[17:02:55.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.080]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.080]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.080]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.080]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.080]             base::names(...future.oldOptions))
[17:02:55.080]     }
[17:02:55.080]     if (FALSE) {
[17:02:55.080]     }
[17:02:55.080]     else {
[17:02:55.080]         if (TRUE) {
[17:02:55.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.080]                 open = "w")
[17:02:55.080]         }
[17:02:55.080]         else {
[17:02:55.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.080]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.080]         }
[17:02:55.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.080]             base::sink(type = "output", split = FALSE)
[17:02:55.080]             base::close(...future.stdout)
[17:02:55.080]         }, add = TRUE)
[17:02:55.080]     }
[17:02:55.080]     ...future.frame <- base::sys.nframe()
[17:02:55.080]     ...future.conditions <- base::list()
[17:02:55.080]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.080]     if (FALSE) {
[17:02:55.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.080]     }
[17:02:55.080]     ...future.result <- base::tryCatch({
[17:02:55.080]         base::withCallingHandlers({
[17:02:55.080]             ...future.value <- base::withVisible(base::local({
[17:02:55.080]                 ...future.makeSendCondition <- base::local({
[17:02:55.080]                   sendCondition <- NULL
[17:02:55.080]                   function(frame = 1L) {
[17:02:55.080]                     if (is.function(sendCondition)) 
[17:02:55.080]                       return(sendCondition)
[17:02:55.080]                     ns <- getNamespace("parallel")
[17:02:55.080]                     if (exists("sendData", mode = "function", 
[17:02:55.080]                       envir = ns)) {
[17:02:55.080]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.080]                         envir = ns)
[17:02:55.080]                       envir <- sys.frame(frame)
[17:02:55.080]                       master <- NULL
[17:02:55.080]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.080]                         !identical(envir, emptyenv())) {
[17:02:55.080]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.080]                           inherits = FALSE)) {
[17:02:55.080]                           master <- get("master", mode = "list", 
[17:02:55.080]                             envir = envir, inherits = FALSE)
[17:02:55.080]                           if (inherits(master, c("SOCKnode", 
[17:02:55.080]                             "SOCK0node"))) {
[17:02:55.080]                             sendCondition <<- function(cond) {
[17:02:55.080]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.080]                                 success = TRUE)
[17:02:55.080]                               parallel_sendData(master, data)
[17:02:55.080]                             }
[17:02:55.080]                             return(sendCondition)
[17:02:55.080]                           }
[17:02:55.080]                         }
[17:02:55.080]                         frame <- frame + 1L
[17:02:55.080]                         envir <- sys.frame(frame)
[17:02:55.080]                       }
[17:02:55.080]                     }
[17:02:55.080]                     sendCondition <<- function(cond) NULL
[17:02:55.080]                   }
[17:02:55.080]                 })
[17:02:55.080]                 withCallingHandlers({
[17:02:55.080]                   1
[17:02:55.080]                 }, immediateCondition = function(cond) {
[17:02:55.080]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.080]                   sendCondition(cond)
[17:02:55.080]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.080]                   {
[17:02:55.080]                     inherits <- base::inherits
[17:02:55.080]                     invokeRestart <- base::invokeRestart
[17:02:55.080]                     is.null <- base::is.null
[17:02:55.080]                     muffled <- FALSE
[17:02:55.080]                     if (inherits(cond, "message")) {
[17:02:55.080]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.080]                       if (muffled) 
[17:02:55.080]                         invokeRestart("muffleMessage")
[17:02:55.080]                     }
[17:02:55.080]                     else if (inherits(cond, "warning")) {
[17:02:55.080]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.080]                       if (muffled) 
[17:02:55.080]                         invokeRestart("muffleWarning")
[17:02:55.080]                     }
[17:02:55.080]                     else if (inherits(cond, "condition")) {
[17:02:55.080]                       if (!is.null(pattern)) {
[17:02:55.080]                         computeRestarts <- base::computeRestarts
[17:02:55.080]                         grepl <- base::grepl
[17:02:55.080]                         restarts <- computeRestarts(cond)
[17:02:55.080]                         for (restart in restarts) {
[17:02:55.080]                           name <- restart$name
[17:02:55.080]                           if (is.null(name)) 
[17:02:55.080]                             next
[17:02:55.080]                           if (!grepl(pattern, name)) 
[17:02:55.080]                             next
[17:02:55.080]                           invokeRestart(restart)
[17:02:55.080]                           muffled <- TRUE
[17:02:55.080]                           break
[17:02:55.080]                         }
[17:02:55.080]                       }
[17:02:55.080]                     }
[17:02:55.080]                     invisible(muffled)
[17:02:55.080]                   }
[17:02:55.080]                   muffleCondition(cond)
[17:02:55.080]                 })
[17:02:55.080]             }))
[17:02:55.080]             future::FutureResult(value = ...future.value$value, 
[17:02:55.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.080]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.080]                     ...future.globalenv.names))
[17:02:55.080]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.080]         }, condition = base::local({
[17:02:55.080]             c <- base::c
[17:02:55.080]             inherits <- base::inherits
[17:02:55.080]             invokeRestart <- base::invokeRestart
[17:02:55.080]             length <- base::length
[17:02:55.080]             list <- base::list
[17:02:55.080]             seq.int <- base::seq.int
[17:02:55.080]             signalCondition <- base::signalCondition
[17:02:55.080]             sys.calls <- base::sys.calls
[17:02:55.080]             `[[` <- base::`[[`
[17:02:55.080]             `+` <- base::`+`
[17:02:55.080]             `<<-` <- base::`<<-`
[17:02:55.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.080]                   3L)]
[17:02:55.080]             }
[17:02:55.080]             function(cond) {
[17:02:55.080]                 is_error <- inherits(cond, "error")
[17:02:55.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.080]                   NULL)
[17:02:55.080]                 if (is_error) {
[17:02:55.080]                   sessionInformation <- function() {
[17:02:55.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.080]                       search = base::search(), system = base::Sys.info())
[17:02:55.080]                   }
[17:02:55.080]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.080]                     cond$call), session = sessionInformation(), 
[17:02:55.080]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.080]                   signalCondition(cond)
[17:02:55.080]                 }
[17:02:55.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.080]                 "immediateCondition"))) {
[17:02:55.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.080]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.080]                   if (TRUE && !signal) {
[17:02:55.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.080]                     {
[17:02:55.080]                       inherits <- base::inherits
[17:02:55.080]                       invokeRestart <- base::invokeRestart
[17:02:55.080]                       is.null <- base::is.null
[17:02:55.080]                       muffled <- FALSE
[17:02:55.080]                       if (inherits(cond, "message")) {
[17:02:55.080]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.080]                         if (muffled) 
[17:02:55.080]                           invokeRestart("muffleMessage")
[17:02:55.080]                       }
[17:02:55.080]                       else if (inherits(cond, "warning")) {
[17:02:55.080]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.080]                         if (muffled) 
[17:02:55.080]                           invokeRestart("muffleWarning")
[17:02:55.080]                       }
[17:02:55.080]                       else if (inherits(cond, "condition")) {
[17:02:55.080]                         if (!is.null(pattern)) {
[17:02:55.080]                           computeRestarts <- base::computeRestarts
[17:02:55.080]                           grepl <- base::grepl
[17:02:55.080]                           restarts <- computeRestarts(cond)
[17:02:55.080]                           for (restart in restarts) {
[17:02:55.080]                             name <- restart$name
[17:02:55.080]                             if (is.null(name)) 
[17:02:55.080]                               next
[17:02:55.080]                             if (!grepl(pattern, name)) 
[17:02:55.080]                               next
[17:02:55.080]                             invokeRestart(restart)
[17:02:55.080]                             muffled <- TRUE
[17:02:55.080]                             break
[17:02:55.080]                           }
[17:02:55.080]                         }
[17:02:55.080]                       }
[17:02:55.080]                       invisible(muffled)
[17:02:55.080]                     }
[17:02:55.080]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.080]                   }
[17:02:55.080]                 }
[17:02:55.080]                 else {
[17:02:55.080]                   if (TRUE) {
[17:02:55.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.080]                     {
[17:02:55.080]                       inherits <- base::inherits
[17:02:55.080]                       invokeRestart <- base::invokeRestart
[17:02:55.080]                       is.null <- base::is.null
[17:02:55.080]                       muffled <- FALSE
[17:02:55.080]                       if (inherits(cond, "message")) {
[17:02:55.080]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.080]                         if (muffled) 
[17:02:55.080]                           invokeRestart("muffleMessage")
[17:02:55.080]                       }
[17:02:55.080]                       else if (inherits(cond, "warning")) {
[17:02:55.080]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.080]                         if (muffled) 
[17:02:55.080]                           invokeRestart("muffleWarning")
[17:02:55.080]                       }
[17:02:55.080]                       else if (inherits(cond, "condition")) {
[17:02:55.080]                         if (!is.null(pattern)) {
[17:02:55.080]                           computeRestarts <- base::computeRestarts
[17:02:55.080]                           grepl <- base::grepl
[17:02:55.080]                           restarts <- computeRestarts(cond)
[17:02:55.080]                           for (restart in restarts) {
[17:02:55.080]                             name <- restart$name
[17:02:55.080]                             if (is.null(name)) 
[17:02:55.080]                               next
[17:02:55.080]                             if (!grepl(pattern, name)) 
[17:02:55.080]                               next
[17:02:55.080]                             invokeRestart(restart)
[17:02:55.080]                             muffled <- TRUE
[17:02:55.080]                             break
[17:02:55.080]                           }
[17:02:55.080]                         }
[17:02:55.080]                       }
[17:02:55.080]                       invisible(muffled)
[17:02:55.080]                     }
[17:02:55.080]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.080]                   }
[17:02:55.080]                 }
[17:02:55.080]             }
[17:02:55.080]         }))
[17:02:55.080]     }, error = function(ex) {
[17:02:55.080]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.080]                 ...future.rng), started = ...future.startTime, 
[17:02:55.080]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.080]             version = "1.8"), class = "FutureResult")
[17:02:55.080]     }, finally = {
[17:02:55.080]         if (!identical(...future.workdir, getwd())) 
[17:02:55.080]             setwd(...future.workdir)
[17:02:55.080]         {
[17:02:55.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.080]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.080]             }
[17:02:55.080]             base::options(...future.oldOptions)
[17:02:55.080]             if (.Platform$OS.type == "windows") {
[17:02:55.080]                 old_names <- names(...future.oldEnvVars)
[17:02:55.080]                 envs <- base::Sys.getenv()
[17:02:55.080]                 names <- names(envs)
[17:02:55.080]                 common <- intersect(names, old_names)
[17:02:55.080]                 added <- setdiff(names, old_names)
[17:02:55.080]                 removed <- setdiff(old_names, names)
[17:02:55.080]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.080]                   envs[common]]
[17:02:55.080]                 NAMES <- toupper(changed)
[17:02:55.080]                 args <- list()
[17:02:55.080]                 for (kk in seq_along(NAMES)) {
[17:02:55.080]                   name <- changed[[kk]]
[17:02:55.080]                   NAME <- NAMES[[kk]]
[17:02:55.080]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.080]                     next
[17:02:55.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.080]                 }
[17:02:55.080]                 NAMES <- toupper(added)
[17:02:55.080]                 for (kk in seq_along(NAMES)) {
[17:02:55.080]                   name <- added[[kk]]
[17:02:55.080]                   NAME <- NAMES[[kk]]
[17:02:55.080]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.080]                     next
[17:02:55.080]                   args[[name]] <- ""
[17:02:55.080]                 }
[17:02:55.080]                 NAMES <- toupper(removed)
[17:02:55.080]                 for (kk in seq_along(NAMES)) {
[17:02:55.080]                   name <- removed[[kk]]
[17:02:55.080]                   NAME <- NAMES[[kk]]
[17:02:55.080]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.080]                     next
[17:02:55.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.080]                 }
[17:02:55.080]                 if (length(args) > 0) 
[17:02:55.080]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.080]             }
[17:02:55.080]             else {
[17:02:55.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.080]             }
[17:02:55.080]             {
[17:02:55.080]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.080]                   0L) {
[17:02:55.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.080]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.080]                   base::options(opts)
[17:02:55.080]                 }
[17:02:55.080]                 {
[17:02:55.080]                   {
[17:02:55.080]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.080]                     NULL
[17:02:55.080]                   }
[17:02:55.080]                   options(future.plan = NULL)
[17:02:55.080]                   if (is.na(NA_character_)) 
[17:02:55.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.080]                     .init = FALSE)
[17:02:55.080]                 }
[17:02:55.080]             }
[17:02:55.080]         }
[17:02:55.080]     })
[17:02:55.080]     if (TRUE) {
[17:02:55.080]         base::sink(type = "output", split = FALSE)
[17:02:55.080]         if (TRUE) {
[17:02:55.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.080]         }
[17:02:55.080]         else {
[17:02:55.080]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.080]         }
[17:02:55.080]         base::close(...future.stdout)
[17:02:55.080]         ...future.stdout <- NULL
[17:02:55.080]     }
[17:02:55.080]     ...future.result$conditions <- ...future.conditions
[17:02:55.080]     ...future.result$finished <- base::Sys.time()
[17:02:55.080]     ...future.result
[17:02:55.080] }
[17:02:55.083] MultisessionFuture started
[17:02:55.083] - Launch lazy future ... done
[17:02:55.083] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.083] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.083] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.084] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:55.085] Searching for globals ... DONE
[17:02:55.085] Resolving globals: TRUE
[17:02:55.085] Resolving any globals that are futures ...
[17:02:55.085] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:55.085] Resolving any globals that are futures ... DONE
[17:02:55.085] Resolving futures part of globals (recursively) ...
[17:02:55.086] resolve() on list ...
[17:02:55.086]  recursive: 99
[17:02:55.086]  length: 1
[17:02:55.086]  elements: ‘a’
[17:02:55.087] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.087] - Validating connection of MultisessionFuture
[17:02:55.087] - received message: FutureResult
[17:02:55.087] - Received FutureResult
[17:02:55.088] - Erased future from FutureRegistry
[17:02:55.088] result() for ClusterFuture ...
[17:02:55.088] - result already collected: FutureResult
[17:02:55.088] result() for ClusterFuture ... done
[17:02:55.088] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.088] Future #1
[17:02:55.088] result() for ClusterFuture ...
[17:02:55.088] - result already collected: FutureResult
[17:02:55.088] result() for ClusterFuture ... done
[17:02:55.089] result() for ClusterFuture ...
[17:02:55.089] - result already collected: FutureResult
[17:02:55.089] result() for ClusterFuture ... done
[17:02:55.089] A MultisessionFuture was resolved
[17:02:55.089]  length: 0 (resolved future 1)
[17:02:55.089] resolve() on list ... DONE
[17:02:55.089] - globals: [1] ‘a’
[17:02:55.089] Resolving futures part of globals (recursively) ... DONE
[17:02:55.091] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[17:02:55.092] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:55.092] - globals: [1] ‘a’
[17:02:55.092] - packages: [1] ‘future’
[17:02:55.092] getGlobalsAndPackages() ... DONE
[17:02:55.092] run() for ‘Future’ ...
[17:02:55.093] - state: ‘created’
[17:02:55.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.106] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.107]   - Field: ‘node’
[17:02:55.107]   - Field: ‘label’
[17:02:55.107]   - Field: ‘local’
[17:02:55.107]   - Field: ‘owner’
[17:02:55.107]   - Field: ‘envir’
[17:02:55.107]   - Field: ‘workers’
[17:02:55.107]   - Field: ‘packages’
[17:02:55.107]   - Field: ‘gc’
[17:02:55.107]   - Field: ‘conditions’
[17:02:55.108]   - Field: ‘persistent’
[17:02:55.108]   - Field: ‘expr’
[17:02:55.108]   - Field: ‘uuid’
[17:02:55.108]   - Field: ‘seed’
[17:02:55.108]   - Field: ‘version’
[17:02:55.108]   - Field: ‘result’
[17:02:55.108]   - Field: ‘asynchronous’
[17:02:55.108]   - Field: ‘calls’
[17:02:55.108]   - Field: ‘globals’
[17:02:55.108]   - Field: ‘stdout’
[17:02:55.108]   - Field: ‘earlySignal’
[17:02:55.109]   - Field: ‘lazy’
[17:02:55.109]   - Field: ‘state’
[17:02:55.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.109] - Launch lazy future ...
[17:02:55.109] Packages needed by the future expression (n = 1): ‘future’
[17:02:55.109] Packages needed by future strategies (n = 0): <none>
[17:02:55.110] {
[17:02:55.110]     {
[17:02:55.110]         {
[17:02:55.110]             ...future.startTime <- base::Sys.time()
[17:02:55.110]             {
[17:02:55.110]                 {
[17:02:55.110]                   {
[17:02:55.110]                     {
[17:02:55.110]                       {
[17:02:55.110]                         base::local({
[17:02:55.110]                           has_future <- base::requireNamespace("future", 
[17:02:55.110]                             quietly = TRUE)
[17:02:55.110]                           if (has_future) {
[17:02:55.110]                             ns <- base::getNamespace("future")
[17:02:55.110]                             version <- ns[[".package"]][["version"]]
[17:02:55.110]                             if (is.null(version)) 
[17:02:55.110]                               version <- utils::packageVersion("future")
[17:02:55.110]                           }
[17:02:55.110]                           else {
[17:02:55.110]                             version <- NULL
[17:02:55.110]                           }
[17:02:55.110]                           if (!has_future || version < "1.8.0") {
[17:02:55.110]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.110]                               "", base::R.version$version.string), 
[17:02:55.110]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:55.110]                                 base::R.version$platform, 8 * 
[17:02:55.110]                                   base::.Machine$sizeof.pointer), 
[17:02:55.110]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.110]                                 "release", "version")], collapse = " "), 
[17:02:55.110]                               hostname = base::Sys.info()[["nodename"]])
[17:02:55.110]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.110]                               info)
[17:02:55.110]                             info <- base::paste(info, collapse = "; ")
[17:02:55.110]                             if (!has_future) {
[17:02:55.110]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.110]                                 info)
[17:02:55.110]                             }
[17:02:55.110]                             else {
[17:02:55.110]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.110]                                 info, version)
[17:02:55.110]                             }
[17:02:55.110]                             base::stop(msg)
[17:02:55.110]                           }
[17:02:55.110]                         })
[17:02:55.110]                       }
[17:02:55.110]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.110]                       base::options(mc.cores = 1L)
[17:02:55.110]                     }
[17:02:55.110]                     base::local({
[17:02:55.110]                       for (pkg in "future") {
[17:02:55.110]                         base::loadNamespace(pkg)
[17:02:55.110]                         base::library(pkg, character.only = TRUE)
[17:02:55.110]                       }
[17:02:55.110]                     })
[17:02:55.110]                   }
[17:02:55.110]                   ...future.strategy.old <- future::plan("list")
[17:02:55.110]                   options(future.plan = NULL)
[17:02:55.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.110]                 }
[17:02:55.110]                 ...future.workdir <- getwd()
[17:02:55.110]             }
[17:02:55.110]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.110]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.110]         }
[17:02:55.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.110]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.110]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.110]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.110]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.110]             base::names(...future.oldOptions))
[17:02:55.110]     }
[17:02:55.110]     if (FALSE) {
[17:02:55.110]     }
[17:02:55.110]     else {
[17:02:55.110]         if (TRUE) {
[17:02:55.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.110]                 open = "w")
[17:02:55.110]         }
[17:02:55.110]         else {
[17:02:55.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.110]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.110]         }
[17:02:55.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.110]             base::sink(type = "output", split = FALSE)
[17:02:55.110]             base::close(...future.stdout)
[17:02:55.110]         }, add = TRUE)
[17:02:55.110]     }
[17:02:55.110]     ...future.frame <- base::sys.nframe()
[17:02:55.110]     ...future.conditions <- base::list()
[17:02:55.110]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.110]     if (FALSE) {
[17:02:55.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.110]     }
[17:02:55.110]     ...future.result <- base::tryCatch({
[17:02:55.110]         base::withCallingHandlers({
[17:02:55.110]             ...future.value <- base::withVisible(base::local({
[17:02:55.110]                 ...future.makeSendCondition <- base::local({
[17:02:55.110]                   sendCondition <- NULL
[17:02:55.110]                   function(frame = 1L) {
[17:02:55.110]                     if (is.function(sendCondition)) 
[17:02:55.110]                       return(sendCondition)
[17:02:55.110]                     ns <- getNamespace("parallel")
[17:02:55.110]                     if (exists("sendData", mode = "function", 
[17:02:55.110]                       envir = ns)) {
[17:02:55.110]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.110]                         envir = ns)
[17:02:55.110]                       envir <- sys.frame(frame)
[17:02:55.110]                       master <- NULL
[17:02:55.110]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.110]                         !identical(envir, emptyenv())) {
[17:02:55.110]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.110]                           inherits = FALSE)) {
[17:02:55.110]                           master <- get("master", mode = "list", 
[17:02:55.110]                             envir = envir, inherits = FALSE)
[17:02:55.110]                           if (inherits(master, c("SOCKnode", 
[17:02:55.110]                             "SOCK0node"))) {
[17:02:55.110]                             sendCondition <<- function(cond) {
[17:02:55.110]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.110]                                 success = TRUE)
[17:02:55.110]                               parallel_sendData(master, data)
[17:02:55.110]                             }
[17:02:55.110]                             return(sendCondition)
[17:02:55.110]                           }
[17:02:55.110]                         }
[17:02:55.110]                         frame <- frame + 1L
[17:02:55.110]                         envir <- sys.frame(frame)
[17:02:55.110]                       }
[17:02:55.110]                     }
[17:02:55.110]                     sendCondition <<- function(cond) NULL
[17:02:55.110]                   }
[17:02:55.110]                 })
[17:02:55.110]                 withCallingHandlers({
[17:02:55.110]                   value(a) + 1
[17:02:55.110]                 }, immediateCondition = function(cond) {
[17:02:55.110]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.110]                   sendCondition(cond)
[17:02:55.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.110]                   {
[17:02:55.110]                     inherits <- base::inherits
[17:02:55.110]                     invokeRestart <- base::invokeRestart
[17:02:55.110]                     is.null <- base::is.null
[17:02:55.110]                     muffled <- FALSE
[17:02:55.110]                     if (inherits(cond, "message")) {
[17:02:55.110]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.110]                       if (muffled) 
[17:02:55.110]                         invokeRestart("muffleMessage")
[17:02:55.110]                     }
[17:02:55.110]                     else if (inherits(cond, "warning")) {
[17:02:55.110]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.110]                       if (muffled) 
[17:02:55.110]                         invokeRestart("muffleWarning")
[17:02:55.110]                     }
[17:02:55.110]                     else if (inherits(cond, "condition")) {
[17:02:55.110]                       if (!is.null(pattern)) {
[17:02:55.110]                         computeRestarts <- base::computeRestarts
[17:02:55.110]                         grepl <- base::grepl
[17:02:55.110]                         restarts <- computeRestarts(cond)
[17:02:55.110]                         for (restart in restarts) {
[17:02:55.110]                           name <- restart$name
[17:02:55.110]                           if (is.null(name)) 
[17:02:55.110]                             next
[17:02:55.110]                           if (!grepl(pattern, name)) 
[17:02:55.110]                             next
[17:02:55.110]                           invokeRestart(restart)
[17:02:55.110]                           muffled <- TRUE
[17:02:55.110]                           break
[17:02:55.110]                         }
[17:02:55.110]                       }
[17:02:55.110]                     }
[17:02:55.110]                     invisible(muffled)
[17:02:55.110]                   }
[17:02:55.110]                   muffleCondition(cond)
[17:02:55.110]                 })
[17:02:55.110]             }))
[17:02:55.110]             future::FutureResult(value = ...future.value$value, 
[17:02:55.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.110]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.110]                     ...future.globalenv.names))
[17:02:55.110]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.110]         }, condition = base::local({
[17:02:55.110]             c <- base::c
[17:02:55.110]             inherits <- base::inherits
[17:02:55.110]             invokeRestart <- base::invokeRestart
[17:02:55.110]             length <- base::length
[17:02:55.110]             list <- base::list
[17:02:55.110]             seq.int <- base::seq.int
[17:02:55.110]             signalCondition <- base::signalCondition
[17:02:55.110]             sys.calls <- base::sys.calls
[17:02:55.110]             `[[` <- base::`[[`
[17:02:55.110]             `+` <- base::`+`
[17:02:55.110]             `<<-` <- base::`<<-`
[17:02:55.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.110]                   3L)]
[17:02:55.110]             }
[17:02:55.110]             function(cond) {
[17:02:55.110]                 is_error <- inherits(cond, "error")
[17:02:55.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.110]                   NULL)
[17:02:55.110]                 if (is_error) {
[17:02:55.110]                   sessionInformation <- function() {
[17:02:55.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.110]                       search = base::search(), system = base::Sys.info())
[17:02:55.110]                   }
[17:02:55.110]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.110]                     cond$call), session = sessionInformation(), 
[17:02:55.110]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.110]                   signalCondition(cond)
[17:02:55.110]                 }
[17:02:55.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.110]                 "immediateCondition"))) {
[17:02:55.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.110]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.110]                   if (TRUE && !signal) {
[17:02:55.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.110]                     {
[17:02:55.110]                       inherits <- base::inherits
[17:02:55.110]                       invokeRestart <- base::invokeRestart
[17:02:55.110]                       is.null <- base::is.null
[17:02:55.110]                       muffled <- FALSE
[17:02:55.110]                       if (inherits(cond, "message")) {
[17:02:55.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.110]                         if (muffled) 
[17:02:55.110]                           invokeRestart("muffleMessage")
[17:02:55.110]                       }
[17:02:55.110]                       else if (inherits(cond, "warning")) {
[17:02:55.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.110]                         if (muffled) 
[17:02:55.110]                           invokeRestart("muffleWarning")
[17:02:55.110]                       }
[17:02:55.110]                       else if (inherits(cond, "condition")) {
[17:02:55.110]                         if (!is.null(pattern)) {
[17:02:55.110]                           computeRestarts <- base::computeRestarts
[17:02:55.110]                           grepl <- base::grepl
[17:02:55.110]                           restarts <- computeRestarts(cond)
[17:02:55.110]                           for (restart in restarts) {
[17:02:55.110]                             name <- restart$name
[17:02:55.110]                             if (is.null(name)) 
[17:02:55.110]                               next
[17:02:55.110]                             if (!grepl(pattern, name)) 
[17:02:55.110]                               next
[17:02:55.110]                             invokeRestart(restart)
[17:02:55.110]                             muffled <- TRUE
[17:02:55.110]                             break
[17:02:55.110]                           }
[17:02:55.110]                         }
[17:02:55.110]                       }
[17:02:55.110]                       invisible(muffled)
[17:02:55.110]                     }
[17:02:55.110]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.110]                   }
[17:02:55.110]                 }
[17:02:55.110]                 else {
[17:02:55.110]                   if (TRUE) {
[17:02:55.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.110]                     {
[17:02:55.110]                       inherits <- base::inherits
[17:02:55.110]                       invokeRestart <- base::invokeRestart
[17:02:55.110]                       is.null <- base::is.null
[17:02:55.110]                       muffled <- FALSE
[17:02:55.110]                       if (inherits(cond, "message")) {
[17:02:55.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.110]                         if (muffled) 
[17:02:55.110]                           invokeRestart("muffleMessage")
[17:02:55.110]                       }
[17:02:55.110]                       else if (inherits(cond, "warning")) {
[17:02:55.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.110]                         if (muffled) 
[17:02:55.110]                           invokeRestart("muffleWarning")
[17:02:55.110]                       }
[17:02:55.110]                       else if (inherits(cond, "condition")) {
[17:02:55.110]                         if (!is.null(pattern)) {
[17:02:55.110]                           computeRestarts <- base::computeRestarts
[17:02:55.110]                           grepl <- base::grepl
[17:02:55.110]                           restarts <- computeRestarts(cond)
[17:02:55.110]                           for (restart in restarts) {
[17:02:55.110]                             name <- restart$name
[17:02:55.110]                             if (is.null(name)) 
[17:02:55.110]                               next
[17:02:55.110]                             if (!grepl(pattern, name)) 
[17:02:55.110]                               next
[17:02:55.110]                             invokeRestart(restart)
[17:02:55.110]                             muffled <- TRUE
[17:02:55.110]                             break
[17:02:55.110]                           }
[17:02:55.110]                         }
[17:02:55.110]                       }
[17:02:55.110]                       invisible(muffled)
[17:02:55.110]                     }
[17:02:55.110]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.110]                   }
[17:02:55.110]                 }
[17:02:55.110]             }
[17:02:55.110]         }))
[17:02:55.110]     }, error = function(ex) {
[17:02:55.110]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.110]                 ...future.rng), started = ...future.startTime, 
[17:02:55.110]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.110]             version = "1.8"), class = "FutureResult")
[17:02:55.110]     }, finally = {
[17:02:55.110]         if (!identical(...future.workdir, getwd())) 
[17:02:55.110]             setwd(...future.workdir)
[17:02:55.110]         {
[17:02:55.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.110]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.110]             }
[17:02:55.110]             base::options(...future.oldOptions)
[17:02:55.110]             if (.Platform$OS.type == "windows") {
[17:02:55.110]                 old_names <- names(...future.oldEnvVars)
[17:02:55.110]                 envs <- base::Sys.getenv()
[17:02:55.110]                 names <- names(envs)
[17:02:55.110]                 common <- intersect(names, old_names)
[17:02:55.110]                 added <- setdiff(names, old_names)
[17:02:55.110]                 removed <- setdiff(old_names, names)
[17:02:55.110]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.110]                   envs[common]]
[17:02:55.110]                 NAMES <- toupper(changed)
[17:02:55.110]                 args <- list()
[17:02:55.110]                 for (kk in seq_along(NAMES)) {
[17:02:55.110]                   name <- changed[[kk]]
[17:02:55.110]                   NAME <- NAMES[[kk]]
[17:02:55.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.110]                     next
[17:02:55.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.110]                 }
[17:02:55.110]                 NAMES <- toupper(added)
[17:02:55.110]                 for (kk in seq_along(NAMES)) {
[17:02:55.110]                   name <- added[[kk]]
[17:02:55.110]                   NAME <- NAMES[[kk]]
[17:02:55.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.110]                     next
[17:02:55.110]                   args[[name]] <- ""
[17:02:55.110]                 }
[17:02:55.110]                 NAMES <- toupper(removed)
[17:02:55.110]                 for (kk in seq_along(NAMES)) {
[17:02:55.110]                   name <- removed[[kk]]
[17:02:55.110]                   NAME <- NAMES[[kk]]
[17:02:55.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.110]                     next
[17:02:55.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.110]                 }
[17:02:55.110]                 if (length(args) > 0) 
[17:02:55.110]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.110]             }
[17:02:55.110]             else {
[17:02:55.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.110]             }
[17:02:55.110]             {
[17:02:55.110]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.110]                   0L) {
[17:02:55.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.110]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.110]                   base::options(opts)
[17:02:55.110]                 }
[17:02:55.110]                 {
[17:02:55.110]                   {
[17:02:55.110]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.110]                     NULL
[17:02:55.110]                   }
[17:02:55.110]                   options(future.plan = NULL)
[17:02:55.110]                   if (is.na(NA_character_)) 
[17:02:55.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.110]                     .init = FALSE)
[17:02:55.110]                 }
[17:02:55.110]             }
[17:02:55.110]         }
[17:02:55.110]     })
[17:02:55.110]     if (TRUE) {
[17:02:55.110]         base::sink(type = "output", split = FALSE)
[17:02:55.110]         if (TRUE) {
[17:02:55.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.110]         }
[17:02:55.110]         else {
[17:02:55.110]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.110]         }
[17:02:55.110]         base::close(...future.stdout)
[17:02:55.110]         ...future.stdout <- NULL
[17:02:55.110]     }
[17:02:55.110]     ...future.result$conditions <- ...future.conditions
[17:02:55.110]     ...future.result$finished <- base::Sys.time()
[17:02:55.110]     ...future.result
[17:02:55.110] }
[17:02:55.112] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:02:55.114] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:02:55.168] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.168] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.169] MultisessionFuture started
[17:02:55.169] - Launch lazy future ... done
[17:02:55.169] run() for ‘MultisessionFuture’ ... done
[17:02:55.169] result() for ClusterFuture ...
[17:02:55.169] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.169] - Validating connection of MultisessionFuture
[17:02:55.217] - received message: FutureResult
[17:02:55.218] - Received FutureResult
[17:02:55.218] - Erased future from FutureRegistry
[17:02:55.218] result() for ClusterFuture ...
[17:02:55.218] - result already collected: FutureResult
[17:02:55.218] result() for ClusterFuture ... done
[17:02:55.218] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.218] result() for ClusterFuture ... done
[17:02:55.218] result() for ClusterFuture ...
[17:02:55.218] - result already collected: FutureResult
[17:02:55.218] result() for ClusterFuture ... done
value(b) = 2
[17:02:55.219] result() for ClusterFuture ...
[17:02:55.219] - result already collected: FutureResult
[17:02:55.219] result() for ClusterFuture ... done
[17:02:55.219] result() for ClusterFuture ...
[17:02:55.219] - result already collected: FutureResult
[17:02:55.219] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.219] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.220] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.220] 
[17:02:55.220] Searching for globals ... DONE
[17:02:55.220] - globals: [0] <none>
[17:02:55.220] getGlobalsAndPackages() ... DONE
[17:02:55.221] run() for ‘Future’ ...
[17:02:55.221] - state: ‘created’
[17:02:55.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.236]   - Field: ‘node’
[17:02:55.236]   - Field: ‘label’
[17:02:55.236]   - Field: ‘local’
[17:02:55.236]   - Field: ‘owner’
[17:02:55.236]   - Field: ‘envir’
[17:02:55.236]   - Field: ‘workers’
[17:02:55.236]   - Field: ‘packages’
[17:02:55.236]   - Field: ‘gc’
[17:02:55.236]   - Field: ‘conditions’
[17:02:55.236]   - Field: ‘persistent’
[17:02:55.237]   - Field: ‘expr’
[17:02:55.237]   - Field: ‘uuid’
[17:02:55.237]   - Field: ‘seed’
[17:02:55.237]   - Field: ‘version’
[17:02:55.237]   - Field: ‘result’
[17:02:55.237]   - Field: ‘asynchronous’
[17:02:55.237]   - Field: ‘calls’
[17:02:55.237]   - Field: ‘globals’
[17:02:55.237]   - Field: ‘stdout’
[17:02:55.237]   - Field: ‘earlySignal’
[17:02:55.237]   - Field: ‘lazy’
[17:02:55.238]   - Field: ‘state’
[17:02:55.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.238] - Launch lazy future ...
[17:02:55.238] Packages needed by the future expression (n = 0): <none>
[17:02:55.238] Packages needed by future strategies (n = 0): <none>
[17:02:55.239] {
[17:02:55.239]     {
[17:02:55.239]         {
[17:02:55.239]             ...future.startTime <- base::Sys.time()
[17:02:55.239]             {
[17:02:55.239]                 {
[17:02:55.239]                   {
[17:02:55.239]                     {
[17:02:55.239]                       base::local({
[17:02:55.239]                         has_future <- base::requireNamespace("future", 
[17:02:55.239]                           quietly = TRUE)
[17:02:55.239]                         if (has_future) {
[17:02:55.239]                           ns <- base::getNamespace("future")
[17:02:55.239]                           version <- ns[[".package"]][["version"]]
[17:02:55.239]                           if (is.null(version)) 
[17:02:55.239]                             version <- utils::packageVersion("future")
[17:02:55.239]                         }
[17:02:55.239]                         else {
[17:02:55.239]                           version <- NULL
[17:02:55.239]                         }
[17:02:55.239]                         if (!has_future || version < "1.8.0") {
[17:02:55.239]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.239]                             "", base::R.version$version.string), 
[17:02:55.239]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.239]                               "release", "version")], collapse = " "), 
[17:02:55.239]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.239]                             info)
[17:02:55.239]                           info <- base::paste(info, collapse = "; ")
[17:02:55.239]                           if (!has_future) {
[17:02:55.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.239]                               info)
[17:02:55.239]                           }
[17:02:55.239]                           else {
[17:02:55.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.239]                               info, version)
[17:02:55.239]                           }
[17:02:55.239]                           base::stop(msg)
[17:02:55.239]                         }
[17:02:55.239]                       })
[17:02:55.239]                     }
[17:02:55.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.239]                     base::options(mc.cores = 1L)
[17:02:55.239]                   }
[17:02:55.239]                   ...future.strategy.old <- future::plan("list")
[17:02:55.239]                   options(future.plan = NULL)
[17:02:55.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.239]                 }
[17:02:55.239]                 ...future.workdir <- getwd()
[17:02:55.239]             }
[17:02:55.239]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.239]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.239]         }
[17:02:55.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.239]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.239]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.239]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.239]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.239]             base::names(...future.oldOptions))
[17:02:55.239]     }
[17:02:55.239]     if (FALSE) {
[17:02:55.239]     }
[17:02:55.239]     else {
[17:02:55.239]         if (TRUE) {
[17:02:55.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.239]                 open = "w")
[17:02:55.239]         }
[17:02:55.239]         else {
[17:02:55.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.239]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.239]         }
[17:02:55.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.239]             base::sink(type = "output", split = FALSE)
[17:02:55.239]             base::close(...future.stdout)
[17:02:55.239]         }, add = TRUE)
[17:02:55.239]     }
[17:02:55.239]     ...future.frame <- base::sys.nframe()
[17:02:55.239]     ...future.conditions <- base::list()
[17:02:55.239]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.239]     if (FALSE) {
[17:02:55.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.239]     }
[17:02:55.239]     ...future.result <- base::tryCatch({
[17:02:55.239]         base::withCallingHandlers({
[17:02:55.239]             ...future.value <- base::withVisible(base::local({
[17:02:55.239]                 ...future.makeSendCondition <- base::local({
[17:02:55.239]                   sendCondition <- NULL
[17:02:55.239]                   function(frame = 1L) {
[17:02:55.239]                     if (is.function(sendCondition)) 
[17:02:55.239]                       return(sendCondition)
[17:02:55.239]                     ns <- getNamespace("parallel")
[17:02:55.239]                     if (exists("sendData", mode = "function", 
[17:02:55.239]                       envir = ns)) {
[17:02:55.239]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.239]                         envir = ns)
[17:02:55.239]                       envir <- sys.frame(frame)
[17:02:55.239]                       master <- NULL
[17:02:55.239]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.239]                         !identical(envir, emptyenv())) {
[17:02:55.239]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.239]                           inherits = FALSE)) {
[17:02:55.239]                           master <- get("master", mode = "list", 
[17:02:55.239]                             envir = envir, inherits = FALSE)
[17:02:55.239]                           if (inherits(master, c("SOCKnode", 
[17:02:55.239]                             "SOCK0node"))) {
[17:02:55.239]                             sendCondition <<- function(cond) {
[17:02:55.239]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.239]                                 success = TRUE)
[17:02:55.239]                               parallel_sendData(master, data)
[17:02:55.239]                             }
[17:02:55.239]                             return(sendCondition)
[17:02:55.239]                           }
[17:02:55.239]                         }
[17:02:55.239]                         frame <- frame + 1L
[17:02:55.239]                         envir <- sys.frame(frame)
[17:02:55.239]                       }
[17:02:55.239]                     }
[17:02:55.239]                     sendCondition <<- function(cond) NULL
[17:02:55.239]                   }
[17:02:55.239]                 })
[17:02:55.239]                 withCallingHandlers({
[17:02:55.239]                   1
[17:02:55.239]                 }, immediateCondition = function(cond) {
[17:02:55.239]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.239]                   sendCondition(cond)
[17:02:55.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.239]                   {
[17:02:55.239]                     inherits <- base::inherits
[17:02:55.239]                     invokeRestart <- base::invokeRestart
[17:02:55.239]                     is.null <- base::is.null
[17:02:55.239]                     muffled <- FALSE
[17:02:55.239]                     if (inherits(cond, "message")) {
[17:02:55.239]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.239]                       if (muffled) 
[17:02:55.239]                         invokeRestart("muffleMessage")
[17:02:55.239]                     }
[17:02:55.239]                     else if (inherits(cond, "warning")) {
[17:02:55.239]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.239]                       if (muffled) 
[17:02:55.239]                         invokeRestart("muffleWarning")
[17:02:55.239]                     }
[17:02:55.239]                     else if (inherits(cond, "condition")) {
[17:02:55.239]                       if (!is.null(pattern)) {
[17:02:55.239]                         computeRestarts <- base::computeRestarts
[17:02:55.239]                         grepl <- base::grepl
[17:02:55.239]                         restarts <- computeRestarts(cond)
[17:02:55.239]                         for (restart in restarts) {
[17:02:55.239]                           name <- restart$name
[17:02:55.239]                           if (is.null(name)) 
[17:02:55.239]                             next
[17:02:55.239]                           if (!grepl(pattern, name)) 
[17:02:55.239]                             next
[17:02:55.239]                           invokeRestart(restart)
[17:02:55.239]                           muffled <- TRUE
[17:02:55.239]                           break
[17:02:55.239]                         }
[17:02:55.239]                       }
[17:02:55.239]                     }
[17:02:55.239]                     invisible(muffled)
[17:02:55.239]                   }
[17:02:55.239]                   muffleCondition(cond)
[17:02:55.239]                 })
[17:02:55.239]             }))
[17:02:55.239]             future::FutureResult(value = ...future.value$value, 
[17:02:55.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.239]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.239]                     ...future.globalenv.names))
[17:02:55.239]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.239]         }, condition = base::local({
[17:02:55.239]             c <- base::c
[17:02:55.239]             inherits <- base::inherits
[17:02:55.239]             invokeRestart <- base::invokeRestart
[17:02:55.239]             length <- base::length
[17:02:55.239]             list <- base::list
[17:02:55.239]             seq.int <- base::seq.int
[17:02:55.239]             signalCondition <- base::signalCondition
[17:02:55.239]             sys.calls <- base::sys.calls
[17:02:55.239]             `[[` <- base::`[[`
[17:02:55.239]             `+` <- base::`+`
[17:02:55.239]             `<<-` <- base::`<<-`
[17:02:55.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.239]                   3L)]
[17:02:55.239]             }
[17:02:55.239]             function(cond) {
[17:02:55.239]                 is_error <- inherits(cond, "error")
[17:02:55.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.239]                   NULL)
[17:02:55.239]                 if (is_error) {
[17:02:55.239]                   sessionInformation <- function() {
[17:02:55.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.239]                       search = base::search(), system = base::Sys.info())
[17:02:55.239]                   }
[17:02:55.239]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.239]                     cond$call), session = sessionInformation(), 
[17:02:55.239]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.239]                   signalCondition(cond)
[17:02:55.239]                 }
[17:02:55.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.239]                 "immediateCondition"))) {
[17:02:55.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.239]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.239]                   if (TRUE && !signal) {
[17:02:55.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.239]                     {
[17:02:55.239]                       inherits <- base::inherits
[17:02:55.239]                       invokeRestart <- base::invokeRestart
[17:02:55.239]                       is.null <- base::is.null
[17:02:55.239]                       muffled <- FALSE
[17:02:55.239]                       if (inherits(cond, "message")) {
[17:02:55.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.239]                         if (muffled) 
[17:02:55.239]                           invokeRestart("muffleMessage")
[17:02:55.239]                       }
[17:02:55.239]                       else if (inherits(cond, "warning")) {
[17:02:55.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.239]                         if (muffled) 
[17:02:55.239]                           invokeRestart("muffleWarning")
[17:02:55.239]                       }
[17:02:55.239]                       else if (inherits(cond, "condition")) {
[17:02:55.239]                         if (!is.null(pattern)) {
[17:02:55.239]                           computeRestarts <- base::computeRestarts
[17:02:55.239]                           grepl <- base::grepl
[17:02:55.239]                           restarts <- computeRestarts(cond)
[17:02:55.239]                           for (restart in restarts) {
[17:02:55.239]                             name <- restart$name
[17:02:55.239]                             if (is.null(name)) 
[17:02:55.239]                               next
[17:02:55.239]                             if (!grepl(pattern, name)) 
[17:02:55.239]                               next
[17:02:55.239]                             invokeRestart(restart)
[17:02:55.239]                             muffled <- TRUE
[17:02:55.239]                             break
[17:02:55.239]                           }
[17:02:55.239]                         }
[17:02:55.239]                       }
[17:02:55.239]                       invisible(muffled)
[17:02:55.239]                     }
[17:02:55.239]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.239]                   }
[17:02:55.239]                 }
[17:02:55.239]                 else {
[17:02:55.239]                   if (TRUE) {
[17:02:55.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.239]                     {
[17:02:55.239]                       inherits <- base::inherits
[17:02:55.239]                       invokeRestart <- base::invokeRestart
[17:02:55.239]                       is.null <- base::is.null
[17:02:55.239]                       muffled <- FALSE
[17:02:55.239]                       if (inherits(cond, "message")) {
[17:02:55.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.239]                         if (muffled) 
[17:02:55.239]                           invokeRestart("muffleMessage")
[17:02:55.239]                       }
[17:02:55.239]                       else if (inherits(cond, "warning")) {
[17:02:55.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.239]                         if (muffled) 
[17:02:55.239]                           invokeRestart("muffleWarning")
[17:02:55.239]                       }
[17:02:55.239]                       else if (inherits(cond, "condition")) {
[17:02:55.239]                         if (!is.null(pattern)) {
[17:02:55.239]                           computeRestarts <- base::computeRestarts
[17:02:55.239]                           grepl <- base::grepl
[17:02:55.239]                           restarts <- computeRestarts(cond)
[17:02:55.239]                           for (restart in restarts) {
[17:02:55.239]                             name <- restart$name
[17:02:55.239]                             if (is.null(name)) 
[17:02:55.239]                               next
[17:02:55.239]                             if (!grepl(pattern, name)) 
[17:02:55.239]                               next
[17:02:55.239]                             invokeRestart(restart)
[17:02:55.239]                             muffled <- TRUE
[17:02:55.239]                             break
[17:02:55.239]                           }
[17:02:55.239]                         }
[17:02:55.239]                       }
[17:02:55.239]                       invisible(muffled)
[17:02:55.239]                     }
[17:02:55.239]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.239]                   }
[17:02:55.239]                 }
[17:02:55.239]             }
[17:02:55.239]         }))
[17:02:55.239]     }, error = function(ex) {
[17:02:55.239]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.239]                 ...future.rng), started = ...future.startTime, 
[17:02:55.239]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.239]             version = "1.8"), class = "FutureResult")
[17:02:55.239]     }, finally = {
[17:02:55.239]         if (!identical(...future.workdir, getwd())) 
[17:02:55.239]             setwd(...future.workdir)
[17:02:55.239]         {
[17:02:55.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.239]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.239]             }
[17:02:55.239]             base::options(...future.oldOptions)
[17:02:55.239]             if (.Platform$OS.type == "windows") {
[17:02:55.239]                 old_names <- names(...future.oldEnvVars)
[17:02:55.239]                 envs <- base::Sys.getenv()
[17:02:55.239]                 names <- names(envs)
[17:02:55.239]                 common <- intersect(names, old_names)
[17:02:55.239]                 added <- setdiff(names, old_names)
[17:02:55.239]                 removed <- setdiff(old_names, names)
[17:02:55.239]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.239]                   envs[common]]
[17:02:55.239]                 NAMES <- toupper(changed)
[17:02:55.239]                 args <- list()
[17:02:55.239]                 for (kk in seq_along(NAMES)) {
[17:02:55.239]                   name <- changed[[kk]]
[17:02:55.239]                   NAME <- NAMES[[kk]]
[17:02:55.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.239]                     next
[17:02:55.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.239]                 }
[17:02:55.239]                 NAMES <- toupper(added)
[17:02:55.239]                 for (kk in seq_along(NAMES)) {
[17:02:55.239]                   name <- added[[kk]]
[17:02:55.239]                   NAME <- NAMES[[kk]]
[17:02:55.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.239]                     next
[17:02:55.239]                   args[[name]] <- ""
[17:02:55.239]                 }
[17:02:55.239]                 NAMES <- toupper(removed)
[17:02:55.239]                 for (kk in seq_along(NAMES)) {
[17:02:55.239]                   name <- removed[[kk]]
[17:02:55.239]                   NAME <- NAMES[[kk]]
[17:02:55.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.239]                     next
[17:02:55.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.239]                 }
[17:02:55.239]                 if (length(args) > 0) 
[17:02:55.239]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.239]             }
[17:02:55.239]             else {
[17:02:55.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.239]             }
[17:02:55.239]             {
[17:02:55.239]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.239]                   0L) {
[17:02:55.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.239]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.239]                   base::options(opts)
[17:02:55.239]                 }
[17:02:55.239]                 {
[17:02:55.239]                   {
[17:02:55.239]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.239]                     NULL
[17:02:55.239]                   }
[17:02:55.239]                   options(future.plan = NULL)
[17:02:55.239]                   if (is.na(NA_character_)) 
[17:02:55.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.239]                     .init = FALSE)
[17:02:55.239]                 }
[17:02:55.239]             }
[17:02:55.239]         }
[17:02:55.239]     })
[17:02:55.239]     if (TRUE) {
[17:02:55.239]         base::sink(type = "output", split = FALSE)
[17:02:55.239]         if (TRUE) {
[17:02:55.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.239]         }
[17:02:55.239]         else {
[17:02:55.239]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.239]         }
[17:02:55.239]         base::close(...future.stdout)
[17:02:55.239]         ...future.stdout <- NULL
[17:02:55.239]     }
[17:02:55.239]     ...future.result$conditions <- ...future.conditions
[17:02:55.239]     ...future.result$finished <- base::Sys.time()
[17:02:55.239]     ...future.result
[17:02:55.239] }
[17:02:55.242] MultisessionFuture started
[17:02:55.242] - Launch lazy future ... done
[17:02:55.242] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.242] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.242] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.243] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:55.243] Searching for globals ... DONE
[17:02:55.243] Resolving globals: TRUE
[17:02:55.243] Resolving any globals that are futures ...
[17:02:55.243] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:55.244] Resolving any globals that are futures ... DONE
[17:02:55.244] Resolving futures part of globals (recursively) ...
[17:02:55.244] resolve() on list ...
[17:02:55.244]  recursive: 99
[17:02:55.244]  length: 1
[17:02:55.244]  elements: ‘a’
[17:02:55.286] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.286] - Validating connection of MultisessionFuture
[17:02:55.286] - received message: FutureResult
[17:02:55.287] - Received FutureResult
[17:02:55.287] - Erased future from FutureRegistry
[17:02:55.287] result() for ClusterFuture ...
[17:02:55.287] - result already collected: FutureResult
[17:02:55.287] result() for ClusterFuture ... done
[17:02:55.287] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.287] Future #1
[17:02:55.287] result() for ClusterFuture ...
[17:02:55.287] - result already collected: FutureResult
[17:02:55.287] result() for ClusterFuture ... done
[17:02:55.288] result() for ClusterFuture ...
[17:02:55.288] - result already collected: FutureResult
[17:02:55.288] result() for ClusterFuture ... done
[17:02:55.288] A MultisessionFuture was resolved
[17:02:55.288]  length: 0 (resolved future 1)
[17:02:55.288] resolve() on list ... DONE
[17:02:55.288] - globals: [1] ‘a’
[17:02:55.288] Resolving futures part of globals (recursively) ... DONE
[17:02:55.290] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[17:02:55.291] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:55.291] - globals: [1] ‘a’
[17:02:55.291] - packages: [1] ‘future’
[17:02:55.291] getGlobalsAndPackages() ... DONE
[17:02:55.291] run() for ‘Future’ ...
[17:02:55.292] - state: ‘created’
[17:02:55.292] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.306] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.306]   - Field: ‘node’
[17:02:55.306]   - Field: ‘label’
[17:02:55.306]   - Field: ‘local’
[17:02:55.306]   - Field: ‘owner’
[17:02:55.307]   - Field: ‘envir’
[17:02:55.307]   - Field: ‘workers’
[17:02:55.307]   - Field: ‘packages’
[17:02:55.307]   - Field: ‘gc’
[17:02:55.307]   - Field: ‘conditions’
[17:02:55.307]   - Field: ‘persistent’
[17:02:55.307]   - Field: ‘expr’
[17:02:55.307]   - Field: ‘uuid’
[17:02:55.307]   - Field: ‘seed’
[17:02:55.310]   - Field: ‘version’
[17:02:55.310]   - Field: ‘result’
[17:02:55.310]   - Field: ‘asynchronous’
[17:02:55.310]   - Field: ‘calls’
[17:02:55.310]   - Field: ‘globals’
[17:02:55.310]   - Field: ‘stdout’
[17:02:55.310]   - Field: ‘earlySignal’
[17:02:55.310]   - Field: ‘lazy’
[17:02:55.310]   - Field: ‘state’
[17:02:55.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.311] - Launch lazy future ...
[17:02:55.311] Packages needed by the future expression (n = 1): ‘future’
[17:02:55.311] Packages needed by future strategies (n = 0): <none>
[17:02:55.312] {
[17:02:55.312]     {
[17:02:55.312]         {
[17:02:55.312]             ...future.startTime <- base::Sys.time()
[17:02:55.312]             {
[17:02:55.312]                 {
[17:02:55.312]                   {
[17:02:55.312]                     {
[17:02:55.312]                       {
[17:02:55.312]                         base::local({
[17:02:55.312]                           has_future <- base::requireNamespace("future", 
[17:02:55.312]                             quietly = TRUE)
[17:02:55.312]                           if (has_future) {
[17:02:55.312]                             ns <- base::getNamespace("future")
[17:02:55.312]                             version <- ns[[".package"]][["version"]]
[17:02:55.312]                             if (is.null(version)) 
[17:02:55.312]                               version <- utils::packageVersion("future")
[17:02:55.312]                           }
[17:02:55.312]                           else {
[17:02:55.312]                             version <- NULL
[17:02:55.312]                           }
[17:02:55.312]                           if (!has_future || version < "1.8.0") {
[17:02:55.312]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.312]                               "", base::R.version$version.string), 
[17:02:55.312]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:55.312]                                 base::R.version$platform, 8 * 
[17:02:55.312]                                   base::.Machine$sizeof.pointer), 
[17:02:55.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.312]                                 "release", "version")], collapse = " "), 
[17:02:55.312]                               hostname = base::Sys.info()[["nodename"]])
[17:02:55.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.312]                               info)
[17:02:55.312]                             info <- base::paste(info, collapse = "; ")
[17:02:55.312]                             if (!has_future) {
[17:02:55.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.312]                                 info)
[17:02:55.312]                             }
[17:02:55.312]                             else {
[17:02:55.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.312]                                 info, version)
[17:02:55.312]                             }
[17:02:55.312]                             base::stop(msg)
[17:02:55.312]                           }
[17:02:55.312]                         })
[17:02:55.312]                       }
[17:02:55.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.312]                       base::options(mc.cores = 1L)
[17:02:55.312]                     }
[17:02:55.312]                     base::local({
[17:02:55.312]                       for (pkg in "future") {
[17:02:55.312]                         base::loadNamespace(pkg)
[17:02:55.312]                         base::library(pkg, character.only = TRUE)
[17:02:55.312]                       }
[17:02:55.312]                     })
[17:02:55.312]                   }
[17:02:55.312]                   ...future.strategy.old <- future::plan("list")
[17:02:55.312]                   options(future.plan = NULL)
[17:02:55.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.312]                 }
[17:02:55.312]                 ...future.workdir <- getwd()
[17:02:55.312]             }
[17:02:55.312]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.312]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.312]         }
[17:02:55.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.312]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.312]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.312]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.312]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.312]             base::names(...future.oldOptions))
[17:02:55.312]     }
[17:02:55.312]     if (FALSE) {
[17:02:55.312]     }
[17:02:55.312]     else {
[17:02:55.312]         if (TRUE) {
[17:02:55.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.312]                 open = "w")
[17:02:55.312]         }
[17:02:55.312]         else {
[17:02:55.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.312]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.312]         }
[17:02:55.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.312]             base::sink(type = "output", split = FALSE)
[17:02:55.312]             base::close(...future.stdout)
[17:02:55.312]         }, add = TRUE)
[17:02:55.312]     }
[17:02:55.312]     ...future.frame <- base::sys.nframe()
[17:02:55.312]     ...future.conditions <- base::list()
[17:02:55.312]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.312]     if (FALSE) {
[17:02:55.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.312]     }
[17:02:55.312]     ...future.result <- base::tryCatch({
[17:02:55.312]         base::withCallingHandlers({
[17:02:55.312]             ...future.value <- base::withVisible(base::local({
[17:02:55.312]                 ...future.makeSendCondition <- base::local({
[17:02:55.312]                   sendCondition <- NULL
[17:02:55.312]                   function(frame = 1L) {
[17:02:55.312]                     if (is.function(sendCondition)) 
[17:02:55.312]                       return(sendCondition)
[17:02:55.312]                     ns <- getNamespace("parallel")
[17:02:55.312]                     if (exists("sendData", mode = "function", 
[17:02:55.312]                       envir = ns)) {
[17:02:55.312]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.312]                         envir = ns)
[17:02:55.312]                       envir <- sys.frame(frame)
[17:02:55.312]                       master <- NULL
[17:02:55.312]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.312]                         !identical(envir, emptyenv())) {
[17:02:55.312]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.312]                           inherits = FALSE)) {
[17:02:55.312]                           master <- get("master", mode = "list", 
[17:02:55.312]                             envir = envir, inherits = FALSE)
[17:02:55.312]                           if (inherits(master, c("SOCKnode", 
[17:02:55.312]                             "SOCK0node"))) {
[17:02:55.312]                             sendCondition <<- function(cond) {
[17:02:55.312]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.312]                                 success = TRUE)
[17:02:55.312]                               parallel_sendData(master, data)
[17:02:55.312]                             }
[17:02:55.312]                             return(sendCondition)
[17:02:55.312]                           }
[17:02:55.312]                         }
[17:02:55.312]                         frame <- frame + 1L
[17:02:55.312]                         envir <- sys.frame(frame)
[17:02:55.312]                       }
[17:02:55.312]                     }
[17:02:55.312]                     sendCondition <<- function(cond) NULL
[17:02:55.312]                   }
[17:02:55.312]                 })
[17:02:55.312]                 withCallingHandlers({
[17:02:55.312]                   value(a) + 1
[17:02:55.312]                 }, immediateCondition = function(cond) {
[17:02:55.312]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.312]                   sendCondition(cond)
[17:02:55.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.312]                   {
[17:02:55.312]                     inherits <- base::inherits
[17:02:55.312]                     invokeRestart <- base::invokeRestart
[17:02:55.312]                     is.null <- base::is.null
[17:02:55.312]                     muffled <- FALSE
[17:02:55.312]                     if (inherits(cond, "message")) {
[17:02:55.312]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.312]                       if (muffled) 
[17:02:55.312]                         invokeRestart("muffleMessage")
[17:02:55.312]                     }
[17:02:55.312]                     else if (inherits(cond, "warning")) {
[17:02:55.312]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.312]                       if (muffled) 
[17:02:55.312]                         invokeRestart("muffleWarning")
[17:02:55.312]                     }
[17:02:55.312]                     else if (inherits(cond, "condition")) {
[17:02:55.312]                       if (!is.null(pattern)) {
[17:02:55.312]                         computeRestarts <- base::computeRestarts
[17:02:55.312]                         grepl <- base::grepl
[17:02:55.312]                         restarts <- computeRestarts(cond)
[17:02:55.312]                         for (restart in restarts) {
[17:02:55.312]                           name <- restart$name
[17:02:55.312]                           if (is.null(name)) 
[17:02:55.312]                             next
[17:02:55.312]                           if (!grepl(pattern, name)) 
[17:02:55.312]                             next
[17:02:55.312]                           invokeRestart(restart)
[17:02:55.312]                           muffled <- TRUE
[17:02:55.312]                           break
[17:02:55.312]                         }
[17:02:55.312]                       }
[17:02:55.312]                     }
[17:02:55.312]                     invisible(muffled)
[17:02:55.312]                   }
[17:02:55.312]                   muffleCondition(cond)
[17:02:55.312]                 })
[17:02:55.312]             }))
[17:02:55.312]             future::FutureResult(value = ...future.value$value, 
[17:02:55.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.312]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.312]                     ...future.globalenv.names))
[17:02:55.312]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.312]         }, condition = base::local({
[17:02:55.312]             c <- base::c
[17:02:55.312]             inherits <- base::inherits
[17:02:55.312]             invokeRestart <- base::invokeRestart
[17:02:55.312]             length <- base::length
[17:02:55.312]             list <- base::list
[17:02:55.312]             seq.int <- base::seq.int
[17:02:55.312]             signalCondition <- base::signalCondition
[17:02:55.312]             sys.calls <- base::sys.calls
[17:02:55.312]             `[[` <- base::`[[`
[17:02:55.312]             `+` <- base::`+`
[17:02:55.312]             `<<-` <- base::`<<-`
[17:02:55.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.312]                   3L)]
[17:02:55.312]             }
[17:02:55.312]             function(cond) {
[17:02:55.312]                 is_error <- inherits(cond, "error")
[17:02:55.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.312]                   NULL)
[17:02:55.312]                 if (is_error) {
[17:02:55.312]                   sessionInformation <- function() {
[17:02:55.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.312]                       search = base::search(), system = base::Sys.info())
[17:02:55.312]                   }
[17:02:55.312]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.312]                     cond$call), session = sessionInformation(), 
[17:02:55.312]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.312]                   signalCondition(cond)
[17:02:55.312]                 }
[17:02:55.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.312]                 "immediateCondition"))) {
[17:02:55.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.312]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.312]                   if (TRUE && !signal) {
[17:02:55.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.312]                     {
[17:02:55.312]                       inherits <- base::inherits
[17:02:55.312]                       invokeRestart <- base::invokeRestart
[17:02:55.312]                       is.null <- base::is.null
[17:02:55.312]                       muffled <- FALSE
[17:02:55.312]                       if (inherits(cond, "message")) {
[17:02:55.312]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.312]                         if (muffled) 
[17:02:55.312]                           invokeRestart("muffleMessage")
[17:02:55.312]                       }
[17:02:55.312]                       else if (inherits(cond, "warning")) {
[17:02:55.312]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.312]                         if (muffled) 
[17:02:55.312]                           invokeRestart("muffleWarning")
[17:02:55.312]                       }
[17:02:55.312]                       else if (inherits(cond, "condition")) {
[17:02:55.312]                         if (!is.null(pattern)) {
[17:02:55.312]                           computeRestarts <- base::computeRestarts
[17:02:55.312]                           grepl <- base::grepl
[17:02:55.312]                           restarts <- computeRestarts(cond)
[17:02:55.312]                           for (restart in restarts) {
[17:02:55.312]                             name <- restart$name
[17:02:55.312]                             if (is.null(name)) 
[17:02:55.312]                               next
[17:02:55.312]                             if (!grepl(pattern, name)) 
[17:02:55.312]                               next
[17:02:55.312]                             invokeRestart(restart)
[17:02:55.312]                             muffled <- TRUE
[17:02:55.312]                             break
[17:02:55.312]                           }
[17:02:55.312]                         }
[17:02:55.312]                       }
[17:02:55.312]                       invisible(muffled)
[17:02:55.312]                     }
[17:02:55.312]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.312]                   }
[17:02:55.312]                 }
[17:02:55.312]                 else {
[17:02:55.312]                   if (TRUE) {
[17:02:55.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.312]                     {
[17:02:55.312]                       inherits <- base::inherits
[17:02:55.312]                       invokeRestart <- base::invokeRestart
[17:02:55.312]                       is.null <- base::is.null
[17:02:55.312]                       muffled <- FALSE
[17:02:55.312]                       if (inherits(cond, "message")) {
[17:02:55.312]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.312]                         if (muffled) 
[17:02:55.312]                           invokeRestart("muffleMessage")
[17:02:55.312]                       }
[17:02:55.312]                       else if (inherits(cond, "warning")) {
[17:02:55.312]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.312]                         if (muffled) 
[17:02:55.312]                           invokeRestart("muffleWarning")
[17:02:55.312]                       }
[17:02:55.312]                       else if (inherits(cond, "condition")) {
[17:02:55.312]                         if (!is.null(pattern)) {
[17:02:55.312]                           computeRestarts <- base::computeRestarts
[17:02:55.312]                           grepl <- base::grepl
[17:02:55.312]                           restarts <- computeRestarts(cond)
[17:02:55.312]                           for (restart in restarts) {
[17:02:55.312]                             name <- restart$name
[17:02:55.312]                             if (is.null(name)) 
[17:02:55.312]                               next
[17:02:55.312]                             if (!grepl(pattern, name)) 
[17:02:55.312]                               next
[17:02:55.312]                             invokeRestart(restart)
[17:02:55.312]                             muffled <- TRUE
[17:02:55.312]                             break
[17:02:55.312]                           }
[17:02:55.312]                         }
[17:02:55.312]                       }
[17:02:55.312]                       invisible(muffled)
[17:02:55.312]                     }
[17:02:55.312]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.312]                   }
[17:02:55.312]                 }
[17:02:55.312]             }
[17:02:55.312]         }))
[17:02:55.312]     }, error = function(ex) {
[17:02:55.312]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.312]                 ...future.rng), started = ...future.startTime, 
[17:02:55.312]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.312]             version = "1.8"), class = "FutureResult")
[17:02:55.312]     }, finally = {
[17:02:55.312]         if (!identical(...future.workdir, getwd())) 
[17:02:55.312]             setwd(...future.workdir)
[17:02:55.312]         {
[17:02:55.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.312]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.312]             }
[17:02:55.312]             base::options(...future.oldOptions)
[17:02:55.312]             if (.Platform$OS.type == "windows") {
[17:02:55.312]                 old_names <- names(...future.oldEnvVars)
[17:02:55.312]                 envs <- base::Sys.getenv()
[17:02:55.312]                 names <- names(envs)
[17:02:55.312]                 common <- intersect(names, old_names)
[17:02:55.312]                 added <- setdiff(names, old_names)
[17:02:55.312]                 removed <- setdiff(old_names, names)
[17:02:55.312]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.312]                   envs[common]]
[17:02:55.312]                 NAMES <- toupper(changed)
[17:02:55.312]                 args <- list()
[17:02:55.312]                 for (kk in seq_along(NAMES)) {
[17:02:55.312]                   name <- changed[[kk]]
[17:02:55.312]                   NAME <- NAMES[[kk]]
[17:02:55.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.312]                     next
[17:02:55.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.312]                 }
[17:02:55.312]                 NAMES <- toupper(added)
[17:02:55.312]                 for (kk in seq_along(NAMES)) {
[17:02:55.312]                   name <- added[[kk]]
[17:02:55.312]                   NAME <- NAMES[[kk]]
[17:02:55.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.312]                     next
[17:02:55.312]                   args[[name]] <- ""
[17:02:55.312]                 }
[17:02:55.312]                 NAMES <- toupper(removed)
[17:02:55.312]                 for (kk in seq_along(NAMES)) {
[17:02:55.312]                   name <- removed[[kk]]
[17:02:55.312]                   NAME <- NAMES[[kk]]
[17:02:55.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.312]                     next
[17:02:55.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.312]                 }
[17:02:55.312]                 if (length(args) > 0) 
[17:02:55.312]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.312]             }
[17:02:55.312]             else {
[17:02:55.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.312]             }
[17:02:55.312]             {
[17:02:55.312]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.312]                   0L) {
[17:02:55.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.312]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.312]                   base::options(opts)
[17:02:55.312]                 }
[17:02:55.312]                 {
[17:02:55.312]                   {
[17:02:55.312]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.312]                     NULL
[17:02:55.312]                   }
[17:02:55.312]                   options(future.plan = NULL)
[17:02:55.312]                   if (is.na(NA_character_)) 
[17:02:55.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.312]                     .init = FALSE)
[17:02:55.312]                 }
[17:02:55.312]             }
[17:02:55.312]         }
[17:02:55.312]     })
[17:02:55.312]     if (TRUE) {
[17:02:55.312]         base::sink(type = "output", split = FALSE)
[17:02:55.312]         if (TRUE) {
[17:02:55.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.312]         }
[17:02:55.312]         else {
[17:02:55.312]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.312]         }
[17:02:55.312]         base::close(...future.stdout)
[17:02:55.312]         ...future.stdout <- NULL
[17:02:55.312]     }
[17:02:55.312]     ...future.result$conditions <- ...future.conditions
[17:02:55.312]     ...future.result$finished <- base::Sys.time()
[17:02:55.312]     ...future.result
[17:02:55.312] }
[17:02:55.314] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:02:55.316] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:02:55.368] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.368] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.369] MultisessionFuture started
[17:02:55.369] - Launch lazy future ... done
[17:02:55.369] run() for ‘MultisessionFuture’ ... done
[17:02:55.369] result() for ClusterFuture ...
[17:02:55.369] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.369] - Validating connection of MultisessionFuture
[17:02:55.414] - received message: FutureResult
[17:02:55.414] - Received FutureResult
[17:02:55.414] - Erased future from FutureRegistry
[17:02:55.414] result() for ClusterFuture ...
[17:02:55.414] - result already collected: FutureResult
[17:02:55.414] result() for ClusterFuture ... done
[17:02:55.414] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.415] result() for ClusterFuture ... done
[17:02:55.415] result() for ClusterFuture ...
[17:02:55.415] - result already collected: FutureResult
[17:02:55.415] result() for ClusterFuture ... done
value(b) = 2
[17:02:55.415] result() for ClusterFuture ...
[17:02:55.415] - result already collected: FutureResult
[17:02:55.415] result() for ClusterFuture ... done
[17:02:55.415] result() for ClusterFuture ...
[17:02:55.415] - result already collected: FutureResult
[17:02:55.416] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.416] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.416] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.416] 
[17:02:55.417] Searching for globals ... DONE
[17:02:55.417] - globals: [0] <none>
[17:02:55.417] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.417] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.417] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.418] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:55.418] Searching for globals ... DONE
[17:02:55.418] Resolving globals: TRUE
[17:02:55.418] Resolving any globals that are futures ...
[17:02:55.418] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:55.419] Resolving any globals that are futures ... DONE
[17:02:55.419] Resolving futures part of globals (recursively) ...
[17:02:55.419] resolve() on list ...
[17:02:55.419]  recursive: 99
[17:02:55.419]  length: 1
[17:02:55.419]  elements: ‘a’
[17:02:55.419] run() for ‘Future’ ...
[17:02:55.420] - state: ‘created’
[17:02:55.420] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.434] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.434]   - Field: ‘node’
[17:02:55.434]   - Field: ‘label’
[17:02:55.434]   - Field: ‘local’
[17:02:55.434]   - Field: ‘owner’
[17:02:55.434]   - Field: ‘envir’
[17:02:55.435]   - Field: ‘workers’
[17:02:55.435]   - Field: ‘packages’
[17:02:55.435]   - Field: ‘gc’
[17:02:55.435]   - Field: ‘conditions’
[17:02:55.435]   - Field: ‘persistent’
[17:02:55.435]   - Field: ‘expr’
[17:02:55.435]   - Field: ‘uuid’
[17:02:55.435]   - Field: ‘seed’
[17:02:55.435]   - Field: ‘version’
[17:02:55.435]   - Field: ‘result’
[17:02:55.436]   - Field: ‘asynchronous’
[17:02:55.436]   - Field: ‘calls’
[17:02:55.436]   - Field: ‘globals’
[17:02:55.436]   - Field: ‘stdout’
[17:02:55.436]   - Field: ‘earlySignal’
[17:02:55.436]   - Field: ‘lazy’
[17:02:55.436]   - Field: ‘state’
[17:02:55.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.436] - Launch lazy future ...
[17:02:55.437] Packages needed by the future expression (n = 0): <none>
[17:02:55.437] Packages needed by future strategies (n = 0): <none>
[17:02:55.437] {
[17:02:55.437]     {
[17:02:55.437]         {
[17:02:55.437]             ...future.startTime <- base::Sys.time()
[17:02:55.437]             {
[17:02:55.437]                 {
[17:02:55.437]                   {
[17:02:55.437]                     {
[17:02:55.437]                       base::local({
[17:02:55.437]                         has_future <- base::requireNamespace("future", 
[17:02:55.437]                           quietly = TRUE)
[17:02:55.437]                         if (has_future) {
[17:02:55.437]                           ns <- base::getNamespace("future")
[17:02:55.437]                           version <- ns[[".package"]][["version"]]
[17:02:55.437]                           if (is.null(version)) 
[17:02:55.437]                             version <- utils::packageVersion("future")
[17:02:55.437]                         }
[17:02:55.437]                         else {
[17:02:55.437]                           version <- NULL
[17:02:55.437]                         }
[17:02:55.437]                         if (!has_future || version < "1.8.0") {
[17:02:55.437]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.437]                             "", base::R.version$version.string), 
[17:02:55.437]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.437]                               "release", "version")], collapse = " "), 
[17:02:55.437]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.437]                             info)
[17:02:55.437]                           info <- base::paste(info, collapse = "; ")
[17:02:55.437]                           if (!has_future) {
[17:02:55.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.437]                               info)
[17:02:55.437]                           }
[17:02:55.437]                           else {
[17:02:55.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.437]                               info, version)
[17:02:55.437]                           }
[17:02:55.437]                           base::stop(msg)
[17:02:55.437]                         }
[17:02:55.437]                       })
[17:02:55.437]                     }
[17:02:55.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.437]                     base::options(mc.cores = 1L)
[17:02:55.437]                   }
[17:02:55.437]                   ...future.strategy.old <- future::plan("list")
[17:02:55.437]                   options(future.plan = NULL)
[17:02:55.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.437]                 }
[17:02:55.437]                 ...future.workdir <- getwd()
[17:02:55.437]             }
[17:02:55.437]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.437]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.437]         }
[17:02:55.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.437]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.437]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.437]             base::names(...future.oldOptions))
[17:02:55.437]     }
[17:02:55.437]     if (FALSE) {
[17:02:55.437]     }
[17:02:55.437]     else {
[17:02:55.437]         if (TRUE) {
[17:02:55.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.437]                 open = "w")
[17:02:55.437]         }
[17:02:55.437]         else {
[17:02:55.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.437]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.437]         }
[17:02:55.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.437]             base::sink(type = "output", split = FALSE)
[17:02:55.437]             base::close(...future.stdout)
[17:02:55.437]         }, add = TRUE)
[17:02:55.437]     }
[17:02:55.437]     ...future.frame <- base::sys.nframe()
[17:02:55.437]     ...future.conditions <- base::list()
[17:02:55.437]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.437]     if (FALSE) {
[17:02:55.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.437]     }
[17:02:55.437]     ...future.result <- base::tryCatch({
[17:02:55.437]         base::withCallingHandlers({
[17:02:55.437]             ...future.value <- base::withVisible(base::local({
[17:02:55.437]                 ...future.makeSendCondition <- base::local({
[17:02:55.437]                   sendCondition <- NULL
[17:02:55.437]                   function(frame = 1L) {
[17:02:55.437]                     if (is.function(sendCondition)) 
[17:02:55.437]                       return(sendCondition)
[17:02:55.437]                     ns <- getNamespace("parallel")
[17:02:55.437]                     if (exists("sendData", mode = "function", 
[17:02:55.437]                       envir = ns)) {
[17:02:55.437]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.437]                         envir = ns)
[17:02:55.437]                       envir <- sys.frame(frame)
[17:02:55.437]                       master <- NULL
[17:02:55.437]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.437]                         !identical(envir, emptyenv())) {
[17:02:55.437]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.437]                           inherits = FALSE)) {
[17:02:55.437]                           master <- get("master", mode = "list", 
[17:02:55.437]                             envir = envir, inherits = FALSE)
[17:02:55.437]                           if (inherits(master, c("SOCKnode", 
[17:02:55.437]                             "SOCK0node"))) {
[17:02:55.437]                             sendCondition <<- function(cond) {
[17:02:55.437]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.437]                                 success = TRUE)
[17:02:55.437]                               parallel_sendData(master, data)
[17:02:55.437]                             }
[17:02:55.437]                             return(sendCondition)
[17:02:55.437]                           }
[17:02:55.437]                         }
[17:02:55.437]                         frame <- frame + 1L
[17:02:55.437]                         envir <- sys.frame(frame)
[17:02:55.437]                       }
[17:02:55.437]                     }
[17:02:55.437]                     sendCondition <<- function(cond) NULL
[17:02:55.437]                   }
[17:02:55.437]                 })
[17:02:55.437]                 withCallingHandlers({
[17:02:55.437]                   1
[17:02:55.437]                 }, immediateCondition = function(cond) {
[17:02:55.437]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.437]                   sendCondition(cond)
[17:02:55.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.437]                   {
[17:02:55.437]                     inherits <- base::inherits
[17:02:55.437]                     invokeRestart <- base::invokeRestart
[17:02:55.437]                     is.null <- base::is.null
[17:02:55.437]                     muffled <- FALSE
[17:02:55.437]                     if (inherits(cond, "message")) {
[17:02:55.437]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.437]                       if (muffled) 
[17:02:55.437]                         invokeRestart("muffleMessage")
[17:02:55.437]                     }
[17:02:55.437]                     else if (inherits(cond, "warning")) {
[17:02:55.437]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.437]                       if (muffled) 
[17:02:55.437]                         invokeRestart("muffleWarning")
[17:02:55.437]                     }
[17:02:55.437]                     else if (inherits(cond, "condition")) {
[17:02:55.437]                       if (!is.null(pattern)) {
[17:02:55.437]                         computeRestarts <- base::computeRestarts
[17:02:55.437]                         grepl <- base::grepl
[17:02:55.437]                         restarts <- computeRestarts(cond)
[17:02:55.437]                         for (restart in restarts) {
[17:02:55.437]                           name <- restart$name
[17:02:55.437]                           if (is.null(name)) 
[17:02:55.437]                             next
[17:02:55.437]                           if (!grepl(pattern, name)) 
[17:02:55.437]                             next
[17:02:55.437]                           invokeRestart(restart)
[17:02:55.437]                           muffled <- TRUE
[17:02:55.437]                           break
[17:02:55.437]                         }
[17:02:55.437]                       }
[17:02:55.437]                     }
[17:02:55.437]                     invisible(muffled)
[17:02:55.437]                   }
[17:02:55.437]                   muffleCondition(cond)
[17:02:55.437]                 })
[17:02:55.437]             }))
[17:02:55.437]             future::FutureResult(value = ...future.value$value, 
[17:02:55.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.437]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.437]                     ...future.globalenv.names))
[17:02:55.437]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.437]         }, condition = base::local({
[17:02:55.437]             c <- base::c
[17:02:55.437]             inherits <- base::inherits
[17:02:55.437]             invokeRestart <- base::invokeRestart
[17:02:55.437]             length <- base::length
[17:02:55.437]             list <- base::list
[17:02:55.437]             seq.int <- base::seq.int
[17:02:55.437]             signalCondition <- base::signalCondition
[17:02:55.437]             sys.calls <- base::sys.calls
[17:02:55.437]             `[[` <- base::`[[`
[17:02:55.437]             `+` <- base::`+`
[17:02:55.437]             `<<-` <- base::`<<-`
[17:02:55.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.437]                   3L)]
[17:02:55.437]             }
[17:02:55.437]             function(cond) {
[17:02:55.437]                 is_error <- inherits(cond, "error")
[17:02:55.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.437]                   NULL)
[17:02:55.437]                 if (is_error) {
[17:02:55.437]                   sessionInformation <- function() {
[17:02:55.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.437]                       search = base::search(), system = base::Sys.info())
[17:02:55.437]                   }
[17:02:55.437]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.437]                     cond$call), session = sessionInformation(), 
[17:02:55.437]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.437]                   signalCondition(cond)
[17:02:55.437]                 }
[17:02:55.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.437]                 "immediateCondition"))) {
[17:02:55.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.437]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.437]                   if (TRUE && !signal) {
[17:02:55.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.437]                     {
[17:02:55.437]                       inherits <- base::inherits
[17:02:55.437]                       invokeRestart <- base::invokeRestart
[17:02:55.437]                       is.null <- base::is.null
[17:02:55.437]                       muffled <- FALSE
[17:02:55.437]                       if (inherits(cond, "message")) {
[17:02:55.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.437]                         if (muffled) 
[17:02:55.437]                           invokeRestart("muffleMessage")
[17:02:55.437]                       }
[17:02:55.437]                       else if (inherits(cond, "warning")) {
[17:02:55.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.437]                         if (muffled) 
[17:02:55.437]                           invokeRestart("muffleWarning")
[17:02:55.437]                       }
[17:02:55.437]                       else if (inherits(cond, "condition")) {
[17:02:55.437]                         if (!is.null(pattern)) {
[17:02:55.437]                           computeRestarts <- base::computeRestarts
[17:02:55.437]                           grepl <- base::grepl
[17:02:55.437]                           restarts <- computeRestarts(cond)
[17:02:55.437]                           for (restart in restarts) {
[17:02:55.437]                             name <- restart$name
[17:02:55.437]                             if (is.null(name)) 
[17:02:55.437]                               next
[17:02:55.437]                             if (!grepl(pattern, name)) 
[17:02:55.437]                               next
[17:02:55.437]                             invokeRestart(restart)
[17:02:55.437]                             muffled <- TRUE
[17:02:55.437]                             break
[17:02:55.437]                           }
[17:02:55.437]                         }
[17:02:55.437]                       }
[17:02:55.437]                       invisible(muffled)
[17:02:55.437]                     }
[17:02:55.437]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.437]                   }
[17:02:55.437]                 }
[17:02:55.437]                 else {
[17:02:55.437]                   if (TRUE) {
[17:02:55.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.437]                     {
[17:02:55.437]                       inherits <- base::inherits
[17:02:55.437]                       invokeRestart <- base::invokeRestart
[17:02:55.437]                       is.null <- base::is.null
[17:02:55.437]                       muffled <- FALSE
[17:02:55.437]                       if (inherits(cond, "message")) {
[17:02:55.437]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.437]                         if (muffled) 
[17:02:55.437]                           invokeRestart("muffleMessage")
[17:02:55.437]                       }
[17:02:55.437]                       else if (inherits(cond, "warning")) {
[17:02:55.437]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.437]                         if (muffled) 
[17:02:55.437]                           invokeRestart("muffleWarning")
[17:02:55.437]                       }
[17:02:55.437]                       else if (inherits(cond, "condition")) {
[17:02:55.437]                         if (!is.null(pattern)) {
[17:02:55.437]                           computeRestarts <- base::computeRestarts
[17:02:55.437]                           grepl <- base::grepl
[17:02:55.437]                           restarts <- computeRestarts(cond)
[17:02:55.437]                           for (restart in restarts) {
[17:02:55.437]                             name <- restart$name
[17:02:55.437]                             if (is.null(name)) 
[17:02:55.437]                               next
[17:02:55.437]                             if (!grepl(pattern, name)) 
[17:02:55.437]                               next
[17:02:55.437]                             invokeRestart(restart)
[17:02:55.437]                             muffled <- TRUE
[17:02:55.437]                             break
[17:02:55.437]                           }
[17:02:55.437]                         }
[17:02:55.437]                       }
[17:02:55.437]                       invisible(muffled)
[17:02:55.437]                     }
[17:02:55.437]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.437]                   }
[17:02:55.437]                 }
[17:02:55.437]             }
[17:02:55.437]         }))
[17:02:55.437]     }, error = function(ex) {
[17:02:55.437]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.437]                 ...future.rng), started = ...future.startTime, 
[17:02:55.437]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.437]             version = "1.8"), class = "FutureResult")
[17:02:55.437]     }, finally = {
[17:02:55.437]         if (!identical(...future.workdir, getwd())) 
[17:02:55.437]             setwd(...future.workdir)
[17:02:55.437]         {
[17:02:55.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.437]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.437]             }
[17:02:55.437]             base::options(...future.oldOptions)
[17:02:55.437]             if (.Platform$OS.type == "windows") {
[17:02:55.437]                 old_names <- names(...future.oldEnvVars)
[17:02:55.437]                 envs <- base::Sys.getenv()
[17:02:55.437]                 names <- names(envs)
[17:02:55.437]                 common <- intersect(names, old_names)
[17:02:55.437]                 added <- setdiff(names, old_names)
[17:02:55.437]                 removed <- setdiff(old_names, names)
[17:02:55.437]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.437]                   envs[common]]
[17:02:55.437]                 NAMES <- toupper(changed)
[17:02:55.437]                 args <- list()
[17:02:55.437]                 for (kk in seq_along(NAMES)) {
[17:02:55.437]                   name <- changed[[kk]]
[17:02:55.437]                   NAME <- NAMES[[kk]]
[17:02:55.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.437]                     next
[17:02:55.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.437]                 }
[17:02:55.437]                 NAMES <- toupper(added)
[17:02:55.437]                 for (kk in seq_along(NAMES)) {
[17:02:55.437]                   name <- added[[kk]]
[17:02:55.437]                   NAME <- NAMES[[kk]]
[17:02:55.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.437]                     next
[17:02:55.437]                   args[[name]] <- ""
[17:02:55.437]                 }
[17:02:55.437]                 NAMES <- toupper(removed)
[17:02:55.437]                 for (kk in seq_along(NAMES)) {
[17:02:55.437]                   name <- removed[[kk]]
[17:02:55.437]                   NAME <- NAMES[[kk]]
[17:02:55.437]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.437]                     next
[17:02:55.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.437]                 }
[17:02:55.437]                 if (length(args) > 0) 
[17:02:55.437]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.437]             }
[17:02:55.437]             else {
[17:02:55.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.437]             }
[17:02:55.437]             {
[17:02:55.437]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.437]                   0L) {
[17:02:55.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.437]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.437]                   base::options(opts)
[17:02:55.437]                 }
[17:02:55.437]                 {
[17:02:55.437]                   {
[17:02:55.437]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.437]                     NULL
[17:02:55.437]                   }
[17:02:55.437]                   options(future.plan = NULL)
[17:02:55.437]                   if (is.na(NA_character_)) 
[17:02:55.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.437]                     .init = FALSE)
[17:02:55.437]                 }
[17:02:55.437]             }
[17:02:55.437]         }
[17:02:55.437]     })
[17:02:55.437]     if (TRUE) {
[17:02:55.437]         base::sink(type = "output", split = FALSE)
[17:02:55.437]         if (TRUE) {
[17:02:55.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.437]         }
[17:02:55.437]         else {
[17:02:55.437]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.437]         }
[17:02:55.437]         base::close(...future.stdout)
[17:02:55.437]         ...future.stdout <- NULL
[17:02:55.437]     }
[17:02:55.437]     ...future.result$conditions <- ...future.conditions
[17:02:55.437]     ...future.result$finished <- base::Sys.time()
[17:02:55.437]     ...future.result
[17:02:55.437] }
[17:02:55.440] MultisessionFuture started
[17:02:55.440] - Launch lazy future ... done
[17:02:55.440] run() for ‘MultisessionFuture’ ... done
[17:02:55.485] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.485] - Validating connection of MultisessionFuture
[17:02:55.486] - received message: FutureResult
[17:02:55.486] - Received FutureResult
[17:02:55.486] - Erased future from FutureRegistry
[17:02:55.486] result() for ClusterFuture ...
[17:02:55.486] - result already collected: FutureResult
[17:02:55.486] result() for ClusterFuture ... done
[17:02:55.486] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.486] Future #1
[17:02:55.486] result() for ClusterFuture ...
[17:02:55.487] - result already collected: FutureResult
[17:02:55.487] result() for ClusterFuture ... done
[17:02:55.487] result() for ClusterFuture ...
[17:02:55.487] - result already collected: FutureResult
[17:02:55.487] result() for ClusterFuture ... done
[17:02:55.487] A MultisessionFuture was resolved
[17:02:55.487]  length: 0 (resolved future 1)
[17:02:55.487] resolve() on list ... DONE
[17:02:55.487] - globals: [1] ‘a’
[17:02:55.487] Resolving futures part of globals (recursively) ... DONE
[17:02:55.489] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[17:02:55.490] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:55.490] - globals: [1] ‘a’
[17:02:55.490] - packages: [1] ‘future’
[17:02:55.490] getGlobalsAndPackages() ... DONE
[17:02:55.491] run() for ‘Future’ ...
[17:02:55.491] - state: ‘created’
[17:02:55.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.510] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.510]   - Field: ‘node’
[17:02:55.511]   - Field: ‘label’
[17:02:55.511]   - Field: ‘local’
[17:02:55.511]   - Field: ‘owner’
[17:02:55.511]   - Field: ‘envir’
[17:02:55.511]   - Field: ‘workers’
[17:02:55.511]   - Field: ‘packages’
[17:02:55.511]   - Field: ‘gc’
[17:02:55.512]   - Field: ‘conditions’
[17:02:55.512]   - Field: ‘persistent’
[17:02:55.512]   - Field: ‘expr’
[17:02:55.512]   - Field: ‘uuid’
[17:02:55.512]   - Field: ‘seed’
[17:02:55.512]   - Field: ‘version’
[17:02:55.512]   - Field: ‘result’
[17:02:55.513]   - Field: ‘asynchronous’
[17:02:55.513]   - Field: ‘calls’
[17:02:55.513]   - Field: ‘globals’
[17:02:55.513]   - Field: ‘stdout’
[17:02:55.513]   - Field: ‘earlySignal’
[17:02:55.513]   - Field: ‘lazy’
[17:02:55.513]   - Field: ‘state’
[17:02:55.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.514] - Launch lazy future ...
[17:02:55.514] Packages needed by the future expression (n = 1): ‘future’
[17:02:55.514] Packages needed by future strategies (n = 0): <none>
[17:02:55.515] {
[17:02:55.515]     {
[17:02:55.515]         {
[17:02:55.515]             ...future.startTime <- base::Sys.time()
[17:02:55.515]             {
[17:02:55.515]                 {
[17:02:55.515]                   {
[17:02:55.515]                     {
[17:02:55.515]                       {
[17:02:55.515]                         base::local({
[17:02:55.515]                           has_future <- base::requireNamespace("future", 
[17:02:55.515]                             quietly = TRUE)
[17:02:55.515]                           if (has_future) {
[17:02:55.515]                             ns <- base::getNamespace("future")
[17:02:55.515]                             version <- ns[[".package"]][["version"]]
[17:02:55.515]                             if (is.null(version)) 
[17:02:55.515]                               version <- utils::packageVersion("future")
[17:02:55.515]                           }
[17:02:55.515]                           else {
[17:02:55.515]                             version <- NULL
[17:02:55.515]                           }
[17:02:55.515]                           if (!has_future || version < "1.8.0") {
[17:02:55.515]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.515]                               "", base::R.version$version.string), 
[17:02:55.515]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:55.515]                                 base::R.version$platform, 8 * 
[17:02:55.515]                                   base::.Machine$sizeof.pointer), 
[17:02:55.515]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.515]                                 "release", "version")], collapse = " "), 
[17:02:55.515]                               hostname = base::Sys.info()[["nodename"]])
[17:02:55.515]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.515]                               info)
[17:02:55.515]                             info <- base::paste(info, collapse = "; ")
[17:02:55.515]                             if (!has_future) {
[17:02:55.515]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.515]                                 info)
[17:02:55.515]                             }
[17:02:55.515]                             else {
[17:02:55.515]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.515]                                 info, version)
[17:02:55.515]                             }
[17:02:55.515]                             base::stop(msg)
[17:02:55.515]                           }
[17:02:55.515]                         })
[17:02:55.515]                       }
[17:02:55.515]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.515]                       base::options(mc.cores = 1L)
[17:02:55.515]                     }
[17:02:55.515]                     base::local({
[17:02:55.515]                       for (pkg in "future") {
[17:02:55.515]                         base::loadNamespace(pkg)
[17:02:55.515]                         base::library(pkg, character.only = TRUE)
[17:02:55.515]                       }
[17:02:55.515]                     })
[17:02:55.515]                   }
[17:02:55.515]                   ...future.strategy.old <- future::plan("list")
[17:02:55.515]                   options(future.plan = NULL)
[17:02:55.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.515]                 }
[17:02:55.515]                 ...future.workdir <- getwd()
[17:02:55.515]             }
[17:02:55.515]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.515]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.515]         }
[17:02:55.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.515]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.515]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.515]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.515]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.515]             base::names(...future.oldOptions))
[17:02:55.515]     }
[17:02:55.515]     if (FALSE) {
[17:02:55.515]     }
[17:02:55.515]     else {
[17:02:55.515]         if (TRUE) {
[17:02:55.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.515]                 open = "w")
[17:02:55.515]         }
[17:02:55.515]         else {
[17:02:55.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.515]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.515]         }
[17:02:55.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.515]             base::sink(type = "output", split = FALSE)
[17:02:55.515]             base::close(...future.stdout)
[17:02:55.515]         }, add = TRUE)
[17:02:55.515]     }
[17:02:55.515]     ...future.frame <- base::sys.nframe()
[17:02:55.515]     ...future.conditions <- base::list()
[17:02:55.515]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.515]     if (FALSE) {
[17:02:55.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.515]     }
[17:02:55.515]     ...future.result <- base::tryCatch({
[17:02:55.515]         base::withCallingHandlers({
[17:02:55.515]             ...future.value <- base::withVisible(base::local({
[17:02:55.515]                 ...future.makeSendCondition <- base::local({
[17:02:55.515]                   sendCondition <- NULL
[17:02:55.515]                   function(frame = 1L) {
[17:02:55.515]                     if (is.function(sendCondition)) 
[17:02:55.515]                       return(sendCondition)
[17:02:55.515]                     ns <- getNamespace("parallel")
[17:02:55.515]                     if (exists("sendData", mode = "function", 
[17:02:55.515]                       envir = ns)) {
[17:02:55.515]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.515]                         envir = ns)
[17:02:55.515]                       envir <- sys.frame(frame)
[17:02:55.515]                       master <- NULL
[17:02:55.515]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.515]                         !identical(envir, emptyenv())) {
[17:02:55.515]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.515]                           inherits = FALSE)) {
[17:02:55.515]                           master <- get("master", mode = "list", 
[17:02:55.515]                             envir = envir, inherits = FALSE)
[17:02:55.515]                           if (inherits(master, c("SOCKnode", 
[17:02:55.515]                             "SOCK0node"))) {
[17:02:55.515]                             sendCondition <<- function(cond) {
[17:02:55.515]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.515]                                 success = TRUE)
[17:02:55.515]                               parallel_sendData(master, data)
[17:02:55.515]                             }
[17:02:55.515]                             return(sendCondition)
[17:02:55.515]                           }
[17:02:55.515]                         }
[17:02:55.515]                         frame <- frame + 1L
[17:02:55.515]                         envir <- sys.frame(frame)
[17:02:55.515]                       }
[17:02:55.515]                     }
[17:02:55.515]                     sendCondition <<- function(cond) NULL
[17:02:55.515]                   }
[17:02:55.515]                 })
[17:02:55.515]                 withCallingHandlers({
[17:02:55.515]                   value(a) + 1
[17:02:55.515]                 }, immediateCondition = function(cond) {
[17:02:55.515]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.515]                   sendCondition(cond)
[17:02:55.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.515]                   {
[17:02:55.515]                     inherits <- base::inherits
[17:02:55.515]                     invokeRestart <- base::invokeRestart
[17:02:55.515]                     is.null <- base::is.null
[17:02:55.515]                     muffled <- FALSE
[17:02:55.515]                     if (inherits(cond, "message")) {
[17:02:55.515]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.515]                       if (muffled) 
[17:02:55.515]                         invokeRestart("muffleMessage")
[17:02:55.515]                     }
[17:02:55.515]                     else if (inherits(cond, "warning")) {
[17:02:55.515]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.515]                       if (muffled) 
[17:02:55.515]                         invokeRestart("muffleWarning")
[17:02:55.515]                     }
[17:02:55.515]                     else if (inherits(cond, "condition")) {
[17:02:55.515]                       if (!is.null(pattern)) {
[17:02:55.515]                         computeRestarts <- base::computeRestarts
[17:02:55.515]                         grepl <- base::grepl
[17:02:55.515]                         restarts <- computeRestarts(cond)
[17:02:55.515]                         for (restart in restarts) {
[17:02:55.515]                           name <- restart$name
[17:02:55.515]                           if (is.null(name)) 
[17:02:55.515]                             next
[17:02:55.515]                           if (!grepl(pattern, name)) 
[17:02:55.515]                             next
[17:02:55.515]                           invokeRestart(restart)
[17:02:55.515]                           muffled <- TRUE
[17:02:55.515]                           break
[17:02:55.515]                         }
[17:02:55.515]                       }
[17:02:55.515]                     }
[17:02:55.515]                     invisible(muffled)
[17:02:55.515]                   }
[17:02:55.515]                   muffleCondition(cond)
[17:02:55.515]                 })
[17:02:55.515]             }))
[17:02:55.515]             future::FutureResult(value = ...future.value$value, 
[17:02:55.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.515]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.515]                     ...future.globalenv.names))
[17:02:55.515]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.515]         }, condition = base::local({
[17:02:55.515]             c <- base::c
[17:02:55.515]             inherits <- base::inherits
[17:02:55.515]             invokeRestart <- base::invokeRestart
[17:02:55.515]             length <- base::length
[17:02:55.515]             list <- base::list
[17:02:55.515]             seq.int <- base::seq.int
[17:02:55.515]             signalCondition <- base::signalCondition
[17:02:55.515]             sys.calls <- base::sys.calls
[17:02:55.515]             `[[` <- base::`[[`
[17:02:55.515]             `+` <- base::`+`
[17:02:55.515]             `<<-` <- base::`<<-`
[17:02:55.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.515]                   3L)]
[17:02:55.515]             }
[17:02:55.515]             function(cond) {
[17:02:55.515]                 is_error <- inherits(cond, "error")
[17:02:55.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.515]                   NULL)
[17:02:55.515]                 if (is_error) {
[17:02:55.515]                   sessionInformation <- function() {
[17:02:55.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.515]                       search = base::search(), system = base::Sys.info())
[17:02:55.515]                   }
[17:02:55.515]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.515]                     cond$call), session = sessionInformation(), 
[17:02:55.515]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.515]                   signalCondition(cond)
[17:02:55.515]                 }
[17:02:55.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.515]                 "immediateCondition"))) {
[17:02:55.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.515]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.515]                   if (TRUE && !signal) {
[17:02:55.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.515]                     {
[17:02:55.515]                       inherits <- base::inherits
[17:02:55.515]                       invokeRestart <- base::invokeRestart
[17:02:55.515]                       is.null <- base::is.null
[17:02:55.515]                       muffled <- FALSE
[17:02:55.515]                       if (inherits(cond, "message")) {
[17:02:55.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.515]                         if (muffled) 
[17:02:55.515]                           invokeRestart("muffleMessage")
[17:02:55.515]                       }
[17:02:55.515]                       else if (inherits(cond, "warning")) {
[17:02:55.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.515]                         if (muffled) 
[17:02:55.515]                           invokeRestart("muffleWarning")
[17:02:55.515]                       }
[17:02:55.515]                       else if (inherits(cond, "condition")) {
[17:02:55.515]                         if (!is.null(pattern)) {
[17:02:55.515]                           computeRestarts <- base::computeRestarts
[17:02:55.515]                           grepl <- base::grepl
[17:02:55.515]                           restarts <- computeRestarts(cond)
[17:02:55.515]                           for (restart in restarts) {
[17:02:55.515]                             name <- restart$name
[17:02:55.515]                             if (is.null(name)) 
[17:02:55.515]                               next
[17:02:55.515]                             if (!grepl(pattern, name)) 
[17:02:55.515]                               next
[17:02:55.515]                             invokeRestart(restart)
[17:02:55.515]                             muffled <- TRUE
[17:02:55.515]                             break
[17:02:55.515]                           }
[17:02:55.515]                         }
[17:02:55.515]                       }
[17:02:55.515]                       invisible(muffled)
[17:02:55.515]                     }
[17:02:55.515]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.515]                   }
[17:02:55.515]                 }
[17:02:55.515]                 else {
[17:02:55.515]                   if (TRUE) {
[17:02:55.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.515]                     {
[17:02:55.515]                       inherits <- base::inherits
[17:02:55.515]                       invokeRestart <- base::invokeRestart
[17:02:55.515]                       is.null <- base::is.null
[17:02:55.515]                       muffled <- FALSE
[17:02:55.515]                       if (inherits(cond, "message")) {
[17:02:55.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.515]                         if (muffled) 
[17:02:55.515]                           invokeRestart("muffleMessage")
[17:02:55.515]                       }
[17:02:55.515]                       else if (inherits(cond, "warning")) {
[17:02:55.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.515]                         if (muffled) 
[17:02:55.515]                           invokeRestart("muffleWarning")
[17:02:55.515]                       }
[17:02:55.515]                       else if (inherits(cond, "condition")) {
[17:02:55.515]                         if (!is.null(pattern)) {
[17:02:55.515]                           computeRestarts <- base::computeRestarts
[17:02:55.515]                           grepl <- base::grepl
[17:02:55.515]                           restarts <- computeRestarts(cond)
[17:02:55.515]                           for (restart in restarts) {
[17:02:55.515]                             name <- restart$name
[17:02:55.515]                             if (is.null(name)) 
[17:02:55.515]                               next
[17:02:55.515]                             if (!grepl(pattern, name)) 
[17:02:55.515]                               next
[17:02:55.515]                             invokeRestart(restart)
[17:02:55.515]                             muffled <- TRUE
[17:02:55.515]                             break
[17:02:55.515]                           }
[17:02:55.515]                         }
[17:02:55.515]                       }
[17:02:55.515]                       invisible(muffled)
[17:02:55.515]                     }
[17:02:55.515]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.515]                   }
[17:02:55.515]                 }
[17:02:55.515]             }
[17:02:55.515]         }))
[17:02:55.515]     }, error = function(ex) {
[17:02:55.515]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.515]                 ...future.rng), started = ...future.startTime, 
[17:02:55.515]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.515]             version = "1.8"), class = "FutureResult")
[17:02:55.515]     }, finally = {
[17:02:55.515]         if (!identical(...future.workdir, getwd())) 
[17:02:55.515]             setwd(...future.workdir)
[17:02:55.515]         {
[17:02:55.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.515]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.515]             }
[17:02:55.515]             base::options(...future.oldOptions)
[17:02:55.515]             if (.Platform$OS.type == "windows") {
[17:02:55.515]                 old_names <- names(...future.oldEnvVars)
[17:02:55.515]                 envs <- base::Sys.getenv()
[17:02:55.515]                 names <- names(envs)
[17:02:55.515]                 common <- intersect(names, old_names)
[17:02:55.515]                 added <- setdiff(names, old_names)
[17:02:55.515]                 removed <- setdiff(old_names, names)
[17:02:55.515]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.515]                   envs[common]]
[17:02:55.515]                 NAMES <- toupper(changed)
[17:02:55.515]                 args <- list()
[17:02:55.515]                 for (kk in seq_along(NAMES)) {
[17:02:55.515]                   name <- changed[[kk]]
[17:02:55.515]                   NAME <- NAMES[[kk]]
[17:02:55.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.515]                     next
[17:02:55.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.515]                 }
[17:02:55.515]                 NAMES <- toupper(added)
[17:02:55.515]                 for (kk in seq_along(NAMES)) {
[17:02:55.515]                   name <- added[[kk]]
[17:02:55.515]                   NAME <- NAMES[[kk]]
[17:02:55.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.515]                     next
[17:02:55.515]                   args[[name]] <- ""
[17:02:55.515]                 }
[17:02:55.515]                 NAMES <- toupper(removed)
[17:02:55.515]                 for (kk in seq_along(NAMES)) {
[17:02:55.515]                   name <- removed[[kk]]
[17:02:55.515]                   NAME <- NAMES[[kk]]
[17:02:55.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.515]                     next
[17:02:55.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.515]                 }
[17:02:55.515]                 if (length(args) > 0) 
[17:02:55.515]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.515]             }
[17:02:55.515]             else {
[17:02:55.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.515]             }
[17:02:55.515]             {
[17:02:55.515]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.515]                   0L) {
[17:02:55.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.515]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.515]                   base::options(opts)
[17:02:55.515]                 }
[17:02:55.515]                 {
[17:02:55.515]                   {
[17:02:55.515]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.515]                     NULL
[17:02:55.515]                   }
[17:02:55.515]                   options(future.plan = NULL)
[17:02:55.515]                   if (is.na(NA_character_)) 
[17:02:55.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.515]                     .init = FALSE)
[17:02:55.515]                 }
[17:02:55.515]             }
[17:02:55.515]         }
[17:02:55.515]     })
[17:02:55.515]     if (TRUE) {
[17:02:55.515]         base::sink(type = "output", split = FALSE)
[17:02:55.515]         if (TRUE) {
[17:02:55.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.515]         }
[17:02:55.515]         else {
[17:02:55.515]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.515]         }
[17:02:55.515]         base::close(...future.stdout)
[17:02:55.515]         ...future.stdout <- NULL
[17:02:55.515]     }
[17:02:55.515]     ...future.result$conditions <- ...future.conditions
[17:02:55.515]     ...future.result$finished <- base::Sys.time()
[17:02:55.515]     ...future.result
[17:02:55.515] }
[17:02:55.519] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:02:55.522] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:02:55.576] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.576] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.577] MultisessionFuture started
[17:02:55.577] - Launch lazy future ... done
[17:02:55.577] run() for ‘MultisessionFuture’ ... done
[17:02:55.578] result() for ClusterFuture ...
[17:02:55.578] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.578] - Validating connection of MultisessionFuture
[17:02:55.622] - received message: FutureResult
[17:02:55.622] - Received FutureResult
[17:02:55.622] - Erased future from FutureRegistry
[17:02:55.622] result() for ClusterFuture ...
[17:02:55.622] - result already collected: FutureResult
[17:02:55.622] result() for ClusterFuture ... done
[17:02:55.623] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.623] result() for ClusterFuture ... done
[17:02:55.623] result() for ClusterFuture ...
[17:02:55.623] - result already collected: FutureResult
[17:02:55.623] result() for ClusterFuture ... done
value(b) = 2
[17:02:55.623] result() for ClusterFuture ...
[17:02:55.623] - result already collected: FutureResult
[17:02:55.623] result() for ClusterFuture ... done
[17:02:55.624] result() for ClusterFuture ...
[17:02:55.624] - result already collected: FutureResult
[17:02:55.624] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.624] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.624] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.625] 
[17:02:55.625] Searching for globals ... DONE
[17:02:55.625] - globals: [0] <none>
[17:02:55.625] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.625] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.626] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.626] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:02:55.627] Searching for globals ... DONE
[17:02:55.627] Resolving globals: TRUE
[17:02:55.627] Resolving any globals that are futures ...
[17:02:55.627] - globals: [3] ‘+’, ‘value’, ‘a’
[17:02:55.627] Resolving any globals that are futures ... DONE
[17:02:55.627] Resolving futures part of globals (recursively) ...
[17:02:55.628] resolve() on list ...
[17:02:55.628]  recursive: 99
[17:02:55.628]  length: 1
[17:02:55.628]  elements: ‘a’
[17:02:55.628] run() for ‘Future’ ...
[17:02:55.628] - state: ‘created’
[17:02:55.628] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.642] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.643]   - Field: ‘node’
[17:02:55.643]   - Field: ‘label’
[17:02:55.643]   - Field: ‘local’
[17:02:55.643]   - Field: ‘owner’
[17:02:55.643]   - Field: ‘envir’
[17:02:55.643]   - Field: ‘workers’
[17:02:55.643]   - Field: ‘packages’
[17:02:55.643]   - Field: ‘gc’
[17:02:55.643]   - Field: ‘conditions’
[17:02:55.643]   - Field: ‘persistent’
[17:02:55.644]   - Field: ‘expr’
[17:02:55.644]   - Field: ‘uuid’
[17:02:55.644]   - Field: ‘seed’
[17:02:55.644]   - Field: ‘version’
[17:02:55.644]   - Field: ‘result’
[17:02:55.644]   - Field: ‘asynchronous’
[17:02:55.644]   - Field: ‘calls’
[17:02:55.644]   - Field: ‘globals’
[17:02:55.644]   - Field: ‘stdout’
[17:02:55.644]   - Field: ‘earlySignal’
[17:02:55.644]   - Field: ‘lazy’
[17:02:55.645]   - Field: ‘state’
[17:02:55.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.645] - Launch lazy future ...
[17:02:55.645] Packages needed by the future expression (n = 0): <none>
[17:02:55.645] Packages needed by future strategies (n = 0): <none>
[17:02:55.646] {
[17:02:55.646]     {
[17:02:55.646]         {
[17:02:55.646]             ...future.startTime <- base::Sys.time()
[17:02:55.646]             {
[17:02:55.646]                 {
[17:02:55.646]                   {
[17:02:55.646]                     {
[17:02:55.646]                       base::local({
[17:02:55.646]                         has_future <- base::requireNamespace("future", 
[17:02:55.646]                           quietly = TRUE)
[17:02:55.646]                         if (has_future) {
[17:02:55.646]                           ns <- base::getNamespace("future")
[17:02:55.646]                           version <- ns[[".package"]][["version"]]
[17:02:55.646]                           if (is.null(version)) 
[17:02:55.646]                             version <- utils::packageVersion("future")
[17:02:55.646]                         }
[17:02:55.646]                         else {
[17:02:55.646]                           version <- NULL
[17:02:55.646]                         }
[17:02:55.646]                         if (!has_future || version < "1.8.0") {
[17:02:55.646]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.646]                             "", base::R.version$version.string), 
[17:02:55.646]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.646]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.646]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.646]                               "release", "version")], collapse = " "), 
[17:02:55.646]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.646]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.646]                             info)
[17:02:55.646]                           info <- base::paste(info, collapse = "; ")
[17:02:55.646]                           if (!has_future) {
[17:02:55.646]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.646]                               info)
[17:02:55.646]                           }
[17:02:55.646]                           else {
[17:02:55.646]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.646]                               info, version)
[17:02:55.646]                           }
[17:02:55.646]                           base::stop(msg)
[17:02:55.646]                         }
[17:02:55.646]                       })
[17:02:55.646]                     }
[17:02:55.646]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.646]                     base::options(mc.cores = 1L)
[17:02:55.646]                   }
[17:02:55.646]                   ...future.strategy.old <- future::plan("list")
[17:02:55.646]                   options(future.plan = NULL)
[17:02:55.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.646]                 }
[17:02:55.646]                 ...future.workdir <- getwd()
[17:02:55.646]             }
[17:02:55.646]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.646]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.646]         }
[17:02:55.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.646]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.646]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.646]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.646]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.646]             base::names(...future.oldOptions))
[17:02:55.646]     }
[17:02:55.646]     if (FALSE) {
[17:02:55.646]     }
[17:02:55.646]     else {
[17:02:55.646]         if (TRUE) {
[17:02:55.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.646]                 open = "w")
[17:02:55.646]         }
[17:02:55.646]         else {
[17:02:55.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.646]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.646]         }
[17:02:55.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.646]             base::sink(type = "output", split = FALSE)
[17:02:55.646]             base::close(...future.stdout)
[17:02:55.646]         }, add = TRUE)
[17:02:55.646]     }
[17:02:55.646]     ...future.frame <- base::sys.nframe()
[17:02:55.646]     ...future.conditions <- base::list()
[17:02:55.646]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.646]     if (FALSE) {
[17:02:55.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.646]     }
[17:02:55.646]     ...future.result <- base::tryCatch({
[17:02:55.646]         base::withCallingHandlers({
[17:02:55.646]             ...future.value <- base::withVisible(base::local({
[17:02:55.646]                 ...future.makeSendCondition <- base::local({
[17:02:55.646]                   sendCondition <- NULL
[17:02:55.646]                   function(frame = 1L) {
[17:02:55.646]                     if (is.function(sendCondition)) 
[17:02:55.646]                       return(sendCondition)
[17:02:55.646]                     ns <- getNamespace("parallel")
[17:02:55.646]                     if (exists("sendData", mode = "function", 
[17:02:55.646]                       envir = ns)) {
[17:02:55.646]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.646]                         envir = ns)
[17:02:55.646]                       envir <- sys.frame(frame)
[17:02:55.646]                       master <- NULL
[17:02:55.646]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.646]                         !identical(envir, emptyenv())) {
[17:02:55.646]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.646]                           inherits = FALSE)) {
[17:02:55.646]                           master <- get("master", mode = "list", 
[17:02:55.646]                             envir = envir, inherits = FALSE)
[17:02:55.646]                           if (inherits(master, c("SOCKnode", 
[17:02:55.646]                             "SOCK0node"))) {
[17:02:55.646]                             sendCondition <<- function(cond) {
[17:02:55.646]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.646]                                 success = TRUE)
[17:02:55.646]                               parallel_sendData(master, data)
[17:02:55.646]                             }
[17:02:55.646]                             return(sendCondition)
[17:02:55.646]                           }
[17:02:55.646]                         }
[17:02:55.646]                         frame <- frame + 1L
[17:02:55.646]                         envir <- sys.frame(frame)
[17:02:55.646]                       }
[17:02:55.646]                     }
[17:02:55.646]                     sendCondition <<- function(cond) NULL
[17:02:55.646]                   }
[17:02:55.646]                 })
[17:02:55.646]                 withCallingHandlers({
[17:02:55.646]                   1
[17:02:55.646]                 }, immediateCondition = function(cond) {
[17:02:55.646]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.646]                   sendCondition(cond)
[17:02:55.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.646]                   {
[17:02:55.646]                     inherits <- base::inherits
[17:02:55.646]                     invokeRestart <- base::invokeRestart
[17:02:55.646]                     is.null <- base::is.null
[17:02:55.646]                     muffled <- FALSE
[17:02:55.646]                     if (inherits(cond, "message")) {
[17:02:55.646]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.646]                       if (muffled) 
[17:02:55.646]                         invokeRestart("muffleMessage")
[17:02:55.646]                     }
[17:02:55.646]                     else if (inherits(cond, "warning")) {
[17:02:55.646]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.646]                       if (muffled) 
[17:02:55.646]                         invokeRestart("muffleWarning")
[17:02:55.646]                     }
[17:02:55.646]                     else if (inherits(cond, "condition")) {
[17:02:55.646]                       if (!is.null(pattern)) {
[17:02:55.646]                         computeRestarts <- base::computeRestarts
[17:02:55.646]                         grepl <- base::grepl
[17:02:55.646]                         restarts <- computeRestarts(cond)
[17:02:55.646]                         for (restart in restarts) {
[17:02:55.646]                           name <- restart$name
[17:02:55.646]                           if (is.null(name)) 
[17:02:55.646]                             next
[17:02:55.646]                           if (!grepl(pattern, name)) 
[17:02:55.646]                             next
[17:02:55.646]                           invokeRestart(restart)
[17:02:55.646]                           muffled <- TRUE
[17:02:55.646]                           break
[17:02:55.646]                         }
[17:02:55.646]                       }
[17:02:55.646]                     }
[17:02:55.646]                     invisible(muffled)
[17:02:55.646]                   }
[17:02:55.646]                   muffleCondition(cond)
[17:02:55.646]                 })
[17:02:55.646]             }))
[17:02:55.646]             future::FutureResult(value = ...future.value$value, 
[17:02:55.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.646]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.646]                     ...future.globalenv.names))
[17:02:55.646]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.646]         }, condition = base::local({
[17:02:55.646]             c <- base::c
[17:02:55.646]             inherits <- base::inherits
[17:02:55.646]             invokeRestart <- base::invokeRestart
[17:02:55.646]             length <- base::length
[17:02:55.646]             list <- base::list
[17:02:55.646]             seq.int <- base::seq.int
[17:02:55.646]             signalCondition <- base::signalCondition
[17:02:55.646]             sys.calls <- base::sys.calls
[17:02:55.646]             `[[` <- base::`[[`
[17:02:55.646]             `+` <- base::`+`
[17:02:55.646]             `<<-` <- base::`<<-`
[17:02:55.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.646]                   3L)]
[17:02:55.646]             }
[17:02:55.646]             function(cond) {
[17:02:55.646]                 is_error <- inherits(cond, "error")
[17:02:55.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.646]                   NULL)
[17:02:55.646]                 if (is_error) {
[17:02:55.646]                   sessionInformation <- function() {
[17:02:55.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.646]                       search = base::search(), system = base::Sys.info())
[17:02:55.646]                   }
[17:02:55.646]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.646]                     cond$call), session = sessionInformation(), 
[17:02:55.646]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.646]                   signalCondition(cond)
[17:02:55.646]                 }
[17:02:55.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.646]                 "immediateCondition"))) {
[17:02:55.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.646]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.646]                   if (TRUE && !signal) {
[17:02:55.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.646]                     {
[17:02:55.646]                       inherits <- base::inherits
[17:02:55.646]                       invokeRestart <- base::invokeRestart
[17:02:55.646]                       is.null <- base::is.null
[17:02:55.646]                       muffled <- FALSE
[17:02:55.646]                       if (inherits(cond, "message")) {
[17:02:55.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.646]                         if (muffled) 
[17:02:55.646]                           invokeRestart("muffleMessage")
[17:02:55.646]                       }
[17:02:55.646]                       else if (inherits(cond, "warning")) {
[17:02:55.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.646]                         if (muffled) 
[17:02:55.646]                           invokeRestart("muffleWarning")
[17:02:55.646]                       }
[17:02:55.646]                       else if (inherits(cond, "condition")) {
[17:02:55.646]                         if (!is.null(pattern)) {
[17:02:55.646]                           computeRestarts <- base::computeRestarts
[17:02:55.646]                           grepl <- base::grepl
[17:02:55.646]                           restarts <- computeRestarts(cond)
[17:02:55.646]                           for (restart in restarts) {
[17:02:55.646]                             name <- restart$name
[17:02:55.646]                             if (is.null(name)) 
[17:02:55.646]                               next
[17:02:55.646]                             if (!grepl(pattern, name)) 
[17:02:55.646]                               next
[17:02:55.646]                             invokeRestart(restart)
[17:02:55.646]                             muffled <- TRUE
[17:02:55.646]                             break
[17:02:55.646]                           }
[17:02:55.646]                         }
[17:02:55.646]                       }
[17:02:55.646]                       invisible(muffled)
[17:02:55.646]                     }
[17:02:55.646]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.646]                   }
[17:02:55.646]                 }
[17:02:55.646]                 else {
[17:02:55.646]                   if (TRUE) {
[17:02:55.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.646]                     {
[17:02:55.646]                       inherits <- base::inherits
[17:02:55.646]                       invokeRestart <- base::invokeRestart
[17:02:55.646]                       is.null <- base::is.null
[17:02:55.646]                       muffled <- FALSE
[17:02:55.646]                       if (inherits(cond, "message")) {
[17:02:55.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.646]                         if (muffled) 
[17:02:55.646]                           invokeRestart("muffleMessage")
[17:02:55.646]                       }
[17:02:55.646]                       else if (inherits(cond, "warning")) {
[17:02:55.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.646]                         if (muffled) 
[17:02:55.646]                           invokeRestart("muffleWarning")
[17:02:55.646]                       }
[17:02:55.646]                       else if (inherits(cond, "condition")) {
[17:02:55.646]                         if (!is.null(pattern)) {
[17:02:55.646]                           computeRestarts <- base::computeRestarts
[17:02:55.646]                           grepl <- base::grepl
[17:02:55.646]                           restarts <- computeRestarts(cond)
[17:02:55.646]                           for (restart in restarts) {
[17:02:55.646]                             name <- restart$name
[17:02:55.646]                             if (is.null(name)) 
[17:02:55.646]                               next
[17:02:55.646]                             if (!grepl(pattern, name)) 
[17:02:55.646]                               next
[17:02:55.646]                             invokeRestart(restart)
[17:02:55.646]                             muffled <- TRUE
[17:02:55.646]                             break
[17:02:55.646]                           }
[17:02:55.646]                         }
[17:02:55.646]                       }
[17:02:55.646]                       invisible(muffled)
[17:02:55.646]                     }
[17:02:55.646]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.646]                   }
[17:02:55.646]                 }
[17:02:55.646]             }
[17:02:55.646]         }))
[17:02:55.646]     }, error = function(ex) {
[17:02:55.646]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.646]                 ...future.rng), started = ...future.startTime, 
[17:02:55.646]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.646]             version = "1.8"), class = "FutureResult")
[17:02:55.646]     }, finally = {
[17:02:55.646]         if (!identical(...future.workdir, getwd())) 
[17:02:55.646]             setwd(...future.workdir)
[17:02:55.646]         {
[17:02:55.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.646]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.646]             }
[17:02:55.646]             base::options(...future.oldOptions)
[17:02:55.646]             if (.Platform$OS.type == "windows") {
[17:02:55.646]                 old_names <- names(...future.oldEnvVars)
[17:02:55.646]                 envs <- base::Sys.getenv()
[17:02:55.646]                 names <- names(envs)
[17:02:55.646]                 common <- intersect(names, old_names)
[17:02:55.646]                 added <- setdiff(names, old_names)
[17:02:55.646]                 removed <- setdiff(old_names, names)
[17:02:55.646]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.646]                   envs[common]]
[17:02:55.646]                 NAMES <- toupper(changed)
[17:02:55.646]                 args <- list()
[17:02:55.646]                 for (kk in seq_along(NAMES)) {
[17:02:55.646]                   name <- changed[[kk]]
[17:02:55.646]                   NAME <- NAMES[[kk]]
[17:02:55.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.646]                     next
[17:02:55.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.646]                 }
[17:02:55.646]                 NAMES <- toupper(added)
[17:02:55.646]                 for (kk in seq_along(NAMES)) {
[17:02:55.646]                   name <- added[[kk]]
[17:02:55.646]                   NAME <- NAMES[[kk]]
[17:02:55.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.646]                     next
[17:02:55.646]                   args[[name]] <- ""
[17:02:55.646]                 }
[17:02:55.646]                 NAMES <- toupper(removed)
[17:02:55.646]                 for (kk in seq_along(NAMES)) {
[17:02:55.646]                   name <- removed[[kk]]
[17:02:55.646]                   NAME <- NAMES[[kk]]
[17:02:55.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.646]                     next
[17:02:55.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.646]                 }
[17:02:55.646]                 if (length(args) > 0) 
[17:02:55.646]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.646]             }
[17:02:55.646]             else {
[17:02:55.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.646]             }
[17:02:55.646]             {
[17:02:55.646]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.646]                   0L) {
[17:02:55.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.646]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.646]                   base::options(opts)
[17:02:55.646]                 }
[17:02:55.646]                 {
[17:02:55.646]                   {
[17:02:55.646]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.646]                     NULL
[17:02:55.646]                   }
[17:02:55.646]                   options(future.plan = NULL)
[17:02:55.646]                   if (is.na(NA_character_)) 
[17:02:55.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.646]                     .init = FALSE)
[17:02:55.646]                 }
[17:02:55.646]             }
[17:02:55.646]         }
[17:02:55.646]     })
[17:02:55.646]     if (TRUE) {
[17:02:55.646]         base::sink(type = "output", split = FALSE)
[17:02:55.646]         if (TRUE) {
[17:02:55.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.646]         }
[17:02:55.646]         else {
[17:02:55.646]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.646]         }
[17:02:55.646]         base::close(...future.stdout)
[17:02:55.646]         ...future.stdout <- NULL
[17:02:55.646]     }
[17:02:55.646]     ...future.result$conditions <- ...future.conditions
[17:02:55.646]     ...future.result$finished <- base::Sys.time()
[17:02:55.646]     ...future.result
[17:02:55.646] }
[17:02:55.649] MultisessionFuture started
[17:02:55.649] - Launch lazy future ... done
[17:02:55.649] run() for ‘MultisessionFuture’ ... done
[17:02:55.693] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.693] - Validating connection of MultisessionFuture
[17:02:55.694] - received message: FutureResult
[17:02:55.694] - Received FutureResult
[17:02:55.694] - Erased future from FutureRegistry
[17:02:55.694] result() for ClusterFuture ...
[17:02:55.694] - result already collected: FutureResult
[17:02:55.694] result() for ClusterFuture ... done
[17:02:55.694] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.694] Future #1
[17:02:55.694] result() for ClusterFuture ...
[17:02:55.694] - result already collected: FutureResult
[17:02:55.695] result() for ClusterFuture ... done
[17:02:55.695] result() for ClusterFuture ...
[17:02:55.695] - result already collected: FutureResult
[17:02:55.695] result() for ClusterFuture ... done
[17:02:55.695] A MultisessionFuture was resolved
[17:02:55.695]  length: 0 (resolved future 1)
[17:02:55.695] resolve() on list ... DONE
[17:02:55.695] - globals: [1] ‘a’
[17:02:55.695] Resolving futures part of globals (recursively) ... DONE
[17:02:55.697] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[17:02:55.698] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:02:55.698] - globals: [1] ‘a’
[17:02:55.698] - packages: [1] ‘future’
[17:02:55.698] getGlobalsAndPackages() ... DONE
[17:02:55.698] run() for ‘Future’ ...
[17:02:55.699] - state: ‘created’
[17:02:55.699] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.713] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.713]   - Field: ‘node’
[17:02:55.714]   - Field: ‘label’
[17:02:55.714]   - Field: ‘local’
[17:02:55.714]   - Field: ‘owner’
[17:02:55.714]   - Field: ‘envir’
[17:02:55.714]   - Field: ‘workers’
[17:02:55.714]   - Field: ‘packages’
[17:02:55.714]   - Field: ‘gc’
[17:02:55.714]   - Field: ‘conditions’
[17:02:55.714]   - Field: ‘persistent’
[17:02:55.714]   - Field: ‘expr’
[17:02:55.714]   - Field: ‘uuid’
[17:02:55.715]   - Field: ‘seed’
[17:02:55.715]   - Field: ‘version’
[17:02:55.715]   - Field: ‘result’
[17:02:55.715]   - Field: ‘asynchronous’
[17:02:55.715]   - Field: ‘calls’
[17:02:55.715]   - Field: ‘globals’
[17:02:55.715]   - Field: ‘stdout’
[17:02:55.715]   - Field: ‘earlySignal’
[17:02:55.715]   - Field: ‘lazy’
[17:02:55.715]   - Field: ‘state’
[17:02:55.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.716] - Launch lazy future ...
[17:02:55.716] Packages needed by the future expression (n = 1): ‘future’
[17:02:55.716] Packages needed by future strategies (n = 0): <none>
[17:02:55.717] {
[17:02:55.717]     {
[17:02:55.717]         {
[17:02:55.717]             ...future.startTime <- base::Sys.time()
[17:02:55.717]             {
[17:02:55.717]                 {
[17:02:55.717]                   {
[17:02:55.717]                     {
[17:02:55.717]                       {
[17:02:55.717]                         base::local({
[17:02:55.717]                           has_future <- base::requireNamespace("future", 
[17:02:55.717]                             quietly = TRUE)
[17:02:55.717]                           if (has_future) {
[17:02:55.717]                             ns <- base::getNamespace("future")
[17:02:55.717]                             version <- ns[[".package"]][["version"]]
[17:02:55.717]                             if (is.null(version)) 
[17:02:55.717]                               version <- utils::packageVersion("future")
[17:02:55.717]                           }
[17:02:55.717]                           else {
[17:02:55.717]                             version <- NULL
[17:02:55.717]                           }
[17:02:55.717]                           if (!has_future || version < "1.8.0") {
[17:02:55.717]                             info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.717]                               "", base::R.version$version.string), 
[17:02:55.717]                               platform = base::sprintf("%s (%s-bit)", 
[17:02:55.717]                                 base::R.version$platform, 8 * 
[17:02:55.717]                                   base::.Machine$sizeof.pointer), 
[17:02:55.717]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.717]                                 "release", "version")], collapse = " "), 
[17:02:55.717]                               hostname = base::Sys.info()[["nodename"]])
[17:02:55.717]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.717]                               info)
[17:02:55.717]                             info <- base::paste(info, collapse = "; ")
[17:02:55.717]                             if (!has_future) {
[17:02:55.717]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.717]                                 info)
[17:02:55.717]                             }
[17:02:55.717]                             else {
[17:02:55.717]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.717]                                 info, version)
[17:02:55.717]                             }
[17:02:55.717]                             base::stop(msg)
[17:02:55.717]                           }
[17:02:55.717]                         })
[17:02:55.717]                       }
[17:02:55.717]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.717]                       base::options(mc.cores = 1L)
[17:02:55.717]                     }
[17:02:55.717]                     base::local({
[17:02:55.717]                       for (pkg in "future") {
[17:02:55.717]                         base::loadNamespace(pkg)
[17:02:55.717]                         base::library(pkg, character.only = TRUE)
[17:02:55.717]                       }
[17:02:55.717]                     })
[17:02:55.717]                   }
[17:02:55.717]                   ...future.strategy.old <- future::plan("list")
[17:02:55.717]                   options(future.plan = NULL)
[17:02:55.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.717]                 }
[17:02:55.717]                 ...future.workdir <- getwd()
[17:02:55.717]             }
[17:02:55.717]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.717]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.717]         }
[17:02:55.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.717]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.717]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.717]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.717]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.717]             base::names(...future.oldOptions))
[17:02:55.717]     }
[17:02:55.717]     if (FALSE) {
[17:02:55.717]     }
[17:02:55.717]     else {
[17:02:55.717]         if (TRUE) {
[17:02:55.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.717]                 open = "w")
[17:02:55.717]         }
[17:02:55.717]         else {
[17:02:55.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.717]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.717]         }
[17:02:55.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.717]             base::sink(type = "output", split = FALSE)
[17:02:55.717]             base::close(...future.stdout)
[17:02:55.717]         }, add = TRUE)
[17:02:55.717]     }
[17:02:55.717]     ...future.frame <- base::sys.nframe()
[17:02:55.717]     ...future.conditions <- base::list()
[17:02:55.717]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.717]     if (FALSE) {
[17:02:55.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.717]     }
[17:02:55.717]     ...future.result <- base::tryCatch({
[17:02:55.717]         base::withCallingHandlers({
[17:02:55.717]             ...future.value <- base::withVisible(base::local({
[17:02:55.717]                 ...future.makeSendCondition <- base::local({
[17:02:55.717]                   sendCondition <- NULL
[17:02:55.717]                   function(frame = 1L) {
[17:02:55.717]                     if (is.function(sendCondition)) 
[17:02:55.717]                       return(sendCondition)
[17:02:55.717]                     ns <- getNamespace("parallel")
[17:02:55.717]                     if (exists("sendData", mode = "function", 
[17:02:55.717]                       envir = ns)) {
[17:02:55.717]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.717]                         envir = ns)
[17:02:55.717]                       envir <- sys.frame(frame)
[17:02:55.717]                       master <- NULL
[17:02:55.717]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.717]                         !identical(envir, emptyenv())) {
[17:02:55.717]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.717]                           inherits = FALSE)) {
[17:02:55.717]                           master <- get("master", mode = "list", 
[17:02:55.717]                             envir = envir, inherits = FALSE)
[17:02:55.717]                           if (inherits(master, c("SOCKnode", 
[17:02:55.717]                             "SOCK0node"))) {
[17:02:55.717]                             sendCondition <<- function(cond) {
[17:02:55.717]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.717]                                 success = TRUE)
[17:02:55.717]                               parallel_sendData(master, data)
[17:02:55.717]                             }
[17:02:55.717]                             return(sendCondition)
[17:02:55.717]                           }
[17:02:55.717]                         }
[17:02:55.717]                         frame <- frame + 1L
[17:02:55.717]                         envir <- sys.frame(frame)
[17:02:55.717]                       }
[17:02:55.717]                     }
[17:02:55.717]                     sendCondition <<- function(cond) NULL
[17:02:55.717]                   }
[17:02:55.717]                 })
[17:02:55.717]                 withCallingHandlers({
[17:02:55.717]                   value(a) + 1
[17:02:55.717]                 }, immediateCondition = function(cond) {
[17:02:55.717]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.717]                   sendCondition(cond)
[17:02:55.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.717]                   {
[17:02:55.717]                     inherits <- base::inherits
[17:02:55.717]                     invokeRestart <- base::invokeRestart
[17:02:55.717]                     is.null <- base::is.null
[17:02:55.717]                     muffled <- FALSE
[17:02:55.717]                     if (inherits(cond, "message")) {
[17:02:55.717]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.717]                       if (muffled) 
[17:02:55.717]                         invokeRestart("muffleMessage")
[17:02:55.717]                     }
[17:02:55.717]                     else if (inherits(cond, "warning")) {
[17:02:55.717]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.717]                       if (muffled) 
[17:02:55.717]                         invokeRestart("muffleWarning")
[17:02:55.717]                     }
[17:02:55.717]                     else if (inherits(cond, "condition")) {
[17:02:55.717]                       if (!is.null(pattern)) {
[17:02:55.717]                         computeRestarts <- base::computeRestarts
[17:02:55.717]                         grepl <- base::grepl
[17:02:55.717]                         restarts <- computeRestarts(cond)
[17:02:55.717]                         for (restart in restarts) {
[17:02:55.717]                           name <- restart$name
[17:02:55.717]                           if (is.null(name)) 
[17:02:55.717]                             next
[17:02:55.717]                           if (!grepl(pattern, name)) 
[17:02:55.717]                             next
[17:02:55.717]                           invokeRestart(restart)
[17:02:55.717]                           muffled <- TRUE
[17:02:55.717]                           break
[17:02:55.717]                         }
[17:02:55.717]                       }
[17:02:55.717]                     }
[17:02:55.717]                     invisible(muffled)
[17:02:55.717]                   }
[17:02:55.717]                   muffleCondition(cond)
[17:02:55.717]                 })
[17:02:55.717]             }))
[17:02:55.717]             future::FutureResult(value = ...future.value$value, 
[17:02:55.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.717]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.717]                     ...future.globalenv.names))
[17:02:55.717]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.717]         }, condition = base::local({
[17:02:55.717]             c <- base::c
[17:02:55.717]             inherits <- base::inherits
[17:02:55.717]             invokeRestart <- base::invokeRestart
[17:02:55.717]             length <- base::length
[17:02:55.717]             list <- base::list
[17:02:55.717]             seq.int <- base::seq.int
[17:02:55.717]             signalCondition <- base::signalCondition
[17:02:55.717]             sys.calls <- base::sys.calls
[17:02:55.717]             `[[` <- base::`[[`
[17:02:55.717]             `+` <- base::`+`
[17:02:55.717]             `<<-` <- base::`<<-`
[17:02:55.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.717]                   3L)]
[17:02:55.717]             }
[17:02:55.717]             function(cond) {
[17:02:55.717]                 is_error <- inherits(cond, "error")
[17:02:55.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.717]                   NULL)
[17:02:55.717]                 if (is_error) {
[17:02:55.717]                   sessionInformation <- function() {
[17:02:55.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.717]                       search = base::search(), system = base::Sys.info())
[17:02:55.717]                   }
[17:02:55.717]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.717]                     cond$call), session = sessionInformation(), 
[17:02:55.717]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.717]                   signalCondition(cond)
[17:02:55.717]                 }
[17:02:55.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.717]                 "immediateCondition"))) {
[17:02:55.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.717]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.717]                   if (TRUE && !signal) {
[17:02:55.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.717]                     {
[17:02:55.717]                       inherits <- base::inherits
[17:02:55.717]                       invokeRestart <- base::invokeRestart
[17:02:55.717]                       is.null <- base::is.null
[17:02:55.717]                       muffled <- FALSE
[17:02:55.717]                       if (inherits(cond, "message")) {
[17:02:55.717]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.717]                         if (muffled) 
[17:02:55.717]                           invokeRestart("muffleMessage")
[17:02:55.717]                       }
[17:02:55.717]                       else if (inherits(cond, "warning")) {
[17:02:55.717]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.717]                         if (muffled) 
[17:02:55.717]                           invokeRestart("muffleWarning")
[17:02:55.717]                       }
[17:02:55.717]                       else if (inherits(cond, "condition")) {
[17:02:55.717]                         if (!is.null(pattern)) {
[17:02:55.717]                           computeRestarts <- base::computeRestarts
[17:02:55.717]                           grepl <- base::grepl
[17:02:55.717]                           restarts <- computeRestarts(cond)
[17:02:55.717]                           for (restart in restarts) {
[17:02:55.717]                             name <- restart$name
[17:02:55.717]                             if (is.null(name)) 
[17:02:55.717]                               next
[17:02:55.717]                             if (!grepl(pattern, name)) 
[17:02:55.717]                               next
[17:02:55.717]                             invokeRestart(restart)
[17:02:55.717]                             muffled <- TRUE
[17:02:55.717]                             break
[17:02:55.717]                           }
[17:02:55.717]                         }
[17:02:55.717]                       }
[17:02:55.717]                       invisible(muffled)
[17:02:55.717]                     }
[17:02:55.717]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.717]                   }
[17:02:55.717]                 }
[17:02:55.717]                 else {
[17:02:55.717]                   if (TRUE) {
[17:02:55.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.717]                     {
[17:02:55.717]                       inherits <- base::inherits
[17:02:55.717]                       invokeRestart <- base::invokeRestart
[17:02:55.717]                       is.null <- base::is.null
[17:02:55.717]                       muffled <- FALSE
[17:02:55.717]                       if (inherits(cond, "message")) {
[17:02:55.717]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.717]                         if (muffled) 
[17:02:55.717]                           invokeRestart("muffleMessage")
[17:02:55.717]                       }
[17:02:55.717]                       else if (inherits(cond, "warning")) {
[17:02:55.717]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.717]                         if (muffled) 
[17:02:55.717]                           invokeRestart("muffleWarning")
[17:02:55.717]                       }
[17:02:55.717]                       else if (inherits(cond, "condition")) {
[17:02:55.717]                         if (!is.null(pattern)) {
[17:02:55.717]                           computeRestarts <- base::computeRestarts
[17:02:55.717]                           grepl <- base::grepl
[17:02:55.717]                           restarts <- computeRestarts(cond)
[17:02:55.717]                           for (restart in restarts) {
[17:02:55.717]                             name <- restart$name
[17:02:55.717]                             if (is.null(name)) 
[17:02:55.717]                               next
[17:02:55.717]                             if (!grepl(pattern, name)) 
[17:02:55.717]                               next
[17:02:55.717]                             invokeRestart(restart)
[17:02:55.717]                             muffled <- TRUE
[17:02:55.717]                             break
[17:02:55.717]                           }
[17:02:55.717]                         }
[17:02:55.717]                       }
[17:02:55.717]                       invisible(muffled)
[17:02:55.717]                     }
[17:02:55.717]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.717]                   }
[17:02:55.717]                 }
[17:02:55.717]             }
[17:02:55.717]         }))
[17:02:55.717]     }, error = function(ex) {
[17:02:55.717]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.717]                 ...future.rng), started = ...future.startTime, 
[17:02:55.717]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.717]             version = "1.8"), class = "FutureResult")
[17:02:55.717]     }, finally = {
[17:02:55.717]         if (!identical(...future.workdir, getwd())) 
[17:02:55.717]             setwd(...future.workdir)
[17:02:55.717]         {
[17:02:55.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.717]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.717]             }
[17:02:55.717]             base::options(...future.oldOptions)
[17:02:55.717]             if (.Platform$OS.type == "windows") {
[17:02:55.717]                 old_names <- names(...future.oldEnvVars)
[17:02:55.717]                 envs <- base::Sys.getenv()
[17:02:55.717]                 names <- names(envs)
[17:02:55.717]                 common <- intersect(names, old_names)
[17:02:55.717]                 added <- setdiff(names, old_names)
[17:02:55.717]                 removed <- setdiff(old_names, names)
[17:02:55.717]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.717]                   envs[common]]
[17:02:55.717]                 NAMES <- toupper(changed)
[17:02:55.717]                 args <- list()
[17:02:55.717]                 for (kk in seq_along(NAMES)) {
[17:02:55.717]                   name <- changed[[kk]]
[17:02:55.717]                   NAME <- NAMES[[kk]]
[17:02:55.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.717]                     next
[17:02:55.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.717]                 }
[17:02:55.717]                 NAMES <- toupper(added)
[17:02:55.717]                 for (kk in seq_along(NAMES)) {
[17:02:55.717]                   name <- added[[kk]]
[17:02:55.717]                   NAME <- NAMES[[kk]]
[17:02:55.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.717]                     next
[17:02:55.717]                   args[[name]] <- ""
[17:02:55.717]                 }
[17:02:55.717]                 NAMES <- toupper(removed)
[17:02:55.717]                 for (kk in seq_along(NAMES)) {
[17:02:55.717]                   name <- removed[[kk]]
[17:02:55.717]                   NAME <- NAMES[[kk]]
[17:02:55.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.717]                     next
[17:02:55.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.717]                 }
[17:02:55.717]                 if (length(args) > 0) 
[17:02:55.717]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.717]             }
[17:02:55.717]             else {
[17:02:55.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.717]             }
[17:02:55.717]             {
[17:02:55.717]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.717]                   0L) {
[17:02:55.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.717]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.717]                   base::options(opts)
[17:02:55.717]                 }
[17:02:55.717]                 {
[17:02:55.717]                   {
[17:02:55.717]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.717]                     NULL
[17:02:55.717]                   }
[17:02:55.717]                   options(future.plan = NULL)
[17:02:55.717]                   if (is.na(NA_character_)) 
[17:02:55.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.717]                     .init = FALSE)
[17:02:55.717]                 }
[17:02:55.717]             }
[17:02:55.717]         }
[17:02:55.717]     })
[17:02:55.717]     if (TRUE) {
[17:02:55.717]         base::sink(type = "output", split = FALSE)
[17:02:55.717]         if (TRUE) {
[17:02:55.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.717]         }
[17:02:55.717]         else {
[17:02:55.717]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.717]         }
[17:02:55.717]         base::close(...future.stdout)
[17:02:55.717]         ...future.stdout <- NULL
[17:02:55.717]     }
[17:02:55.717]     ...future.result$conditions <- ...future.conditions
[17:02:55.717]     ...future.result$finished <- base::Sys.time()
[17:02:55.717]     ...future.result
[17:02:55.717] }
[17:02:55.719] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:02:55.721] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:02:55.772] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.772] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:02:55.775] MultisessionFuture started
[17:02:55.775] - Launch lazy future ... done
[17:02:55.775] run() for ‘MultisessionFuture’ ... done
[17:02:55.775] result() for ClusterFuture ...
[17:02:55.775] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.776] - Validating connection of MultisessionFuture
[17:02:55.818] - received message: FutureResult
[17:02:55.818] - Received FutureResult
[17:02:55.818] - Erased future from FutureRegistry
[17:02:55.818] result() for ClusterFuture ...
[17:02:55.818] - result already collected: FutureResult
[17:02:55.818] result() for ClusterFuture ... done
[17:02:55.818] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.818] result() for ClusterFuture ... done
[17:02:55.818] result() for ClusterFuture ...
[17:02:55.819] - result already collected: FutureResult
[17:02:55.819] result() for ClusterFuture ... done
value(b) = 2
[17:02:55.819] result() for ClusterFuture ...
[17:02:55.819] - result already collected: FutureResult
[17:02:55.819] result() for ClusterFuture ... done
[17:02:55.819] result() for ClusterFuture ...
[17:02:55.819] - result already collected: FutureResult
[17:02:55.819] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.820] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.820] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.821] - globals found: [2] ‘{’, ‘pkg’
[17:02:55.821] Searching for globals ... DONE
[17:02:55.821] Resolving globals: TRUE
[17:02:55.821] Resolving any globals that are futures ...
[17:02:55.821] - globals: [2] ‘{’, ‘pkg’
[17:02:55.821] Resolving any globals that are futures ... DONE
[17:02:55.821] Resolving futures part of globals (recursively) ...
[17:02:55.822] resolve() on list ...
[17:02:55.822]  recursive: 99
[17:02:55.822]  length: 1
[17:02:55.822]  elements: ‘pkg’
[17:02:55.822]  length: 0 (resolved future 1)
[17:02:55.822] resolve() on list ... DONE
[17:02:55.822] - globals: [1] ‘pkg’
[17:02:55.822] Resolving futures part of globals (recursively) ... DONE
[17:02:55.822] The total size of the 1 globals is 112 bytes (112 bytes)
[17:02:55.823] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:02:55.823] - globals: [1] ‘pkg’
[17:02:55.823] 
[17:02:55.823] getGlobalsAndPackages() ... DONE
[17:02:55.823] Packages needed by the future expression (n = 0): <none>
[17:02:55.823] Packages needed by future strategies (n = 0): <none>
[17:02:55.824] {
[17:02:55.824]     {
[17:02:55.824]         {
[17:02:55.824]             ...future.startTime <- base::Sys.time()
[17:02:55.824]             {
[17:02:55.824]                 {
[17:02:55.824]                   {
[17:02:55.824]                     base::local({
[17:02:55.824]                       has_future <- base::requireNamespace("future", 
[17:02:55.824]                         quietly = TRUE)
[17:02:55.824]                       if (has_future) {
[17:02:55.824]                         ns <- base::getNamespace("future")
[17:02:55.824]                         version <- ns[[".package"]][["version"]]
[17:02:55.824]                         if (is.null(version)) 
[17:02:55.824]                           version <- utils::packageVersion("future")
[17:02:55.824]                       }
[17:02:55.824]                       else {
[17:02:55.824]                         version <- NULL
[17:02:55.824]                       }
[17:02:55.824]                       if (!has_future || version < "1.8.0") {
[17:02:55.824]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.824]                           "", base::R.version$version.string), 
[17:02:55.824]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:55.824]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.824]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.824]                             "release", "version")], collapse = " "), 
[17:02:55.824]                           hostname = base::Sys.info()[["nodename"]])
[17:02:55.824]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.824]                           info)
[17:02:55.824]                         info <- base::paste(info, collapse = "; ")
[17:02:55.824]                         if (!has_future) {
[17:02:55.824]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.824]                             info)
[17:02:55.824]                         }
[17:02:55.824]                         else {
[17:02:55.824]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.824]                             info, version)
[17:02:55.824]                         }
[17:02:55.824]                         base::stop(msg)
[17:02:55.824]                       }
[17:02:55.824]                     })
[17:02:55.824]                   }
[17:02:55.824]                   ...future.strategy.old <- future::plan("list")
[17:02:55.824]                   options(future.plan = NULL)
[17:02:55.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.824]                 }
[17:02:55.824]                 ...future.workdir <- getwd()
[17:02:55.824]             }
[17:02:55.824]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.824]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.824]         }
[17:02:55.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.824]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.824]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.824]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.824]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.824]             base::names(...future.oldOptions))
[17:02:55.824]     }
[17:02:55.824]     if (FALSE) {
[17:02:55.824]     }
[17:02:55.824]     else {
[17:02:55.824]         if (TRUE) {
[17:02:55.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.824]                 open = "w")
[17:02:55.824]         }
[17:02:55.824]         else {
[17:02:55.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.824]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.824]         }
[17:02:55.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.824]             base::sink(type = "output", split = FALSE)
[17:02:55.824]             base::close(...future.stdout)
[17:02:55.824]         }, add = TRUE)
[17:02:55.824]     }
[17:02:55.824]     ...future.frame <- base::sys.nframe()
[17:02:55.824]     ...future.conditions <- base::list()
[17:02:55.824]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.824]     if (FALSE) {
[17:02:55.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.824]     }
[17:02:55.824]     ...future.result <- base::tryCatch({
[17:02:55.824]         base::withCallingHandlers({
[17:02:55.824]             ...future.value <- base::withVisible(base::local({
[17:02:55.824]                 pkg
[17:02:55.824]             }))
[17:02:55.824]             future::FutureResult(value = ...future.value$value, 
[17:02:55.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.824]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.824]                     ...future.globalenv.names))
[17:02:55.824]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.824]         }, condition = base::local({
[17:02:55.824]             c <- base::c
[17:02:55.824]             inherits <- base::inherits
[17:02:55.824]             invokeRestart <- base::invokeRestart
[17:02:55.824]             length <- base::length
[17:02:55.824]             list <- base::list
[17:02:55.824]             seq.int <- base::seq.int
[17:02:55.824]             signalCondition <- base::signalCondition
[17:02:55.824]             sys.calls <- base::sys.calls
[17:02:55.824]             `[[` <- base::`[[`
[17:02:55.824]             `+` <- base::`+`
[17:02:55.824]             `<<-` <- base::`<<-`
[17:02:55.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.824]                   3L)]
[17:02:55.824]             }
[17:02:55.824]             function(cond) {
[17:02:55.824]                 is_error <- inherits(cond, "error")
[17:02:55.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.824]                   NULL)
[17:02:55.824]                 if (is_error) {
[17:02:55.824]                   sessionInformation <- function() {
[17:02:55.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.824]                       search = base::search(), system = base::Sys.info())
[17:02:55.824]                   }
[17:02:55.824]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.824]                     cond$call), session = sessionInformation(), 
[17:02:55.824]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.824]                   signalCondition(cond)
[17:02:55.824]                 }
[17:02:55.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.824]                 "immediateCondition"))) {
[17:02:55.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.824]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.824]                   if (TRUE && !signal) {
[17:02:55.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.824]                     {
[17:02:55.824]                       inherits <- base::inherits
[17:02:55.824]                       invokeRestart <- base::invokeRestart
[17:02:55.824]                       is.null <- base::is.null
[17:02:55.824]                       muffled <- FALSE
[17:02:55.824]                       if (inherits(cond, "message")) {
[17:02:55.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.824]                         if (muffled) 
[17:02:55.824]                           invokeRestart("muffleMessage")
[17:02:55.824]                       }
[17:02:55.824]                       else if (inherits(cond, "warning")) {
[17:02:55.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.824]                         if (muffled) 
[17:02:55.824]                           invokeRestart("muffleWarning")
[17:02:55.824]                       }
[17:02:55.824]                       else if (inherits(cond, "condition")) {
[17:02:55.824]                         if (!is.null(pattern)) {
[17:02:55.824]                           computeRestarts <- base::computeRestarts
[17:02:55.824]                           grepl <- base::grepl
[17:02:55.824]                           restarts <- computeRestarts(cond)
[17:02:55.824]                           for (restart in restarts) {
[17:02:55.824]                             name <- restart$name
[17:02:55.824]                             if (is.null(name)) 
[17:02:55.824]                               next
[17:02:55.824]                             if (!grepl(pattern, name)) 
[17:02:55.824]                               next
[17:02:55.824]                             invokeRestart(restart)
[17:02:55.824]                             muffled <- TRUE
[17:02:55.824]                             break
[17:02:55.824]                           }
[17:02:55.824]                         }
[17:02:55.824]                       }
[17:02:55.824]                       invisible(muffled)
[17:02:55.824]                     }
[17:02:55.824]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.824]                   }
[17:02:55.824]                 }
[17:02:55.824]                 else {
[17:02:55.824]                   if (TRUE) {
[17:02:55.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.824]                     {
[17:02:55.824]                       inherits <- base::inherits
[17:02:55.824]                       invokeRestart <- base::invokeRestart
[17:02:55.824]                       is.null <- base::is.null
[17:02:55.824]                       muffled <- FALSE
[17:02:55.824]                       if (inherits(cond, "message")) {
[17:02:55.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.824]                         if (muffled) 
[17:02:55.824]                           invokeRestart("muffleMessage")
[17:02:55.824]                       }
[17:02:55.824]                       else if (inherits(cond, "warning")) {
[17:02:55.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.824]                         if (muffled) 
[17:02:55.824]                           invokeRestart("muffleWarning")
[17:02:55.824]                       }
[17:02:55.824]                       else if (inherits(cond, "condition")) {
[17:02:55.824]                         if (!is.null(pattern)) {
[17:02:55.824]                           computeRestarts <- base::computeRestarts
[17:02:55.824]                           grepl <- base::grepl
[17:02:55.824]                           restarts <- computeRestarts(cond)
[17:02:55.824]                           for (restart in restarts) {
[17:02:55.824]                             name <- restart$name
[17:02:55.824]                             if (is.null(name)) 
[17:02:55.824]                               next
[17:02:55.824]                             if (!grepl(pattern, name)) 
[17:02:55.824]                               next
[17:02:55.824]                             invokeRestart(restart)
[17:02:55.824]                             muffled <- TRUE
[17:02:55.824]                             break
[17:02:55.824]                           }
[17:02:55.824]                         }
[17:02:55.824]                       }
[17:02:55.824]                       invisible(muffled)
[17:02:55.824]                     }
[17:02:55.824]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.824]                   }
[17:02:55.824]                 }
[17:02:55.824]             }
[17:02:55.824]         }))
[17:02:55.824]     }, error = function(ex) {
[17:02:55.824]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.824]                 ...future.rng), started = ...future.startTime, 
[17:02:55.824]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.824]             version = "1.8"), class = "FutureResult")
[17:02:55.824]     }, finally = {
[17:02:55.824]         if (!identical(...future.workdir, getwd())) 
[17:02:55.824]             setwd(...future.workdir)
[17:02:55.824]         {
[17:02:55.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.824]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.824]             }
[17:02:55.824]             base::options(...future.oldOptions)
[17:02:55.824]             if (.Platform$OS.type == "windows") {
[17:02:55.824]                 old_names <- names(...future.oldEnvVars)
[17:02:55.824]                 envs <- base::Sys.getenv()
[17:02:55.824]                 names <- names(envs)
[17:02:55.824]                 common <- intersect(names, old_names)
[17:02:55.824]                 added <- setdiff(names, old_names)
[17:02:55.824]                 removed <- setdiff(old_names, names)
[17:02:55.824]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.824]                   envs[common]]
[17:02:55.824]                 NAMES <- toupper(changed)
[17:02:55.824]                 args <- list()
[17:02:55.824]                 for (kk in seq_along(NAMES)) {
[17:02:55.824]                   name <- changed[[kk]]
[17:02:55.824]                   NAME <- NAMES[[kk]]
[17:02:55.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.824]                     next
[17:02:55.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.824]                 }
[17:02:55.824]                 NAMES <- toupper(added)
[17:02:55.824]                 for (kk in seq_along(NAMES)) {
[17:02:55.824]                   name <- added[[kk]]
[17:02:55.824]                   NAME <- NAMES[[kk]]
[17:02:55.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.824]                     next
[17:02:55.824]                   args[[name]] <- ""
[17:02:55.824]                 }
[17:02:55.824]                 NAMES <- toupper(removed)
[17:02:55.824]                 for (kk in seq_along(NAMES)) {
[17:02:55.824]                   name <- removed[[kk]]
[17:02:55.824]                   NAME <- NAMES[[kk]]
[17:02:55.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.824]                     next
[17:02:55.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.824]                 }
[17:02:55.824]                 if (length(args) > 0) 
[17:02:55.824]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.824]             }
[17:02:55.824]             else {
[17:02:55.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.824]             }
[17:02:55.824]             {
[17:02:55.824]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.824]                   0L) {
[17:02:55.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.824]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.824]                   base::options(opts)
[17:02:55.824]                 }
[17:02:55.824]                 {
[17:02:55.824]                   {
[17:02:55.824]                     NULL
[17:02:55.824]                     RNGkind("Mersenne-Twister")
[17:02:55.824]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:55.824]                       inherits = FALSE)
[17:02:55.824]                   }
[17:02:55.824]                   options(future.plan = NULL)
[17:02:55.824]                   if (is.na(NA_character_)) 
[17:02:55.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.824]                     .init = FALSE)
[17:02:55.824]                 }
[17:02:55.824]             }
[17:02:55.824]         }
[17:02:55.824]     })
[17:02:55.824]     if (TRUE) {
[17:02:55.824]         base::sink(type = "output", split = FALSE)
[17:02:55.824]         if (TRUE) {
[17:02:55.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.824]         }
[17:02:55.824]         else {
[17:02:55.824]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.824]         }
[17:02:55.824]         base::close(...future.stdout)
[17:02:55.824]         ...future.stdout <- NULL
[17:02:55.824]     }
[17:02:55.824]     ...future.result$conditions <- ...future.conditions
[17:02:55.824]     ...future.result$finished <- base::Sys.time()
[17:02:55.824]     ...future.result
[17:02:55.824] }
[17:02:55.826] assign_globals() ...
[17:02:55.826] List of 1
[17:02:55.826]  $ pkg: chr "foo"
[17:02:55.826]  - attr(*, "where")=List of 1
[17:02:55.826]   ..$ pkg:<environment: R_EmptyEnv> 
[17:02:55.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:55.826]  - attr(*, "resolved")= logi TRUE
[17:02:55.826]  - attr(*, "total_size")= num 112
[17:02:55.828] - copied ‘pkg’ to environment
[17:02:55.828] assign_globals() ... done
[17:02:55.828] plan(): Setting new future strategy stack:
[17:02:55.828] List of future strategies:
[17:02:55.828] 1. sequential:
[17:02:55.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:55.828]    - tweaked: FALSE
[17:02:55.828]    - call: NULL
[17:02:55.829] plan(): nbrOfWorkers() = 1
[17:02:55.829] plan(): Setting new future strategy stack:
[17:02:55.829] List of future strategies:
[17:02:55.829] 1. multisession:
[17:02:55.829]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:55.829]    - tweaked: FALSE
[17:02:55.829]    - call: plan(strategy)
[17:02:55.833] plan(): nbrOfWorkers() = 2
[17:02:55.834] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.834] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.834] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.836] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:02:55.836] Searching for globals ... DONE
[17:02:55.836] Resolving globals: TRUE
[17:02:55.837] Resolving any globals that are futures ...
[17:02:55.837] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:02:55.837] Resolving any globals that are futures ... DONE
[17:02:55.837] 
[17:02:55.837] 
[17:02:55.837] getGlobalsAndPackages() ... DONE
[17:02:55.837] run() for ‘Future’ ...
[17:02:55.838] - state: ‘created’
[17:02:55.838] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.851] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.851]   - Field: ‘node’
[17:02:55.852]   - Field: ‘label’
[17:02:55.852]   - Field: ‘local’
[17:02:55.852]   - Field: ‘owner’
[17:02:55.852]   - Field: ‘envir’
[17:02:55.852]   - Field: ‘workers’
[17:02:55.852]   - Field: ‘packages’
[17:02:55.852]   - Field: ‘gc’
[17:02:55.852]   - Field: ‘conditions’
[17:02:55.852]   - Field: ‘persistent’
[17:02:55.852]   - Field: ‘expr’
[17:02:55.852]   - Field: ‘uuid’
[17:02:55.853]   - Field: ‘seed’
[17:02:55.853]   - Field: ‘version’
[17:02:55.853]   - Field: ‘result’
[17:02:55.853]   - Field: ‘asynchronous’
[17:02:55.853]   - Field: ‘calls’
[17:02:55.853]   - Field: ‘globals’
[17:02:55.853]   - Field: ‘stdout’
[17:02:55.853]   - Field: ‘earlySignal’
[17:02:55.853]   - Field: ‘lazy’
[17:02:55.853]   - Field: ‘state’
[17:02:55.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.854] - Launch lazy future ...
[17:02:55.854] Packages needed by the future expression (n = 0): <none>
[17:02:55.854] Packages needed by future strategies (n = 0): <none>
[17:02:55.854] {
[17:02:55.854]     {
[17:02:55.854]         {
[17:02:55.854]             ...future.startTime <- base::Sys.time()
[17:02:55.854]             {
[17:02:55.854]                 {
[17:02:55.854]                   {
[17:02:55.854]                     {
[17:02:55.854]                       base::local({
[17:02:55.854]                         has_future <- base::requireNamespace("future", 
[17:02:55.854]                           quietly = TRUE)
[17:02:55.854]                         if (has_future) {
[17:02:55.854]                           ns <- base::getNamespace("future")
[17:02:55.854]                           version <- ns[[".package"]][["version"]]
[17:02:55.854]                           if (is.null(version)) 
[17:02:55.854]                             version <- utils::packageVersion("future")
[17:02:55.854]                         }
[17:02:55.854]                         else {
[17:02:55.854]                           version <- NULL
[17:02:55.854]                         }
[17:02:55.854]                         if (!has_future || version < "1.8.0") {
[17:02:55.854]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.854]                             "", base::R.version$version.string), 
[17:02:55.854]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.854]                               "release", "version")], collapse = " "), 
[17:02:55.854]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.854]                             info)
[17:02:55.854]                           info <- base::paste(info, collapse = "; ")
[17:02:55.854]                           if (!has_future) {
[17:02:55.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.854]                               info)
[17:02:55.854]                           }
[17:02:55.854]                           else {
[17:02:55.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.854]                               info, version)
[17:02:55.854]                           }
[17:02:55.854]                           base::stop(msg)
[17:02:55.854]                         }
[17:02:55.854]                       })
[17:02:55.854]                     }
[17:02:55.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.854]                     base::options(mc.cores = 1L)
[17:02:55.854]                   }
[17:02:55.854]                   ...future.strategy.old <- future::plan("list")
[17:02:55.854]                   options(future.plan = NULL)
[17:02:55.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.854]                 }
[17:02:55.854]                 ...future.workdir <- getwd()
[17:02:55.854]             }
[17:02:55.854]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.854]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.854]         }
[17:02:55.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.854]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.854]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.854]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.854]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.854]             base::names(...future.oldOptions))
[17:02:55.854]     }
[17:02:55.854]     if (FALSE) {
[17:02:55.854]     }
[17:02:55.854]     else {
[17:02:55.854]         if (TRUE) {
[17:02:55.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.854]                 open = "w")
[17:02:55.854]         }
[17:02:55.854]         else {
[17:02:55.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.854]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.854]         }
[17:02:55.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.854]             base::sink(type = "output", split = FALSE)
[17:02:55.854]             base::close(...future.stdout)
[17:02:55.854]         }, add = TRUE)
[17:02:55.854]     }
[17:02:55.854]     ...future.frame <- base::sys.nframe()
[17:02:55.854]     ...future.conditions <- base::list()
[17:02:55.854]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.854]     if (FALSE) {
[17:02:55.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.854]     }
[17:02:55.854]     ...future.result <- base::tryCatch({
[17:02:55.854]         base::withCallingHandlers({
[17:02:55.854]             ...future.value <- base::withVisible(base::local({
[17:02:55.854]                 ...future.makeSendCondition <- base::local({
[17:02:55.854]                   sendCondition <- NULL
[17:02:55.854]                   function(frame = 1L) {
[17:02:55.854]                     if (is.function(sendCondition)) 
[17:02:55.854]                       return(sendCondition)
[17:02:55.854]                     ns <- getNamespace("parallel")
[17:02:55.854]                     if (exists("sendData", mode = "function", 
[17:02:55.854]                       envir = ns)) {
[17:02:55.854]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.854]                         envir = ns)
[17:02:55.854]                       envir <- sys.frame(frame)
[17:02:55.854]                       master <- NULL
[17:02:55.854]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.854]                         !identical(envir, emptyenv())) {
[17:02:55.854]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.854]                           inherits = FALSE)) {
[17:02:55.854]                           master <- get("master", mode = "list", 
[17:02:55.854]                             envir = envir, inherits = FALSE)
[17:02:55.854]                           if (inherits(master, c("SOCKnode", 
[17:02:55.854]                             "SOCK0node"))) {
[17:02:55.854]                             sendCondition <<- function(cond) {
[17:02:55.854]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.854]                                 success = TRUE)
[17:02:55.854]                               parallel_sendData(master, data)
[17:02:55.854]                             }
[17:02:55.854]                             return(sendCondition)
[17:02:55.854]                           }
[17:02:55.854]                         }
[17:02:55.854]                         frame <- frame + 1L
[17:02:55.854]                         envir <- sys.frame(frame)
[17:02:55.854]                       }
[17:02:55.854]                     }
[17:02:55.854]                     sendCondition <<- function(cond) NULL
[17:02:55.854]                   }
[17:02:55.854]                 })
[17:02:55.854]                 withCallingHandlers({
[17:02:55.854]                   {
[17:02:55.854]                     x <- 0
[17:02:55.854]                     x <- x + 1
[17:02:55.854]                     x
[17:02:55.854]                   }
[17:02:55.854]                 }, immediateCondition = function(cond) {
[17:02:55.854]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.854]                   sendCondition(cond)
[17:02:55.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.854]                   {
[17:02:55.854]                     inherits <- base::inherits
[17:02:55.854]                     invokeRestart <- base::invokeRestart
[17:02:55.854]                     is.null <- base::is.null
[17:02:55.854]                     muffled <- FALSE
[17:02:55.854]                     if (inherits(cond, "message")) {
[17:02:55.854]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.854]                       if (muffled) 
[17:02:55.854]                         invokeRestart("muffleMessage")
[17:02:55.854]                     }
[17:02:55.854]                     else if (inherits(cond, "warning")) {
[17:02:55.854]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.854]                       if (muffled) 
[17:02:55.854]                         invokeRestart("muffleWarning")
[17:02:55.854]                     }
[17:02:55.854]                     else if (inherits(cond, "condition")) {
[17:02:55.854]                       if (!is.null(pattern)) {
[17:02:55.854]                         computeRestarts <- base::computeRestarts
[17:02:55.854]                         grepl <- base::grepl
[17:02:55.854]                         restarts <- computeRestarts(cond)
[17:02:55.854]                         for (restart in restarts) {
[17:02:55.854]                           name <- restart$name
[17:02:55.854]                           if (is.null(name)) 
[17:02:55.854]                             next
[17:02:55.854]                           if (!grepl(pattern, name)) 
[17:02:55.854]                             next
[17:02:55.854]                           invokeRestart(restart)
[17:02:55.854]                           muffled <- TRUE
[17:02:55.854]                           break
[17:02:55.854]                         }
[17:02:55.854]                       }
[17:02:55.854]                     }
[17:02:55.854]                     invisible(muffled)
[17:02:55.854]                   }
[17:02:55.854]                   muffleCondition(cond)
[17:02:55.854]                 })
[17:02:55.854]             }))
[17:02:55.854]             future::FutureResult(value = ...future.value$value, 
[17:02:55.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.854]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.854]                     ...future.globalenv.names))
[17:02:55.854]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.854]         }, condition = base::local({
[17:02:55.854]             c <- base::c
[17:02:55.854]             inherits <- base::inherits
[17:02:55.854]             invokeRestart <- base::invokeRestart
[17:02:55.854]             length <- base::length
[17:02:55.854]             list <- base::list
[17:02:55.854]             seq.int <- base::seq.int
[17:02:55.854]             signalCondition <- base::signalCondition
[17:02:55.854]             sys.calls <- base::sys.calls
[17:02:55.854]             `[[` <- base::`[[`
[17:02:55.854]             `+` <- base::`+`
[17:02:55.854]             `<<-` <- base::`<<-`
[17:02:55.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.854]                   3L)]
[17:02:55.854]             }
[17:02:55.854]             function(cond) {
[17:02:55.854]                 is_error <- inherits(cond, "error")
[17:02:55.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.854]                   NULL)
[17:02:55.854]                 if (is_error) {
[17:02:55.854]                   sessionInformation <- function() {
[17:02:55.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.854]                       search = base::search(), system = base::Sys.info())
[17:02:55.854]                   }
[17:02:55.854]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.854]                     cond$call), session = sessionInformation(), 
[17:02:55.854]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.854]                   signalCondition(cond)
[17:02:55.854]                 }
[17:02:55.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.854]                 "immediateCondition"))) {
[17:02:55.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.854]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.854]                   if (TRUE && !signal) {
[17:02:55.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.854]                     {
[17:02:55.854]                       inherits <- base::inherits
[17:02:55.854]                       invokeRestart <- base::invokeRestart
[17:02:55.854]                       is.null <- base::is.null
[17:02:55.854]                       muffled <- FALSE
[17:02:55.854]                       if (inherits(cond, "message")) {
[17:02:55.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.854]                         if (muffled) 
[17:02:55.854]                           invokeRestart("muffleMessage")
[17:02:55.854]                       }
[17:02:55.854]                       else if (inherits(cond, "warning")) {
[17:02:55.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.854]                         if (muffled) 
[17:02:55.854]                           invokeRestart("muffleWarning")
[17:02:55.854]                       }
[17:02:55.854]                       else if (inherits(cond, "condition")) {
[17:02:55.854]                         if (!is.null(pattern)) {
[17:02:55.854]                           computeRestarts <- base::computeRestarts
[17:02:55.854]                           grepl <- base::grepl
[17:02:55.854]                           restarts <- computeRestarts(cond)
[17:02:55.854]                           for (restart in restarts) {
[17:02:55.854]                             name <- restart$name
[17:02:55.854]                             if (is.null(name)) 
[17:02:55.854]                               next
[17:02:55.854]                             if (!grepl(pattern, name)) 
[17:02:55.854]                               next
[17:02:55.854]                             invokeRestart(restart)
[17:02:55.854]                             muffled <- TRUE
[17:02:55.854]                             break
[17:02:55.854]                           }
[17:02:55.854]                         }
[17:02:55.854]                       }
[17:02:55.854]                       invisible(muffled)
[17:02:55.854]                     }
[17:02:55.854]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.854]                   }
[17:02:55.854]                 }
[17:02:55.854]                 else {
[17:02:55.854]                   if (TRUE) {
[17:02:55.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.854]                     {
[17:02:55.854]                       inherits <- base::inherits
[17:02:55.854]                       invokeRestart <- base::invokeRestart
[17:02:55.854]                       is.null <- base::is.null
[17:02:55.854]                       muffled <- FALSE
[17:02:55.854]                       if (inherits(cond, "message")) {
[17:02:55.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.854]                         if (muffled) 
[17:02:55.854]                           invokeRestart("muffleMessage")
[17:02:55.854]                       }
[17:02:55.854]                       else if (inherits(cond, "warning")) {
[17:02:55.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.854]                         if (muffled) 
[17:02:55.854]                           invokeRestart("muffleWarning")
[17:02:55.854]                       }
[17:02:55.854]                       else if (inherits(cond, "condition")) {
[17:02:55.854]                         if (!is.null(pattern)) {
[17:02:55.854]                           computeRestarts <- base::computeRestarts
[17:02:55.854]                           grepl <- base::grepl
[17:02:55.854]                           restarts <- computeRestarts(cond)
[17:02:55.854]                           for (restart in restarts) {
[17:02:55.854]                             name <- restart$name
[17:02:55.854]                             if (is.null(name)) 
[17:02:55.854]                               next
[17:02:55.854]                             if (!grepl(pattern, name)) 
[17:02:55.854]                               next
[17:02:55.854]                             invokeRestart(restart)
[17:02:55.854]                             muffled <- TRUE
[17:02:55.854]                             break
[17:02:55.854]                           }
[17:02:55.854]                         }
[17:02:55.854]                       }
[17:02:55.854]                       invisible(muffled)
[17:02:55.854]                     }
[17:02:55.854]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.854]                   }
[17:02:55.854]                 }
[17:02:55.854]             }
[17:02:55.854]         }))
[17:02:55.854]     }, error = function(ex) {
[17:02:55.854]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.854]                 ...future.rng), started = ...future.startTime, 
[17:02:55.854]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.854]             version = "1.8"), class = "FutureResult")
[17:02:55.854]     }, finally = {
[17:02:55.854]         if (!identical(...future.workdir, getwd())) 
[17:02:55.854]             setwd(...future.workdir)
[17:02:55.854]         {
[17:02:55.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.854]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.854]             }
[17:02:55.854]             base::options(...future.oldOptions)
[17:02:55.854]             if (.Platform$OS.type == "windows") {
[17:02:55.854]                 old_names <- names(...future.oldEnvVars)
[17:02:55.854]                 envs <- base::Sys.getenv()
[17:02:55.854]                 names <- names(envs)
[17:02:55.854]                 common <- intersect(names, old_names)
[17:02:55.854]                 added <- setdiff(names, old_names)
[17:02:55.854]                 removed <- setdiff(old_names, names)
[17:02:55.854]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.854]                   envs[common]]
[17:02:55.854]                 NAMES <- toupper(changed)
[17:02:55.854]                 args <- list()
[17:02:55.854]                 for (kk in seq_along(NAMES)) {
[17:02:55.854]                   name <- changed[[kk]]
[17:02:55.854]                   NAME <- NAMES[[kk]]
[17:02:55.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.854]                     next
[17:02:55.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.854]                 }
[17:02:55.854]                 NAMES <- toupper(added)
[17:02:55.854]                 for (kk in seq_along(NAMES)) {
[17:02:55.854]                   name <- added[[kk]]
[17:02:55.854]                   NAME <- NAMES[[kk]]
[17:02:55.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.854]                     next
[17:02:55.854]                   args[[name]] <- ""
[17:02:55.854]                 }
[17:02:55.854]                 NAMES <- toupper(removed)
[17:02:55.854]                 for (kk in seq_along(NAMES)) {
[17:02:55.854]                   name <- removed[[kk]]
[17:02:55.854]                   NAME <- NAMES[[kk]]
[17:02:55.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.854]                     next
[17:02:55.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.854]                 }
[17:02:55.854]                 if (length(args) > 0) 
[17:02:55.854]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.854]             }
[17:02:55.854]             else {
[17:02:55.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.854]             }
[17:02:55.854]             {
[17:02:55.854]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.854]                   0L) {
[17:02:55.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.854]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.854]                   base::options(opts)
[17:02:55.854]                 }
[17:02:55.854]                 {
[17:02:55.854]                   {
[17:02:55.854]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.854]                     NULL
[17:02:55.854]                   }
[17:02:55.854]                   options(future.plan = NULL)
[17:02:55.854]                   if (is.na(NA_character_)) 
[17:02:55.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.854]                     .init = FALSE)
[17:02:55.854]                 }
[17:02:55.854]             }
[17:02:55.854]         }
[17:02:55.854]     })
[17:02:55.854]     if (TRUE) {
[17:02:55.854]         base::sink(type = "output", split = FALSE)
[17:02:55.854]         if (TRUE) {
[17:02:55.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.854]         }
[17:02:55.854]         else {
[17:02:55.854]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.854]         }
[17:02:55.854]         base::close(...future.stdout)
[17:02:55.854]         ...future.stdout <- NULL
[17:02:55.854]     }
[17:02:55.854]     ...future.result$conditions <- ...future.conditions
[17:02:55.854]     ...future.result$finished <- base::Sys.time()
[17:02:55.854]     ...future.result
[17:02:55.854] }
[17:02:55.857] MultisessionFuture started
[17:02:55.858] - Launch lazy future ... done
[17:02:55.858] run() for ‘MultisessionFuture’ ... done
[17:02:55.858] result() for ClusterFuture ...
[17:02:55.858] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.858] - Validating connection of MultisessionFuture
[17:02:55.901] - received message: FutureResult
[17:02:55.902] - Received FutureResult
[17:02:55.902] - Erased future from FutureRegistry
[17:02:55.902] result() for ClusterFuture ...
[17:02:55.902] - result already collected: FutureResult
[17:02:55.902] result() for ClusterFuture ... done
[17:02:55.902] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.902] result() for ClusterFuture ... done
[17:02:55.902] result() for ClusterFuture ...
[17:02:55.902] - result already collected: FutureResult
[17:02:55.902] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.903] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.903] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.905] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:02:55.905] Searching for globals ... DONE
[17:02:55.905] Resolving globals: TRUE
[17:02:55.905] Resolving any globals that are futures ...
[17:02:55.905] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:02:55.905] Resolving any globals that are futures ... DONE
[17:02:55.905] Resolving futures part of globals (recursively) ...
[17:02:55.906] resolve() on list ...
[17:02:55.906]  recursive: 99
[17:02:55.906]  length: 1
[17:02:55.906]  elements: ‘x’
[17:02:55.906]  length: 0 (resolved future 1)
[17:02:55.906] resolve() on list ... DONE
[17:02:55.906] - globals: [1] ‘x’
[17:02:55.906] Resolving futures part of globals (recursively) ... DONE
[17:02:55.907] The total size of the 1 globals is 56 bytes (56 bytes)
[17:02:55.907] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:02:55.907] - globals: [1] ‘x’
[17:02:55.907] 
[17:02:55.907] getGlobalsAndPackages() ... DONE
[17:02:55.907] run() for ‘Future’ ...
[17:02:55.908] - state: ‘created’
[17:02:55.908] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.921] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.922]   - Field: ‘node’
[17:02:55.922]   - Field: ‘label’
[17:02:55.922]   - Field: ‘local’
[17:02:55.922]   - Field: ‘owner’
[17:02:55.922]   - Field: ‘envir’
[17:02:55.922]   - Field: ‘workers’
[17:02:55.922]   - Field: ‘packages’
[17:02:55.922]   - Field: ‘gc’
[17:02:55.922]   - Field: ‘conditions’
[17:02:55.923]   - Field: ‘persistent’
[17:02:55.923]   - Field: ‘expr’
[17:02:55.923]   - Field: ‘uuid’
[17:02:55.923]   - Field: ‘seed’
[17:02:55.923]   - Field: ‘version’
[17:02:55.923]   - Field: ‘result’
[17:02:55.923]   - Field: ‘asynchronous’
[17:02:55.923]   - Field: ‘calls’
[17:02:55.923]   - Field: ‘globals’
[17:02:55.923]   - Field: ‘stdout’
[17:02:55.923]   - Field: ‘earlySignal’
[17:02:55.924]   - Field: ‘lazy’
[17:02:55.924]   - Field: ‘state’
[17:02:55.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.924] - Launch lazy future ...
[17:02:55.924] Packages needed by the future expression (n = 0): <none>
[17:02:55.924] Packages needed by future strategies (n = 0): <none>
[17:02:55.925] {
[17:02:55.925]     {
[17:02:55.925]         {
[17:02:55.925]             ...future.startTime <- base::Sys.time()
[17:02:55.925]             {
[17:02:55.925]                 {
[17:02:55.925]                   {
[17:02:55.925]                     {
[17:02:55.925]                       base::local({
[17:02:55.925]                         has_future <- base::requireNamespace("future", 
[17:02:55.925]                           quietly = TRUE)
[17:02:55.925]                         if (has_future) {
[17:02:55.925]                           ns <- base::getNamespace("future")
[17:02:55.925]                           version <- ns[[".package"]][["version"]]
[17:02:55.925]                           if (is.null(version)) 
[17:02:55.925]                             version <- utils::packageVersion("future")
[17:02:55.925]                         }
[17:02:55.925]                         else {
[17:02:55.925]                           version <- NULL
[17:02:55.925]                         }
[17:02:55.925]                         if (!has_future || version < "1.8.0") {
[17:02:55.925]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.925]                             "", base::R.version$version.string), 
[17:02:55.925]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.925]                               "release", "version")], collapse = " "), 
[17:02:55.925]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.925]                             info)
[17:02:55.925]                           info <- base::paste(info, collapse = "; ")
[17:02:55.925]                           if (!has_future) {
[17:02:55.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.925]                               info)
[17:02:55.925]                           }
[17:02:55.925]                           else {
[17:02:55.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.925]                               info, version)
[17:02:55.925]                           }
[17:02:55.925]                           base::stop(msg)
[17:02:55.925]                         }
[17:02:55.925]                       })
[17:02:55.925]                     }
[17:02:55.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.925]                     base::options(mc.cores = 1L)
[17:02:55.925]                   }
[17:02:55.925]                   ...future.strategy.old <- future::plan("list")
[17:02:55.925]                   options(future.plan = NULL)
[17:02:55.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.925]                 }
[17:02:55.925]                 ...future.workdir <- getwd()
[17:02:55.925]             }
[17:02:55.925]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.925]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.925]         }
[17:02:55.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.925]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.925]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.925]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.925]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.925]             base::names(...future.oldOptions))
[17:02:55.925]     }
[17:02:55.925]     if (FALSE) {
[17:02:55.925]     }
[17:02:55.925]     else {
[17:02:55.925]         if (TRUE) {
[17:02:55.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.925]                 open = "w")
[17:02:55.925]         }
[17:02:55.925]         else {
[17:02:55.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.925]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.925]         }
[17:02:55.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.925]             base::sink(type = "output", split = FALSE)
[17:02:55.925]             base::close(...future.stdout)
[17:02:55.925]         }, add = TRUE)
[17:02:55.925]     }
[17:02:55.925]     ...future.frame <- base::sys.nframe()
[17:02:55.925]     ...future.conditions <- base::list()
[17:02:55.925]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.925]     if (FALSE) {
[17:02:55.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.925]     }
[17:02:55.925]     ...future.result <- base::tryCatch({
[17:02:55.925]         base::withCallingHandlers({
[17:02:55.925]             ...future.value <- base::withVisible(base::local({
[17:02:55.925]                 ...future.makeSendCondition <- base::local({
[17:02:55.925]                   sendCondition <- NULL
[17:02:55.925]                   function(frame = 1L) {
[17:02:55.925]                     if (is.function(sendCondition)) 
[17:02:55.925]                       return(sendCondition)
[17:02:55.925]                     ns <- getNamespace("parallel")
[17:02:55.925]                     if (exists("sendData", mode = "function", 
[17:02:55.925]                       envir = ns)) {
[17:02:55.925]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.925]                         envir = ns)
[17:02:55.925]                       envir <- sys.frame(frame)
[17:02:55.925]                       master <- NULL
[17:02:55.925]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.925]                         !identical(envir, emptyenv())) {
[17:02:55.925]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.925]                           inherits = FALSE)) {
[17:02:55.925]                           master <- get("master", mode = "list", 
[17:02:55.925]                             envir = envir, inherits = FALSE)
[17:02:55.925]                           if (inherits(master, c("SOCKnode", 
[17:02:55.925]                             "SOCK0node"))) {
[17:02:55.925]                             sendCondition <<- function(cond) {
[17:02:55.925]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.925]                                 success = TRUE)
[17:02:55.925]                               parallel_sendData(master, data)
[17:02:55.925]                             }
[17:02:55.925]                             return(sendCondition)
[17:02:55.925]                           }
[17:02:55.925]                         }
[17:02:55.925]                         frame <- frame + 1L
[17:02:55.925]                         envir <- sys.frame(frame)
[17:02:55.925]                       }
[17:02:55.925]                     }
[17:02:55.925]                     sendCondition <<- function(cond) NULL
[17:02:55.925]                   }
[17:02:55.925]                 })
[17:02:55.925]                 withCallingHandlers({
[17:02:55.925]                   {
[17:02:55.925]                     x <- x + 1
[17:02:55.925]                     x
[17:02:55.925]                   }
[17:02:55.925]                 }, immediateCondition = function(cond) {
[17:02:55.925]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.925]                   sendCondition(cond)
[17:02:55.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.925]                   {
[17:02:55.925]                     inherits <- base::inherits
[17:02:55.925]                     invokeRestart <- base::invokeRestart
[17:02:55.925]                     is.null <- base::is.null
[17:02:55.925]                     muffled <- FALSE
[17:02:55.925]                     if (inherits(cond, "message")) {
[17:02:55.925]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.925]                       if (muffled) 
[17:02:55.925]                         invokeRestart("muffleMessage")
[17:02:55.925]                     }
[17:02:55.925]                     else if (inherits(cond, "warning")) {
[17:02:55.925]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.925]                       if (muffled) 
[17:02:55.925]                         invokeRestart("muffleWarning")
[17:02:55.925]                     }
[17:02:55.925]                     else if (inherits(cond, "condition")) {
[17:02:55.925]                       if (!is.null(pattern)) {
[17:02:55.925]                         computeRestarts <- base::computeRestarts
[17:02:55.925]                         grepl <- base::grepl
[17:02:55.925]                         restarts <- computeRestarts(cond)
[17:02:55.925]                         for (restart in restarts) {
[17:02:55.925]                           name <- restart$name
[17:02:55.925]                           if (is.null(name)) 
[17:02:55.925]                             next
[17:02:55.925]                           if (!grepl(pattern, name)) 
[17:02:55.925]                             next
[17:02:55.925]                           invokeRestart(restart)
[17:02:55.925]                           muffled <- TRUE
[17:02:55.925]                           break
[17:02:55.925]                         }
[17:02:55.925]                       }
[17:02:55.925]                     }
[17:02:55.925]                     invisible(muffled)
[17:02:55.925]                   }
[17:02:55.925]                   muffleCondition(cond)
[17:02:55.925]                 })
[17:02:55.925]             }))
[17:02:55.925]             future::FutureResult(value = ...future.value$value, 
[17:02:55.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.925]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.925]                     ...future.globalenv.names))
[17:02:55.925]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.925]         }, condition = base::local({
[17:02:55.925]             c <- base::c
[17:02:55.925]             inherits <- base::inherits
[17:02:55.925]             invokeRestart <- base::invokeRestart
[17:02:55.925]             length <- base::length
[17:02:55.925]             list <- base::list
[17:02:55.925]             seq.int <- base::seq.int
[17:02:55.925]             signalCondition <- base::signalCondition
[17:02:55.925]             sys.calls <- base::sys.calls
[17:02:55.925]             `[[` <- base::`[[`
[17:02:55.925]             `+` <- base::`+`
[17:02:55.925]             `<<-` <- base::`<<-`
[17:02:55.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.925]                   3L)]
[17:02:55.925]             }
[17:02:55.925]             function(cond) {
[17:02:55.925]                 is_error <- inherits(cond, "error")
[17:02:55.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.925]                   NULL)
[17:02:55.925]                 if (is_error) {
[17:02:55.925]                   sessionInformation <- function() {
[17:02:55.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.925]                       search = base::search(), system = base::Sys.info())
[17:02:55.925]                   }
[17:02:55.925]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.925]                     cond$call), session = sessionInformation(), 
[17:02:55.925]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.925]                   signalCondition(cond)
[17:02:55.925]                 }
[17:02:55.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.925]                 "immediateCondition"))) {
[17:02:55.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.925]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.925]                   if (TRUE && !signal) {
[17:02:55.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.925]                     {
[17:02:55.925]                       inherits <- base::inherits
[17:02:55.925]                       invokeRestart <- base::invokeRestart
[17:02:55.925]                       is.null <- base::is.null
[17:02:55.925]                       muffled <- FALSE
[17:02:55.925]                       if (inherits(cond, "message")) {
[17:02:55.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.925]                         if (muffled) 
[17:02:55.925]                           invokeRestart("muffleMessage")
[17:02:55.925]                       }
[17:02:55.925]                       else if (inherits(cond, "warning")) {
[17:02:55.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.925]                         if (muffled) 
[17:02:55.925]                           invokeRestart("muffleWarning")
[17:02:55.925]                       }
[17:02:55.925]                       else if (inherits(cond, "condition")) {
[17:02:55.925]                         if (!is.null(pattern)) {
[17:02:55.925]                           computeRestarts <- base::computeRestarts
[17:02:55.925]                           grepl <- base::grepl
[17:02:55.925]                           restarts <- computeRestarts(cond)
[17:02:55.925]                           for (restart in restarts) {
[17:02:55.925]                             name <- restart$name
[17:02:55.925]                             if (is.null(name)) 
[17:02:55.925]                               next
[17:02:55.925]                             if (!grepl(pattern, name)) 
[17:02:55.925]                               next
[17:02:55.925]                             invokeRestart(restart)
[17:02:55.925]                             muffled <- TRUE
[17:02:55.925]                             break
[17:02:55.925]                           }
[17:02:55.925]                         }
[17:02:55.925]                       }
[17:02:55.925]                       invisible(muffled)
[17:02:55.925]                     }
[17:02:55.925]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.925]                   }
[17:02:55.925]                 }
[17:02:55.925]                 else {
[17:02:55.925]                   if (TRUE) {
[17:02:55.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.925]                     {
[17:02:55.925]                       inherits <- base::inherits
[17:02:55.925]                       invokeRestart <- base::invokeRestart
[17:02:55.925]                       is.null <- base::is.null
[17:02:55.925]                       muffled <- FALSE
[17:02:55.925]                       if (inherits(cond, "message")) {
[17:02:55.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.925]                         if (muffled) 
[17:02:55.925]                           invokeRestart("muffleMessage")
[17:02:55.925]                       }
[17:02:55.925]                       else if (inherits(cond, "warning")) {
[17:02:55.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.925]                         if (muffled) 
[17:02:55.925]                           invokeRestart("muffleWarning")
[17:02:55.925]                       }
[17:02:55.925]                       else if (inherits(cond, "condition")) {
[17:02:55.925]                         if (!is.null(pattern)) {
[17:02:55.925]                           computeRestarts <- base::computeRestarts
[17:02:55.925]                           grepl <- base::grepl
[17:02:55.925]                           restarts <- computeRestarts(cond)
[17:02:55.925]                           for (restart in restarts) {
[17:02:55.925]                             name <- restart$name
[17:02:55.925]                             if (is.null(name)) 
[17:02:55.925]                               next
[17:02:55.925]                             if (!grepl(pattern, name)) 
[17:02:55.925]                               next
[17:02:55.925]                             invokeRestart(restart)
[17:02:55.925]                             muffled <- TRUE
[17:02:55.925]                             break
[17:02:55.925]                           }
[17:02:55.925]                         }
[17:02:55.925]                       }
[17:02:55.925]                       invisible(muffled)
[17:02:55.925]                     }
[17:02:55.925]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.925]                   }
[17:02:55.925]                 }
[17:02:55.925]             }
[17:02:55.925]         }))
[17:02:55.925]     }, error = function(ex) {
[17:02:55.925]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.925]                 ...future.rng), started = ...future.startTime, 
[17:02:55.925]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.925]             version = "1.8"), class = "FutureResult")
[17:02:55.925]     }, finally = {
[17:02:55.925]         if (!identical(...future.workdir, getwd())) 
[17:02:55.925]             setwd(...future.workdir)
[17:02:55.925]         {
[17:02:55.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.925]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.925]             }
[17:02:55.925]             base::options(...future.oldOptions)
[17:02:55.925]             if (.Platform$OS.type == "windows") {
[17:02:55.925]                 old_names <- names(...future.oldEnvVars)
[17:02:55.925]                 envs <- base::Sys.getenv()
[17:02:55.925]                 names <- names(envs)
[17:02:55.925]                 common <- intersect(names, old_names)
[17:02:55.925]                 added <- setdiff(names, old_names)
[17:02:55.925]                 removed <- setdiff(old_names, names)
[17:02:55.925]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.925]                   envs[common]]
[17:02:55.925]                 NAMES <- toupper(changed)
[17:02:55.925]                 args <- list()
[17:02:55.925]                 for (kk in seq_along(NAMES)) {
[17:02:55.925]                   name <- changed[[kk]]
[17:02:55.925]                   NAME <- NAMES[[kk]]
[17:02:55.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.925]                     next
[17:02:55.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.925]                 }
[17:02:55.925]                 NAMES <- toupper(added)
[17:02:55.925]                 for (kk in seq_along(NAMES)) {
[17:02:55.925]                   name <- added[[kk]]
[17:02:55.925]                   NAME <- NAMES[[kk]]
[17:02:55.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.925]                     next
[17:02:55.925]                   args[[name]] <- ""
[17:02:55.925]                 }
[17:02:55.925]                 NAMES <- toupper(removed)
[17:02:55.925]                 for (kk in seq_along(NAMES)) {
[17:02:55.925]                   name <- removed[[kk]]
[17:02:55.925]                   NAME <- NAMES[[kk]]
[17:02:55.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.925]                     next
[17:02:55.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.925]                 }
[17:02:55.925]                 if (length(args) > 0) 
[17:02:55.925]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.925]             }
[17:02:55.925]             else {
[17:02:55.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.925]             }
[17:02:55.925]             {
[17:02:55.925]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.925]                   0L) {
[17:02:55.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.925]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.925]                   base::options(opts)
[17:02:55.925]                 }
[17:02:55.925]                 {
[17:02:55.925]                   {
[17:02:55.925]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.925]                     NULL
[17:02:55.925]                   }
[17:02:55.925]                   options(future.plan = NULL)
[17:02:55.925]                   if (is.na(NA_character_)) 
[17:02:55.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.925]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.925]                     .init = FALSE)
[17:02:55.925]                 }
[17:02:55.925]             }
[17:02:55.925]         }
[17:02:55.925]     })
[17:02:55.925]     if (TRUE) {
[17:02:55.925]         base::sink(type = "output", split = FALSE)
[17:02:55.925]         if (TRUE) {
[17:02:55.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.925]         }
[17:02:55.925]         else {
[17:02:55.925]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.925]         }
[17:02:55.925]         base::close(...future.stdout)
[17:02:55.925]         ...future.stdout <- NULL
[17:02:55.925]     }
[17:02:55.925]     ...future.result$conditions <- ...future.conditions
[17:02:55.925]     ...future.result$finished <- base::Sys.time()
[17:02:55.925]     ...future.result
[17:02:55.925] }
[17:02:55.927] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:02:55.927] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:02:55.928] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:02:55.928] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:02:55.928] MultisessionFuture started
[17:02:55.928] - Launch lazy future ... done
[17:02:55.929] run() for ‘MultisessionFuture’ ... done
[17:02:55.929] result() for ClusterFuture ...
[17:02:55.929] receiveMessageFromWorker() for ClusterFuture ...
[17:02:55.929] - Validating connection of MultisessionFuture
[17:02:55.974] - received message: FutureResult
[17:02:55.974] - Received FutureResult
[17:02:55.974] - Erased future from FutureRegistry
[17:02:55.974] result() for ClusterFuture ...
[17:02:55.974] - result already collected: FutureResult
[17:02:55.974] result() for ClusterFuture ... done
[17:02:55.974] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:55.975] result() for ClusterFuture ... done
[17:02:55.975] result() for ClusterFuture ...
[17:02:55.975] - result already collected: FutureResult
[17:02:55.975] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:55.975] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:55.975] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:02:55.977] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:02:55.977] Searching for globals ... DONE
[17:02:55.977] Resolving globals: TRUE
[17:02:55.977] Resolving any globals that are futures ...
[17:02:55.978] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:02:55.978] Resolving any globals that are futures ... DONE
[17:02:55.978] Resolving futures part of globals (recursively) ...
[17:02:55.978] resolve() on list ...
[17:02:55.978]  recursive: 99
[17:02:55.978]  length: 1
[17:02:55.979]  elements: ‘x’
[17:02:55.979]  length: 0 (resolved future 1)
[17:02:55.979] resolve() on list ... DONE
[17:02:55.979] - globals: [1] ‘x’
[17:02:55.979] Resolving futures part of globals (recursively) ... DONE
[17:02:55.979] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:02:55.979] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:02:55.980] - globals: [1] ‘x’
[17:02:55.980] 
[17:02:55.980] getGlobalsAndPackages() ... DONE
[17:02:55.980] run() for ‘Future’ ...
[17:02:55.980] - state: ‘created’
[17:02:55.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:55.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:55.995] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:55.995]   - Field: ‘node’
[17:02:55.995]   - Field: ‘label’
[17:02:55.995]   - Field: ‘local’
[17:02:55.995]   - Field: ‘owner’
[17:02:55.995]   - Field: ‘envir’
[17:02:55.995]   - Field: ‘workers’
[17:02:55.995]   - Field: ‘packages’
[17:02:55.995]   - Field: ‘gc’
[17:02:55.996]   - Field: ‘conditions’
[17:02:55.996]   - Field: ‘persistent’
[17:02:55.996]   - Field: ‘expr’
[17:02:55.996]   - Field: ‘uuid’
[17:02:55.996]   - Field: ‘seed’
[17:02:55.996]   - Field: ‘version’
[17:02:55.996]   - Field: ‘result’
[17:02:55.996]   - Field: ‘asynchronous’
[17:02:55.996]   - Field: ‘calls’
[17:02:55.996]   - Field: ‘globals’
[17:02:55.996]   - Field: ‘stdout’
[17:02:55.997]   - Field: ‘earlySignal’
[17:02:55.997]   - Field: ‘lazy’
[17:02:55.997]   - Field: ‘state’
[17:02:55.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:55.997] - Launch lazy future ...
[17:02:55.997] Packages needed by the future expression (n = 0): <none>
[17:02:55.997] Packages needed by future strategies (n = 0): <none>
[17:02:55.998] {
[17:02:55.998]     {
[17:02:55.998]         {
[17:02:55.998]             ...future.startTime <- base::Sys.time()
[17:02:55.998]             {
[17:02:55.998]                 {
[17:02:55.998]                   {
[17:02:55.998]                     {
[17:02:55.998]                       base::local({
[17:02:55.998]                         has_future <- base::requireNamespace("future", 
[17:02:55.998]                           quietly = TRUE)
[17:02:55.998]                         if (has_future) {
[17:02:55.998]                           ns <- base::getNamespace("future")
[17:02:55.998]                           version <- ns[[".package"]][["version"]]
[17:02:55.998]                           if (is.null(version)) 
[17:02:55.998]                             version <- utils::packageVersion("future")
[17:02:55.998]                         }
[17:02:55.998]                         else {
[17:02:55.998]                           version <- NULL
[17:02:55.998]                         }
[17:02:55.998]                         if (!has_future || version < "1.8.0") {
[17:02:55.998]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:55.998]                             "", base::R.version$version.string), 
[17:02:55.998]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:55.998]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:55.998]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:55.998]                               "release", "version")], collapse = " "), 
[17:02:55.998]                             hostname = base::Sys.info()[["nodename"]])
[17:02:55.998]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:55.998]                             info)
[17:02:55.998]                           info <- base::paste(info, collapse = "; ")
[17:02:55.998]                           if (!has_future) {
[17:02:55.998]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:55.998]                               info)
[17:02:55.998]                           }
[17:02:55.998]                           else {
[17:02:55.998]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:55.998]                               info, version)
[17:02:55.998]                           }
[17:02:55.998]                           base::stop(msg)
[17:02:55.998]                         }
[17:02:55.998]                       })
[17:02:55.998]                     }
[17:02:55.998]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:55.998]                     base::options(mc.cores = 1L)
[17:02:55.998]                   }
[17:02:55.998]                   ...future.strategy.old <- future::plan("list")
[17:02:55.998]                   options(future.plan = NULL)
[17:02:55.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:55.998]                 }
[17:02:55.998]                 ...future.workdir <- getwd()
[17:02:55.998]             }
[17:02:55.998]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:55.998]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:55.998]         }
[17:02:55.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:55.998]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:02:55.998]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:55.998]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:55.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:55.998]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:55.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:55.998]             base::names(...future.oldOptions))
[17:02:55.998]     }
[17:02:55.998]     if (FALSE) {
[17:02:55.998]     }
[17:02:55.998]     else {
[17:02:55.998]         if (TRUE) {
[17:02:55.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:55.998]                 open = "w")
[17:02:55.998]         }
[17:02:55.998]         else {
[17:02:55.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:55.998]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:55.998]         }
[17:02:55.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:55.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:55.998]             base::sink(type = "output", split = FALSE)
[17:02:55.998]             base::close(...future.stdout)
[17:02:55.998]         }, add = TRUE)
[17:02:55.998]     }
[17:02:55.998]     ...future.frame <- base::sys.nframe()
[17:02:55.998]     ...future.conditions <- base::list()
[17:02:55.998]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:55.998]     if (FALSE) {
[17:02:55.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:55.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:55.998]     }
[17:02:55.998]     ...future.result <- base::tryCatch({
[17:02:55.998]         base::withCallingHandlers({
[17:02:55.998]             ...future.value <- base::withVisible(base::local({
[17:02:55.998]                 ...future.makeSendCondition <- base::local({
[17:02:55.998]                   sendCondition <- NULL
[17:02:55.998]                   function(frame = 1L) {
[17:02:55.998]                     if (is.function(sendCondition)) 
[17:02:55.998]                       return(sendCondition)
[17:02:55.998]                     ns <- getNamespace("parallel")
[17:02:55.998]                     if (exists("sendData", mode = "function", 
[17:02:55.998]                       envir = ns)) {
[17:02:55.998]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:55.998]                         envir = ns)
[17:02:55.998]                       envir <- sys.frame(frame)
[17:02:55.998]                       master <- NULL
[17:02:55.998]                       while (!identical(envir, .GlobalEnv) && 
[17:02:55.998]                         !identical(envir, emptyenv())) {
[17:02:55.998]                         if (exists("master", mode = "list", envir = envir, 
[17:02:55.998]                           inherits = FALSE)) {
[17:02:55.998]                           master <- get("master", mode = "list", 
[17:02:55.998]                             envir = envir, inherits = FALSE)
[17:02:55.998]                           if (inherits(master, c("SOCKnode", 
[17:02:55.998]                             "SOCK0node"))) {
[17:02:55.998]                             sendCondition <<- function(cond) {
[17:02:55.998]                               data <- list(type = "VALUE", value = cond, 
[17:02:55.998]                                 success = TRUE)
[17:02:55.998]                               parallel_sendData(master, data)
[17:02:55.998]                             }
[17:02:55.998]                             return(sendCondition)
[17:02:55.998]                           }
[17:02:55.998]                         }
[17:02:55.998]                         frame <- frame + 1L
[17:02:55.998]                         envir <- sys.frame(frame)
[17:02:55.998]                       }
[17:02:55.998]                     }
[17:02:55.998]                     sendCondition <<- function(cond) NULL
[17:02:55.998]                   }
[17:02:55.998]                 })
[17:02:55.998]                 withCallingHandlers({
[17:02:55.998]                   {
[17:02:55.998]                     x <- x()
[17:02:55.998]                     x
[17:02:55.998]                   }
[17:02:55.998]                 }, immediateCondition = function(cond) {
[17:02:55.998]                   sendCondition <- ...future.makeSendCondition()
[17:02:55.998]                   sendCondition(cond)
[17:02:55.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.998]                   {
[17:02:55.998]                     inherits <- base::inherits
[17:02:55.998]                     invokeRestart <- base::invokeRestart
[17:02:55.998]                     is.null <- base::is.null
[17:02:55.998]                     muffled <- FALSE
[17:02:55.998]                     if (inherits(cond, "message")) {
[17:02:55.998]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:55.998]                       if (muffled) 
[17:02:55.998]                         invokeRestart("muffleMessage")
[17:02:55.998]                     }
[17:02:55.998]                     else if (inherits(cond, "warning")) {
[17:02:55.998]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:55.998]                       if (muffled) 
[17:02:55.998]                         invokeRestart("muffleWarning")
[17:02:55.998]                     }
[17:02:55.998]                     else if (inherits(cond, "condition")) {
[17:02:55.998]                       if (!is.null(pattern)) {
[17:02:55.998]                         computeRestarts <- base::computeRestarts
[17:02:55.998]                         grepl <- base::grepl
[17:02:55.998]                         restarts <- computeRestarts(cond)
[17:02:55.998]                         for (restart in restarts) {
[17:02:55.998]                           name <- restart$name
[17:02:55.998]                           if (is.null(name)) 
[17:02:55.998]                             next
[17:02:55.998]                           if (!grepl(pattern, name)) 
[17:02:55.998]                             next
[17:02:55.998]                           invokeRestart(restart)
[17:02:55.998]                           muffled <- TRUE
[17:02:55.998]                           break
[17:02:55.998]                         }
[17:02:55.998]                       }
[17:02:55.998]                     }
[17:02:55.998]                     invisible(muffled)
[17:02:55.998]                   }
[17:02:55.998]                   muffleCondition(cond)
[17:02:55.998]                 })
[17:02:55.998]             }))
[17:02:55.998]             future::FutureResult(value = ...future.value$value, 
[17:02:55.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.998]                   ...future.rng), globalenv = if (FALSE) 
[17:02:55.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:55.998]                     ...future.globalenv.names))
[17:02:55.998]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:55.998]         }, condition = base::local({
[17:02:55.998]             c <- base::c
[17:02:55.998]             inherits <- base::inherits
[17:02:55.998]             invokeRestart <- base::invokeRestart
[17:02:55.998]             length <- base::length
[17:02:55.998]             list <- base::list
[17:02:55.998]             seq.int <- base::seq.int
[17:02:55.998]             signalCondition <- base::signalCondition
[17:02:55.998]             sys.calls <- base::sys.calls
[17:02:55.998]             `[[` <- base::`[[`
[17:02:55.998]             `+` <- base::`+`
[17:02:55.998]             `<<-` <- base::`<<-`
[17:02:55.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:55.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:55.998]                   3L)]
[17:02:55.998]             }
[17:02:55.998]             function(cond) {
[17:02:55.998]                 is_error <- inherits(cond, "error")
[17:02:55.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:55.998]                   NULL)
[17:02:55.998]                 if (is_error) {
[17:02:55.998]                   sessionInformation <- function() {
[17:02:55.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:55.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:55.998]                       search = base::search(), system = base::Sys.info())
[17:02:55.998]                   }
[17:02:55.998]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:55.998]                     cond$call), session = sessionInformation(), 
[17:02:55.998]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:55.998]                   signalCondition(cond)
[17:02:55.998]                 }
[17:02:55.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:55.998]                 "immediateCondition"))) {
[17:02:55.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:55.998]                   ...future.conditions[[length(...future.conditions) + 
[17:02:55.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:55.998]                   if (TRUE && !signal) {
[17:02:55.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.998]                     {
[17:02:55.998]                       inherits <- base::inherits
[17:02:55.998]                       invokeRestart <- base::invokeRestart
[17:02:55.998]                       is.null <- base::is.null
[17:02:55.998]                       muffled <- FALSE
[17:02:55.998]                       if (inherits(cond, "message")) {
[17:02:55.998]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.998]                         if (muffled) 
[17:02:55.998]                           invokeRestart("muffleMessage")
[17:02:55.998]                       }
[17:02:55.998]                       else if (inherits(cond, "warning")) {
[17:02:55.998]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.998]                         if (muffled) 
[17:02:55.998]                           invokeRestart("muffleWarning")
[17:02:55.998]                       }
[17:02:55.998]                       else if (inherits(cond, "condition")) {
[17:02:55.998]                         if (!is.null(pattern)) {
[17:02:55.998]                           computeRestarts <- base::computeRestarts
[17:02:55.998]                           grepl <- base::grepl
[17:02:55.998]                           restarts <- computeRestarts(cond)
[17:02:55.998]                           for (restart in restarts) {
[17:02:55.998]                             name <- restart$name
[17:02:55.998]                             if (is.null(name)) 
[17:02:55.998]                               next
[17:02:55.998]                             if (!grepl(pattern, name)) 
[17:02:55.998]                               next
[17:02:55.998]                             invokeRestart(restart)
[17:02:55.998]                             muffled <- TRUE
[17:02:55.998]                             break
[17:02:55.998]                           }
[17:02:55.998]                         }
[17:02:55.998]                       }
[17:02:55.998]                       invisible(muffled)
[17:02:55.998]                     }
[17:02:55.998]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.998]                   }
[17:02:55.998]                 }
[17:02:55.998]                 else {
[17:02:55.998]                   if (TRUE) {
[17:02:55.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:55.998]                     {
[17:02:55.998]                       inherits <- base::inherits
[17:02:55.998]                       invokeRestart <- base::invokeRestart
[17:02:55.998]                       is.null <- base::is.null
[17:02:55.998]                       muffled <- FALSE
[17:02:55.998]                       if (inherits(cond, "message")) {
[17:02:55.998]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:55.998]                         if (muffled) 
[17:02:55.998]                           invokeRestart("muffleMessage")
[17:02:55.998]                       }
[17:02:55.998]                       else if (inherits(cond, "warning")) {
[17:02:55.998]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:55.998]                         if (muffled) 
[17:02:55.998]                           invokeRestart("muffleWarning")
[17:02:55.998]                       }
[17:02:55.998]                       else if (inherits(cond, "condition")) {
[17:02:55.998]                         if (!is.null(pattern)) {
[17:02:55.998]                           computeRestarts <- base::computeRestarts
[17:02:55.998]                           grepl <- base::grepl
[17:02:55.998]                           restarts <- computeRestarts(cond)
[17:02:55.998]                           for (restart in restarts) {
[17:02:55.998]                             name <- restart$name
[17:02:55.998]                             if (is.null(name)) 
[17:02:55.998]                               next
[17:02:55.998]                             if (!grepl(pattern, name)) 
[17:02:55.998]                               next
[17:02:55.998]                             invokeRestart(restart)
[17:02:55.998]                             muffled <- TRUE
[17:02:55.998]                             break
[17:02:55.998]                           }
[17:02:55.998]                         }
[17:02:55.998]                       }
[17:02:55.998]                       invisible(muffled)
[17:02:55.998]                     }
[17:02:55.998]                     muffleCondition(cond, pattern = "^muffle")
[17:02:55.998]                   }
[17:02:55.998]                 }
[17:02:55.998]             }
[17:02:55.998]         }))
[17:02:55.998]     }, error = function(ex) {
[17:02:55.998]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:55.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:55.998]                 ...future.rng), started = ...future.startTime, 
[17:02:55.998]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:55.998]             version = "1.8"), class = "FutureResult")
[17:02:55.998]     }, finally = {
[17:02:55.998]         if (!identical(...future.workdir, getwd())) 
[17:02:55.998]             setwd(...future.workdir)
[17:02:55.998]         {
[17:02:55.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:55.998]                 ...future.oldOptions$nwarnings <- NULL
[17:02:55.998]             }
[17:02:55.998]             base::options(...future.oldOptions)
[17:02:55.998]             if (.Platform$OS.type == "windows") {
[17:02:55.998]                 old_names <- names(...future.oldEnvVars)
[17:02:55.998]                 envs <- base::Sys.getenv()
[17:02:55.998]                 names <- names(envs)
[17:02:55.998]                 common <- intersect(names, old_names)
[17:02:55.998]                 added <- setdiff(names, old_names)
[17:02:55.998]                 removed <- setdiff(old_names, names)
[17:02:55.998]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:55.998]                   envs[common]]
[17:02:55.998]                 NAMES <- toupper(changed)
[17:02:55.998]                 args <- list()
[17:02:55.998]                 for (kk in seq_along(NAMES)) {
[17:02:55.998]                   name <- changed[[kk]]
[17:02:55.998]                   NAME <- NAMES[[kk]]
[17:02:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.998]                     next
[17:02:55.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.998]                 }
[17:02:55.998]                 NAMES <- toupper(added)
[17:02:55.998]                 for (kk in seq_along(NAMES)) {
[17:02:55.998]                   name <- added[[kk]]
[17:02:55.998]                   NAME <- NAMES[[kk]]
[17:02:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.998]                     next
[17:02:55.998]                   args[[name]] <- ""
[17:02:55.998]                 }
[17:02:55.998]                 NAMES <- toupper(removed)
[17:02:55.998]                 for (kk in seq_along(NAMES)) {
[17:02:55.998]                   name <- removed[[kk]]
[17:02:55.998]                   NAME <- NAMES[[kk]]
[17:02:55.998]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:55.998]                     next
[17:02:55.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:55.998]                 }
[17:02:55.998]                 if (length(args) > 0) 
[17:02:55.998]                   base::do.call(base::Sys.setenv, args = args)
[17:02:55.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:55.998]             }
[17:02:55.998]             else {
[17:02:55.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:55.998]             }
[17:02:55.998]             {
[17:02:55.998]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:55.998]                   0L) {
[17:02:55.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:55.998]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:55.998]                   base::options(opts)
[17:02:55.998]                 }
[17:02:55.998]                 {
[17:02:55.998]                   {
[17:02:55.998]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:55.998]                     NULL
[17:02:55.998]                   }
[17:02:55.998]                   options(future.plan = NULL)
[17:02:55.998]                   if (is.na(NA_character_)) 
[17:02:55.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:55.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:55.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:55.998]                     .init = FALSE)
[17:02:55.998]                 }
[17:02:55.998]             }
[17:02:55.998]         }
[17:02:55.998]     })
[17:02:55.998]     if (TRUE) {
[17:02:55.998]         base::sink(type = "output", split = FALSE)
[17:02:55.998]         if (TRUE) {
[17:02:55.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:55.998]         }
[17:02:55.998]         else {
[17:02:55.998]             ...future.result["stdout"] <- base::list(NULL)
[17:02:55.998]         }
[17:02:55.998]         base::close(...future.stdout)
[17:02:55.998]         ...future.stdout <- NULL
[17:02:55.998]     }
[17:02:55.998]     ...future.result$conditions <- ...future.conditions
[17:02:55.998]     ...future.result$finished <- base::Sys.time()
[17:02:55.998]     ...future.result
[17:02:55.998] }
[17:02:56.000] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[17:02:56.001] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[17:02:56.001] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[17:02:56.001] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[17:02:56.002] MultisessionFuture started
[17:02:56.002] - Launch lazy future ... done
[17:02:56.002] run() for ‘MultisessionFuture’ ... done
[17:02:56.002] result() for ClusterFuture ...
[17:02:56.002] receiveMessageFromWorker() for ClusterFuture ...
[17:02:56.002] - Validating connection of MultisessionFuture
[17:02:56.045] - received message: FutureResult
[17:02:56.046] - Received FutureResult
[17:02:56.046] - Erased future from FutureRegistry
[17:02:56.046] result() for ClusterFuture ...
[17:02:56.046] - result already collected: FutureResult
[17:02:56.046] result() for ClusterFuture ... done
[17:02:56.046] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:56.046] result() for ClusterFuture ... done
[17:02:56.046] result() for ClusterFuture ...
[17:02:56.046] - result already collected: FutureResult
[17:02:56.046] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[17:02:56.047] plan(): Setting new future strategy stack:
[17:02:56.047] List of future strategies:
[17:02:56.047] 1. FutureStrategy:
[17:02:56.047]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:56.047]    - tweaked: FALSE
[17:02:56.047]    - call: future::plan(oplan)
[17:02:56.048] plan(): nbrOfWorkers() = 1
> 
