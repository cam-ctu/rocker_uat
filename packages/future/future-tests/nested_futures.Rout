
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:47:30.297] plan(): Setting new future strategy stack:
[17:47:30.298] List of future strategies:
[17:47:30.298] 1. sequential:
[17:47:30.298]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.298]    - tweaked: FALSE
[17:47:30.298]    - call: future::plan("sequential")
[17:47:30.309] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[17:47:30.362] plan(): Setting new future strategy stack:
[17:47:30.363] List of future strategies:
[17:47:30.363] 1. sequential:
[17:47:30.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.363]    - tweaked: FALSE
[17:47:30.363]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.363] 2. sequential:
[17:47:30.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.363]    - tweaked: FALSE
[17:47:30.363]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.373] plan(): nbrOfWorkers() = 1
[17:47:30.376] getGlobalsAndPackages() ...
[17:47:30.376] Searching for globals...
[17:47:30.397] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:30.397] Searching for globals ... DONE
[17:47:30.397] Resolving globals: FALSE
[17:47:30.399] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[17:47:30.399] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:30.401] - globals: [2] ‘nested’, ‘strategy2’
[17:47:30.401] - packages: [1] ‘future’
[17:47:30.401] getGlobalsAndPackages() ... DONE
[17:47:30.402] run() for ‘Future’ ...
[17:47:30.402] - state: ‘created’
[17:47:30.402] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.403] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.403]   - Field: ‘label’
[17:47:30.403]   - Field: ‘local’
[17:47:30.403]   - Field: ‘owner’
[17:47:30.403]   - Field: ‘envir’
[17:47:30.403]   - Field: ‘packages’
[17:47:30.403]   - Field: ‘gc’
[17:47:30.403]   - Field: ‘conditions’
[17:47:30.403]   - Field: ‘expr’
[17:47:30.404]   - Field: ‘uuid’
[17:47:30.404]   - Field: ‘seed’
[17:47:30.404]   - Field: ‘version’
[17:47:30.404]   - Field: ‘result’
[17:47:30.404]   - Field: ‘asynchronous’
[17:47:30.404]   - Field: ‘calls’
[17:47:30.404]   - Field: ‘globals’
[17:47:30.404]   - Field: ‘stdout’
[17:47:30.404]   - Field: ‘earlySignal’
[17:47:30.404]   - Field: ‘lazy’
[17:47:30.404]   - Field: ‘state’
[17:47:30.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.405] - Launch lazy future ...
[17:47:30.405] Packages needed by the future expression (n = 1): ‘future’
[17:47:30.405] Packages needed by future strategies (n = 1): ‘future’
[17:47:30.406] {
[17:47:30.406]     {
[17:47:30.406]         {
[17:47:30.406]             ...future.startTime <- base::Sys.time()
[17:47:30.406]             {
[17:47:30.406]                 {
[17:47:30.406]                   {
[17:47:30.406]                     {
[17:47:30.406]                       base::local({
[17:47:30.406]                         has_future <- base::requireNamespace("future", 
[17:47:30.406]                           quietly = TRUE)
[17:47:30.406]                         if (has_future) {
[17:47:30.406]                           ns <- base::getNamespace("future")
[17:47:30.406]                           version <- ns[[".package"]][["version"]]
[17:47:30.406]                           if (is.null(version)) 
[17:47:30.406]                             version <- utils::packageVersion("future")
[17:47:30.406]                         }
[17:47:30.406]                         else {
[17:47:30.406]                           version <- NULL
[17:47:30.406]                         }
[17:47:30.406]                         if (!has_future || version < "1.8.0") {
[17:47:30.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.406]                             "", base::R.version$version.string), 
[17:47:30.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.406]                               "release", "version")], collapse = " "), 
[17:47:30.406]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.406]                             info)
[17:47:30.406]                           info <- base::paste(info, collapse = "; ")
[17:47:30.406]                           if (!has_future) {
[17:47:30.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.406]                               info)
[17:47:30.406]                           }
[17:47:30.406]                           else {
[17:47:30.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.406]                               info, version)
[17:47:30.406]                           }
[17:47:30.406]                           base::stop(msg)
[17:47:30.406]                         }
[17:47:30.406]                       })
[17:47:30.406]                     }
[17:47:30.406]                     base::local({
[17:47:30.406]                       for (pkg in "future") {
[17:47:30.406]                         base::loadNamespace(pkg)
[17:47:30.406]                         base::library(pkg, character.only = TRUE)
[17:47:30.406]                       }
[17:47:30.406]                     })
[17:47:30.406]                   }
[17:47:30.406]                   ...future.strategy.old <- future::plan("list")
[17:47:30.406]                   options(future.plan = NULL)
[17:47:30.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.406]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:30.406]                   {
[17:47:30.406]                     future <- SequentialFuture(..., envir = envir)
[17:47:30.406]                     if (!future$lazy) 
[17:47:30.406]                       future <- run(future)
[17:47:30.406]                     invisible(future)
[17:47:30.406]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:30.406]                 }
[17:47:30.406]                 ...future.workdir <- getwd()
[17:47:30.406]             }
[17:47:30.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.406]         }
[17:47:30.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.406]             base::names(...future.oldOptions))
[17:47:30.406]     }
[17:47:30.406]     if (FALSE) {
[17:47:30.406]     }
[17:47:30.406]     else {
[17:47:30.406]         if (TRUE) {
[17:47:30.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.406]                 open = "w")
[17:47:30.406]         }
[17:47:30.406]         else {
[17:47:30.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.406]         }
[17:47:30.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.406]             base::sink(type = "output", split = FALSE)
[17:47:30.406]             base::close(...future.stdout)
[17:47:30.406]         }, add = TRUE)
[17:47:30.406]     }
[17:47:30.406]     ...future.frame <- base::sys.nframe()
[17:47:30.406]     ...future.conditions <- base::list()
[17:47:30.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.406]     if (FALSE) {
[17:47:30.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.406]     }
[17:47:30.406]     ...future.result <- base::tryCatch({
[17:47:30.406]         base::withCallingHandlers({
[17:47:30.406]             ...future.value <- base::withVisible(base::local({
[17:47:30.406]                 a <- 1L
[17:47:30.406]                 plan_a <- unclass(future::plan("list"))
[17:47:30.406]                 nested_a <- nested[-1]
[17:47:30.406]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:30.406]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.406]                   strategy2))
[17:47:30.406]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:30.406]                   "init") <- NULL
[17:47:30.406]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:30.406]                   "init") <- NULL
[17:47:30.406]                 stopifnot(all.equal(plan_a, nested_a))
[17:47:30.406]                 y %<-% {
[17:47:30.406]                   b <- 2L
[17:47:30.406]                   plan_b <- future::plan("list")
[17:47:30.406]                   nested_b <- nested_a[-1]
[17:47:30.406]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:30.406]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.406]                     "sequential"))
[17:47:30.406]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:30.406]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:30.406]                 }
[17:47:30.406]                 y
[17:47:30.406]             }))
[17:47:30.406]             future::FutureResult(value = ...future.value$value, 
[17:47:30.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.406]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.406]                     ...future.globalenv.names))
[17:47:30.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.406]         }, condition = base::local({
[17:47:30.406]             c <- base::c
[17:47:30.406]             inherits <- base::inherits
[17:47:30.406]             invokeRestart <- base::invokeRestart
[17:47:30.406]             length <- base::length
[17:47:30.406]             list <- base::list
[17:47:30.406]             seq.int <- base::seq.int
[17:47:30.406]             signalCondition <- base::signalCondition
[17:47:30.406]             sys.calls <- base::sys.calls
[17:47:30.406]             `[[` <- base::`[[`
[17:47:30.406]             `+` <- base::`+`
[17:47:30.406]             `<<-` <- base::`<<-`
[17:47:30.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.406]                   3L)]
[17:47:30.406]             }
[17:47:30.406]             function(cond) {
[17:47:30.406]                 is_error <- inherits(cond, "error")
[17:47:30.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.406]                   NULL)
[17:47:30.406]                 if (is_error) {
[17:47:30.406]                   sessionInformation <- function() {
[17:47:30.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.406]                       search = base::search(), system = base::Sys.info())
[17:47:30.406]                   }
[17:47:30.406]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.406]                     cond$call), session = sessionInformation(), 
[17:47:30.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.406]                   signalCondition(cond)
[17:47:30.406]                 }
[17:47:30.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.406]                 "immediateCondition"))) {
[17:47:30.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.406]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.406]                   if (TRUE && !signal) {
[17:47:30.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.406]                     {
[17:47:30.406]                       inherits <- base::inherits
[17:47:30.406]                       invokeRestart <- base::invokeRestart
[17:47:30.406]                       is.null <- base::is.null
[17:47:30.406]                       muffled <- FALSE
[17:47:30.406]                       if (inherits(cond, "message")) {
[17:47:30.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.406]                         if (muffled) 
[17:47:30.406]                           invokeRestart("muffleMessage")
[17:47:30.406]                       }
[17:47:30.406]                       else if (inherits(cond, "warning")) {
[17:47:30.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.406]                         if (muffled) 
[17:47:30.406]                           invokeRestart("muffleWarning")
[17:47:30.406]                       }
[17:47:30.406]                       else if (inherits(cond, "condition")) {
[17:47:30.406]                         if (!is.null(pattern)) {
[17:47:30.406]                           computeRestarts <- base::computeRestarts
[17:47:30.406]                           grepl <- base::grepl
[17:47:30.406]                           restarts <- computeRestarts(cond)
[17:47:30.406]                           for (restart in restarts) {
[17:47:30.406]                             name <- restart$name
[17:47:30.406]                             if (is.null(name)) 
[17:47:30.406]                               next
[17:47:30.406]                             if (!grepl(pattern, name)) 
[17:47:30.406]                               next
[17:47:30.406]                             invokeRestart(restart)
[17:47:30.406]                             muffled <- TRUE
[17:47:30.406]                             break
[17:47:30.406]                           }
[17:47:30.406]                         }
[17:47:30.406]                       }
[17:47:30.406]                       invisible(muffled)
[17:47:30.406]                     }
[17:47:30.406]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.406]                   }
[17:47:30.406]                 }
[17:47:30.406]                 else {
[17:47:30.406]                   if (TRUE) {
[17:47:30.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.406]                     {
[17:47:30.406]                       inherits <- base::inherits
[17:47:30.406]                       invokeRestart <- base::invokeRestart
[17:47:30.406]                       is.null <- base::is.null
[17:47:30.406]                       muffled <- FALSE
[17:47:30.406]                       if (inherits(cond, "message")) {
[17:47:30.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.406]                         if (muffled) 
[17:47:30.406]                           invokeRestart("muffleMessage")
[17:47:30.406]                       }
[17:47:30.406]                       else if (inherits(cond, "warning")) {
[17:47:30.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.406]                         if (muffled) 
[17:47:30.406]                           invokeRestart("muffleWarning")
[17:47:30.406]                       }
[17:47:30.406]                       else if (inherits(cond, "condition")) {
[17:47:30.406]                         if (!is.null(pattern)) {
[17:47:30.406]                           computeRestarts <- base::computeRestarts
[17:47:30.406]                           grepl <- base::grepl
[17:47:30.406]                           restarts <- computeRestarts(cond)
[17:47:30.406]                           for (restart in restarts) {
[17:47:30.406]                             name <- restart$name
[17:47:30.406]                             if (is.null(name)) 
[17:47:30.406]                               next
[17:47:30.406]                             if (!grepl(pattern, name)) 
[17:47:30.406]                               next
[17:47:30.406]                             invokeRestart(restart)
[17:47:30.406]                             muffled <- TRUE
[17:47:30.406]                             break
[17:47:30.406]                           }
[17:47:30.406]                         }
[17:47:30.406]                       }
[17:47:30.406]                       invisible(muffled)
[17:47:30.406]                     }
[17:47:30.406]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.406]                   }
[17:47:30.406]                 }
[17:47:30.406]             }
[17:47:30.406]         }))
[17:47:30.406]     }, error = function(ex) {
[17:47:30.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.406]                 ...future.rng), started = ...future.startTime, 
[17:47:30.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.406]             version = "1.8"), class = "FutureResult")
[17:47:30.406]     }, finally = {
[17:47:30.406]         if (!identical(...future.workdir, getwd())) 
[17:47:30.406]             setwd(...future.workdir)
[17:47:30.406]         {
[17:47:30.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.406]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.406]             }
[17:47:30.406]             base::options(...future.oldOptions)
[17:47:30.406]             if (.Platform$OS.type == "windows") {
[17:47:30.406]                 old_names <- names(...future.oldEnvVars)
[17:47:30.406]                 envs <- base::Sys.getenv()
[17:47:30.406]                 names <- names(envs)
[17:47:30.406]                 common <- intersect(names, old_names)
[17:47:30.406]                 added <- setdiff(names, old_names)
[17:47:30.406]                 removed <- setdiff(old_names, names)
[17:47:30.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.406]                   envs[common]]
[17:47:30.406]                 NAMES <- toupper(changed)
[17:47:30.406]                 args <- list()
[17:47:30.406]                 for (kk in seq_along(NAMES)) {
[17:47:30.406]                   name <- changed[[kk]]
[17:47:30.406]                   NAME <- NAMES[[kk]]
[17:47:30.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.406]                     next
[17:47:30.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.406]                 }
[17:47:30.406]                 NAMES <- toupper(added)
[17:47:30.406]                 for (kk in seq_along(NAMES)) {
[17:47:30.406]                   name <- added[[kk]]
[17:47:30.406]                   NAME <- NAMES[[kk]]
[17:47:30.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.406]                     next
[17:47:30.406]                   args[[name]] <- ""
[17:47:30.406]                 }
[17:47:30.406]                 NAMES <- toupper(removed)
[17:47:30.406]                 for (kk in seq_along(NAMES)) {
[17:47:30.406]                   name <- removed[[kk]]
[17:47:30.406]                   NAME <- NAMES[[kk]]
[17:47:30.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.406]                     next
[17:47:30.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.406]                 }
[17:47:30.406]                 if (length(args) > 0) 
[17:47:30.406]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.406]             }
[17:47:30.406]             else {
[17:47:30.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.406]             }
[17:47:30.406]             {
[17:47:30.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.406]                   0L) {
[17:47:30.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.406]                   base::options(opts)
[17:47:30.406]                 }
[17:47:30.406]                 {
[17:47:30.406]                   {
[17:47:30.406]                     NULL
[17:47:30.406]                     RNGkind("Mersenne-Twister")
[17:47:30.406]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.406]                       inherits = FALSE)
[17:47:30.406]                   }
[17:47:30.406]                   options(future.plan = NULL)
[17:47:30.406]                   if (is.na(NA_character_)) 
[17:47:30.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.406]                     .init = FALSE)
[17:47:30.406]                 }
[17:47:30.406]             }
[17:47:30.406]         }
[17:47:30.406]     })
[17:47:30.406]     if (TRUE) {
[17:47:30.406]         base::sink(type = "output", split = FALSE)
[17:47:30.406]         if (TRUE) {
[17:47:30.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.406]         }
[17:47:30.406]         else {
[17:47:30.406]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.406]         }
[17:47:30.406]         base::close(...future.stdout)
[17:47:30.406]         ...future.stdout <- NULL
[17:47:30.406]     }
[17:47:30.406]     ...future.result$conditions <- ...future.conditions
[17:47:30.406]     ...future.result$finished <- base::Sys.time()
[17:47:30.406]     ...future.result
[17:47:30.406] }
[17:47:30.408] assign_globals() ...
[17:47:30.408] List of 2
[17:47:30.408]  $ nested   :List of 2
[17:47:30.408]   ..$ a:function (..., envir = parent.frame())  
[17:47:30.408]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:30.408]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.408]   ..$ b:function (..., envir = parent.frame())  
[17:47:30.408]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:30.408]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.408]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:30.408]  $ strategy2: chr "sequential"
[17:47:30.408]  - attr(*, "where")=List of 2
[17:47:30.408]   ..$ nested   :<environment: R_EmptyEnv> 
[17:47:30.408]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:47:30.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.408]  - attr(*, "resolved")= logi FALSE
[17:47:30.408]  - attr(*, "total_size")= num 23144
[17:47:30.408]  - attr(*, "already-done")= logi TRUE
[17:47:30.415] - copied ‘nested’ to environment
[17:47:30.415] - copied ‘strategy2’ to environment
[17:47:30.415] assign_globals() ... done
[17:47:30.416] plan(): Setting new future strategy stack:
[17:47:30.416] List of future strategies:
[17:47:30.416] 1. sequential:
[17:47:30.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.416]    - tweaked: FALSE
[17:47:30.416]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.416] plan(): nbrOfWorkers() = 1
[17:47:30.452] plan(): Setting new future strategy stack:
[17:47:30.452] List of future strategies:
[17:47:30.452] 1. sequential:
[17:47:30.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.452]    - tweaked: FALSE
[17:47:30.452]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.452] 2. sequential:
[17:47:30.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.452]    - tweaked: FALSE
[17:47:30.452]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.453] plan(): nbrOfWorkers() = 1
[17:47:30.453] SequentialFuture started (and completed)
[17:47:30.454] signalConditions() ...
[17:47:30.454]  - include = ‘immediateCondition’
[17:47:30.454]  - exclude = 
[17:47:30.454]  - resignal = FALSE
[17:47:30.454]  - Number of conditions: 54
[17:47:30.455] signalConditions() ... done
[17:47:30.455] - Launch lazy future ... done
[17:47:30.455] run() for ‘SequentialFuture’ ... done
[17:47:30.455] signalConditions() ...
[17:47:30.455]  - include = ‘immediateCondition’
[17:47:30.455]  - exclude = 
[17:47:30.455]  - resignal = FALSE
[17:47:30.455]  - Number of conditions: 54
[17:47:30.455] signalConditions() ... done
[17:47:30.456] Future state: ‘finished’
[17:47:30.456] signalConditions() ...
[17:47:30.456]  - include = ‘condition’
[17:47:30.456]  - exclude = ‘immediateCondition’
[17:47:30.456]  - resignal = TRUE
[17:47:30.456]  - Number of conditions: 54
[17:47:30.456]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.418] getGlobalsAndPackages() ...
[17:47:30.456]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.418] Searching for globals...
[17:47:30.456]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.436] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:47:30.456]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.436] Searching for globals ... DONE
[17:47:30.457]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.436] Resolving globals: FALSE
[17:47:30.457]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.437] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[17:47:30.457]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.437] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:47:30.457]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.437] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:47:30.457]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.437] 
[17:47:30.457]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.438] getGlobalsAndPackages() ... DONE
[17:47:30.457]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.438] run() for ‘Future’ ...
[17:47:30.457]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.438] - state: ‘created’
[17:47:30.458]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.458]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.438] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.458]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.458]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘label’
[17:47:30.458]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘local’
[17:47:30.458]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘owner’
[17:47:30.458]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘envir’
[17:47:30.458]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘packages’
[17:47:30.459]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘gc’
[17:47:30.459]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘conditions’
[17:47:30.459]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘expr’
[17:47:30.459]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘uuid’
[17:47:30.459]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.439]   - Field: ‘seed’
[17:47:30.459]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘version’
[17:47:30.459]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘result’
[17:47:30.459]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘asynchronous’
[17:47:30.460]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘calls’
[17:47:30.460]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘globals’
[17:47:30.460]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘stdout’
[17:47:30.460]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘earlySignal’
[17:47:30.460]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘lazy’
[17:47:30.460]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440]   - Field: ‘state’
[17:47:30.460]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.460]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.441] - Launch lazy future ...
[17:47:30.461]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.441] Packages needed by the future expression (n = 0): <none>
[17:47:30.461]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.441] Packages needed by future strategies (n = 0): <none>
[17:47:30.461]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.441] {
[17:47:30.441]     {
[17:47:30.441]         {
[17:47:30.441]             ...future.startTime <- base::Sys.time()
[17:47:30.441]             {
[17:47:30.441]                 {
[17:47:30.441]                   {
[17:47:30.441]                     base::local({
[17:47:30.441]                       has_future <- base::requireNamespace("future", 
[17:47:30.441]                         quietly = TRUE)
[17:47:30.441]                       if (has_future) {
[17:47:30.441]                         ns <- base::getNamespace("future")
[17:47:30.441]                         version <- ns[[".package"]][["version"]]
[17:47:30.441]                         if (is.null(version)) 
[17:47:30.441]                           version <- utils::packageVersion("future")
[17:47:30.441]                       }
[17:47:30.441]                       else {
[17:47:30.441]                         version <- NULL
[17:47:30.441]                       }
[17:47:30.441]                       if (!has_future || version < "1.8.0") {
[17:47:30.441]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.441]                           "", base::R.version$version.string), 
[17:47:30.441]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:30.441]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.441]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.441]                             "release", "version")], collapse = " "), 
[17:47:30.441]                           hostname = base::Sys.info()[["nodename"]])
[17:47:30.441]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.441]                           info)
[17:47:30.441]                         info <- base::paste(info, collapse = "; ")
[17:47:30.441]                         if (!has_future) {
[17:47:30.441]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.441]                             info)
[17:47:30.441]                         }
[17:47:30.441]                         else {
[17:47:30.441]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.441]                             info, version)
[17:47:30.441]                         }
[17:47:30.441]                         base::stop(msg)
[17:47:30.441]                       }
[17:47:30.441]                     })
[17:47:30.441]                   }
[17:47:30.441]                   ...future.strategy.old <- future::plan("list")
[17:47:30.441]                   options(future.plan = NULL)
[17:47:30.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:30.441]                 }
[17:47:30.441]                 ...future.workdir <- getwd()
[17:47:30.441]             }
[17:47:30.441]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.441]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.441]         }
[17:47:30.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.441]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.441]             base::names(...future.oldOptions))
[17:47:30.441]     }
[17:47:30.441]     if (FALSE) {
[17:47:30.441]     }
[17:47:30.441]     else {
[17:47:30.441]         if (TRUE) {
[17:47:30.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.441]                 open = "w")
[17:47:30.441]         }
[17:47:30.441]         else {
[17:47:30.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.441]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.441]         }
[17:47:30.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.441]             base::sink(type = "output", split = FALSE)
[17:47:30.441]             base::close(...future.stdout)
[17:47:30.441]         }, add = TRUE)
[17:47:30.441]     }
[17:47:30.441]     ...future.frame <- base::sys.nframe()
[17:47:30.441]     ...future.conditions <- base::list()
[17:47:30.441]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.441]     if (FALSE) {
[17:47:30.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.441]     }
[17:47:30.441]     ...future.result <- base::tryCatch({
[17:47:30.441]         base::withCallingHandlers({
[17:47:30.441]             ...future.value <- base::withVisible(base::local({
[17:47:30.441]                 b <- 2L
[17:47:30.441]                 plan_b <- future::plan("list")
[17:47:30.441]                 nested_b <- nested_a[-1]
[17:47:30.441]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:30.441]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.441]                   "sequential"))
[17:47:30.441]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:30.441]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:30.441]             }))
[17:47:30.441]             future::FutureResult(value = ...future.value$value, 
[17:47:30.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.441]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.441]                     ...future.globalenv.names))
[17:47:30.441]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.441]         }, condition = base::local({
[17:47:30.441]             c <- base::c
[17:47:30.441]             inherits <- base::inherits
[17:47:30.441]             invokeRestart <- base::invokeRestart
[17:47:30.441]             length <- base::length
[17:47:30.441]             list <- base::list
[17:47:30.441]             seq.int <- base::seq.int
[17:47:30.441]             signalCondition <- base::signalCondition
[17:47:30.441]             sys.calls <- base::sys.calls
[17:47:30.441]             `[[` <- base::`[[`
[17:47:30.441]             `+` <- base::`+`
[17:47:30.441]             `<<-` <- base::`<<-`
[17:47:30.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.441]                   3L)]
[17:47:30.441]             }
[17:47:30.441]             function(cond) {
[17:47:30.441]                 is_error <- inherits(cond, "error")
[17:47:30.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.441]                   NULL)
[17:47:30.441]                 if (is_error) {
[17:47:30.441]                   sessionInformation <- function() {
[17:47:30.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.441]                       search = base::search(), system = base::Sys.info())
[17:47:30.441]                   }
[17:47:30.441]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.441]                     cond$call), session = sessionInformation(), 
[17:47:30.441]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.441]                   signalCondition(cond)
[17:47:30.441]                 }
[17:47:30.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.441]                 "immediateCondition"))) {
[17:47:30.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.441]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.441]                   if (TRUE && !signal) {
[17:47:30.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.441]                     {
[17:47:30.441]                       inherits <- base::inherits
[17:47:30.441]                       invokeRestart <- base::invokeRestart
[17:47:30.441]                       is.null <- base::is.null
[17:47:30.441]                       muffled <- FALSE
[17:47:30.441]                       if (inherits(cond, "message")) {
[17:47:30.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.441]                         if (muffled) 
[17:47:30.441]                           invokeRestart("muffleMessage")
[17:47:30.441]                       }
[17:47:30.441]                       else if (inherits(cond, "warning")) {
[17:47:30.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.441]                         if (muffled) 
[17:47:30.441]                           invokeRestart("muffleWarning")
[17:47:30.441]                       }
[17:47:30.441]                       else if (inherits(cond, "condition")) {
[17:47:30.441]                         if (!is.null(pattern)) {
[17:47:30.441]                           computeRestarts <- base::computeRestarts
[17:47:30.441]                           grepl <- base::grepl
[17:47:30.441]                           restarts <- computeRestarts(cond)
[17:47:30.441]                           for (restart in restarts) {
[17:47:30.441]                             name <- restart$name
[17:47:30.441]                             if (is.null(name)) 
[17:47:30.441]                               next
[17:47:30.441]                             if (!grepl(pattern, name)) 
[17:47:30.441]                               next
[17:47:30.441]                             invokeRestart(restart)
[17:47:30.441]                             muffled <- TRUE
[17:47:30.441]                             break
[17:47:30.441]                           }
[17:47:30.441]                         }
[17:47:30.441]                       }
[17:47:30.441]                       invisible(muffled)
[17:47:30.441]                     }
[17:47:30.441]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.441]                   }
[17:47:30.441]                 }
[17:47:30.441]                 else {
[17:47:30.441]                   if (TRUE) {
[17:47:30.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.441]                     {
[17:47:30.441]                       inherits <- base::inherits
[17:47:30.441]                       invokeRestart <- base::invokeRestart
[17:47:30.441]                       is.null <- base::is.null
[17:47:30.441]                       muffled <- FALSE
[17:47:30.441]                       if (inherits(cond, "message")) {
[17:47:30.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.441]                         if (muffled) 
[17:47:30.441]                           invokeRestart("muffleMessage")
[17:47:30.441]                       }
[17:47:30.441]                       else if (inherits(cond, "warning")) {
[17:47:30.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.441]                         if (muffled) 
[17:47:30.441]                           invokeRestart("muffleWarning")
[17:47:30.441]                       }
[17:47:30.441]                       else if (inherits(cond, "condition")) {
[17:47:30.441]                         if (!is.null(pattern)) {
[17:47:30.441]                           computeRestarts <- base::computeRestarts
[17:47:30.441]                           grepl <- base::grepl
[17:47:30.441]                           restarts <- computeRestarts(cond)
[17:47:30.441]                           for (restart in restarts) {
[17:47:30.441]                             name <- restart$name
[17:47:30.441]                             if (is.null(name)) 
[17:47:30.441]                               next
[17:47:30.441]                             if (!grepl(pattern, name)) 
[17:47:30.441]                               next
[17:47:30.441]                             invokeRestart(restart)
[17:47:30.441]                             muffled <- TRUE
[17:47:30.441]                             break
[17:47:30.441]                           }
[17:47:30.441]                         }
[17:47:30.441]                       }
[17:47:30.441]                       invisible(muffled)
[17:47:30.441]                     }
[17:47:30.441]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.441]                   }
[17:47:30.441]                 }
[17:47:30.441]             }
[17:47:30.441]         }))
[17:47:30.441]     }, error = function(ex) {
[17:47:30.441]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.441]                 ...future.rng), started = ...future.startTime, 
[17:47:30.441]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.441]             version = "1.8"), class = "FutureResult")
[17:47:30.441]     }, finally = {
[17:47:30.441]         if (!identical(...future.workdir, getwd())) 
[17:47:30.441]             setwd(...future.workdir)
[17:47:30.441]         {
[17:47:30.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.441]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.441]             }
[17:47:30.441]             base::options(...future.oldOptions)
[17:47:30.441]             if (.Platform$OS.type == "windows") {
[17:47:30.441]                 old_names <- names(...future.oldEnvVars)
[17:47:30.441]                 envs <- base::Sys.getenv()
[17:47:30.441]                 names <- names(envs)
[17:47:30.441]                 common <- intersect(names, old_names)
[17:47:30.441]                 added <- setdiff(names, old_names)
[17:47:30.441]                 removed <- setdiff(old_names, names)
[17:47:30.441]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.441]                   envs[common]]
[17:47:30.441]                 NAMES <- toupper(changed)
[17:47:30.441]                 args <- list()
[17:47:30.441]                 for (kk in seq_along(NAMES)) {
[17:47:30.441]                   name <- changed[[kk]]
[17:47:30.441]                   NAME <- NAMES[[kk]]
[17:47:30.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.441]                     next
[17:47:30.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.441]                 }
[17:47:30.441]                 NAMES <- toupper(added)
[17:47:30.441]                 for (kk in seq_along(NAMES)) {
[17:47:30.441]                   name <- added[[kk]]
[17:47:30.441]                   NAME <- NAMES[[kk]]
[17:47:30.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.441]                     next
[17:47:30.441]                   args[[name]] <- ""
[17:47:30.441]                 }
[17:47:30.441]                 NAMES <- toupper(removed)
[17:47:30.441]                 for (kk in seq_along(NAMES)) {
[17:47:30.441]                   name <- removed[[kk]]
[17:47:30.441]                   NAME <- NAMES[[kk]]
[17:47:30.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.441]                     next
[17:47:30.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.441]                 }
[17:47:30.441]                 if (length(args) > 0) 
[17:47:30.441]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.441]             }
[17:47:30.441]             else {
[17:47:30.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.441]             }
[17:47:30.441]             {
[17:47:30.441]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.441]                   0L) {
[17:47:30.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.441]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.441]                   base::options(opts)
[17:47:30.441]                 }
[17:47:30.441]                 {
[17:47:30.441]                   {
[17:47:30.441]                     NULL
[17:47:30.441]                     RNGkind("Mersenne-Twister")
[17:47:30.441]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.441]                       inherits = FALSE)
[17:47:30.441]                   }
[17:47:30.441]                   options(future.plan = NULL)
[17:47:30.441]                   if (is.na(NA_character_)) 
[17:47:30.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.441]                     .init = FALSE)
[17:47:30.441]                 }
[17:47:30.441]             }
[17:47:30.441]         }
[17:47:30.441]     })
[17:47:30.441]     if (TRUE) {
[17:47:30.441]         base::sink(type = "output", split = FALSE)
[17:47:30.441]         if (TRUE) {
[17:47:30.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.441]         }
[17:47:30.441]         else {
[17:47:30.441]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.441]         }
[17:47:30.441]         base::close(...future.stdout)
[17:47:30.441]         ...future.stdout <- NULL
[17:47:30.441]     }
[17:47:30.441]     ...future.result$conditions <- ...future.conditions
[17:47:30.441]     ...future.result$finished <- base::Sys.time()
[17:47:30.441]     ...future.result
[17:47:30.441] }
[17:47:30.461]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.443] assign_globals() ...
[17:47:30.461]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.443] List of 3
[17:47:30.443]  $ nested_a:List of 1
[17:47:30.443]   ..$ b:function (..., envir = parent.frame())  
[17:47:30.443]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:30.443]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.443]  $ a       : int 1
[17:47:30.443]  $ plan_a  :List of 1
[17:47:30.443]   ..$ b:function (..., envir = parent.frame())  
[17:47:30.443]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:30.443]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.443]  - attr(*, "where")=List of 3
[17:47:30.443]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:47:30.443]   ..$ a       :<environment: R_EmptyEnv> 
[17:47:30.443]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:47:30.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.443]  - attr(*, "resolved")= logi FALSE
[17:47:30.443]  - attr(*, "total_size")= num 23080
[17:47:30.443]  - attr(*, "already-done")= logi TRUE
[17:47:30.461]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.448] - copied ‘nested_a’ to environment
[17:47:30.461]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.448] - copied ‘a’ to environment
[17:47:30.461]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.448] - copied ‘plan_a’ to environment
[17:47:30.462]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.448] assign_globals() ... done
[17:47:30.462]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.448] plan(): Setting new future strategy stack:
[17:47:30.462]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.448] List of future strategies:
[17:47:30.448] 1. sequential:
[17:47:30.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.448]    - tweaked: FALSE
[17:47:30.448]    - call: NULL
[17:47:30.462]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.449] plan(): nbrOfWorkers() = 1
[17:47:30.462]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.450] plan(): Setting new future strategy stack:
[17:47:30.462]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.450] List of future strategies:
[17:47:30.450] 1. sequential:
[17:47:30.450]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.450]    - tweaked: FALSE
[17:47:30.450]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.462]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.450] plan(): nbrOfWorkers() = 1
[17:47:30.462]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.451] SequentialFuture started (and completed)
[17:47:30.463]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.451] - Launch lazy future ... done
[17:47:30.463]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.451] run() for ‘SequentialFuture’ ... done
[17:47:30.463] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:30.468] getGlobalsAndPackages() ...
[17:47:30.468] Searching for globals...
[17:47:30.469] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:30.469] Searching for globals ... DONE
[17:47:30.469] Resolving globals: FALSE
[17:47:30.470] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:30.470] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:30.470] - globals: [1] ‘data’
[17:47:30.470] - packages: [1] ‘future’
[17:47:30.470] getGlobalsAndPackages() ... DONE
[17:47:30.470] run() for ‘Future’ ...
[17:47:30.471] - state: ‘created’
[17:47:30.471] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.471] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.471]   - Field: ‘label’
[17:47:30.471]   - Field: ‘local’
[17:47:30.471]   - Field: ‘owner’
[17:47:30.471]   - Field: ‘envir’
[17:47:30.472]   - Field: ‘packages’
[17:47:30.472]   - Field: ‘gc’
[17:47:30.472]   - Field: ‘conditions’
[17:47:30.472]   - Field: ‘expr’
[17:47:30.472]   - Field: ‘uuid’
[17:47:30.472]   - Field: ‘seed’
[17:47:30.472]   - Field: ‘version’
[17:47:30.472]   - Field: ‘result’
[17:47:30.472]   - Field: ‘asynchronous’
[17:47:30.472]   - Field: ‘calls’
[17:47:30.472]   - Field: ‘globals’
[17:47:30.472]   - Field: ‘stdout’
[17:47:30.473]   - Field: ‘earlySignal’
[17:47:30.473]   - Field: ‘lazy’
[17:47:30.473]   - Field: ‘state’
[17:47:30.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.473] - Launch lazy future ...
[17:47:30.473] Packages needed by the future expression (n = 1): ‘future’
[17:47:30.473] Packages needed by future strategies (n = 1): ‘future’
[17:47:30.474] {
[17:47:30.474]     {
[17:47:30.474]         {
[17:47:30.474]             ...future.startTime <- base::Sys.time()
[17:47:30.474]             {
[17:47:30.474]                 {
[17:47:30.474]                   {
[17:47:30.474]                     {
[17:47:30.474]                       base::local({
[17:47:30.474]                         has_future <- base::requireNamespace("future", 
[17:47:30.474]                           quietly = TRUE)
[17:47:30.474]                         if (has_future) {
[17:47:30.474]                           ns <- base::getNamespace("future")
[17:47:30.474]                           version <- ns[[".package"]][["version"]]
[17:47:30.474]                           if (is.null(version)) 
[17:47:30.474]                             version <- utils::packageVersion("future")
[17:47:30.474]                         }
[17:47:30.474]                         else {
[17:47:30.474]                           version <- NULL
[17:47:30.474]                         }
[17:47:30.474]                         if (!has_future || version < "1.8.0") {
[17:47:30.474]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.474]                             "", base::R.version$version.string), 
[17:47:30.474]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.474]                               "release", "version")], collapse = " "), 
[17:47:30.474]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.474]                             info)
[17:47:30.474]                           info <- base::paste(info, collapse = "; ")
[17:47:30.474]                           if (!has_future) {
[17:47:30.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.474]                               info)
[17:47:30.474]                           }
[17:47:30.474]                           else {
[17:47:30.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.474]                               info, version)
[17:47:30.474]                           }
[17:47:30.474]                           base::stop(msg)
[17:47:30.474]                         }
[17:47:30.474]                       })
[17:47:30.474]                     }
[17:47:30.474]                     base::local({
[17:47:30.474]                       for (pkg in "future") {
[17:47:30.474]                         base::loadNamespace(pkg)
[17:47:30.474]                         base::library(pkg, character.only = TRUE)
[17:47:30.474]                       }
[17:47:30.474]                     })
[17:47:30.474]                   }
[17:47:30.474]                   ...future.strategy.old <- future::plan("list")
[17:47:30.474]                   options(future.plan = NULL)
[17:47:30.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.474]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:30.474]                   {
[17:47:30.474]                     future <- SequentialFuture(..., envir = envir)
[17:47:30.474]                     if (!future$lazy) 
[17:47:30.474]                       future <- run(future)
[17:47:30.474]                     invisible(future)
[17:47:30.474]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:30.474]                 }
[17:47:30.474]                 ...future.workdir <- getwd()
[17:47:30.474]             }
[17:47:30.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.474]         }
[17:47:30.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.474]             base::names(...future.oldOptions))
[17:47:30.474]     }
[17:47:30.474]     if (FALSE) {
[17:47:30.474]     }
[17:47:30.474]     else {
[17:47:30.474]         if (TRUE) {
[17:47:30.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.474]                 open = "w")
[17:47:30.474]         }
[17:47:30.474]         else {
[17:47:30.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.474]         }
[17:47:30.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.474]             base::sink(type = "output", split = FALSE)
[17:47:30.474]             base::close(...future.stdout)
[17:47:30.474]         }, add = TRUE)
[17:47:30.474]     }
[17:47:30.474]     ...future.frame <- base::sys.nframe()
[17:47:30.474]     ...future.conditions <- base::list()
[17:47:30.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.474]     if (FALSE) {
[17:47:30.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.474]     }
[17:47:30.474]     ...future.result <- base::tryCatch({
[17:47:30.474]         base::withCallingHandlers({
[17:47:30.474]             ...future.value <- base::withVisible(base::local({
[17:47:30.474]                 value(future(subset(data, a == 2)))
[17:47:30.474]             }))
[17:47:30.474]             future::FutureResult(value = ...future.value$value, 
[17:47:30.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.474]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.474]                     ...future.globalenv.names))
[17:47:30.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.474]         }, condition = base::local({
[17:47:30.474]             c <- base::c
[17:47:30.474]             inherits <- base::inherits
[17:47:30.474]             invokeRestart <- base::invokeRestart
[17:47:30.474]             length <- base::length
[17:47:30.474]             list <- base::list
[17:47:30.474]             seq.int <- base::seq.int
[17:47:30.474]             signalCondition <- base::signalCondition
[17:47:30.474]             sys.calls <- base::sys.calls
[17:47:30.474]             `[[` <- base::`[[`
[17:47:30.474]             `+` <- base::`+`
[17:47:30.474]             `<<-` <- base::`<<-`
[17:47:30.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.474]                   3L)]
[17:47:30.474]             }
[17:47:30.474]             function(cond) {
[17:47:30.474]                 is_error <- inherits(cond, "error")
[17:47:30.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.474]                   NULL)
[17:47:30.474]                 if (is_error) {
[17:47:30.474]                   sessionInformation <- function() {
[17:47:30.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.474]                       search = base::search(), system = base::Sys.info())
[17:47:30.474]                   }
[17:47:30.474]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.474]                     cond$call), session = sessionInformation(), 
[17:47:30.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.474]                   signalCondition(cond)
[17:47:30.474]                 }
[17:47:30.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.474]                 "immediateCondition"))) {
[17:47:30.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.474]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.474]                   if (TRUE && !signal) {
[17:47:30.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.474]                     {
[17:47:30.474]                       inherits <- base::inherits
[17:47:30.474]                       invokeRestart <- base::invokeRestart
[17:47:30.474]                       is.null <- base::is.null
[17:47:30.474]                       muffled <- FALSE
[17:47:30.474]                       if (inherits(cond, "message")) {
[17:47:30.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.474]                         if (muffled) 
[17:47:30.474]                           invokeRestart("muffleMessage")
[17:47:30.474]                       }
[17:47:30.474]                       else if (inherits(cond, "warning")) {
[17:47:30.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.474]                         if (muffled) 
[17:47:30.474]                           invokeRestart("muffleWarning")
[17:47:30.474]                       }
[17:47:30.474]                       else if (inherits(cond, "condition")) {
[17:47:30.474]                         if (!is.null(pattern)) {
[17:47:30.474]                           computeRestarts <- base::computeRestarts
[17:47:30.474]                           grepl <- base::grepl
[17:47:30.474]                           restarts <- computeRestarts(cond)
[17:47:30.474]                           for (restart in restarts) {
[17:47:30.474]                             name <- restart$name
[17:47:30.474]                             if (is.null(name)) 
[17:47:30.474]                               next
[17:47:30.474]                             if (!grepl(pattern, name)) 
[17:47:30.474]                               next
[17:47:30.474]                             invokeRestart(restart)
[17:47:30.474]                             muffled <- TRUE
[17:47:30.474]                             break
[17:47:30.474]                           }
[17:47:30.474]                         }
[17:47:30.474]                       }
[17:47:30.474]                       invisible(muffled)
[17:47:30.474]                     }
[17:47:30.474]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.474]                   }
[17:47:30.474]                 }
[17:47:30.474]                 else {
[17:47:30.474]                   if (TRUE) {
[17:47:30.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.474]                     {
[17:47:30.474]                       inherits <- base::inherits
[17:47:30.474]                       invokeRestart <- base::invokeRestart
[17:47:30.474]                       is.null <- base::is.null
[17:47:30.474]                       muffled <- FALSE
[17:47:30.474]                       if (inherits(cond, "message")) {
[17:47:30.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.474]                         if (muffled) 
[17:47:30.474]                           invokeRestart("muffleMessage")
[17:47:30.474]                       }
[17:47:30.474]                       else if (inherits(cond, "warning")) {
[17:47:30.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.474]                         if (muffled) 
[17:47:30.474]                           invokeRestart("muffleWarning")
[17:47:30.474]                       }
[17:47:30.474]                       else if (inherits(cond, "condition")) {
[17:47:30.474]                         if (!is.null(pattern)) {
[17:47:30.474]                           computeRestarts <- base::computeRestarts
[17:47:30.474]                           grepl <- base::grepl
[17:47:30.474]                           restarts <- computeRestarts(cond)
[17:47:30.474]                           for (restart in restarts) {
[17:47:30.474]                             name <- restart$name
[17:47:30.474]                             if (is.null(name)) 
[17:47:30.474]                               next
[17:47:30.474]                             if (!grepl(pattern, name)) 
[17:47:30.474]                               next
[17:47:30.474]                             invokeRestart(restart)
[17:47:30.474]                             muffled <- TRUE
[17:47:30.474]                             break
[17:47:30.474]                           }
[17:47:30.474]                         }
[17:47:30.474]                       }
[17:47:30.474]                       invisible(muffled)
[17:47:30.474]                     }
[17:47:30.474]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.474]                   }
[17:47:30.474]                 }
[17:47:30.474]             }
[17:47:30.474]         }))
[17:47:30.474]     }, error = function(ex) {
[17:47:30.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.474]                 ...future.rng), started = ...future.startTime, 
[17:47:30.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.474]             version = "1.8"), class = "FutureResult")
[17:47:30.474]     }, finally = {
[17:47:30.474]         if (!identical(...future.workdir, getwd())) 
[17:47:30.474]             setwd(...future.workdir)
[17:47:30.474]         {
[17:47:30.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.474]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.474]             }
[17:47:30.474]             base::options(...future.oldOptions)
[17:47:30.474]             if (.Platform$OS.type == "windows") {
[17:47:30.474]                 old_names <- names(...future.oldEnvVars)
[17:47:30.474]                 envs <- base::Sys.getenv()
[17:47:30.474]                 names <- names(envs)
[17:47:30.474]                 common <- intersect(names, old_names)
[17:47:30.474]                 added <- setdiff(names, old_names)
[17:47:30.474]                 removed <- setdiff(old_names, names)
[17:47:30.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.474]                   envs[common]]
[17:47:30.474]                 NAMES <- toupper(changed)
[17:47:30.474]                 args <- list()
[17:47:30.474]                 for (kk in seq_along(NAMES)) {
[17:47:30.474]                   name <- changed[[kk]]
[17:47:30.474]                   NAME <- NAMES[[kk]]
[17:47:30.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.474]                     next
[17:47:30.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.474]                 }
[17:47:30.474]                 NAMES <- toupper(added)
[17:47:30.474]                 for (kk in seq_along(NAMES)) {
[17:47:30.474]                   name <- added[[kk]]
[17:47:30.474]                   NAME <- NAMES[[kk]]
[17:47:30.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.474]                     next
[17:47:30.474]                   args[[name]] <- ""
[17:47:30.474]                 }
[17:47:30.474]                 NAMES <- toupper(removed)
[17:47:30.474]                 for (kk in seq_along(NAMES)) {
[17:47:30.474]                   name <- removed[[kk]]
[17:47:30.474]                   NAME <- NAMES[[kk]]
[17:47:30.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.474]                     next
[17:47:30.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.474]                 }
[17:47:30.474]                 if (length(args) > 0) 
[17:47:30.474]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.474]             }
[17:47:30.474]             else {
[17:47:30.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.474]             }
[17:47:30.474]             {
[17:47:30.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.474]                   0L) {
[17:47:30.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.474]                   base::options(opts)
[17:47:30.474]                 }
[17:47:30.474]                 {
[17:47:30.474]                   {
[17:47:30.474]                     NULL
[17:47:30.474]                     RNGkind("Mersenne-Twister")
[17:47:30.474]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.474]                       inherits = FALSE)
[17:47:30.474]                   }
[17:47:30.474]                   options(future.plan = NULL)
[17:47:30.474]                   if (is.na(NA_character_)) 
[17:47:30.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.474]                     .init = FALSE)
[17:47:30.474]                 }
[17:47:30.474]             }
[17:47:30.474]         }
[17:47:30.474]     })
[17:47:30.474]     if (TRUE) {
[17:47:30.474]         base::sink(type = "output", split = FALSE)
[17:47:30.474]         if (TRUE) {
[17:47:30.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.474]         }
[17:47:30.474]         else {
[17:47:30.474]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.474]         }
[17:47:30.474]         base::close(...future.stdout)
[17:47:30.474]         ...future.stdout <- NULL
[17:47:30.474]     }
[17:47:30.474]     ...future.result$conditions <- ...future.conditions
[17:47:30.474]     ...future.result$finished <- base::Sys.time()
[17:47:30.474]     ...future.result
[17:47:30.474] }
[17:47:30.475] assign_globals() ...
[17:47:30.475] List of 1
[17:47:30.475]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:30.475]   ..$ a: int [1:3] 1 2 3
[17:47:30.475]   ..$ b: int [1:3] 3 2 1
[17:47:30.475]  - attr(*, "where")=List of 1
[17:47:30.475]   ..$ data:<environment: R_EmptyEnv> 
[17:47:30.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.475]  - attr(*, "resolved")= logi FALSE
[17:47:30.475]  - attr(*, "total_size")= num 128
[17:47:30.475]  - attr(*, "already-done")= logi TRUE
[17:47:30.480] - copied ‘data’ to environment
[17:47:30.480] assign_globals() ... done
[17:47:30.480] plan(): Setting new future strategy stack:
[17:47:30.480] List of future strategies:
[17:47:30.480] 1. sequential:
[17:47:30.480]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.480]    - tweaked: FALSE
[17:47:30.480]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.481] plan(): nbrOfWorkers() = 1
[17:47:30.509] plan(): Setting new future strategy stack:
[17:47:30.509] List of future strategies:
[17:47:30.509] 1. sequential:
[17:47:30.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.509]    - tweaked: FALSE
[17:47:30.509]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.509] 2. sequential:
[17:47:30.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.509]    - tweaked: FALSE
[17:47:30.509]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.510] plan(): nbrOfWorkers() = 1
[17:47:30.510] SequentialFuture started (and completed)
[17:47:30.510] signalConditions() ...
[17:47:30.510]  - include = ‘immediateCondition’
[17:47:30.510]  - exclude = 
[17:47:30.510]  - resignal = FALSE
[17:47:30.510]  - Number of conditions: 52
[17:47:30.510] signalConditions() ... done
[17:47:30.511] - Launch lazy future ... done
[17:47:30.511] run() for ‘SequentialFuture’ ... done
[17:47:30.511] signalConditions() ...
[17:47:30.511]  - include = ‘immediateCondition’
[17:47:30.511]  - exclude = 
[17:47:30.511]  - resignal = FALSE
[17:47:30.511]  - Number of conditions: 52
[17:47:30.511] signalConditions() ... done
[17:47:30.511] Future state: ‘finished’
[17:47:30.512] signalConditions() ...
[17:47:30.512]  - include = ‘condition’
[17:47:30.512]  - exclude = ‘immediateCondition’
[17:47:30.512]  - resignal = TRUE
[17:47:30.512]  - Number of conditions: 52
[17:47:30.512]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.481] getGlobalsAndPackages() ...
[17:47:30.512]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.481] Searching for globals...
[17:47:30.512]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.495] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:30.512]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.495] Searching for globals ... DONE
[17:47:30.512]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.495] Resolving globals: FALSE
[17:47:30.513]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.496] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:30.513]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.496] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:30.513]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.496] - globals: [1] ‘data’
[17:47:30.513]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.496] 
[17:47:30.513]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.496] getGlobalsAndPackages() ... DONE
[17:47:30.513]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.496] run() for ‘Future’ ...
[17:47:30.513]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497] - state: ‘created’
[17:47:30.513]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.514]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.514]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.514]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497]   - Field: ‘label’
[17:47:30.514]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497]   - Field: ‘local’
[17:47:30.514]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497]   - Field: ‘owner’
[17:47:30.514]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.497]   - Field: ‘envir’
[17:47:30.514]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘packages’
[17:47:30.514]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘gc’
[17:47:30.515]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘conditions’
[17:47:30.515]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘expr’
[17:47:30.515]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘uuid’
[17:47:30.515]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘seed’
[17:47:30.515]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘version’
[17:47:30.515]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘result’
[17:47:30.515]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘asynchronous’
[17:47:30.516]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.498]   - Field: ‘calls’
[17:47:30.516]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.499]   - Field: ‘globals’
[17:47:30.516]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.499]   - Field: ‘stdout’
[17:47:30.516]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.499]   - Field: ‘earlySignal’
[17:47:30.516]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.499]   - Field: ‘lazy’
[17:47:30.516]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.499]   - Field: ‘state’
[17:47:30.516]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.516]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.500] - Launch lazy future ...
[17:47:30.516]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.501] Packages needed by the future expression (n = 0): <none>
[17:47:30.517]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.501] Packages needed by future strategies (n = 0): <none>
[17:47:30.517]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.501] {
[17:47:30.501]     {
[17:47:30.501]         {
[17:47:30.501]             ...future.startTime <- base::Sys.time()
[17:47:30.501]             {
[17:47:30.501]                 {
[17:47:30.501]                   {
[17:47:30.501]                     base::local({
[17:47:30.501]                       has_future <- base::requireNamespace("future", 
[17:47:30.501]                         quietly = TRUE)
[17:47:30.501]                       if (has_future) {
[17:47:30.501]                         ns <- base::getNamespace("future")
[17:47:30.501]                         version <- ns[[".package"]][["version"]]
[17:47:30.501]                         if (is.null(version)) 
[17:47:30.501]                           version <- utils::packageVersion("future")
[17:47:30.501]                       }
[17:47:30.501]                       else {
[17:47:30.501]                         version <- NULL
[17:47:30.501]                       }
[17:47:30.501]                       if (!has_future || version < "1.8.0") {
[17:47:30.501]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.501]                           "", base::R.version$version.string), 
[17:47:30.501]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:30.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.501]                             "release", "version")], collapse = " "), 
[17:47:30.501]                           hostname = base::Sys.info()[["nodename"]])
[17:47:30.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.501]                           info)
[17:47:30.501]                         info <- base::paste(info, collapse = "; ")
[17:47:30.501]                         if (!has_future) {
[17:47:30.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.501]                             info)
[17:47:30.501]                         }
[17:47:30.501]                         else {
[17:47:30.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.501]                             info, version)
[17:47:30.501]                         }
[17:47:30.501]                         base::stop(msg)
[17:47:30.501]                       }
[17:47:30.501]                     })
[17:47:30.501]                   }
[17:47:30.501]                   ...future.strategy.old <- future::plan("list")
[17:47:30.501]                   options(future.plan = NULL)
[17:47:30.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:30.501]                 }
[17:47:30.501]                 ...future.workdir <- getwd()
[17:47:30.501]             }
[17:47:30.501]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.501]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.501]         }
[17:47:30.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.501]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.501]             base::names(...future.oldOptions))
[17:47:30.501]     }
[17:47:30.501]     if (FALSE) {
[17:47:30.501]     }
[17:47:30.501]     else {
[17:47:30.501]         if (TRUE) {
[17:47:30.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.501]                 open = "w")
[17:47:30.501]         }
[17:47:30.501]         else {
[17:47:30.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.501]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.501]         }
[17:47:30.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.501]             base::sink(type = "output", split = FALSE)
[17:47:30.501]             base::close(...future.stdout)
[17:47:30.501]         }, add = TRUE)
[17:47:30.501]     }
[17:47:30.501]     ...future.frame <- base::sys.nframe()
[17:47:30.501]     ...future.conditions <- base::list()
[17:47:30.501]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.501]     if (FALSE) {
[17:47:30.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.501]     }
[17:47:30.501]     ...future.result <- base::tryCatch({
[17:47:30.501]         base::withCallingHandlers({
[17:47:30.501]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:47:30.501]                 a == 2)))
[17:47:30.501]             future::FutureResult(value = ...future.value$value, 
[17:47:30.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.501]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.501]                     ...future.globalenv.names))
[17:47:30.501]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.501]         }, condition = base::local({
[17:47:30.501]             c <- base::c
[17:47:30.501]             inherits <- base::inherits
[17:47:30.501]             invokeRestart <- base::invokeRestart
[17:47:30.501]             length <- base::length
[17:47:30.501]             list <- base::list
[17:47:30.501]             seq.int <- base::seq.int
[17:47:30.501]             signalCondition <- base::signalCondition
[17:47:30.501]             sys.calls <- base::sys.calls
[17:47:30.501]             `[[` <- base::`[[`
[17:47:30.501]             `+` <- base::`+`
[17:47:30.501]             `<<-` <- base::`<<-`
[17:47:30.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.501]                   3L)]
[17:47:30.501]             }
[17:47:30.501]             function(cond) {
[17:47:30.501]                 is_error <- inherits(cond, "error")
[17:47:30.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.501]                   NULL)
[17:47:30.501]                 if (is_error) {
[17:47:30.501]                   sessionInformation <- function() {
[17:47:30.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.501]                       search = base::search(), system = base::Sys.info())
[17:47:30.501]                   }
[17:47:30.501]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.501]                     cond$call), session = sessionInformation(), 
[17:47:30.501]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.501]                   signalCondition(cond)
[17:47:30.501]                 }
[17:47:30.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.501]                 "immediateCondition"))) {
[17:47:30.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.501]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.501]                   if (TRUE && !signal) {
[17:47:30.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.501]                     {
[17:47:30.501]                       inherits <- base::inherits
[17:47:30.501]                       invokeRestart <- base::invokeRestart
[17:47:30.501]                       is.null <- base::is.null
[17:47:30.501]                       muffled <- FALSE
[17:47:30.501]                       if (inherits(cond, "message")) {
[17:47:30.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.501]                         if (muffled) 
[17:47:30.501]                           invokeRestart("muffleMessage")
[17:47:30.501]                       }
[17:47:30.501]                       else if (inherits(cond, "warning")) {
[17:47:30.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.501]                         if (muffled) 
[17:47:30.501]                           invokeRestart("muffleWarning")
[17:47:30.501]                       }
[17:47:30.501]                       else if (inherits(cond, "condition")) {
[17:47:30.501]                         if (!is.null(pattern)) {
[17:47:30.501]                           computeRestarts <- base::computeRestarts
[17:47:30.501]                           grepl <- base::grepl
[17:47:30.501]                           restarts <- computeRestarts(cond)
[17:47:30.501]                           for (restart in restarts) {
[17:47:30.501]                             name <- restart$name
[17:47:30.501]                             if (is.null(name)) 
[17:47:30.501]                               next
[17:47:30.501]                             if (!grepl(pattern, name)) 
[17:47:30.501]                               next
[17:47:30.501]                             invokeRestart(restart)
[17:47:30.501]                             muffled <- TRUE
[17:47:30.501]                             break
[17:47:30.501]                           }
[17:47:30.501]                         }
[17:47:30.501]                       }
[17:47:30.501]                       invisible(muffled)
[17:47:30.501]                     }
[17:47:30.501]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.501]                   }
[17:47:30.501]                 }
[17:47:30.501]                 else {
[17:47:30.501]                   if (TRUE) {
[17:47:30.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.501]                     {
[17:47:30.501]                       inherits <- base::inherits
[17:47:30.501]                       invokeRestart <- base::invokeRestart
[17:47:30.501]                       is.null <- base::is.null
[17:47:30.501]                       muffled <- FALSE
[17:47:30.501]                       if (inherits(cond, "message")) {
[17:47:30.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.501]                         if (muffled) 
[17:47:30.501]                           invokeRestart("muffleMessage")
[17:47:30.501]                       }
[17:47:30.501]                       else if (inherits(cond, "warning")) {
[17:47:30.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.501]                         if (muffled) 
[17:47:30.501]                           invokeRestart("muffleWarning")
[17:47:30.501]                       }
[17:47:30.501]                       else if (inherits(cond, "condition")) {
[17:47:30.501]                         if (!is.null(pattern)) {
[17:47:30.501]                           computeRestarts <- base::computeRestarts
[17:47:30.501]                           grepl <- base::grepl
[17:47:30.501]                           restarts <- computeRestarts(cond)
[17:47:30.501]                           for (restart in restarts) {
[17:47:30.501]                             name <- restart$name
[17:47:30.501]                             if (is.null(name)) 
[17:47:30.501]                               next
[17:47:30.501]                             if (!grepl(pattern, name)) 
[17:47:30.501]                               next
[17:47:30.501]                             invokeRestart(restart)
[17:47:30.501]                             muffled <- TRUE
[17:47:30.501]                             break
[17:47:30.501]                           }
[17:47:30.501]                         }
[17:47:30.501]                       }
[17:47:30.501]                       invisible(muffled)
[17:47:30.501]                     }
[17:47:30.501]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.501]                   }
[17:47:30.501]                 }
[17:47:30.501]             }
[17:47:30.501]         }))
[17:47:30.501]     }, error = function(ex) {
[17:47:30.501]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.501]                 ...future.rng), started = ...future.startTime, 
[17:47:30.501]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.501]             version = "1.8"), class = "FutureResult")
[17:47:30.501]     }, finally = {
[17:47:30.501]         if (!identical(...future.workdir, getwd())) 
[17:47:30.501]             setwd(...future.workdir)
[17:47:30.501]         {
[17:47:30.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.501]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.501]             }
[17:47:30.501]             base::options(...future.oldOptions)
[17:47:30.501]             if (.Platform$OS.type == "windows") {
[17:47:30.501]                 old_names <- names(...future.oldEnvVars)
[17:47:30.501]                 envs <- base::Sys.getenv()
[17:47:30.501]                 names <- names(envs)
[17:47:30.501]                 common <- intersect(names, old_names)
[17:47:30.501]                 added <- setdiff(names, old_names)
[17:47:30.501]                 removed <- setdiff(old_names, names)
[17:47:30.501]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.501]                   envs[common]]
[17:47:30.501]                 NAMES <- toupper(changed)
[17:47:30.501]                 args <- list()
[17:47:30.501]                 for (kk in seq_along(NAMES)) {
[17:47:30.501]                   name <- changed[[kk]]
[17:47:30.501]                   NAME <- NAMES[[kk]]
[17:47:30.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.501]                     next
[17:47:30.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.501]                 }
[17:47:30.501]                 NAMES <- toupper(added)
[17:47:30.501]                 for (kk in seq_along(NAMES)) {
[17:47:30.501]                   name <- added[[kk]]
[17:47:30.501]                   NAME <- NAMES[[kk]]
[17:47:30.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.501]                     next
[17:47:30.501]                   args[[name]] <- ""
[17:47:30.501]                 }
[17:47:30.501]                 NAMES <- toupper(removed)
[17:47:30.501]                 for (kk in seq_along(NAMES)) {
[17:47:30.501]                   name <- removed[[kk]]
[17:47:30.501]                   NAME <- NAMES[[kk]]
[17:47:30.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.501]                     next
[17:47:30.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.501]                 }
[17:47:30.501]                 if (length(args) > 0) 
[17:47:30.501]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.501]             }
[17:47:30.501]             else {
[17:47:30.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.501]             }
[17:47:30.501]             {
[17:47:30.501]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.501]                   0L) {
[17:47:30.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.501]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.501]                   base::options(opts)
[17:47:30.501]                 }
[17:47:30.501]                 {
[17:47:30.501]                   {
[17:47:30.501]                     NULL
[17:47:30.501]                     RNGkind("Mersenne-Twister")
[17:47:30.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.501]                       inherits = FALSE)
[17:47:30.501]                   }
[17:47:30.501]                   options(future.plan = NULL)
[17:47:30.501]                   if (is.na(NA_character_)) 
[17:47:30.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.501]                     .init = FALSE)
[17:47:30.501]                 }
[17:47:30.501]             }
[17:47:30.501]         }
[17:47:30.501]     })
[17:47:30.501]     if (TRUE) {
[17:47:30.501]         base::sink(type = "output", split = FALSE)
[17:47:30.501]         if (TRUE) {
[17:47:30.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.501]         }
[17:47:30.501]         else {
[17:47:30.501]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.501]         }
[17:47:30.501]         base::close(...future.stdout)
[17:47:30.501]         ...future.stdout <- NULL
[17:47:30.501]     }
[17:47:30.501]     ...future.result$conditions <- ...future.conditions
[17:47:30.501]     ...future.result$finished <- base::Sys.time()
[17:47:30.501]     ...future.result
[17:47:30.501] }
[17:47:30.517]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.503] assign_globals() ...
[17:47:30.517]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.503] List of 1
[17:47:30.503]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:30.503]   ..$ a: int [1:3] 1 2 3
[17:47:30.503]   ..$ b: int [1:3] 3 2 1
[17:47:30.503]  - attr(*, "where")=List of 1
[17:47:30.503]   ..$ data:<environment: R_EmptyEnv> 
[17:47:30.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.503]  - attr(*, "resolved")= logi FALSE
[17:47:30.503]  - attr(*, "total_size")= num 128
[17:47:30.503]  - attr(*, "already-done")= logi TRUE
[17:47:30.517]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.506] - copied ‘data’ to environment
[17:47:30.517]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.506] assign_globals() ... done
[17:47:30.517]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.506] plan(): Setting new future strategy stack:
[17:47:30.518]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.506] List of future strategies:
[17:47:30.506] 1. sequential:
[17:47:30.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.506]    - tweaked: FALSE
[17:47:30.506]    - call: NULL
[17:47:30.518]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.507] plan(): nbrOfWorkers() = 1
[17:47:30.518]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.508] plan(): Setting new future strategy stack:
[17:47:30.518]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.508] List of future strategies:
[17:47:30.508] 1. sequential:
[17:47:30.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.508]    - tweaked: FALSE
[17:47:30.508]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.518]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.508] plan(): nbrOfWorkers() = 1
[17:47:30.518]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.508] SequentialFuture started (and completed)
[17:47:30.518]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.508] - Launch lazy future ... done
[17:47:30.518]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.509] run() for ‘SequentialFuture’ ... done
[17:47:30.519] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[17:47:30.519] plan(): Setting new future strategy stack:
[17:47:30.519] List of future strategies:
[17:47:30.519] 1. sequential:
[17:47:30.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.519]    - tweaked: FALSE
[17:47:30.519]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.519] 2. multicore:
[17:47:30.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:30.519]    - tweaked: FALSE
[17:47:30.519]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.520] plan(): nbrOfWorkers() = 1
[17:47:30.520] getGlobalsAndPackages() ...
[17:47:30.520] Searching for globals...
[17:47:30.536] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:30.536] Searching for globals ... DONE
[17:47:30.536] Resolving globals: FALSE
[17:47:30.537] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[17:47:30.537] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:30.538] - globals: [2] ‘nested’, ‘strategy2’
[17:47:30.538] - packages: [1] ‘future’
[17:47:30.538] getGlobalsAndPackages() ... DONE
[17:47:30.538] run() for ‘Future’ ...
[17:47:30.538] - state: ‘created’
[17:47:30.538] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.539] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.539]   - Field: ‘label’
[17:47:30.539]   - Field: ‘local’
[17:47:30.539]   - Field: ‘owner’
[17:47:30.539]   - Field: ‘envir’
[17:47:30.539]   - Field: ‘packages’
[17:47:30.539]   - Field: ‘gc’
[17:47:30.539]   - Field: ‘conditions’
[17:47:30.539]   - Field: ‘expr’
[17:47:30.539]   - Field: ‘uuid’
[17:47:30.540]   - Field: ‘seed’
[17:47:30.540]   - Field: ‘version’
[17:47:30.540]   - Field: ‘result’
[17:47:30.540]   - Field: ‘asynchronous’
[17:47:30.540]   - Field: ‘calls’
[17:47:30.540]   - Field: ‘globals’
[17:47:30.540]   - Field: ‘stdout’
[17:47:30.540]   - Field: ‘earlySignal’
[17:47:30.540]   - Field: ‘lazy’
[17:47:30.540]   - Field: ‘state’
[17:47:30.540] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.541] - Launch lazy future ...
[17:47:30.541] Packages needed by the future expression (n = 1): ‘future’
[17:47:30.541] Packages needed by future strategies (n = 1): ‘future’
[17:47:30.542] {
[17:47:30.542]     {
[17:47:30.542]         {
[17:47:30.542]             ...future.startTime <- base::Sys.time()
[17:47:30.542]             {
[17:47:30.542]                 {
[17:47:30.542]                   {
[17:47:30.542]                     {
[17:47:30.542]                       base::local({
[17:47:30.542]                         has_future <- base::requireNamespace("future", 
[17:47:30.542]                           quietly = TRUE)
[17:47:30.542]                         if (has_future) {
[17:47:30.542]                           ns <- base::getNamespace("future")
[17:47:30.542]                           version <- ns[[".package"]][["version"]]
[17:47:30.542]                           if (is.null(version)) 
[17:47:30.542]                             version <- utils::packageVersion("future")
[17:47:30.542]                         }
[17:47:30.542]                         else {
[17:47:30.542]                           version <- NULL
[17:47:30.542]                         }
[17:47:30.542]                         if (!has_future || version < "1.8.0") {
[17:47:30.542]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.542]                             "", base::R.version$version.string), 
[17:47:30.542]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.542]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.542]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.542]                               "release", "version")], collapse = " "), 
[17:47:30.542]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.542]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.542]                             info)
[17:47:30.542]                           info <- base::paste(info, collapse = "; ")
[17:47:30.542]                           if (!has_future) {
[17:47:30.542]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.542]                               info)
[17:47:30.542]                           }
[17:47:30.542]                           else {
[17:47:30.542]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.542]                               info, version)
[17:47:30.542]                           }
[17:47:30.542]                           base::stop(msg)
[17:47:30.542]                         }
[17:47:30.542]                       })
[17:47:30.542]                     }
[17:47:30.542]                     base::local({
[17:47:30.542]                       for (pkg in "future") {
[17:47:30.542]                         base::loadNamespace(pkg)
[17:47:30.542]                         base::library(pkg, character.only = TRUE)
[17:47:30.542]                       }
[17:47:30.542]                     })
[17:47:30.542]                   }
[17:47:30.542]                   ...future.strategy.old <- future::plan("list")
[17:47:30.542]                   options(future.plan = NULL)
[17:47:30.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.542]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:30.542]                     envir = parent.frame()) 
[17:47:30.542]                   {
[17:47:30.542]                     default_workers <- missing(workers)
[17:47:30.542]                     if (is.function(workers)) 
[17:47:30.542]                       workers <- workers()
[17:47:30.542]                     workers <- structure(as.integer(workers), 
[17:47:30.542]                       class = class(workers))
[17:47:30.542]                     stop_if_not(is.finite(workers), workers >= 
[17:47:30.542]                       1L)
[17:47:30.542]                     if ((workers == 1L && !inherits(workers, 
[17:47:30.542]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:30.542]                       if (default_workers) 
[17:47:30.542]                         supportsMulticore(warn = TRUE)
[17:47:30.542]                       return(sequential(..., envir = envir))
[17:47:30.542]                     }
[17:47:30.542]                     oopts <- options(mc.cores = workers)
[17:47:30.542]                     on.exit(options(oopts))
[17:47:30.542]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:30.542]                       envir = envir)
[17:47:30.542]                     if (!future$lazy) 
[17:47:30.542]                       future <- run(future)
[17:47:30.542]                     invisible(future)
[17:47:30.542]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:30.542]                 }
[17:47:30.542]                 ...future.workdir <- getwd()
[17:47:30.542]             }
[17:47:30.542]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.542]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.542]         }
[17:47:30.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.542]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.542]             base::names(...future.oldOptions))
[17:47:30.542]     }
[17:47:30.542]     if (FALSE) {
[17:47:30.542]     }
[17:47:30.542]     else {
[17:47:30.542]         if (TRUE) {
[17:47:30.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.542]                 open = "w")
[17:47:30.542]         }
[17:47:30.542]         else {
[17:47:30.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.542]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.542]         }
[17:47:30.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.542]             base::sink(type = "output", split = FALSE)
[17:47:30.542]             base::close(...future.stdout)
[17:47:30.542]         }, add = TRUE)
[17:47:30.542]     }
[17:47:30.542]     ...future.frame <- base::sys.nframe()
[17:47:30.542]     ...future.conditions <- base::list()
[17:47:30.542]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.542]     if (FALSE) {
[17:47:30.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.542]     }
[17:47:30.542]     ...future.result <- base::tryCatch({
[17:47:30.542]         base::withCallingHandlers({
[17:47:30.542]             ...future.value <- base::withVisible(base::local({
[17:47:30.542]                 a <- 1L
[17:47:30.542]                 plan_a <- unclass(future::plan("list"))
[17:47:30.542]                 nested_a <- nested[-1]
[17:47:30.542]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:30.542]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.542]                   strategy2))
[17:47:30.542]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:30.542]                   "init") <- NULL
[17:47:30.542]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:30.542]                   "init") <- NULL
[17:47:30.542]                 stopifnot(all.equal(plan_a, nested_a))
[17:47:30.542]                 y %<-% {
[17:47:30.542]                   b <- 2L
[17:47:30.542]                   plan_b <- future::plan("list")
[17:47:30.542]                   nested_b <- nested_a[-1]
[17:47:30.542]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:30.542]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.542]                     "sequential"))
[17:47:30.542]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:30.542]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:30.542]                 }
[17:47:30.542]                 y
[17:47:30.542]             }))
[17:47:30.542]             future::FutureResult(value = ...future.value$value, 
[17:47:30.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.542]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.542]                     ...future.globalenv.names))
[17:47:30.542]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.542]         }, condition = base::local({
[17:47:30.542]             c <- base::c
[17:47:30.542]             inherits <- base::inherits
[17:47:30.542]             invokeRestart <- base::invokeRestart
[17:47:30.542]             length <- base::length
[17:47:30.542]             list <- base::list
[17:47:30.542]             seq.int <- base::seq.int
[17:47:30.542]             signalCondition <- base::signalCondition
[17:47:30.542]             sys.calls <- base::sys.calls
[17:47:30.542]             `[[` <- base::`[[`
[17:47:30.542]             `+` <- base::`+`
[17:47:30.542]             `<<-` <- base::`<<-`
[17:47:30.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.542]                   3L)]
[17:47:30.542]             }
[17:47:30.542]             function(cond) {
[17:47:30.542]                 is_error <- inherits(cond, "error")
[17:47:30.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.542]                   NULL)
[17:47:30.542]                 if (is_error) {
[17:47:30.542]                   sessionInformation <- function() {
[17:47:30.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.542]                       search = base::search(), system = base::Sys.info())
[17:47:30.542]                   }
[17:47:30.542]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.542]                     cond$call), session = sessionInformation(), 
[17:47:30.542]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.542]                   signalCondition(cond)
[17:47:30.542]                 }
[17:47:30.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.542]                 "immediateCondition"))) {
[17:47:30.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.542]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.542]                   if (TRUE && !signal) {
[17:47:30.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.542]                     {
[17:47:30.542]                       inherits <- base::inherits
[17:47:30.542]                       invokeRestart <- base::invokeRestart
[17:47:30.542]                       is.null <- base::is.null
[17:47:30.542]                       muffled <- FALSE
[17:47:30.542]                       if (inherits(cond, "message")) {
[17:47:30.542]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.542]                         if (muffled) 
[17:47:30.542]                           invokeRestart("muffleMessage")
[17:47:30.542]                       }
[17:47:30.542]                       else if (inherits(cond, "warning")) {
[17:47:30.542]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.542]                         if (muffled) 
[17:47:30.542]                           invokeRestart("muffleWarning")
[17:47:30.542]                       }
[17:47:30.542]                       else if (inherits(cond, "condition")) {
[17:47:30.542]                         if (!is.null(pattern)) {
[17:47:30.542]                           computeRestarts <- base::computeRestarts
[17:47:30.542]                           grepl <- base::grepl
[17:47:30.542]                           restarts <- computeRestarts(cond)
[17:47:30.542]                           for (restart in restarts) {
[17:47:30.542]                             name <- restart$name
[17:47:30.542]                             if (is.null(name)) 
[17:47:30.542]                               next
[17:47:30.542]                             if (!grepl(pattern, name)) 
[17:47:30.542]                               next
[17:47:30.542]                             invokeRestart(restart)
[17:47:30.542]                             muffled <- TRUE
[17:47:30.542]                             break
[17:47:30.542]                           }
[17:47:30.542]                         }
[17:47:30.542]                       }
[17:47:30.542]                       invisible(muffled)
[17:47:30.542]                     }
[17:47:30.542]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.542]                   }
[17:47:30.542]                 }
[17:47:30.542]                 else {
[17:47:30.542]                   if (TRUE) {
[17:47:30.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.542]                     {
[17:47:30.542]                       inherits <- base::inherits
[17:47:30.542]                       invokeRestart <- base::invokeRestart
[17:47:30.542]                       is.null <- base::is.null
[17:47:30.542]                       muffled <- FALSE
[17:47:30.542]                       if (inherits(cond, "message")) {
[17:47:30.542]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.542]                         if (muffled) 
[17:47:30.542]                           invokeRestart("muffleMessage")
[17:47:30.542]                       }
[17:47:30.542]                       else if (inherits(cond, "warning")) {
[17:47:30.542]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.542]                         if (muffled) 
[17:47:30.542]                           invokeRestart("muffleWarning")
[17:47:30.542]                       }
[17:47:30.542]                       else if (inherits(cond, "condition")) {
[17:47:30.542]                         if (!is.null(pattern)) {
[17:47:30.542]                           computeRestarts <- base::computeRestarts
[17:47:30.542]                           grepl <- base::grepl
[17:47:30.542]                           restarts <- computeRestarts(cond)
[17:47:30.542]                           for (restart in restarts) {
[17:47:30.542]                             name <- restart$name
[17:47:30.542]                             if (is.null(name)) 
[17:47:30.542]                               next
[17:47:30.542]                             if (!grepl(pattern, name)) 
[17:47:30.542]                               next
[17:47:30.542]                             invokeRestart(restart)
[17:47:30.542]                             muffled <- TRUE
[17:47:30.542]                             break
[17:47:30.542]                           }
[17:47:30.542]                         }
[17:47:30.542]                       }
[17:47:30.542]                       invisible(muffled)
[17:47:30.542]                     }
[17:47:30.542]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.542]                   }
[17:47:30.542]                 }
[17:47:30.542]             }
[17:47:30.542]         }))
[17:47:30.542]     }, error = function(ex) {
[17:47:30.542]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.542]                 ...future.rng), started = ...future.startTime, 
[17:47:30.542]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.542]             version = "1.8"), class = "FutureResult")
[17:47:30.542]     }, finally = {
[17:47:30.542]         if (!identical(...future.workdir, getwd())) 
[17:47:30.542]             setwd(...future.workdir)
[17:47:30.542]         {
[17:47:30.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.542]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.542]             }
[17:47:30.542]             base::options(...future.oldOptions)
[17:47:30.542]             if (.Platform$OS.type == "windows") {
[17:47:30.542]                 old_names <- names(...future.oldEnvVars)
[17:47:30.542]                 envs <- base::Sys.getenv()
[17:47:30.542]                 names <- names(envs)
[17:47:30.542]                 common <- intersect(names, old_names)
[17:47:30.542]                 added <- setdiff(names, old_names)
[17:47:30.542]                 removed <- setdiff(old_names, names)
[17:47:30.542]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.542]                   envs[common]]
[17:47:30.542]                 NAMES <- toupper(changed)
[17:47:30.542]                 args <- list()
[17:47:30.542]                 for (kk in seq_along(NAMES)) {
[17:47:30.542]                   name <- changed[[kk]]
[17:47:30.542]                   NAME <- NAMES[[kk]]
[17:47:30.542]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.542]                     next
[17:47:30.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.542]                 }
[17:47:30.542]                 NAMES <- toupper(added)
[17:47:30.542]                 for (kk in seq_along(NAMES)) {
[17:47:30.542]                   name <- added[[kk]]
[17:47:30.542]                   NAME <- NAMES[[kk]]
[17:47:30.542]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.542]                     next
[17:47:30.542]                   args[[name]] <- ""
[17:47:30.542]                 }
[17:47:30.542]                 NAMES <- toupper(removed)
[17:47:30.542]                 for (kk in seq_along(NAMES)) {
[17:47:30.542]                   name <- removed[[kk]]
[17:47:30.542]                   NAME <- NAMES[[kk]]
[17:47:30.542]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.542]                     next
[17:47:30.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.542]                 }
[17:47:30.542]                 if (length(args) > 0) 
[17:47:30.542]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.542]             }
[17:47:30.542]             else {
[17:47:30.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.542]             }
[17:47:30.542]             {
[17:47:30.542]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.542]                   0L) {
[17:47:30.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.542]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.542]                   base::options(opts)
[17:47:30.542]                 }
[17:47:30.542]                 {
[17:47:30.542]                   {
[17:47:30.542]                     NULL
[17:47:30.542]                     RNGkind("Mersenne-Twister")
[17:47:30.542]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.542]                       inherits = FALSE)
[17:47:30.542]                   }
[17:47:30.542]                   options(future.plan = NULL)
[17:47:30.542]                   if (is.na(NA_character_)) 
[17:47:30.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.542]                     .init = FALSE)
[17:47:30.542]                 }
[17:47:30.542]             }
[17:47:30.542]         }
[17:47:30.542]     })
[17:47:30.542]     if (TRUE) {
[17:47:30.542]         base::sink(type = "output", split = FALSE)
[17:47:30.542]         if (TRUE) {
[17:47:30.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.542]         }
[17:47:30.542]         else {
[17:47:30.542]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.542]         }
[17:47:30.542]         base::close(...future.stdout)
[17:47:30.542]         ...future.stdout <- NULL
[17:47:30.542]     }
[17:47:30.542]     ...future.result$conditions <- ...future.conditions
[17:47:30.542]     ...future.result$finished <- base::Sys.time()
[17:47:30.542]     ...future.result
[17:47:30.542] }
[17:47:30.544] assign_globals() ...
[17:47:30.544] List of 2
[17:47:30.544]  $ nested   :List of 2
[17:47:30.544]   ..$ a:function (..., envir = parent.frame())  
[17:47:30.544]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:30.544]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.544]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:30.544]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:30.544]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.544]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:30.544]  $ strategy2: chr "multicore"
[17:47:30.544]  - attr(*, "where")=List of 2
[17:47:30.544]   ..$ nested   :<environment: R_EmptyEnv> 
[17:47:30.544]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:47:30.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.544]  - attr(*, "resolved")= logi FALSE
[17:47:30.544]  - attr(*, "total_size")= num 59224
[17:47:30.544]  - attr(*, "already-done")= logi TRUE
[17:47:30.549] - copied ‘nested’ to environment
[17:47:30.549] - copied ‘strategy2’ to environment
[17:47:30.549] assign_globals() ... done
[17:47:30.549] plan(): Setting new future strategy stack:
[17:47:30.549] List of future strategies:
[17:47:30.549] 1. multicore:
[17:47:30.549]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:30.549]    - tweaked: FALSE
[17:47:30.549]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.553] plan(): nbrOfWorkers() = 2
[17:47:30.615] plan(): Setting new future strategy stack:
[17:47:30.615] List of future strategies:
[17:47:30.615] 1. sequential:
[17:47:30.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.615]    - tweaked: FALSE
[17:47:30.615]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.615] 2. multicore:
[17:47:30.615]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:30.615]    - tweaked: FALSE
[17:47:30.615]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.616] plan(): nbrOfWorkers() = 1
[17:47:30.616] SequentialFuture started (and completed)
[17:47:30.616] signalConditions() ...
[17:47:30.617]  - include = ‘immediateCondition’
[17:47:30.617]  - exclude = 
[17:47:30.617]  - resignal = FALSE
[17:47:30.617]  - Number of conditions: 57
[17:47:30.617] signalConditions() ... done
[17:47:30.617] - Launch lazy future ... done
[17:47:30.617] run() for ‘SequentialFuture’ ... done
[17:47:30.617] signalConditions() ...
[17:47:30.618]  - include = ‘immediateCondition’
[17:47:30.618]  - exclude = 
[17:47:30.618]  - resignal = FALSE
[17:47:30.618]  - Number of conditions: 57
[17:47:30.618] signalConditions() ... done
[17:47:30.618] Future state: ‘finished’
[17:47:30.618] signalConditions() ...
[17:47:30.618]  - include = ‘condition’
[17:47:30.619]  - exclude = ‘immediateCondition’
[17:47:30.619]  - resignal = TRUE
[17:47:30.619]  - Number of conditions: 57
[17:47:30.619]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.554] getGlobalsAndPackages() ...
[17:47:30.619]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.554] Searching for globals...
[17:47:30.619]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.572] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:47:30.619]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.572] Searching for globals ... DONE
[17:47:30.620]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.572] Resolving globals: FALSE
[17:47:30.620]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.573] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[17:47:30.620]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.573] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:47:30.620]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.574] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:47:30.620]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.574] 
[17:47:30.620]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.574] getGlobalsAndPackages() ... DONE
[17:47:30.620]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.574] run() for ‘Future’ ...
[17:47:30.621]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.574] - state: ‘created’
[17:47:30.621]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.574] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:30.621]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:30.621]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:30.621]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.578]   - Field: ‘label’
[17:47:30.621]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘local’
[17:47:30.622]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘owner’
[17:47:30.622]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘envir’
[17:47:30.622]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘workers’
[17:47:30.622]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘packages’
[17:47:30.622]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘gc’
[17:47:30.622]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘job’
[17:47:30.622]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.579]   - Field: ‘conditions’
[17:47:30.623]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘expr’
[17:47:30.623]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘uuid’
[17:47:30.623]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘seed’
[17:47:30.623]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘version’
[17:47:30.623]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘result’
[17:47:30.623]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘asynchronous’
[17:47:30.624]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘calls’
[17:47:30.624]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.580]   - Field: ‘globals’
[17:47:30.624]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.581]   - Field: ‘stdout’
[17:47:30.624]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.581]   - Field: ‘earlySignal’
[17:47:30.624]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.581]   - Field: ‘lazy’
[17:47:30.624]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.581]   - Field: ‘state’
[17:47:30.624]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.581] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:30.625]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.581] - Launch lazy future ...
[17:47:30.625]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.582] Packages needed by the future expression (n = 0): <none>
[17:47:30.625]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.582] Packages needed by future strategies (n = 0): <none>
[17:47:30.625]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.583] {
[17:47:30.583]     {
[17:47:30.583]         {
[17:47:30.583]             ...future.startTime <- base::Sys.time()
[17:47:30.583]             {
[17:47:30.583]                 {
[17:47:30.583]                   {
[17:47:30.583]                     {
[17:47:30.583]                       base::local({
[17:47:30.583]                         has_future <- base::requireNamespace("future", 
[17:47:30.583]                           quietly = TRUE)
[17:47:30.583]                         if (has_future) {
[17:47:30.583]                           ns <- base::getNamespace("future")
[17:47:30.583]                           version <- ns[[".package"]][["version"]]
[17:47:30.583]                           if (is.null(version)) 
[17:47:30.583]                             version <- utils::packageVersion("future")
[17:47:30.583]                         }
[17:47:30.583]                         else {
[17:47:30.583]                           version <- NULL
[17:47:30.583]                         }
[17:47:30.583]                         if (!has_future || version < "1.8.0") {
[17:47:30.583]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.583]                             "", base::R.version$version.string), 
[17:47:30.583]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.583]                               "release", "version")], collapse = " "), 
[17:47:30.583]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.583]                             info)
[17:47:30.583]                           info <- base::paste(info, collapse = "; ")
[17:47:30.583]                           if (!has_future) {
[17:47:30.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.583]                               info)
[17:47:30.583]                           }
[17:47:30.583]                           else {
[17:47:30.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.583]                               info, version)
[17:47:30.583]                           }
[17:47:30.583]                           base::stop(msg)
[17:47:30.583]                         }
[17:47:30.583]                       })
[17:47:30.583]                     }
[17:47:30.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:30.583]                     base::options(mc.cores = 1L)
[17:47:30.583]                   }
[17:47:30.583]                   ...future.strategy.old <- future::plan("list")
[17:47:30.583]                   options(future.plan = NULL)
[17:47:30.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:30.583]                 }
[17:47:30.583]                 ...future.workdir <- getwd()
[17:47:30.583]             }
[17:47:30.583]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.583]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.583]         }
[17:47:30.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.583]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.583]             base::names(...future.oldOptions))
[17:47:30.583]     }
[17:47:30.583]     if (FALSE) {
[17:47:30.583]     }
[17:47:30.583]     else {
[17:47:30.583]         if (TRUE) {
[17:47:30.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.583]                 open = "w")
[17:47:30.583]         }
[17:47:30.583]         else {
[17:47:30.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.583]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.583]         }
[17:47:30.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.583]             base::sink(type = "output", split = FALSE)
[17:47:30.583]             base::close(...future.stdout)
[17:47:30.583]         }, add = TRUE)
[17:47:30.583]     }
[17:47:30.583]     ...future.frame <- base::sys.nframe()
[17:47:30.583]     ...future.conditions <- base::list()
[17:47:30.583]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.583]     if (FALSE) {
[17:47:30.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.583]     }
[17:47:30.583]     ...future.result <- base::tryCatch({
[17:47:30.583]         base::withCallingHandlers({
[17:47:30.583]             ...future.value <- base::withVisible(base::local({
[17:47:30.583]                 withCallingHandlers({
[17:47:30.583]                   {
[17:47:30.583]                     b <- 2L
[17:47:30.583]                     plan_b <- future::plan("list")
[17:47:30.583]                     nested_b <- nested_a[-1]
[17:47:30.583]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:30.583]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.583]                       "sequential"))
[17:47:30.583]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:30.583]                       b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:30.583]                   }
[17:47:30.583]                 }, immediateCondition = function(cond) {
[17:47:30.583]                   save_rds <- function (object, pathname, ...) 
[17:47:30.583]                   {
[17:47:30.583]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:30.583]                     if (file_test("-f", pathname_tmp)) {
[17:47:30.583]                       fi_tmp <- file.info(pathname_tmp)
[17:47:30.583]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:30.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:30.583]                         fi_tmp[["mtime"]])
[17:47:30.583]                     }
[17:47:30.583]                     tryCatch({
[17:47:30.583]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:30.583]                     }, error = function(ex) {
[17:47:30.583]                       msg <- conditionMessage(ex)
[17:47:30.583]                       fi_tmp <- file.info(pathname_tmp)
[17:47:30.583]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:30.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:30.583]                         fi_tmp[["mtime"]], msg)
[17:47:30.583]                       ex$message <- msg
[17:47:30.583]                       stop(ex)
[17:47:30.583]                     })
[17:47:30.583]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:30.583]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:30.583]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:30.583]                       fi_tmp <- file.info(pathname_tmp)
[17:47:30.583]                       fi <- file.info(pathname)
[17:47:30.583]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:30.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:30.583]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:30.583]                         fi[["size"]], fi[["mtime"]])
[17:47:30.583]                       stop(msg)
[17:47:30.583]                     }
[17:47:30.583]                     invisible(pathname)
[17:47:30.583]                   }
[17:47:30.583]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:30.583]                     rootPath = tempdir()) 
[17:47:30.583]                   {
[17:47:30.583]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:30.583]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:30.583]                       tmpdir = path, fileext = ".rds")
[17:47:30.583]                     save_rds(obj, file)
[17:47:30.583]                   }
[17:47:30.583]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:30.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.583]                   {
[17:47:30.583]                     inherits <- base::inherits
[17:47:30.583]                     invokeRestart <- base::invokeRestart
[17:47:30.583]                     is.null <- base::is.null
[17:47:30.583]                     muffled <- FALSE
[17:47:30.583]                     if (inherits(cond, "message")) {
[17:47:30.583]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:30.583]                       if (muffled) 
[17:47:30.583]                         invokeRestart("muffleMessage")
[17:47:30.583]                     }
[17:47:30.583]                     else if (inherits(cond, "warning")) {
[17:47:30.583]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:30.583]                       if (muffled) 
[17:47:30.583]                         invokeRestart("muffleWarning")
[17:47:30.583]                     }
[17:47:30.583]                     else if (inherits(cond, "condition")) {
[17:47:30.583]                       if (!is.null(pattern)) {
[17:47:30.583]                         computeRestarts <- base::computeRestarts
[17:47:30.583]                         grepl <- base::grepl
[17:47:30.583]                         restarts <- computeRestarts(cond)
[17:47:30.583]                         for (restart in restarts) {
[17:47:30.583]                           name <- restart$name
[17:47:30.583]                           if (is.null(name)) 
[17:47:30.583]                             next
[17:47:30.583]                           if (!grepl(pattern, name)) 
[17:47:30.583]                             next
[17:47:30.583]                           invokeRestart(restart)
[17:47:30.583]                           muffled <- TRUE
[17:47:30.583]                           break
[17:47:30.583]                         }
[17:47:30.583]                       }
[17:47:30.583]                     }
[17:47:30.583]                     invisible(muffled)
[17:47:30.583]                   }
[17:47:30.583]                   muffleCondition(cond)
[17:47:30.583]                 })
[17:47:30.583]             }))
[17:47:30.583]             future::FutureResult(value = ...future.value$value, 
[17:47:30.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.583]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.583]                     ...future.globalenv.names))
[17:47:30.583]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.583]         }, condition = base::local({
[17:47:30.583]             c <- base::c
[17:47:30.583]             inherits <- base::inherits
[17:47:30.583]             invokeRestart <- base::invokeRestart
[17:47:30.583]             length <- base::length
[17:47:30.583]             list <- base::list
[17:47:30.583]             seq.int <- base::seq.int
[17:47:30.583]             signalCondition <- base::signalCondition
[17:47:30.583]             sys.calls <- base::sys.calls
[17:47:30.583]             `[[` <- base::`[[`
[17:47:30.583]             `+` <- base::`+`
[17:47:30.583]             `<<-` <- base::`<<-`
[17:47:30.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.583]                   3L)]
[17:47:30.583]             }
[17:47:30.583]             function(cond) {
[17:47:30.583]                 is_error <- inherits(cond, "error")
[17:47:30.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.583]                   NULL)
[17:47:30.583]                 if (is_error) {
[17:47:30.583]                   sessionInformation <- function() {
[17:47:30.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.583]                       search = base::search(), system = base::Sys.info())
[17:47:30.583]                   }
[17:47:30.583]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.583]                     cond$call), session = sessionInformation(), 
[17:47:30.583]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.583]                   signalCondition(cond)
[17:47:30.583]                 }
[17:47:30.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.583]                 "immediateCondition"))) {
[17:47:30.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.583]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.583]                   if (TRUE && !signal) {
[17:47:30.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.583]                     {
[17:47:30.583]                       inherits <- base::inherits
[17:47:30.583]                       invokeRestart <- base::invokeRestart
[17:47:30.583]                       is.null <- base::is.null
[17:47:30.583]                       muffled <- FALSE
[17:47:30.583]                       if (inherits(cond, "message")) {
[17:47:30.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.583]                         if (muffled) 
[17:47:30.583]                           invokeRestart("muffleMessage")
[17:47:30.583]                       }
[17:47:30.583]                       else if (inherits(cond, "warning")) {
[17:47:30.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.583]                         if (muffled) 
[17:47:30.583]                           invokeRestart("muffleWarning")
[17:47:30.583]                       }
[17:47:30.583]                       else if (inherits(cond, "condition")) {
[17:47:30.583]                         if (!is.null(pattern)) {
[17:47:30.583]                           computeRestarts <- base::computeRestarts
[17:47:30.583]                           grepl <- base::grepl
[17:47:30.583]                           restarts <- computeRestarts(cond)
[17:47:30.583]                           for (restart in restarts) {
[17:47:30.583]                             name <- restart$name
[17:47:30.583]                             if (is.null(name)) 
[17:47:30.583]                               next
[17:47:30.583]                             if (!grepl(pattern, name)) 
[17:47:30.583]                               next
[17:47:30.583]                             invokeRestart(restart)
[17:47:30.583]                             muffled <- TRUE
[17:47:30.583]                             break
[17:47:30.583]                           }
[17:47:30.583]                         }
[17:47:30.583]                       }
[17:47:30.583]                       invisible(muffled)
[17:47:30.583]                     }
[17:47:30.583]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.583]                   }
[17:47:30.583]                 }
[17:47:30.583]                 else {
[17:47:30.583]                   if (TRUE) {
[17:47:30.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.583]                     {
[17:47:30.583]                       inherits <- base::inherits
[17:47:30.583]                       invokeRestart <- base::invokeRestart
[17:47:30.583]                       is.null <- base::is.null
[17:47:30.583]                       muffled <- FALSE
[17:47:30.583]                       if (inherits(cond, "message")) {
[17:47:30.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.583]                         if (muffled) 
[17:47:30.583]                           invokeRestart("muffleMessage")
[17:47:30.583]                       }
[17:47:30.583]                       else if (inherits(cond, "warning")) {
[17:47:30.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.583]                         if (muffled) 
[17:47:30.583]                           invokeRestart("muffleWarning")
[17:47:30.583]                       }
[17:47:30.583]                       else if (inherits(cond, "condition")) {
[17:47:30.583]                         if (!is.null(pattern)) {
[17:47:30.583]                           computeRestarts <- base::computeRestarts
[17:47:30.583]                           grepl <- base::grepl
[17:47:30.583]                           restarts <- computeRestarts(cond)
[17:47:30.583]                           for (restart in restarts) {
[17:47:30.583]                             name <- restart$name
[17:47:30.583]                             if (is.null(name)) 
[17:47:30.583]                               next
[17:47:30.583]                             if (!grepl(pattern, name)) 
[17:47:30.583]                               next
[17:47:30.583]                             invokeRestart(restart)
[17:47:30.583]                             muffled <- TRUE
[17:47:30.583]                             break
[17:47:30.583]                           }
[17:47:30.583]                         }
[17:47:30.583]                       }
[17:47:30.583]                       invisible(muffled)
[17:47:30.583]                     }
[17:47:30.583]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.583]                   }
[17:47:30.583]                 }
[17:47:30.583]             }
[17:47:30.583]         }))
[17:47:30.583]     }, error = function(ex) {
[17:47:30.583]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.583]                 ...future.rng), started = ...future.startTime, 
[17:47:30.583]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.583]             version = "1.8"), class = "FutureResult")
[17:47:30.583]     }, finally = {
[17:47:30.583]         if (!identical(...future.workdir, getwd())) 
[17:47:30.583]             setwd(...future.workdir)
[17:47:30.583]         {
[17:47:30.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.583]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.583]             }
[17:47:30.583]             base::options(...future.oldOptions)
[17:47:30.583]             if (.Platform$OS.type == "windows") {
[17:47:30.583]                 old_names <- names(...future.oldEnvVars)
[17:47:30.583]                 envs <- base::Sys.getenv()
[17:47:30.583]                 names <- names(envs)
[17:47:30.583]                 common <- intersect(names, old_names)
[17:47:30.583]                 added <- setdiff(names, old_names)
[17:47:30.583]                 removed <- setdiff(old_names, names)
[17:47:30.583]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.583]                   envs[common]]
[17:47:30.583]                 NAMES <- toupper(changed)
[17:47:30.583]                 args <- list()
[17:47:30.583]                 for (kk in seq_along(NAMES)) {
[17:47:30.583]                   name <- changed[[kk]]
[17:47:30.583]                   NAME <- NAMES[[kk]]
[17:47:30.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.583]                     next
[17:47:30.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.583]                 }
[17:47:30.583]                 NAMES <- toupper(added)
[17:47:30.583]                 for (kk in seq_along(NAMES)) {
[17:47:30.583]                   name <- added[[kk]]
[17:47:30.583]                   NAME <- NAMES[[kk]]
[17:47:30.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.583]                     next
[17:47:30.583]                   args[[name]] <- ""
[17:47:30.583]                 }
[17:47:30.583]                 NAMES <- toupper(removed)
[17:47:30.583]                 for (kk in seq_along(NAMES)) {
[17:47:30.583]                   name <- removed[[kk]]
[17:47:30.583]                   NAME <- NAMES[[kk]]
[17:47:30.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.583]                     next
[17:47:30.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.583]                 }
[17:47:30.583]                 if (length(args) > 0) 
[17:47:30.583]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.583]             }
[17:47:30.583]             else {
[17:47:30.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.583]             }
[17:47:30.583]             {
[17:47:30.583]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.583]                   0L) {
[17:47:30.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.583]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.583]                   base::options(opts)
[17:47:30.583]                 }
[17:47:30.583]                 {
[17:47:30.583]                   {
[17:47:30.583]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:30.583]                     NULL
[17:47:30.583]                   }
[17:47:30.583]                   options(future.plan = NULL)
[17:47:30.583]                   if (is.na(NA_character_)) 
[17:47:30.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.583]                     .init = FALSE)
[17:47:30.583]                 }
[17:47:30.583]             }
[17:47:30.583]         }
[17:47:30.583]     })
[17:47:30.583]     if (TRUE) {
[17:47:30.583]         base::sink(type = "output", split = FALSE)
[17:47:30.583]         if (TRUE) {
[17:47:30.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.583]         }
[17:47:30.583]         else {
[17:47:30.583]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.583]         }
[17:47:30.583]         base::close(...future.stdout)
[17:47:30.583]         ...future.stdout <- NULL
[17:47:30.583]     }
[17:47:30.583]     ...future.result$conditions <- ...future.conditions
[17:47:30.583]     ...future.result$finished <- base::Sys.time()
[17:47:30.583]     ...future.result
[17:47:30.583] }
[17:47:30.625]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.585] assign_globals() ...
[17:47:30.625]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.585] List of 3
[17:47:30.585]  $ nested_a:List of 1
[17:47:30.585]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:30.585]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:30.585]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.585]  $ a       : int 1
[17:47:30.585]  $ plan_a  :List of 1
[17:47:30.585]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:30.585]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:30.585]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.585]  - attr(*, "where")=List of 3
[17:47:30.585]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:47:30.585]   ..$ a       :<environment: R_EmptyEnv> 
[17:47:30.585]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:47:30.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.585]  - attr(*, "resolved")= logi FALSE
[17:47:30.585]  - attr(*, "total_size")= num 95240
[17:47:30.585]  - attr(*, "already-done")= logi TRUE
[17:47:30.626]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.590] - copied ‘nested_a’ to environment
[17:47:30.626]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.590] - copied ‘a’ to environment
[17:47:30.626]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.590] - copied ‘plan_a’ to environment
[17:47:30.626]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.590] assign_globals() ... done
[17:47:30.626]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.590] requestCore(): workers = 2
[17:47:30.626]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.593] MulticoreFuture started
[17:47:30.626]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.594] - Launch lazy future ... done
[17:47:30.627]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.594] run() for ‘MulticoreFuture’ ... done
[17:47:30.627]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.595] result() for MulticoreFuture ...
[17:47:30.627]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.614] result() for MulticoreFuture ...
[17:47:30.627]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.614] result() for MulticoreFuture ... done
[17:47:30.627]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.614] result() for MulticoreFuture ... done
[17:47:30.627]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.614] result() for MulticoreFuture ...
[17:47:30.627]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.614] result() for MulticoreFuture ... done
[17:47:30.628] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:30.633] getGlobalsAndPackages() ...
[17:47:30.633] Searching for globals...
[17:47:30.635] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:30.635] Searching for globals ... DONE
[17:47:30.635] Resolving globals: FALSE
[17:47:30.636] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:30.636] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:30.636] - globals: [1] ‘data’
[17:47:30.636] - packages: [1] ‘future’
[17:47:30.636] getGlobalsAndPackages() ... DONE
[17:47:30.637] run() for ‘Future’ ...
[17:47:30.637] - state: ‘created’
[17:47:30.637] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.637] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.639]   - Field: ‘label’
[17:47:30.639]   - Field: ‘local’
[17:47:30.639]   - Field: ‘owner’
[17:47:30.639]   - Field: ‘envir’
[17:47:30.639]   - Field: ‘packages’
[17:47:30.639]   - Field: ‘gc’
[17:47:30.639]   - Field: ‘conditions’
[17:47:30.639]   - Field: ‘expr’
[17:47:30.640]   - Field: ‘uuid’
[17:47:30.640]   - Field: ‘seed’
[17:47:30.640]   - Field: ‘version’
[17:47:30.640]   - Field: ‘result’
[17:47:30.640]   - Field: ‘asynchronous’
[17:47:30.640]   - Field: ‘calls’
[17:47:30.640]   - Field: ‘globals’
[17:47:30.640]   - Field: ‘stdout’
[17:47:30.640]   - Field: ‘earlySignal’
[17:47:30.640]   - Field: ‘lazy’
[17:47:30.640]   - Field: ‘state’
[17:47:30.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.641] - Launch lazy future ...
[17:47:30.641] Packages needed by the future expression (n = 1): ‘future’
[17:47:30.641] Packages needed by future strategies (n = 1): ‘future’
[17:47:30.642] {
[17:47:30.642]     {
[17:47:30.642]         {
[17:47:30.642]             ...future.startTime <- base::Sys.time()
[17:47:30.642]             {
[17:47:30.642]                 {
[17:47:30.642]                   {
[17:47:30.642]                     {
[17:47:30.642]                       base::local({
[17:47:30.642]                         has_future <- base::requireNamespace("future", 
[17:47:30.642]                           quietly = TRUE)
[17:47:30.642]                         if (has_future) {
[17:47:30.642]                           ns <- base::getNamespace("future")
[17:47:30.642]                           version <- ns[[".package"]][["version"]]
[17:47:30.642]                           if (is.null(version)) 
[17:47:30.642]                             version <- utils::packageVersion("future")
[17:47:30.642]                         }
[17:47:30.642]                         else {
[17:47:30.642]                           version <- NULL
[17:47:30.642]                         }
[17:47:30.642]                         if (!has_future || version < "1.8.0") {
[17:47:30.642]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.642]                             "", base::R.version$version.string), 
[17:47:30.642]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.642]                               "release", "version")], collapse = " "), 
[17:47:30.642]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.642]                             info)
[17:47:30.642]                           info <- base::paste(info, collapse = "; ")
[17:47:30.642]                           if (!has_future) {
[17:47:30.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.642]                               info)
[17:47:30.642]                           }
[17:47:30.642]                           else {
[17:47:30.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.642]                               info, version)
[17:47:30.642]                           }
[17:47:30.642]                           base::stop(msg)
[17:47:30.642]                         }
[17:47:30.642]                       })
[17:47:30.642]                     }
[17:47:30.642]                     base::local({
[17:47:30.642]                       for (pkg in "future") {
[17:47:30.642]                         base::loadNamespace(pkg)
[17:47:30.642]                         base::library(pkg, character.only = TRUE)
[17:47:30.642]                       }
[17:47:30.642]                     })
[17:47:30.642]                   }
[17:47:30.642]                   ...future.strategy.old <- future::plan("list")
[17:47:30.642]                   options(future.plan = NULL)
[17:47:30.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.642]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:30.642]                     envir = parent.frame()) 
[17:47:30.642]                   {
[17:47:30.642]                     default_workers <- missing(workers)
[17:47:30.642]                     if (is.function(workers)) 
[17:47:30.642]                       workers <- workers()
[17:47:30.642]                     workers <- structure(as.integer(workers), 
[17:47:30.642]                       class = class(workers))
[17:47:30.642]                     stop_if_not(is.finite(workers), workers >= 
[17:47:30.642]                       1L)
[17:47:30.642]                     if ((workers == 1L && !inherits(workers, 
[17:47:30.642]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:30.642]                       if (default_workers) 
[17:47:30.642]                         supportsMulticore(warn = TRUE)
[17:47:30.642]                       return(sequential(..., envir = envir))
[17:47:30.642]                     }
[17:47:30.642]                     oopts <- options(mc.cores = workers)
[17:47:30.642]                     on.exit(options(oopts))
[17:47:30.642]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:30.642]                       envir = envir)
[17:47:30.642]                     if (!future$lazy) 
[17:47:30.642]                       future <- run(future)
[17:47:30.642]                     invisible(future)
[17:47:30.642]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:30.642]                 }
[17:47:30.642]                 ...future.workdir <- getwd()
[17:47:30.642]             }
[17:47:30.642]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.642]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.642]         }
[17:47:30.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.642]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.642]             base::names(...future.oldOptions))
[17:47:30.642]     }
[17:47:30.642]     if (FALSE) {
[17:47:30.642]     }
[17:47:30.642]     else {
[17:47:30.642]         if (TRUE) {
[17:47:30.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.642]                 open = "w")
[17:47:30.642]         }
[17:47:30.642]         else {
[17:47:30.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.642]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.642]         }
[17:47:30.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.642]             base::sink(type = "output", split = FALSE)
[17:47:30.642]             base::close(...future.stdout)
[17:47:30.642]         }, add = TRUE)
[17:47:30.642]     }
[17:47:30.642]     ...future.frame <- base::sys.nframe()
[17:47:30.642]     ...future.conditions <- base::list()
[17:47:30.642]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.642]     if (FALSE) {
[17:47:30.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.642]     }
[17:47:30.642]     ...future.result <- base::tryCatch({
[17:47:30.642]         base::withCallingHandlers({
[17:47:30.642]             ...future.value <- base::withVisible(base::local({
[17:47:30.642]                 value(future(subset(data, a == 2)))
[17:47:30.642]             }))
[17:47:30.642]             future::FutureResult(value = ...future.value$value, 
[17:47:30.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.642]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.642]                     ...future.globalenv.names))
[17:47:30.642]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.642]         }, condition = base::local({
[17:47:30.642]             c <- base::c
[17:47:30.642]             inherits <- base::inherits
[17:47:30.642]             invokeRestart <- base::invokeRestart
[17:47:30.642]             length <- base::length
[17:47:30.642]             list <- base::list
[17:47:30.642]             seq.int <- base::seq.int
[17:47:30.642]             signalCondition <- base::signalCondition
[17:47:30.642]             sys.calls <- base::sys.calls
[17:47:30.642]             `[[` <- base::`[[`
[17:47:30.642]             `+` <- base::`+`
[17:47:30.642]             `<<-` <- base::`<<-`
[17:47:30.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.642]                   3L)]
[17:47:30.642]             }
[17:47:30.642]             function(cond) {
[17:47:30.642]                 is_error <- inherits(cond, "error")
[17:47:30.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.642]                   NULL)
[17:47:30.642]                 if (is_error) {
[17:47:30.642]                   sessionInformation <- function() {
[17:47:30.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.642]                       search = base::search(), system = base::Sys.info())
[17:47:30.642]                   }
[17:47:30.642]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.642]                     cond$call), session = sessionInformation(), 
[17:47:30.642]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.642]                   signalCondition(cond)
[17:47:30.642]                 }
[17:47:30.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.642]                 "immediateCondition"))) {
[17:47:30.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.642]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.642]                   if (TRUE && !signal) {
[17:47:30.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.642]                     {
[17:47:30.642]                       inherits <- base::inherits
[17:47:30.642]                       invokeRestart <- base::invokeRestart
[17:47:30.642]                       is.null <- base::is.null
[17:47:30.642]                       muffled <- FALSE
[17:47:30.642]                       if (inherits(cond, "message")) {
[17:47:30.642]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.642]                         if (muffled) 
[17:47:30.642]                           invokeRestart("muffleMessage")
[17:47:30.642]                       }
[17:47:30.642]                       else if (inherits(cond, "warning")) {
[17:47:30.642]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.642]                         if (muffled) 
[17:47:30.642]                           invokeRestart("muffleWarning")
[17:47:30.642]                       }
[17:47:30.642]                       else if (inherits(cond, "condition")) {
[17:47:30.642]                         if (!is.null(pattern)) {
[17:47:30.642]                           computeRestarts <- base::computeRestarts
[17:47:30.642]                           grepl <- base::grepl
[17:47:30.642]                           restarts <- computeRestarts(cond)
[17:47:30.642]                           for (restart in restarts) {
[17:47:30.642]                             name <- restart$name
[17:47:30.642]                             if (is.null(name)) 
[17:47:30.642]                               next
[17:47:30.642]                             if (!grepl(pattern, name)) 
[17:47:30.642]                               next
[17:47:30.642]                             invokeRestart(restart)
[17:47:30.642]                             muffled <- TRUE
[17:47:30.642]                             break
[17:47:30.642]                           }
[17:47:30.642]                         }
[17:47:30.642]                       }
[17:47:30.642]                       invisible(muffled)
[17:47:30.642]                     }
[17:47:30.642]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.642]                   }
[17:47:30.642]                 }
[17:47:30.642]                 else {
[17:47:30.642]                   if (TRUE) {
[17:47:30.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.642]                     {
[17:47:30.642]                       inherits <- base::inherits
[17:47:30.642]                       invokeRestart <- base::invokeRestart
[17:47:30.642]                       is.null <- base::is.null
[17:47:30.642]                       muffled <- FALSE
[17:47:30.642]                       if (inherits(cond, "message")) {
[17:47:30.642]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.642]                         if (muffled) 
[17:47:30.642]                           invokeRestart("muffleMessage")
[17:47:30.642]                       }
[17:47:30.642]                       else if (inherits(cond, "warning")) {
[17:47:30.642]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.642]                         if (muffled) 
[17:47:30.642]                           invokeRestart("muffleWarning")
[17:47:30.642]                       }
[17:47:30.642]                       else if (inherits(cond, "condition")) {
[17:47:30.642]                         if (!is.null(pattern)) {
[17:47:30.642]                           computeRestarts <- base::computeRestarts
[17:47:30.642]                           grepl <- base::grepl
[17:47:30.642]                           restarts <- computeRestarts(cond)
[17:47:30.642]                           for (restart in restarts) {
[17:47:30.642]                             name <- restart$name
[17:47:30.642]                             if (is.null(name)) 
[17:47:30.642]                               next
[17:47:30.642]                             if (!grepl(pattern, name)) 
[17:47:30.642]                               next
[17:47:30.642]                             invokeRestart(restart)
[17:47:30.642]                             muffled <- TRUE
[17:47:30.642]                             break
[17:47:30.642]                           }
[17:47:30.642]                         }
[17:47:30.642]                       }
[17:47:30.642]                       invisible(muffled)
[17:47:30.642]                     }
[17:47:30.642]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.642]                   }
[17:47:30.642]                 }
[17:47:30.642]             }
[17:47:30.642]         }))
[17:47:30.642]     }, error = function(ex) {
[17:47:30.642]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.642]                 ...future.rng), started = ...future.startTime, 
[17:47:30.642]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.642]             version = "1.8"), class = "FutureResult")
[17:47:30.642]     }, finally = {
[17:47:30.642]         if (!identical(...future.workdir, getwd())) 
[17:47:30.642]             setwd(...future.workdir)
[17:47:30.642]         {
[17:47:30.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.642]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.642]             }
[17:47:30.642]             base::options(...future.oldOptions)
[17:47:30.642]             if (.Platform$OS.type == "windows") {
[17:47:30.642]                 old_names <- names(...future.oldEnvVars)
[17:47:30.642]                 envs <- base::Sys.getenv()
[17:47:30.642]                 names <- names(envs)
[17:47:30.642]                 common <- intersect(names, old_names)
[17:47:30.642]                 added <- setdiff(names, old_names)
[17:47:30.642]                 removed <- setdiff(old_names, names)
[17:47:30.642]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.642]                   envs[common]]
[17:47:30.642]                 NAMES <- toupper(changed)
[17:47:30.642]                 args <- list()
[17:47:30.642]                 for (kk in seq_along(NAMES)) {
[17:47:30.642]                   name <- changed[[kk]]
[17:47:30.642]                   NAME <- NAMES[[kk]]
[17:47:30.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.642]                     next
[17:47:30.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.642]                 }
[17:47:30.642]                 NAMES <- toupper(added)
[17:47:30.642]                 for (kk in seq_along(NAMES)) {
[17:47:30.642]                   name <- added[[kk]]
[17:47:30.642]                   NAME <- NAMES[[kk]]
[17:47:30.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.642]                     next
[17:47:30.642]                   args[[name]] <- ""
[17:47:30.642]                 }
[17:47:30.642]                 NAMES <- toupper(removed)
[17:47:30.642]                 for (kk in seq_along(NAMES)) {
[17:47:30.642]                   name <- removed[[kk]]
[17:47:30.642]                   NAME <- NAMES[[kk]]
[17:47:30.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.642]                     next
[17:47:30.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.642]                 }
[17:47:30.642]                 if (length(args) > 0) 
[17:47:30.642]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.642]             }
[17:47:30.642]             else {
[17:47:30.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.642]             }
[17:47:30.642]             {
[17:47:30.642]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.642]                   0L) {
[17:47:30.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.642]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.642]                   base::options(opts)
[17:47:30.642]                 }
[17:47:30.642]                 {
[17:47:30.642]                   {
[17:47:30.642]                     NULL
[17:47:30.642]                     RNGkind("Mersenne-Twister")
[17:47:30.642]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.642]                       inherits = FALSE)
[17:47:30.642]                   }
[17:47:30.642]                   options(future.plan = NULL)
[17:47:30.642]                   if (is.na(NA_character_)) 
[17:47:30.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.642]                     .init = FALSE)
[17:47:30.642]                 }
[17:47:30.642]             }
[17:47:30.642]         }
[17:47:30.642]     })
[17:47:30.642]     if (TRUE) {
[17:47:30.642]         base::sink(type = "output", split = FALSE)
[17:47:30.642]         if (TRUE) {
[17:47:30.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.642]         }
[17:47:30.642]         else {
[17:47:30.642]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.642]         }
[17:47:30.642]         base::close(...future.stdout)
[17:47:30.642]         ...future.stdout <- NULL
[17:47:30.642]     }
[17:47:30.642]     ...future.result$conditions <- ...future.conditions
[17:47:30.642]     ...future.result$finished <- base::Sys.time()
[17:47:30.642]     ...future.result
[17:47:30.642] }
[17:47:30.643] assign_globals() ...
[17:47:30.643] List of 1
[17:47:30.643]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:30.643]   ..$ a: int [1:3] 1 2 3
[17:47:30.643]   ..$ b: int [1:3] 3 2 1
[17:47:30.643]  - attr(*, "where")=List of 1
[17:47:30.643]   ..$ data:<environment: R_EmptyEnv> 
[17:47:30.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.643]  - attr(*, "resolved")= logi FALSE
[17:47:30.643]  - attr(*, "total_size")= num 128
[17:47:30.643]  - attr(*, "already-done")= logi TRUE
[17:47:30.646] - copied ‘data’ to environment
[17:47:30.646] assign_globals() ... done
[17:47:30.647] plan(): Setting new future strategy stack:
[17:47:30.647] List of future strategies:
[17:47:30.647] 1. multicore:
[17:47:30.647]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:30.647]    - tweaked: FALSE
[17:47:30.647]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.651] plan(): nbrOfWorkers() = 2
[17:47:30.694] plan(): Setting new future strategy stack:
[17:47:30.694] List of future strategies:
[17:47:30.694] 1. sequential:
[17:47:30.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.694]    - tweaked: FALSE
[17:47:30.694]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.694] 2. multicore:
[17:47:30.694]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:30.694]    - tweaked: FALSE
[17:47:30.694]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.695] plan(): nbrOfWorkers() = 1
[17:47:30.695] SequentialFuture started (and completed)
[17:47:30.695] signalConditions() ...
[17:47:30.696]  - include = ‘immediateCondition’
[17:47:30.696]  - exclude = 
[17:47:30.696]  - resignal = FALSE
[17:47:30.696]  - Number of conditions: 55
[17:47:30.696] signalConditions() ... done
[17:47:30.696] - Launch lazy future ... done
[17:47:30.696] run() for ‘SequentialFuture’ ... done
[17:47:30.697] signalConditions() ...
[17:47:30.697]  - include = ‘immediateCondition’
[17:47:30.697]  - exclude = 
[17:47:30.697]  - resignal = FALSE
[17:47:30.697]  - Number of conditions: 55
[17:47:30.697] signalConditions() ... done
[17:47:30.697] Future state: ‘finished’
[17:47:30.697] signalConditions() ...
[17:47:30.697]  - include = ‘condition’
[17:47:30.698]  - exclude = ‘immediateCondition’
[17:47:30.698]  - resignal = TRUE
[17:47:30.698]  - Number of conditions: 55
[17:47:30.698]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.651] getGlobalsAndPackages() ...
[17:47:30.698]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.651] Searching for globals...
[17:47:30.698]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.666] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:30.698]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.666] Searching for globals ... DONE
[17:47:30.699]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.666] Resolving globals: FALSE
[17:47:30.699]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.667] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:30.699]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.667] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:30.699]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.667] - globals: [1] ‘data’
[17:47:30.699]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.667] 
[17:47:30.699]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.668] getGlobalsAndPackages() ... DONE
[17:47:30.700]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.668] run() for ‘Future’ ...
[17:47:30.700]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.668] - state: ‘created’
[17:47:30.700]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:30.700]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:30.700]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:30.700]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘label’
[17:47:30.700]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘local’
[17:47:30.701]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘owner’
[17:47:30.701]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘envir’
[17:47:30.703]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘workers’
[17:47:30.703]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘packages’
[17:47:30.704]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘gc’
[17:47:30.704]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.672]   - Field: ‘job’
[17:47:30.704]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘conditions’
[17:47:30.704]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘expr’
[17:47:30.704]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘uuid’
[17:47:30.705]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘seed’
[17:47:30.705]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘version’
[17:47:30.705]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘result’
[17:47:30.705]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘asynchronous’
[17:47:30.705]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘calls’
[17:47:30.705]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘globals’
[17:47:30.706]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.673]   - Field: ‘stdout’
[17:47:30.706]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674]   - Field: ‘earlySignal’
[17:47:30.706]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674]   - Field: ‘lazy’
[17:47:30.706]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674]   - Field: ‘state’
[17:47:30.706]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:30.706]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674] - Launch lazy future ...
[17:47:30.707]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674] Packages needed by the future expression (n = 0): <none>
[17:47:30.707]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.674] Packages needed by future strategies (n = 0): <none>
[17:47:30.707]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.675] {
[17:47:30.675]     {
[17:47:30.675]         {
[17:47:30.675]             ...future.startTime <- base::Sys.time()
[17:47:30.675]             {
[17:47:30.675]                 {
[17:47:30.675]                   {
[17:47:30.675]                     {
[17:47:30.675]                       base::local({
[17:47:30.675]                         has_future <- base::requireNamespace("future", 
[17:47:30.675]                           quietly = TRUE)
[17:47:30.675]                         if (has_future) {
[17:47:30.675]                           ns <- base::getNamespace("future")
[17:47:30.675]                           version <- ns[[".package"]][["version"]]
[17:47:30.675]                           if (is.null(version)) 
[17:47:30.675]                             version <- utils::packageVersion("future")
[17:47:30.675]                         }
[17:47:30.675]                         else {
[17:47:30.675]                           version <- NULL
[17:47:30.675]                         }
[17:47:30.675]                         if (!has_future || version < "1.8.0") {
[17:47:30.675]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.675]                             "", base::R.version$version.string), 
[17:47:30.675]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.675]                               "release", "version")], collapse = " "), 
[17:47:30.675]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.675]                             info)
[17:47:30.675]                           info <- base::paste(info, collapse = "; ")
[17:47:30.675]                           if (!has_future) {
[17:47:30.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.675]                               info)
[17:47:30.675]                           }
[17:47:30.675]                           else {
[17:47:30.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.675]                               info, version)
[17:47:30.675]                           }
[17:47:30.675]                           base::stop(msg)
[17:47:30.675]                         }
[17:47:30.675]                       })
[17:47:30.675]                     }
[17:47:30.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:30.675]                     base::options(mc.cores = 1L)
[17:47:30.675]                   }
[17:47:30.675]                   ...future.strategy.old <- future::plan("list")
[17:47:30.675]                   options(future.plan = NULL)
[17:47:30.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:30.675]                 }
[17:47:30.675]                 ...future.workdir <- getwd()
[17:47:30.675]             }
[17:47:30.675]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.675]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.675]         }
[17:47:30.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.675]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.675]             base::names(...future.oldOptions))
[17:47:30.675]     }
[17:47:30.675]     if (FALSE) {
[17:47:30.675]     }
[17:47:30.675]     else {
[17:47:30.675]         if (TRUE) {
[17:47:30.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.675]                 open = "w")
[17:47:30.675]         }
[17:47:30.675]         else {
[17:47:30.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.675]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.675]         }
[17:47:30.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.675]             base::sink(type = "output", split = FALSE)
[17:47:30.675]             base::close(...future.stdout)
[17:47:30.675]         }, add = TRUE)
[17:47:30.675]     }
[17:47:30.675]     ...future.frame <- base::sys.nframe()
[17:47:30.675]     ...future.conditions <- base::list()
[17:47:30.675]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.675]     if (FALSE) {
[17:47:30.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.675]     }
[17:47:30.675]     ...future.result <- base::tryCatch({
[17:47:30.675]         base::withCallingHandlers({
[17:47:30.675]             ...future.value <- base::withVisible(base::local({
[17:47:30.675]                 withCallingHandlers({
[17:47:30.675]                   subset(data, a == 2)
[17:47:30.675]                 }, immediateCondition = function(cond) {
[17:47:30.675]                   save_rds <- function (object, pathname, ...) 
[17:47:30.675]                   {
[17:47:30.675]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:30.675]                     if (file_test("-f", pathname_tmp)) {
[17:47:30.675]                       fi_tmp <- file.info(pathname_tmp)
[17:47:30.675]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:30.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:30.675]                         fi_tmp[["mtime"]])
[17:47:30.675]                     }
[17:47:30.675]                     tryCatch({
[17:47:30.675]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:30.675]                     }, error = function(ex) {
[17:47:30.675]                       msg <- conditionMessage(ex)
[17:47:30.675]                       fi_tmp <- file.info(pathname_tmp)
[17:47:30.675]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:30.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:30.675]                         fi_tmp[["mtime"]], msg)
[17:47:30.675]                       ex$message <- msg
[17:47:30.675]                       stop(ex)
[17:47:30.675]                     })
[17:47:30.675]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:30.675]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:30.675]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:30.675]                       fi_tmp <- file.info(pathname_tmp)
[17:47:30.675]                       fi <- file.info(pathname)
[17:47:30.675]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:30.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:30.675]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:30.675]                         fi[["size"]], fi[["mtime"]])
[17:47:30.675]                       stop(msg)
[17:47:30.675]                     }
[17:47:30.675]                     invisible(pathname)
[17:47:30.675]                   }
[17:47:30.675]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:30.675]                     rootPath = tempdir()) 
[17:47:30.675]                   {
[17:47:30.675]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:30.675]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:30.675]                       tmpdir = path, fileext = ".rds")
[17:47:30.675]                     save_rds(obj, file)
[17:47:30.675]                   }
[17:47:30.675]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:30.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.675]                   {
[17:47:30.675]                     inherits <- base::inherits
[17:47:30.675]                     invokeRestart <- base::invokeRestart
[17:47:30.675]                     is.null <- base::is.null
[17:47:30.675]                     muffled <- FALSE
[17:47:30.675]                     if (inherits(cond, "message")) {
[17:47:30.675]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:30.675]                       if (muffled) 
[17:47:30.675]                         invokeRestart("muffleMessage")
[17:47:30.675]                     }
[17:47:30.675]                     else if (inherits(cond, "warning")) {
[17:47:30.675]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:30.675]                       if (muffled) 
[17:47:30.675]                         invokeRestart("muffleWarning")
[17:47:30.675]                     }
[17:47:30.675]                     else if (inherits(cond, "condition")) {
[17:47:30.675]                       if (!is.null(pattern)) {
[17:47:30.675]                         computeRestarts <- base::computeRestarts
[17:47:30.675]                         grepl <- base::grepl
[17:47:30.675]                         restarts <- computeRestarts(cond)
[17:47:30.675]                         for (restart in restarts) {
[17:47:30.675]                           name <- restart$name
[17:47:30.675]                           if (is.null(name)) 
[17:47:30.675]                             next
[17:47:30.675]                           if (!grepl(pattern, name)) 
[17:47:30.675]                             next
[17:47:30.675]                           invokeRestart(restart)
[17:47:30.675]                           muffled <- TRUE
[17:47:30.675]                           break
[17:47:30.675]                         }
[17:47:30.675]                       }
[17:47:30.675]                     }
[17:47:30.675]                     invisible(muffled)
[17:47:30.675]                   }
[17:47:30.675]                   muffleCondition(cond)
[17:47:30.675]                 })
[17:47:30.675]             }))
[17:47:30.675]             future::FutureResult(value = ...future.value$value, 
[17:47:30.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.675]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.675]                     ...future.globalenv.names))
[17:47:30.675]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.675]         }, condition = base::local({
[17:47:30.675]             c <- base::c
[17:47:30.675]             inherits <- base::inherits
[17:47:30.675]             invokeRestart <- base::invokeRestart
[17:47:30.675]             length <- base::length
[17:47:30.675]             list <- base::list
[17:47:30.675]             seq.int <- base::seq.int
[17:47:30.675]             signalCondition <- base::signalCondition
[17:47:30.675]             sys.calls <- base::sys.calls
[17:47:30.675]             `[[` <- base::`[[`
[17:47:30.675]             `+` <- base::`+`
[17:47:30.675]             `<<-` <- base::`<<-`
[17:47:30.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.675]                   3L)]
[17:47:30.675]             }
[17:47:30.675]             function(cond) {
[17:47:30.675]                 is_error <- inherits(cond, "error")
[17:47:30.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.675]                   NULL)
[17:47:30.675]                 if (is_error) {
[17:47:30.675]                   sessionInformation <- function() {
[17:47:30.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.675]                       search = base::search(), system = base::Sys.info())
[17:47:30.675]                   }
[17:47:30.675]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.675]                     cond$call), session = sessionInformation(), 
[17:47:30.675]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.675]                   signalCondition(cond)
[17:47:30.675]                 }
[17:47:30.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.675]                 "immediateCondition"))) {
[17:47:30.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.675]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.675]                   if (TRUE && !signal) {
[17:47:30.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.675]                     {
[17:47:30.675]                       inherits <- base::inherits
[17:47:30.675]                       invokeRestart <- base::invokeRestart
[17:47:30.675]                       is.null <- base::is.null
[17:47:30.675]                       muffled <- FALSE
[17:47:30.675]                       if (inherits(cond, "message")) {
[17:47:30.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.675]                         if (muffled) 
[17:47:30.675]                           invokeRestart("muffleMessage")
[17:47:30.675]                       }
[17:47:30.675]                       else if (inherits(cond, "warning")) {
[17:47:30.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.675]                         if (muffled) 
[17:47:30.675]                           invokeRestart("muffleWarning")
[17:47:30.675]                       }
[17:47:30.675]                       else if (inherits(cond, "condition")) {
[17:47:30.675]                         if (!is.null(pattern)) {
[17:47:30.675]                           computeRestarts <- base::computeRestarts
[17:47:30.675]                           grepl <- base::grepl
[17:47:30.675]                           restarts <- computeRestarts(cond)
[17:47:30.675]                           for (restart in restarts) {
[17:47:30.675]                             name <- restart$name
[17:47:30.675]                             if (is.null(name)) 
[17:47:30.675]                               next
[17:47:30.675]                             if (!grepl(pattern, name)) 
[17:47:30.675]                               next
[17:47:30.675]                             invokeRestart(restart)
[17:47:30.675]                             muffled <- TRUE
[17:47:30.675]                             break
[17:47:30.675]                           }
[17:47:30.675]                         }
[17:47:30.675]                       }
[17:47:30.675]                       invisible(muffled)
[17:47:30.675]                     }
[17:47:30.675]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.675]                   }
[17:47:30.675]                 }
[17:47:30.675]                 else {
[17:47:30.675]                   if (TRUE) {
[17:47:30.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.675]                     {
[17:47:30.675]                       inherits <- base::inherits
[17:47:30.675]                       invokeRestart <- base::invokeRestart
[17:47:30.675]                       is.null <- base::is.null
[17:47:30.675]                       muffled <- FALSE
[17:47:30.675]                       if (inherits(cond, "message")) {
[17:47:30.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.675]                         if (muffled) 
[17:47:30.675]                           invokeRestart("muffleMessage")
[17:47:30.675]                       }
[17:47:30.675]                       else if (inherits(cond, "warning")) {
[17:47:30.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.675]                         if (muffled) 
[17:47:30.675]                           invokeRestart("muffleWarning")
[17:47:30.675]                       }
[17:47:30.675]                       else if (inherits(cond, "condition")) {
[17:47:30.675]                         if (!is.null(pattern)) {
[17:47:30.675]                           computeRestarts <- base::computeRestarts
[17:47:30.675]                           grepl <- base::grepl
[17:47:30.675]                           restarts <- computeRestarts(cond)
[17:47:30.675]                           for (restart in restarts) {
[17:47:30.675]                             name <- restart$name
[17:47:30.675]                             if (is.null(name)) 
[17:47:30.675]                               next
[17:47:30.675]                             if (!grepl(pattern, name)) 
[17:47:30.675]                               next
[17:47:30.675]                             invokeRestart(restart)
[17:47:30.675]                             muffled <- TRUE
[17:47:30.675]                             break
[17:47:30.675]                           }
[17:47:30.675]                         }
[17:47:30.675]                       }
[17:47:30.675]                       invisible(muffled)
[17:47:30.675]                     }
[17:47:30.675]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.675]                   }
[17:47:30.675]                 }
[17:47:30.675]             }
[17:47:30.675]         }))
[17:47:30.675]     }, error = function(ex) {
[17:47:30.675]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.675]                 ...future.rng), started = ...future.startTime, 
[17:47:30.675]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.675]             version = "1.8"), class = "FutureResult")
[17:47:30.675]     }, finally = {
[17:47:30.675]         if (!identical(...future.workdir, getwd())) 
[17:47:30.675]             setwd(...future.workdir)
[17:47:30.675]         {
[17:47:30.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.675]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.675]             }
[17:47:30.675]             base::options(...future.oldOptions)
[17:47:30.675]             if (.Platform$OS.type == "windows") {
[17:47:30.675]                 old_names <- names(...future.oldEnvVars)
[17:47:30.675]                 envs <- base::Sys.getenv()
[17:47:30.675]                 names <- names(envs)
[17:47:30.675]                 common <- intersect(names, old_names)
[17:47:30.675]                 added <- setdiff(names, old_names)
[17:47:30.675]                 removed <- setdiff(old_names, names)
[17:47:30.675]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.675]                   envs[common]]
[17:47:30.675]                 NAMES <- toupper(changed)
[17:47:30.675]                 args <- list()
[17:47:30.675]                 for (kk in seq_along(NAMES)) {
[17:47:30.675]                   name <- changed[[kk]]
[17:47:30.675]                   NAME <- NAMES[[kk]]
[17:47:30.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.675]                     next
[17:47:30.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.675]                 }
[17:47:30.675]                 NAMES <- toupper(added)
[17:47:30.675]                 for (kk in seq_along(NAMES)) {
[17:47:30.675]                   name <- added[[kk]]
[17:47:30.675]                   NAME <- NAMES[[kk]]
[17:47:30.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.675]                     next
[17:47:30.675]                   args[[name]] <- ""
[17:47:30.675]                 }
[17:47:30.675]                 NAMES <- toupper(removed)
[17:47:30.675]                 for (kk in seq_along(NAMES)) {
[17:47:30.675]                   name <- removed[[kk]]
[17:47:30.675]                   NAME <- NAMES[[kk]]
[17:47:30.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.675]                     next
[17:47:30.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.675]                 }
[17:47:30.675]                 if (length(args) > 0) 
[17:47:30.675]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.675]             }
[17:47:30.675]             else {
[17:47:30.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.675]             }
[17:47:30.675]             {
[17:47:30.675]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.675]                   0L) {
[17:47:30.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.675]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.675]                   base::options(opts)
[17:47:30.675]                 }
[17:47:30.675]                 {
[17:47:30.675]                   {
[17:47:30.675]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:30.675]                     NULL
[17:47:30.675]                   }
[17:47:30.675]                   options(future.plan = NULL)
[17:47:30.675]                   if (is.na(NA_character_)) 
[17:47:30.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.675]                     .init = FALSE)
[17:47:30.675]                 }
[17:47:30.675]             }
[17:47:30.675]         }
[17:47:30.675]     })
[17:47:30.675]     if (TRUE) {
[17:47:30.675]         base::sink(type = "output", split = FALSE)
[17:47:30.675]         if (TRUE) {
[17:47:30.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.675]         }
[17:47:30.675]         else {
[17:47:30.675]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.675]         }
[17:47:30.675]         base::close(...future.stdout)
[17:47:30.675]         ...future.stdout <- NULL
[17:47:30.675]     }
[17:47:30.675]     ...future.result$conditions <- ...future.conditions
[17:47:30.675]     ...future.result$finished <- base::Sys.time()
[17:47:30.675]     ...future.result
[17:47:30.675] }
[17:47:30.707]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.677] assign_globals() ...
[17:47:30.707]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.677] List of 1
[17:47:30.677]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:30.677]   ..$ a: int [1:3] 1 2 3
[17:47:30.677]   ..$ b: int [1:3] 3 2 1
[17:47:30.677]  - attr(*, "where")=List of 1
[17:47:30.677]   ..$ data:<environment: R_EmptyEnv> 
[17:47:30.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.677]  - attr(*, "resolved")= logi FALSE
[17:47:30.677]  - attr(*, "total_size")= num 128
[17:47:30.677]  - attr(*, "already-done")= logi TRUE
[17:47:30.707]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.680] - copied ‘data’ to environment
[17:47:30.708]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.680] assign_globals() ... done
[17:47:30.708]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.680] requestCore(): workers = 2
[17:47:30.708]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.682] MulticoreFuture started
[17:47:30.708]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.683] - Launch lazy future ... done
[17:47:30.708]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.683] run() for ‘MulticoreFuture’ ... done
[17:47:30.708]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.684] result() for MulticoreFuture ...
[17:47:30.709]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.693] result() for MulticoreFuture ...
[17:47:30.709]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.693] result() for MulticoreFuture ... done
[17:47:30.709]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.693] result() for MulticoreFuture ... done
[17:47:30.709]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.693] result() for MulticoreFuture ...
[17:47:30.709]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.693] result() for MulticoreFuture ... done
[17:47:30.709] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[17:47:30.710] plan(): Setting new future strategy stack:
[17:47:30.710] List of future strategies:
[17:47:30.710] 1. sequential:
[17:47:30.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:30.710]    - tweaked: FALSE
[17:47:30.710]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.710] 2. multisession:
[17:47:30.710]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:30.710]    - tweaked: FALSE
[17:47:30.710]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.711] plan(): nbrOfWorkers() = 1
[17:47:30.711] getGlobalsAndPackages() ...
[17:47:30.711] Searching for globals...
[17:47:30.729] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:30.729] Searching for globals ... DONE
[17:47:30.729] Resolving globals: FALSE
[17:47:30.730] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[17:47:30.730] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:30.730] - globals: [2] ‘nested’, ‘strategy2’
[17:47:30.731] - packages: [1] ‘future’
[17:47:30.731] getGlobalsAndPackages() ... DONE
[17:47:30.731] run() for ‘Future’ ...
[17:47:30.731] - state: ‘created’
[17:47:30.731] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:30.732] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:30.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:30.732]   - Field: ‘label’
[17:47:30.732]   - Field: ‘local’
[17:47:30.732]   - Field: ‘owner’
[17:47:30.732]   - Field: ‘envir’
[17:47:30.732]   - Field: ‘packages’
[17:47:30.732]   - Field: ‘gc’
[17:47:30.732]   - Field: ‘conditions’
[17:47:30.732]   - Field: ‘expr’
[17:47:30.732]   - Field: ‘uuid’
[17:47:30.733]   - Field: ‘seed’
[17:47:30.733]   - Field: ‘version’
[17:47:30.733]   - Field: ‘result’
[17:47:30.733]   - Field: ‘asynchronous’
[17:47:30.733]   - Field: ‘calls’
[17:47:30.733]   - Field: ‘globals’
[17:47:30.733]   - Field: ‘stdout’
[17:47:30.733]   - Field: ‘earlySignal’
[17:47:30.733]   - Field: ‘lazy’
[17:47:30.733]   - Field: ‘state’
[17:47:30.733] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:30.734] - Launch lazy future ...
[17:47:30.734] Packages needed by the future expression (n = 1): ‘future’
[17:47:30.734] Packages needed by future strategies (n = 1): ‘future’
[17:47:30.734] {
[17:47:30.734]     {
[17:47:30.734]         {
[17:47:30.734]             ...future.startTime <- base::Sys.time()
[17:47:30.734]             {
[17:47:30.734]                 {
[17:47:30.734]                   {
[17:47:30.734]                     {
[17:47:30.734]                       base::local({
[17:47:30.734]                         has_future <- base::requireNamespace("future", 
[17:47:30.734]                           quietly = TRUE)
[17:47:30.734]                         if (has_future) {
[17:47:30.734]                           ns <- base::getNamespace("future")
[17:47:30.734]                           version <- ns[[".package"]][["version"]]
[17:47:30.734]                           if (is.null(version)) 
[17:47:30.734]                             version <- utils::packageVersion("future")
[17:47:30.734]                         }
[17:47:30.734]                         else {
[17:47:30.734]                           version <- NULL
[17:47:30.734]                         }
[17:47:30.734]                         if (!has_future || version < "1.8.0") {
[17:47:30.734]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:30.734]                             "", base::R.version$version.string), 
[17:47:30.734]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:30.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:30.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:30.734]                               "release", "version")], collapse = " "), 
[17:47:30.734]                             hostname = base::Sys.info()[["nodename"]])
[17:47:30.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:30.734]                             info)
[17:47:30.734]                           info <- base::paste(info, collapse = "; ")
[17:47:30.734]                           if (!has_future) {
[17:47:30.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:30.734]                               info)
[17:47:30.734]                           }
[17:47:30.734]                           else {
[17:47:30.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:30.734]                               info, version)
[17:47:30.734]                           }
[17:47:30.734]                           base::stop(msg)
[17:47:30.734]                         }
[17:47:30.734]                       })
[17:47:30.734]                     }
[17:47:30.734]                     base::local({
[17:47:30.734]                       for (pkg in "future") {
[17:47:30.734]                         base::loadNamespace(pkg)
[17:47:30.734]                         base::library(pkg, character.only = TRUE)
[17:47:30.734]                       }
[17:47:30.734]                     })
[17:47:30.734]                   }
[17:47:30.734]                   ...future.strategy.old <- future::plan("list")
[17:47:30.734]                   options(future.plan = NULL)
[17:47:30.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.734]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:30.734]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:30.734]                     envir = parent.frame()) 
[17:47:30.734]                   {
[17:47:30.734]                     if (is.function(workers)) 
[17:47:30.734]                       workers <- workers()
[17:47:30.734]                     workers <- structure(as.integer(workers), 
[17:47:30.734]                       class = class(workers))
[17:47:30.734]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:30.734]                       workers >= 1)
[17:47:30.734]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:30.734]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:30.734]                     }
[17:47:30.734]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:30.734]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:30.734]                       envir = envir)
[17:47:30.734]                     if (!future$lazy) 
[17:47:30.734]                       future <- run(future)
[17:47:30.734]                     invisible(future)
[17:47:30.734]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:30.734]                 }
[17:47:30.734]                 ...future.workdir <- getwd()
[17:47:30.734]             }
[17:47:30.734]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:30.734]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:30.734]         }
[17:47:30.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:30.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:30.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:30.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:30.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:30.734]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:30.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:30.734]             base::names(...future.oldOptions))
[17:47:30.734]     }
[17:47:30.734]     if (FALSE) {
[17:47:30.734]     }
[17:47:30.734]     else {
[17:47:30.734]         if (TRUE) {
[17:47:30.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:30.734]                 open = "w")
[17:47:30.734]         }
[17:47:30.734]         else {
[17:47:30.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:30.734]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:30.734]         }
[17:47:30.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:30.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:30.734]             base::sink(type = "output", split = FALSE)
[17:47:30.734]             base::close(...future.stdout)
[17:47:30.734]         }, add = TRUE)
[17:47:30.734]     }
[17:47:30.734]     ...future.frame <- base::sys.nframe()
[17:47:30.734]     ...future.conditions <- base::list()
[17:47:30.734]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:30.734]     if (FALSE) {
[17:47:30.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:30.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:30.734]     }
[17:47:30.734]     ...future.result <- base::tryCatch({
[17:47:30.734]         base::withCallingHandlers({
[17:47:30.734]             ...future.value <- base::withVisible(base::local({
[17:47:30.734]                 a <- 1L
[17:47:30.734]                 plan_a <- unclass(future::plan("list"))
[17:47:30.734]                 nested_a <- nested[-1]
[17:47:30.734]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:30.734]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.734]                   strategy2))
[17:47:30.734]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:30.734]                   "init") <- NULL
[17:47:30.734]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:30.734]                   "init") <- NULL
[17:47:30.734]                 stopifnot(all.equal(plan_a, nested_a))
[17:47:30.734]                 y %<-% {
[17:47:30.734]                   b <- 2L
[17:47:30.734]                   plan_b <- future::plan("list")
[17:47:30.734]                   nested_b <- nested_a[-1]
[17:47:30.734]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:30.734]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:30.734]                     "sequential"))
[17:47:30.734]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:30.734]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:30.734]                 }
[17:47:30.734]                 y
[17:47:30.734]             }))
[17:47:30.734]             future::FutureResult(value = ...future.value$value, 
[17:47:30.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.734]                   ...future.rng), globalenv = if (FALSE) 
[17:47:30.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:30.734]                     ...future.globalenv.names))
[17:47:30.734]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:30.734]         }, condition = base::local({
[17:47:30.734]             c <- base::c
[17:47:30.734]             inherits <- base::inherits
[17:47:30.734]             invokeRestart <- base::invokeRestart
[17:47:30.734]             length <- base::length
[17:47:30.734]             list <- base::list
[17:47:30.734]             seq.int <- base::seq.int
[17:47:30.734]             signalCondition <- base::signalCondition
[17:47:30.734]             sys.calls <- base::sys.calls
[17:47:30.734]             `[[` <- base::`[[`
[17:47:30.734]             `+` <- base::`+`
[17:47:30.734]             `<<-` <- base::`<<-`
[17:47:30.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:30.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:30.734]                   3L)]
[17:47:30.734]             }
[17:47:30.734]             function(cond) {
[17:47:30.734]                 is_error <- inherits(cond, "error")
[17:47:30.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:30.734]                   NULL)
[17:47:30.734]                 if (is_error) {
[17:47:30.734]                   sessionInformation <- function() {
[17:47:30.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:30.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:30.734]                       search = base::search(), system = base::Sys.info())
[17:47:30.734]                   }
[17:47:30.734]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:30.734]                     cond$call), session = sessionInformation(), 
[17:47:30.734]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:30.734]                   signalCondition(cond)
[17:47:30.734]                 }
[17:47:30.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:30.734]                 "immediateCondition"))) {
[17:47:30.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:30.734]                   ...future.conditions[[length(...future.conditions) + 
[17:47:30.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:30.734]                   if (TRUE && !signal) {
[17:47:30.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.734]                     {
[17:47:30.734]                       inherits <- base::inherits
[17:47:30.734]                       invokeRestart <- base::invokeRestart
[17:47:30.734]                       is.null <- base::is.null
[17:47:30.734]                       muffled <- FALSE
[17:47:30.734]                       if (inherits(cond, "message")) {
[17:47:30.734]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.734]                         if (muffled) 
[17:47:30.734]                           invokeRestart("muffleMessage")
[17:47:30.734]                       }
[17:47:30.734]                       else if (inherits(cond, "warning")) {
[17:47:30.734]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.734]                         if (muffled) 
[17:47:30.734]                           invokeRestart("muffleWarning")
[17:47:30.734]                       }
[17:47:30.734]                       else if (inherits(cond, "condition")) {
[17:47:30.734]                         if (!is.null(pattern)) {
[17:47:30.734]                           computeRestarts <- base::computeRestarts
[17:47:30.734]                           grepl <- base::grepl
[17:47:30.734]                           restarts <- computeRestarts(cond)
[17:47:30.734]                           for (restart in restarts) {
[17:47:30.734]                             name <- restart$name
[17:47:30.734]                             if (is.null(name)) 
[17:47:30.734]                               next
[17:47:30.734]                             if (!grepl(pattern, name)) 
[17:47:30.734]                               next
[17:47:30.734]                             invokeRestart(restart)
[17:47:30.734]                             muffled <- TRUE
[17:47:30.734]                             break
[17:47:30.734]                           }
[17:47:30.734]                         }
[17:47:30.734]                       }
[17:47:30.734]                       invisible(muffled)
[17:47:30.734]                     }
[17:47:30.734]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.734]                   }
[17:47:30.734]                 }
[17:47:30.734]                 else {
[17:47:30.734]                   if (TRUE) {
[17:47:30.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:30.734]                     {
[17:47:30.734]                       inherits <- base::inherits
[17:47:30.734]                       invokeRestart <- base::invokeRestart
[17:47:30.734]                       is.null <- base::is.null
[17:47:30.734]                       muffled <- FALSE
[17:47:30.734]                       if (inherits(cond, "message")) {
[17:47:30.734]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:30.734]                         if (muffled) 
[17:47:30.734]                           invokeRestart("muffleMessage")
[17:47:30.734]                       }
[17:47:30.734]                       else if (inherits(cond, "warning")) {
[17:47:30.734]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:30.734]                         if (muffled) 
[17:47:30.734]                           invokeRestart("muffleWarning")
[17:47:30.734]                       }
[17:47:30.734]                       else if (inherits(cond, "condition")) {
[17:47:30.734]                         if (!is.null(pattern)) {
[17:47:30.734]                           computeRestarts <- base::computeRestarts
[17:47:30.734]                           grepl <- base::grepl
[17:47:30.734]                           restarts <- computeRestarts(cond)
[17:47:30.734]                           for (restart in restarts) {
[17:47:30.734]                             name <- restart$name
[17:47:30.734]                             if (is.null(name)) 
[17:47:30.734]                               next
[17:47:30.734]                             if (!grepl(pattern, name)) 
[17:47:30.734]                               next
[17:47:30.734]                             invokeRestart(restart)
[17:47:30.734]                             muffled <- TRUE
[17:47:30.734]                             break
[17:47:30.734]                           }
[17:47:30.734]                         }
[17:47:30.734]                       }
[17:47:30.734]                       invisible(muffled)
[17:47:30.734]                     }
[17:47:30.734]                     muffleCondition(cond, pattern = "^muffle")
[17:47:30.734]                   }
[17:47:30.734]                 }
[17:47:30.734]             }
[17:47:30.734]         }))
[17:47:30.734]     }, error = function(ex) {
[17:47:30.734]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:30.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:30.734]                 ...future.rng), started = ...future.startTime, 
[17:47:30.734]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:30.734]             version = "1.8"), class = "FutureResult")
[17:47:30.734]     }, finally = {
[17:47:30.734]         if (!identical(...future.workdir, getwd())) 
[17:47:30.734]             setwd(...future.workdir)
[17:47:30.734]         {
[17:47:30.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:30.734]                 ...future.oldOptions$nwarnings <- NULL
[17:47:30.734]             }
[17:47:30.734]             base::options(...future.oldOptions)
[17:47:30.734]             if (.Platform$OS.type == "windows") {
[17:47:30.734]                 old_names <- names(...future.oldEnvVars)
[17:47:30.734]                 envs <- base::Sys.getenv()
[17:47:30.734]                 names <- names(envs)
[17:47:30.734]                 common <- intersect(names, old_names)
[17:47:30.734]                 added <- setdiff(names, old_names)
[17:47:30.734]                 removed <- setdiff(old_names, names)
[17:47:30.734]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:30.734]                   envs[common]]
[17:47:30.734]                 NAMES <- toupper(changed)
[17:47:30.734]                 args <- list()
[17:47:30.734]                 for (kk in seq_along(NAMES)) {
[17:47:30.734]                   name <- changed[[kk]]
[17:47:30.734]                   NAME <- NAMES[[kk]]
[17:47:30.734]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.734]                     next
[17:47:30.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.734]                 }
[17:47:30.734]                 NAMES <- toupper(added)
[17:47:30.734]                 for (kk in seq_along(NAMES)) {
[17:47:30.734]                   name <- added[[kk]]
[17:47:30.734]                   NAME <- NAMES[[kk]]
[17:47:30.734]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.734]                     next
[17:47:30.734]                   args[[name]] <- ""
[17:47:30.734]                 }
[17:47:30.734]                 NAMES <- toupper(removed)
[17:47:30.734]                 for (kk in seq_along(NAMES)) {
[17:47:30.734]                   name <- removed[[kk]]
[17:47:30.734]                   NAME <- NAMES[[kk]]
[17:47:30.734]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:30.734]                     next
[17:47:30.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:30.734]                 }
[17:47:30.734]                 if (length(args) > 0) 
[17:47:30.734]                   base::do.call(base::Sys.setenv, args = args)
[17:47:30.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:30.734]             }
[17:47:30.734]             else {
[17:47:30.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:30.734]             }
[17:47:30.734]             {
[17:47:30.734]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:30.734]                   0L) {
[17:47:30.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:30.734]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:30.734]                   base::options(opts)
[17:47:30.734]                 }
[17:47:30.734]                 {
[17:47:30.734]                   {
[17:47:30.734]                     NULL
[17:47:30.734]                     RNGkind("Mersenne-Twister")
[17:47:30.734]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:30.734]                       inherits = FALSE)
[17:47:30.734]                   }
[17:47:30.734]                   options(future.plan = NULL)
[17:47:30.734]                   if (is.na(NA_character_)) 
[17:47:30.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:30.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:30.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:30.734]                     .init = FALSE)
[17:47:30.734]                 }
[17:47:30.734]             }
[17:47:30.734]         }
[17:47:30.734]     })
[17:47:30.734]     if (TRUE) {
[17:47:30.734]         base::sink(type = "output", split = FALSE)
[17:47:30.734]         if (TRUE) {
[17:47:30.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:30.734]         }
[17:47:30.734]         else {
[17:47:30.734]             ...future.result["stdout"] <- base::list(NULL)
[17:47:30.734]         }
[17:47:30.734]         base::close(...future.stdout)
[17:47:30.734]         ...future.stdout <- NULL
[17:47:30.734]     }
[17:47:30.734]     ...future.result$conditions <- ...future.conditions
[17:47:30.734]     ...future.result$finished <- base::Sys.time()
[17:47:30.734]     ...future.result
[17:47:30.734] }
[17:47:30.736] assign_globals() ...
[17:47:30.736] List of 2
[17:47:30.736]  $ nested   :List of 2
[17:47:30.736]   ..$ a:function (..., envir = parent.frame())  
[17:47:30.736]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:30.736]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.736]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:30.736]     envir = parent.frame())  
[17:47:30.736]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:47:30.736]   .. ..- attr(*, "init")= logi TRUE
[17:47:30.736]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:47:30.736]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:30.736]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:30.736]  $ strategy2: chr "multisession"
[17:47:30.736]  - attr(*, "where")=List of 2
[17:47:30.736]   ..$ nested   :<environment: R_EmptyEnv> 
[17:47:30.736]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:47:30.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:30.736]  - attr(*, "resolved")= logi FALSE
[17:47:30.736]  - attr(*, "total_size")= num 56736
[17:47:30.736]  - attr(*, "already-done")= logi TRUE
[17:47:30.741] - copied ‘nested’ to environment
[17:47:30.742] - copied ‘strategy2’ to environment
[17:47:30.742] assign_globals() ... done
[17:47:30.742] plan(): Setting new future strategy stack:
[17:47:30.742] List of future strategies:
[17:47:30.742] 1. multisession:
[17:47:30.742]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:30.742]    - tweaked: FALSE
[17:47:30.742]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:30.746] plan(): nbrOfWorkers() = 2
[17:47:31.459] plan(): Setting new future strategy stack:
[17:47:31.459] List of future strategies:
[17:47:31.459] 1. sequential:
[17:47:31.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.459]    - tweaked: FALSE
[17:47:31.459]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.459] 2. multisession:
[17:47:31.459]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:31.459]    - tweaked: FALSE
[17:47:31.459]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.460] plan(): nbrOfWorkers() = 1
[17:47:31.460] SequentialFuture started (and completed)
[17:47:31.460] signalConditions() ...
[17:47:31.460]  - include = ‘immediateCondition’
[17:47:31.460]  - exclude = 
[17:47:31.460]  - resignal = FALSE
[17:47:31.460]  - Number of conditions: 97
[17:47:31.461] signalConditions() ... done
[17:47:31.461] - Launch lazy future ... done
[17:47:31.461] run() for ‘SequentialFuture’ ... done
[17:47:31.461] signalConditions() ...
[17:47:31.461]  - include = ‘immediateCondition’
[17:47:31.461]  - exclude = 
[17:47:31.461]  - resignal = FALSE
[17:47:31.462]  - Number of conditions: 97
[17:47:31.462] signalConditions() ... done
[17:47:31.462] Future state: ‘finished’
[17:47:31.462] signalConditions() ...
[17:47:31.462]  - include = ‘condition’
[17:47:31.462]  - exclude = ‘immediateCondition’
[17:47:31.462]  - resignal = TRUE
[17:47:31.462]  - Number of conditions: 97
[17:47:31.463]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.748] getGlobalsAndPackages() ...
[17:47:31.463]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.748] Searching for globals...
[17:47:31.463]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.766] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:47:31.463]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.766] Searching for globals ... DONE
[17:47:31.463]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.766] Resolving globals: FALSE
[17:47:31.463]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.767] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[17:47:31.464]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:47:31.464]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:47:31.464]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] 
[17:47:31.464]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] getGlobalsAndPackages() ... DONE
[17:47:31.464]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] run() for ‘Future’ ...
[17:47:31.464]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] - state: ‘created’
[17:47:31.465]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.465]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.774] [local output] makeClusterPSOCK() ...
[17:47:31.465]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.812] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:31.465]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.814] [local output] Base port: 11483
[17:47:31.465]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.814] [local output] Getting setup options for 2 cluster nodes ...
[17:47:31.465]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.814] [local output]  - Node 1 of 2 ...
[17:47:31.466]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.814] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:31.466]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:30.815] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b917365b21fb.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b917365b21fb.pid")'’
[17:47:31.466]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.000] - Possible to infer worker's PID: TRUE
[17:47:31.466]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.001] [local output] Rscript port: 11483

[17:47:31.466]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.001] [local output]  - Node 2 of 2 ...
[17:47:31.466]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.001] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:31.467]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.002] [local output] Rscript port: 11483

[17:47:31.467]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.002] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:31.467]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.002] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:31.467]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.003] [local output] Setting up PSOCK nodes in parallel
[17:47:31.467]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.003] List of 36
[17:47:31.003]  $ worker          : chr "localhost"
[17:47:31.003]   ..- attr(*, "localhost")= logi TRUE
[17:47:31.003]  $ master          : chr "localhost"
[17:47:31.003]  $ port            : int 11483
[17:47:31.003]  $ connectTimeout  : num 120
[17:47:31.003]  $ timeout         : num 2592000
[17:47:31.003]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:31.003]  $ homogeneous     : logi TRUE
[17:47:31.003]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:31.003]  $ rscript_envs    : NULL
[17:47:31.003]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:31.003]  $ rscript_startup : NULL
[17:47:31.003]  $ rscript_sh      : chr "sh"
[17:47:31.003]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:31.003]  $ methods         : logi TRUE
[17:47:31.003]  $ socketOptions   : chr "no-delay"
[17:47:31.003]  $ useXDR          : logi FALSE
[17:47:31.003]  $ outfile         : chr "/dev/null"
[17:47:31.003]  $ renice          : int NA
[17:47:31.003]  $ rshcmd          : NULL
[17:47:31.003]  $ user            : chr(0) 
[17:47:31.003]  $ revtunnel       : logi FALSE
[17:47:31.003]  $ rshlogfile      : NULL
[17:47:31.003]  $ rshopts         : chr(0) 
[17:47:31.003]  $ rank            : int 1
[17:47:31.003]  $ manual          : logi FALSE
[17:47:31.003]  $ dryrun          : logi FALSE
[17:47:31.003]  $ quiet           : logi FALSE
[17:47:31.003]  $ setup_strategy  : chr "parallel"
[17:47:31.003]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:31.003]  $ pidfile         : chr "/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b917365b21fb.pid"
[17:47:31.003]  $ rshcmd_label    : NULL
[17:47:31.003]  $ rsh_call        : NULL
[17:47:31.003]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:31.003]  $ localMachine    : logi TRUE
[17:47:31.003]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:31.003]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:31.003]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:31.003]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:31.003]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:31.003]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:31.003]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:31.003]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:31.003]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:31.003]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:31.003]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:31.003]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:31.003]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:31.003]  $ arguments       :List of 28
[17:47:31.003]   ..$ worker          : chr "localhost"
[17:47:31.003]   ..$ master          : NULL
[17:47:31.003]   ..$ port            : int 11483
[17:47:31.003]   ..$ connectTimeout  : num 120
[17:47:31.003]   ..$ timeout         : num 2592000
[17:47:31.003]   ..$ rscript         : NULL
[17:47:31.003]   ..$ homogeneous     : NULL
[17:47:31.003]   ..$ rscript_args    : NULL
[17:47:31.003]   ..$ rscript_envs    : NULL
[17:47:31.003]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:31.003]   ..$ rscript_startup : NULL
[17:47:31.003]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:31.003]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:31.003]   ..$ methods         : logi TRUE
[17:47:31.003]   ..$ socketOptions   : chr "no-delay"
[17:47:31.003]   ..$ useXDR          : logi FALSE
[17:47:31.003]   ..$ outfile         : chr "/dev/null"
[17:47:31.003]   ..$ renice          : int NA
[17:47:31.003]   ..$ rshcmd          : NULL
[17:47:31.003]   ..$ user            : NULL
[17:47:31.003]   ..$ revtunnel       : logi NA
[17:47:31.003]   ..$ rshlogfile      : NULL
[17:47:31.003]   ..$ rshopts         : NULL
[17:47:31.003]   ..$ rank            : int 1
[17:47:31.003]   ..$ manual          : logi FALSE
[17:47:31.003]   ..$ dryrun          : logi FALSE
[17:47:31.003]   ..$ quiet           : logi FALSE
[17:47:31.003]   ..$ setup_strategy  : chr "parallel"
[17:47:31.003]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:31.467]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.019] [local output] System call to launch all workers:
[17:47:31.468]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.019] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b917365b21fb.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11483 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:31.468]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.019] [local output] Starting PSOCK main server
[17:47:31.468]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.025] [local output] Workers launched
[17:47:31.468]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.025] [local output] Waiting for workers to connect back
[17:47:31.468]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.025]  - [local output] 0 workers out of 2 ready
[17:47:31.468]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.267]  - [local output] 0 workers out of 2 ready
[17:47:31.469]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.268]  - [local output] 1 workers out of 2 ready
[17:47:31.469]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.268]  - [local output] 2 workers out of 2 ready
[17:47:31.469]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.268] [local output] Launching of workers completed
[17:47:31.469]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.268] [local output] Collecting session information from workers
[17:47:31.469]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.269] [local output]  - Worker #1 of 2
[17:47:31.469]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.270] [local output]  - Worker #2 of 2
[17:47:31.469]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.270] [local output] makeClusterPSOCK() ... done
[17:47:31.470]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.280] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.470]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:31.470]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘node’
[17:47:31.470]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘label’
[17:47:31.470]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘local’
[17:47:31.470]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘owner’
[17:47:31.471]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘envir’
[17:47:31.471]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘workers’
[17:47:31.471]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.281]   - Field: ‘packages’
[17:47:31.471]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘gc’
[17:47:31.471]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘conditions’
[17:47:31.471]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘persistent’
[17:47:31.472]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘expr’
[17:47:31.472]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘uuid’
[17:47:31.472]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘seed’
[17:47:31.472]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘version’
[17:47:31.472]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.282]   - Field: ‘result’
[17:47:31.472]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘asynchronous’
[17:47:31.473]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘calls’
[17:47:31.473]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘globals’
[17:47:31.473]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘stdout’
[17:47:31.473]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘earlySignal’
[17:47:31.473]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘lazy’
[17:47:31.473]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283]   - Field: ‘state’
[17:47:31.474]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:31.474]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.284] - Launch lazy future ...
[17:47:31.474]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.284] Packages needed by the future expression (n = 0): <none>
[17:47:31.474]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.285] Packages needed by future strategies (n = 0): <none>
[17:47:31.474]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.285] {
[17:47:31.285]     {
[17:47:31.285]         {
[17:47:31.285]             ...future.startTime <- base::Sys.time()
[17:47:31.285]             {
[17:47:31.285]                 {
[17:47:31.285]                   {
[17:47:31.285]                     {
[17:47:31.285]                       base::local({
[17:47:31.285]                         has_future <- base::requireNamespace("future", 
[17:47:31.285]                           quietly = TRUE)
[17:47:31.285]                         if (has_future) {
[17:47:31.285]                           ns <- base::getNamespace("future")
[17:47:31.285]                           version <- ns[[".package"]][["version"]]
[17:47:31.285]                           if (is.null(version)) 
[17:47:31.285]                             version <- utils::packageVersion("future")
[17:47:31.285]                         }
[17:47:31.285]                         else {
[17:47:31.285]                           version <- NULL
[17:47:31.285]                         }
[17:47:31.285]                         if (!has_future || version < "1.8.0") {
[17:47:31.285]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.285]                             "", base::R.version$version.string), 
[17:47:31.285]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:31.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.285]                               "release", "version")], collapse = " "), 
[17:47:31.285]                             hostname = base::Sys.info()[["nodename"]])
[17:47:31.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.285]                             info)
[17:47:31.285]                           info <- base::paste(info, collapse = "; ")
[17:47:31.285]                           if (!has_future) {
[17:47:31.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.285]                               info)
[17:47:31.285]                           }
[17:47:31.285]                           else {
[17:47:31.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.285]                               info, version)
[17:47:31.285]                           }
[17:47:31.285]                           base::stop(msg)
[17:47:31.285]                         }
[17:47:31.285]                       })
[17:47:31.285]                     }
[17:47:31.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.285]                     base::options(mc.cores = 1L)
[17:47:31.285]                   }
[17:47:31.285]                   ...future.strategy.old <- future::plan("list")
[17:47:31.285]                   options(future.plan = NULL)
[17:47:31.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:31.285]                 }
[17:47:31.285]                 ...future.workdir <- getwd()
[17:47:31.285]             }
[17:47:31.285]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.285]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.285]         }
[17:47:31.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.285]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.285]             base::names(...future.oldOptions))
[17:47:31.285]     }
[17:47:31.285]     if (FALSE) {
[17:47:31.285]     }
[17:47:31.285]     else {
[17:47:31.285]         if (TRUE) {
[17:47:31.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.285]                 open = "w")
[17:47:31.285]         }
[17:47:31.285]         else {
[17:47:31.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.285]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.285]         }
[17:47:31.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.285]             base::sink(type = "output", split = FALSE)
[17:47:31.285]             base::close(...future.stdout)
[17:47:31.285]         }, add = TRUE)
[17:47:31.285]     }
[17:47:31.285]     ...future.frame <- base::sys.nframe()
[17:47:31.285]     ...future.conditions <- base::list()
[17:47:31.285]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.285]     if (FALSE) {
[17:47:31.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.285]     }
[17:47:31.285]     ...future.result <- base::tryCatch({
[17:47:31.285]         base::withCallingHandlers({
[17:47:31.285]             ...future.value <- base::withVisible(base::local({
[17:47:31.285]                 ...future.makeSendCondition <- base::local({
[17:47:31.285]                   sendCondition <- NULL
[17:47:31.285]                   function(frame = 1L) {
[17:47:31.285]                     if (is.function(sendCondition)) 
[17:47:31.285]                       return(sendCondition)
[17:47:31.285]                     ns <- getNamespace("parallel")
[17:47:31.285]                     if (exists("sendData", mode = "function", 
[17:47:31.285]                       envir = ns)) {
[17:47:31.285]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:31.285]                         envir = ns)
[17:47:31.285]                       envir <- sys.frame(frame)
[17:47:31.285]                       master <- NULL
[17:47:31.285]                       while (!identical(envir, .GlobalEnv) && 
[17:47:31.285]                         !identical(envir, emptyenv())) {
[17:47:31.285]                         if (exists("master", mode = "list", envir = envir, 
[17:47:31.285]                           inherits = FALSE)) {
[17:47:31.285]                           master <- get("master", mode = "list", 
[17:47:31.285]                             envir = envir, inherits = FALSE)
[17:47:31.285]                           if (inherits(master, c("SOCKnode", 
[17:47:31.285]                             "SOCK0node"))) {
[17:47:31.285]                             sendCondition <<- function(cond) {
[17:47:31.285]                               data <- list(type = "VALUE", value = cond, 
[17:47:31.285]                                 success = TRUE)
[17:47:31.285]                               parallel_sendData(master, data)
[17:47:31.285]                             }
[17:47:31.285]                             return(sendCondition)
[17:47:31.285]                           }
[17:47:31.285]                         }
[17:47:31.285]                         frame <- frame + 1L
[17:47:31.285]                         envir <- sys.frame(frame)
[17:47:31.285]                       }
[17:47:31.285]                     }
[17:47:31.285]                     sendCondition <<- function(cond) NULL
[17:47:31.285]                   }
[17:47:31.285]                 })
[17:47:31.285]                 withCallingHandlers({
[17:47:31.285]                   {
[17:47:31.285]                     b <- 2L
[17:47:31.285]                     plan_b <- future::plan("list")
[17:47:31.285]                     nested_b <- nested_a[-1]
[17:47:31.285]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:31.285]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:31.285]                       "sequential"))
[17:47:31.285]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:31.285]                       b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:31.285]                   }
[17:47:31.285]                 }, immediateCondition = function(cond) {
[17:47:31.285]                   sendCondition <- ...future.makeSendCondition()
[17:47:31.285]                   sendCondition(cond)
[17:47:31.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.285]                   {
[17:47:31.285]                     inherits <- base::inherits
[17:47:31.285]                     invokeRestart <- base::invokeRestart
[17:47:31.285]                     is.null <- base::is.null
[17:47:31.285]                     muffled <- FALSE
[17:47:31.285]                     if (inherits(cond, "message")) {
[17:47:31.285]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.285]                       if (muffled) 
[17:47:31.285]                         invokeRestart("muffleMessage")
[17:47:31.285]                     }
[17:47:31.285]                     else if (inherits(cond, "warning")) {
[17:47:31.285]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.285]                       if (muffled) 
[17:47:31.285]                         invokeRestart("muffleWarning")
[17:47:31.285]                     }
[17:47:31.285]                     else if (inherits(cond, "condition")) {
[17:47:31.285]                       if (!is.null(pattern)) {
[17:47:31.285]                         computeRestarts <- base::computeRestarts
[17:47:31.285]                         grepl <- base::grepl
[17:47:31.285]                         restarts <- computeRestarts(cond)
[17:47:31.285]                         for (restart in restarts) {
[17:47:31.285]                           name <- restart$name
[17:47:31.285]                           if (is.null(name)) 
[17:47:31.285]                             next
[17:47:31.285]                           if (!grepl(pattern, name)) 
[17:47:31.285]                             next
[17:47:31.285]                           invokeRestart(restart)
[17:47:31.285]                           muffled <- TRUE
[17:47:31.285]                           break
[17:47:31.285]                         }
[17:47:31.285]                       }
[17:47:31.285]                     }
[17:47:31.285]                     invisible(muffled)
[17:47:31.285]                   }
[17:47:31.285]                   muffleCondition(cond)
[17:47:31.285]                 })
[17:47:31.285]             }))
[17:47:31.285]             future::FutureResult(value = ...future.value$value, 
[17:47:31.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.285]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.285]                     ...future.globalenv.names))
[17:47:31.285]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.285]         }, condition = base::local({
[17:47:31.285]             c <- base::c
[17:47:31.285]             inherits <- base::inherits
[17:47:31.285]             invokeRestart <- base::invokeRestart
[17:47:31.285]             length <- base::length
[17:47:31.285]             list <- base::list
[17:47:31.285]             seq.int <- base::seq.int
[17:47:31.285]             signalCondition <- base::signalCondition
[17:47:31.285]             sys.calls <- base::sys.calls
[17:47:31.285]             `[[` <- base::`[[`
[17:47:31.285]             `+` <- base::`+`
[17:47:31.285]             `<<-` <- base::`<<-`
[17:47:31.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.285]                   3L)]
[17:47:31.285]             }
[17:47:31.285]             function(cond) {
[17:47:31.285]                 is_error <- inherits(cond, "error")
[17:47:31.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.285]                   NULL)
[17:47:31.285]                 if (is_error) {
[17:47:31.285]                   sessionInformation <- function() {
[17:47:31.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.285]                       search = base::search(), system = base::Sys.info())
[17:47:31.285]                   }
[17:47:31.285]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.285]                     cond$call), session = sessionInformation(), 
[17:47:31.285]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.285]                   signalCondition(cond)
[17:47:31.285]                 }
[17:47:31.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.285]                 "immediateCondition"))) {
[17:47:31.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.285]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.285]                   if (TRUE && !signal) {
[17:47:31.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.285]                     {
[17:47:31.285]                       inherits <- base::inherits
[17:47:31.285]                       invokeRestart <- base::invokeRestart
[17:47:31.285]                       is.null <- base::is.null
[17:47:31.285]                       muffled <- FALSE
[17:47:31.285]                       if (inherits(cond, "message")) {
[17:47:31.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.285]                         if (muffled) 
[17:47:31.285]                           invokeRestart("muffleMessage")
[17:47:31.285]                       }
[17:47:31.285]                       else if (inherits(cond, "warning")) {
[17:47:31.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.285]                         if (muffled) 
[17:47:31.285]                           invokeRestart("muffleWarning")
[17:47:31.285]                       }
[17:47:31.285]                       else if (inherits(cond, "condition")) {
[17:47:31.285]                         if (!is.null(pattern)) {
[17:47:31.285]                           computeRestarts <- base::computeRestarts
[17:47:31.285]                           grepl <- base::grepl
[17:47:31.285]                           restarts <- computeRestarts(cond)
[17:47:31.285]                           for (restart in restarts) {
[17:47:31.285]                             name <- restart$name
[17:47:31.285]                             if (is.null(name)) 
[17:47:31.285]                               next
[17:47:31.285]                             if (!grepl(pattern, name)) 
[17:47:31.285]                               next
[17:47:31.285]                             invokeRestart(restart)
[17:47:31.285]                             muffled <- TRUE
[17:47:31.285]                             break
[17:47:31.285]                           }
[17:47:31.285]                         }
[17:47:31.285]                       }
[17:47:31.285]                       invisible(muffled)
[17:47:31.285]                     }
[17:47:31.285]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.285]                   }
[17:47:31.285]                 }
[17:47:31.285]                 else {
[17:47:31.285]                   if (TRUE) {
[17:47:31.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.285]                     {
[17:47:31.285]                       inherits <- base::inherits
[17:47:31.285]                       invokeRestart <- base::invokeRestart
[17:47:31.285]                       is.null <- base::is.null
[17:47:31.285]                       muffled <- FALSE
[17:47:31.285]                       if (inherits(cond, "message")) {
[17:47:31.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.285]                         if (muffled) 
[17:47:31.285]                           invokeRestart("muffleMessage")
[17:47:31.285]                       }
[17:47:31.285]                       else if (inherits(cond, "warning")) {
[17:47:31.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.285]                         if (muffled) 
[17:47:31.285]                           invokeRestart("muffleWarning")
[17:47:31.285]                       }
[17:47:31.285]                       else if (inherits(cond, "condition")) {
[17:47:31.285]                         if (!is.null(pattern)) {
[17:47:31.285]                           computeRestarts <- base::computeRestarts
[17:47:31.285]                           grepl <- base::grepl
[17:47:31.285]                           restarts <- computeRestarts(cond)
[17:47:31.285]                           for (restart in restarts) {
[17:47:31.285]                             name <- restart$name
[17:47:31.285]                             if (is.null(name)) 
[17:47:31.285]                               next
[17:47:31.285]                             if (!grepl(pattern, name)) 
[17:47:31.285]                               next
[17:47:31.285]                             invokeRestart(restart)
[17:47:31.285]                             muffled <- TRUE
[17:47:31.285]                             break
[17:47:31.285]                           }
[17:47:31.285]                         }
[17:47:31.285]                       }
[17:47:31.285]                       invisible(muffled)
[17:47:31.285]                     }
[17:47:31.285]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.285]                   }
[17:47:31.285]                 }
[17:47:31.285]             }
[17:47:31.285]         }))
[17:47:31.285]     }, error = function(ex) {
[17:47:31.285]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.285]                 ...future.rng), started = ...future.startTime, 
[17:47:31.285]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.285]             version = "1.8"), class = "FutureResult")
[17:47:31.285]     }, finally = {
[17:47:31.285]         if (!identical(...future.workdir, getwd())) 
[17:47:31.285]             setwd(...future.workdir)
[17:47:31.285]         {
[17:47:31.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.285]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.285]             }
[17:47:31.285]             base::options(...future.oldOptions)
[17:47:31.285]             if (.Platform$OS.type == "windows") {
[17:47:31.285]                 old_names <- names(...future.oldEnvVars)
[17:47:31.285]                 envs <- base::Sys.getenv()
[17:47:31.285]                 names <- names(envs)
[17:47:31.285]                 common <- intersect(names, old_names)
[17:47:31.285]                 added <- setdiff(names, old_names)
[17:47:31.285]                 removed <- setdiff(old_names, names)
[17:47:31.285]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.285]                   envs[common]]
[17:47:31.285]                 NAMES <- toupper(changed)
[17:47:31.285]                 args <- list()
[17:47:31.285]                 for (kk in seq_along(NAMES)) {
[17:47:31.285]                   name <- changed[[kk]]
[17:47:31.285]                   NAME <- NAMES[[kk]]
[17:47:31.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.285]                     next
[17:47:31.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.285]                 }
[17:47:31.285]                 NAMES <- toupper(added)
[17:47:31.285]                 for (kk in seq_along(NAMES)) {
[17:47:31.285]                   name <- added[[kk]]
[17:47:31.285]                   NAME <- NAMES[[kk]]
[17:47:31.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.285]                     next
[17:47:31.285]                   args[[name]] <- ""
[17:47:31.285]                 }
[17:47:31.285]                 NAMES <- toupper(removed)
[17:47:31.285]                 for (kk in seq_along(NAMES)) {
[17:47:31.285]                   name <- removed[[kk]]
[17:47:31.285]                   NAME <- NAMES[[kk]]
[17:47:31.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.285]                     next
[17:47:31.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.285]                 }
[17:47:31.285]                 if (length(args) > 0) 
[17:47:31.285]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.285]             }
[17:47:31.285]             else {
[17:47:31.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.285]             }
[17:47:31.285]             {
[17:47:31.285]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.285]                   0L) {
[17:47:31.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.285]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.285]                   base::options(opts)
[17:47:31.285]                 }
[17:47:31.285]                 {
[17:47:31.285]                   {
[17:47:31.285]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.285]                     NULL
[17:47:31.285]                   }
[17:47:31.285]                   options(future.plan = NULL)
[17:47:31.285]                   if (is.na(NA_character_)) 
[17:47:31.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.285]                     .init = FALSE)
[17:47:31.285]                 }
[17:47:31.285]             }
[17:47:31.285]         }
[17:47:31.285]     })
[17:47:31.285]     if (TRUE) {
[17:47:31.285]         base::sink(type = "output", split = FALSE)
[17:47:31.285]         if (TRUE) {
[17:47:31.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.285]         }
[17:47:31.285]         else {
[17:47:31.285]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.285]         }
[17:47:31.285]         base::close(...future.stdout)
[17:47:31.285]         ...future.stdout <- NULL
[17:47:31.285]     }
[17:47:31.285]     ...future.result$conditions <- ...future.conditions
[17:47:31.285]     ...future.result$finished <- base::Sys.time()
[17:47:31.285]     ...future.result
[17:47:31.285] }
[17:47:31.474]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.336] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[17:47:31.475]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.336] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[17:47:31.475]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.337] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[17:47:31.475]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.337] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:47:31.475]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.337] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:47:31.475]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.338] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[17:47:31.475]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.380] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[17:47:31.476]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.380] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[17:47:31.476]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.381] MultisessionFuture started
[17:47:31.476]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.381] - Launch lazy future ... done
[17:47:31.476]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.381] run() for ‘MultisessionFuture’ ... done
[17:47:31.476]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.381] result() for ClusterFuture ...
[17:47:31.476]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.382] receiveMessageFromWorker() for ClusterFuture ...
[17:47:31.476]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.382] - Validating connection of MultisessionFuture
[17:47:31.477]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.456] - received message: FutureResult
[17:47:31.477]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.457] - Received FutureResult
[17:47:31.477]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.457] - Erased future from FutureRegistry
[17:47:31.477]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.457] result() for ClusterFuture ...
[17:47:31.477]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.457] - result already collected: FutureResult
[17:47:31.477]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.457] result() for ClusterFuture ... done
[17:47:31.478]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.458] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:31.478]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.458] result() for ClusterFuture ... done
[17:47:31.478]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.458] result() for ClusterFuture ...
[17:47:31.478]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.458] - result already collected: FutureResult
[17:47:31.478]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.458] result() for ClusterFuture ... done
[17:47:31.478] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:31.485] getGlobalsAndPackages() ...
[17:47:31.485] Searching for globals...
[17:47:31.487] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:31.487] Searching for globals ... DONE
[17:47:31.487] Resolving globals: FALSE
[17:47:31.488] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:31.488] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:31.488] - globals: [1] ‘data’
[17:47:31.489] - packages: [1] ‘future’
[17:47:31.489] getGlobalsAndPackages() ... DONE
[17:47:31.489] run() for ‘Future’ ...
[17:47:31.489] - state: ‘created’
[17:47:31.489] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:31.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:31.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:31.490]   - Field: ‘label’
[17:47:31.490]   - Field: ‘local’
[17:47:31.490]   - Field: ‘owner’
[17:47:31.490]   - Field: ‘envir’
[17:47:31.490]   - Field: ‘packages’
[17:47:31.490]   - Field: ‘gc’
[17:47:31.491]   - Field: ‘conditions’
[17:47:31.491]   - Field: ‘expr’
[17:47:31.491]   - Field: ‘uuid’
[17:47:31.491]   - Field: ‘seed’
[17:47:31.491]   - Field: ‘version’
[17:47:31.491]   - Field: ‘result’
[17:47:31.491]   - Field: ‘asynchronous’
[17:47:31.491]   - Field: ‘calls’
[17:47:31.492]   - Field: ‘globals’
[17:47:31.492]   - Field: ‘stdout’
[17:47:31.492]   - Field: ‘earlySignal’
[17:47:31.492]   - Field: ‘lazy’
[17:47:31.492]   - Field: ‘state’
[17:47:31.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:31.492] - Launch lazy future ...
[17:47:31.492] Packages needed by the future expression (n = 1): ‘future’
[17:47:31.493] Packages needed by future strategies (n = 1): ‘future’
[17:47:31.493] {
[17:47:31.493]     {
[17:47:31.493]         {
[17:47:31.493]             ...future.startTime <- base::Sys.time()
[17:47:31.493]             {
[17:47:31.493]                 {
[17:47:31.493]                   {
[17:47:31.493]                     {
[17:47:31.493]                       base::local({
[17:47:31.493]                         has_future <- base::requireNamespace("future", 
[17:47:31.493]                           quietly = TRUE)
[17:47:31.493]                         if (has_future) {
[17:47:31.493]                           ns <- base::getNamespace("future")
[17:47:31.493]                           version <- ns[[".package"]][["version"]]
[17:47:31.493]                           if (is.null(version)) 
[17:47:31.493]                             version <- utils::packageVersion("future")
[17:47:31.493]                         }
[17:47:31.493]                         else {
[17:47:31.493]                           version <- NULL
[17:47:31.493]                         }
[17:47:31.493]                         if (!has_future || version < "1.8.0") {
[17:47:31.493]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.493]                             "", base::R.version$version.string), 
[17:47:31.493]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:31.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.493]                               "release", "version")], collapse = " "), 
[17:47:31.493]                             hostname = base::Sys.info()[["nodename"]])
[17:47:31.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.493]                             info)
[17:47:31.493]                           info <- base::paste(info, collapse = "; ")
[17:47:31.493]                           if (!has_future) {
[17:47:31.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.493]                               info)
[17:47:31.493]                           }
[17:47:31.493]                           else {
[17:47:31.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.493]                               info, version)
[17:47:31.493]                           }
[17:47:31.493]                           base::stop(msg)
[17:47:31.493]                         }
[17:47:31.493]                       })
[17:47:31.493]                     }
[17:47:31.493]                     base::local({
[17:47:31.493]                       for (pkg in "future") {
[17:47:31.493]                         base::loadNamespace(pkg)
[17:47:31.493]                         base::library(pkg, character.only = TRUE)
[17:47:31.493]                       }
[17:47:31.493]                     })
[17:47:31.493]                   }
[17:47:31.493]                   ...future.strategy.old <- future::plan("list")
[17:47:31.493]                   options(future.plan = NULL)
[17:47:31.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.493]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:31.493]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:31.493]                     envir = parent.frame()) 
[17:47:31.493]                   {
[17:47:31.493]                     if (is.function(workers)) 
[17:47:31.493]                       workers <- workers()
[17:47:31.493]                     workers <- structure(as.integer(workers), 
[17:47:31.493]                       class = class(workers))
[17:47:31.493]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:31.493]                       workers >= 1)
[17:47:31.493]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:31.493]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:31.493]                     }
[17:47:31.493]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:31.493]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:31.493]                       envir = envir)
[17:47:31.493]                     if (!future$lazy) 
[17:47:31.493]                       future <- run(future)
[17:47:31.493]                     invisible(future)
[17:47:31.493]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:31.493]                 }
[17:47:31.493]                 ...future.workdir <- getwd()
[17:47:31.493]             }
[17:47:31.493]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.493]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.493]         }
[17:47:31.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.493]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.493]             base::names(...future.oldOptions))
[17:47:31.493]     }
[17:47:31.493]     if (FALSE) {
[17:47:31.493]     }
[17:47:31.493]     else {
[17:47:31.493]         if (TRUE) {
[17:47:31.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.493]                 open = "w")
[17:47:31.493]         }
[17:47:31.493]         else {
[17:47:31.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.493]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.493]         }
[17:47:31.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.493]             base::sink(type = "output", split = FALSE)
[17:47:31.493]             base::close(...future.stdout)
[17:47:31.493]         }, add = TRUE)
[17:47:31.493]     }
[17:47:31.493]     ...future.frame <- base::sys.nframe()
[17:47:31.493]     ...future.conditions <- base::list()
[17:47:31.493]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.493]     if (FALSE) {
[17:47:31.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.493]     }
[17:47:31.493]     ...future.result <- base::tryCatch({
[17:47:31.493]         base::withCallingHandlers({
[17:47:31.493]             ...future.value <- base::withVisible(base::local({
[17:47:31.493]                 value(future(subset(data, a == 2)))
[17:47:31.493]             }))
[17:47:31.493]             future::FutureResult(value = ...future.value$value, 
[17:47:31.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.493]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.493]                     ...future.globalenv.names))
[17:47:31.493]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.493]         }, condition = base::local({
[17:47:31.493]             c <- base::c
[17:47:31.493]             inherits <- base::inherits
[17:47:31.493]             invokeRestart <- base::invokeRestart
[17:47:31.493]             length <- base::length
[17:47:31.493]             list <- base::list
[17:47:31.493]             seq.int <- base::seq.int
[17:47:31.493]             signalCondition <- base::signalCondition
[17:47:31.493]             sys.calls <- base::sys.calls
[17:47:31.493]             `[[` <- base::`[[`
[17:47:31.493]             `+` <- base::`+`
[17:47:31.493]             `<<-` <- base::`<<-`
[17:47:31.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.493]                   3L)]
[17:47:31.493]             }
[17:47:31.493]             function(cond) {
[17:47:31.493]                 is_error <- inherits(cond, "error")
[17:47:31.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.493]                   NULL)
[17:47:31.493]                 if (is_error) {
[17:47:31.493]                   sessionInformation <- function() {
[17:47:31.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.493]                       search = base::search(), system = base::Sys.info())
[17:47:31.493]                   }
[17:47:31.493]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.493]                     cond$call), session = sessionInformation(), 
[17:47:31.493]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.493]                   signalCondition(cond)
[17:47:31.493]                 }
[17:47:31.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.493]                 "immediateCondition"))) {
[17:47:31.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.493]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.493]                   if (TRUE && !signal) {
[17:47:31.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.493]                     {
[17:47:31.493]                       inherits <- base::inherits
[17:47:31.493]                       invokeRestart <- base::invokeRestart
[17:47:31.493]                       is.null <- base::is.null
[17:47:31.493]                       muffled <- FALSE
[17:47:31.493]                       if (inherits(cond, "message")) {
[17:47:31.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.493]                         if (muffled) 
[17:47:31.493]                           invokeRestart("muffleMessage")
[17:47:31.493]                       }
[17:47:31.493]                       else if (inherits(cond, "warning")) {
[17:47:31.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.493]                         if (muffled) 
[17:47:31.493]                           invokeRestart("muffleWarning")
[17:47:31.493]                       }
[17:47:31.493]                       else if (inherits(cond, "condition")) {
[17:47:31.493]                         if (!is.null(pattern)) {
[17:47:31.493]                           computeRestarts <- base::computeRestarts
[17:47:31.493]                           grepl <- base::grepl
[17:47:31.493]                           restarts <- computeRestarts(cond)
[17:47:31.493]                           for (restart in restarts) {
[17:47:31.493]                             name <- restart$name
[17:47:31.493]                             if (is.null(name)) 
[17:47:31.493]                               next
[17:47:31.493]                             if (!grepl(pattern, name)) 
[17:47:31.493]                               next
[17:47:31.493]                             invokeRestart(restart)
[17:47:31.493]                             muffled <- TRUE
[17:47:31.493]                             break
[17:47:31.493]                           }
[17:47:31.493]                         }
[17:47:31.493]                       }
[17:47:31.493]                       invisible(muffled)
[17:47:31.493]                     }
[17:47:31.493]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.493]                   }
[17:47:31.493]                 }
[17:47:31.493]                 else {
[17:47:31.493]                   if (TRUE) {
[17:47:31.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.493]                     {
[17:47:31.493]                       inherits <- base::inherits
[17:47:31.493]                       invokeRestart <- base::invokeRestart
[17:47:31.493]                       is.null <- base::is.null
[17:47:31.493]                       muffled <- FALSE
[17:47:31.493]                       if (inherits(cond, "message")) {
[17:47:31.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.493]                         if (muffled) 
[17:47:31.493]                           invokeRestart("muffleMessage")
[17:47:31.493]                       }
[17:47:31.493]                       else if (inherits(cond, "warning")) {
[17:47:31.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.493]                         if (muffled) 
[17:47:31.493]                           invokeRestart("muffleWarning")
[17:47:31.493]                       }
[17:47:31.493]                       else if (inherits(cond, "condition")) {
[17:47:31.493]                         if (!is.null(pattern)) {
[17:47:31.493]                           computeRestarts <- base::computeRestarts
[17:47:31.493]                           grepl <- base::grepl
[17:47:31.493]                           restarts <- computeRestarts(cond)
[17:47:31.493]                           for (restart in restarts) {
[17:47:31.493]                             name <- restart$name
[17:47:31.493]                             if (is.null(name)) 
[17:47:31.493]                               next
[17:47:31.493]                             if (!grepl(pattern, name)) 
[17:47:31.493]                               next
[17:47:31.493]                             invokeRestart(restart)
[17:47:31.493]                             muffled <- TRUE
[17:47:31.493]                             break
[17:47:31.493]                           }
[17:47:31.493]                         }
[17:47:31.493]                       }
[17:47:31.493]                       invisible(muffled)
[17:47:31.493]                     }
[17:47:31.493]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.493]                   }
[17:47:31.493]                 }
[17:47:31.493]             }
[17:47:31.493]         }))
[17:47:31.493]     }, error = function(ex) {
[17:47:31.493]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.493]                 ...future.rng), started = ...future.startTime, 
[17:47:31.493]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.493]             version = "1.8"), class = "FutureResult")
[17:47:31.493]     }, finally = {
[17:47:31.493]         if (!identical(...future.workdir, getwd())) 
[17:47:31.493]             setwd(...future.workdir)
[17:47:31.493]         {
[17:47:31.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.493]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.493]             }
[17:47:31.493]             base::options(...future.oldOptions)
[17:47:31.493]             if (.Platform$OS.type == "windows") {
[17:47:31.493]                 old_names <- names(...future.oldEnvVars)
[17:47:31.493]                 envs <- base::Sys.getenv()
[17:47:31.493]                 names <- names(envs)
[17:47:31.493]                 common <- intersect(names, old_names)
[17:47:31.493]                 added <- setdiff(names, old_names)
[17:47:31.493]                 removed <- setdiff(old_names, names)
[17:47:31.493]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.493]                   envs[common]]
[17:47:31.493]                 NAMES <- toupper(changed)
[17:47:31.493]                 args <- list()
[17:47:31.493]                 for (kk in seq_along(NAMES)) {
[17:47:31.493]                   name <- changed[[kk]]
[17:47:31.493]                   NAME <- NAMES[[kk]]
[17:47:31.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.493]                     next
[17:47:31.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.493]                 }
[17:47:31.493]                 NAMES <- toupper(added)
[17:47:31.493]                 for (kk in seq_along(NAMES)) {
[17:47:31.493]                   name <- added[[kk]]
[17:47:31.493]                   NAME <- NAMES[[kk]]
[17:47:31.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.493]                     next
[17:47:31.493]                   args[[name]] <- ""
[17:47:31.493]                 }
[17:47:31.493]                 NAMES <- toupper(removed)
[17:47:31.493]                 for (kk in seq_along(NAMES)) {
[17:47:31.493]                   name <- removed[[kk]]
[17:47:31.493]                   NAME <- NAMES[[kk]]
[17:47:31.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.493]                     next
[17:47:31.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.493]                 }
[17:47:31.493]                 if (length(args) > 0) 
[17:47:31.493]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.493]             }
[17:47:31.493]             else {
[17:47:31.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.493]             }
[17:47:31.493]             {
[17:47:31.493]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.493]                   0L) {
[17:47:31.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.493]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.493]                   base::options(opts)
[17:47:31.493]                 }
[17:47:31.493]                 {
[17:47:31.493]                   {
[17:47:31.493]                     NULL
[17:47:31.493]                     RNGkind("Mersenne-Twister")
[17:47:31.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:31.493]                       inherits = FALSE)
[17:47:31.493]                   }
[17:47:31.493]                   options(future.plan = NULL)
[17:47:31.493]                   if (is.na(NA_character_)) 
[17:47:31.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.493]                     .init = FALSE)
[17:47:31.493]                 }
[17:47:31.493]             }
[17:47:31.493]         }
[17:47:31.493]     })
[17:47:31.493]     if (TRUE) {
[17:47:31.493]         base::sink(type = "output", split = FALSE)
[17:47:31.493]         if (TRUE) {
[17:47:31.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.493]         }
[17:47:31.493]         else {
[17:47:31.493]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.493]         }
[17:47:31.493]         base::close(...future.stdout)
[17:47:31.493]         ...future.stdout <- NULL
[17:47:31.493]     }
[17:47:31.493]     ...future.result$conditions <- ...future.conditions
[17:47:31.493]     ...future.result$finished <- base::Sys.time()
[17:47:31.493]     ...future.result
[17:47:31.493] }
[17:47:31.495] assign_globals() ...
[17:47:31.495] List of 1
[17:47:31.495]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:31.495]   ..$ a: int [1:3] 1 2 3
[17:47:31.495]   ..$ b: int [1:3] 3 2 1
[17:47:31.495]  - attr(*, "where")=List of 1
[17:47:31.495]   ..$ data:<environment: R_EmptyEnv> 
[17:47:31.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.495]  - attr(*, "resolved")= logi FALSE
[17:47:31.495]  - attr(*, "total_size")= num 128
[17:47:31.495]  - attr(*, "already-done")= logi TRUE
[17:47:31.499] - copied ‘data’ to environment
[17:47:31.501] assign_globals() ... done
[17:47:31.501] plan(): Setting new future strategy stack:
[17:47:31.502] List of future strategies:
[17:47:31.502] 1. multisession:
[17:47:31.502]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:31.502]    - tweaked: FALSE
[17:47:31.502]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.505] plan(): nbrOfWorkers() = 2
[17:47:31.548] plan(): Setting new future strategy stack:
[17:47:31.548] List of future strategies:
[17:47:31.548] 1. sequential:
[17:47:31.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.548]    - tweaked: FALSE
[17:47:31.548]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.548] 2. multisession:
[17:47:31.548]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:31.548]    - tweaked: FALSE
[17:47:31.548]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.548] plan(): nbrOfWorkers() = 1
[17:47:31.549] SequentialFuture started (and completed)
[17:47:31.549] signalConditions() ...
[17:47:31.549]  - include = ‘immediateCondition’
[17:47:31.549]  - exclude = 
[17:47:31.549]  - resignal = FALSE
[17:47:31.549]  - Number of conditions: 63
[17:47:31.549] signalConditions() ... done
[17:47:31.549] - Launch lazy future ... done
[17:47:31.549] run() for ‘SequentialFuture’ ... done
[17:47:31.549] signalConditions() ...
[17:47:31.550]  - include = ‘immediateCondition’
[17:47:31.550]  - exclude = 
[17:47:31.550]  - resignal = FALSE
[17:47:31.550]  - Number of conditions: 63
[17:47:31.550] signalConditions() ... done
[17:47:31.550] Future state: ‘finished’
[17:47:31.550] signalConditions() ...
[17:47:31.550]  - include = ‘condition’
[17:47:31.550]  - exclude = ‘immediateCondition’
[17:47:31.550]  - resignal = TRUE
[17:47:31.550]  - Number of conditions: 63
[17:47:31.551]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.506] getGlobalsAndPackages() ...
[17:47:31.551]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.506] Searching for globals...
[17:47:31.551]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.519] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:31.551]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.519] Searching for globals ... DONE
[17:47:31.551]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.519] Resolving globals: FALSE
[17:47:31.551]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.520] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:31.551]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.520] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:31.551]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.520] - globals: [1] ‘data’
[17:47:31.552]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.520] 
[17:47:31.552]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.520] getGlobalsAndPackages() ... DONE
[17:47:31.552]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.521] run() for ‘Future’ ...
[17:47:31.552]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.521] - state: ‘created’
[17:47:31.552]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.521] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.552]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.536] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.552]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:31.552]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘node’
[17:47:31.553]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘label’
[17:47:31.553]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘local’
[17:47:31.553]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘owner’
[17:47:31.553]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘envir’
[17:47:31.553]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘workers’
[17:47:31.553]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘packages’
[17:47:31.553]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.537]   - Field: ‘gc’
[17:47:31.553]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘conditions’
[17:47:31.554]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘persistent’
[17:47:31.554]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘expr’
[17:47:31.554]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘uuid’
[17:47:31.554]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘seed’
[17:47:31.554]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘version’
[17:47:31.554]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘result’
[17:47:31.554]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘asynchronous’
[17:47:31.554]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.538]   - Field: ‘calls’
[17:47:31.555]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539]   - Field: ‘globals’
[17:47:31.555]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539]   - Field: ‘stdout’
[17:47:31.555]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539]   - Field: ‘earlySignal’
[17:47:31.555]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539]   - Field: ‘lazy’
[17:47:31.555]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539]   - Field: ‘state’
[17:47:31.555]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:31.555]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539] - Launch lazy future ...
[17:47:31.556]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.539] Packages needed by the future expression (n = 0): <none>
[17:47:31.556]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.540] Packages needed by future strategies (n = 0): <none>
[17:47:31.556]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.540] {
[17:47:31.540]     {
[17:47:31.540]         {
[17:47:31.540]             ...future.startTime <- base::Sys.time()
[17:47:31.540]             {
[17:47:31.540]                 {
[17:47:31.540]                   {
[17:47:31.540]                     {
[17:47:31.540]                       base::local({
[17:47:31.540]                         has_future <- base::requireNamespace("future", 
[17:47:31.540]                           quietly = TRUE)
[17:47:31.540]                         if (has_future) {
[17:47:31.540]                           ns <- base::getNamespace("future")
[17:47:31.540]                           version <- ns[[".package"]][["version"]]
[17:47:31.540]                           if (is.null(version)) 
[17:47:31.540]                             version <- utils::packageVersion("future")
[17:47:31.540]                         }
[17:47:31.540]                         else {
[17:47:31.540]                           version <- NULL
[17:47:31.540]                         }
[17:47:31.540]                         if (!has_future || version < "1.8.0") {
[17:47:31.540]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.540]                             "", base::R.version$version.string), 
[17:47:31.540]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:31.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.540]                               "release", "version")], collapse = " "), 
[17:47:31.540]                             hostname = base::Sys.info()[["nodename"]])
[17:47:31.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.540]                             info)
[17:47:31.540]                           info <- base::paste(info, collapse = "; ")
[17:47:31.540]                           if (!has_future) {
[17:47:31.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.540]                               info)
[17:47:31.540]                           }
[17:47:31.540]                           else {
[17:47:31.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.540]                               info, version)
[17:47:31.540]                           }
[17:47:31.540]                           base::stop(msg)
[17:47:31.540]                         }
[17:47:31.540]                       })
[17:47:31.540]                     }
[17:47:31.540]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.540]                     base::options(mc.cores = 1L)
[17:47:31.540]                   }
[17:47:31.540]                   ...future.strategy.old <- future::plan("list")
[17:47:31.540]                   options(future.plan = NULL)
[17:47:31.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:31.540]                 }
[17:47:31.540]                 ...future.workdir <- getwd()
[17:47:31.540]             }
[17:47:31.540]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.540]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.540]         }
[17:47:31.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.540]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.540]             base::names(...future.oldOptions))
[17:47:31.540]     }
[17:47:31.540]     if (FALSE) {
[17:47:31.540]     }
[17:47:31.540]     else {
[17:47:31.540]         if (TRUE) {
[17:47:31.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.540]                 open = "w")
[17:47:31.540]         }
[17:47:31.540]         else {
[17:47:31.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.540]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.540]         }
[17:47:31.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.540]             base::sink(type = "output", split = FALSE)
[17:47:31.540]             base::close(...future.stdout)
[17:47:31.540]         }, add = TRUE)
[17:47:31.540]     }
[17:47:31.540]     ...future.frame <- base::sys.nframe()
[17:47:31.540]     ...future.conditions <- base::list()
[17:47:31.540]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.540]     if (FALSE) {
[17:47:31.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.540]     }
[17:47:31.540]     ...future.result <- base::tryCatch({
[17:47:31.540]         base::withCallingHandlers({
[17:47:31.540]             ...future.value <- base::withVisible(base::local({
[17:47:31.540]                 ...future.makeSendCondition <- base::local({
[17:47:31.540]                   sendCondition <- NULL
[17:47:31.540]                   function(frame = 1L) {
[17:47:31.540]                     if (is.function(sendCondition)) 
[17:47:31.540]                       return(sendCondition)
[17:47:31.540]                     ns <- getNamespace("parallel")
[17:47:31.540]                     if (exists("sendData", mode = "function", 
[17:47:31.540]                       envir = ns)) {
[17:47:31.540]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:31.540]                         envir = ns)
[17:47:31.540]                       envir <- sys.frame(frame)
[17:47:31.540]                       master <- NULL
[17:47:31.540]                       while (!identical(envir, .GlobalEnv) && 
[17:47:31.540]                         !identical(envir, emptyenv())) {
[17:47:31.540]                         if (exists("master", mode = "list", envir = envir, 
[17:47:31.540]                           inherits = FALSE)) {
[17:47:31.540]                           master <- get("master", mode = "list", 
[17:47:31.540]                             envir = envir, inherits = FALSE)
[17:47:31.540]                           if (inherits(master, c("SOCKnode", 
[17:47:31.540]                             "SOCK0node"))) {
[17:47:31.540]                             sendCondition <<- function(cond) {
[17:47:31.540]                               data <- list(type = "VALUE", value = cond, 
[17:47:31.540]                                 success = TRUE)
[17:47:31.540]                               parallel_sendData(master, data)
[17:47:31.540]                             }
[17:47:31.540]                             return(sendCondition)
[17:47:31.540]                           }
[17:47:31.540]                         }
[17:47:31.540]                         frame <- frame + 1L
[17:47:31.540]                         envir <- sys.frame(frame)
[17:47:31.540]                       }
[17:47:31.540]                     }
[17:47:31.540]                     sendCondition <<- function(cond) NULL
[17:47:31.540]                   }
[17:47:31.540]                 })
[17:47:31.540]                 withCallingHandlers({
[17:47:31.540]                   subset(data, a == 2)
[17:47:31.540]                 }, immediateCondition = function(cond) {
[17:47:31.540]                   sendCondition <- ...future.makeSendCondition()
[17:47:31.540]                   sendCondition(cond)
[17:47:31.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.540]                   {
[17:47:31.540]                     inherits <- base::inherits
[17:47:31.540]                     invokeRestart <- base::invokeRestart
[17:47:31.540]                     is.null <- base::is.null
[17:47:31.540]                     muffled <- FALSE
[17:47:31.540]                     if (inherits(cond, "message")) {
[17:47:31.540]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.540]                       if (muffled) 
[17:47:31.540]                         invokeRestart("muffleMessage")
[17:47:31.540]                     }
[17:47:31.540]                     else if (inherits(cond, "warning")) {
[17:47:31.540]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.540]                       if (muffled) 
[17:47:31.540]                         invokeRestart("muffleWarning")
[17:47:31.540]                     }
[17:47:31.540]                     else if (inherits(cond, "condition")) {
[17:47:31.540]                       if (!is.null(pattern)) {
[17:47:31.540]                         computeRestarts <- base::computeRestarts
[17:47:31.540]                         grepl <- base::grepl
[17:47:31.540]                         restarts <- computeRestarts(cond)
[17:47:31.540]                         for (restart in restarts) {
[17:47:31.540]                           name <- restart$name
[17:47:31.540]                           if (is.null(name)) 
[17:47:31.540]                             next
[17:47:31.540]                           if (!grepl(pattern, name)) 
[17:47:31.540]                             next
[17:47:31.540]                           invokeRestart(restart)
[17:47:31.540]                           muffled <- TRUE
[17:47:31.540]                           break
[17:47:31.540]                         }
[17:47:31.540]                       }
[17:47:31.540]                     }
[17:47:31.540]                     invisible(muffled)
[17:47:31.540]                   }
[17:47:31.540]                   muffleCondition(cond)
[17:47:31.540]                 })
[17:47:31.540]             }))
[17:47:31.540]             future::FutureResult(value = ...future.value$value, 
[17:47:31.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.540]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.540]                     ...future.globalenv.names))
[17:47:31.540]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.540]         }, condition = base::local({
[17:47:31.540]             c <- base::c
[17:47:31.540]             inherits <- base::inherits
[17:47:31.540]             invokeRestart <- base::invokeRestart
[17:47:31.540]             length <- base::length
[17:47:31.540]             list <- base::list
[17:47:31.540]             seq.int <- base::seq.int
[17:47:31.540]             signalCondition <- base::signalCondition
[17:47:31.540]             sys.calls <- base::sys.calls
[17:47:31.540]             `[[` <- base::`[[`
[17:47:31.540]             `+` <- base::`+`
[17:47:31.540]             `<<-` <- base::`<<-`
[17:47:31.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.540]                   3L)]
[17:47:31.540]             }
[17:47:31.540]             function(cond) {
[17:47:31.540]                 is_error <- inherits(cond, "error")
[17:47:31.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.540]                   NULL)
[17:47:31.540]                 if (is_error) {
[17:47:31.540]                   sessionInformation <- function() {
[17:47:31.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.540]                       search = base::search(), system = base::Sys.info())
[17:47:31.540]                   }
[17:47:31.540]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.540]                     cond$call), session = sessionInformation(), 
[17:47:31.540]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.540]                   signalCondition(cond)
[17:47:31.540]                 }
[17:47:31.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.540]                 "immediateCondition"))) {
[17:47:31.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.540]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.540]                   if (TRUE && !signal) {
[17:47:31.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.540]                     {
[17:47:31.540]                       inherits <- base::inherits
[17:47:31.540]                       invokeRestart <- base::invokeRestart
[17:47:31.540]                       is.null <- base::is.null
[17:47:31.540]                       muffled <- FALSE
[17:47:31.540]                       if (inherits(cond, "message")) {
[17:47:31.540]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.540]                         if (muffled) 
[17:47:31.540]                           invokeRestart("muffleMessage")
[17:47:31.540]                       }
[17:47:31.540]                       else if (inherits(cond, "warning")) {
[17:47:31.540]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.540]                         if (muffled) 
[17:47:31.540]                           invokeRestart("muffleWarning")
[17:47:31.540]                       }
[17:47:31.540]                       else if (inherits(cond, "condition")) {
[17:47:31.540]                         if (!is.null(pattern)) {
[17:47:31.540]                           computeRestarts <- base::computeRestarts
[17:47:31.540]                           grepl <- base::grepl
[17:47:31.540]                           restarts <- computeRestarts(cond)
[17:47:31.540]                           for (restart in restarts) {
[17:47:31.540]                             name <- restart$name
[17:47:31.540]                             if (is.null(name)) 
[17:47:31.540]                               next
[17:47:31.540]                             if (!grepl(pattern, name)) 
[17:47:31.540]                               next
[17:47:31.540]                             invokeRestart(restart)
[17:47:31.540]                             muffled <- TRUE
[17:47:31.540]                             break
[17:47:31.540]                           }
[17:47:31.540]                         }
[17:47:31.540]                       }
[17:47:31.540]                       invisible(muffled)
[17:47:31.540]                     }
[17:47:31.540]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.540]                   }
[17:47:31.540]                 }
[17:47:31.540]                 else {
[17:47:31.540]                   if (TRUE) {
[17:47:31.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.540]                     {
[17:47:31.540]                       inherits <- base::inherits
[17:47:31.540]                       invokeRestart <- base::invokeRestart
[17:47:31.540]                       is.null <- base::is.null
[17:47:31.540]                       muffled <- FALSE
[17:47:31.540]                       if (inherits(cond, "message")) {
[17:47:31.540]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.540]                         if (muffled) 
[17:47:31.540]                           invokeRestart("muffleMessage")
[17:47:31.540]                       }
[17:47:31.540]                       else if (inherits(cond, "warning")) {
[17:47:31.540]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.540]                         if (muffled) 
[17:47:31.540]                           invokeRestart("muffleWarning")
[17:47:31.540]                       }
[17:47:31.540]                       else if (inherits(cond, "condition")) {
[17:47:31.540]                         if (!is.null(pattern)) {
[17:47:31.540]                           computeRestarts <- base::computeRestarts
[17:47:31.540]                           grepl <- base::grepl
[17:47:31.540]                           restarts <- computeRestarts(cond)
[17:47:31.540]                           for (restart in restarts) {
[17:47:31.540]                             name <- restart$name
[17:47:31.540]                             if (is.null(name)) 
[17:47:31.540]                               next
[17:47:31.540]                             if (!grepl(pattern, name)) 
[17:47:31.540]                               next
[17:47:31.540]                             invokeRestart(restart)
[17:47:31.540]                             muffled <- TRUE
[17:47:31.540]                             break
[17:47:31.540]                           }
[17:47:31.540]                         }
[17:47:31.540]                       }
[17:47:31.540]                       invisible(muffled)
[17:47:31.540]                     }
[17:47:31.540]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.540]                   }
[17:47:31.540]                 }
[17:47:31.540]             }
[17:47:31.540]         }))
[17:47:31.540]     }, error = function(ex) {
[17:47:31.540]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.540]                 ...future.rng), started = ...future.startTime, 
[17:47:31.540]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.540]             version = "1.8"), class = "FutureResult")
[17:47:31.540]     }, finally = {
[17:47:31.540]         if (!identical(...future.workdir, getwd())) 
[17:47:31.540]             setwd(...future.workdir)
[17:47:31.540]         {
[17:47:31.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.540]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.540]             }
[17:47:31.540]             base::options(...future.oldOptions)
[17:47:31.540]             if (.Platform$OS.type == "windows") {
[17:47:31.540]                 old_names <- names(...future.oldEnvVars)
[17:47:31.540]                 envs <- base::Sys.getenv()
[17:47:31.540]                 names <- names(envs)
[17:47:31.540]                 common <- intersect(names, old_names)
[17:47:31.540]                 added <- setdiff(names, old_names)
[17:47:31.540]                 removed <- setdiff(old_names, names)
[17:47:31.540]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.540]                   envs[common]]
[17:47:31.540]                 NAMES <- toupper(changed)
[17:47:31.540]                 args <- list()
[17:47:31.540]                 for (kk in seq_along(NAMES)) {
[17:47:31.540]                   name <- changed[[kk]]
[17:47:31.540]                   NAME <- NAMES[[kk]]
[17:47:31.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.540]                     next
[17:47:31.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.540]                 }
[17:47:31.540]                 NAMES <- toupper(added)
[17:47:31.540]                 for (kk in seq_along(NAMES)) {
[17:47:31.540]                   name <- added[[kk]]
[17:47:31.540]                   NAME <- NAMES[[kk]]
[17:47:31.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.540]                     next
[17:47:31.540]                   args[[name]] <- ""
[17:47:31.540]                 }
[17:47:31.540]                 NAMES <- toupper(removed)
[17:47:31.540]                 for (kk in seq_along(NAMES)) {
[17:47:31.540]                   name <- removed[[kk]]
[17:47:31.540]                   NAME <- NAMES[[kk]]
[17:47:31.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.540]                     next
[17:47:31.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.540]                 }
[17:47:31.540]                 if (length(args) > 0) 
[17:47:31.540]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.540]             }
[17:47:31.540]             else {
[17:47:31.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.540]             }
[17:47:31.540]             {
[17:47:31.540]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.540]                   0L) {
[17:47:31.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.540]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.540]                   base::options(opts)
[17:47:31.540]                 }
[17:47:31.540]                 {
[17:47:31.540]                   {
[17:47:31.540]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.540]                     NULL
[17:47:31.540]                   }
[17:47:31.540]                   options(future.plan = NULL)
[17:47:31.540]                   if (is.na(NA_character_)) 
[17:47:31.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.540]                     .init = FALSE)
[17:47:31.540]                 }
[17:47:31.540]             }
[17:47:31.540]         }
[17:47:31.540]     })
[17:47:31.540]     if (TRUE) {
[17:47:31.540]         base::sink(type = "output", split = FALSE)
[17:47:31.540]         if (TRUE) {
[17:47:31.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.540]         }
[17:47:31.540]         else {
[17:47:31.540]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.540]         }
[17:47:31.540]         base::close(...future.stdout)
[17:47:31.540]         ...future.stdout <- NULL
[17:47:31.540]     }
[17:47:31.540]     ...future.result$conditions <- ...future.conditions
[17:47:31.540]     ...future.result$finished <- base::Sys.time()
[17:47:31.540]     ...future.result
[17:47:31.540] }
[17:47:31.556]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.542] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:47:31.556]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.543] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:47:31.556]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.543] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:47:31.556]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.543] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:47:31.556]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.544] MultisessionFuture started
[17:47:31.557]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.544] - Launch lazy future ... done
[17:47:31.557]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.544] run() for ‘MultisessionFuture’ ... done
[17:47:31.557]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.544] result() for ClusterFuture ...
[17:47:31.557]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.545] receiveMessageFromWorker() for ClusterFuture ...
[17:47:31.557]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.545] - Validating connection of MultisessionFuture
[17:47:31.557]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.546] - received message: FutureResult
[17:47:31.557]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.546] - Received FutureResult
[17:47:31.557]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.546] - Erased future from FutureRegistry
[17:47:31.558]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] result() for ClusterFuture ...
[17:47:31.558]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] - result already collected: FutureResult
[17:47:31.558]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] result() for ClusterFuture ... done
[17:47:31.558]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:31.558]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] result() for ClusterFuture ... done
[17:47:31.558]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] result() for ClusterFuture ...
[17:47:31.558]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] - result already collected: FutureResult
[17:47:31.558]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.547] result() for ClusterFuture ... done
[17:47:31.559] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[17:47:31.559] plan(): Setting new future strategy stack:
[17:47:31.559] List of future strategies:
[17:47:31.559] 1. multicore:
[17:47:31.559]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.559]    - tweaked: FALSE
[17:47:31.559]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.559] 2. sequential:
[17:47:31.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.559]    - tweaked: FALSE
[17:47:31.559]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.563] plan(): nbrOfWorkers() = 2
[17:47:31.564] getGlobalsAndPackages() ...
[17:47:31.564] Searching for globals...
[17:47:31.586] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:31.586] Searching for globals ... DONE
[17:47:31.586] Resolving globals: FALSE
[17:47:31.587] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[17:47:31.587] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:31.587] - globals: [2] ‘nested’, ‘strategy2’
[17:47:31.588] - packages: [1] ‘future’
[17:47:31.588] getGlobalsAndPackages() ... DONE
[17:47:31.588] run() for ‘Future’ ...
[17:47:31.588] - state: ‘created’
[17:47:31.588] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.592] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.592] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:31.592]   - Field: ‘label’
[17:47:31.592]   - Field: ‘local’
[17:47:31.592]   - Field: ‘owner’
[17:47:31.592]   - Field: ‘envir’
[17:47:31.592]   - Field: ‘workers’
[17:47:31.592]   - Field: ‘packages’
[17:47:31.592]   - Field: ‘gc’
[17:47:31.593]   - Field: ‘job’
[17:47:31.593]   - Field: ‘conditions’
[17:47:31.593]   - Field: ‘expr’
[17:47:31.593]   - Field: ‘uuid’
[17:47:31.593]   - Field: ‘seed’
[17:47:31.593]   - Field: ‘version’
[17:47:31.593]   - Field: ‘result’
[17:47:31.593]   - Field: ‘asynchronous’
[17:47:31.593]   - Field: ‘calls’
[17:47:31.593]   - Field: ‘globals’
[17:47:31.593]   - Field: ‘stdout’
[17:47:31.593]   - Field: ‘earlySignal’
[17:47:31.594]   - Field: ‘lazy’
[17:47:31.594]   - Field: ‘state’
[17:47:31.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:31.594] - Launch lazy future ...
[17:47:31.594] Packages needed by the future expression (n = 1): ‘future’
[17:47:31.594] Packages needed by future strategies (n = 1): ‘future’
[17:47:31.595] {
[17:47:31.595]     {
[17:47:31.595]         {
[17:47:31.595]             ...future.startTime <- base::Sys.time()
[17:47:31.595]             {
[17:47:31.595]                 {
[17:47:31.595]                   {
[17:47:31.595]                     {
[17:47:31.595]                       {
[17:47:31.595]                         base::local({
[17:47:31.595]                           has_future <- base::requireNamespace("future", 
[17:47:31.595]                             quietly = TRUE)
[17:47:31.595]                           if (has_future) {
[17:47:31.595]                             ns <- base::getNamespace("future")
[17:47:31.595]                             version <- ns[[".package"]][["version"]]
[17:47:31.595]                             if (is.null(version)) 
[17:47:31.595]                               version <- utils::packageVersion("future")
[17:47:31.595]                           }
[17:47:31.595]                           else {
[17:47:31.595]                             version <- NULL
[17:47:31.595]                           }
[17:47:31.595]                           if (!has_future || version < "1.8.0") {
[17:47:31.595]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.595]                               "", base::R.version$version.string), 
[17:47:31.595]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:31.595]                                 base::R.version$platform, 8 * 
[17:47:31.595]                                   base::.Machine$sizeof.pointer), 
[17:47:31.595]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.595]                                 "release", "version")], collapse = " "), 
[17:47:31.595]                               hostname = base::Sys.info()[["nodename"]])
[17:47:31.595]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.595]                               info)
[17:47:31.595]                             info <- base::paste(info, collapse = "; ")
[17:47:31.595]                             if (!has_future) {
[17:47:31.595]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.595]                                 info)
[17:47:31.595]                             }
[17:47:31.595]                             else {
[17:47:31.595]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.595]                                 info, version)
[17:47:31.595]                             }
[17:47:31.595]                             base::stop(msg)
[17:47:31.595]                           }
[17:47:31.595]                         })
[17:47:31.595]                       }
[17:47:31.595]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.595]                       base::options(mc.cores = 1L)
[17:47:31.595]                     }
[17:47:31.595]                     base::local({
[17:47:31.595]                       for (pkg in "future") {
[17:47:31.595]                         base::loadNamespace(pkg)
[17:47:31.595]                         base::library(pkg, character.only = TRUE)
[17:47:31.595]                       }
[17:47:31.595]                     })
[17:47:31.595]                   }
[17:47:31.595]                   ...future.strategy.old <- future::plan("list")
[17:47:31.595]                   options(future.plan = NULL)
[17:47:31.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.595]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:31.595]                   {
[17:47:31.595]                     future <- SequentialFuture(..., envir = envir)
[17:47:31.595]                     if (!future$lazy) 
[17:47:31.595]                       future <- run(future)
[17:47:31.595]                     invisible(future)
[17:47:31.595]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:31.595]                 }
[17:47:31.595]                 ...future.workdir <- getwd()
[17:47:31.595]             }
[17:47:31.595]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.595]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.595]         }
[17:47:31.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.595]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.595]             base::names(...future.oldOptions))
[17:47:31.595]     }
[17:47:31.595]     if (FALSE) {
[17:47:31.595]     }
[17:47:31.595]     else {
[17:47:31.595]         if (TRUE) {
[17:47:31.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.595]                 open = "w")
[17:47:31.595]         }
[17:47:31.595]         else {
[17:47:31.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.595]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.595]         }
[17:47:31.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.595]             base::sink(type = "output", split = FALSE)
[17:47:31.595]             base::close(...future.stdout)
[17:47:31.595]         }, add = TRUE)
[17:47:31.595]     }
[17:47:31.595]     ...future.frame <- base::sys.nframe()
[17:47:31.595]     ...future.conditions <- base::list()
[17:47:31.595]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.595]     if (FALSE) {
[17:47:31.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.595]     }
[17:47:31.595]     ...future.result <- base::tryCatch({
[17:47:31.595]         base::withCallingHandlers({
[17:47:31.595]             ...future.value <- base::withVisible(base::local({
[17:47:31.595]                 withCallingHandlers({
[17:47:31.595]                   {
[17:47:31.595]                     a <- 1L
[17:47:31.595]                     plan_a <- unclass(future::plan("list"))
[17:47:31.595]                     nested_a <- nested[-1]
[17:47:31.595]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:31.595]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:31.595]                       strategy2))
[17:47:31.595]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:31.595]                       "init") <- NULL
[17:47:31.595]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:31.595]                       "init") <- NULL
[17:47:31.595]                     stopifnot(all.equal(plan_a, nested_a))
[17:47:31.595]                     y %<-% {
[17:47:31.595]                       b <- 2L
[17:47:31.595]                       plan_b <- future::plan("list")
[17:47:31.595]                       nested_b <- nested_a[-1]
[17:47:31.595]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:31.595]                         1L, inherits(plan_b[[1]], "future"), 
[17:47:31.595]                         inherits(future::plan("next"), "sequential"))
[17:47:31.595]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:31.595]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:31.595]                     }
[17:47:31.595]                     y
[17:47:31.595]                   }
[17:47:31.595]                 }, immediateCondition = function(cond) {
[17:47:31.595]                   save_rds <- function (object, pathname, ...) 
[17:47:31.595]                   {
[17:47:31.595]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:31.595]                     if (file_test("-f", pathname_tmp)) {
[17:47:31.595]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.595]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:31.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.595]                         fi_tmp[["mtime"]])
[17:47:31.595]                     }
[17:47:31.595]                     tryCatch({
[17:47:31.595]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:31.595]                     }, error = function(ex) {
[17:47:31.595]                       msg <- conditionMessage(ex)
[17:47:31.595]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.595]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:31.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.595]                         fi_tmp[["mtime"]], msg)
[17:47:31.595]                       ex$message <- msg
[17:47:31.595]                       stop(ex)
[17:47:31.595]                     })
[17:47:31.595]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:31.595]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:31.595]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:31.595]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.595]                       fi <- file.info(pathname)
[17:47:31.595]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:31.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.595]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:31.595]                         fi[["size"]], fi[["mtime"]])
[17:47:31.595]                       stop(msg)
[17:47:31.595]                     }
[17:47:31.595]                     invisible(pathname)
[17:47:31.595]                   }
[17:47:31.595]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:31.595]                     rootPath = tempdir()) 
[17:47:31.595]                   {
[17:47:31.595]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:31.595]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:31.595]                       tmpdir = path, fileext = ".rds")
[17:47:31.595]                     save_rds(obj, file)
[17:47:31.595]                   }
[17:47:31.595]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:31.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.595]                   {
[17:47:31.595]                     inherits <- base::inherits
[17:47:31.595]                     invokeRestart <- base::invokeRestart
[17:47:31.595]                     is.null <- base::is.null
[17:47:31.595]                     muffled <- FALSE
[17:47:31.595]                     if (inherits(cond, "message")) {
[17:47:31.595]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.595]                       if (muffled) 
[17:47:31.595]                         invokeRestart("muffleMessage")
[17:47:31.595]                     }
[17:47:31.595]                     else if (inherits(cond, "warning")) {
[17:47:31.595]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.595]                       if (muffled) 
[17:47:31.595]                         invokeRestart("muffleWarning")
[17:47:31.595]                     }
[17:47:31.595]                     else if (inherits(cond, "condition")) {
[17:47:31.595]                       if (!is.null(pattern)) {
[17:47:31.595]                         computeRestarts <- base::computeRestarts
[17:47:31.595]                         grepl <- base::grepl
[17:47:31.595]                         restarts <- computeRestarts(cond)
[17:47:31.595]                         for (restart in restarts) {
[17:47:31.595]                           name <- restart$name
[17:47:31.595]                           if (is.null(name)) 
[17:47:31.595]                             next
[17:47:31.595]                           if (!grepl(pattern, name)) 
[17:47:31.595]                             next
[17:47:31.595]                           invokeRestart(restart)
[17:47:31.595]                           muffled <- TRUE
[17:47:31.595]                           break
[17:47:31.595]                         }
[17:47:31.595]                       }
[17:47:31.595]                     }
[17:47:31.595]                     invisible(muffled)
[17:47:31.595]                   }
[17:47:31.595]                   muffleCondition(cond)
[17:47:31.595]                 })
[17:47:31.595]             }))
[17:47:31.595]             future::FutureResult(value = ...future.value$value, 
[17:47:31.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.595]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.595]                     ...future.globalenv.names))
[17:47:31.595]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.595]         }, condition = base::local({
[17:47:31.595]             c <- base::c
[17:47:31.595]             inherits <- base::inherits
[17:47:31.595]             invokeRestart <- base::invokeRestart
[17:47:31.595]             length <- base::length
[17:47:31.595]             list <- base::list
[17:47:31.595]             seq.int <- base::seq.int
[17:47:31.595]             signalCondition <- base::signalCondition
[17:47:31.595]             sys.calls <- base::sys.calls
[17:47:31.595]             `[[` <- base::`[[`
[17:47:31.595]             `+` <- base::`+`
[17:47:31.595]             `<<-` <- base::`<<-`
[17:47:31.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.595]                   3L)]
[17:47:31.595]             }
[17:47:31.595]             function(cond) {
[17:47:31.595]                 is_error <- inherits(cond, "error")
[17:47:31.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.595]                   NULL)
[17:47:31.595]                 if (is_error) {
[17:47:31.595]                   sessionInformation <- function() {
[17:47:31.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.595]                       search = base::search(), system = base::Sys.info())
[17:47:31.595]                   }
[17:47:31.595]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.595]                     cond$call), session = sessionInformation(), 
[17:47:31.595]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.595]                   signalCondition(cond)
[17:47:31.595]                 }
[17:47:31.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.595]                 "immediateCondition"))) {
[17:47:31.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.595]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.595]                   if (TRUE && !signal) {
[17:47:31.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.595]                     {
[17:47:31.595]                       inherits <- base::inherits
[17:47:31.595]                       invokeRestart <- base::invokeRestart
[17:47:31.595]                       is.null <- base::is.null
[17:47:31.595]                       muffled <- FALSE
[17:47:31.595]                       if (inherits(cond, "message")) {
[17:47:31.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.595]                         if (muffled) 
[17:47:31.595]                           invokeRestart("muffleMessage")
[17:47:31.595]                       }
[17:47:31.595]                       else if (inherits(cond, "warning")) {
[17:47:31.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.595]                         if (muffled) 
[17:47:31.595]                           invokeRestart("muffleWarning")
[17:47:31.595]                       }
[17:47:31.595]                       else if (inherits(cond, "condition")) {
[17:47:31.595]                         if (!is.null(pattern)) {
[17:47:31.595]                           computeRestarts <- base::computeRestarts
[17:47:31.595]                           grepl <- base::grepl
[17:47:31.595]                           restarts <- computeRestarts(cond)
[17:47:31.595]                           for (restart in restarts) {
[17:47:31.595]                             name <- restart$name
[17:47:31.595]                             if (is.null(name)) 
[17:47:31.595]                               next
[17:47:31.595]                             if (!grepl(pattern, name)) 
[17:47:31.595]                               next
[17:47:31.595]                             invokeRestart(restart)
[17:47:31.595]                             muffled <- TRUE
[17:47:31.595]                             break
[17:47:31.595]                           }
[17:47:31.595]                         }
[17:47:31.595]                       }
[17:47:31.595]                       invisible(muffled)
[17:47:31.595]                     }
[17:47:31.595]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.595]                   }
[17:47:31.595]                 }
[17:47:31.595]                 else {
[17:47:31.595]                   if (TRUE) {
[17:47:31.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.595]                     {
[17:47:31.595]                       inherits <- base::inherits
[17:47:31.595]                       invokeRestart <- base::invokeRestart
[17:47:31.595]                       is.null <- base::is.null
[17:47:31.595]                       muffled <- FALSE
[17:47:31.595]                       if (inherits(cond, "message")) {
[17:47:31.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.595]                         if (muffled) 
[17:47:31.595]                           invokeRestart("muffleMessage")
[17:47:31.595]                       }
[17:47:31.595]                       else if (inherits(cond, "warning")) {
[17:47:31.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.595]                         if (muffled) 
[17:47:31.595]                           invokeRestart("muffleWarning")
[17:47:31.595]                       }
[17:47:31.595]                       else if (inherits(cond, "condition")) {
[17:47:31.595]                         if (!is.null(pattern)) {
[17:47:31.595]                           computeRestarts <- base::computeRestarts
[17:47:31.595]                           grepl <- base::grepl
[17:47:31.595]                           restarts <- computeRestarts(cond)
[17:47:31.595]                           for (restart in restarts) {
[17:47:31.595]                             name <- restart$name
[17:47:31.595]                             if (is.null(name)) 
[17:47:31.595]                               next
[17:47:31.595]                             if (!grepl(pattern, name)) 
[17:47:31.595]                               next
[17:47:31.595]                             invokeRestart(restart)
[17:47:31.595]                             muffled <- TRUE
[17:47:31.595]                             break
[17:47:31.595]                           }
[17:47:31.595]                         }
[17:47:31.595]                       }
[17:47:31.595]                       invisible(muffled)
[17:47:31.595]                     }
[17:47:31.595]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.595]                   }
[17:47:31.595]                 }
[17:47:31.595]             }
[17:47:31.595]         }))
[17:47:31.595]     }, error = function(ex) {
[17:47:31.595]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.595]                 ...future.rng), started = ...future.startTime, 
[17:47:31.595]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.595]             version = "1.8"), class = "FutureResult")
[17:47:31.595]     }, finally = {
[17:47:31.595]         if (!identical(...future.workdir, getwd())) 
[17:47:31.595]             setwd(...future.workdir)
[17:47:31.595]         {
[17:47:31.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.595]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.595]             }
[17:47:31.595]             base::options(...future.oldOptions)
[17:47:31.595]             if (.Platform$OS.type == "windows") {
[17:47:31.595]                 old_names <- names(...future.oldEnvVars)
[17:47:31.595]                 envs <- base::Sys.getenv()
[17:47:31.595]                 names <- names(envs)
[17:47:31.595]                 common <- intersect(names, old_names)
[17:47:31.595]                 added <- setdiff(names, old_names)
[17:47:31.595]                 removed <- setdiff(old_names, names)
[17:47:31.595]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.595]                   envs[common]]
[17:47:31.595]                 NAMES <- toupper(changed)
[17:47:31.595]                 args <- list()
[17:47:31.595]                 for (kk in seq_along(NAMES)) {
[17:47:31.595]                   name <- changed[[kk]]
[17:47:31.595]                   NAME <- NAMES[[kk]]
[17:47:31.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.595]                     next
[17:47:31.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.595]                 }
[17:47:31.595]                 NAMES <- toupper(added)
[17:47:31.595]                 for (kk in seq_along(NAMES)) {
[17:47:31.595]                   name <- added[[kk]]
[17:47:31.595]                   NAME <- NAMES[[kk]]
[17:47:31.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.595]                     next
[17:47:31.595]                   args[[name]] <- ""
[17:47:31.595]                 }
[17:47:31.595]                 NAMES <- toupper(removed)
[17:47:31.595]                 for (kk in seq_along(NAMES)) {
[17:47:31.595]                   name <- removed[[kk]]
[17:47:31.595]                   NAME <- NAMES[[kk]]
[17:47:31.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.595]                     next
[17:47:31.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.595]                 }
[17:47:31.595]                 if (length(args) > 0) 
[17:47:31.595]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.595]             }
[17:47:31.595]             else {
[17:47:31.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.595]             }
[17:47:31.595]             {
[17:47:31.595]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.595]                   0L) {
[17:47:31.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.595]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.595]                   base::options(opts)
[17:47:31.595]                 }
[17:47:31.595]                 {
[17:47:31.595]                   {
[17:47:31.595]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.595]                     NULL
[17:47:31.595]                   }
[17:47:31.595]                   options(future.plan = NULL)
[17:47:31.595]                   if (is.na(NA_character_)) 
[17:47:31.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.595]                     .init = FALSE)
[17:47:31.595]                 }
[17:47:31.595]             }
[17:47:31.595]         }
[17:47:31.595]     })
[17:47:31.595]     if (TRUE) {
[17:47:31.595]         base::sink(type = "output", split = FALSE)
[17:47:31.595]         if (TRUE) {
[17:47:31.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.595]         }
[17:47:31.595]         else {
[17:47:31.595]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.595]         }
[17:47:31.595]         base::close(...future.stdout)
[17:47:31.595]         ...future.stdout <- NULL
[17:47:31.595]     }
[17:47:31.595]     ...future.result$conditions <- ...future.conditions
[17:47:31.595]     ...future.result$finished <- base::Sys.time()
[17:47:31.595]     ...future.result
[17:47:31.595] }
[17:47:31.597] assign_globals() ...
[17:47:31.597] List of 2
[17:47:31.597]  $ nested   :List of 2
[17:47:31.597]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:31.597]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:31.597]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.597]   ..$ b:function (..., envir = parent.frame())  
[17:47:31.597]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:31.597]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.597]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:31.597]  $ strategy2: chr "sequential"
[17:47:31.597]  - attr(*, "where")=List of 2
[17:47:31.597]   ..$ nested   :<environment: R_EmptyEnv> 
[17:47:31.597]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:47:31.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.597]  - attr(*, "resolved")= logi FALSE
[17:47:31.597]  - attr(*, "total_size")= num 59224
[17:47:31.597]  - attr(*, "already-done")= logi TRUE
[17:47:31.601] - copied ‘nested’ to environment
[17:47:31.602] - copied ‘strategy2’ to environment
[17:47:31.602] assign_globals() ... done
[17:47:31.602] requestCore(): workers = 2
[17:47:31.604] MulticoreFuture started
[17:47:31.605] - Launch lazy future ... done
[17:47:31.605] run() for ‘MulticoreFuture’ ... done
[17:47:31.605] result() for MulticoreFuture ...
[17:47:31.605] plan(): Setting new future strategy stack:
[17:47:31.606] List of future strategies:
[17:47:31.606] 1. sequential:
[17:47:31.606]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.606]    - tweaked: FALSE
[17:47:31.606]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.607] plan(): nbrOfWorkers() = 1
[17:47:31.643] plan(): Setting new future strategy stack:
[17:47:31.643] List of future strategies:
[17:47:31.643] 1. multicore:
[17:47:31.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.643]    - tweaked: FALSE
[17:47:31.643]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.643] 2. sequential:
[17:47:31.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.643]    - tweaked: FALSE
[17:47:31.643]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.648] plan(): nbrOfWorkers() = 2
[17:47:31.649] result() for MulticoreFuture ...
[17:47:31.649] result() for MulticoreFuture ... done
[17:47:31.649] signalConditions() ...
[17:47:31.649]  - include = ‘immediateCondition’
[17:47:31.649]  - exclude = 
[17:47:31.650]  - resignal = FALSE
[17:47:31.650]  - Number of conditions: 54
[17:47:31.650] signalConditions() ... done
[17:47:31.650] result() for MulticoreFuture ... done
[17:47:31.650] result() for MulticoreFuture ...
[17:47:31.650] result() for MulticoreFuture ... done
[17:47:31.650] signalConditions() ...
[17:47:31.650]  - include = ‘immediateCondition’
[17:47:31.651]  - exclude = 
[17:47:31.651]  - resignal = FALSE
[17:47:31.651]  - Number of conditions: 54
[17:47:31.651] signalConditions() ... done
[17:47:31.651] Future state: ‘finished’
[17:47:31.651] result() for MulticoreFuture ...
[17:47:31.651] result() for MulticoreFuture ... done
[17:47:31.652] signalConditions() ...
[17:47:31.652]  - include = ‘condition’
[17:47:31.652]  - exclude = ‘immediateCondition’
[17:47:31.652]  - resignal = TRUE
[17:47:31.652]  - Number of conditions: 54
[17:47:31.652]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.609] getGlobalsAndPackages() ...
[17:47:31.652]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.609] Searching for globals...
[17:47:31.652]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.618] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:47:31.653]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.618] Searching for globals ... DONE
[17:47:31.653]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.619] Resolving globals: FALSE
[17:47:31.653]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.620] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[17:47:31.653]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.621] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:47:31.653]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.621] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:47:31.653]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.621] 
[17:47:31.654]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.621] getGlobalsAndPackages() ... DONE
[17:47:31.654]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.622] run() for ‘Future’ ...
[17:47:31.654]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.622] - state: ‘created’
[17:47:31.654]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.622] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:31.654]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.623] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:31.655]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:31.655]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.623]   - Field: ‘label’
[17:47:31.655]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.624]   - Field: ‘local’
[17:47:31.655]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.624]   - Field: ‘owner’
[17:47:31.655]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.624]   - Field: ‘envir’
[17:47:31.655]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.624]   - Field: ‘packages’
[17:47:31.656]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.624]   - Field: ‘gc’
[17:47:31.656]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.625]   - Field: ‘conditions’
[17:47:31.656]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.625]   - Field: ‘expr’
[17:47:31.656]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.625]   - Field: ‘uuid’
[17:47:31.656]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.625]   - Field: ‘seed’
[17:47:31.656]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.625]   - Field: ‘version’
[17:47:31.657]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.625]   - Field: ‘result’
[17:47:31.657]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.626]   - Field: ‘asynchronous’
[17:47:31.657]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.626]   - Field: ‘calls’
[17:47:31.657]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.626]   - Field: ‘globals’
[17:47:31.657]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.626]   - Field: ‘stdout’
[17:47:31.658]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.626]   - Field: ‘earlySignal’
[17:47:31.658]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.626]   - Field: ‘lazy’
[17:47:31.658]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.627]   - Field: ‘state’
[17:47:31.658]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:31.658]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.627] - Launch lazy future ...
[17:47:31.658]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.627] Packages needed by the future expression (n = 0): <none>
[17:47:31.658]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.627] Packages needed by future strategies (n = 0): <none>
[17:47:31.659]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.628] {
[17:47:31.628]     {
[17:47:31.628]         {
[17:47:31.628]             ...future.startTime <- base::Sys.time()
[17:47:31.628]             {
[17:47:31.628]                 {
[17:47:31.628]                   {
[17:47:31.628]                     base::local({
[17:47:31.628]                       has_future <- base::requireNamespace("future", 
[17:47:31.628]                         quietly = TRUE)
[17:47:31.628]                       if (has_future) {
[17:47:31.628]                         ns <- base::getNamespace("future")
[17:47:31.628]                         version <- ns[[".package"]][["version"]]
[17:47:31.628]                         if (is.null(version)) 
[17:47:31.628]                           version <- utils::packageVersion("future")
[17:47:31.628]                       }
[17:47:31.628]                       else {
[17:47:31.628]                         version <- NULL
[17:47:31.628]                       }
[17:47:31.628]                       if (!has_future || version < "1.8.0") {
[17:47:31.628]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.628]                           "", base::R.version$version.string), 
[17:47:31.628]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:31.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.628]                             "release", "version")], collapse = " "), 
[17:47:31.628]                           hostname = base::Sys.info()[["nodename"]])
[17:47:31.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.628]                           info)
[17:47:31.628]                         info <- base::paste(info, collapse = "; ")
[17:47:31.628]                         if (!has_future) {
[17:47:31.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.628]                             info)
[17:47:31.628]                         }
[17:47:31.628]                         else {
[17:47:31.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.628]                             info, version)
[17:47:31.628]                         }
[17:47:31.628]                         base::stop(msg)
[17:47:31.628]                       }
[17:47:31.628]                     })
[17:47:31.628]                   }
[17:47:31.628]                   ...future.strategy.old <- future::plan("list")
[17:47:31.628]                   options(future.plan = NULL)
[17:47:31.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:31.628]                 }
[17:47:31.628]                 ...future.workdir <- getwd()
[17:47:31.628]             }
[17:47:31.628]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.628]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.628]         }
[17:47:31.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.628]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.628]             base::names(...future.oldOptions))
[17:47:31.628]     }
[17:47:31.628]     if (FALSE) {
[17:47:31.628]     }
[17:47:31.628]     else {
[17:47:31.628]         if (TRUE) {
[17:47:31.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.628]                 open = "w")
[17:47:31.628]         }
[17:47:31.628]         else {
[17:47:31.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.628]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.628]         }
[17:47:31.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.628]             base::sink(type = "output", split = FALSE)
[17:47:31.628]             base::close(...future.stdout)
[17:47:31.628]         }, add = TRUE)
[17:47:31.628]     }
[17:47:31.628]     ...future.frame <- base::sys.nframe()
[17:47:31.628]     ...future.conditions <- base::list()
[17:47:31.628]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.628]     if (FALSE) {
[17:47:31.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.628]     }
[17:47:31.628]     ...future.result <- base::tryCatch({
[17:47:31.628]         base::withCallingHandlers({
[17:47:31.628]             ...future.value <- base::withVisible(base::local({
[17:47:31.628]                 b <- 2L
[17:47:31.628]                 plan_b <- future::plan("list")
[17:47:31.628]                 nested_b <- nested_a[-1]
[17:47:31.628]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:31.628]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:31.628]                   "sequential"))
[17:47:31.628]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:31.628]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:31.628]             }))
[17:47:31.628]             future::FutureResult(value = ...future.value$value, 
[17:47:31.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.628]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.628]                     ...future.globalenv.names))
[17:47:31.628]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.628]         }, condition = base::local({
[17:47:31.628]             c <- base::c
[17:47:31.628]             inherits <- base::inherits
[17:47:31.628]             invokeRestart <- base::invokeRestart
[17:47:31.628]             length <- base::length
[17:47:31.628]             list <- base::list
[17:47:31.628]             seq.int <- base::seq.int
[17:47:31.628]             signalCondition <- base::signalCondition
[17:47:31.628]             sys.calls <- base::sys.calls
[17:47:31.628]             `[[` <- base::`[[`
[17:47:31.628]             `+` <- base::`+`
[17:47:31.628]             `<<-` <- base::`<<-`
[17:47:31.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.628]                   3L)]
[17:47:31.628]             }
[17:47:31.628]             function(cond) {
[17:47:31.628]                 is_error <- inherits(cond, "error")
[17:47:31.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.628]                   NULL)
[17:47:31.628]                 if (is_error) {
[17:47:31.628]                   sessionInformation <- function() {
[17:47:31.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.628]                       search = base::search(), system = base::Sys.info())
[17:47:31.628]                   }
[17:47:31.628]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.628]                     cond$call), session = sessionInformation(), 
[17:47:31.628]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.628]                   signalCondition(cond)
[17:47:31.628]                 }
[17:47:31.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.628]                 "immediateCondition"))) {
[17:47:31.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.628]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.628]                   if (TRUE && !signal) {
[17:47:31.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.628]                     {
[17:47:31.628]                       inherits <- base::inherits
[17:47:31.628]                       invokeRestart <- base::invokeRestart
[17:47:31.628]                       is.null <- base::is.null
[17:47:31.628]                       muffled <- FALSE
[17:47:31.628]                       if (inherits(cond, "message")) {
[17:47:31.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.628]                         if (muffled) 
[17:47:31.628]                           invokeRestart("muffleMessage")
[17:47:31.628]                       }
[17:47:31.628]                       else if (inherits(cond, "warning")) {
[17:47:31.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.628]                         if (muffled) 
[17:47:31.628]                           invokeRestart("muffleWarning")
[17:47:31.628]                       }
[17:47:31.628]                       else if (inherits(cond, "condition")) {
[17:47:31.628]                         if (!is.null(pattern)) {
[17:47:31.628]                           computeRestarts <- base::computeRestarts
[17:47:31.628]                           grepl <- base::grepl
[17:47:31.628]                           restarts <- computeRestarts(cond)
[17:47:31.628]                           for (restart in restarts) {
[17:47:31.628]                             name <- restart$name
[17:47:31.628]                             if (is.null(name)) 
[17:47:31.628]                               next
[17:47:31.628]                             if (!grepl(pattern, name)) 
[17:47:31.628]                               next
[17:47:31.628]                             invokeRestart(restart)
[17:47:31.628]                             muffled <- TRUE
[17:47:31.628]                             break
[17:47:31.628]                           }
[17:47:31.628]                         }
[17:47:31.628]                       }
[17:47:31.628]                       invisible(muffled)
[17:47:31.628]                     }
[17:47:31.628]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.628]                   }
[17:47:31.628]                 }
[17:47:31.628]                 else {
[17:47:31.628]                   if (TRUE) {
[17:47:31.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.628]                     {
[17:47:31.628]                       inherits <- base::inherits
[17:47:31.628]                       invokeRestart <- base::invokeRestart
[17:47:31.628]                       is.null <- base::is.null
[17:47:31.628]                       muffled <- FALSE
[17:47:31.628]                       if (inherits(cond, "message")) {
[17:47:31.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.628]                         if (muffled) 
[17:47:31.628]                           invokeRestart("muffleMessage")
[17:47:31.628]                       }
[17:47:31.628]                       else if (inherits(cond, "warning")) {
[17:47:31.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.628]                         if (muffled) 
[17:47:31.628]                           invokeRestart("muffleWarning")
[17:47:31.628]                       }
[17:47:31.628]                       else if (inherits(cond, "condition")) {
[17:47:31.628]                         if (!is.null(pattern)) {
[17:47:31.628]                           computeRestarts <- base::computeRestarts
[17:47:31.628]                           grepl <- base::grepl
[17:47:31.628]                           restarts <- computeRestarts(cond)
[17:47:31.628]                           for (restart in restarts) {
[17:47:31.628]                             name <- restart$name
[17:47:31.628]                             if (is.null(name)) 
[17:47:31.628]                               next
[17:47:31.628]                             if (!grepl(pattern, name)) 
[17:47:31.628]                               next
[17:47:31.628]                             invokeRestart(restart)
[17:47:31.628]                             muffled <- TRUE
[17:47:31.628]                             break
[17:47:31.628]                           }
[17:47:31.628]                         }
[17:47:31.628]                       }
[17:47:31.628]                       invisible(muffled)
[17:47:31.628]                     }
[17:47:31.628]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.628]                   }
[17:47:31.628]                 }
[17:47:31.628]             }
[17:47:31.628]         }))
[17:47:31.628]     }, error = function(ex) {
[17:47:31.628]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.628]                 ...future.rng), started = ...future.startTime, 
[17:47:31.628]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.628]             version = "1.8"), class = "FutureResult")
[17:47:31.628]     }, finally = {
[17:47:31.628]         if (!identical(...future.workdir, getwd())) 
[17:47:31.628]             setwd(...future.workdir)
[17:47:31.628]         {
[17:47:31.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.628]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.628]             }
[17:47:31.628]             base::options(...future.oldOptions)
[17:47:31.628]             if (.Platform$OS.type == "windows") {
[17:47:31.628]                 old_names <- names(...future.oldEnvVars)
[17:47:31.628]                 envs <- base::Sys.getenv()
[17:47:31.628]                 names <- names(envs)
[17:47:31.628]                 common <- intersect(names, old_names)
[17:47:31.628]                 added <- setdiff(names, old_names)
[17:47:31.628]                 removed <- setdiff(old_names, names)
[17:47:31.628]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.628]                   envs[common]]
[17:47:31.628]                 NAMES <- toupper(changed)
[17:47:31.628]                 args <- list()
[17:47:31.628]                 for (kk in seq_along(NAMES)) {
[17:47:31.628]                   name <- changed[[kk]]
[17:47:31.628]                   NAME <- NAMES[[kk]]
[17:47:31.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.628]                     next
[17:47:31.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.628]                 }
[17:47:31.628]                 NAMES <- toupper(added)
[17:47:31.628]                 for (kk in seq_along(NAMES)) {
[17:47:31.628]                   name <- added[[kk]]
[17:47:31.628]                   NAME <- NAMES[[kk]]
[17:47:31.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.628]                     next
[17:47:31.628]                   args[[name]] <- ""
[17:47:31.628]                 }
[17:47:31.628]                 NAMES <- toupper(removed)
[17:47:31.628]                 for (kk in seq_along(NAMES)) {
[17:47:31.628]                   name <- removed[[kk]]
[17:47:31.628]                   NAME <- NAMES[[kk]]
[17:47:31.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.628]                     next
[17:47:31.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.628]                 }
[17:47:31.628]                 if (length(args) > 0) 
[17:47:31.628]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.628]             }
[17:47:31.628]             else {
[17:47:31.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.628]             }
[17:47:31.628]             {
[17:47:31.628]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.628]                   0L) {
[17:47:31.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.628]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.628]                   base::options(opts)
[17:47:31.628]                 }
[17:47:31.628]                 {
[17:47:31.628]                   {
[17:47:31.628]                     NULL
[17:47:31.628]                     RNGkind("Mersenne-Twister")
[17:47:31.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:31.628]                       inherits = FALSE)
[17:47:31.628]                   }
[17:47:31.628]                   options(future.plan = NULL)
[17:47:31.628]                   if (is.na(NA_character_)) 
[17:47:31.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.628]                     .init = FALSE)
[17:47:31.628]                 }
[17:47:31.628]             }
[17:47:31.628]         }
[17:47:31.628]     })
[17:47:31.628]     if (TRUE) {
[17:47:31.628]         base::sink(type = "output", split = FALSE)
[17:47:31.628]         if (TRUE) {
[17:47:31.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.628]         }
[17:47:31.628]         else {
[17:47:31.628]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.628]         }
[17:47:31.628]         base::close(...future.stdout)
[17:47:31.628]         ...future.stdout <- NULL
[17:47:31.628]     }
[17:47:31.628]     ...future.result$conditions <- ...future.conditions
[17:47:31.628]     ...future.result$finished <- base::Sys.time()
[17:47:31.628]     ...future.result
[17:47:31.628] }
[17:47:31.659]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.631] assign_globals() ...
[17:47:31.659]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.631] List of 3
[17:47:31.631]  $ nested_a:List of 1
[17:47:31.631]   ..$ b:function (..., envir = parent.frame())  
[17:47:31.631]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:31.631]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.631]  $ a       : int 1
[17:47:31.631]  $ plan_a  :List of 1
[17:47:31.631]   ..$ b:function (..., envir = parent.frame())  
[17:47:31.631]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:47:31.631]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.631]  - attr(*, "where")=List of 3
[17:47:31.631]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:47:31.631]   ..$ a       :<environment: R_EmptyEnv> 
[17:47:31.631]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:47:31.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.631]  - attr(*, "resolved")= logi FALSE
[17:47:31.631]  - attr(*, "total_size")= num 23080
[17:47:31.631]  - attr(*, "already-done")= logi TRUE
[17:47:31.659]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.638] - copied ‘nested_a’ to environment
[17:47:31.659]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.638] - copied ‘a’ to environment
[17:47:31.659]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.638] - copied ‘plan_a’ to environment
[17:47:31.660]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.638] assign_globals() ... done
[17:47:31.660]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.639] plan(): Setting new future strategy stack:
[17:47:31.660]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.639] List of future strategies:
[17:47:31.639] 1. sequential:
[17:47:31.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.639]    - tweaked: FALSE
[17:47:31.639]    - call: NULL
[17:47:31.660]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.640] plan(): nbrOfWorkers() = 1
[17:47:31.660]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.641] plan(): Setting new future strategy stack:
[17:47:31.660]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.641] List of future strategies:
[17:47:31.641] 1. sequential:
[17:47:31.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.641]    - tweaked: FALSE
[17:47:31.641]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.661]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.642] plan(): nbrOfWorkers() = 1
[17:47:31.661]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.642] SequentialFuture started (and completed)
[17:47:31.661]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.642] - Launch lazy future ... done
[17:47:31.661]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.642] run() for ‘SequentialFuture’ ... done
[17:47:31.661] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:31.668] getGlobalsAndPackages() ...
[17:47:31.668] Searching for globals...
[17:47:31.669] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:31.669] Searching for globals ... DONE
[17:47:31.670] Resolving globals: FALSE
[17:47:31.670] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:31.671] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:31.671] - globals: [1] ‘data’
[17:47:31.671] - packages: [1] ‘future’
[17:47:31.671] getGlobalsAndPackages() ... DONE
[17:47:31.672] run() for ‘Future’ ...
[17:47:31.672] - state: ‘created’
[17:47:31.672] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.676] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:31.676]   - Field: ‘label’
[17:47:31.676]   - Field: ‘local’
[17:47:31.676]   - Field: ‘owner’
[17:47:31.676]   - Field: ‘envir’
[17:47:31.676]   - Field: ‘workers’
[17:47:31.677]   - Field: ‘packages’
[17:47:31.677]   - Field: ‘gc’
[17:47:31.677]   - Field: ‘job’
[17:47:31.677]   - Field: ‘conditions’
[17:47:31.677]   - Field: ‘expr’
[17:47:31.677]   - Field: ‘uuid’
[17:47:31.677]   - Field: ‘seed’
[17:47:31.677]   - Field: ‘version’
[17:47:31.677]   - Field: ‘result’
[17:47:31.677]   - Field: ‘asynchronous’
[17:47:31.678]   - Field: ‘calls’
[17:47:31.678]   - Field: ‘globals’
[17:47:31.678]   - Field: ‘stdout’
[17:47:31.678]   - Field: ‘earlySignal’
[17:47:31.678]   - Field: ‘lazy’
[17:47:31.678]   - Field: ‘state’
[17:47:31.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:31.678] - Launch lazy future ...
[17:47:31.679] Packages needed by the future expression (n = 1): ‘future’
[17:47:31.679] Packages needed by future strategies (n = 1): ‘future’
[17:47:31.679] {
[17:47:31.679]     {
[17:47:31.679]         {
[17:47:31.679]             ...future.startTime <- base::Sys.time()
[17:47:31.679]             {
[17:47:31.679]                 {
[17:47:31.679]                   {
[17:47:31.679]                     {
[17:47:31.679]                       {
[17:47:31.679]                         base::local({
[17:47:31.679]                           has_future <- base::requireNamespace("future", 
[17:47:31.679]                             quietly = TRUE)
[17:47:31.679]                           if (has_future) {
[17:47:31.679]                             ns <- base::getNamespace("future")
[17:47:31.679]                             version <- ns[[".package"]][["version"]]
[17:47:31.679]                             if (is.null(version)) 
[17:47:31.679]                               version <- utils::packageVersion("future")
[17:47:31.679]                           }
[17:47:31.679]                           else {
[17:47:31.679]                             version <- NULL
[17:47:31.679]                           }
[17:47:31.679]                           if (!has_future || version < "1.8.0") {
[17:47:31.679]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.679]                               "", base::R.version$version.string), 
[17:47:31.679]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:31.679]                                 base::R.version$platform, 8 * 
[17:47:31.679]                                   base::.Machine$sizeof.pointer), 
[17:47:31.679]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.679]                                 "release", "version")], collapse = " "), 
[17:47:31.679]                               hostname = base::Sys.info()[["nodename"]])
[17:47:31.679]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.679]                               info)
[17:47:31.679]                             info <- base::paste(info, collapse = "; ")
[17:47:31.679]                             if (!has_future) {
[17:47:31.679]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.679]                                 info)
[17:47:31.679]                             }
[17:47:31.679]                             else {
[17:47:31.679]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.679]                                 info, version)
[17:47:31.679]                             }
[17:47:31.679]                             base::stop(msg)
[17:47:31.679]                           }
[17:47:31.679]                         })
[17:47:31.679]                       }
[17:47:31.679]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.679]                       base::options(mc.cores = 1L)
[17:47:31.679]                     }
[17:47:31.679]                     base::local({
[17:47:31.679]                       for (pkg in "future") {
[17:47:31.679]                         base::loadNamespace(pkg)
[17:47:31.679]                         base::library(pkg, character.only = TRUE)
[17:47:31.679]                       }
[17:47:31.679]                     })
[17:47:31.679]                   }
[17:47:31.679]                   ...future.strategy.old <- future::plan("list")
[17:47:31.679]                   options(future.plan = NULL)
[17:47:31.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.679]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:31.679]                   {
[17:47:31.679]                     future <- SequentialFuture(..., envir = envir)
[17:47:31.679]                     if (!future$lazy) 
[17:47:31.679]                       future <- run(future)
[17:47:31.679]                     invisible(future)
[17:47:31.679]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:31.679]                 }
[17:47:31.679]                 ...future.workdir <- getwd()
[17:47:31.679]             }
[17:47:31.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.679]         }
[17:47:31.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.679]             base::names(...future.oldOptions))
[17:47:31.679]     }
[17:47:31.679]     if (FALSE) {
[17:47:31.679]     }
[17:47:31.679]     else {
[17:47:31.679]         if (TRUE) {
[17:47:31.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.679]                 open = "w")
[17:47:31.679]         }
[17:47:31.679]         else {
[17:47:31.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.679]         }
[17:47:31.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.679]             base::sink(type = "output", split = FALSE)
[17:47:31.679]             base::close(...future.stdout)
[17:47:31.679]         }, add = TRUE)
[17:47:31.679]     }
[17:47:31.679]     ...future.frame <- base::sys.nframe()
[17:47:31.679]     ...future.conditions <- base::list()
[17:47:31.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.679]     if (FALSE) {
[17:47:31.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.679]     }
[17:47:31.679]     ...future.result <- base::tryCatch({
[17:47:31.679]         base::withCallingHandlers({
[17:47:31.679]             ...future.value <- base::withVisible(base::local({
[17:47:31.679]                 withCallingHandlers({
[17:47:31.679]                   {
[17:47:31.679]                     value(future(subset(data, a == 2)))
[17:47:31.679]                   }
[17:47:31.679]                 }, immediateCondition = function(cond) {
[17:47:31.679]                   save_rds <- function (object, pathname, ...) 
[17:47:31.679]                   {
[17:47:31.679]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:31.679]                     if (file_test("-f", pathname_tmp)) {
[17:47:31.679]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.679]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:31.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.679]                         fi_tmp[["mtime"]])
[17:47:31.679]                     }
[17:47:31.679]                     tryCatch({
[17:47:31.679]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:31.679]                     }, error = function(ex) {
[17:47:31.679]                       msg <- conditionMessage(ex)
[17:47:31.679]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.679]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:31.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.679]                         fi_tmp[["mtime"]], msg)
[17:47:31.679]                       ex$message <- msg
[17:47:31.679]                       stop(ex)
[17:47:31.679]                     })
[17:47:31.679]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:31.679]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:31.679]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:31.679]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.679]                       fi <- file.info(pathname)
[17:47:31.679]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:31.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.679]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:31.679]                         fi[["size"]], fi[["mtime"]])
[17:47:31.679]                       stop(msg)
[17:47:31.679]                     }
[17:47:31.679]                     invisible(pathname)
[17:47:31.679]                   }
[17:47:31.679]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:31.679]                     rootPath = tempdir()) 
[17:47:31.679]                   {
[17:47:31.679]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:31.679]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:31.679]                       tmpdir = path, fileext = ".rds")
[17:47:31.679]                     save_rds(obj, file)
[17:47:31.679]                   }
[17:47:31.679]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:31.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.679]                   {
[17:47:31.679]                     inherits <- base::inherits
[17:47:31.679]                     invokeRestart <- base::invokeRestart
[17:47:31.679]                     is.null <- base::is.null
[17:47:31.679]                     muffled <- FALSE
[17:47:31.679]                     if (inherits(cond, "message")) {
[17:47:31.679]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.679]                       if (muffled) 
[17:47:31.679]                         invokeRestart("muffleMessage")
[17:47:31.679]                     }
[17:47:31.679]                     else if (inherits(cond, "warning")) {
[17:47:31.679]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.679]                       if (muffled) 
[17:47:31.679]                         invokeRestart("muffleWarning")
[17:47:31.679]                     }
[17:47:31.679]                     else if (inherits(cond, "condition")) {
[17:47:31.679]                       if (!is.null(pattern)) {
[17:47:31.679]                         computeRestarts <- base::computeRestarts
[17:47:31.679]                         grepl <- base::grepl
[17:47:31.679]                         restarts <- computeRestarts(cond)
[17:47:31.679]                         for (restart in restarts) {
[17:47:31.679]                           name <- restart$name
[17:47:31.679]                           if (is.null(name)) 
[17:47:31.679]                             next
[17:47:31.679]                           if (!grepl(pattern, name)) 
[17:47:31.679]                             next
[17:47:31.679]                           invokeRestart(restart)
[17:47:31.679]                           muffled <- TRUE
[17:47:31.679]                           break
[17:47:31.679]                         }
[17:47:31.679]                       }
[17:47:31.679]                     }
[17:47:31.679]                     invisible(muffled)
[17:47:31.679]                   }
[17:47:31.679]                   muffleCondition(cond)
[17:47:31.679]                 })
[17:47:31.679]             }))
[17:47:31.679]             future::FutureResult(value = ...future.value$value, 
[17:47:31.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.679]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.679]                     ...future.globalenv.names))
[17:47:31.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.679]         }, condition = base::local({
[17:47:31.679]             c <- base::c
[17:47:31.679]             inherits <- base::inherits
[17:47:31.679]             invokeRestart <- base::invokeRestart
[17:47:31.679]             length <- base::length
[17:47:31.679]             list <- base::list
[17:47:31.679]             seq.int <- base::seq.int
[17:47:31.679]             signalCondition <- base::signalCondition
[17:47:31.679]             sys.calls <- base::sys.calls
[17:47:31.679]             `[[` <- base::`[[`
[17:47:31.679]             `+` <- base::`+`
[17:47:31.679]             `<<-` <- base::`<<-`
[17:47:31.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.679]                   3L)]
[17:47:31.679]             }
[17:47:31.679]             function(cond) {
[17:47:31.679]                 is_error <- inherits(cond, "error")
[17:47:31.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.679]                   NULL)
[17:47:31.679]                 if (is_error) {
[17:47:31.679]                   sessionInformation <- function() {
[17:47:31.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.679]                       search = base::search(), system = base::Sys.info())
[17:47:31.679]                   }
[17:47:31.679]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.679]                     cond$call), session = sessionInformation(), 
[17:47:31.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.679]                   signalCondition(cond)
[17:47:31.679]                 }
[17:47:31.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.679]                 "immediateCondition"))) {
[17:47:31.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.679]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.679]                   if (TRUE && !signal) {
[17:47:31.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.679]                     {
[17:47:31.679]                       inherits <- base::inherits
[17:47:31.679]                       invokeRestart <- base::invokeRestart
[17:47:31.679]                       is.null <- base::is.null
[17:47:31.679]                       muffled <- FALSE
[17:47:31.679]                       if (inherits(cond, "message")) {
[17:47:31.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.679]                         if (muffled) 
[17:47:31.679]                           invokeRestart("muffleMessage")
[17:47:31.679]                       }
[17:47:31.679]                       else if (inherits(cond, "warning")) {
[17:47:31.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.679]                         if (muffled) 
[17:47:31.679]                           invokeRestart("muffleWarning")
[17:47:31.679]                       }
[17:47:31.679]                       else if (inherits(cond, "condition")) {
[17:47:31.679]                         if (!is.null(pattern)) {
[17:47:31.679]                           computeRestarts <- base::computeRestarts
[17:47:31.679]                           grepl <- base::grepl
[17:47:31.679]                           restarts <- computeRestarts(cond)
[17:47:31.679]                           for (restart in restarts) {
[17:47:31.679]                             name <- restart$name
[17:47:31.679]                             if (is.null(name)) 
[17:47:31.679]                               next
[17:47:31.679]                             if (!grepl(pattern, name)) 
[17:47:31.679]                               next
[17:47:31.679]                             invokeRestart(restart)
[17:47:31.679]                             muffled <- TRUE
[17:47:31.679]                             break
[17:47:31.679]                           }
[17:47:31.679]                         }
[17:47:31.679]                       }
[17:47:31.679]                       invisible(muffled)
[17:47:31.679]                     }
[17:47:31.679]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.679]                   }
[17:47:31.679]                 }
[17:47:31.679]                 else {
[17:47:31.679]                   if (TRUE) {
[17:47:31.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.679]                     {
[17:47:31.679]                       inherits <- base::inherits
[17:47:31.679]                       invokeRestart <- base::invokeRestart
[17:47:31.679]                       is.null <- base::is.null
[17:47:31.679]                       muffled <- FALSE
[17:47:31.679]                       if (inherits(cond, "message")) {
[17:47:31.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.679]                         if (muffled) 
[17:47:31.679]                           invokeRestart("muffleMessage")
[17:47:31.679]                       }
[17:47:31.679]                       else if (inherits(cond, "warning")) {
[17:47:31.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.679]                         if (muffled) 
[17:47:31.679]                           invokeRestart("muffleWarning")
[17:47:31.679]                       }
[17:47:31.679]                       else if (inherits(cond, "condition")) {
[17:47:31.679]                         if (!is.null(pattern)) {
[17:47:31.679]                           computeRestarts <- base::computeRestarts
[17:47:31.679]                           grepl <- base::grepl
[17:47:31.679]                           restarts <- computeRestarts(cond)
[17:47:31.679]                           for (restart in restarts) {
[17:47:31.679]                             name <- restart$name
[17:47:31.679]                             if (is.null(name)) 
[17:47:31.679]                               next
[17:47:31.679]                             if (!grepl(pattern, name)) 
[17:47:31.679]                               next
[17:47:31.679]                             invokeRestart(restart)
[17:47:31.679]                             muffled <- TRUE
[17:47:31.679]                             break
[17:47:31.679]                           }
[17:47:31.679]                         }
[17:47:31.679]                       }
[17:47:31.679]                       invisible(muffled)
[17:47:31.679]                     }
[17:47:31.679]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.679]                   }
[17:47:31.679]                 }
[17:47:31.679]             }
[17:47:31.679]         }))
[17:47:31.679]     }, error = function(ex) {
[17:47:31.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.679]                 ...future.rng), started = ...future.startTime, 
[17:47:31.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.679]             version = "1.8"), class = "FutureResult")
[17:47:31.679]     }, finally = {
[17:47:31.679]         if (!identical(...future.workdir, getwd())) 
[17:47:31.679]             setwd(...future.workdir)
[17:47:31.679]         {
[17:47:31.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.679]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.679]             }
[17:47:31.679]             base::options(...future.oldOptions)
[17:47:31.679]             if (.Platform$OS.type == "windows") {
[17:47:31.679]                 old_names <- names(...future.oldEnvVars)
[17:47:31.679]                 envs <- base::Sys.getenv()
[17:47:31.679]                 names <- names(envs)
[17:47:31.679]                 common <- intersect(names, old_names)
[17:47:31.679]                 added <- setdiff(names, old_names)
[17:47:31.679]                 removed <- setdiff(old_names, names)
[17:47:31.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.679]                   envs[common]]
[17:47:31.679]                 NAMES <- toupper(changed)
[17:47:31.679]                 args <- list()
[17:47:31.679]                 for (kk in seq_along(NAMES)) {
[17:47:31.679]                   name <- changed[[kk]]
[17:47:31.679]                   NAME <- NAMES[[kk]]
[17:47:31.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.679]                     next
[17:47:31.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.679]                 }
[17:47:31.679]                 NAMES <- toupper(added)
[17:47:31.679]                 for (kk in seq_along(NAMES)) {
[17:47:31.679]                   name <- added[[kk]]
[17:47:31.679]                   NAME <- NAMES[[kk]]
[17:47:31.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.679]                     next
[17:47:31.679]                   args[[name]] <- ""
[17:47:31.679]                 }
[17:47:31.679]                 NAMES <- toupper(removed)
[17:47:31.679]                 for (kk in seq_along(NAMES)) {
[17:47:31.679]                   name <- removed[[kk]]
[17:47:31.679]                   NAME <- NAMES[[kk]]
[17:47:31.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.679]                     next
[17:47:31.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.679]                 }
[17:47:31.679]                 if (length(args) > 0) 
[17:47:31.679]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.679]             }
[17:47:31.679]             else {
[17:47:31.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.679]             }
[17:47:31.679]             {
[17:47:31.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.679]                   0L) {
[17:47:31.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.679]                   base::options(opts)
[17:47:31.679]                 }
[17:47:31.679]                 {
[17:47:31.679]                   {
[17:47:31.679]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.679]                     NULL
[17:47:31.679]                   }
[17:47:31.679]                   options(future.plan = NULL)
[17:47:31.679]                   if (is.na(NA_character_)) 
[17:47:31.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.679]                     .init = FALSE)
[17:47:31.679]                 }
[17:47:31.679]             }
[17:47:31.679]         }
[17:47:31.679]     })
[17:47:31.679]     if (TRUE) {
[17:47:31.679]         base::sink(type = "output", split = FALSE)
[17:47:31.679]         if (TRUE) {
[17:47:31.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.679]         }
[17:47:31.679]         else {
[17:47:31.679]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.679]         }
[17:47:31.679]         base::close(...future.stdout)
[17:47:31.679]         ...future.stdout <- NULL
[17:47:31.679]     }
[17:47:31.679]     ...future.result$conditions <- ...future.conditions
[17:47:31.679]     ...future.result$finished <- base::Sys.time()
[17:47:31.679]     ...future.result
[17:47:31.679] }
[17:47:31.682] assign_globals() ...
[17:47:31.682] List of 1
[17:47:31.682]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:31.682]   ..$ a: int [1:3] 1 2 3
[17:47:31.682]   ..$ b: int [1:3] 3 2 1
[17:47:31.682]  - attr(*, "where")=List of 1
[17:47:31.682]   ..$ data:<environment: R_EmptyEnv> 
[17:47:31.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.682]  - attr(*, "resolved")= logi FALSE
[17:47:31.682]  - attr(*, "total_size")= num 128
[17:47:31.682]  - attr(*, "already-done")= logi TRUE
[17:47:31.686] - copied ‘data’ to environment
[17:47:31.686] assign_globals() ... done
[17:47:31.686] requestCore(): workers = 2
[17:47:31.688] MulticoreFuture started
[17:47:31.689] - Launch lazy future ... done
[17:47:31.689] run() for ‘MulticoreFuture’ ... done
[17:47:31.689] result() for MulticoreFuture ...
[17:47:31.690] plan(): Setting new future strategy stack:
[17:47:31.690] List of future strategies:
[17:47:31.690] 1. sequential:
[17:47:31.690]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.690]    - tweaked: FALSE
[17:47:31.690]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.691] plan(): nbrOfWorkers() = 1
[17:47:31.715] plan(): Setting new future strategy stack:
[17:47:31.715] List of future strategies:
[17:47:31.715] 1. multicore:
[17:47:31.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.715]    - tweaked: FALSE
[17:47:31.715]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.715] 2. sequential:
[17:47:31.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.715]    - tweaked: FALSE
[17:47:31.715]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.720] plan(): nbrOfWorkers() = 2
[17:47:31.721] result() for MulticoreFuture ...
[17:47:31.721] result() for MulticoreFuture ... done
[17:47:31.722] signalConditions() ...
[17:47:31.722]  - include = ‘immediateCondition’
[17:47:31.722]  - exclude = 
[17:47:31.722]  - resignal = FALSE
[17:47:31.722]  - Number of conditions: 52
[17:47:31.722] signalConditions() ... done
[17:47:31.722] result() for MulticoreFuture ... done
[17:47:31.722] result() for MulticoreFuture ...
[17:47:31.722] result() for MulticoreFuture ... done
[17:47:31.723] signalConditions() ...
[17:47:31.723]  - include = ‘immediateCondition’
[17:47:31.723]  - exclude = 
[17:47:31.723]  - resignal = FALSE
[17:47:31.723]  - Number of conditions: 52
[17:47:31.723] signalConditions() ... done
[17:47:31.723] Future state: ‘finished’
[17:47:31.724] result() for MulticoreFuture ...
[17:47:31.724] result() for MulticoreFuture ... done
[17:47:31.724] signalConditions() ...
[17:47:31.724]  - include = ‘condition’
[17:47:31.724]  - exclude = ‘immediateCondition’
[17:47:31.724]  - resignal = TRUE
[17:47:31.724]  - Number of conditions: 52
[17:47:31.724]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.692] getGlobalsAndPackages() ...
[17:47:31.724]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.692] Searching for globals...
[17:47:31.725]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.694] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:31.725]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.694] Searching for globals ... DONE
[17:47:31.725]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.695] Resolving globals: FALSE
[17:47:31.725]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.696] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:31.725]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.696] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:31.725]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.697] - globals: [1] ‘data’
[17:47:31.726]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.697] 
[17:47:31.726]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.697] getGlobalsAndPackages() ... DONE
[17:47:31.726]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.698] run() for ‘Future’ ...
[17:47:31.726]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.698] - state: ‘created’
[17:47:31.726]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:31.726]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.699] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:31.726]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:31.727]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.699]   - Field: ‘label’
[17:47:31.727]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.699]   - Field: ‘local’
[17:47:31.727]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.699]   - Field: ‘owner’
[17:47:31.727]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.700]   - Field: ‘envir’
[17:47:31.727]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.700]   - Field: ‘packages’
[17:47:31.727]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.700]   - Field: ‘gc’
[17:47:31.728]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.700]   - Field: ‘conditions’
[17:47:31.728]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.700]   - Field: ‘expr’
[17:47:31.728]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.700]   - Field: ‘uuid’
[17:47:31.728]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘seed’
[17:47:31.728]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘version’
[17:47:31.728]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘result’
[17:47:31.728]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘asynchronous’
[17:47:31.729]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘calls’
[17:47:31.729]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘globals’
[17:47:31.729]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.701]   - Field: ‘stdout’
[17:47:31.729]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.702]   - Field: ‘earlySignal’
[17:47:31.729]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.702]   - Field: ‘lazy’
[17:47:31.729]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.702]   - Field: ‘state’
[17:47:31.729]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:31.730]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.702] - Launch lazy future ...
[17:47:31.730]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.703] Packages needed by the future expression (n = 0): <none>
[17:47:31.730]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.703] Packages needed by future strategies (n = 0): <none>
[17:47:31.730]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.703] {
[17:47:31.703]     {
[17:47:31.703]         {
[17:47:31.703]             ...future.startTime <- base::Sys.time()
[17:47:31.703]             {
[17:47:31.703]                 {
[17:47:31.703]                   {
[17:47:31.703]                     base::local({
[17:47:31.703]                       has_future <- base::requireNamespace("future", 
[17:47:31.703]                         quietly = TRUE)
[17:47:31.703]                       if (has_future) {
[17:47:31.703]                         ns <- base::getNamespace("future")
[17:47:31.703]                         version <- ns[[".package"]][["version"]]
[17:47:31.703]                         if (is.null(version)) 
[17:47:31.703]                           version <- utils::packageVersion("future")
[17:47:31.703]                       }
[17:47:31.703]                       else {
[17:47:31.703]                         version <- NULL
[17:47:31.703]                       }
[17:47:31.703]                       if (!has_future || version < "1.8.0") {
[17:47:31.703]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.703]                           "", base::R.version$version.string), 
[17:47:31.703]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:31.703]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.703]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.703]                             "release", "version")], collapse = " "), 
[17:47:31.703]                           hostname = base::Sys.info()[["nodename"]])
[17:47:31.703]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.703]                           info)
[17:47:31.703]                         info <- base::paste(info, collapse = "; ")
[17:47:31.703]                         if (!has_future) {
[17:47:31.703]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.703]                             info)
[17:47:31.703]                         }
[17:47:31.703]                         else {
[17:47:31.703]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.703]                             info, version)
[17:47:31.703]                         }
[17:47:31.703]                         base::stop(msg)
[17:47:31.703]                       }
[17:47:31.703]                     })
[17:47:31.703]                   }
[17:47:31.703]                   ...future.strategy.old <- future::plan("list")
[17:47:31.703]                   options(future.plan = NULL)
[17:47:31.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:31.703]                 }
[17:47:31.703]                 ...future.workdir <- getwd()
[17:47:31.703]             }
[17:47:31.703]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.703]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.703]         }
[17:47:31.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.703]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.703]             base::names(...future.oldOptions))
[17:47:31.703]     }
[17:47:31.703]     if (FALSE) {
[17:47:31.703]     }
[17:47:31.703]     else {
[17:47:31.703]         if (TRUE) {
[17:47:31.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.703]                 open = "w")
[17:47:31.703]         }
[17:47:31.703]         else {
[17:47:31.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.703]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.703]         }
[17:47:31.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.703]             base::sink(type = "output", split = FALSE)
[17:47:31.703]             base::close(...future.stdout)
[17:47:31.703]         }, add = TRUE)
[17:47:31.703]     }
[17:47:31.703]     ...future.frame <- base::sys.nframe()
[17:47:31.703]     ...future.conditions <- base::list()
[17:47:31.703]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.703]     if (FALSE) {
[17:47:31.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.703]     }
[17:47:31.703]     ...future.result <- base::tryCatch({
[17:47:31.703]         base::withCallingHandlers({
[17:47:31.703]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:47:31.703]                 a == 2)))
[17:47:31.703]             future::FutureResult(value = ...future.value$value, 
[17:47:31.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.703]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.703]                     ...future.globalenv.names))
[17:47:31.703]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.703]         }, condition = base::local({
[17:47:31.703]             c <- base::c
[17:47:31.703]             inherits <- base::inherits
[17:47:31.703]             invokeRestart <- base::invokeRestart
[17:47:31.703]             length <- base::length
[17:47:31.703]             list <- base::list
[17:47:31.703]             seq.int <- base::seq.int
[17:47:31.703]             signalCondition <- base::signalCondition
[17:47:31.703]             sys.calls <- base::sys.calls
[17:47:31.703]             `[[` <- base::`[[`
[17:47:31.703]             `+` <- base::`+`
[17:47:31.703]             `<<-` <- base::`<<-`
[17:47:31.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.703]                   3L)]
[17:47:31.703]             }
[17:47:31.703]             function(cond) {
[17:47:31.703]                 is_error <- inherits(cond, "error")
[17:47:31.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.703]                   NULL)
[17:47:31.703]                 if (is_error) {
[17:47:31.703]                   sessionInformation <- function() {
[17:47:31.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.703]                       search = base::search(), system = base::Sys.info())
[17:47:31.703]                   }
[17:47:31.703]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.703]                     cond$call), session = sessionInformation(), 
[17:47:31.703]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.703]                   signalCondition(cond)
[17:47:31.703]                 }
[17:47:31.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.703]                 "immediateCondition"))) {
[17:47:31.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.703]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.703]                   if (TRUE && !signal) {
[17:47:31.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.703]                     {
[17:47:31.703]                       inherits <- base::inherits
[17:47:31.703]                       invokeRestart <- base::invokeRestart
[17:47:31.703]                       is.null <- base::is.null
[17:47:31.703]                       muffled <- FALSE
[17:47:31.703]                       if (inherits(cond, "message")) {
[17:47:31.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.703]                         if (muffled) 
[17:47:31.703]                           invokeRestart("muffleMessage")
[17:47:31.703]                       }
[17:47:31.703]                       else if (inherits(cond, "warning")) {
[17:47:31.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.703]                         if (muffled) 
[17:47:31.703]                           invokeRestart("muffleWarning")
[17:47:31.703]                       }
[17:47:31.703]                       else if (inherits(cond, "condition")) {
[17:47:31.703]                         if (!is.null(pattern)) {
[17:47:31.703]                           computeRestarts <- base::computeRestarts
[17:47:31.703]                           grepl <- base::grepl
[17:47:31.703]                           restarts <- computeRestarts(cond)
[17:47:31.703]                           for (restart in restarts) {
[17:47:31.703]                             name <- restart$name
[17:47:31.703]                             if (is.null(name)) 
[17:47:31.703]                               next
[17:47:31.703]                             if (!grepl(pattern, name)) 
[17:47:31.703]                               next
[17:47:31.703]                             invokeRestart(restart)
[17:47:31.703]                             muffled <- TRUE
[17:47:31.703]                             break
[17:47:31.703]                           }
[17:47:31.703]                         }
[17:47:31.703]                       }
[17:47:31.703]                       invisible(muffled)
[17:47:31.703]                     }
[17:47:31.703]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.703]                   }
[17:47:31.703]                 }
[17:47:31.703]                 else {
[17:47:31.703]                   if (TRUE) {
[17:47:31.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.703]                     {
[17:47:31.703]                       inherits <- base::inherits
[17:47:31.703]                       invokeRestart <- base::invokeRestart
[17:47:31.703]                       is.null <- base::is.null
[17:47:31.703]                       muffled <- FALSE
[17:47:31.703]                       if (inherits(cond, "message")) {
[17:47:31.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.703]                         if (muffled) 
[17:47:31.703]                           invokeRestart("muffleMessage")
[17:47:31.703]                       }
[17:47:31.703]                       else if (inherits(cond, "warning")) {
[17:47:31.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.703]                         if (muffled) 
[17:47:31.703]                           invokeRestart("muffleWarning")
[17:47:31.703]                       }
[17:47:31.703]                       else if (inherits(cond, "condition")) {
[17:47:31.703]                         if (!is.null(pattern)) {
[17:47:31.703]                           computeRestarts <- base::computeRestarts
[17:47:31.703]                           grepl <- base::grepl
[17:47:31.703]                           restarts <- computeRestarts(cond)
[17:47:31.703]                           for (restart in restarts) {
[17:47:31.703]                             name <- restart$name
[17:47:31.703]                             if (is.null(name)) 
[17:47:31.703]                               next
[17:47:31.703]                             if (!grepl(pattern, name)) 
[17:47:31.703]                               next
[17:47:31.703]                             invokeRestart(restart)
[17:47:31.703]                             muffled <- TRUE
[17:47:31.703]                             break
[17:47:31.703]                           }
[17:47:31.703]                         }
[17:47:31.703]                       }
[17:47:31.703]                       invisible(muffled)
[17:47:31.703]                     }
[17:47:31.703]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.703]                   }
[17:47:31.703]                 }
[17:47:31.703]             }
[17:47:31.703]         }))
[17:47:31.703]     }, error = function(ex) {
[17:47:31.703]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.703]                 ...future.rng), started = ...future.startTime, 
[17:47:31.703]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.703]             version = "1.8"), class = "FutureResult")
[17:47:31.703]     }, finally = {
[17:47:31.703]         if (!identical(...future.workdir, getwd())) 
[17:47:31.703]             setwd(...future.workdir)
[17:47:31.703]         {
[17:47:31.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.703]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.703]             }
[17:47:31.703]             base::options(...future.oldOptions)
[17:47:31.703]             if (.Platform$OS.type == "windows") {
[17:47:31.703]                 old_names <- names(...future.oldEnvVars)
[17:47:31.703]                 envs <- base::Sys.getenv()
[17:47:31.703]                 names <- names(envs)
[17:47:31.703]                 common <- intersect(names, old_names)
[17:47:31.703]                 added <- setdiff(names, old_names)
[17:47:31.703]                 removed <- setdiff(old_names, names)
[17:47:31.703]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.703]                   envs[common]]
[17:47:31.703]                 NAMES <- toupper(changed)
[17:47:31.703]                 args <- list()
[17:47:31.703]                 for (kk in seq_along(NAMES)) {
[17:47:31.703]                   name <- changed[[kk]]
[17:47:31.703]                   NAME <- NAMES[[kk]]
[17:47:31.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.703]                     next
[17:47:31.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.703]                 }
[17:47:31.703]                 NAMES <- toupper(added)
[17:47:31.703]                 for (kk in seq_along(NAMES)) {
[17:47:31.703]                   name <- added[[kk]]
[17:47:31.703]                   NAME <- NAMES[[kk]]
[17:47:31.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.703]                     next
[17:47:31.703]                   args[[name]] <- ""
[17:47:31.703]                 }
[17:47:31.703]                 NAMES <- toupper(removed)
[17:47:31.703]                 for (kk in seq_along(NAMES)) {
[17:47:31.703]                   name <- removed[[kk]]
[17:47:31.703]                   NAME <- NAMES[[kk]]
[17:47:31.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.703]                     next
[17:47:31.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.703]                 }
[17:47:31.703]                 if (length(args) > 0) 
[17:47:31.703]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.703]             }
[17:47:31.703]             else {
[17:47:31.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.703]             }
[17:47:31.703]             {
[17:47:31.703]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.703]                   0L) {
[17:47:31.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.703]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.703]                   base::options(opts)
[17:47:31.703]                 }
[17:47:31.703]                 {
[17:47:31.703]                   {
[17:47:31.703]                     NULL
[17:47:31.703]                     RNGkind("Mersenne-Twister")
[17:47:31.703]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:31.703]                       inherits = FALSE)
[17:47:31.703]                   }
[17:47:31.703]                   options(future.plan = NULL)
[17:47:31.703]                   if (is.na(NA_character_)) 
[17:47:31.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.703]                     .init = FALSE)
[17:47:31.703]                 }
[17:47:31.703]             }
[17:47:31.703]         }
[17:47:31.703]     })
[17:47:31.703]     if (TRUE) {
[17:47:31.703]         base::sink(type = "output", split = FALSE)
[17:47:31.703]         if (TRUE) {
[17:47:31.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.703]         }
[17:47:31.703]         else {
[17:47:31.703]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.703]         }
[17:47:31.703]         base::close(...future.stdout)
[17:47:31.703]         ...future.stdout <- NULL
[17:47:31.703]     }
[17:47:31.703]     ...future.result$conditions <- ...future.conditions
[17:47:31.703]     ...future.result$finished <- base::Sys.time()
[17:47:31.703]     ...future.result
[17:47:31.703] }
[17:47:31.730]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.706] assign_globals() ...
[17:47:31.730]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.706] List of 1
[17:47:31.706]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:31.706]   ..$ a: int [1:3] 1 2 3
[17:47:31.706]   ..$ b: int [1:3] 3 2 1
[17:47:31.706]  - attr(*, "where")=List of 1
[17:47:31.706]   ..$ data:<environment: R_EmptyEnv> 
[17:47:31.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.706]  - attr(*, "resolved")= logi FALSE
[17:47:31.706]  - attr(*, "total_size")= num 128
[17:47:31.706]  - attr(*, "already-done")= logi TRUE
[17:47:31.731]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.711] - copied ‘data’ to environment
[17:47:31.731]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.711] assign_globals() ... done
[17:47:31.731]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.711] plan(): Setting new future strategy stack:
[17:47:31.731]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.711] List of future strategies:
[17:47:31.711] 1. sequential:
[17:47:31.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.711]    - tweaked: FALSE
[17:47:31.711]    - call: NULL
[17:47:31.731]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.712] plan(): nbrOfWorkers() = 1
[17:47:31.731]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.713] plan(): Setting new future strategy stack:
[17:47:31.731]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.713] List of future strategies:
[17:47:31.713] 1. sequential:
[17:47:31.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.713]    - tweaked: FALSE
[17:47:31.713]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.732]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.714] plan(): nbrOfWorkers() = 1
[17:47:31.732]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.714] SequentialFuture started (and completed)
[17:47:31.732]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.714] - Launch lazy future ... done
[17:47:31.732]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.715] run() for ‘SequentialFuture’ ... done
[17:47:31.732] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[17:47:31.733] plan(): Setting new future strategy stack:
[17:47:31.733] List of future strategies:
[17:47:31.733] 1. multicore:
[17:47:31.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.733]    - tweaked: FALSE
[17:47:31.733]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.733] 2. multicore:
[17:47:31.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.733]    - tweaked: FALSE
[17:47:31.733]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.738] plan(): nbrOfWorkers() = 2
[17:47:31.738] getGlobalsAndPackages() ...
[17:47:31.738] Searching for globals...
[17:47:31.759] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:31.760] Searching for globals ... DONE
[17:47:31.760] Resolving globals: FALSE
[17:47:31.761] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[17:47:31.761] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:31.761] - globals: [2] ‘nested’, ‘strategy2’
[17:47:31.762] - packages: [1] ‘future’
[17:47:31.762] getGlobalsAndPackages() ... DONE
[17:47:31.762] run() for ‘Future’ ...
[17:47:31.762] - state: ‘created’
[17:47:31.762] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.766] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:31.766]   - Field: ‘label’
[17:47:31.766]   - Field: ‘local’
[17:47:31.766]   - Field: ‘owner’
[17:47:31.766]   - Field: ‘envir’
[17:47:31.767]   - Field: ‘workers’
[17:47:31.767]   - Field: ‘packages’
[17:47:31.767]   - Field: ‘gc’
[17:47:31.767]   - Field: ‘job’
[17:47:31.767]   - Field: ‘conditions’
[17:47:31.767]   - Field: ‘expr’
[17:47:31.767]   - Field: ‘uuid’
[17:47:31.767]   - Field: ‘seed’
[17:47:31.767]   - Field: ‘version’
[17:47:31.768]   - Field: ‘result’
[17:47:31.768]   - Field: ‘asynchronous’
[17:47:31.768]   - Field: ‘calls’
[17:47:31.768]   - Field: ‘globals’
[17:47:31.768]   - Field: ‘stdout’
[17:47:31.768]   - Field: ‘earlySignal’
[17:47:31.768]   - Field: ‘lazy’
[17:47:31.768]   - Field: ‘state’
[17:47:31.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:31.769] - Launch lazy future ...
[17:47:31.769] Packages needed by the future expression (n = 1): ‘future’
[17:47:31.769] Packages needed by future strategies (n = 1): ‘future’
[17:47:31.770] {
[17:47:31.770]     {
[17:47:31.770]         {
[17:47:31.770]             ...future.startTime <- base::Sys.time()
[17:47:31.770]             {
[17:47:31.770]                 {
[17:47:31.770]                   {
[17:47:31.770]                     {
[17:47:31.770]                       {
[17:47:31.770]                         base::local({
[17:47:31.770]                           has_future <- base::requireNamespace("future", 
[17:47:31.770]                             quietly = TRUE)
[17:47:31.770]                           if (has_future) {
[17:47:31.770]                             ns <- base::getNamespace("future")
[17:47:31.770]                             version <- ns[[".package"]][["version"]]
[17:47:31.770]                             if (is.null(version)) 
[17:47:31.770]                               version <- utils::packageVersion("future")
[17:47:31.770]                           }
[17:47:31.770]                           else {
[17:47:31.770]                             version <- NULL
[17:47:31.770]                           }
[17:47:31.770]                           if (!has_future || version < "1.8.0") {
[17:47:31.770]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.770]                               "", base::R.version$version.string), 
[17:47:31.770]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:31.770]                                 base::R.version$platform, 8 * 
[17:47:31.770]                                   base::.Machine$sizeof.pointer), 
[17:47:31.770]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.770]                                 "release", "version")], collapse = " "), 
[17:47:31.770]                               hostname = base::Sys.info()[["nodename"]])
[17:47:31.770]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.770]                               info)
[17:47:31.770]                             info <- base::paste(info, collapse = "; ")
[17:47:31.770]                             if (!has_future) {
[17:47:31.770]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.770]                                 info)
[17:47:31.770]                             }
[17:47:31.770]                             else {
[17:47:31.770]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.770]                                 info, version)
[17:47:31.770]                             }
[17:47:31.770]                             base::stop(msg)
[17:47:31.770]                           }
[17:47:31.770]                         })
[17:47:31.770]                       }
[17:47:31.770]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.770]                       base::options(mc.cores = 1L)
[17:47:31.770]                     }
[17:47:31.770]                     base::local({
[17:47:31.770]                       for (pkg in "future") {
[17:47:31.770]                         base::loadNamespace(pkg)
[17:47:31.770]                         base::library(pkg, character.only = TRUE)
[17:47:31.770]                       }
[17:47:31.770]                     })
[17:47:31.770]                   }
[17:47:31.770]                   ...future.strategy.old <- future::plan("list")
[17:47:31.770]                   options(future.plan = NULL)
[17:47:31.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.770]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:31.770]                     envir = parent.frame()) 
[17:47:31.770]                   {
[17:47:31.770]                     default_workers <- missing(workers)
[17:47:31.770]                     if (is.function(workers)) 
[17:47:31.770]                       workers <- workers()
[17:47:31.770]                     workers <- structure(as.integer(workers), 
[17:47:31.770]                       class = class(workers))
[17:47:31.770]                     stop_if_not(is.finite(workers), workers >= 
[17:47:31.770]                       1L)
[17:47:31.770]                     if ((workers == 1L && !inherits(workers, 
[17:47:31.770]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:31.770]                       if (default_workers) 
[17:47:31.770]                         supportsMulticore(warn = TRUE)
[17:47:31.770]                       return(sequential(..., envir = envir))
[17:47:31.770]                     }
[17:47:31.770]                     oopts <- options(mc.cores = workers)
[17:47:31.770]                     on.exit(options(oopts))
[17:47:31.770]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:31.770]                       envir = envir)
[17:47:31.770]                     if (!future$lazy) 
[17:47:31.770]                       future <- run(future)
[17:47:31.770]                     invisible(future)
[17:47:31.770]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:31.770]                 }
[17:47:31.770]                 ...future.workdir <- getwd()
[17:47:31.770]             }
[17:47:31.770]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.770]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.770]         }
[17:47:31.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.770]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.770]             base::names(...future.oldOptions))
[17:47:31.770]     }
[17:47:31.770]     if (FALSE) {
[17:47:31.770]     }
[17:47:31.770]     else {
[17:47:31.770]         if (TRUE) {
[17:47:31.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.770]                 open = "w")
[17:47:31.770]         }
[17:47:31.770]         else {
[17:47:31.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.770]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.770]         }
[17:47:31.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.770]             base::sink(type = "output", split = FALSE)
[17:47:31.770]             base::close(...future.stdout)
[17:47:31.770]         }, add = TRUE)
[17:47:31.770]     }
[17:47:31.770]     ...future.frame <- base::sys.nframe()
[17:47:31.770]     ...future.conditions <- base::list()
[17:47:31.770]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.770]     if (FALSE) {
[17:47:31.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.770]     }
[17:47:31.770]     ...future.result <- base::tryCatch({
[17:47:31.770]         base::withCallingHandlers({
[17:47:31.770]             ...future.value <- base::withVisible(base::local({
[17:47:31.770]                 withCallingHandlers({
[17:47:31.770]                   {
[17:47:31.770]                     a <- 1L
[17:47:31.770]                     plan_a <- unclass(future::plan("list"))
[17:47:31.770]                     nested_a <- nested[-1]
[17:47:31.770]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:31.770]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:31.770]                       strategy2))
[17:47:31.770]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:31.770]                       "init") <- NULL
[17:47:31.770]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:31.770]                       "init") <- NULL
[17:47:31.770]                     stopifnot(all.equal(plan_a, nested_a))
[17:47:31.770]                     y %<-% {
[17:47:31.770]                       b <- 2L
[17:47:31.770]                       plan_b <- future::plan("list")
[17:47:31.770]                       nested_b <- nested_a[-1]
[17:47:31.770]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:31.770]                         1L, inherits(plan_b[[1]], "future"), 
[17:47:31.770]                         inherits(future::plan("next"), "sequential"))
[17:47:31.770]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:31.770]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:31.770]                     }
[17:47:31.770]                     y
[17:47:31.770]                   }
[17:47:31.770]                 }, immediateCondition = function(cond) {
[17:47:31.770]                   save_rds <- function (object, pathname, ...) 
[17:47:31.770]                   {
[17:47:31.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:31.770]                     if (file_test("-f", pathname_tmp)) {
[17:47:31.770]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:31.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.770]                         fi_tmp[["mtime"]])
[17:47:31.770]                     }
[17:47:31.770]                     tryCatch({
[17:47:31.770]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:31.770]                     }, error = function(ex) {
[17:47:31.770]                       msg <- conditionMessage(ex)
[17:47:31.770]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:31.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.770]                         fi_tmp[["mtime"]], msg)
[17:47:31.770]                       ex$message <- msg
[17:47:31.770]                       stop(ex)
[17:47:31.770]                     })
[17:47:31.770]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:31.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:31.770]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:31.770]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.770]                       fi <- file.info(pathname)
[17:47:31.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:31.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:31.770]                         fi[["size"]], fi[["mtime"]])
[17:47:31.770]                       stop(msg)
[17:47:31.770]                     }
[17:47:31.770]                     invisible(pathname)
[17:47:31.770]                   }
[17:47:31.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:31.770]                     rootPath = tempdir()) 
[17:47:31.770]                   {
[17:47:31.770]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:31.770]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:31.770]                       tmpdir = path, fileext = ".rds")
[17:47:31.770]                     save_rds(obj, file)
[17:47:31.770]                   }
[17:47:31.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:31.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.770]                   {
[17:47:31.770]                     inherits <- base::inherits
[17:47:31.770]                     invokeRestart <- base::invokeRestart
[17:47:31.770]                     is.null <- base::is.null
[17:47:31.770]                     muffled <- FALSE
[17:47:31.770]                     if (inherits(cond, "message")) {
[17:47:31.770]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.770]                       if (muffled) 
[17:47:31.770]                         invokeRestart("muffleMessage")
[17:47:31.770]                     }
[17:47:31.770]                     else if (inherits(cond, "warning")) {
[17:47:31.770]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.770]                       if (muffled) 
[17:47:31.770]                         invokeRestart("muffleWarning")
[17:47:31.770]                     }
[17:47:31.770]                     else if (inherits(cond, "condition")) {
[17:47:31.770]                       if (!is.null(pattern)) {
[17:47:31.770]                         computeRestarts <- base::computeRestarts
[17:47:31.770]                         grepl <- base::grepl
[17:47:31.770]                         restarts <- computeRestarts(cond)
[17:47:31.770]                         for (restart in restarts) {
[17:47:31.770]                           name <- restart$name
[17:47:31.770]                           if (is.null(name)) 
[17:47:31.770]                             next
[17:47:31.770]                           if (!grepl(pattern, name)) 
[17:47:31.770]                             next
[17:47:31.770]                           invokeRestart(restart)
[17:47:31.770]                           muffled <- TRUE
[17:47:31.770]                           break
[17:47:31.770]                         }
[17:47:31.770]                       }
[17:47:31.770]                     }
[17:47:31.770]                     invisible(muffled)
[17:47:31.770]                   }
[17:47:31.770]                   muffleCondition(cond)
[17:47:31.770]                 })
[17:47:31.770]             }))
[17:47:31.770]             future::FutureResult(value = ...future.value$value, 
[17:47:31.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.770]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.770]                     ...future.globalenv.names))
[17:47:31.770]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.770]         }, condition = base::local({
[17:47:31.770]             c <- base::c
[17:47:31.770]             inherits <- base::inherits
[17:47:31.770]             invokeRestart <- base::invokeRestart
[17:47:31.770]             length <- base::length
[17:47:31.770]             list <- base::list
[17:47:31.770]             seq.int <- base::seq.int
[17:47:31.770]             signalCondition <- base::signalCondition
[17:47:31.770]             sys.calls <- base::sys.calls
[17:47:31.770]             `[[` <- base::`[[`
[17:47:31.770]             `+` <- base::`+`
[17:47:31.770]             `<<-` <- base::`<<-`
[17:47:31.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.770]                   3L)]
[17:47:31.770]             }
[17:47:31.770]             function(cond) {
[17:47:31.770]                 is_error <- inherits(cond, "error")
[17:47:31.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.770]                   NULL)
[17:47:31.770]                 if (is_error) {
[17:47:31.770]                   sessionInformation <- function() {
[17:47:31.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.770]                       search = base::search(), system = base::Sys.info())
[17:47:31.770]                   }
[17:47:31.770]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.770]                     cond$call), session = sessionInformation(), 
[17:47:31.770]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.770]                   signalCondition(cond)
[17:47:31.770]                 }
[17:47:31.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.770]                 "immediateCondition"))) {
[17:47:31.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.770]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.770]                   if (TRUE && !signal) {
[17:47:31.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.770]                     {
[17:47:31.770]                       inherits <- base::inherits
[17:47:31.770]                       invokeRestart <- base::invokeRestart
[17:47:31.770]                       is.null <- base::is.null
[17:47:31.770]                       muffled <- FALSE
[17:47:31.770]                       if (inherits(cond, "message")) {
[17:47:31.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.770]                         if (muffled) 
[17:47:31.770]                           invokeRestart("muffleMessage")
[17:47:31.770]                       }
[17:47:31.770]                       else if (inherits(cond, "warning")) {
[17:47:31.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.770]                         if (muffled) 
[17:47:31.770]                           invokeRestart("muffleWarning")
[17:47:31.770]                       }
[17:47:31.770]                       else if (inherits(cond, "condition")) {
[17:47:31.770]                         if (!is.null(pattern)) {
[17:47:31.770]                           computeRestarts <- base::computeRestarts
[17:47:31.770]                           grepl <- base::grepl
[17:47:31.770]                           restarts <- computeRestarts(cond)
[17:47:31.770]                           for (restart in restarts) {
[17:47:31.770]                             name <- restart$name
[17:47:31.770]                             if (is.null(name)) 
[17:47:31.770]                               next
[17:47:31.770]                             if (!grepl(pattern, name)) 
[17:47:31.770]                               next
[17:47:31.770]                             invokeRestart(restart)
[17:47:31.770]                             muffled <- TRUE
[17:47:31.770]                             break
[17:47:31.770]                           }
[17:47:31.770]                         }
[17:47:31.770]                       }
[17:47:31.770]                       invisible(muffled)
[17:47:31.770]                     }
[17:47:31.770]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.770]                   }
[17:47:31.770]                 }
[17:47:31.770]                 else {
[17:47:31.770]                   if (TRUE) {
[17:47:31.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.770]                     {
[17:47:31.770]                       inherits <- base::inherits
[17:47:31.770]                       invokeRestart <- base::invokeRestart
[17:47:31.770]                       is.null <- base::is.null
[17:47:31.770]                       muffled <- FALSE
[17:47:31.770]                       if (inherits(cond, "message")) {
[17:47:31.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.770]                         if (muffled) 
[17:47:31.770]                           invokeRestart("muffleMessage")
[17:47:31.770]                       }
[17:47:31.770]                       else if (inherits(cond, "warning")) {
[17:47:31.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.770]                         if (muffled) 
[17:47:31.770]                           invokeRestart("muffleWarning")
[17:47:31.770]                       }
[17:47:31.770]                       else if (inherits(cond, "condition")) {
[17:47:31.770]                         if (!is.null(pattern)) {
[17:47:31.770]                           computeRestarts <- base::computeRestarts
[17:47:31.770]                           grepl <- base::grepl
[17:47:31.770]                           restarts <- computeRestarts(cond)
[17:47:31.770]                           for (restart in restarts) {
[17:47:31.770]                             name <- restart$name
[17:47:31.770]                             if (is.null(name)) 
[17:47:31.770]                               next
[17:47:31.770]                             if (!grepl(pattern, name)) 
[17:47:31.770]                               next
[17:47:31.770]                             invokeRestart(restart)
[17:47:31.770]                             muffled <- TRUE
[17:47:31.770]                             break
[17:47:31.770]                           }
[17:47:31.770]                         }
[17:47:31.770]                       }
[17:47:31.770]                       invisible(muffled)
[17:47:31.770]                     }
[17:47:31.770]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.770]                   }
[17:47:31.770]                 }
[17:47:31.770]             }
[17:47:31.770]         }))
[17:47:31.770]     }, error = function(ex) {
[17:47:31.770]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.770]                 ...future.rng), started = ...future.startTime, 
[17:47:31.770]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.770]             version = "1.8"), class = "FutureResult")
[17:47:31.770]     }, finally = {
[17:47:31.770]         if (!identical(...future.workdir, getwd())) 
[17:47:31.770]             setwd(...future.workdir)
[17:47:31.770]         {
[17:47:31.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.770]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.770]             }
[17:47:31.770]             base::options(...future.oldOptions)
[17:47:31.770]             if (.Platform$OS.type == "windows") {
[17:47:31.770]                 old_names <- names(...future.oldEnvVars)
[17:47:31.770]                 envs <- base::Sys.getenv()
[17:47:31.770]                 names <- names(envs)
[17:47:31.770]                 common <- intersect(names, old_names)
[17:47:31.770]                 added <- setdiff(names, old_names)
[17:47:31.770]                 removed <- setdiff(old_names, names)
[17:47:31.770]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.770]                   envs[common]]
[17:47:31.770]                 NAMES <- toupper(changed)
[17:47:31.770]                 args <- list()
[17:47:31.770]                 for (kk in seq_along(NAMES)) {
[17:47:31.770]                   name <- changed[[kk]]
[17:47:31.770]                   NAME <- NAMES[[kk]]
[17:47:31.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.770]                     next
[17:47:31.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.770]                 }
[17:47:31.770]                 NAMES <- toupper(added)
[17:47:31.770]                 for (kk in seq_along(NAMES)) {
[17:47:31.770]                   name <- added[[kk]]
[17:47:31.770]                   NAME <- NAMES[[kk]]
[17:47:31.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.770]                     next
[17:47:31.770]                   args[[name]] <- ""
[17:47:31.770]                 }
[17:47:31.770]                 NAMES <- toupper(removed)
[17:47:31.770]                 for (kk in seq_along(NAMES)) {
[17:47:31.770]                   name <- removed[[kk]]
[17:47:31.770]                   NAME <- NAMES[[kk]]
[17:47:31.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.770]                     next
[17:47:31.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.770]                 }
[17:47:31.770]                 if (length(args) > 0) 
[17:47:31.770]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.770]             }
[17:47:31.770]             else {
[17:47:31.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.770]             }
[17:47:31.770]             {
[17:47:31.770]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.770]                   0L) {
[17:47:31.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.770]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.770]                   base::options(opts)
[17:47:31.770]                 }
[17:47:31.770]                 {
[17:47:31.770]                   {
[17:47:31.770]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.770]                     NULL
[17:47:31.770]                   }
[17:47:31.770]                   options(future.plan = NULL)
[17:47:31.770]                   if (is.na(NA_character_)) 
[17:47:31.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.770]                     .init = FALSE)
[17:47:31.770]                 }
[17:47:31.770]             }
[17:47:31.770]         }
[17:47:31.770]     })
[17:47:31.770]     if (TRUE) {
[17:47:31.770]         base::sink(type = "output", split = FALSE)
[17:47:31.770]         if (TRUE) {
[17:47:31.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.770]         }
[17:47:31.770]         else {
[17:47:31.770]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.770]         }
[17:47:31.770]         base::close(...future.stdout)
[17:47:31.770]         ...future.stdout <- NULL
[17:47:31.770]     }
[17:47:31.770]     ...future.result$conditions <- ...future.conditions
[17:47:31.770]     ...future.result$finished <- base::Sys.time()
[17:47:31.770]     ...future.result
[17:47:31.770] }
[17:47:31.772] assign_globals() ...
[17:47:31.772] List of 2
[17:47:31.772]  $ nested   :List of 2
[17:47:31.772]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:31.772]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:31.772]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.772]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:31.772]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:31.772]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.772]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:31.772]  $ strategy2: chr "multicore"
[17:47:31.772]  - attr(*, "where")=List of 2
[17:47:31.772]   ..$ nested   :<environment: R_EmptyEnv> 
[17:47:31.772]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:47:31.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.772]  - attr(*, "resolved")= logi FALSE
[17:47:31.772]  - attr(*, "total_size")= num 95304
[17:47:31.772]  - attr(*, "already-done")= logi TRUE
[17:47:31.778] - copied ‘nested’ to environment
[17:47:31.778] - copied ‘strategy2’ to environment
[17:47:31.778] assign_globals() ... done
[17:47:31.778] requestCore(): workers = 2
[17:47:31.780] MulticoreFuture started
[17:47:31.781] - Launch lazy future ... done
[17:47:31.781] run() for ‘MulticoreFuture’ ... done
[17:47:31.782] result() for MulticoreFuture ...
[17:47:31.782] plan(): Setting new future strategy stack:
[17:47:31.782] List of future strategies:
[17:47:31.782] 1. multicore:
[17:47:31.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.782]    - tweaked: FALSE
[17:47:31.782]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.788] plan(): nbrOfWorkers() = 1
[17:47:31.829] plan(): Setting new future strategy stack:
[17:47:31.829] List of future strategies:
[17:47:31.829] 1. multicore:
[17:47:31.829]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.829]    - tweaked: FALSE
[17:47:31.829]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.829] 2. multicore:
[17:47:31.829]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.829]    - tweaked: FALSE
[17:47:31.829]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.833] plan(): nbrOfWorkers() = 2
[17:47:31.834] result() for MulticoreFuture ...
[17:47:31.834] result() for MulticoreFuture ... done
[17:47:31.834] signalConditions() ...
[17:47:31.835]  - include = ‘immediateCondition’
[17:47:31.835]  - exclude = 
[17:47:31.835]  - resignal = FALSE
[17:47:31.835]  - Number of conditions: 54
[17:47:31.835] signalConditions() ... done
[17:47:31.835] result() for MulticoreFuture ... done
[17:47:31.835] result() for MulticoreFuture ...
[17:47:31.835] result() for MulticoreFuture ... done
[17:47:31.836] signalConditions() ...
[17:47:31.836]  - include = ‘immediateCondition’
[17:47:31.836]  - exclude = 
[17:47:31.836]  - resignal = FALSE
[17:47:31.836]  - Number of conditions: 54
[17:47:31.836] signalConditions() ... done
[17:47:31.836] Future state: ‘finished’
[17:47:31.836] result() for MulticoreFuture ...
[17:47:31.837] result() for MulticoreFuture ... done
[17:47:31.837] signalConditions() ...
[17:47:31.837]  - include = ‘condition’
[17:47:31.837]  - exclude = ‘immediateCondition’
[17:47:31.837]  - resignal = TRUE
[17:47:31.837]  - Number of conditions: 54
[17:47:31.837]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.790] getGlobalsAndPackages() ...
[17:47:31.837]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.790] Searching for globals...
[17:47:31.838]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.798] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:47:31.838]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.798] Searching for globals ... DONE
[17:47:31.838]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.799] Resolving globals: FALSE
[17:47:31.838]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.800] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[17:47:31.838]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.801] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:47:31.838]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.801] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:47:31.839]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.801] 
[17:47:31.839]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.801] getGlobalsAndPackages() ... DONE
[17:47:31.839]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.802] run() for ‘Future’ ...
[17:47:31.839]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.802] - state: ‘created’
[17:47:31.839]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.802] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.840]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.806] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:31.840]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:31.840]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.807]   - Field: ‘label’
[17:47:31.840]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.807]   - Field: ‘local’
[17:47:31.840]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.807]   - Field: ‘owner’
[17:47:31.840]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.807]   - Field: ‘envir’
[17:47:31.841]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.807]   - Field: ‘packages’
[17:47:31.841]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.808]   - Field: ‘gc’
[17:47:31.841]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.808]   - Field: ‘conditions’
[17:47:31.841]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.808]   - Field: ‘expr’
[17:47:31.841]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.808]   - Field: ‘uuid’
[17:47:31.841]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.808]   - Field: ‘seed’
[17:47:31.842]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.808]   - Field: ‘version’
[17:47:31.842]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘result’
[17:47:31.842]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘asynchronous’
[17:47:31.842]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘calls’
[17:47:31.842]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘globals’
[17:47:31.842]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘stdout’
[17:47:31.842]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘earlySignal’
[17:47:31.843]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.809]   - Field: ‘lazy’
[17:47:31.843]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.810]   - Field: ‘state’
[17:47:31.843]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:31.843]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.810] - Launch lazy future ...
[17:47:31.843]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.810] Packages needed by the future expression (n = 0): <none>
[17:47:31.844]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.810] Packages needed by future strategies (n = 0): <none>
[17:47:31.844]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.811] {
[17:47:31.811]     {
[17:47:31.811]         {
[17:47:31.811]             ...future.startTime <- base::Sys.time()
[17:47:31.811]             {
[17:47:31.811]                 {
[17:47:31.811]                   {
[17:47:31.811]                     base::local({
[17:47:31.811]                       has_future <- base::requireNamespace("future", 
[17:47:31.811]                         quietly = TRUE)
[17:47:31.811]                       if (has_future) {
[17:47:31.811]                         ns <- base::getNamespace("future")
[17:47:31.811]                         version <- ns[[".package"]][["version"]]
[17:47:31.811]                         if (is.null(version)) 
[17:47:31.811]                           version <- utils::packageVersion("future")
[17:47:31.811]                       }
[17:47:31.811]                       else {
[17:47:31.811]                         version <- NULL
[17:47:31.811]                       }
[17:47:31.811]                       if (!has_future || version < "1.8.0") {
[17:47:31.811]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.811]                           "", base::R.version$version.string), 
[17:47:31.811]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:31.811]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.811]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.811]                             "release", "version")], collapse = " "), 
[17:47:31.811]                           hostname = base::Sys.info()[["nodename"]])
[17:47:31.811]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.811]                           info)
[17:47:31.811]                         info <- base::paste(info, collapse = "; ")
[17:47:31.811]                         if (!has_future) {
[17:47:31.811]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.811]                             info)
[17:47:31.811]                         }
[17:47:31.811]                         else {
[17:47:31.811]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.811]                             info, version)
[17:47:31.811]                         }
[17:47:31.811]                         base::stop(msg)
[17:47:31.811]                       }
[17:47:31.811]                     })
[17:47:31.811]                   }
[17:47:31.811]                   ...future.strategy.old <- future::plan("list")
[17:47:31.811]                   options(future.plan = NULL)
[17:47:31.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:31.811]                 }
[17:47:31.811]                 ...future.workdir <- getwd()
[17:47:31.811]             }
[17:47:31.811]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.811]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.811]         }
[17:47:31.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.811]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.811]             base::names(...future.oldOptions))
[17:47:31.811]     }
[17:47:31.811]     if (FALSE) {
[17:47:31.811]     }
[17:47:31.811]     else {
[17:47:31.811]         if (TRUE) {
[17:47:31.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.811]                 open = "w")
[17:47:31.811]         }
[17:47:31.811]         else {
[17:47:31.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.811]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.811]         }
[17:47:31.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.811]             base::sink(type = "output", split = FALSE)
[17:47:31.811]             base::close(...future.stdout)
[17:47:31.811]         }, add = TRUE)
[17:47:31.811]     }
[17:47:31.811]     ...future.frame <- base::sys.nframe()
[17:47:31.811]     ...future.conditions <- base::list()
[17:47:31.811]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.811]     if (FALSE) {
[17:47:31.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.811]     }
[17:47:31.811]     ...future.result <- base::tryCatch({
[17:47:31.811]         base::withCallingHandlers({
[17:47:31.811]             ...future.value <- base::withVisible(base::local({
[17:47:31.811]                 b <- 2L
[17:47:31.811]                 plan_b <- future::plan("list")
[17:47:31.811]                 nested_b <- nested_a[-1]
[17:47:31.811]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:31.811]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:31.811]                   "sequential"))
[17:47:31.811]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:31.811]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:31.811]             }))
[17:47:31.811]             future::FutureResult(value = ...future.value$value, 
[17:47:31.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.811]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.811]                     ...future.globalenv.names))
[17:47:31.811]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.811]         }, condition = base::local({
[17:47:31.811]             c <- base::c
[17:47:31.811]             inherits <- base::inherits
[17:47:31.811]             invokeRestart <- base::invokeRestart
[17:47:31.811]             length <- base::length
[17:47:31.811]             list <- base::list
[17:47:31.811]             seq.int <- base::seq.int
[17:47:31.811]             signalCondition <- base::signalCondition
[17:47:31.811]             sys.calls <- base::sys.calls
[17:47:31.811]             `[[` <- base::`[[`
[17:47:31.811]             `+` <- base::`+`
[17:47:31.811]             `<<-` <- base::`<<-`
[17:47:31.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.811]                   3L)]
[17:47:31.811]             }
[17:47:31.811]             function(cond) {
[17:47:31.811]                 is_error <- inherits(cond, "error")
[17:47:31.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.811]                   NULL)
[17:47:31.811]                 if (is_error) {
[17:47:31.811]                   sessionInformation <- function() {
[17:47:31.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.811]                       search = base::search(), system = base::Sys.info())
[17:47:31.811]                   }
[17:47:31.811]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.811]                     cond$call), session = sessionInformation(), 
[17:47:31.811]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.811]                   signalCondition(cond)
[17:47:31.811]                 }
[17:47:31.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.811]                 "immediateCondition"))) {
[17:47:31.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.811]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.811]                   if (TRUE && !signal) {
[17:47:31.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.811]                     {
[17:47:31.811]                       inherits <- base::inherits
[17:47:31.811]                       invokeRestart <- base::invokeRestart
[17:47:31.811]                       is.null <- base::is.null
[17:47:31.811]                       muffled <- FALSE
[17:47:31.811]                       if (inherits(cond, "message")) {
[17:47:31.811]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.811]                         if (muffled) 
[17:47:31.811]                           invokeRestart("muffleMessage")
[17:47:31.811]                       }
[17:47:31.811]                       else if (inherits(cond, "warning")) {
[17:47:31.811]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.811]                         if (muffled) 
[17:47:31.811]                           invokeRestart("muffleWarning")
[17:47:31.811]                       }
[17:47:31.811]                       else if (inherits(cond, "condition")) {
[17:47:31.811]                         if (!is.null(pattern)) {
[17:47:31.811]                           computeRestarts <- base::computeRestarts
[17:47:31.811]                           grepl <- base::grepl
[17:47:31.811]                           restarts <- computeRestarts(cond)
[17:47:31.811]                           for (restart in restarts) {
[17:47:31.811]                             name <- restart$name
[17:47:31.811]                             if (is.null(name)) 
[17:47:31.811]                               next
[17:47:31.811]                             if (!grepl(pattern, name)) 
[17:47:31.811]                               next
[17:47:31.811]                             invokeRestart(restart)
[17:47:31.811]                             muffled <- TRUE
[17:47:31.811]                             break
[17:47:31.811]                           }
[17:47:31.811]                         }
[17:47:31.811]                       }
[17:47:31.811]                       invisible(muffled)
[17:47:31.811]                     }
[17:47:31.811]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.811]                   }
[17:47:31.811]                 }
[17:47:31.811]                 else {
[17:47:31.811]                   if (TRUE) {
[17:47:31.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.811]                     {
[17:47:31.811]                       inherits <- base::inherits
[17:47:31.811]                       invokeRestart <- base::invokeRestart
[17:47:31.811]                       is.null <- base::is.null
[17:47:31.811]                       muffled <- FALSE
[17:47:31.811]                       if (inherits(cond, "message")) {
[17:47:31.811]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.811]                         if (muffled) 
[17:47:31.811]                           invokeRestart("muffleMessage")
[17:47:31.811]                       }
[17:47:31.811]                       else if (inherits(cond, "warning")) {
[17:47:31.811]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.811]                         if (muffled) 
[17:47:31.811]                           invokeRestart("muffleWarning")
[17:47:31.811]                       }
[17:47:31.811]                       else if (inherits(cond, "condition")) {
[17:47:31.811]                         if (!is.null(pattern)) {
[17:47:31.811]                           computeRestarts <- base::computeRestarts
[17:47:31.811]                           grepl <- base::grepl
[17:47:31.811]                           restarts <- computeRestarts(cond)
[17:47:31.811]                           for (restart in restarts) {
[17:47:31.811]                             name <- restart$name
[17:47:31.811]                             if (is.null(name)) 
[17:47:31.811]                               next
[17:47:31.811]                             if (!grepl(pattern, name)) 
[17:47:31.811]                               next
[17:47:31.811]                             invokeRestart(restart)
[17:47:31.811]                             muffled <- TRUE
[17:47:31.811]                             break
[17:47:31.811]                           }
[17:47:31.811]                         }
[17:47:31.811]                       }
[17:47:31.811]                       invisible(muffled)
[17:47:31.811]                     }
[17:47:31.811]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.811]                   }
[17:47:31.811]                 }
[17:47:31.811]             }
[17:47:31.811]         }))
[17:47:31.811]     }, error = function(ex) {
[17:47:31.811]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.811]                 ...future.rng), started = ...future.startTime, 
[17:47:31.811]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.811]             version = "1.8"), class = "FutureResult")
[17:47:31.811]     }, finally = {
[17:47:31.811]         if (!identical(...future.workdir, getwd())) 
[17:47:31.811]             setwd(...future.workdir)
[17:47:31.811]         {
[17:47:31.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.811]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.811]             }
[17:47:31.811]             base::options(...future.oldOptions)
[17:47:31.811]             if (.Platform$OS.type == "windows") {
[17:47:31.811]                 old_names <- names(...future.oldEnvVars)
[17:47:31.811]                 envs <- base::Sys.getenv()
[17:47:31.811]                 names <- names(envs)
[17:47:31.811]                 common <- intersect(names, old_names)
[17:47:31.811]                 added <- setdiff(names, old_names)
[17:47:31.811]                 removed <- setdiff(old_names, names)
[17:47:31.811]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.811]                   envs[common]]
[17:47:31.811]                 NAMES <- toupper(changed)
[17:47:31.811]                 args <- list()
[17:47:31.811]                 for (kk in seq_along(NAMES)) {
[17:47:31.811]                   name <- changed[[kk]]
[17:47:31.811]                   NAME <- NAMES[[kk]]
[17:47:31.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.811]                     next
[17:47:31.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.811]                 }
[17:47:31.811]                 NAMES <- toupper(added)
[17:47:31.811]                 for (kk in seq_along(NAMES)) {
[17:47:31.811]                   name <- added[[kk]]
[17:47:31.811]                   NAME <- NAMES[[kk]]
[17:47:31.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.811]                     next
[17:47:31.811]                   args[[name]] <- ""
[17:47:31.811]                 }
[17:47:31.811]                 NAMES <- toupper(removed)
[17:47:31.811]                 for (kk in seq_along(NAMES)) {
[17:47:31.811]                   name <- removed[[kk]]
[17:47:31.811]                   NAME <- NAMES[[kk]]
[17:47:31.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.811]                     next
[17:47:31.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.811]                 }
[17:47:31.811]                 if (length(args) > 0) 
[17:47:31.811]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.811]             }
[17:47:31.811]             else {
[17:47:31.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.811]             }
[17:47:31.811]             {
[17:47:31.811]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.811]                   0L) {
[17:47:31.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.811]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.811]                   base::options(opts)
[17:47:31.811]                 }
[17:47:31.811]                 {
[17:47:31.811]                   {
[17:47:31.811]                     NULL
[17:47:31.811]                     RNGkind("Mersenne-Twister")
[17:47:31.811]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:31.811]                       inherits = FALSE)
[17:47:31.811]                   }
[17:47:31.811]                   options(future.plan = NULL)
[17:47:31.811]                   if (is.na(NA_character_)) 
[17:47:31.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.811]                     .init = FALSE)
[17:47:31.811]                 }
[17:47:31.811]             }
[17:47:31.811]         }
[17:47:31.811]     })
[17:47:31.811]     if (TRUE) {
[17:47:31.811]         base::sink(type = "output", split = FALSE)
[17:47:31.811]         if (TRUE) {
[17:47:31.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.811]         }
[17:47:31.811]         else {
[17:47:31.811]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.811]         }
[17:47:31.811]         base::close(...future.stdout)
[17:47:31.811]         ...future.stdout <- NULL
[17:47:31.811]     }
[17:47:31.811]     ...future.result$conditions <- ...future.conditions
[17:47:31.811]     ...future.result$finished <- base::Sys.time()
[17:47:31.811]     ...future.result
[17:47:31.811] }
[17:47:31.844]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.814] assign_globals() ...
[17:47:31.844]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.814] List of 3
[17:47:31.814]  $ nested_a:List of 1
[17:47:31.814]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:31.814]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:31.814]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.814]  $ a       : int 1
[17:47:31.814]  $ plan_a  :List of 1
[17:47:31.814]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:31.814]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:31.814]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.814]  - attr(*, "where")=List of 3
[17:47:31.814]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:47:31.814]   ..$ a       :<environment: R_EmptyEnv> 
[17:47:31.814]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:47:31.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.814]  - attr(*, "resolved")= logi FALSE
[17:47:31.814]  - attr(*, "total_size")= num 95240
[17:47:31.814]  - attr(*, "already-done")= logi TRUE
[17:47:31.844]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.821] - copied ‘nested_a’ to environment
[17:47:31.844]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.821] - copied ‘a’ to environment
[17:47:31.845]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.821] - copied ‘plan_a’ to environment
[17:47:31.845]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.821] assign_globals() ... done
[17:47:31.845]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.822] plan(): Setting new future strategy stack:
[17:47:31.845]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.822] List of future strategies:
[17:47:31.822] 1. sequential:
[17:47:31.822]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.822]    - tweaked: FALSE
[17:47:31.822]    - call: NULL
[17:47:31.845]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.822] plan(): nbrOfWorkers() = 1
[17:47:31.845]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.823] plan(): Setting new future strategy stack:
[17:47:31.846]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.823] List of future strategies:
[17:47:31.823] 1. multicore:
[17:47:31.823]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.823]    - tweaked: FALSE
[17:47:31.823]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.846]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.827] plan(): nbrOfWorkers() = 1
[17:47:31.846]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.828] SequentialFuture started (and completed)
[17:47:31.846]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.828] - Launch lazy future ... done
[17:47:31.846]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.828] run() for ‘SequentialFuture’ ... done
[17:47:31.846] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:31.852] getGlobalsAndPackages() ...
[17:47:31.852] Searching for globals...
[17:47:31.854] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:31.854] Searching for globals ... DONE
[17:47:31.854] Resolving globals: FALSE
[17:47:31.855] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:31.855] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:31.855] - globals: [1] ‘data’
[17:47:31.856] - packages: [1] ‘future’
[17:47:31.856] getGlobalsAndPackages() ... DONE
[17:47:31.856] run() for ‘Future’ ...
[17:47:31.856] - state: ‘created’
[17:47:31.856] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:31.861]   - Field: ‘label’
[17:47:31.861]   - Field: ‘local’
[17:47:31.861]   - Field: ‘owner’
[17:47:31.861]   - Field: ‘envir’
[17:47:31.861]   - Field: ‘workers’
[17:47:31.861]   - Field: ‘packages’
[17:47:31.861]   - Field: ‘gc’
[17:47:31.861]   - Field: ‘job’
[17:47:31.862]   - Field: ‘conditions’
[17:47:31.862]   - Field: ‘expr’
[17:47:31.862]   - Field: ‘uuid’
[17:47:31.862]   - Field: ‘seed’
[17:47:31.862]   - Field: ‘version’
[17:47:31.862]   - Field: ‘result’
[17:47:31.862]   - Field: ‘asynchronous’
[17:47:31.862]   - Field: ‘calls’
[17:47:31.862]   - Field: ‘globals’
[17:47:31.862]   - Field: ‘stdout’
[17:47:31.863]   - Field: ‘earlySignal’
[17:47:31.863]   - Field: ‘lazy’
[17:47:31.863]   - Field: ‘state’
[17:47:31.863] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:31.863] - Launch lazy future ...
[17:47:31.863] Packages needed by the future expression (n = 1): ‘future’
[17:47:31.864] Packages needed by future strategies (n = 1): ‘future’
[17:47:31.864] {
[17:47:31.864]     {
[17:47:31.864]         {
[17:47:31.864]             ...future.startTime <- base::Sys.time()
[17:47:31.864]             {
[17:47:31.864]                 {
[17:47:31.864]                   {
[17:47:31.864]                     {
[17:47:31.864]                       {
[17:47:31.864]                         base::local({
[17:47:31.864]                           has_future <- base::requireNamespace("future", 
[17:47:31.864]                             quietly = TRUE)
[17:47:31.864]                           if (has_future) {
[17:47:31.864]                             ns <- base::getNamespace("future")
[17:47:31.864]                             version <- ns[[".package"]][["version"]]
[17:47:31.864]                             if (is.null(version)) 
[17:47:31.864]                               version <- utils::packageVersion("future")
[17:47:31.864]                           }
[17:47:31.864]                           else {
[17:47:31.864]                             version <- NULL
[17:47:31.864]                           }
[17:47:31.864]                           if (!has_future || version < "1.8.0") {
[17:47:31.864]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.864]                               "", base::R.version$version.string), 
[17:47:31.864]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:31.864]                                 base::R.version$platform, 8 * 
[17:47:31.864]                                   base::.Machine$sizeof.pointer), 
[17:47:31.864]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.864]                                 "release", "version")], collapse = " "), 
[17:47:31.864]                               hostname = base::Sys.info()[["nodename"]])
[17:47:31.864]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.864]                               info)
[17:47:31.864]                             info <- base::paste(info, collapse = "; ")
[17:47:31.864]                             if (!has_future) {
[17:47:31.864]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.864]                                 info)
[17:47:31.864]                             }
[17:47:31.864]                             else {
[17:47:31.864]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.864]                                 info, version)
[17:47:31.864]                             }
[17:47:31.864]                             base::stop(msg)
[17:47:31.864]                           }
[17:47:31.864]                         })
[17:47:31.864]                       }
[17:47:31.864]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.864]                       base::options(mc.cores = 1L)
[17:47:31.864]                     }
[17:47:31.864]                     base::local({
[17:47:31.864]                       for (pkg in "future") {
[17:47:31.864]                         base::loadNamespace(pkg)
[17:47:31.864]                         base::library(pkg, character.only = TRUE)
[17:47:31.864]                       }
[17:47:31.864]                     })
[17:47:31.864]                   }
[17:47:31.864]                   ...future.strategy.old <- future::plan("list")
[17:47:31.864]                   options(future.plan = NULL)
[17:47:31.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.864]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:31.864]                     envir = parent.frame()) 
[17:47:31.864]                   {
[17:47:31.864]                     default_workers <- missing(workers)
[17:47:31.864]                     if (is.function(workers)) 
[17:47:31.864]                       workers <- workers()
[17:47:31.864]                     workers <- structure(as.integer(workers), 
[17:47:31.864]                       class = class(workers))
[17:47:31.864]                     stop_if_not(is.finite(workers), workers >= 
[17:47:31.864]                       1L)
[17:47:31.864]                     if ((workers == 1L && !inherits(workers, 
[17:47:31.864]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:31.864]                       if (default_workers) 
[17:47:31.864]                         supportsMulticore(warn = TRUE)
[17:47:31.864]                       return(sequential(..., envir = envir))
[17:47:31.864]                     }
[17:47:31.864]                     oopts <- options(mc.cores = workers)
[17:47:31.864]                     on.exit(options(oopts))
[17:47:31.864]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:31.864]                       envir = envir)
[17:47:31.864]                     if (!future$lazy) 
[17:47:31.864]                       future <- run(future)
[17:47:31.864]                     invisible(future)
[17:47:31.864]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:31.864]                 }
[17:47:31.864]                 ...future.workdir <- getwd()
[17:47:31.864]             }
[17:47:31.864]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.864]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.864]         }
[17:47:31.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.864]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.864]             base::names(...future.oldOptions))
[17:47:31.864]     }
[17:47:31.864]     if (FALSE) {
[17:47:31.864]     }
[17:47:31.864]     else {
[17:47:31.864]         if (TRUE) {
[17:47:31.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.864]                 open = "w")
[17:47:31.864]         }
[17:47:31.864]         else {
[17:47:31.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.864]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.864]         }
[17:47:31.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.864]             base::sink(type = "output", split = FALSE)
[17:47:31.864]             base::close(...future.stdout)
[17:47:31.864]         }, add = TRUE)
[17:47:31.864]     }
[17:47:31.864]     ...future.frame <- base::sys.nframe()
[17:47:31.864]     ...future.conditions <- base::list()
[17:47:31.864]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.864]     if (FALSE) {
[17:47:31.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.864]     }
[17:47:31.864]     ...future.result <- base::tryCatch({
[17:47:31.864]         base::withCallingHandlers({
[17:47:31.864]             ...future.value <- base::withVisible(base::local({
[17:47:31.864]                 withCallingHandlers({
[17:47:31.864]                   {
[17:47:31.864]                     value(future(subset(data, a == 2)))
[17:47:31.864]                   }
[17:47:31.864]                 }, immediateCondition = function(cond) {
[17:47:31.864]                   save_rds <- function (object, pathname, ...) 
[17:47:31.864]                   {
[17:47:31.864]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:31.864]                     if (file_test("-f", pathname_tmp)) {
[17:47:31.864]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.864]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:31.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.864]                         fi_tmp[["mtime"]])
[17:47:31.864]                     }
[17:47:31.864]                     tryCatch({
[17:47:31.864]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:31.864]                     }, error = function(ex) {
[17:47:31.864]                       msg <- conditionMessage(ex)
[17:47:31.864]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.864]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:31.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.864]                         fi_tmp[["mtime"]], msg)
[17:47:31.864]                       ex$message <- msg
[17:47:31.864]                       stop(ex)
[17:47:31.864]                     })
[17:47:31.864]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:31.864]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:31.864]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:31.864]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.864]                       fi <- file.info(pathname)
[17:47:31.864]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:31.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.864]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:31.864]                         fi[["size"]], fi[["mtime"]])
[17:47:31.864]                       stop(msg)
[17:47:31.864]                     }
[17:47:31.864]                     invisible(pathname)
[17:47:31.864]                   }
[17:47:31.864]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:31.864]                     rootPath = tempdir()) 
[17:47:31.864]                   {
[17:47:31.864]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:31.864]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:31.864]                       tmpdir = path, fileext = ".rds")
[17:47:31.864]                     save_rds(obj, file)
[17:47:31.864]                   }
[17:47:31.864]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:31.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.864]                   {
[17:47:31.864]                     inherits <- base::inherits
[17:47:31.864]                     invokeRestart <- base::invokeRestart
[17:47:31.864]                     is.null <- base::is.null
[17:47:31.864]                     muffled <- FALSE
[17:47:31.864]                     if (inherits(cond, "message")) {
[17:47:31.864]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.864]                       if (muffled) 
[17:47:31.864]                         invokeRestart("muffleMessage")
[17:47:31.864]                     }
[17:47:31.864]                     else if (inherits(cond, "warning")) {
[17:47:31.864]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.864]                       if (muffled) 
[17:47:31.864]                         invokeRestart("muffleWarning")
[17:47:31.864]                     }
[17:47:31.864]                     else if (inherits(cond, "condition")) {
[17:47:31.864]                       if (!is.null(pattern)) {
[17:47:31.864]                         computeRestarts <- base::computeRestarts
[17:47:31.864]                         grepl <- base::grepl
[17:47:31.864]                         restarts <- computeRestarts(cond)
[17:47:31.864]                         for (restart in restarts) {
[17:47:31.864]                           name <- restart$name
[17:47:31.864]                           if (is.null(name)) 
[17:47:31.864]                             next
[17:47:31.864]                           if (!grepl(pattern, name)) 
[17:47:31.864]                             next
[17:47:31.864]                           invokeRestart(restart)
[17:47:31.864]                           muffled <- TRUE
[17:47:31.864]                           break
[17:47:31.864]                         }
[17:47:31.864]                       }
[17:47:31.864]                     }
[17:47:31.864]                     invisible(muffled)
[17:47:31.864]                   }
[17:47:31.864]                   muffleCondition(cond)
[17:47:31.864]                 })
[17:47:31.864]             }))
[17:47:31.864]             future::FutureResult(value = ...future.value$value, 
[17:47:31.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.864]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.864]                     ...future.globalenv.names))
[17:47:31.864]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.864]         }, condition = base::local({
[17:47:31.864]             c <- base::c
[17:47:31.864]             inherits <- base::inherits
[17:47:31.864]             invokeRestart <- base::invokeRestart
[17:47:31.864]             length <- base::length
[17:47:31.864]             list <- base::list
[17:47:31.864]             seq.int <- base::seq.int
[17:47:31.864]             signalCondition <- base::signalCondition
[17:47:31.864]             sys.calls <- base::sys.calls
[17:47:31.864]             `[[` <- base::`[[`
[17:47:31.864]             `+` <- base::`+`
[17:47:31.864]             `<<-` <- base::`<<-`
[17:47:31.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.864]                   3L)]
[17:47:31.864]             }
[17:47:31.864]             function(cond) {
[17:47:31.864]                 is_error <- inherits(cond, "error")
[17:47:31.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.864]                   NULL)
[17:47:31.864]                 if (is_error) {
[17:47:31.864]                   sessionInformation <- function() {
[17:47:31.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.864]                       search = base::search(), system = base::Sys.info())
[17:47:31.864]                   }
[17:47:31.864]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.864]                     cond$call), session = sessionInformation(), 
[17:47:31.864]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.864]                   signalCondition(cond)
[17:47:31.864]                 }
[17:47:31.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.864]                 "immediateCondition"))) {
[17:47:31.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.864]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.864]                   if (TRUE && !signal) {
[17:47:31.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.864]                     {
[17:47:31.864]                       inherits <- base::inherits
[17:47:31.864]                       invokeRestart <- base::invokeRestart
[17:47:31.864]                       is.null <- base::is.null
[17:47:31.864]                       muffled <- FALSE
[17:47:31.864]                       if (inherits(cond, "message")) {
[17:47:31.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.864]                         if (muffled) 
[17:47:31.864]                           invokeRestart("muffleMessage")
[17:47:31.864]                       }
[17:47:31.864]                       else if (inherits(cond, "warning")) {
[17:47:31.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.864]                         if (muffled) 
[17:47:31.864]                           invokeRestart("muffleWarning")
[17:47:31.864]                       }
[17:47:31.864]                       else if (inherits(cond, "condition")) {
[17:47:31.864]                         if (!is.null(pattern)) {
[17:47:31.864]                           computeRestarts <- base::computeRestarts
[17:47:31.864]                           grepl <- base::grepl
[17:47:31.864]                           restarts <- computeRestarts(cond)
[17:47:31.864]                           for (restart in restarts) {
[17:47:31.864]                             name <- restart$name
[17:47:31.864]                             if (is.null(name)) 
[17:47:31.864]                               next
[17:47:31.864]                             if (!grepl(pattern, name)) 
[17:47:31.864]                               next
[17:47:31.864]                             invokeRestart(restart)
[17:47:31.864]                             muffled <- TRUE
[17:47:31.864]                             break
[17:47:31.864]                           }
[17:47:31.864]                         }
[17:47:31.864]                       }
[17:47:31.864]                       invisible(muffled)
[17:47:31.864]                     }
[17:47:31.864]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.864]                   }
[17:47:31.864]                 }
[17:47:31.864]                 else {
[17:47:31.864]                   if (TRUE) {
[17:47:31.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.864]                     {
[17:47:31.864]                       inherits <- base::inherits
[17:47:31.864]                       invokeRestart <- base::invokeRestart
[17:47:31.864]                       is.null <- base::is.null
[17:47:31.864]                       muffled <- FALSE
[17:47:31.864]                       if (inherits(cond, "message")) {
[17:47:31.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.864]                         if (muffled) 
[17:47:31.864]                           invokeRestart("muffleMessage")
[17:47:31.864]                       }
[17:47:31.864]                       else if (inherits(cond, "warning")) {
[17:47:31.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.864]                         if (muffled) 
[17:47:31.864]                           invokeRestart("muffleWarning")
[17:47:31.864]                       }
[17:47:31.864]                       else if (inherits(cond, "condition")) {
[17:47:31.864]                         if (!is.null(pattern)) {
[17:47:31.864]                           computeRestarts <- base::computeRestarts
[17:47:31.864]                           grepl <- base::grepl
[17:47:31.864]                           restarts <- computeRestarts(cond)
[17:47:31.864]                           for (restart in restarts) {
[17:47:31.864]                             name <- restart$name
[17:47:31.864]                             if (is.null(name)) 
[17:47:31.864]                               next
[17:47:31.864]                             if (!grepl(pattern, name)) 
[17:47:31.864]                               next
[17:47:31.864]                             invokeRestart(restart)
[17:47:31.864]                             muffled <- TRUE
[17:47:31.864]                             break
[17:47:31.864]                           }
[17:47:31.864]                         }
[17:47:31.864]                       }
[17:47:31.864]                       invisible(muffled)
[17:47:31.864]                     }
[17:47:31.864]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.864]                   }
[17:47:31.864]                 }
[17:47:31.864]             }
[17:47:31.864]         }))
[17:47:31.864]     }, error = function(ex) {
[17:47:31.864]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.864]                 ...future.rng), started = ...future.startTime, 
[17:47:31.864]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.864]             version = "1.8"), class = "FutureResult")
[17:47:31.864]     }, finally = {
[17:47:31.864]         if (!identical(...future.workdir, getwd())) 
[17:47:31.864]             setwd(...future.workdir)
[17:47:31.864]         {
[17:47:31.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.864]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.864]             }
[17:47:31.864]             base::options(...future.oldOptions)
[17:47:31.864]             if (.Platform$OS.type == "windows") {
[17:47:31.864]                 old_names <- names(...future.oldEnvVars)
[17:47:31.864]                 envs <- base::Sys.getenv()
[17:47:31.864]                 names <- names(envs)
[17:47:31.864]                 common <- intersect(names, old_names)
[17:47:31.864]                 added <- setdiff(names, old_names)
[17:47:31.864]                 removed <- setdiff(old_names, names)
[17:47:31.864]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.864]                   envs[common]]
[17:47:31.864]                 NAMES <- toupper(changed)
[17:47:31.864]                 args <- list()
[17:47:31.864]                 for (kk in seq_along(NAMES)) {
[17:47:31.864]                   name <- changed[[kk]]
[17:47:31.864]                   NAME <- NAMES[[kk]]
[17:47:31.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.864]                     next
[17:47:31.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.864]                 }
[17:47:31.864]                 NAMES <- toupper(added)
[17:47:31.864]                 for (kk in seq_along(NAMES)) {
[17:47:31.864]                   name <- added[[kk]]
[17:47:31.864]                   NAME <- NAMES[[kk]]
[17:47:31.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.864]                     next
[17:47:31.864]                   args[[name]] <- ""
[17:47:31.864]                 }
[17:47:31.864]                 NAMES <- toupper(removed)
[17:47:31.864]                 for (kk in seq_along(NAMES)) {
[17:47:31.864]                   name <- removed[[kk]]
[17:47:31.864]                   NAME <- NAMES[[kk]]
[17:47:31.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.864]                     next
[17:47:31.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.864]                 }
[17:47:31.864]                 if (length(args) > 0) 
[17:47:31.864]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.864]             }
[17:47:31.864]             else {
[17:47:31.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.864]             }
[17:47:31.864]             {
[17:47:31.864]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.864]                   0L) {
[17:47:31.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.864]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.864]                   base::options(opts)
[17:47:31.864]                 }
[17:47:31.864]                 {
[17:47:31.864]                   {
[17:47:31.864]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.864]                     NULL
[17:47:31.864]                   }
[17:47:31.864]                   options(future.plan = NULL)
[17:47:31.864]                   if (is.na(NA_character_)) 
[17:47:31.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.864]                     .init = FALSE)
[17:47:31.864]                 }
[17:47:31.864]             }
[17:47:31.864]         }
[17:47:31.864]     })
[17:47:31.864]     if (TRUE) {
[17:47:31.864]         base::sink(type = "output", split = FALSE)
[17:47:31.864]         if (TRUE) {
[17:47:31.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.864]         }
[17:47:31.864]         else {
[17:47:31.864]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.864]         }
[17:47:31.864]         base::close(...future.stdout)
[17:47:31.864]         ...future.stdout <- NULL
[17:47:31.864]     }
[17:47:31.864]     ...future.result$conditions <- ...future.conditions
[17:47:31.864]     ...future.result$finished <- base::Sys.time()
[17:47:31.864]     ...future.result
[17:47:31.864] }
[17:47:31.867] assign_globals() ...
[17:47:31.867] List of 1
[17:47:31.867]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:31.867]   ..$ a: int [1:3] 1 2 3
[17:47:31.867]   ..$ b: int [1:3] 3 2 1
[17:47:31.867]  - attr(*, "where")=List of 1
[17:47:31.867]   ..$ data:<environment: R_EmptyEnv> 
[17:47:31.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.867]  - attr(*, "resolved")= logi FALSE
[17:47:31.867]  - attr(*, "total_size")= num 128
[17:47:31.867]  - attr(*, "already-done")= logi TRUE
[17:47:31.870] - copied ‘data’ to environment
[17:47:31.870] assign_globals() ... done
[17:47:31.871] requestCore(): workers = 2
[17:47:31.873] MulticoreFuture started
[17:47:31.873] - Launch lazy future ... done
[17:47:31.873] run() for ‘MulticoreFuture’ ... done
[17:47:31.874] result() for MulticoreFuture ...
[17:47:31.874] plan(): Setting new future strategy stack:
[17:47:31.874] List of future strategies:
[17:47:31.874] 1. multicore:
[17:47:31.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.874]    - tweaked: FALSE
[17:47:31.874]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.880] plan(): nbrOfWorkers() = 1
[17:47:31.915] plan(): Setting new future strategy stack:
[17:47:31.915] List of future strategies:
[17:47:31.915] 1. multicore:
[17:47:31.915]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.915]    - tweaked: FALSE
[17:47:31.915]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.915] 2. multicore:
[17:47:31.915]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.915]    - tweaked: FALSE
[17:47:31.915]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.920] plan(): nbrOfWorkers() = 2
[17:47:31.921] result() for MulticoreFuture ...
[17:47:31.921] result() for MulticoreFuture ... done
[17:47:31.921] signalConditions() ...
[17:47:31.921]  - include = ‘immediateCondition’
[17:47:31.921]  - exclude = 
[17:47:31.922]  - resignal = FALSE
[17:47:31.922]  - Number of conditions: 52
[17:47:31.922] signalConditions() ... done
[17:47:31.922] result() for MulticoreFuture ... done
[17:47:31.922] result() for MulticoreFuture ...
[17:47:31.922] result() for MulticoreFuture ... done
[17:47:31.923] signalConditions() ...
[17:47:31.923]  - include = ‘immediateCondition’
[17:47:31.923]  - exclude = 
[17:47:31.923]  - resignal = FALSE
[17:47:31.923]  - Number of conditions: 52
[17:47:31.923] signalConditions() ... done
[17:47:31.924] Future state: ‘finished’
[17:47:31.924] result() for MulticoreFuture ...
[17:47:31.924] result() for MulticoreFuture ... done
[17:47:31.924] signalConditions() ...
[17:47:31.924]  - include = ‘condition’
[17:47:31.924]  - exclude = ‘immediateCondition’
[17:47:31.924]  - resignal = TRUE
[17:47:31.925]  - Number of conditions: 52
[17:47:31.925]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.881] getGlobalsAndPackages() ...
[17:47:31.925]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.881] Searching for globals...
[17:47:31.925]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.883] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:31.925]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.883] Searching for globals ... DONE
[17:47:31.926]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.883] Resolving globals: FALSE
[17:47:31.926]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.884] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:31.926]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.884] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:31.926]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.885] - globals: [1] ‘data’
[17:47:31.926]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.885] 
[17:47:31.926]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.885] getGlobalsAndPackages() ... DONE
[17:47:31.927]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.886] run() for ‘Future’ ...
[17:47:31.927]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.886] - state: ‘created’
[17:47:31.927]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.886] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.927]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.890] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:31.927]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:31.927]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.891]   - Field: ‘label’
[17:47:31.927]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.891]   - Field: ‘local’
[17:47:31.928]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.891]   - Field: ‘owner’
[17:47:31.928]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.891]   - Field: ‘envir’
[17:47:31.928]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.891]   - Field: ‘packages’
[17:47:31.928]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.892]   - Field: ‘gc’
[17:47:31.928]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.892]   - Field: ‘conditions’
[17:47:31.928]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.892]   - Field: ‘expr’
[17:47:31.929]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.892]   - Field: ‘uuid’
[17:47:31.929]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.892]   - Field: ‘seed’
[17:47:31.929]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.892]   - Field: ‘version’
[17:47:31.929]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘result’
[17:47:31.929]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘asynchronous’
[17:47:31.929]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘calls’
[17:47:31.929]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘globals’
[17:47:31.930]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘stdout’
[17:47:31.930]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘earlySignal’
[17:47:31.930]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.893]   - Field: ‘lazy’
[17:47:31.930]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.894]   - Field: ‘state’
[17:47:31.930]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:31.930]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.894] - Launch lazy future ...
[17:47:31.930]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.894] Packages needed by the future expression (n = 0): <none>
[17:47:31.931]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.894] Packages needed by future strategies (n = 0): <none>
[17:47:31.931]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.895] {
[17:47:31.895]     {
[17:47:31.895]         {
[17:47:31.895]             ...future.startTime <- base::Sys.time()
[17:47:31.895]             {
[17:47:31.895]                 {
[17:47:31.895]                   {
[17:47:31.895]                     base::local({
[17:47:31.895]                       has_future <- base::requireNamespace("future", 
[17:47:31.895]                         quietly = TRUE)
[17:47:31.895]                       if (has_future) {
[17:47:31.895]                         ns <- base::getNamespace("future")
[17:47:31.895]                         version <- ns[[".package"]][["version"]]
[17:47:31.895]                         if (is.null(version)) 
[17:47:31.895]                           version <- utils::packageVersion("future")
[17:47:31.895]                       }
[17:47:31.895]                       else {
[17:47:31.895]                         version <- NULL
[17:47:31.895]                       }
[17:47:31.895]                       if (!has_future || version < "1.8.0") {
[17:47:31.895]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.895]                           "", base::R.version$version.string), 
[17:47:31.895]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:31.895]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:31.895]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.895]                             "release", "version")], collapse = " "), 
[17:47:31.895]                           hostname = base::Sys.info()[["nodename"]])
[17:47:31.895]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.895]                           info)
[17:47:31.895]                         info <- base::paste(info, collapse = "; ")
[17:47:31.895]                         if (!has_future) {
[17:47:31.895]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.895]                             info)
[17:47:31.895]                         }
[17:47:31.895]                         else {
[17:47:31.895]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.895]                             info, version)
[17:47:31.895]                         }
[17:47:31.895]                         base::stop(msg)
[17:47:31.895]                       }
[17:47:31.895]                     })
[17:47:31.895]                   }
[17:47:31.895]                   ...future.strategy.old <- future::plan("list")
[17:47:31.895]                   options(future.plan = NULL)
[17:47:31.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:31.895]                 }
[17:47:31.895]                 ...future.workdir <- getwd()
[17:47:31.895]             }
[17:47:31.895]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.895]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.895]         }
[17:47:31.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.895]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.895]             base::names(...future.oldOptions))
[17:47:31.895]     }
[17:47:31.895]     if (FALSE) {
[17:47:31.895]     }
[17:47:31.895]     else {
[17:47:31.895]         if (TRUE) {
[17:47:31.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.895]                 open = "w")
[17:47:31.895]         }
[17:47:31.895]         else {
[17:47:31.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.895]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.895]         }
[17:47:31.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.895]             base::sink(type = "output", split = FALSE)
[17:47:31.895]             base::close(...future.stdout)
[17:47:31.895]         }, add = TRUE)
[17:47:31.895]     }
[17:47:31.895]     ...future.frame <- base::sys.nframe()
[17:47:31.895]     ...future.conditions <- base::list()
[17:47:31.895]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.895]     if (FALSE) {
[17:47:31.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.895]     }
[17:47:31.895]     ...future.result <- base::tryCatch({
[17:47:31.895]         base::withCallingHandlers({
[17:47:31.895]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:47:31.895]                 a == 2)))
[17:47:31.895]             future::FutureResult(value = ...future.value$value, 
[17:47:31.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.895]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.895]                     ...future.globalenv.names))
[17:47:31.895]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.895]         }, condition = base::local({
[17:47:31.895]             c <- base::c
[17:47:31.895]             inherits <- base::inherits
[17:47:31.895]             invokeRestart <- base::invokeRestart
[17:47:31.895]             length <- base::length
[17:47:31.895]             list <- base::list
[17:47:31.895]             seq.int <- base::seq.int
[17:47:31.895]             signalCondition <- base::signalCondition
[17:47:31.895]             sys.calls <- base::sys.calls
[17:47:31.895]             `[[` <- base::`[[`
[17:47:31.895]             `+` <- base::`+`
[17:47:31.895]             `<<-` <- base::`<<-`
[17:47:31.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.895]                   3L)]
[17:47:31.895]             }
[17:47:31.895]             function(cond) {
[17:47:31.895]                 is_error <- inherits(cond, "error")
[17:47:31.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.895]                   NULL)
[17:47:31.895]                 if (is_error) {
[17:47:31.895]                   sessionInformation <- function() {
[17:47:31.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.895]                       search = base::search(), system = base::Sys.info())
[17:47:31.895]                   }
[17:47:31.895]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.895]                     cond$call), session = sessionInformation(), 
[17:47:31.895]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.895]                   signalCondition(cond)
[17:47:31.895]                 }
[17:47:31.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.895]                 "immediateCondition"))) {
[17:47:31.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.895]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.895]                   if (TRUE && !signal) {
[17:47:31.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.895]                     {
[17:47:31.895]                       inherits <- base::inherits
[17:47:31.895]                       invokeRestart <- base::invokeRestart
[17:47:31.895]                       is.null <- base::is.null
[17:47:31.895]                       muffled <- FALSE
[17:47:31.895]                       if (inherits(cond, "message")) {
[17:47:31.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.895]                         if (muffled) 
[17:47:31.895]                           invokeRestart("muffleMessage")
[17:47:31.895]                       }
[17:47:31.895]                       else if (inherits(cond, "warning")) {
[17:47:31.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.895]                         if (muffled) 
[17:47:31.895]                           invokeRestart("muffleWarning")
[17:47:31.895]                       }
[17:47:31.895]                       else if (inherits(cond, "condition")) {
[17:47:31.895]                         if (!is.null(pattern)) {
[17:47:31.895]                           computeRestarts <- base::computeRestarts
[17:47:31.895]                           grepl <- base::grepl
[17:47:31.895]                           restarts <- computeRestarts(cond)
[17:47:31.895]                           for (restart in restarts) {
[17:47:31.895]                             name <- restart$name
[17:47:31.895]                             if (is.null(name)) 
[17:47:31.895]                               next
[17:47:31.895]                             if (!grepl(pattern, name)) 
[17:47:31.895]                               next
[17:47:31.895]                             invokeRestart(restart)
[17:47:31.895]                             muffled <- TRUE
[17:47:31.895]                             break
[17:47:31.895]                           }
[17:47:31.895]                         }
[17:47:31.895]                       }
[17:47:31.895]                       invisible(muffled)
[17:47:31.895]                     }
[17:47:31.895]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.895]                   }
[17:47:31.895]                 }
[17:47:31.895]                 else {
[17:47:31.895]                   if (TRUE) {
[17:47:31.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.895]                     {
[17:47:31.895]                       inherits <- base::inherits
[17:47:31.895]                       invokeRestart <- base::invokeRestart
[17:47:31.895]                       is.null <- base::is.null
[17:47:31.895]                       muffled <- FALSE
[17:47:31.895]                       if (inherits(cond, "message")) {
[17:47:31.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.895]                         if (muffled) 
[17:47:31.895]                           invokeRestart("muffleMessage")
[17:47:31.895]                       }
[17:47:31.895]                       else if (inherits(cond, "warning")) {
[17:47:31.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.895]                         if (muffled) 
[17:47:31.895]                           invokeRestart("muffleWarning")
[17:47:31.895]                       }
[17:47:31.895]                       else if (inherits(cond, "condition")) {
[17:47:31.895]                         if (!is.null(pattern)) {
[17:47:31.895]                           computeRestarts <- base::computeRestarts
[17:47:31.895]                           grepl <- base::grepl
[17:47:31.895]                           restarts <- computeRestarts(cond)
[17:47:31.895]                           for (restart in restarts) {
[17:47:31.895]                             name <- restart$name
[17:47:31.895]                             if (is.null(name)) 
[17:47:31.895]                               next
[17:47:31.895]                             if (!grepl(pattern, name)) 
[17:47:31.895]                               next
[17:47:31.895]                             invokeRestart(restart)
[17:47:31.895]                             muffled <- TRUE
[17:47:31.895]                             break
[17:47:31.895]                           }
[17:47:31.895]                         }
[17:47:31.895]                       }
[17:47:31.895]                       invisible(muffled)
[17:47:31.895]                     }
[17:47:31.895]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.895]                   }
[17:47:31.895]                 }
[17:47:31.895]             }
[17:47:31.895]         }))
[17:47:31.895]     }, error = function(ex) {
[17:47:31.895]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.895]                 ...future.rng), started = ...future.startTime, 
[17:47:31.895]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.895]             version = "1.8"), class = "FutureResult")
[17:47:31.895]     }, finally = {
[17:47:31.895]         if (!identical(...future.workdir, getwd())) 
[17:47:31.895]             setwd(...future.workdir)
[17:47:31.895]         {
[17:47:31.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.895]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.895]             }
[17:47:31.895]             base::options(...future.oldOptions)
[17:47:31.895]             if (.Platform$OS.type == "windows") {
[17:47:31.895]                 old_names <- names(...future.oldEnvVars)
[17:47:31.895]                 envs <- base::Sys.getenv()
[17:47:31.895]                 names <- names(envs)
[17:47:31.895]                 common <- intersect(names, old_names)
[17:47:31.895]                 added <- setdiff(names, old_names)
[17:47:31.895]                 removed <- setdiff(old_names, names)
[17:47:31.895]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.895]                   envs[common]]
[17:47:31.895]                 NAMES <- toupper(changed)
[17:47:31.895]                 args <- list()
[17:47:31.895]                 for (kk in seq_along(NAMES)) {
[17:47:31.895]                   name <- changed[[kk]]
[17:47:31.895]                   NAME <- NAMES[[kk]]
[17:47:31.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.895]                     next
[17:47:31.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.895]                 }
[17:47:31.895]                 NAMES <- toupper(added)
[17:47:31.895]                 for (kk in seq_along(NAMES)) {
[17:47:31.895]                   name <- added[[kk]]
[17:47:31.895]                   NAME <- NAMES[[kk]]
[17:47:31.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.895]                     next
[17:47:31.895]                   args[[name]] <- ""
[17:47:31.895]                 }
[17:47:31.895]                 NAMES <- toupper(removed)
[17:47:31.895]                 for (kk in seq_along(NAMES)) {
[17:47:31.895]                   name <- removed[[kk]]
[17:47:31.895]                   NAME <- NAMES[[kk]]
[17:47:31.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.895]                     next
[17:47:31.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.895]                 }
[17:47:31.895]                 if (length(args) > 0) 
[17:47:31.895]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.895]             }
[17:47:31.895]             else {
[17:47:31.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.895]             }
[17:47:31.895]             {
[17:47:31.895]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.895]                   0L) {
[17:47:31.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.895]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.895]                   base::options(opts)
[17:47:31.895]                 }
[17:47:31.895]                 {
[17:47:31.895]                   {
[17:47:31.895]                     NULL
[17:47:31.895]                     RNGkind("Mersenne-Twister")
[17:47:31.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:31.895]                       inherits = FALSE)
[17:47:31.895]                   }
[17:47:31.895]                   options(future.plan = NULL)
[17:47:31.895]                   if (is.na(NA_character_)) 
[17:47:31.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.895]                     .init = FALSE)
[17:47:31.895]                 }
[17:47:31.895]             }
[17:47:31.895]         }
[17:47:31.895]     })
[17:47:31.895]     if (TRUE) {
[17:47:31.895]         base::sink(type = "output", split = FALSE)
[17:47:31.895]         if (TRUE) {
[17:47:31.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.895]         }
[17:47:31.895]         else {
[17:47:31.895]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.895]         }
[17:47:31.895]         base::close(...future.stdout)
[17:47:31.895]         ...future.stdout <- NULL
[17:47:31.895]     }
[17:47:31.895]     ...future.result$conditions <- ...future.conditions
[17:47:31.895]     ...future.result$finished <- base::Sys.time()
[17:47:31.895]     ...future.result
[17:47:31.895] }
[17:47:31.931]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.897] assign_globals() ...
[17:47:31.931]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.897] List of 1
[17:47:31.897]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:31.897]   ..$ a: int [1:3] 1 2 3
[17:47:31.897]   ..$ b: int [1:3] 3 2 1
[17:47:31.897]  - attr(*, "where")=List of 1
[17:47:31.897]   ..$ data:<environment: R_EmptyEnv> 
[17:47:31.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.897]  - attr(*, "resolved")= logi FALSE
[17:47:31.897]  - attr(*, "total_size")= num 128
[17:47:31.897]  - attr(*, "already-done")= logi TRUE
[17:47:31.931]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.902] - copied ‘data’ to environment
[17:47:31.931]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.902] assign_globals() ... done
[17:47:31.932]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.903] plan(): Setting new future strategy stack:
[17:47:31.932]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.903] List of future strategies:
[17:47:31.903] 1. sequential:
[17:47:31.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:31.903]    - tweaked: FALSE
[17:47:31.903]    - call: NULL
[17:47:31.932]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.903] plan(): nbrOfWorkers() = 1
[17:47:31.932]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.904] plan(): Setting new future strategy stack:
[17:47:31.932]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.905] List of future strategies:
[17:47:31.905] 1. multicore:
[17:47:31.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.905]    - tweaked: FALSE
[17:47:31.905]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.932]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.908] plan(): nbrOfWorkers() = 1
[17:47:31.932]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.909] SequentialFuture started (and completed)
[17:47:31.933]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.909] - Launch lazy future ... done
[17:47:31.933]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.909] run() for ‘SequentialFuture’ ... done
[17:47:31.933] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[17:47:31.933] plan(): Setting new future strategy stack:
[17:47:31.933] List of future strategies:
[17:47:31.933] 1. multicore:
[17:47:31.933]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:31.933]    - tweaked: FALSE
[17:47:31.933]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.933] 2. multisession:
[17:47:31.933]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:31.933]    - tweaked: FALSE
[17:47:31.933]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.938] plan(): nbrOfWorkers() = 2
[17:47:31.938] getGlobalsAndPackages() ...
[17:47:31.938] Searching for globals...
[17:47:31.961] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:31.962] Searching for globals ... DONE
[17:47:31.962] Resolving globals: FALSE
[17:47:31.963] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[17:47:31.963] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:31.964] - globals: [2] ‘nested’, ‘strategy2’
[17:47:31.964] - packages: [1] ‘future’
[17:47:31.964] getGlobalsAndPackages() ... DONE
[17:47:31.964] run() for ‘Future’ ...
[17:47:31.964] - state: ‘created’
[17:47:31.964] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:31.968] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:31.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:31.969]   - Field: ‘label’
[17:47:31.969]   - Field: ‘local’
[17:47:31.969]   - Field: ‘owner’
[17:47:31.969]   - Field: ‘envir’
[17:47:31.969]   - Field: ‘workers’
[17:47:31.969]   - Field: ‘packages’
[17:47:31.969]   - Field: ‘gc’
[17:47:31.969]   - Field: ‘job’
[17:47:31.970]   - Field: ‘conditions’
[17:47:31.970]   - Field: ‘expr’
[17:47:31.970]   - Field: ‘uuid’
[17:47:31.970]   - Field: ‘seed’
[17:47:31.970]   - Field: ‘version’
[17:47:31.970]   - Field: ‘result’
[17:47:31.970]   - Field: ‘asynchronous’
[17:47:31.970]   - Field: ‘calls’
[17:47:31.970]   - Field: ‘globals’
[17:47:31.970]   - Field: ‘stdout’
[17:47:31.971]   - Field: ‘earlySignal’
[17:47:31.971]   - Field: ‘lazy’
[17:47:31.971]   - Field: ‘state’
[17:47:31.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:31.971] - Launch lazy future ...
[17:47:31.971] Packages needed by the future expression (n = 1): ‘future’
[17:47:31.972] Packages needed by future strategies (n = 1): ‘future’
[17:47:31.972] {
[17:47:31.972]     {
[17:47:31.972]         {
[17:47:31.972]             ...future.startTime <- base::Sys.time()
[17:47:31.972]             {
[17:47:31.972]                 {
[17:47:31.972]                   {
[17:47:31.972]                     {
[17:47:31.972]                       {
[17:47:31.972]                         base::local({
[17:47:31.972]                           has_future <- base::requireNamespace("future", 
[17:47:31.972]                             quietly = TRUE)
[17:47:31.972]                           if (has_future) {
[17:47:31.972]                             ns <- base::getNamespace("future")
[17:47:31.972]                             version <- ns[[".package"]][["version"]]
[17:47:31.972]                             if (is.null(version)) 
[17:47:31.972]                               version <- utils::packageVersion("future")
[17:47:31.972]                           }
[17:47:31.972]                           else {
[17:47:31.972]                             version <- NULL
[17:47:31.972]                           }
[17:47:31.972]                           if (!has_future || version < "1.8.0") {
[17:47:31.972]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:31.972]                               "", base::R.version$version.string), 
[17:47:31.972]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:31.972]                                 base::R.version$platform, 8 * 
[17:47:31.972]                                   base::.Machine$sizeof.pointer), 
[17:47:31.972]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:31.972]                                 "release", "version")], collapse = " "), 
[17:47:31.972]                               hostname = base::Sys.info()[["nodename"]])
[17:47:31.972]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:31.972]                               info)
[17:47:31.972]                             info <- base::paste(info, collapse = "; ")
[17:47:31.972]                             if (!has_future) {
[17:47:31.972]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:31.972]                                 info)
[17:47:31.972]                             }
[17:47:31.972]                             else {
[17:47:31.972]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:31.972]                                 info, version)
[17:47:31.972]                             }
[17:47:31.972]                             base::stop(msg)
[17:47:31.972]                           }
[17:47:31.972]                         })
[17:47:31.972]                       }
[17:47:31.972]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:31.972]                       base::options(mc.cores = 1L)
[17:47:31.972]                     }
[17:47:31.972]                     base::local({
[17:47:31.972]                       for (pkg in "future") {
[17:47:31.972]                         base::loadNamespace(pkg)
[17:47:31.972]                         base::library(pkg, character.only = TRUE)
[17:47:31.972]                       }
[17:47:31.972]                     })
[17:47:31.972]                   }
[17:47:31.972]                   ...future.strategy.old <- future::plan("list")
[17:47:31.972]                   options(future.plan = NULL)
[17:47:31.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.972]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:31.972]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:31.972]                     envir = parent.frame()) 
[17:47:31.972]                   {
[17:47:31.972]                     if (is.function(workers)) 
[17:47:31.972]                       workers <- workers()
[17:47:31.972]                     workers <- structure(as.integer(workers), 
[17:47:31.972]                       class = class(workers))
[17:47:31.972]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:31.972]                       workers >= 1)
[17:47:31.972]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:31.972]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:31.972]                     }
[17:47:31.972]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:31.972]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:31.972]                       envir = envir)
[17:47:31.972]                     if (!future$lazy) 
[17:47:31.972]                       future <- run(future)
[17:47:31.972]                     invisible(future)
[17:47:31.972]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:31.972]                 }
[17:47:31.972]                 ...future.workdir <- getwd()
[17:47:31.972]             }
[17:47:31.972]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:31.972]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:31.972]         }
[17:47:31.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:31.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:31.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:31.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:31.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:31.972]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:31.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:31.972]             base::names(...future.oldOptions))
[17:47:31.972]     }
[17:47:31.972]     if (FALSE) {
[17:47:31.972]     }
[17:47:31.972]     else {
[17:47:31.972]         if (TRUE) {
[17:47:31.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:31.972]                 open = "w")
[17:47:31.972]         }
[17:47:31.972]         else {
[17:47:31.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:31.972]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:31.972]         }
[17:47:31.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:31.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:31.972]             base::sink(type = "output", split = FALSE)
[17:47:31.972]             base::close(...future.stdout)
[17:47:31.972]         }, add = TRUE)
[17:47:31.972]     }
[17:47:31.972]     ...future.frame <- base::sys.nframe()
[17:47:31.972]     ...future.conditions <- base::list()
[17:47:31.972]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:31.972]     if (FALSE) {
[17:47:31.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:31.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:31.972]     }
[17:47:31.972]     ...future.result <- base::tryCatch({
[17:47:31.972]         base::withCallingHandlers({
[17:47:31.972]             ...future.value <- base::withVisible(base::local({
[17:47:31.972]                 withCallingHandlers({
[17:47:31.972]                   {
[17:47:31.972]                     a <- 1L
[17:47:31.972]                     plan_a <- unclass(future::plan("list"))
[17:47:31.972]                     nested_a <- nested[-1]
[17:47:31.972]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:31.972]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:31.972]                       strategy2))
[17:47:31.972]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:31.972]                       "init") <- NULL
[17:47:31.972]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:31.972]                       "init") <- NULL
[17:47:31.972]                     stopifnot(all.equal(plan_a, nested_a))
[17:47:31.972]                     y %<-% {
[17:47:31.972]                       b <- 2L
[17:47:31.972]                       plan_b <- future::plan("list")
[17:47:31.972]                       nested_b <- nested_a[-1]
[17:47:31.972]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:31.972]                         1L, inherits(plan_b[[1]], "future"), 
[17:47:31.972]                         inherits(future::plan("next"), "sequential"))
[17:47:31.972]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:31.972]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:31.972]                     }
[17:47:31.972]                     y
[17:47:31.972]                   }
[17:47:31.972]                 }, immediateCondition = function(cond) {
[17:47:31.972]                   save_rds <- function (object, pathname, ...) 
[17:47:31.972]                   {
[17:47:31.972]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:31.972]                     if (file_test("-f", pathname_tmp)) {
[17:47:31.972]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.972]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:31.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.972]                         fi_tmp[["mtime"]])
[17:47:31.972]                     }
[17:47:31.972]                     tryCatch({
[17:47:31.972]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:31.972]                     }, error = function(ex) {
[17:47:31.972]                       msg <- conditionMessage(ex)
[17:47:31.972]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.972]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:31.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.972]                         fi_tmp[["mtime"]], msg)
[17:47:31.972]                       ex$message <- msg
[17:47:31.972]                       stop(ex)
[17:47:31.972]                     })
[17:47:31.972]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:31.972]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:31.972]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:31.972]                       fi_tmp <- file.info(pathname_tmp)
[17:47:31.972]                       fi <- file.info(pathname)
[17:47:31.972]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:31.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:31.972]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:31.972]                         fi[["size"]], fi[["mtime"]])
[17:47:31.972]                       stop(msg)
[17:47:31.972]                     }
[17:47:31.972]                     invisible(pathname)
[17:47:31.972]                   }
[17:47:31.972]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:31.972]                     rootPath = tempdir()) 
[17:47:31.972]                   {
[17:47:31.972]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:31.972]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:31.972]                       tmpdir = path, fileext = ".rds")
[17:47:31.972]                     save_rds(obj, file)
[17:47:31.972]                   }
[17:47:31.972]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:31.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.972]                   {
[17:47:31.972]                     inherits <- base::inherits
[17:47:31.972]                     invokeRestart <- base::invokeRestart
[17:47:31.972]                     is.null <- base::is.null
[17:47:31.972]                     muffled <- FALSE
[17:47:31.972]                     if (inherits(cond, "message")) {
[17:47:31.972]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:31.972]                       if (muffled) 
[17:47:31.972]                         invokeRestart("muffleMessage")
[17:47:31.972]                     }
[17:47:31.972]                     else if (inherits(cond, "warning")) {
[17:47:31.972]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:31.972]                       if (muffled) 
[17:47:31.972]                         invokeRestart("muffleWarning")
[17:47:31.972]                     }
[17:47:31.972]                     else if (inherits(cond, "condition")) {
[17:47:31.972]                       if (!is.null(pattern)) {
[17:47:31.972]                         computeRestarts <- base::computeRestarts
[17:47:31.972]                         grepl <- base::grepl
[17:47:31.972]                         restarts <- computeRestarts(cond)
[17:47:31.972]                         for (restart in restarts) {
[17:47:31.972]                           name <- restart$name
[17:47:31.972]                           if (is.null(name)) 
[17:47:31.972]                             next
[17:47:31.972]                           if (!grepl(pattern, name)) 
[17:47:31.972]                             next
[17:47:31.972]                           invokeRestart(restart)
[17:47:31.972]                           muffled <- TRUE
[17:47:31.972]                           break
[17:47:31.972]                         }
[17:47:31.972]                       }
[17:47:31.972]                     }
[17:47:31.972]                     invisible(muffled)
[17:47:31.972]                   }
[17:47:31.972]                   muffleCondition(cond)
[17:47:31.972]                 })
[17:47:31.972]             }))
[17:47:31.972]             future::FutureResult(value = ...future.value$value, 
[17:47:31.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.972]                   ...future.rng), globalenv = if (FALSE) 
[17:47:31.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:31.972]                     ...future.globalenv.names))
[17:47:31.972]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:31.972]         }, condition = base::local({
[17:47:31.972]             c <- base::c
[17:47:31.972]             inherits <- base::inherits
[17:47:31.972]             invokeRestart <- base::invokeRestart
[17:47:31.972]             length <- base::length
[17:47:31.972]             list <- base::list
[17:47:31.972]             seq.int <- base::seq.int
[17:47:31.972]             signalCondition <- base::signalCondition
[17:47:31.972]             sys.calls <- base::sys.calls
[17:47:31.972]             `[[` <- base::`[[`
[17:47:31.972]             `+` <- base::`+`
[17:47:31.972]             `<<-` <- base::`<<-`
[17:47:31.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:31.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:31.972]                   3L)]
[17:47:31.972]             }
[17:47:31.972]             function(cond) {
[17:47:31.972]                 is_error <- inherits(cond, "error")
[17:47:31.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:31.972]                   NULL)
[17:47:31.972]                 if (is_error) {
[17:47:31.972]                   sessionInformation <- function() {
[17:47:31.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:31.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:31.972]                       search = base::search(), system = base::Sys.info())
[17:47:31.972]                   }
[17:47:31.972]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:31.972]                     cond$call), session = sessionInformation(), 
[17:47:31.972]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:31.972]                   signalCondition(cond)
[17:47:31.972]                 }
[17:47:31.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:31.972]                 "immediateCondition"))) {
[17:47:31.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:31.972]                   ...future.conditions[[length(...future.conditions) + 
[17:47:31.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:31.972]                   if (TRUE && !signal) {
[17:47:31.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.972]                     {
[17:47:31.972]                       inherits <- base::inherits
[17:47:31.972]                       invokeRestart <- base::invokeRestart
[17:47:31.972]                       is.null <- base::is.null
[17:47:31.972]                       muffled <- FALSE
[17:47:31.972]                       if (inherits(cond, "message")) {
[17:47:31.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.972]                         if (muffled) 
[17:47:31.972]                           invokeRestart("muffleMessage")
[17:47:31.972]                       }
[17:47:31.972]                       else if (inherits(cond, "warning")) {
[17:47:31.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.972]                         if (muffled) 
[17:47:31.972]                           invokeRestart("muffleWarning")
[17:47:31.972]                       }
[17:47:31.972]                       else if (inherits(cond, "condition")) {
[17:47:31.972]                         if (!is.null(pattern)) {
[17:47:31.972]                           computeRestarts <- base::computeRestarts
[17:47:31.972]                           grepl <- base::grepl
[17:47:31.972]                           restarts <- computeRestarts(cond)
[17:47:31.972]                           for (restart in restarts) {
[17:47:31.972]                             name <- restart$name
[17:47:31.972]                             if (is.null(name)) 
[17:47:31.972]                               next
[17:47:31.972]                             if (!grepl(pattern, name)) 
[17:47:31.972]                               next
[17:47:31.972]                             invokeRestart(restart)
[17:47:31.972]                             muffled <- TRUE
[17:47:31.972]                             break
[17:47:31.972]                           }
[17:47:31.972]                         }
[17:47:31.972]                       }
[17:47:31.972]                       invisible(muffled)
[17:47:31.972]                     }
[17:47:31.972]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.972]                   }
[17:47:31.972]                 }
[17:47:31.972]                 else {
[17:47:31.972]                   if (TRUE) {
[17:47:31.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:31.972]                     {
[17:47:31.972]                       inherits <- base::inherits
[17:47:31.972]                       invokeRestart <- base::invokeRestart
[17:47:31.972]                       is.null <- base::is.null
[17:47:31.972]                       muffled <- FALSE
[17:47:31.972]                       if (inherits(cond, "message")) {
[17:47:31.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:31.972]                         if (muffled) 
[17:47:31.972]                           invokeRestart("muffleMessage")
[17:47:31.972]                       }
[17:47:31.972]                       else if (inherits(cond, "warning")) {
[17:47:31.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:31.972]                         if (muffled) 
[17:47:31.972]                           invokeRestart("muffleWarning")
[17:47:31.972]                       }
[17:47:31.972]                       else if (inherits(cond, "condition")) {
[17:47:31.972]                         if (!is.null(pattern)) {
[17:47:31.972]                           computeRestarts <- base::computeRestarts
[17:47:31.972]                           grepl <- base::grepl
[17:47:31.972]                           restarts <- computeRestarts(cond)
[17:47:31.972]                           for (restart in restarts) {
[17:47:31.972]                             name <- restart$name
[17:47:31.972]                             if (is.null(name)) 
[17:47:31.972]                               next
[17:47:31.972]                             if (!grepl(pattern, name)) 
[17:47:31.972]                               next
[17:47:31.972]                             invokeRestart(restart)
[17:47:31.972]                             muffled <- TRUE
[17:47:31.972]                             break
[17:47:31.972]                           }
[17:47:31.972]                         }
[17:47:31.972]                       }
[17:47:31.972]                       invisible(muffled)
[17:47:31.972]                     }
[17:47:31.972]                     muffleCondition(cond, pattern = "^muffle")
[17:47:31.972]                   }
[17:47:31.972]                 }
[17:47:31.972]             }
[17:47:31.972]         }))
[17:47:31.972]     }, error = function(ex) {
[17:47:31.972]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:31.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:31.972]                 ...future.rng), started = ...future.startTime, 
[17:47:31.972]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:31.972]             version = "1.8"), class = "FutureResult")
[17:47:31.972]     }, finally = {
[17:47:31.972]         if (!identical(...future.workdir, getwd())) 
[17:47:31.972]             setwd(...future.workdir)
[17:47:31.972]         {
[17:47:31.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:31.972]                 ...future.oldOptions$nwarnings <- NULL
[17:47:31.972]             }
[17:47:31.972]             base::options(...future.oldOptions)
[17:47:31.972]             if (.Platform$OS.type == "windows") {
[17:47:31.972]                 old_names <- names(...future.oldEnvVars)
[17:47:31.972]                 envs <- base::Sys.getenv()
[17:47:31.972]                 names <- names(envs)
[17:47:31.972]                 common <- intersect(names, old_names)
[17:47:31.972]                 added <- setdiff(names, old_names)
[17:47:31.972]                 removed <- setdiff(old_names, names)
[17:47:31.972]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:31.972]                   envs[common]]
[17:47:31.972]                 NAMES <- toupper(changed)
[17:47:31.972]                 args <- list()
[17:47:31.972]                 for (kk in seq_along(NAMES)) {
[17:47:31.972]                   name <- changed[[kk]]
[17:47:31.972]                   NAME <- NAMES[[kk]]
[17:47:31.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.972]                     next
[17:47:31.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.972]                 }
[17:47:31.972]                 NAMES <- toupper(added)
[17:47:31.972]                 for (kk in seq_along(NAMES)) {
[17:47:31.972]                   name <- added[[kk]]
[17:47:31.972]                   NAME <- NAMES[[kk]]
[17:47:31.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.972]                     next
[17:47:31.972]                   args[[name]] <- ""
[17:47:31.972]                 }
[17:47:31.972]                 NAMES <- toupper(removed)
[17:47:31.972]                 for (kk in seq_along(NAMES)) {
[17:47:31.972]                   name <- removed[[kk]]
[17:47:31.972]                   NAME <- NAMES[[kk]]
[17:47:31.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:31.972]                     next
[17:47:31.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:31.972]                 }
[17:47:31.972]                 if (length(args) > 0) 
[17:47:31.972]                   base::do.call(base::Sys.setenv, args = args)
[17:47:31.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:31.972]             }
[17:47:31.972]             else {
[17:47:31.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:31.972]             }
[17:47:31.972]             {
[17:47:31.972]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:31.972]                   0L) {
[17:47:31.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:31.972]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:31.972]                   base::options(opts)
[17:47:31.972]                 }
[17:47:31.972]                 {
[17:47:31.972]                   {
[17:47:31.972]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:31.972]                     NULL
[17:47:31.972]                   }
[17:47:31.972]                   options(future.plan = NULL)
[17:47:31.972]                   if (is.na(NA_character_)) 
[17:47:31.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:31.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:31.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:31.972]                     .init = FALSE)
[17:47:31.972]                 }
[17:47:31.972]             }
[17:47:31.972]         }
[17:47:31.972]     })
[17:47:31.972]     if (TRUE) {
[17:47:31.972]         base::sink(type = "output", split = FALSE)
[17:47:31.972]         if (TRUE) {
[17:47:31.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:31.972]         }
[17:47:31.972]         else {
[17:47:31.972]             ...future.result["stdout"] <- base::list(NULL)
[17:47:31.972]         }
[17:47:31.972]         base::close(...future.stdout)
[17:47:31.972]         ...future.stdout <- NULL
[17:47:31.972]     }
[17:47:31.972]     ...future.result$conditions <- ...future.conditions
[17:47:31.972]     ...future.result$finished <- base::Sys.time()
[17:47:31.972]     ...future.result
[17:47:31.972] }
[17:47:31.975] assign_globals() ...
[17:47:31.975] List of 2
[17:47:31.975]  $ nested   :List of 2
[17:47:31.975]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:47:31.975]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:47:31.975]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.975]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:31.975]     envir = parent.frame())  
[17:47:31.975]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:47:31.975]   .. ..- attr(*, "init")= logi TRUE
[17:47:31.975]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:47:31.975]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:31.975]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:31.975]  $ strategy2: chr "multisession"
[17:47:31.975]  - attr(*, "where")=List of 2
[17:47:31.975]   ..$ nested   :<environment: R_EmptyEnv> 
[17:47:31.975]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:47:31.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:31.975]  - attr(*, "resolved")= logi FALSE
[17:47:31.975]  - attr(*, "total_size")= num 92816
[17:47:31.975]  - attr(*, "already-done")= logi TRUE
[17:47:31.981] - copied ‘nested’ to environment
[17:47:31.981] - copied ‘strategy2’ to environment
[17:47:31.981] assign_globals() ... done
[17:47:31.981] requestCore(): workers = 2
[17:47:31.984] MulticoreFuture started
[17:47:31.984] - Launch lazy future ... done
[17:47:31.984] run() for ‘MulticoreFuture’ ... done
[17:47:31.985] result() for MulticoreFuture ...
[17:47:31.985] plan(): Setting new future strategy stack:
[17:47:31.985] List of future strategies:
[17:47:31.985] 1. multisession:
[17:47:31.985]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:31.985]    - tweaked: FALSE
[17:47:31.985]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:31.991] plan(): nbrOfWorkers() = 1
[17:47:32.031] plan(): Setting new future strategy stack:
[17:47:32.031] List of future strategies:
[17:47:32.031] 1. multicore:
[17:47:32.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:32.031]    - tweaked: FALSE
[17:47:32.031]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.031] 2. multisession:
[17:47:32.031]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.031]    - tweaked: FALSE
[17:47:32.031]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.035] plan(): nbrOfWorkers() = 2
[17:47:32.037] result() for MulticoreFuture ...
[17:47:32.037] result() for MulticoreFuture ... done
[17:47:32.037] signalConditions() ...
[17:47:32.037]  - include = ‘immediateCondition’
[17:47:32.037]  - exclude = 
[17:47:32.037]  - resignal = FALSE
[17:47:32.037]  - Number of conditions: 54
[17:47:32.038] signalConditions() ... done
[17:47:32.038] result() for MulticoreFuture ... done
[17:47:32.038] result() for MulticoreFuture ...
[17:47:32.038] result() for MulticoreFuture ... done
[17:47:32.038] signalConditions() ...
[17:47:32.038]  - include = ‘immediateCondition’
[17:47:32.038]  - exclude = 
[17:47:32.038]  - resignal = FALSE
[17:47:32.038]  - Number of conditions: 54
[17:47:32.039] signalConditions() ... done
[17:47:32.039] Future state: ‘finished’
[17:47:32.039] result() for MulticoreFuture ...
[17:47:32.039] result() for MulticoreFuture ... done
[17:47:32.039] signalConditions() ...
[17:47:32.039]  - include = ‘condition’
[17:47:32.039]  - exclude = ‘immediateCondition’
[17:47:32.039]  - resignal = TRUE
[17:47:32.040]  - Number of conditions: 54
[17:47:32.040]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.993] getGlobalsAndPackages() ...
[17:47:32.040]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:31.993] Searching for globals...
[17:47:32.040]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.000] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:47:32.040]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.001] Searching for globals ... DONE
[17:47:32.040]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.001] Resolving globals: FALSE
[17:47:32.040]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.002] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[17:47:32.041]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.002] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:47:32.041]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.003] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:47:32.041]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.003] 
[17:47:32.041]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.003] getGlobalsAndPackages() ... DONE
[17:47:32.041]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.004] run() for ‘Future’ ...
[17:47:32.041]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.004] - state: ‘created’
[17:47:32.041]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:32.042]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:32.042]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:32.042]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.009]   - Field: ‘label’
[17:47:32.042]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.009]   - Field: ‘local’
[17:47:32.042]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.009]   - Field: ‘owner’
[17:47:32.042]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.009]   - Field: ‘envir’
[17:47:32.043]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.009]   - Field: ‘packages’
[17:47:32.043]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.009]   - Field: ‘gc’
[17:47:32.043]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘conditions’
[17:47:32.043]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘expr’
[17:47:32.043]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘uuid’
[17:47:32.043]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘seed’
[17:47:32.043]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘version’
[17:47:32.044]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘result’
[17:47:32.044]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.010]   - Field: ‘asynchronous’
[17:47:32.044]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.011]   - Field: ‘calls’
[17:47:32.044]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.011]   - Field: ‘globals’
[17:47:32.044]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.011]   - Field: ‘stdout’
[17:47:32.044]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.011]   - Field: ‘earlySignal’
[17:47:32.044]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.011]   - Field: ‘lazy’
[17:47:32.045]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.011]   - Field: ‘state’
[17:47:32.045]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:32.045]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.012] - Launch lazy future ...
[17:47:32.045]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.012] Packages needed by the future expression (n = 0): <none>
[17:47:32.045]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.012] Packages needed by future strategies (n = 0): <none>
[17:47:32.045]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.013] {
[17:47:32.013]     {
[17:47:32.013]         {
[17:47:32.013]             ...future.startTime <- base::Sys.time()
[17:47:32.013]             {
[17:47:32.013]                 {
[17:47:32.013]                   {
[17:47:32.013]                     base::local({
[17:47:32.013]                       has_future <- base::requireNamespace("future", 
[17:47:32.013]                         quietly = TRUE)
[17:47:32.013]                       if (has_future) {
[17:47:32.013]                         ns <- base::getNamespace("future")
[17:47:32.013]                         version <- ns[[".package"]][["version"]]
[17:47:32.013]                         if (is.null(version)) 
[17:47:32.013]                           version <- utils::packageVersion("future")
[17:47:32.013]                       }
[17:47:32.013]                       else {
[17:47:32.013]                         version <- NULL
[17:47:32.013]                       }
[17:47:32.013]                       if (!has_future || version < "1.8.0") {
[17:47:32.013]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:32.013]                           "", base::R.version$version.string), 
[17:47:32.013]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:32.013]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:32.013]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:32.013]                             "release", "version")], collapse = " "), 
[17:47:32.013]                           hostname = base::Sys.info()[["nodename"]])
[17:47:32.013]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:32.013]                           info)
[17:47:32.013]                         info <- base::paste(info, collapse = "; ")
[17:47:32.013]                         if (!has_future) {
[17:47:32.013]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:32.013]                             info)
[17:47:32.013]                         }
[17:47:32.013]                         else {
[17:47:32.013]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:32.013]                             info, version)
[17:47:32.013]                         }
[17:47:32.013]                         base::stop(msg)
[17:47:32.013]                       }
[17:47:32.013]                     })
[17:47:32.013]                   }
[17:47:32.013]                   ...future.strategy.old <- future::plan("list")
[17:47:32.013]                   options(future.plan = NULL)
[17:47:32.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:32.013]                 }
[17:47:32.013]                 ...future.workdir <- getwd()
[17:47:32.013]             }
[17:47:32.013]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:32.013]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:32.013]         }
[17:47:32.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:32.013]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:32.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:32.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:32.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:32.013]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:32.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:32.013]             base::names(...future.oldOptions))
[17:47:32.013]     }
[17:47:32.013]     if (FALSE) {
[17:47:32.013]     }
[17:47:32.013]     else {
[17:47:32.013]         if (TRUE) {
[17:47:32.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:32.013]                 open = "w")
[17:47:32.013]         }
[17:47:32.013]         else {
[17:47:32.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:32.013]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:32.013]         }
[17:47:32.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:32.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:32.013]             base::sink(type = "output", split = FALSE)
[17:47:32.013]             base::close(...future.stdout)
[17:47:32.013]         }, add = TRUE)
[17:47:32.013]     }
[17:47:32.013]     ...future.frame <- base::sys.nframe()
[17:47:32.013]     ...future.conditions <- base::list()
[17:47:32.013]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:32.013]     if (FALSE) {
[17:47:32.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:32.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:32.013]     }
[17:47:32.013]     ...future.result <- base::tryCatch({
[17:47:32.013]         base::withCallingHandlers({
[17:47:32.013]             ...future.value <- base::withVisible(base::local({
[17:47:32.013]                 b <- 2L
[17:47:32.013]                 plan_b <- future::plan("list")
[17:47:32.013]                 nested_b <- nested_a[-1]
[17:47:32.013]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:32.013]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:47:32.013]                   "sequential"))
[17:47:32.013]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:32.013]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:32.013]             }))
[17:47:32.013]             future::FutureResult(value = ...future.value$value, 
[17:47:32.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.013]                   ...future.rng), globalenv = if (FALSE) 
[17:47:32.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:32.013]                     ...future.globalenv.names))
[17:47:32.013]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:32.013]         }, condition = base::local({
[17:47:32.013]             c <- base::c
[17:47:32.013]             inherits <- base::inherits
[17:47:32.013]             invokeRestart <- base::invokeRestart
[17:47:32.013]             length <- base::length
[17:47:32.013]             list <- base::list
[17:47:32.013]             seq.int <- base::seq.int
[17:47:32.013]             signalCondition <- base::signalCondition
[17:47:32.013]             sys.calls <- base::sys.calls
[17:47:32.013]             `[[` <- base::`[[`
[17:47:32.013]             `+` <- base::`+`
[17:47:32.013]             `<<-` <- base::`<<-`
[17:47:32.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:32.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:32.013]                   3L)]
[17:47:32.013]             }
[17:47:32.013]             function(cond) {
[17:47:32.013]                 is_error <- inherits(cond, "error")
[17:47:32.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:32.013]                   NULL)
[17:47:32.013]                 if (is_error) {
[17:47:32.013]                   sessionInformation <- function() {
[17:47:32.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:32.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:32.013]                       search = base::search(), system = base::Sys.info())
[17:47:32.013]                   }
[17:47:32.013]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:32.013]                     cond$call), session = sessionInformation(), 
[17:47:32.013]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:32.013]                   signalCondition(cond)
[17:47:32.013]                 }
[17:47:32.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:32.013]                 "immediateCondition"))) {
[17:47:32.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:32.013]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:32.013]                   if (TRUE && !signal) {
[17:47:32.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.013]                     {
[17:47:32.013]                       inherits <- base::inherits
[17:47:32.013]                       invokeRestart <- base::invokeRestart
[17:47:32.013]                       is.null <- base::is.null
[17:47:32.013]                       muffled <- FALSE
[17:47:32.013]                       if (inherits(cond, "message")) {
[17:47:32.013]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.013]                         if (muffled) 
[17:47:32.013]                           invokeRestart("muffleMessage")
[17:47:32.013]                       }
[17:47:32.013]                       else if (inherits(cond, "warning")) {
[17:47:32.013]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.013]                         if (muffled) 
[17:47:32.013]                           invokeRestart("muffleWarning")
[17:47:32.013]                       }
[17:47:32.013]                       else if (inherits(cond, "condition")) {
[17:47:32.013]                         if (!is.null(pattern)) {
[17:47:32.013]                           computeRestarts <- base::computeRestarts
[17:47:32.013]                           grepl <- base::grepl
[17:47:32.013]                           restarts <- computeRestarts(cond)
[17:47:32.013]                           for (restart in restarts) {
[17:47:32.013]                             name <- restart$name
[17:47:32.013]                             if (is.null(name)) 
[17:47:32.013]                               next
[17:47:32.013]                             if (!grepl(pattern, name)) 
[17:47:32.013]                               next
[17:47:32.013]                             invokeRestart(restart)
[17:47:32.013]                             muffled <- TRUE
[17:47:32.013]                             break
[17:47:32.013]                           }
[17:47:32.013]                         }
[17:47:32.013]                       }
[17:47:32.013]                       invisible(muffled)
[17:47:32.013]                     }
[17:47:32.013]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.013]                   }
[17:47:32.013]                 }
[17:47:32.013]                 else {
[17:47:32.013]                   if (TRUE) {
[17:47:32.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.013]                     {
[17:47:32.013]                       inherits <- base::inherits
[17:47:32.013]                       invokeRestart <- base::invokeRestart
[17:47:32.013]                       is.null <- base::is.null
[17:47:32.013]                       muffled <- FALSE
[17:47:32.013]                       if (inherits(cond, "message")) {
[17:47:32.013]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.013]                         if (muffled) 
[17:47:32.013]                           invokeRestart("muffleMessage")
[17:47:32.013]                       }
[17:47:32.013]                       else if (inherits(cond, "warning")) {
[17:47:32.013]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.013]                         if (muffled) 
[17:47:32.013]                           invokeRestart("muffleWarning")
[17:47:32.013]                       }
[17:47:32.013]                       else if (inherits(cond, "condition")) {
[17:47:32.013]                         if (!is.null(pattern)) {
[17:47:32.013]                           computeRestarts <- base::computeRestarts
[17:47:32.013]                           grepl <- base::grepl
[17:47:32.013]                           restarts <- computeRestarts(cond)
[17:47:32.013]                           for (restart in restarts) {
[17:47:32.013]                             name <- restart$name
[17:47:32.013]                             if (is.null(name)) 
[17:47:32.013]                               next
[17:47:32.013]                             if (!grepl(pattern, name)) 
[17:47:32.013]                               next
[17:47:32.013]                             invokeRestart(restart)
[17:47:32.013]                             muffled <- TRUE
[17:47:32.013]                             break
[17:47:32.013]                           }
[17:47:32.013]                         }
[17:47:32.013]                       }
[17:47:32.013]                       invisible(muffled)
[17:47:32.013]                     }
[17:47:32.013]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.013]                   }
[17:47:32.013]                 }
[17:47:32.013]             }
[17:47:32.013]         }))
[17:47:32.013]     }, error = function(ex) {
[17:47:32.013]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:32.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.013]                 ...future.rng), started = ...future.startTime, 
[17:47:32.013]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:32.013]             version = "1.8"), class = "FutureResult")
[17:47:32.013]     }, finally = {
[17:47:32.013]         if (!identical(...future.workdir, getwd())) 
[17:47:32.013]             setwd(...future.workdir)
[17:47:32.013]         {
[17:47:32.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:32.013]                 ...future.oldOptions$nwarnings <- NULL
[17:47:32.013]             }
[17:47:32.013]             base::options(...future.oldOptions)
[17:47:32.013]             if (.Platform$OS.type == "windows") {
[17:47:32.013]                 old_names <- names(...future.oldEnvVars)
[17:47:32.013]                 envs <- base::Sys.getenv()
[17:47:32.013]                 names <- names(envs)
[17:47:32.013]                 common <- intersect(names, old_names)
[17:47:32.013]                 added <- setdiff(names, old_names)
[17:47:32.013]                 removed <- setdiff(old_names, names)
[17:47:32.013]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:32.013]                   envs[common]]
[17:47:32.013]                 NAMES <- toupper(changed)
[17:47:32.013]                 args <- list()
[17:47:32.013]                 for (kk in seq_along(NAMES)) {
[17:47:32.013]                   name <- changed[[kk]]
[17:47:32.013]                   NAME <- NAMES[[kk]]
[17:47:32.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.013]                     next
[17:47:32.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.013]                 }
[17:47:32.013]                 NAMES <- toupper(added)
[17:47:32.013]                 for (kk in seq_along(NAMES)) {
[17:47:32.013]                   name <- added[[kk]]
[17:47:32.013]                   NAME <- NAMES[[kk]]
[17:47:32.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.013]                     next
[17:47:32.013]                   args[[name]] <- ""
[17:47:32.013]                 }
[17:47:32.013]                 NAMES <- toupper(removed)
[17:47:32.013]                 for (kk in seq_along(NAMES)) {
[17:47:32.013]                   name <- removed[[kk]]
[17:47:32.013]                   NAME <- NAMES[[kk]]
[17:47:32.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.013]                     next
[17:47:32.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.013]                 }
[17:47:32.013]                 if (length(args) > 0) 
[17:47:32.013]                   base::do.call(base::Sys.setenv, args = args)
[17:47:32.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:32.013]             }
[17:47:32.013]             else {
[17:47:32.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:32.013]             }
[17:47:32.013]             {
[17:47:32.013]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:32.013]                   0L) {
[17:47:32.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:32.013]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:32.013]                   base::options(opts)
[17:47:32.013]                 }
[17:47:32.013]                 {
[17:47:32.013]                   {
[17:47:32.013]                     NULL
[17:47:32.013]                     RNGkind("Mersenne-Twister")
[17:47:32.013]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:32.013]                       inherits = FALSE)
[17:47:32.013]                   }
[17:47:32.013]                   options(future.plan = NULL)
[17:47:32.013]                   if (is.na(NA_character_)) 
[17:47:32.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:32.013]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:32.013]                     .init = FALSE)
[17:47:32.013]                 }
[17:47:32.013]             }
[17:47:32.013]         }
[17:47:32.013]     })
[17:47:32.013]     if (TRUE) {
[17:47:32.013]         base::sink(type = "output", split = FALSE)
[17:47:32.013]         if (TRUE) {
[17:47:32.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:32.013]         }
[17:47:32.013]         else {
[17:47:32.013]             ...future.result["stdout"] <- base::list(NULL)
[17:47:32.013]         }
[17:47:32.013]         base::close(...future.stdout)
[17:47:32.013]         ...future.stdout <- NULL
[17:47:32.013]     }
[17:47:32.013]     ...future.result$conditions <- ...future.conditions
[17:47:32.013]     ...future.result$finished <- base::Sys.time()
[17:47:32.013]     ...future.result
[17:47:32.013] }
[17:47:32.046]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.015] assign_globals() ...
[17:47:32.046]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.015] List of 3
[17:47:32.015]  $ nested_a:List of 1
[17:47:32.015]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:32.015]     envir = parent.frame())  
[17:47:32.015]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:47:32.015]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:47:32.015]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:32.015]  $ a       : int 1
[17:47:32.015]  $ plan_a  :List of 1
[17:47:32.015]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:32.015]     envir = parent.frame())  
[17:47:32.015]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:47:32.015]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:47:32.015]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:47:32.015]  - attr(*, "where")=List of 3
[17:47:32.015]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:47:32.015]   ..$ a       :<environment: R_EmptyEnv> 
[17:47:32.015]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:47:32.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:32.015]  - attr(*, "resolved")= logi FALSE
[17:47:32.015]  - attr(*, "total_size")= num 89928
[17:47:32.015]  - attr(*, "already-done")= logi TRUE
[17:47:32.046]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.023] - copied ‘nested_a’ to environment
[17:47:32.046]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.023] - copied ‘a’ to environment
[17:47:32.046]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.023] - copied ‘plan_a’ to environment
[17:47:32.046]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.024] assign_globals() ... done
[17:47:32.046]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.024] plan(): Setting new future strategy stack:
[17:47:32.047]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.024] List of future strategies:
[17:47:32.024] 1. sequential:
[17:47:32.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:32.024]    - tweaked: FALSE
[17:47:32.024]    - call: NULL
[17:47:32.047]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.025] plan(): nbrOfWorkers() = 1
[17:47:32.047]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.026] plan(): Setting new future strategy stack:
[17:47:32.047]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.026] List of future strategies:
[17:47:32.026] 1. multisession:
[17:47:32.026]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.026]    - tweaked: FALSE
[17:47:32.026]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.047]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.030] plan(): nbrOfWorkers() = 1
[17:47:32.047]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.030] SequentialFuture started (and completed)
[17:47:32.048]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.030] - Launch lazy future ... done
[17:47:32.048]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.030] run() for ‘SequentialFuture’ ... done
[17:47:32.048] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:32.054] getGlobalsAndPackages() ...
[17:47:32.055] Searching for globals...
[17:47:32.056] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:32.056] Searching for globals ... DONE
[17:47:32.057] Resolving globals: FALSE
[17:47:32.057] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:32.058] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:32.058] - globals: [1] ‘data’
[17:47:32.058] - packages: [1] ‘future’
[17:47:32.058] getGlobalsAndPackages() ... DONE
[17:47:32.058] run() for ‘Future’ ...
[17:47:32.059] - state: ‘created’
[17:47:32.059] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:32.063] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:32.063] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:32.063]   - Field: ‘label’
[17:47:32.063]   - Field: ‘local’
[17:47:32.063]   - Field: ‘owner’
[17:47:32.063]   - Field: ‘envir’
[17:47:32.064]   - Field: ‘workers’
[17:47:32.064]   - Field: ‘packages’
[17:47:32.064]   - Field: ‘gc’
[17:47:32.064]   - Field: ‘job’
[17:47:32.064]   - Field: ‘conditions’
[17:47:32.064]   - Field: ‘expr’
[17:47:32.064]   - Field: ‘uuid’
[17:47:32.064]   - Field: ‘seed’
[17:47:32.064]   - Field: ‘version’
[17:47:32.065]   - Field: ‘result’
[17:47:32.065]   - Field: ‘asynchronous’
[17:47:32.065]   - Field: ‘calls’
[17:47:32.065]   - Field: ‘globals’
[17:47:32.065]   - Field: ‘stdout’
[17:47:32.065]   - Field: ‘earlySignal’
[17:47:32.065]   - Field: ‘lazy’
[17:47:32.065]   - Field: ‘state’
[17:47:32.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:32.065] - Launch lazy future ...
[17:47:32.066] Packages needed by the future expression (n = 1): ‘future’
[17:47:32.066] Packages needed by future strategies (n = 1): ‘future’
[17:47:32.067] {
[17:47:32.067]     {
[17:47:32.067]         {
[17:47:32.067]             ...future.startTime <- base::Sys.time()
[17:47:32.067]             {
[17:47:32.067]                 {
[17:47:32.067]                   {
[17:47:32.067]                     {
[17:47:32.067]                       {
[17:47:32.067]                         base::local({
[17:47:32.067]                           has_future <- base::requireNamespace("future", 
[17:47:32.067]                             quietly = TRUE)
[17:47:32.067]                           if (has_future) {
[17:47:32.067]                             ns <- base::getNamespace("future")
[17:47:32.067]                             version <- ns[[".package"]][["version"]]
[17:47:32.067]                             if (is.null(version)) 
[17:47:32.067]                               version <- utils::packageVersion("future")
[17:47:32.067]                           }
[17:47:32.067]                           else {
[17:47:32.067]                             version <- NULL
[17:47:32.067]                           }
[17:47:32.067]                           if (!has_future || version < "1.8.0") {
[17:47:32.067]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:32.067]                               "", base::R.version$version.string), 
[17:47:32.067]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:32.067]                                 base::R.version$platform, 8 * 
[17:47:32.067]                                   base::.Machine$sizeof.pointer), 
[17:47:32.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:32.067]                                 "release", "version")], collapse = " "), 
[17:47:32.067]                               hostname = base::Sys.info()[["nodename"]])
[17:47:32.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:32.067]                               info)
[17:47:32.067]                             info <- base::paste(info, collapse = "; ")
[17:47:32.067]                             if (!has_future) {
[17:47:32.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:32.067]                                 info)
[17:47:32.067]                             }
[17:47:32.067]                             else {
[17:47:32.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:32.067]                                 info, version)
[17:47:32.067]                             }
[17:47:32.067]                             base::stop(msg)
[17:47:32.067]                           }
[17:47:32.067]                         })
[17:47:32.067]                       }
[17:47:32.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:32.067]                       base::options(mc.cores = 1L)
[17:47:32.067]                     }
[17:47:32.067]                     base::local({
[17:47:32.067]                       for (pkg in "future") {
[17:47:32.067]                         base::loadNamespace(pkg)
[17:47:32.067]                         base::library(pkg, character.only = TRUE)
[17:47:32.067]                       }
[17:47:32.067]                     })
[17:47:32.067]                   }
[17:47:32.067]                   ...future.strategy.old <- future::plan("list")
[17:47:32.067]                   options(future.plan = NULL)
[17:47:32.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.067]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:32.067]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:32.067]                     envir = parent.frame()) 
[17:47:32.067]                   {
[17:47:32.067]                     if (is.function(workers)) 
[17:47:32.067]                       workers <- workers()
[17:47:32.067]                     workers <- structure(as.integer(workers), 
[17:47:32.067]                       class = class(workers))
[17:47:32.067]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:32.067]                       workers >= 1)
[17:47:32.067]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:32.067]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:32.067]                     }
[17:47:32.067]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:32.067]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:32.067]                       envir = envir)
[17:47:32.067]                     if (!future$lazy) 
[17:47:32.067]                       future <- run(future)
[17:47:32.067]                     invisible(future)
[17:47:32.067]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:32.067]                 }
[17:47:32.067]                 ...future.workdir <- getwd()
[17:47:32.067]             }
[17:47:32.067]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:32.067]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:32.067]         }
[17:47:32.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:32.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:32.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:32.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:32.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:32.067]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:32.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:32.067]             base::names(...future.oldOptions))
[17:47:32.067]     }
[17:47:32.067]     if (FALSE) {
[17:47:32.067]     }
[17:47:32.067]     else {
[17:47:32.067]         if (TRUE) {
[17:47:32.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:32.067]                 open = "w")
[17:47:32.067]         }
[17:47:32.067]         else {
[17:47:32.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:32.067]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:32.067]         }
[17:47:32.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:32.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:32.067]             base::sink(type = "output", split = FALSE)
[17:47:32.067]             base::close(...future.stdout)
[17:47:32.067]         }, add = TRUE)
[17:47:32.067]     }
[17:47:32.067]     ...future.frame <- base::sys.nframe()
[17:47:32.067]     ...future.conditions <- base::list()
[17:47:32.067]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:32.067]     if (FALSE) {
[17:47:32.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:32.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:32.067]     }
[17:47:32.067]     ...future.result <- base::tryCatch({
[17:47:32.067]         base::withCallingHandlers({
[17:47:32.067]             ...future.value <- base::withVisible(base::local({
[17:47:32.067]                 withCallingHandlers({
[17:47:32.067]                   {
[17:47:32.067]                     value(future(subset(data, a == 2)))
[17:47:32.067]                   }
[17:47:32.067]                 }, immediateCondition = function(cond) {
[17:47:32.067]                   save_rds <- function (object, pathname, ...) 
[17:47:32.067]                   {
[17:47:32.067]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:32.067]                     if (file_test("-f", pathname_tmp)) {
[17:47:32.067]                       fi_tmp <- file.info(pathname_tmp)
[17:47:32.067]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:32.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:32.067]                         fi_tmp[["mtime"]])
[17:47:32.067]                     }
[17:47:32.067]                     tryCatch({
[17:47:32.067]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:32.067]                     }, error = function(ex) {
[17:47:32.067]                       msg <- conditionMessage(ex)
[17:47:32.067]                       fi_tmp <- file.info(pathname_tmp)
[17:47:32.067]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:32.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:32.067]                         fi_tmp[["mtime"]], msg)
[17:47:32.067]                       ex$message <- msg
[17:47:32.067]                       stop(ex)
[17:47:32.067]                     })
[17:47:32.067]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:32.067]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:32.067]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:32.067]                       fi_tmp <- file.info(pathname_tmp)
[17:47:32.067]                       fi <- file.info(pathname)
[17:47:32.067]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:32.067]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:32.067]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:32.067]                         fi[["size"]], fi[["mtime"]])
[17:47:32.067]                       stop(msg)
[17:47:32.067]                     }
[17:47:32.067]                     invisible(pathname)
[17:47:32.067]                   }
[17:47:32.067]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:32.067]                     rootPath = tempdir()) 
[17:47:32.067]                   {
[17:47:32.067]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:32.067]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:32.067]                       tmpdir = path, fileext = ".rds")
[17:47:32.067]                     save_rds(obj, file)
[17:47:32.067]                   }
[17:47:32.067]                   saveImmediateCondition(cond, path = "/tmp/RtmpS8clGH/.future/immediateConditions")
[17:47:32.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.067]                   {
[17:47:32.067]                     inherits <- base::inherits
[17:47:32.067]                     invokeRestart <- base::invokeRestart
[17:47:32.067]                     is.null <- base::is.null
[17:47:32.067]                     muffled <- FALSE
[17:47:32.067]                     if (inherits(cond, "message")) {
[17:47:32.067]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:32.067]                       if (muffled) 
[17:47:32.067]                         invokeRestart("muffleMessage")
[17:47:32.067]                     }
[17:47:32.067]                     else if (inherits(cond, "warning")) {
[17:47:32.067]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:32.067]                       if (muffled) 
[17:47:32.067]                         invokeRestart("muffleWarning")
[17:47:32.067]                     }
[17:47:32.067]                     else if (inherits(cond, "condition")) {
[17:47:32.067]                       if (!is.null(pattern)) {
[17:47:32.067]                         computeRestarts <- base::computeRestarts
[17:47:32.067]                         grepl <- base::grepl
[17:47:32.067]                         restarts <- computeRestarts(cond)
[17:47:32.067]                         for (restart in restarts) {
[17:47:32.067]                           name <- restart$name
[17:47:32.067]                           if (is.null(name)) 
[17:47:32.067]                             next
[17:47:32.067]                           if (!grepl(pattern, name)) 
[17:47:32.067]                             next
[17:47:32.067]                           invokeRestart(restart)
[17:47:32.067]                           muffled <- TRUE
[17:47:32.067]                           break
[17:47:32.067]                         }
[17:47:32.067]                       }
[17:47:32.067]                     }
[17:47:32.067]                     invisible(muffled)
[17:47:32.067]                   }
[17:47:32.067]                   muffleCondition(cond)
[17:47:32.067]                 })
[17:47:32.067]             }))
[17:47:32.067]             future::FutureResult(value = ...future.value$value, 
[17:47:32.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.067]                   ...future.rng), globalenv = if (FALSE) 
[17:47:32.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:32.067]                     ...future.globalenv.names))
[17:47:32.067]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:32.067]         }, condition = base::local({
[17:47:32.067]             c <- base::c
[17:47:32.067]             inherits <- base::inherits
[17:47:32.067]             invokeRestart <- base::invokeRestart
[17:47:32.067]             length <- base::length
[17:47:32.067]             list <- base::list
[17:47:32.067]             seq.int <- base::seq.int
[17:47:32.067]             signalCondition <- base::signalCondition
[17:47:32.067]             sys.calls <- base::sys.calls
[17:47:32.067]             `[[` <- base::`[[`
[17:47:32.067]             `+` <- base::`+`
[17:47:32.067]             `<<-` <- base::`<<-`
[17:47:32.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:32.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:32.067]                   3L)]
[17:47:32.067]             }
[17:47:32.067]             function(cond) {
[17:47:32.067]                 is_error <- inherits(cond, "error")
[17:47:32.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:32.067]                   NULL)
[17:47:32.067]                 if (is_error) {
[17:47:32.067]                   sessionInformation <- function() {
[17:47:32.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:32.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:32.067]                       search = base::search(), system = base::Sys.info())
[17:47:32.067]                   }
[17:47:32.067]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:32.067]                     cond$call), session = sessionInformation(), 
[17:47:32.067]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:32.067]                   signalCondition(cond)
[17:47:32.067]                 }
[17:47:32.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:32.067]                 "immediateCondition"))) {
[17:47:32.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:32.067]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:32.067]                   if (TRUE && !signal) {
[17:47:32.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.067]                     {
[17:47:32.067]                       inherits <- base::inherits
[17:47:32.067]                       invokeRestart <- base::invokeRestart
[17:47:32.067]                       is.null <- base::is.null
[17:47:32.067]                       muffled <- FALSE
[17:47:32.067]                       if (inherits(cond, "message")) {
[17:47:32.067]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.067]                         if (muffled) 
[17:47:32.067]                           invokeRestart("muffleMessage")
[17:47:32.067]                       }
[17:47:32.067]                       else if (inherits(cond, "warning")) {
[17:47:32.067]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.067]                         if (muffled) 
[17:47:32.067]                           invokeRestart("muffleWarning")
[17:47:32.067]                       }
[17:47:32.067]                       else if (inherits(cond, "condition")) {
[17:47:32.067]                         if (!is.null(pattern)) {
[17:47:32.067]                           computeRestarts <- base::computeRestarts
[17:47:32.067]                           grepl <- base::grepl
[17:47:32.067]                           restarts <- computeRestarts(cond)
[17:47:32.067]                           for (restart in restarts) {
[17:47:32.067]                             name <- restart$name
[17:47:32.067]                             if (is.null(name)) 
[17:47:32.067]                               next
[17:47:32.067]                             if (!grepl(pattern, name)) 
[17:47:32.067]                               next
[17:47:32.067]                             invokeRestart(restart)
[17:47:32.067]                             muffled <- TRUE
[17:47:32.067]                             break
[17:47:32.067]                           }
[17:47:32.067]                         }
[17:47:32.067]                       }
[17:47:32.067]                       invisible(muffled)
[17:47:32.067]                     }
[17:47:32.067]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.067]                   }
[17:47:32.067]                 }
[17:47:32.067]                 else {
[17:47:32.067]                   if (TRUE) {
[17:47:32.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.067]                     {
[17:47:32.067]                       inherits <- base::inherits
[17:47:32.067]                       invokeRestart <- base::invokeRestart
[17:47:32.067]                       is.null <- base::is.null
[17:47:32.067]                       muffled <- FALSE
[17:47:32.067]                       if (inherits(cond, "message")) {
[17:47:32.067]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.067]                         if (muffled) 
[17:47:32.067]                           invokeRestart("muffleMessage")
[17:47:32.067]                       }
[17:47:32.067]                       else if (inherits(cond, "warning")) {
[17:47:32.067]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.067]                         if (muffled) 
[17:47:32.067]                           invokeRestart("muffleWarning")
[17:47:32.067]                       }
[17:47:32.067]                       else if (inherits(cond, "condition")) {
[17:47:32.067]                         if (!is.null(pattern)) {
[17:47:32.067]                           computeRestarts <- base::computeRestarts
[17:47:32.067]                           grepl <- base::grepl
[17:47:32.067]                           restarts <- computeRestarts(cond)
[17:47:32.067]                           for (restart in restarts) {
[17:47:32.067]                             name <- restart$name
[17:47:32.067]                             if (is.null(name)) 
[17:47:32.067]                               next
[17:47:32.067]                             if (!grepl(pattern, name)) 
[17:47:32.067]                               next
[17:47:32.067]                             invokeRestart(restart)
[17:47:32.067]                             muffled <- TRUE
[17:47:32.067]                             break
[17:47:32.067]                           }
[17:47:32.067]                         }
[17:47:32.067]                       }
[17:47:32.067]                       invisible(muffled)
[17:47:32.067]                     }
[17:47:32.067]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.067]                   }
[17:47:32.067]                 }
[17:47:32.067]             }
[17:47:32.067]         }))
[17:47:32.067]     }, error = function(ex) {
[17:47:32.067]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:32.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.067]                 ...future.rng), started = ...future.startTime, 
[17:47:32.067]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:32.067]             version = "1.8"), class = "FutureResult")
[17:47:32.067]     }, finally = {
[17:47:32.067]         if (!identical(...future.workdir, getwd())) 
[17:47:32.067]             setwd(...future.workdir)
[17:47:32.067]         {
[17:47:32.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:32.067]                 ...future.oldOptions$nwarnings <- NULL
[17:47:32.067]             }
[17:47:32.067]             base::options(...future.oldOptions)
[17:47:32.067]             if (.Platform$OS.type == "windows") {
[17:47:32.067]                 old_names <- names(...future.oldEnvVars)
[17:47:32.067]                 envs <- base::Sys.getenv()
[17:47:32.067]                 names <- names(envs)
[17:47:32.067]                 common <- intersect(names, old_names)
[17:47:32.067]                 added <- setdiff(names, old_names)
[17:47:32.067]                 removed <- setdiff(old_names, names)
[17:47:32.067]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:32.067]                   envs[common]]
[17:47:32.067]                 NAMES <- toupper(changed)
[17:47:32.067]                 args <- list()
[17:47:32.067]                 for (kk in seq_along(NAMES)) {
[17:47:32.067]                   name <- changed[[kk]]
[17:47:32.067]                   NAME <- NAMES[[kk]]
[17:47:32.067]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.067]                     next
[17:47:32.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.067]                 }
[17:47:32.067]                 NAMES <- toupper(added)
[17:47:32.067]                 for (kk in seq_along(NAMES)) {
[17:47:32.067]                   name <- added[[kk]]
[17:47:32.067]                   NAME <- NAMES[[kk]]
[17:47:32.067]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.067]                     next
[17:47:32.067]                   args[[name]] <- ""
[17:47:32.067]                 }
[17:47:32.067]                 NAMES <- toupper(removed)
[17:47:32.067]                 for (kk in seq_along(NAMES)) {
[17:47:32.067]                   name <- removed[[kk]]
[17:47:32.067]                   NAME <- NAMES[[kk]]
[17:47:32.067]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.067]                     next
[17:47:32.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.067]                 }
[17:47:32.067]                 if (length(args) > 0) 
[17:47:32.067]                   base::do.call(base::Sys.setenv, args = args)
[17:47:32.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:32.067]             }
[17:47:32.067]             else {
[17:47:32.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:32.067]             }
[17:47:32.067]             {
[17:47:32.067]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:32.067]                   0L) {
[17:47:32.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:32.067]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:32.067]                   base::options(opts)
[17:47:32.067]                 }
[17:47:32.067]                 {
[17:47:32.067]                   {
[17:47:32.067]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:32.067]                     NULL
[17:47:32.067]                   }
[17:47:32.067]                   options(future.plan = NULL)
[17:47:32.067]                   if (is.na(NA_character_)) 
[17:47:32.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:32.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:32.067]                     .init = FALSE)
[17:47:32.067]                 }
[17:47:32.067]             }
[17:47:32.067]         }
[17:47:32.067]     })
[17:47:32.067]     if (TRUE) {
[17:47:32.067]         base::sink(type = "output", split = FALSE)
[17:47:32.067]         if (TRUE) {
[17:47:32.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:32.067]         }
[17:47:32.067]         else {
[17:47:32.067]             ...future.result["stdout"] <- base::list(NULL)
[17:47:32.067]         }
[17:47:32.067]         base::close(...future.stdout)
[17:47:32.067]         ...future.stdout <- NULL
[17:47:32.067]     }
[17:47:32.067]     ...future.result$conditions <- ...future.conditions
[17:47:32.067]     ...future.result$finished <- base::Sys.time()
[17:47:32.067]     ...future.result
[17:47:32.067] }
[17:47:32.069] assign_globals() ...
[17:47:32.069] List of 1
[17:47:32.069]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:32.069]   ..$ a: int [1:3] 1 2 3
[17:47:32.069]   ..$ b: int [1:3] 3 2 1
[17:47:32.069]  - attr(*, "where")=List of 1
[17:47:32.069]   ..$ data:<environment: R_EmptyEnv> 
[17:47:32.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:32.069]  - attr(*, "resolved")= logi FALSE
[17:47:32.069]  - attr(*, "total_size")= num 128
[17:47:32.069]  - attr(*, "already-done")= logi TRUE
[17:47:32.073] - copied ‘data’ to environment
[17:47:32.073] assign_globals() ... done
[17:47:32.073] requestCore(): workers = 2
[17:47:32.075] MulticoreFuture started
[17:47:32.076] - Launch lazy future ... done
[17:47:32.076] run() for ‘MulticoreFuture’ ... done
[17:47:32.076] result() for MulticoreFuture ...
[17:47:32.077] plan(): Setting new future strategy stack:
[17:47:32.077] List of future strategies:
[17:47:32.077] 1. multisession:
[17:47:32.077]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.077]    - tweaked: FALSE
[17:47:32.077]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.083] plan(): nbrOfWorkers() = 1
[17:47:32.119] plan(): Setting new future strategy stack:
[17:47:32.119] List of future strategies:
[17:47:32.119] 1. multicore:
[17:47:32.119]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:32.119]    - tweaked: FALSE
[17:47:32.119]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.119] 2. multisession:
[17:47:32.119]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.119]    - tweaked: FALSE
[17:47:32.119]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.123] plan(): nbrOfWorkers() = 2
[17:47:32.124] result() for MulticoreFuture ...
[17:47:32.125] result() for MulticoreFuture ... done
[17:47:32.125] signalConditions() ...
[17:47:32.125]  - include = ‘immediateCondition’
[17:47:32.125]  - exclude = 
[17:47:32.125]  - resignal = FALSE
[17:47:32.125]  - Number of conditions: 52
[17:47:32.125] signalConditions() ... done
[17:47:32.125] result() for MulticoreFuture ... done
[17:47:32.125] result() for MulticoreFuture ...
[17:47:32.126] result() for MulticoreFuture ... done
[17:47:32.126] signalConditions() ...
[17:47:32.126]  - include = ‘immediateCondition’
[17:47:32.126]  - exclude = 
[17:47:32.126]  - resignal = FALSE
[17:47:32.126]  - Number of conditions: 52
[17:47:32.126] signalConditions() ... done
[17:47:32.126] Future state: ‘finished’
[17:47:32.127] result() for MulticoreFuture ...
[17:47:32.127] result() for MulticoreFuture ... done
[17:47:32.127] signalConditions() ...
[17:47:32.127]  - include = ‘condition’
[17:47:32.127]  - exclude = ‘immediateCondition’
[17:47:32.127]  - resignal = TRUE
[17:47:32.127]  - Number of conditions: 52
[17:47:32.127]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.084] getGlobalsAndPackages() ...
[17:47:32.127]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.084] Searching for globals...
[17:47:32.128]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.086] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:32.128]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.086] Searching for globals ... DONE
[17:47:32.128]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.086] Resolving globals: FALSE
[17:47:32.128]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.087] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:32.128]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.088] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:32.128]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.088] - globals: [1] ‘data’
[17:47:32.128]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.088] 
[17:47:32.129]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.088] getGlobalsAndPackages() ... DONE
[17:47:32.129]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.089] run() for ‘Future’ ...
[17:47:32.129]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.089] - state: ‘created’
[17:47:32.129]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:32.129]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.099] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:32.129]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:32.130]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.100]   - Field: ‘label’
[17:47:32.130]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.100]   - Field: ‘local’
[17:47:32.130]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.100]   - Field: ‘owner’
[17:47:32.130]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.101]   - Field: ‘envir’
[17:47:32.134]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.101]   - Field: ‘packages’
[17:47:32.134]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.101]   - Field: ‘gc’
[17:47:32.134]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.101]   - Field: ‘conditions’
[17:47:32.134]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.101]   - Field: ‘expr’
[17:47:32.135]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.101]   - Field: ‘uuid’
[17:47:32.135]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.102]   - Field: ‘seed’
[17:47:32.135]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.102]   - Field: ‘version’
[17:47:32.135]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.102]   - Field: ‘result’
[17:47:32.135]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.102]   - Field: ‘asynchronous’
[17:47:32.135]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.102]   - Field: ‘calls’
[17:47:32.136]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.102]   - Field: ‘globals’
[17:47:32.136]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.103]   - Field: ‘stdout’
[17:47:32.136]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.103]   - Field: ‘earlySignal’
[17:47:32.136]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.103]   - Field: ‘lazy’
[17:47:32.136]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.103]   - Field: ‘state’
[17:47:32.136]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:32.137]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.103] - Launch lazy future ...
[17:47:32.137]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.104] Packages needed by the future expression (n = 0): <none>
[17:47:32.137]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.104] Packages needed by future strategies (n = 0): <none>
[17:47:32.137]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.105] {
[17:47:32.105]     {
[17:47:32.105]         {
[17:47:32.105]             ...future.startTime <- base::Sys.time()
[17:47:32.105]             {
[17:47:32.105]                 {
[17:47:32.105]                   {
[17:47:32.105]                     base::local({
[17:47:32.105]                       has_future <- base::requireNamespace("future", 
[17:47:32.105]                         quietly = TRUE)
[17:47:32.105]                       if (has_future) {
[17:47:32.105]                         ns <- base::getNamespace("future")
[17:47:32.105]                         version <- ns[[".package"]][["version"]]
[17:47:32.105]                         if (is.null(version)) 
[17:47:32.105]                           version <- utils::packageVersion("future")
[17:47:32.105]                       }
[17:47:32.105]                       else {
[17:47:32.105]                         version <- NULL
[17:47:32.105]                       }
[17:47:32.105]                       if (!has_future || version < "1.8.0") {
[17:47:32.105]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:32.105]                           "", base::R.version$version.string), 
[17:47:32.105]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:32.105]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:32.105]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:32.105]                             "release", "version")], collapse = " "), 
[17:47:32.105]                           hostname = base::Sys.info()[["nodename"]])
[17:47:32.105]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:32.105]                           info)
[17:47:32.105]                         info <- base::paste(info, collapse = "; ")
[17:47:32.105]                         if (!has_future) {
[17:47:32.105]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:32.105]                             info)
[17:47:32.105]                         }
[17:47:32.105]                         else {
[17:47:32.105]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:32.105]                             info, version)
[17:47:32.105]                         }
[17:47:32.105]                         base::stop(msg)
[17:47:32.105]                       }
[17:47:32.105]                     })
[17:47:32.105]                   }
[17:47:32.105]                   ...future.strategy.old <- future::plan("list")
[17:47:32.105]                   options(future.plan = NULL)
[17:47:32.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:32.105]                 }
[17:47:32.105]                 ...future.workdir <- getwd()
[17:47:32.105]             }
[17:47:32.105]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:32.105]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:32.105]         }
[17:47:32.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:32.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:32.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:32.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:32.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:32.105]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:32.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:32.105]             base::names(...future.oldOptions))
[17:47:32.105]     }
[17:47:32.105]     if (FALSE) {
[17:47:32.105]     }
[17:47:32.105]     else {
[17:47:32.105]         if (TRUE) {
[17:47:32.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:32.105]                 open = "w")
[17:47:32.105]         }
[17:47:32.105]         else {
[17:47:32.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:32.105]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:32.105]         }
[17:47:32.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:32.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:32.105]             base::sink(type = "output", split = FALSE)
[17:47:32.105]             base::close(...future.stdout)
[17:47:32.105]         }, add = TRUE)
[17:47:32.105]     }
[17:47:32.105]     ...future.frame <- base::sys.nframe()
[17:47:32.105]     ...future.conditions <- base::list()
[17:47:32.105]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:32.105]     if (FALSE) {
[17:47:32.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:32.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:32.105]     }
[17:47:32.105]     ...future.result <- base::tryCatch({
[17:47:32.105]         base::withCallingHandlers({
[17:47:32.105]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:47:32.105]                 a == 2)))
[17:47:32.105]             future::FutureResult(value = ...future.value$value, 
[17:47:32.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.105]                   ...future.rng), globalenv = if (FALSE) 
[17:47:32.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:32.105]                     ...future.globalenv.names))
[17:47:32.105]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:32.105]         }, condition = base::local({
[17:47:32.105]             c <- base::c
[17:47:32.105]             inherits <- base::inherits
[17:47:32.105]             invokeRestart <- base::invokeRestart
[17:47:32.105]             length <- base::length
[17:47:32.105]             list <- base::list
[17:47:32.105]             seq.int <- base::seq.int
[17:47:32.105]             signalCondition <- base::signalCondition
[17:47:32.105]             sys.calls <- base::sys.calls
[17:47:32.105]             `[[` <- base::`[[`
[17:47:32.105]             `+` <- base::`+`
[17:47:32.105]             `<<-` <- base::`<<-`
[17:47:32.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:32.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:32.105]                   3L)]
[17:47:32.105]             }
[17:47:32.105]             function(cond) {
[17:47:32.105]                 is_error <- inherits(cond, "error")
[17:47:32.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:32.105]                   NULL)
[17:47:32.105]                 if (is_error) {
[17:47:32.105]                   sessionInformation <- function() {
[17:47:32.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:32.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:32.105]                       search = base::search(), system = base::Sys.info())
[17:47:32.105]                   }
[17:47:32.105]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:32.105]                     cond$call), session = sessionInformation(), 
[17:47:32.105]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:32.105]                   signalCondition(cond)
[17:47:32.105]                 }
[17:47:32.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:32.105]                 "immediateCondition"))) {
[17:47:32.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:32.105]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:32.105]                   if (TRUE && !signal) {
[17:47:32.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.105]                     {
[17:47:32.105]                       inherits <- base::inherits
[17:47:32.105]                       invokeRestart <- base::invokeRestart
[17:47:32.105]                       is.null <- base::is.null
[17:47:32.105]                       muffled <- FALSE
[17:47:32.105]                       if (inherits(cond, "message")) {
[17:47:32.105]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.105]                         if (muffled) 
[17:47:32.105]                           invokeRestart("muffleMessage")
[17:47:32.105]                       }
[17:47:32.105]                       else if (inherits(cond, "warning")) {
[17:47:32.105]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.105]                         if (muffled) 
[17:47:32.105]                           invokeRestart("muffleWarning")
[17:47:32.105]                       }
[17:47:32.105]                       else if (inherits(cond, "condition")) {
[17:47:32.105]                         if (!is.null(pattern)) {
[17:47:32.105]                           computeRestarts <- base::computeRestarts
[17:47:32.105]                           grepl <- base::grepl
[17:47:32.105]                           restarts <- computeRestarts(cond)
[17:47:32.105]                           for (restart in restarts) {
[17:47:32.105]                             name <- restart$name
[17:47:32.105]                             if (is.null(name)) 
[17:47:32.105]                               next
[17:47:32.105]                             if (!grepl(pattern, name)) 
[17:47:32.105]                               next
[17:47:32.105]                             invokeRestart(restart)
[17:47:32.105]                             muffled <- TRUE
[17:47:32.105]                             break
[17:47:32.105]                           }
[17:47:32.105]                         }
[17:47:32.105]                       }
[17:47:32.105]                       invisible(muffled)
[17:47:32.105]                     }
[17:47:32.105]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.105]                   }
[17:47:32.105]                 }
[17:47:32.105]                 else {
[17:47:32.105]                   if (TRUE) {
[17:47:32.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.105]                     {
[17:47:32.105]                       inherits <- base::inherits
[17:47:32.105]                       invokeRestart <- base::invokeRestart
[17:47:32.105]                       is.null <- base::is.null
[17:47:32.105]                       muffled <- FALSE
[17:47:32.105]                       if (inherits(cond, "message")) {
[17:47:32.105]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.105]                         if (muffled) 
[17:47:32.105]                           invokeRestart("muffleMessage")
[17:47:32.105]                       }
[17:47:32.105]                       else if (inherits(cond, "warning")) {
[17:47:32.105]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.105]                         if (muffled) 
[17:47:32.105]                           invokeRestart("muffleWarning")
[17:47:32.105]                       }
[17:47:32.105]                       else if (inherits(cond, "condition")) {
[17:47:32.105]                         if (!is.null(pattern)) {
[17:47:32.105]                           computeRestarts <- base::computeRestarts
[17:47:32.105]                           grepl <- base::grepl
[17:47:32.105]                           restarts <- computeRestarts(cond)
[17:47:32.105]                           for (restart in restarts) {
[17:47:32.105]                             name <- restart$name
[17:47:32.105]                             if (is.null(name)) 
[17:47:32.105]                               next
[17:47:32.105]                             if (!grepl(pattern, name)) 
[17:47:32.105]                               next
[17:47:32.105]                             invokeRestart(restart)
[17:47:32.105]                             muffled <- TRUE
[17:47:32.105]                             break
[17:47:32.105]                           }
[17:47:32.105]                         }
[17:47:32.105]                       }
[17:47:32.105]                       invisible(muffled)
[17:47:32.105]                     }
[17:47:32.105]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.105]                   }
[17:47:32.105]                 }
[17:47:32.105]             }
[17:47:32.105]         }))
[17:47:32.105]     }, error = function(ex) {
[17:47:32.105]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:32.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.105]                 ...future.rng), started = ...future.startTime, 
[17:47:32.105]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:32.105]             version = "1.8"), class = "FutureResult")
[17:47:32.105]     }, finally = {
[17:47:32.105]         if (!identical(...future.workdir, getwd())) 
[17:47:32.105]             setwd(...future.workdir)
[17:47:32.105]         {
[17:47:32.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:32.105]                 ...future.oldOptions$nwarnings <- NULL
[17:47:32.105]             }
[17:47:32.105]             base::options(...future.oldOptions)
[17:47:32.105]             if (.Platform$OS.type == "windows") {
[17:47:32.105]                 old_names <- names(...future.oldEnvVars)
[17:47:32.105]                 envs <- base::Sys.getenv()
[17:47:32.105]                 names <- names(envs)
[17:47:32.105]                 common <- intersect(names, old_names)
[17:47:32.105]                 added <- setdiff(names, old_names)
[17:47:32.105]                 removed <- setdiff(old_names, names)
[17:47:32.105]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:32.105]                   envs[common]]
[17:47:32.105]                 NAMES <- toupper(changed)
[17:47:32.105]                 args <- list()
[17:47:32.105]                 for (kk in seq_along(NAMES)) {
[17:47:32.105]                   name <- changed[[kk]]
[17:47:32.105]                   NAME <- NAMES[[kk]]
[17:47:32.105]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.105]                     next
[17:47:32.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.105]                 }
[17:47:32.105]                 NAMES <- toupper(added)
[17:47:32.105]                 for (kk in seq_along(NAMES)) {
[17:47:32.105]                   name <- added[[kk]]
[17:47:32.105]                   NAME <- NAMES[[kk]]
[17:47:32.105]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.105]                     next
[17:47:32.105]                   args[[name]] <- ""
[17:47:32.105]                 }
[17:47:32.105]                 NAMES <- toupper(removed)
[17:47:32.105]                 for (kk in seq_along(NAMES)) {
[17:47:32.105]                   name <- removed[[kk]]
[17:47:32.105]                   NAME <- NAMES[[kk]]
[17:47:32.105]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.105]                     next
[17:47:32.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.105]                 }
[17:47:32.105]                 if (length(args) > 0) 
[17:47:32.105]                   base::do.call(base::Sys.setenv, args = args)
[17:47:32.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:32.105]             }
[17:47:32.105]             else {
[17:47:32.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:32.105]             }
[17:47:32.105]             {
[17:47:32.105]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:32.105]                   0L) {
[17:47:32.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:32.105]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:32.105]                   base::options(opts)
[17:47:32.105]                 }
[17:47:32.105]                 {
[17:47:32.105]                   {
[17:47:32.105]                     NULL
[17:47:32.105]                     RNGkind("Mersenne-Twister")
[17:47:32.105]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:32.105]                       inherits = FALSE)
[17:47:32.105]                   }
[17:47:32.105]                   options(future.plan = NULL)
[17:47:32.105]                   if (is.na(NA_character_)) 
[17:47:32.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:32.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:32.105]                     .init = FALSE)
[17:47:32.105]                 }
[17:47:32.105]             }
[17:47:32.105]         }
[17:47:32.105]     })
[17:47:32.105]     if (TRUE) {
[17:47:32.105]         base::sink(type = "output", split = FALSE)
[17:47:32.105]         if (TRUE) {
[17:47:32.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:32.105]         }
[17:47:32.105]         else {
[17:47:32.105]             ...future.result["stdout"] <- base::list(NULL)
[17:47:32.105]         }
[17:47:32.105]         base::close(...future.stdout)
[17:47:32.105]         ...future.stdout <- NULL
[17:47:32.105]     }
[17:47:32.105]     ...future.result$conditions <- ...future.conditions
[17:47:32.105]     ...future.result$finished <- base::Sys.time()
[17:47:32.105]     ...future.result
[17:47:32.105] }
[17:47:32.137]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.107] assign_globals() ...
[17:47:32.137]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.107] List of 1
[17:47:32.107]  $ data:'data.frame':	3 obs. of  2 variables:
[17:47:32.107]   ..$ a: int [1:3] 1 2 3
[17:47:32.107]   ..$ b: int [1:3] 3 2 1
[17:47:32.107]  - attr(*, "where")=List of 1
[17:47:32.107]   ..$ data:<environment: R_EmptyEnv> 
[17:47:32.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:32.107]  - attr(*, "resolved")= logi FALSE
[17:47:32.107]  - attr(*, "total_size")= num 128
[17:47:32.107]  - attr(*, "already-done")= logi TRUE
[17:47:32.137]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.111] - copied ‘data’ to environment
[17:47:32.138]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.112] assign_globals() ... done
[17:47:32.138]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.112] plan(): Setting new future strategy stack:
[17:47:32.138]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.112] List of future strategies:
[17:47:32.112] 1. sequential:
[17:47:32.112]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:32.112]    - tweaked: FALSE
[17:47:32.112]    - call: NULL
[17:47:32.138]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.113] plan(): nbrOfWorkers() = 1
[17:47:32.138]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.114] plan(): Setting new future strategy stack:
[17:47:32.138]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.114] List of future strategies:
[17:47:32.114] 1. multisession:
[17:47:32.114]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.114]    - tweaked: FALSE
[17:47:32.114]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.138]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.118] plan(): nbrOfWorkers() = 1
[17:47:32.139]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.118] SequentialFuture started (and completed)
[17:47:32.139]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.118] - Launch lazy future ... done
[17:47:32.139]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:47:32.119] run() for ‘SequentialFuture’ ... done
[17:47:32.139] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[17:47:32.140] plan(): Setting new future strategy stack:
[17:47:32.140] List of future strategies:
[17:47:32.140] 1. multisession:
[17:47:32.140]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.140]    - tweaked: FALSE
[17:47:32.140]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.140] 2. sequential:
[17:47:32.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:32.140]    - tweaked: FALSE
[17:47:32.140]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.141] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:47:32.141] multisession:
[17:47:32.141] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.141] - tweaked: FALSE
[17:47:32.141] - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.145] getGlobalsAndPackages() ...
[17:47:32.145] Not searching for globals
[17:47:32.145] - globals: [0] <none>
[17:47:32.145] getGlobalsAndPackages() ... DONE
[17:47:32.146] [local output] makeClusterPSOCK() ...
[17:47:32.149] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:32.150] [local output] Base port: 11629
[17:47:32.150] [local output] Getting setup options for 2 cluster nodes ...
[17:47:32.150] [local output]  - Node 1 of 2 ...
[17:47:32.150] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:32.151] [local output] Rscript port: 11629

[17:47:32.151] [local output]  - Node 2 of 2 ...
[17:47:32.152] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:32.152] [local output] Rscript port: 11629

[17:47:32.153] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:32.153] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:32.153] [local output] Setting up PSOCK nodes in parallel
[17:47:32.153] List of 36
[17:47:32.153]  $ worker          : chr "localhost"
[17:47:32.153]   ..- attr(*, "localhost")= logi TRUE
[17:47:32.153]  $ master          : chr "localhost"
[17:47:32.153]  $ port            : int 11629
[17:47:32.153]  $ connectTimeout  : num 120
[17:47:32.153]  $ timeout         : num 2592000
[17:47:32.153]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:32.153]  $ homogeneous     : logi TRUE
[17:47:32.153]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:32.153]  $ rscript_envs    : NULL
[17:47:32.153]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:32.153]  $ rscript_startup : NULL
[17:47:32.153]  $ rscript_sh      : chr "sh"
[17:47:32.153]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:32.153]  $ methods         : logi TRUE
[17:47:32.153]  $ socketOptions   : chr "no-delay"
[17:47:32.153]  $ useXDR          : logi FALSE
[17:47:32.153]  $ outfile         : chr "/dev/null"
[17:47:32.153]  $ renice          : int NA
[17:47:32.153]  $ rshcmd          : NULL
[17:47:32.153]  $ user            : chr(0) 
[17:47:32.153]  $ revtunnel       : logi FALSE
[17:47:32.153]  $ rshlogfile      : NULL
[17:47:32.153]  $ rshopts         : chr(0) 
[17:47:32.153]  $ rank            : int 1
[17:47:32.153]  $ manual          : logi FALSE
[17:47:32.153]  $ dryrun          : logi FALSE
[17:47:32.153]  $ quiet           : logi FALSE
[17:47:32.153]  $ setup_strategy  : chr "parallel"
[17:47:32.153]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:32.153]  $ pidfile         : chr "/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b9171afba424.pid"
[17:47:32.153]  $ rshcmd_label    : NULL
[17:47:32.153]  $ rsh_call        : NULL
[17:47:32.153]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:32.153]  $ localMachine    : logi TRUE
[17:47:32.153]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:32.153]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:32.153]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:32.153]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:32.153]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:32.153]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:32.153]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:32.153]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:32.153]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:32.153]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:32.153]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:32.153]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:32.153]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:32.153]  $ arguments       :List of 28
[17:47:32.153]   ..$ worker          : chr "localhost"
[17:47:32.153]   ..$ master          : NULL
[17:47:32.153]   ..$ port            : int 11629
[17:47:32.153]   ..$ connectTimeout  : num 120
[17:47:32.153]   ..$ timeout         : num 2592000
[17:47:32.153]   ..$ rscript         : NULL
[17:47:32.153]   ..$ homogeneous     : NULL
[17:47:32.153]   ..$ rscript_args    : NULL
[17:47:32.153]   ..$ rscript_envs    : NULL
[17:47:32.153]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:32.153]   ..$ rscript_startup : NULL
[17:47:32.153]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:32.153]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:32.153]   ..$ methods         : logi TRUE
[17:47:32.153]   ..$ socketOptions   : chr "no-delay"
[17:47:32.153]   ..$ useXDR          : logi FALSE
[17:47:32.153]   ..$ outfile         : chr "/dev/null"
[17:47:32.153]   ..$ renice          : int NA
[17:47:32.153]   ..$ rshcmd          : NULL
[17:47:32.153]   ..$ user            : NULL
[17:47:32.153]   ..$ revtunnel       : logi NA
[17:47:32.153]   ..$ rshlogfile      : NULL
[17:47:32.153]   ..$ rshopts         : NULL
[17:47:32.153]   ..$ rank            : int 1
[17:47:32.153]   ..$ manual          : logi FALSE
[17:47:32.153]   ..$ dryrun          : logi FALSE
[17:47:32.153]   ..$ quiet           : logi FALSE
[17:47:32.153]   ..$ setup_strategy  : chr "parallel"
[17:47:32.153]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:32.173] [local output] System call to launch all workers:
[17:47:32.173] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b9171afba424.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11629 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:32.173] [local output] Starting PSOCK main server
[17:47:32.174] [local output] Workers launched
[17:47:32.175] [local output] Waiting for workers to connect back
[17:47:32.175]  - [local output] 0 workers out of 2 ready
[17:47:32.434]  - [local output] 0 workers out of 2 ready
[17:47:32.434]  - [local output] 1 workers out of 2 ready
[17:47:32.439]  - [local output] 1 workers out of 2 ready
[17:47:32.440]  - [local output] 2 workers out of 2 ready
[17:47:32.440] [local output] Launching of workers completed
[17:47:32.440] [local output] Collecting session information from workers
[17:47:32.441] [local output]  - Worker #1 of 2
[17:47:32.441] [local output]  - Worker #2 of 2
[17:47:32.441] [local output] makeClusterPSOCK() ... done
[17:47:32.452] Packages needed by the future expression (n = 0): <none>
[17:47:32.452] Packages needed by future strategies (n = 1): ‘future’
[17:47:32.453] {
[17:47:32.453]     {
[17:47:32.453]         {
[17:47:32.453]             ...future.startTime <- base::Sys.time()
[17:47:32.453]             {
[17:47:32.453]                 {
[17:47:32.453]                   {
[17:47:32.453]                     {
[17:47:32.453]                       {
[17:47:32.453]                         base::local({
[17:47:32.453]                           has_future <- base::requireNamespace("future", 
[17:47:32.453]                             quietly = TRUE)
[17:47:32.453]                           if (has_future) {
[17:47:32.453]                             ns <- base::getNamespace("future")
[17:47:32.453]                             version <- ns[[".package"]][["version"]]
[17:47:32.453]                             if (is.null(version)) 
[17:47:32.453]                               version <- utils::packageVersion("future")
[17:47:32.453]                           }
[17:47:32.453]                           else {
[17:47:32.453]                             version <- NULL
[17:47:32.453]                           }
[17:47:32.453]                           if (!has_future || version < "1.8.0") {
[17:47:32.453]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:32.453]                               "", base::R.version$version.string), 
[17:47:32.453]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:32.453]                                 base::R.version$platform, 8 * 
[17:47:32.453]                                   base::.Machine$sizeof.pointer), 
[17:47:32.453]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:32.453]                                 "release", "version")], collapse = " "), 
[17:47:32.453]                               hostname = base::Sys.info()[["nodename"]])
[17:47:32.453]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:32.453]                               info)
[17:47:32.453]                             info <- base::paste(info, collapse = "; ")
[17:47:32.453]                             if (!has_future) {
[17:47:32.453]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:32.453]                                 info)
[17:47:32.453]                             }
[17:47:32.453]                             else {
[17:47:32.453]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:32.453]                                 info, version)
[17:47:32.453]                             }
[17:47:32.453]                             base::stop(msg)
[17:47:32.453]                           }
[17:47:32.453]                         })
[17:47:32.453]                       }
[17:47:32.453]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:32.453]                       base::options(mc.cores = 1L)
[17:47:32.453]                     }
[17:47:32.453]                     base::local({
[17:47:32.453]                       for (pkg in "future") {
[17:47:32.453]                         base::loadNamespace(pkg)
[17:47:32.453]                         base::library(pkg, character.only = TRUE)
[17:47:32.453]                       }
[17:47:32.453]                     })
[17:47:32.453]                   }
[17:47:32.453]                   ...future.strategy.old <- future::plan("list")
[17:47:32.453]                   options(future.plan = NULL)
[17:47:32.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.453]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:32.453]                   {
[17:47:32.453]                     future <- SequentialFuture(..., envir = envir)
[17:47:32.453]                     if (!future$lazy) 
[17:47:32.453]                       future <- run(future)
[17:47:32.453]                     invisible(future)
[17:47:32.453]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:32.453]                 }
[17:47:32.453]                 ...future.workdir <- getwd()
[17:47:32.453]             }
[17:47:32.453]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:32.453]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:32.453]         }
[17:47:32.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:32.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:32.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:32.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:32.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:32.453]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:32.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:32.453]             base::names(...future.oldOptions))
[17:47:32.453]     }
[17:47:32.453]     if (FALSE) {
[17:47:32.453]     }
[17:47:32.453]     else {
[17:47:32.453]         if (TRUE) {
[17:47:32.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:32.453]                 open = "w")
[17:47:32.453]         }
[17:47:32.453]         else {
[17:47:32.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:32.453]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:32.453]         }
[17:47:32.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:32.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:32.453]             base::sink(type = "output", split = FALSE)
[17:47:32.453]             base::close(...future.stdout)
[17:47:32.453]         }, add = TRUE)
[17:47:32.453]     }
[17:47:32.453]     ...future.frame <- base::sys.nframe()
[17:47:32.453]     ...future.conditions <- base::list()
[17:47:32.453]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:32.453]     if (FALSE) {
[17:47:32.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:32.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:32.453]     }
[17:47:32.453]     ...future.result <- base::tryCatch({
[17:47:32.453]         base::withCallingHandlers({
[17:47:32.453]             ...future.value <- base::withVisible(base::local({
[17:47:32.453]                 ...future.makeSendCondition <- base::local({
[17:47:32.453]                   sendCondition <- NULL
[17:47:32.453]                   function(frame = 1L) {
[17:47:32.453]                     if (is.function(sendCondition)) 
[17:47:32.453]                       return(sendCondition)
[17:47:32.453]                     ns <- getNamespace("parallel")
[17:47:32.453]                     if (exists("sendData", mode = "function", 
[17:47:32.453]                       envir = ns)) {
[17:47:32.453]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:32.453]                         envir = ns)
[17:47:32.453]                       envir <- sys.frame(frame)
[17:47:32.453]                       master <- NULL
[17:47:32.453]                       while (!identical(envir, .GlobalEnv) && 
[17:47:32.453]                         !identical(envir, emptyenv())) {
[17:47:32.453]                         if (exists("master", mode = "list", envir = envir, 
[17:47:32.453]                           inherits = FALSE)) {
[17:47:32.453]                           master <- get("master", mode = "list", 
[17:47:32.453]                             envir = envir, inherits = FALSE)
[17:47:32.453]                           if (inherits(master, c("SOCKnode", 
[17:47:32.453]                             "SOCK0node"))) {
[17:47:32.453]                             sendCondition <<- function(cond) {
[17:47:32.453]                               data <- list(type = "VALUE", value = cond, 
[17:47:32.453]                                 success = TRUE)
[17:47:32.453]                               parallel_sendData(master, data)
[17:47:32.453]                             }
[17:47:32.453]                             return(sendCondition)
[17:47:32.453]                           }
[17:47:32.453]                         }
[17:47:32.453]                         frame <- frame + 1L
[17:47:32.453]                         envir <- sys.frame(frame)
[17:47:32.453]                       }
[17:47:32.453]                     }
[17:47:32.453]                     sendCondition <<- function(cond) NULL
[17:47:32.453]                   }
[17:47:32.453]                 })
[17:47:32.453]                 withCallingHandlers({
[17:47:32.453]                   NA
[17:47:32.453]                 }, immediateCondition = function(cond) {
[17:47:32.453]                   sendCondition <- ...future.makeSendCondition()
[17:47:32.453]                   sendCondition(cond)
[17:47:32.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.453]                   {
[17:47:32.453]                     inherits <- base::inherits
[17:47:32.453]                     invokeRestart <- base::invokeRestart
[17:47:32.453]                     is.null <- base::is.null
[17:47:32.453]                     muffled <- FALSE
[17:47:32.453]                     if (inherits(cond, "message")) {
[17:47:32.453]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:32.453]                       if (muffled) 
[17:47:32.453]                         invokeRestart("muffleMessage")
[17:47:32.453]                     }
[17:47:32.453]                     else if (inherits(cond, "warning")) {
[17:47:32.453]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:32.453]                       if (muffled) 
[17:47:32.453]                         invokeRestart("muffleWarning")
[17:47:32.453]                     }
[17:47:32.453]                     else if (inherits(cond, "condition")) {
[17:47:32.453]                       if (!is.null(pattern)) {
[17:47:32.453]                         computeRestarts <- base::computeRestarts
[17:47:32.453]                         grepl <- base::grepl
[17:47:32.453]                         restarts <- computeRestarts(cond)
[17:47:32.453]                         for (restart in restarts) {
[17:47:32.453]                           name <- restart$name
[17:47:32.453]                           if (is.null(name)) 
[17:47:32.453]                             next
[17:47:32.453]                           if (!grepl(pattern, name)) 
[17:47:32.453]                             next
[17:47:32.453]                           invokeRestart(restart)
[17:47:32.453]                           muffled <- TRUE
[17:47:32.453]                           break
[17:47:32.453]                         }
[17:47:32.453]                       }
[17:47:32.453]                     }
[17:47:32.453]                     invisible(muffled)
[17:47:32.453]                   }
[17:47:32.453]                   muffleCondition(cond)
[17:47:32.453]                 })
[17:47:32.453]             }))
[17:47:32.453]             future::FutureResult(value = ...future.value$value, 
[17:47:32.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.453]                   ...future.rng), globalenv = if (FALSE) 
[17:47:32.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:32.453]                     ...future.globalenv.names))
[17:47:32.453]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:32.453]         }, condition = base::local({
[17:47:32.453]             c <- base::c
[17:47:32.453]             inherits <- base::inherits
[17:47:32.453]             invokeRestart <- base::invokeRestart
[17:47:32.453]             length <- base::length
[17:47:32.453]             list <- base::list
[17:47:32.453]             seq.int <- base::seq.int
[17:47:32.453]             signalCondition <- base::signalCondition
[17:47:32.453]             sys.calls <- base::sys.calls
[17:47:32.453]             `[[` <- base::`[[`
[17:47:32.453]             `+` <- base::`+`
[17:47:32.453]             `<<-` <- base::`<<-`
[17:47:32.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:32.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:32.453]                   3L)]
[17:47:32.453]             }
[17:47:32.453]             function(cond) {
[17:47:32.453]                 is_error <- inherits(cond, "error")
[17:47:32.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:32.453]                   NULL)
[17:47:32.453]                 if (is_error) {
[17:47:32.453]                   sessionInformation <- function() {
[17:47:32.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:32.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:32.453]                       search = base::search(), system = base::Sys.info())
[17:47:32.453]                   }
[17:47:32.453]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:32.453]                     cond$call), session = sessionInformation(), 
[17:47:32.453]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:32.453]                   signalCondition(cond)
[17:47:32.453]                 }
[17:47:32.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:32.453]                 "immediateCondition"))) {
[17:47:32.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:32.453]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:32.453]                   if (TRUE && !signal) {
[17:47:32.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.453]                     {
[17:47:32.453]                       inherits <- base::inherits
[17:47:32.453]                       invokeRestart <- base::invokeRestart
[17:47:32.453]                       is.null <- base::is.null
[17:47:32.453]                       muffled <- FALSE
[17:47:32.453]                       if (inherits(cond, "message")) {
[17:47:32.453]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.453]                         if (muffled) 
[17:47:32.453]                           invokeRestart("muffleMessage")
[17:47:32.453]                       }
[17:47:32.453]                       else if (inherits(cond, "warning")) {
[17:47:32.453]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.453]                         if (muffled) 
[17:47:32.453]                           invokeRestart("muffleWarning")
[17:47:32.453]                       }
[17:47:32.453]                       else if (inherits(cond, "condition")) {
[17:47:32.453]                         if (!is.null(pattern)) {
[17:47:32.453]                           computeRestarts <- base::computeRestarts
[17:47:32.453]                           grepl <- base::grepl
[17:47:32.453]                           restarts <- computeRestarts(cond)
[17:47:32.453]                           for (restart in restarts) {
[17:47:32.453]                             name <- restart$name
[17:47:32.453]                             if (is.null(name)) 
[17:47:32.453]                               next
[17:47:32.453]                             if (!grepl(pattern, name)) 
[17:47:32.453]                               next
[17:47:32.453]                             invokeRestart(restart)
[17:47:32.453]                             muffled <- TRUE
[17:47:32.453]                             break
[17:47:32.453]                           }
[17:47:32.453]                         }
[17:47:32.453]                       }
[17:47:32.453]                       invisible(muffled)
[17:47:32.453]                     }
[17:47:32.453]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.453]                   }
[17:47:32.453]                 }
[17:47:32.453]                 else {
[17:47:32.453]                   if (TRUE) {
[17:47:32.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.453]                     {
[17:47:32.453]                       inherits <- base::inherits
[17:47:32.453]                       invokeRestart <- base::invokeRestart
[17:47:32.453]                       is.null <- base::is.null
[17:47:32.453]                       muffled <- FALSE
[17:47:32.453]                       if (inherits(cond, "message")) {
[17:47:32.453]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.453]                         if (muffled) 
[17:47:32.453]                           invokeRestart("muffleMessage")
[17:47:32.453]                       }
[17:47:32.453]                       else if (inherits(cond, "warning")) {
[17:47:32.453]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.453]                         if (muffled) 
[17:47:32.453]                           invokeRestart("muffleWarning")
[17:47:32.453]                       }
[17:47:32.453]                       else if (inherits(cond, "condition")) {
[17:47:32.453]                         if (!is.null(pattern)) {
[17:47:32.453]                           computeRestarts <- base::computeRestarts
[17:47:32.453]                           grepl <- base::grepl
[17:47:32.453]                           restarts <- computeRestarts(cond)
[17:47:32.453]                           for (restart in restarts) {
[17:47:32.453]                             name <- restart$name
[17:47:32.453]                             if (is.null(name)) 
[17:47:32.453]                               next
[17:47:32.453]                             if (!grepl(pattern, name)) 
[17:47:32.453]                               next
[17:47:32.453]                             invokeRestart(restart)
[17:47:32.453]                             muffled <- TRUE
[17:47:32.453]                             break
[17:47:32.453]                           }
[17:47:32.453]                         }
[17:47:32.453]                       }
[17:47:32.453]                       invisible(muffled)
[17:47:32.453]                     }
[17:47:32.453]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.453]                   }
[17:47:32.453]                 }
[17:47:32.453]             }
[17:47:32.453]         }))
[17:47:32.453]     }, error = function(ex) {
[17:47:32.453]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:32.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.453]                 ...future.rng), started = ...future.startTime, 
[17:47:32.453]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:32.453]             version = "1.8"), class = "FutureResult")
[17:47:32.453]     }, finally = {
[17:47:32.453]         if (!identical(...future.workdir, getwd())) 
[17:47:32.453]             setwd(...future.workdir)
[17:47:32.453]         {
[17:47:32.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:32.453]                 ...future.oldOptions$nwarnings <- NULL
[17:47:32.453]             }
[17:47:32.453]             base::options(...future.oldOptions)
[17:47:32.453]             if (.Platform$OS.type == "windows") {
[17:47:32.453]                 old_names <- names(...future.oldEnvVars)
[17:47:32.453]                 envs <- base::Sys.getenv()
[17:47:32.453]                 names <- names(envs)
[17:47:32.453]                 common <- intersect(names, old_names)
[17:47:32.453]                 added <- setdiff(names, old_names)
[17:47:32.453]                 removed <- setdiff(old_names, names)
[17:47:32.453]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:32.453]                   envs[common]]
[17:47:32.453]                 NAMES <- toupper(changed)
[17:47:32.453]                 args <- list()
[17:47:32.453]                 for (kk in seq_along(NAMES)) {
[17:47:32.453]                   name <- changed[[kk]]
[17:47:32.453]                   NAME <- NAMES[[kk]]
[17:47:32.453]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.453]                     next
[17:47:32.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.453]                 }
[17:47:32.453]                 NAMES <- toupper(added)
[17:47:32.453]                 for (kk in seq_along(NAMES)) {
[17:47:32.453]                   name <- added[[kk]]
[17:47:32.453]                   NAME <- NAMES[[kk]]
[17:47:32.453]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.453]                     next
[17:47:32.453]                   args[[name]] <- ""
[17:47:32.453]                 }
[17:47:32.453]                 NAMES <- toupper(removed)
[17:47:32.453]                 for (kk in seq_along(NAMES)) {
[17:47:32.453]                   name <- removed[[kk]]
[17:47:32.453]                   NAME <- NAMES[[kk]]
[17:47:32.453]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.453]                     next
[17:47:32.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.453]                 }
[17:47:32.453]                 if (length(args) > 0) 
[17:47:32.453]                   base::do.call(base::Sys.setenv, args = args)
[17:47:32.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:32.453]             }
[17:47:32.453]             else {
[17:47:32.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:32.453]             }
[17:47:32.453]             {
[17:47:32.453]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:32.453]                   0L) {
[17:47:32.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:32.453]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:32.453]                   base::options(opts)
[17:47:32.453]                 }
[17:47:32.453]                 {
[17:47:32.453]                   {
[17:47:32.453]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:32.453]                     NULL
[17:47:32.453]                   }
[17:47:32.453]                   options(future.plan = NULL)
[17:47:32.453]                   if (is.na(NA_character_)) 
[17:47:32.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:32.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:32.453]                     .init = FALSE)
[17:47:32.453]                 }
[17:47:32.453]             }
[17:47:32.453]         }
[17:47:32.453]     })
[17:47:32.453]     if (TRUE) {
[17:47:32.453]         base::sink(type = "output", split = FALSE)
[17:47:32.453]         if (TRUE) {
[17:47:32.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:32.453]         }
[17:47:32.453]         else {
[17:47:32.453]             ...future.result["stdout"] <- base::list(NULL)
[17:47:32.453]         }
[17:47:32.453]         base::close(...future.stdout)
[17:47:32.453]         ...future.stdout <- NULL
[17:47:32.453]     }
[17:47:32.453]     ...future.result$conditions <- ...future.conditions
[17:47:32.453]     ...future.result$finished <- base::Sys.time()
[17:47:32.453]     ...future.result
[17:47:32.453] }
[17:47:32.506] MultisessionFuture started
[17:47:32.506] result() for ClusterFuture ...
[17:47:32.506] receiveMessageFromWorker() for ClusterFuture ...
[17:47:32.506] - Validating connection of MultisessionFuture
[17:47:32.541] - received message: FutureResult
[17:47:32.542] - Received FutureResult
[17:47:32.542] - Erased future from FutureRegistry
[17:47:32.542] result() for ClusterFuture ...
[17:47:32.542] - result already collected: FutureResult
[17:47:32.542] result() for ClusterFuture ... done
[17:47:32.542] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:32.542] result() for ClusterFuture ... done
[17:47:32.542] result() for ClusterFuture ...
[17:47:32.542] - result already collected: FutureResult
[17:47:32.542] result() for ClusterFuture ... done
[17:47:32.543] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:47:32.546] plan(): nbrOfWorkers() = 2
[17:47:32.547] getGlobalsAndPackages() ...
[17:47:32.547] Searching for globals...
[17:47:32.564] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:32.565] Searching for globals ... DONE
[17:47:32.565] Resolving globals: FALSE
[17:47:32.566] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[17:47:32.566] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:32.566] - globals: [2] ‘nested’, ‘strategy2’
[17:47:32.566] - packages: [1] ‘future’
[17:47:32.566] getGlobalsAndPackages() ... DONE
[17:47:32.567] run() for ‘Future’ ...
[17:47:32.567] - state: ‘created’
[17:47:32.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:32.581] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:32.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:32.583]   - Field: ‘node’
[17:47:32.584]   - Field: ‘label’
[17:47:32.584]   - Field: ‘local’
[17:47:32.584]   - Field: ‘owner’
[17:47:32.584]   - Field: ‘envir’
[17:47:32.584]   - Field: ‘workers’
[17:47:32.584]   - Field: ‘packages’
[17:47:32.584]   - Field: ‘gc’
[17:47:32.584]   - Field: ‘conditions’
[17:47:32.584]   - Field: ‘persistent’
[17:47:32.584]   - Field: ‘expr’
[17:47:32.584]   - Field: ‘uuid’
[17:47:32.585]   - Field: ‘seed’
[17:47:32.585]   - Field: ‘version’
[17:47:32.585]   - Field: ‘result’
[17:47:32.585]   - Field: ‘asynchronous’
[17:47:32.585]   - Field: ‘calls’
[17:47:32.585]   - Field: ‘globals’
[17:47:32.585]   - Field: ‘stdout’
[17:47:32.585]   - Field: ‘earlySignal’
[17:47:32.585]   - Field: ‘lazy’
[17:47:32.585]   - Field: ‘state’
[17:47:32.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:32.586] - Launch lazy future ...
[17:47:32.586] Packages needed by the future expression (n = 1): ‘future’
[17:47:32.586] Packages needed by future strategies (n = 1): ‘future’
[17:47:32.586] {
[17:47:32.586]     {
[17:47:32.586]         {
[17:47:32.586]             ...future.startTime <- base::Sys.time()
[17:47:32.586]             {
[17:47:32.586]                 {
[17:47:32.586]                   {
[17:47:32.586]                     {
[17:47:32.586]                       {
[17:47:32.586]                         base::local({
[17:47:32.586]                           has_future <- base::requireNamespace("future", 
[17:47:32.586]                             quietly = TRUE)
[17:47:32.586]                           if (has_future) {
[17:47:32.586]                             ns <- base::getNamespace("future")
[17:47:32.586]                             version <- ns[[".package"]][["version"]]
[17:47:32.586]                             if (is.null(version)) 
[17:47:32.586]                               version <- utils::packageVersion("future")
[17:47:32.586]                           }
[17:47:32.586]                           else {
[17:47:32.586]                             version <- NULL
[17:47:32.586]                           }
[17:47:32.586]                           if (!has_future || version < "1.8.0") {
[17:47:32.586]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:32.586]                               "", base::R.version$version.string), 
[17:47:32.586]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:32.586]                                 base::R.version$platform, 8 * 
[17:47:32.586]                                   base::.Machine$sizeof.pointer), 
[17:47:32.586]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:32.586]                                 "release", "version")], collapse = " "), 
[17:47:32.586]                               hostname = base::Sys.info()[["nodename"]])
[17:47:32.586]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:32.586]                               info)
[17:47:32.586]                             info <- base::paste(info, collapse = "; ")
[17:47:32.586]                             if (!has_future) {
[17:47:32.586]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:32.586]                                 info)
[17:47:32.586]                             }
[17:47:32.586]                             else {
[17:47:32.586]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:32.586]                                 info, version)
[17:47:32.586]                             }
[17:47:32.586]                             base::stop(msg)
[17:47:32.586]                           }
[17:47:32.586]                         })
[17:47:32.586]                       }
[17:47:32.586]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:32.586]                       base::options(mc.cores = 1L)
[17:47:32.586]                     }
[17:47:32.586]                     base::local({
[17:47:32.586]                       for (pkg in "future") {
[17:47:32.586]                         base::loadNamespace(pkg)
[17:47:32.586]                         base::library(pkg, character.only = TRUE)
[17:47:32.586]                       }
[17:47:32.586]                     })
[17:47:32.586]                   }
[17:47:32.586]                   ...future.strategy.old <- future::plan("list")
[17:47:32.586]                   options(future.plan = NULL)
[17:47:32.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.586]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:32.586]                   {
[17:47:32.586]                     future <- SequentialFuture(..., envir = envir)
[17:47:32.586]                     if (!future$lazy) 
[17:47:32.586]                       future <- run(future)
[17:47:32.586]                     invisible(future)
[17:47:32.586]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:32.586]                 }
[17:47:32.586]                 ...future.workdir <- getwd()
[17:47:32.586]             }
[17:47:32.586]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:32.586]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:32.586]         }
[17:47:32.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:32.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:32.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:32.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:32.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:32.586]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:32.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:32.586]             base::names(...future.oldOptions))
[17:47:32.586]     }
[17:47:32.586]     if (FALSE) {
[17:47:32.586]     }
[17:47:32.586]     else {
[17:47:32.586]         if (TRUE) {
[17:47:32.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:32.586]                 open = "w")
[17:47:32.586]         }
[17:47:32.586]         else {
[17:47:32.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:32.586]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:32.586]         }
[17:47:32.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:32.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:32.586]             base::sink(type = "output", split = FALSE)
[17:47:32.586]             base::close(...future.stdout)
[17:47:32.586]         }, add = TRUE)
[17:47:32.586]     }
[17:47:32.586]     ...future.frame <- base::sys.nframe()
[17:47:32.586]     ...future.conditions <- base::list()
[17:47:32.586]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:32.586]     if (FALSE) {
[17:47:32.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:32.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:32.586]     }
[17:47:32.586]     ...future.result <- base::tryCatch({
[17:47:32.586]         base::withCallingHandlers({
[17:47:32.586]             ...future.value <- base::withVisible(base::local({
[17:47:32.586]                 ...future.makeSendCondition <- base::local({
[17:47:32.586]                   sendCondition <- NULL
[17:47:32.586]                   function(frame = 1L) {
[17:47:32.586]                     if (is.function(sendCondition)) 
[17:47:32.586]                       return(sendCondition)
[17:47:32.586]                     ns <- getNamespace("parallel")
[17:47:32.586]                     if (exists("sendData", mode = "function", 
[17:47:32.586]                       envir = ns)) {
[17:47:32.586]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:32.586]                         envir = ns)
[17:47:32.586]                       envir <- sys.frame(frame)
[17:47:32.586]                       master <- NULL
[17:47:32.586]                       while (!identical(envir, .GlobalEnv) && 
[17:47:32.586]                         !identical(envir, emptyenv())) {
[17:47:32.586]                         if (exists("master", mode = "list", envir = envir, 
[17:47:32.586]                           inherits = FALSE)) {
[17:47:32.586]                           master <- get("master", mode = "list", 
[17:47:32.586]                             envir = envir, inherits = FALSE)
[17:47:32.586]                           if (inherits(master, c("SOCKnode", 
[17:47:32.586]                             "SOCK0node"))) {
[17:47:32.586]                             sendCondition <<- function(cond) {
[17:47:32.586]                               data <- list(type = "VALUE", value = cond, 
[17:47:32.586]                                 success = TRUE)
[17:47:32.586]                               parallel_sendData(master, data)
[17:47:32.586]                             }
[17:47:32.586]                             return(sendCondition)
[17:47:32.586]                           }
[17:47:32.586]                         }
[17:47:32.586]                         frame <- frame + 1L
[17:47:32.586]                         envir <- sys.frame(frame)
[17:47:32.586]                       }
[17:47:32.586]                     }
[17:47:32.586]                     sendCondition <<- function(cond) NULL
[17:47:32.586]                   }
[17:47:32.586]                 })
[17:47:32.586]                 withCallingHandlers({
[17:47:32.586]                   {
[17:47:32.586]                     a <- 1L
[17:47:32.586]                     plan_a <- unclass(future::plan("list"))
[17:47:32.586]                     nested_a <- nested[-1]
[17:47:32.586]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:32.586]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:32.586]                       strategy2))
[17:47:32.586]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:32.586]                       "init") <- NULL
[17:47:32.586]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:32.586]                       "init") <- NULL
[17:47:32.586]                     stopifnot(all.equal(plan_a, nested_a))
[17:47:32.586]                     y %<-% {
[17:47:32.586]                       b <- 2L
[17:47:32.586]                       plan_b <- future::plan("list")
[17:47:32.586]                       nested_b <- nested_a[-1]
[17:47:32.586]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:32.586]                         1L, inherits(plan_b[[1]], "future"), 
[17:47:32.586]                         inherits(future::plan("next"), "sequential"))
[17:47:32.586]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:32.586]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:32.586]                     }
[17:47:32.586]                     y
[17:47:32.586]                   }
[17:47:32.586]                 }, immediateCondition = function(cond) {
[17:47:32.586]                   sendCondition <- ...future.makeSendCondition()
[17:47:32.586]                   sendCondition(cond)
[17:47:32.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.586]                   {
[17:47:32.586]                     inherits <- base::inherits
[17:47:32.586]                     invokeRestart <- base::invokeRestart
[17:47:32.586]                     is.null <- base::is.null
[17:47:32.586]                     muffled <- FALSE
[17:47:32.586]                     if (inherits(cond, "message")) {
[17:47:32.586]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:32.586]                       if (muffled) 
[17:47:32.586]                         invokeRestart("muffleMessage")
[17:47:32.586]                     }
[17:47:32.586]                     else if (inherits(cond, "warning")) {
[17:47:32.586]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:32.586]                       if (muffled) 
[17:47:32.586]                         invokeRestart("muffleWarning")
[17:47:32.586]                     }
[17:47:32.586]                     else if (inherits(cond, "condition")) {
[17:47:32.586]                       if (!is.null(pattern)) {
[17:47:32.586]                         computeRestarts <- base::computeRestarts
[17:47:32.586]                         grepl <- base::grepl
[17:47:32.586]                         restarts <- computeRestarts(cond)
[17:47:32.586]                         for (restart in restarts) {
[17:47:32.586]                           name <- restart$name
[17:47:32.586]                           if (is.null(name)) 
[17:47:32.586]                             next
[17:47:32.586]                           if (!grepl(pattern, name)) 
[17:47:32.586]                             next
[17:47:32.586]                           invokeRestart(restart)
[17:47:32.586]                           muffled <- TRUE
[17:47:32.586]                           break
[17:47:32.586]                         }
[17:47:32.586]                       }
[17:47:32.586]                     }
[17:47:32.586]                     invisible(muffled)
[17:47:32.586]                   }
[17:47:32.586]                   muffleCondition(cond)
[17:47:32.586]                 })
[17:47:32.586]             }))
[17:47:32.586]             future::FutureResult(value = ...future.value$value, 
[17:47:32.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.586]                   ...future.rng), globalenv = if (FALSE) 
[17:47:32.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:32.586]                     ...future.globalenv.names))
[17:47:32.586]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:32.586]         }, condition = base::local({
[17:47:32.586]             c <- base::c
[17:47:32.586]             inherits <- base::inherits
[17:47:32.586]             invokeRestart <- base::invokeRestart
[17:47:32.586]             length <- base::length
[17:47:32.586]             list <- base::list
[17:47:32.586]             seq.int <- base::seq.int
[17:47:32.586]             signalCondition <- base::signalCondition
[17:47:32.586]             sys.calls <- base::sys.calls
[17:47:32.586]             `[[` <- base::`[[`
[17:47:32.586]             `+` <- base::`+`
[17:47:32.586]             `<<-` <- base::`<<-`
[17:47:32.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:32.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:32.586]                   3L)]
[17:47:32.586]             }
[17:47:32.586]             function(cond) {
[17:47:32.586]                 is_error <- inherits(cond, "error")
[17:47:32.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:32.586]                   NULL)
[17:47:32.586]                 if (is_error) {
[17:47:32.586]                   sessionInformation <- function() {
[17:47:32.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:32.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:32.586]                       search = base::search(), system = base::Sys.info())
[17:47:32.586]                   }
[17:47:32.586]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:32.586]                     cond$call), session = sessionInformation(), 
[17:47:32.586]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:32.586]                   signalCondition(cond)
[17:47:32.586]                 }
[17:47:32.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:32.586]                 "immediateCondition"))) {
[17:47:32.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:32.586]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:32.586]                   if (TRUE && !signal) {
[17:47:32.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.586]                     {
[17:47:32.586]                       inherits <- base::inherits
[17:47:32.586]                       invokeRestart <- base::invokeRestart
[17:47:32.586]                       is.null <- base::is.null
[17:47:32.586]                       muffled <- FALSE
[17:47:32.586]                       if (inherits(cond, "message")) {
[17:47:32.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.586]                         if (muffled) 
[17:47:32.586]                           invokeRestart("muffleMessage")
[17:47:32.586]                       }
[17:47:32.586]                       else if (inherits(cond, "warning")) {
[17:47:32.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.586]                         if (muffled) 
[17:47:32.586]                           invokeRestart("muffleWarning")
[17:47:32.586]                       }
[17:47:32.586]                       else if (inherits(cond, "condition")) {
[17:47:32.586]                         if (!is.null(pattern)) {
[17:47:32.586]                           computeRestarts <- base::computeRestarts
[17:47:32.586]                           grepl <- base::grepl
[17:47:32.586]                           restarts <- computeRestarts(cond)
[17:47:32.586]                           for (restart in restarts) {
[17:47:32.586]                             name <- restart$name
[17:47:32.586]                             if (is.null(name)) 
[17:47:32.586]                               next
[17:47:32.586]                             if (!grepl(pattern, name)) 
[17:47:32.586]                               next
[17:47:32.586]                             invokeRestart(restart)
[17:47:32.586]                             muffled <- TRUE
[17:47:32.586]                             break
[17:47:32.586]                           }
[17:47:32.586]                         }
[17:47:32.586]                       }
[17:47:32.586]                       invisible(muffled)
[17:47:32.586]                     }
[17:47:32.586]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.586]                   }
[17:47:32.586]                 }
[17:47:32.586]                 else {
[17:47:32.586]                   if (TRUE) {
[17:47:32.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.586]                     {
[17:47:32.586]                       inherits <- base::inherits
[17:47:32.586]                       invokeRestart <- base::invokeRestart
[17:47:32.586]                       is.null <- base::is.null
[17:47:32.586]                       muffled <- FALSE
[17:47:32.586]                       if (inherits(cond, "message")) {
[17:47:32.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.586]                         if (muffled) 
[17:47:32.586]                           invokeRestart("muffleMessage")
[17:47:32.586]                       }
[17:47:32.586]                       else if (inherits(cond, "warning")) {
[17:47:32.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.586]                         if (muffled) 
[17:47:32.586]                           invokeRestart("muffleWarning")
[17:47:32.586]                       }
[17:47:32.586]                       else if (inherits(cond, "condition")) {
[17:47:32.586]                         if (!is.null(pattern)) {
[17:47:32.586]                           computeRestarts <- base::computeRestarts
[17:47:32.586]                           grepl <- base::grepl
[17:47:32.586]                           restarts <- computeRestarts(cond)
[17:47:32.586]                           for (restart in restarts) {
[17:47:32.586]                             name <- restart$name
[17:47:32.586]                             if (is.null(name)) 
[17:47:32.586]                               next
[17:47:32.586]                             if (!grepl(pattern, name)) 
[17:47:32.586]                               next
[17:47:32.586]                             invokeRestart(restart)
[17:47:32.586]                             muffled <- TRUE
[17:47:32.586]                             break
[17:47:32.586]                           }
[17:47:32.586]                         }
[17:47:32.586]                       }
[17:47:32.586]                       invisible(muffled)
[17:47:32.586]                     }
[17:47:32.586]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.586]                   }
[17:47:32.586]                 }
[17:47:32.586]             }
[17:47:32.586]         }))
[17:47:32.586]     }, error = function(ex) {
[17:47:32.586]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:32.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.586]                 ...future.rng), started = ...future.startTime, 
[17:47:32.586]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:32.586]             version = "1.8"), class = "FutureResult")
[17:47:32.586]     }, finally = {
[17:47:32.586]         if (!identical(...future.workdir, getwd())) 
[17:47:32.586]             setwd(...future.workdir)
[17:47:32.586]         {
[17:47:32.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:32.586]                 ...future.oldOptions$nwarnings <- NULL
[17:47:32.586]             }
[17:47:32.586]             base::options(...future.oldOptions)
[17:47:32.586]             if (.Platform$OS.type == "windows") {
[17:47:32.586]                 old_names <- names(...future.oldEnvVars)
[17:47:32.586]                 envs <- base::Sys.getenv()
[17:47:32.586]                 names <- names(envs)
[17:47:32.586]                 common <- intersect(names, old_names)
[17:47:32.586]                 added <- setdiff(names, old_names)
[17:47:32.586]                 removed <- setdiff(old_names, names)
[17:47:32.586]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:32.586]                   envs[common]]
[17:47:32.586]                 NAMES <- toupper(changed)
[17:47:32.586]                 args <- list()
[17:47:32.586]                 for (kk in seq_along(NAMES)) {
[17:47:32.586]                   name <- changed[[kk]]
[17:47:32.586]                   NAME <- NAMES[[kk]]
[17:47:32.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.586]                     next
[17:47:32.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.586]                 }
[17:47:32.586]                 NAMES <- toupper(added)
[17:47:32.586]                 for (kk in seq_along(NAMES)) {
[17:47:32.586]                   name <- added[[kk]]
[17:47:32.586]                   NAME <- NAMES[[kk]]
[17:47:32.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.586]                     next
[17:47:32.586]                   args[[name]] <- ""
[17:47:32.586]                 }
[17:47:32.586]                 NAMES <- toupper(removed)
[17:47:32.586]                 for (kk in seq_along(NAMES)) {
[17:47:32.586]                   name <- removed[[kk]]
[17:47:32.586]                   NAME <- NAMES[[kk]]
[17:47:32.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.586]                     next
[17:47:32.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.586]                 }
[17:47:32.586]                 if (length(args) > 0) 
[17:47:32.586]                   base::do.call(base::Sys.setenv, args = args)
[17:47:32.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:32.586]             }
[17:47:32.586]             else {
[17:47:32.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:32.586]             }
[17:47:32.586]             {
[17:47:32.586]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:32.586]                   0L) {
[17:47:32.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:32.586]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:32.586]                   base::options(opts)
[17:47:32.586]                 }
[17:47:32.586]                 {
[17:47:32.586]                   {
[17:47:32.586]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:32.586]                     NULL
[17:47:32.586]                   }
[17:47:32.586]                   options(future.plan = NULL)
[17:47:32.586]                   if (is.na(NA_character_)) 
[17:47:32.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:32.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:32.586]                     .init = FALSE)
[17:47:32.586]                 }
[17:47:32.586]             }
[17:47:32.586]         }
[17:47:32.586]     })
[17:47:32.586]     if (TRUE) {
[17:47:32.586]         base::sink(type = "output", split = FALSE)
[17:47:32.586]         if (TRUE) {
[17:47:32.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:32.586]         }
[17:47:32.586]         else {
[17:47:32.586]             ...future.result["stdout"] <- base::list(NULL)
[17:47:32.586]         }
[17:47:32.586]         base::close(...future.stdout)
[17:47:32.586]         ...future.stdout <- NULL
[17:47:32.586]     }
[17:47:32.586]     ...future.result$conditions <- ...future.conditions
[17:47:32.586]     ...future.result$finished <- base::Sys.time()
[17:47:32.586]     ...future.result
[17:47:32.586] }
[17:47:32.589] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[17:47:32.590] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[17:47:32.632] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[17:47:32.632] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:47:32.632] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:47:32.632] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[17:47:32.633] MultisessionFuture started
[17:47:32.633] - Launch lazy future ... done
[17:47:32.633] run() for ‘MultisessionFuture’ ... done
[17:47:32.633] result() for ClusterFuture ...
[17:47:32.633] receiveMessageFromWorker() for ClusterFuture ...
[17:47:32.633] - Validating connection of MultisessionFuture
[17:47:32.698] - received message: FutureResult
[17:47:32.698] - Received FutureResult
[17:47:32.699] - Erased future from FutureRegistry
[17:47:32.699] result() for ClusterFuture ...
[17:47:32.699] - result already collected: FutureResult
[17:47:32.699] result() for ClusterFuture ... done
[17:47:32.699] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:32.699] result() for ClusterFuture ... done
[17:47:32.699] result() for ClusterFuture ...
[17:47:32.699] - result already collected: FutureResult
[17:47:32.699] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:32.704] getGlobalsAndPackages() ...
[17:47:32.704] Searching for globals...
[17:47:32.705] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:32.706] Searching for globals ... DONE
[17:47:32.706] Resolving globals: FALSE
[17:47:32.706] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:32.707] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:32.707] - globals: [1] ‘data’
[17:47:32.707] - packages: [1] ‘future’
[17:47:32.707] getGlobalsAndPackages() ... DONE
[17:47:32.707] run() for ‘Future’ ...
[17:47:32.707] - state: ‘created’
[17:47:32.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:32.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:32.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:32.722]   - Field: ‘node’
[17:47:32.722]   - Field: ‘label’
[17:47:32.722]   - Field: ‘local’
[17:47:32.722]   - Field: ‘owner’
[17:47:32.723]   - Field: ‘envir’
[17:47:32.723]   - Field: ‘workers’
[17:47:32.723]   - Field: ‘packages’
[17:47:32.723]   - Field: ‘gc’
[17:47:32.723]   - Field: ‘conditions’
[17:47:32.723]   - Field: ‘persistent’
[17:47:32.723]   - Field: ‘expr’
[17:47:32.723]   - Field: ‘uuid’
[17:47:32.723]   - Field: ‘seed’
[17:47:32.723]   - Field: ‘version’
[17:47:32.724]   - Field: ‘result’
[17:47:32.724]   - Field: ‘asynchronous’
[17:47:32.724]   - Field: ‘calls’
[17:47:32.724]   - Field: ‘globals’
[17:47:32.724]   - Field: ‘stdout’
[17:47:32.724]   - Field: ‘earlySignal’
[17:47:32.724]   - Field: ‘lazy’
[17:47:32.724]   - Field: ‘state’
[17:47:32.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:32.724] - Launch lazy future ...
[17:47:32.725] Packages needed by the future expression (n = 1): ‘future’
[17:47:32.725] Packages needed by future strategies (n = 1): ‘future’
[17:47:32.725] {
[17:47:32.725]     {
[17:47:32.725]         {
[17:47:32.725]             ...future.startTime <- base::Sys.time()
[17:47:32.725]             {
[17:47:32.725]                 {
[17:47:32.725]                   {
[17:47:32.725]                     {
[17:47:32.725]                       {
[17:47:32.725]                         base::local({
[17:47:32.725]                           has_future <- base::requireNamespace("future", 
[17:47:32.725]                             quietly = TRUE)
[17:47:32.725]                           if (has_future) {
[17:47:32.725]                             ns <- base::getNamespace("future")
[17:47:32.725]                             version <- ns[[".package"]][["version"]]
[17:47:32.725]                             if (is.null(version)) 
[17:47:32.725]                               version <- utils::packageVersion("future")
[17:47:32.725]                           }
[17:47:32.725]                           else {
[17:47:32.725]                             version <- NULL
[17:47:32.725]                           }
[17:47:32.725]                           if (!has_future || version < "1.8.0") {
[17:47:32.725]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:32.725]                               "", base::R.version$version.string), 
[17:47:32.725]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:32.725]                                 base::R.version$platform, 8 * 
[17:47:32.725]                                   base::.Machine$sizeof.pointer), 
[17:47:32.725]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:32.725]                                 "release", "version")], collapse = " "), 
[17:47:32.725]                               hostname = base::Sys.info()[["nodename"]])
[17:47:32.725]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:32.725]                               info)
[17:47:32.725]                             info <- base::paste(info, collapse = "; ")
[17:47:32.725]                             if (!has_future) {
[17:47:32.725]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:32.725]                                 info)
[17:47:32.725]                             }
[17:47:32.725]                             else {
[17:47:32.725]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:32.725]                                 info, version)
[17:47:32.725]                             }
[17:47:32.725]                             base::stop(msg)
[17:47:32.725]                           }
[17:47:32.725]                         })
[17:47:32.725]                       }
[17:47:32.725]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:32.725]                       base::options(mc.cores = 1L)
[17:47:32.725]                     }
[17:47:32.725]                     base::local({
[17:47:32.725]                       for (pkg in "future") {
[17:47:32.725]                         base::loadNamespace(pkg)
[17:47:32.725]                         base::library(pkg, character.only = TRUE)
[17:47:32.725]                       }
[17:47:32.725]                     })
[17:47:32.725]                   }
[17:47:32.725]                   ...future.strategy.old <- future::plan("list")
[17:47:32.725]                   options(future.plan = NULL)
[17:47:32.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.725]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:47:32.725]                   {
[17:47:32.725]                     future <- SequentialFuture(..., envir = envir)
[17:47:32.725]                     if (!future$lazy) 
[17:47:32.725]                       future <- run(future)
[17:47:32.725]                     invisible(future)
[17:47:32.725]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:32.725]                 }
[17:47:32.725]                 ...future.workdir <- getwd()
[17:47:32.725]             }
[17:47:32.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:32.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:32.725]         }
[17:47:32.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:32.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:32.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:32.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:32.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:32.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:32.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:32.725]             base::names(...future.oldOptions))
[17:47:32.725]     }
[17:47:32.725]     if (FALSE) {
[17:47:32.725]     }
[17:47:32.725]     else {
[17:47:32.725]         if (TRUE) {
[17:47:32.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:32.725]                 open = "w")
[17:47:32.725]         }
[17:47:32.725]         else {
[17:47:32.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:32.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:32.725]         }
[17:47:32.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:32.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:32.725]             base::sink(type = "output", split = FALSE)
[17:47:32.725]             base::close(...future.stdout)
[17:47:32.725]         }, add = TRUE)
[17:47:32.725]     }
[17:47:32.725]     ...future.frame <- base::sys.nframe()
[17:47:32.725]     ...future.conditions <- base::list()
[17:47:32.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:32.725]     if (FALSE) {
[17:47:32.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:32.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:32.725]     }
[17:47:32.725]     ...future.result <- base::tryCatch({
[17:47:32.725]         base::withCallingHandlers({
[17:47:32.725]             ...future.value <- base::withVisible(base::local({
[17:47:32.725]                 ...future.makeSendCondition <- base::local({
[17:47:32.725]                   sendCondition <- NULL
[17:47:32.725]                   function(frame = 1L) {
[17:47:32.725]                     if (is.function(sendCondition)) 
[17:47:32.725]                       return(sendCondition)
[17:47:32.725]                     ns <- getNamespace("parallel")
[17:47:32.725]                     if (exists("sendData", mode = "function", 
[17:47:32.725]                       envir = ns)) {
[17:47:32.725]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:32.725]                         envir = ns)
[17:47:32.725]                       envir <- sys.frame(frame)
[17:47:32.725]                       master <- NULL
[17:47:32.725]                       while (!identical(envir, .GlobalEnv) && 
[17:47:32.725]                         !identical(envir, emptyenv())) {
[17:47:32.725]                         if (exists("master", mode = "list", envir = envir, 
[17:47:32.725]                           inherits = FALSE)) {
[17:47:32.725]                           master <- get("master", mode = "list", 
[17:47:32.725]                             envir = envir, inherits = FALSE)
[17:47:32.725]                           if (inherits(master, c("SOCKnode", 
[17:47:32.725]                             "SOCK0node"))) {
[17:47:32.725]                             sendCondition <<- function(cond) {
[17:47:32.725]                               data <- list(type = "VALUE", value = cond, 
[17:47:32.725]                                 success = TRUE)
[17:47:32.725]                               parallel_sendData(master, data)
[17:47:32.725]                             }
[17:47:32.725]                             return(sendCondition)
[17:47:32.725]                           }
[17:47:32.725]                         }
[17:47:32.725]                         frame <- frame + 1L
[17:47:32.725]                         envir <- sys.frame(frame)
[17:47:32.725]                       }
[17:47:32.725]                     }
[17:47:32.725]                     sendCondition <<- function(cond) NULL
[17:47:32.725]                   }
[17:47:32.725]                 })
[17:47:32.725]                 withCallingHandlers({
[17:47:32.725]                   {
[17:47:32.725]                     value(future(subset(data, a == 2)))
[17:47:32.725]                   }
[17:47:32.725]                 }, immediateCondition = function(cond) {
[17:47:32.725]                   sendCondition <- ...future.makeSendCondition()
[17:47:32.725]                   sendCondition(cond)
[17:47:32.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.725]                   {
[17:47:32.725]                     inherits <- base::inherits
[17:47:32.725]                     invokeRestart <- base::invokeRestart
[17:47:32.725]                     is.null <- base::is.null
[17:47:32.725]                     muffled <- FALSE
[17:47:32.725]                     if (inherits(cond, "message")) {
[17:47:32.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:32.725]                       if (muffled) 
[17:47:32.725]                         invokeRestart("muffleMessage")
[17:47:32.725]                     }
[17:47:32.725]                     else if (inherits(cond, "warning")) {
[17:47:32.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:32.725]                       if (muffled) 
[17:47:32.725]                         invokeRestart("muffleWarning")
[17:47:32.725]                     }
[17:47:32.725]                     else if (inherits(cond, "condition")) {
[17:47:32.725]                       if (!is.null(pattern)) {
[17:47:32.725]                         computeRestarts <- base::computeRestarts
[17:47:32.725]                         grepl <- base::grepl
[17:47:32.725]                         restarts <- computeRestarts(cond)
[17:47:32.725]                         for (restart in restarts) {
[17:47:32.725]                           name <- restart$name
[17:47:32.725]                           if (is.null(name)) 
[17:47:32.725]                             next
[17:47:32.725]                           if (!grepl(pattern, name)) 
[17:47:32.725]                             next
[17:47:32.725]                           invokeRestart(restart)
[17:47:32.725]                           muffled <- TRUE
[17:47:32.725]                           break
[17:47:32.725]                         }
[17:47:32.725]                       }
[17:47:32.725]                     }
[17:47:32.725]                     invisible(muffled)
[17:47:32.725]                   }
[17:47:32.725]                   muffleCondition(cond)
[17:47:32.725]                 })
[17:47:32.725]             }))
[17:47:32.725]             future::FutureResult(value = ...future.value$value, 
[17:47:32.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.725]                   ...future.rng), globalenv = if (FALSE) 
[17:47:32.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:32.725]                     ...future.globalenv.names))
[17:47:32.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:32.725]         }, condition = base::local({
[17:47:32.725]             c <- base::c
[17:47:32.725]             inherits <- base::inherits
[17:47:32.725]             invokeRestart <- base::invokeRestart
[17:47:32.725]             length <- base::length
[17:47:32.725]             list <- base::list
[17:47:32.725]             seq.int <- base::seq.int
[17:47:32.725]             signalCondition <- base::signalCondition
[17:47:32.725]             sys.calls <- base::sys.calls
[17:47:32.725]             `[[` <- base::`[[`
[17:47:32.725]             `+` <- base::`+`
[17:47:32.725]             `<<-` <- base::`<<-`
[17:47:32.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:32.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:32.725]                   3L)]
[17:47:32.725]             }
[17:47:32.725]             function(cond) {
[17:47:32.725]                 is_error <- inherits(cond, "error")
[17:47:32.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:32.725]                   NULL)
[17:47:32.725]                 if (is_error) {
[17:47:32.725]                   sessionInformation <- function() {
[17:47:32.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:32.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:32.725]                       search = base::search(), system = base::Sys.info())
[17:47:32.725]                   }
[17:47:32.725]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:32.725]                     cond$call), session = sessionInformation(), 
[17:47:32.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:32.725]                   signalCondition(cond)
[17:47:32.725]                 }
[17:47:32.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:32.725]                 "immediateCondition"))) {
[17:47:32.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:32.725]                   ...future.conditions[[length(...future.conditions) + 
[17:47:32.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:32.725]                   if (TRUE && !signal) {
[17:47:32.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.725]                     {
[17:47:32.725]                       inherits <- base::inherits
[17:47:32.725]                       invokeRestart <- base::invokeRestart
[17:47:32.725]                       is.null <- base::is.null
[17:47:32.725]                       muffled <- FALSE
[17:47:32.725]                       if (inherits(cond, "message")) {
[17:47:32.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.725]                         if (muffled) 
[17:47:32.725]                           invokeRestart("muffleMessage")
[17:47:32.725]                       }
[17:47:32.725]                       else if (inherits(cond, "warning")) {
[17:47:32.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.725]                         if (muffled) 
[17:47:32.725]                           invokeRestart("muffleWarning")
[17:47:32.725]                       }
[17:47:32.725]                       else if (inherits(cond, "condition")) {
[17:47:32.725]                         if (!is.null(pattern)) {
[17:47:32.725]                           computeRestarts <- base::computeRestarts
[17:47:32.725]                           grepl <- base::grepl
[17:47:32.725]                           restarts <- computeRestarts(cond)
[17:47:32.725]                           for (restart in restarts) {
[17:47:32.725]                             name <- restart$name
[17:47:32.725]                             if (is.null(name)) 
[17:47:32.725]                               next
[17:47:32.725]                             if (!grepl(pattern, name)) 
[17:47:32.725]                               next
[17:47:32.725]                             invokeRestart(restart)
[17:47:32.725]                             muffled <- TRUE
[17:47:32.725]                             break
[17:47:32.725]                           }
[17:47:32.725]                         }
[17:47:32.725]                       }
[17:47:32.725]                       invisible(muffled)
[17:47:32.725]                     }
[17:47:32.725]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.725]                   }
[17:47:32.725]                 }
[17:47:32.725]                 else {
[17:47:32.725]                   if (TRUE) {
[17:47:32.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:32.725]                     {
[17:47:32.725]                       inherits <- base::inherits
[17:47:32.725]                       invokeRestart <- base::invokeRestart
[17:47:32.725]                       is.null <- base::is.null
[17:47:32.725]                       muffled <- FALSE
[17:47:32.725]                       if (inherits(cond, "message")) {
[17:47:32.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:32.725]                         if (muffled) 
[17:47:32.725]                           invokeRestart("muffleMessage")
[17:47:32.725]                       }
[17:47:32.725]                       else if (inherits(cond, "warning")) {
[17:47:32.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:32.725]                         if (muffled) 
[17:47:32.725]                           invokeRestart("muffleWarning")
[17:47:32.725]                       }
[17:47:32.725]                       else if (inherits(cond, "condition")) {
[17:47:32.725]                         if (!is.null(pattern)) {
[17:47:32.725]                           computeRestarts <- base::computeRestarts
[17:47:32.725]                           grepl <- base::grepl
[17:47:32.725]                           restarts <- computeRestarts(cond)
[17:47:32.725]                           for (restart in restarts) {
[17:47:32.725]                             name <- restart$name
[17:47:32.725]                             if (is.null(name)) 
[17:47:32.725]                               next
[17:47:32.725]                             if (!grepl(pattern, name)) 
[17:47:32.725]                               next
[17:47:32.725]                             invokeRestart(restart)
[17:47:32.725]                             muffled <- TRUE
[17:47:32.725]                             break
[17:47:32.725]                           }
[17:47:32.725]                         }
[17:47:32.725]                       }
[17:47:32.725]                       invisible(muffled)
[17:47:32.725]                     }
[17:47:32.725]                     muffleCondition(cond, pattern = "^muffle")
[17:47:32.725]                   }
[17:47:32.725]                 }
[17:47:32.725]             }
[17:47:32.725]         }))
[17:47:32.725]     }, error = function(ex) {
[17:47:32.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:32.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:32.725]                 ...future.rng), started = ...future.startTime, 
[17:47:32.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:32.725]             version = "1.8"), class = "FutureResult")
[17:47:32.725]     }, finally = {
[17:47:32.725]         if (!identical(...future.workdir, getwd())) 
[17:47:32.725]             setwd(...future.workdir)
[17:47:32.725]         {
[17:47:32.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:32.725]                 ...future.oldOptions$nwarnings <- NULL
[17:47:32.725]             }
[17:47:32.725]             base::options(...future.oldOptions)
[17:47:32.725]             if (.Platform$OS.type == "windows") {
[17:47:32.725]                 old_names <- names(...future.oldEnvVars)
[17:47:32.725]                 envs <- base::Sys.getenv()
[17:47:32.725]                 names <- names(envs)
[17:47:32.725]                 common <- intersect(names, old_names)
[17:47:32.725]                 added <- setdiff(names, old_names)
[17:47:32.725]                 removed <- setdiff(old_names, names)
[17:47:32.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:32.725]                   envs[common]]
[17:47:32.725]                 NAMES <- toupper(changed)
[17:47:32.725]                 args <- list()
[17:47:32.725]                 for (kk in seq_along(NAMES)) {
[17:47:32.725]                   name <- changed[[kk]]
[17:47:32.725]                   NAME <- NAMES[[kk]]
[17:47:32.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.725]                     next
[17:47:32.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.725]                 }
[17:47:32.725]                 NAMES <- toupper(added)
[17:47:32.725]                 for (kk in seq_along(NAMES)) {
[17:47:32.725]                   name <- added[[kk]]
[17:47:32.725]                   NAME <- NAMES[[kk]]
[17:47:32.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.725]                     next
[17:47:32.725]                   args[[name]] <- ""
[17:47:32.725]                 }
[17:47:32.725]                 NAMES <- toupper(removed)
[17:47:32.725]                 for (kk in seq_along(NAMES)) {
[17:47:32.725]                   name <- removed[[kk]]
[17:47:32.725]                   NAME <- NAMES[[kk]]
[17:47:32.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:32.725]                     next
[17:47:32.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:32.725]                 }
[17:47:32.725]                 if (length(args) > 0) 
[17:47:32.725]                   base::do.call(base::Sys.setenv, args = args)
[17:47:32.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:32.725]             }
[17:47:32.725]             else {
[17:47:32.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:32.725]             }
[17:47:32.725]             {
[17:47:32.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:32.725]                   0L) {
[17:47:32.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:32.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:32.725]                   base::options(opts)
[17:47:32.725]                 }
[17:47:32.725]                 {
[17:47:32.725]                   {
[17:47:32.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:32.725]                     NULL
[17:47:32.725]                   }
[17:47:32.725]                   options(future.plan = NULL)
[17:47:32.725]                   if (is.na(NA_character_)) 
[17:47:32.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:32.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:32.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:32.725]                     .init = FALSE)
[17:47:32.725]                 }
[17:47:32.725]             }
[17:47:32.725]         }
[17:47:32.725]     })
[17:47:32.725]     if (TRUE) {
[17:47:32.725]         base::sink(type = "output", split = FALSE)
[17:47:32.725]         if (TRUE) {
[17:47:32.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:32.725]         }
[17:47:32.725]         else {
[17:47:32.725]             ...future.result["stdout"] <- base::list(NULL)
[17:47:32.725]         }
[17:47:32.725]         base::close(...future.stdout)
[17:47:32.725]         ...future.stdout <- NULL
[17:47:32.725]     }
[17:47:32.725]     ...future.result$conditions <- ...future.conditions
[17:47:32.725]     ...future.result$finished <- base::Sys.time()
[17:47:32.725]     ...future.result
[17:47:32.725] }
[17:47:32.728] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:47:32.728] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:47:32.729] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:47:32.729] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:47:32.729] MultisessionFuture started
[17:47:32.729] - Launch lazy future ... done
[17:47:32.729] run() for ‘MultisessionFuture’ ... done
[17:47:32.729] result() for ClusterFuture ...
[17:47:32.730] receiveMessageFromWorker() for ClusterFuture ...
[17:47:32.730] - Validating connection of MultisessionFuture
[17:47:32.777] - received message: FutureResult
[17:47:32.777] - Received FutureResult
[17:47:32.777] - Erased future from FutureRegistry
[17:47:32.777] result() for ClusterFuture ...
[17:47:32.778] - result already collected: FutureResult
[17:47:32.778] result() for ClusterFuture ... done
[17:47:32.778] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:32.778] result() for ClusterFuture ... done
[17:47:32.778] result() for ClusterFuture ...
[17:47:32.778] - result already collected: FutureResult
[17:47:32.778] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[17:47:32.778] plan(): Setting new future strategy stack:
[17:47:32.779] List of future strategies:
[17:47:32.779] 1. multisession:
[17:47:32.779]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.779]    - tweaked: FALSE
[17:47:32.779]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.779] 2. multicore:
[17:47:32.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:32.779]    - tweaked: FALSE
[17:47:32.779]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.779] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:47:32.779] multisession:
[17:47:32.779] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:32.779] - tweaked: FALSE
[17:47:32.779] - call: plan(list(a = strategy1, b = strategy2))
[17:47:32.784] getGlobalsAndPackages() ...
[17:47:32.785] Not searching for globals
[17:47:32.785] - globals: [0] <none>
[17:47:32.785] getGlobalsAndPackages() ... DONE
[17:47:32.785] [local output] makeClusterPSOCK() ...
[17:47:32.789] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:32.790] [local output] Base port: 11635
[17:47:32.790] [local output] Getting setup options for 2 cluster nodes ...
[17:47:32.790] [local output]  - Node 1 of 2 ...
[17:47:32.790] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:32.791] [local output] Rscript port: 11635

[17:47:32.791] [local output]  - Node 2 of 2 ...
[17:47:32.792] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:32.792] [local output] Rscript port: 11635

[17:47:32.793] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:32.793] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:32.793] [local output] Setting up PSOCK nodes in parallel
[17:47:32.793] List of 36
[17:47:32.793]  $ worker          : chr "localhost"
[17:47:32.793]   ..- attr(*, "localhost")= logi TRUE
[17:47:32.793]  $ master          : chr "localhost"
[17:47:32.793]  $ port            : int 11635
[17:47:32.793]  $ connectTimeout  : num 120
[17:47:32.793]  $ timeout         : num 2592000
[17:47:32.793]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:32.793]  $ homogeneous     : logi TRUE
[17:47:32.793]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:32.793]  $ rscript_envs    : NULL
[17:47:32.793]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:32.793]  $ rscript_startup : NULL
[17:47:32.793]  $ rscript_sh      : chr "sh"
[17:47:32.793]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:32.793]  $ methods         : logi TRUE
[17:47:32.793]  $ socketOptions   : chr "no-delay"
[17:47:32.793]  $ useXDR          : logi FALSE
[17:47:32.793]  $ outfile         : chr "/dev/null"
[17:47:32.793]  $ renice          : int NA
[17:47:32.793]  $ rshcmd          : NULL
[17:47:32.793]  $ user            : chr(0) 
[17:47:32.793]  $ revtunnel       : logi FALSE
[17:47:32.793]  $ rshlogfile      : NULL
[17:47:32.793]  $ rshopts         : chr(0) 
[17:47:32.793]  $ rank            : int 1
[17:47:32.793]  $ manual          : logi FALSE
[17:47:32.793]  $ dryrun          : logi FALSE
[17:47:32.793]  $ quiet           : logi FALSE
[17:47:32.793]  $ setup_strategy  : chr "parallel"
[17:47:32.793]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:32.793]  $ pidfile         : chr "/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b91785f7def.pid"
[17:47:32.793]  $ rshcmd_label    : NULL
[17:47:32.793]  $ rsh_call        : NULL
[17:47:32.793]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:32.793]  $ localMachine    : logi TRUE
[17:47:32.793]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:32.793]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:32.793]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:32.793]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:32.793]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:32.793]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:32.793]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:32.793]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:32.793]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:32.793]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:32.793]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:32.793]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:32.793]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:32.793]  $ arguments       :List of 28
[17:47:32.793]   ..$ worker          : chr "localhost"
[17:47:32.793]   ..$ master          : NULL
[17:47:32.793]   ..$ port            : int 11635
[17:47:32.793]   ..$ connectTimeout  : num 120
[17:47:32.793]   ..$ timeout         : num 2592000
[17:47:32.793]   ..$ rscript         : NULL
[17:47:32.793]   ..$ homogeneous     : NULL
[17:47:32.793]   ..$ rscript_args    : NULL
[17:47:32.793]   ..$ rscript_envs    : NULL
[17:47:32.793]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:32.793]   ..$ rscript_startup : NULL
[17:47:32.793]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:32.793]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:32.793]   ..$ methods         : logi TRUE
[17:47:32.793]   ..$ socketOptions   : chr "no-delay"
[17:47:32.793]   ..$ useXDR          : logi FALSE
[17:47:32.793]   ..$ outfile         : chr "/dev/null"
[17:47:32.793]   ..$ renice          : int NA
[17:47:32.793]   ..$ rshcmd          : NULL
[17:47:32.793]   ..$ user            : NULL
[17:47:32.793]   ..$ revtunnel       : logi NA
[17:47:32.793]   ..$ rshlogfile      : NULL
[17:47:32.793]   ..$ rshopts         : NULL
[17:47:32.793]   ..$ rank            : int 1
[17:47:32.793]   ..$ manual          : logi FALSE
[17:47:32.793]   ..$ dryrun          : logi FALSE
[17:47:32.793]   ..$ quiet           : logi FALSE
[17:47:32.793]   ..$ setup_strategy  : chr "parallel"
[17:47:32.793]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:32.811] [local output] System call to launch all workers:
[17:47:32.811] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b91785f7def.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11635 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:32.811] [local output] Starting PSOCK main server
[17:47:32.813] [local output] Workers launched
[17:47:32.813] [local output] Waiting for workers to connect back
[17:47:32.813]  - [local output] 0 workers out of 2 ready
[17:47:33.067]  - [local output] 0 workers out of 2 ready
[17:47:33.068]  - [local output] 1 workers out of 2 ready
[17:47:33.071]  - [local output] 1 workers out of 2 ready
[17:47:33.072]  - [local output] 2 workers out of 2 ready
[17:47:33.072] [local output] Launching of workers completed
[17:47:33.072] [local output] Collecting session information from workers
[17:47:33.072] [local output]  - Worker #1 of 2
[17:47:33.073] [local output]  - Worker #2 of 2
[17:47:33.073] [local output] makeClusterPSOCK() ... done
[17:47:33.084] Packages needed by the future expression (n = 0): <none>
[17:47:33.084] Packages needed by future strategies (n = 1): ‘future’
[17:47:33.084] {
[17:47:33.084]     {
[17:47:33.084]         {
[17:47:33.084]             ...future.startTime <- base::Sys.time()
[17:47:33.084]             {
[17:47:33.084]                 {
[17:47:33.084]                   {
[17:47:33.084]                     {
[17:47:33.084]                       {
[17:47:33.084]                         base::local({
[17:47:33.084]                           has_future <- base::requireNamespace("future", 
[17:47:33.084]                             quietly = TRUE)
[17:47:33.084]                           if (has_future) {
[17:47:33.084]                             ns <- base::getNamespace("future")
[17:47:33.084]                             version <- ns[[".package"]][["version"]]
[17:47:33.084]                             if (is.null(version)) 
[17:47:33.084]                               version <- utils::packageVersion("future")
[17:47:33.084]                           }
[17:47:33.084]                           else {
[17:47:33.084]                             version <- NULL
[17:47:33.084]                           }
[17:47:33.084]                           if (!has_future || version < "1.8.0") {
[17:47:33.084]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:33.084]                               "", base::R.version$version.string), 
[17:47:33.084]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:33.084]                                 base::R.version$platform, 8 * 
[17:47:33.084]                                   base::.Machine$sizeof.pointer), 
[17:47:33.084]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:33.084]                                 "release", "version")], collapse = " "), 
[17:47:33.084]                               hostname = base::Sys.info()[["nodename"]])
[17:47:33.084]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:33.084]                               info)
[17:47:33.084]                             info <- base::paste(info, collapse = "; ")
[17:47:33.084]                             if (!has_future) {
[17:47:33.084]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:33.084]                                 info)
[17:47:33.084]                             }
[17:47:33.084]                             else {
[17:47:33.084]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:33.084]                                 info, version)
[17:47:33.084]                             }
[17:47:33.084]                             base::stop(msg)
[17:47:33.084]                           }
[17:47:33.084]                         })
[17:47:33.084]                       }
[17:47:33.084]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:33.084]                       base::options(mc.cores = 1L)
[17:47:33.084]                     }
[17:47:33.084]                     base::local({
[17:47:33.084]                       for (pkg in "future") {
[17:47:33.084]                         base::loadNamespace(pkg)
[17:47:33.084]                         base::library(pkg, character.only = TRUE)
[17:47:33.084]                       }
[17:47:33.084]                     })
[17:47:33.084]                   }
[17:47:33.084]                   ...future.strategy.old <- future::plan("list")
[17:47:33.084]                   options(future.plan = NULL)
[17:47:33.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.084]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:33.084]                     envir = parent.frame()) 
[17:47:33.084]                   {
[17:47:33.084]                     default_workers <- missing(workers)
[17:47:33.084]                     if (is.function(workers)) 
[17:47:33.084]                       workers <- workers()
[17:47:33.084]                     workers <- structure(as.integer(workers), 
[17:47:33.084]                       class = class(workers))
[17:47:33.084]                     stop_if_not(is.finite(workers), workers >= 
[17:47:33.084]                       1L)
[17:47:33.084]                     if ((workers == 1L && !inherits(workers, 
[17:47:33.084]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:33.084]                       if (default_workers) 
[17:47:33.084]                         supportsMulticore(warn = TRUE)
[17:47:33.084]                       return(sequential(..., envir = envir))
[17:47:33.084]                     }
[17:47:33.084]                     oopts <- options(mc.cores = workers)
[17:47:33.084]                     on.exit(options(oopts))
[17:47:33.084]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:33.084]                       envir = envir)
[17:47:33.084]                     if (!future$lazy) 
[17:47:33.084]                       future <- run(future)
[17:47:33.084]                     invisible(future)
[17:47:33.084]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:33.084]                 }
[17:47:33.084]                 ...future.workdir <- getwd()
[17:47:33.084]             }
[17:47:33.084]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:33.084]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:33.084]         }
[17:47:33.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:33.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:33.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:33.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:33.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:33.084]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:33.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:33.084]             base::names(...future.oldOptions))
[17:47:33.084]     }
[17:47:33.084]     if (FALSE) {
[17:47:33.084]     }
[17:47:33.084]     else {
[17:47:33.084]         if (TRUE) {
[17:47:33.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:33.084]                 open = "w")
[17:47:33.084]         }
[17:47:33.084]         else {
[17:47:33.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:33.084]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:33.084]         }
[17:47:33.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:33.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:33.084]             base::sink(type = "output", split = FALSE)
[17:47:33.084]             base::close(...future.stdout)
[17:47:33.084]         }, add = TRUE)
[17:47:33.084]     }
[17:47:33.084]     ...future.frame <- base::sys.nframe()
[17:47:33.084]     ...future.conditions <- base::list()
[17:47:33.084]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:33.084]     if (FALSE) {
[17:47:33.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:33.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:33.084]     }
[17:47:33.084]     ...future.result <- base::tryCatch({
[17:47:33.084]         base::withCallingHandlers({
[17:47:33.084]             ...future.value <- base::withVisible(base::local({
[17:47:33.084]                 ...future.makeSendCondition <- base::local({
[17:47:33.084]                   sendCondition <- NULL
[17:47:33.084]                   function(frame = 1L) {
[17:47:33.084]                     if (is.function(sendCondition)) 
[17:47:33.084]                       return(sendCondition)
[17:47:33.084]                     ns <- getNamespace("parallel")
[17:47:33.084]                     if (exists("sendData", mode = "function", 
[17:47:33.084]                       envir = ns)) {
[17:47:33.084]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:33.084]                         envir = ns)
[17:47:33.084]                       envir <- sys.frame(frame)
[17:47:33.084]                       master <- NULL
[17:47:33.084]                       while (!identical(envir, .GlobalEnv) && 
[17:47:33.084]                         !identical(envir, emptyenv())) {
[17:47:33.084]                         if (exists("master", mode = "list", envir = envir, 
[17:47:33.084]                           inherits = FALSE)) {
[17:47:33.084]                           master <- get("master", mode = "list", 
[17:47:33.084]                             envir = envir, inherits = FALSE)
[17:47:33.084]                           if (inherits(master, c("SOCKnode", 
[17:47:33.084]                             "SOCK0node"))) {
[17:47:33.084]                             sendCondition <<- function(cond) {
[17:47:33.084]                               data <- list(type = "VALUE", value = cond, 
[17:47:33.084]                                 success = TRUE)
[17:47:33.084]                               parallel_sendData(master, data)
[17:47:33.084]                             }
[17:47:33.084]                             return(sendCondition)
[17:47:33.084]                           }
[17:47:33.084]                         }
[17:47:33.084]                         frame <- frame + 1L
[17:47:33.084]                         envir <- sys.frame(frame)
[17:47:33.084]                       }
[17:47:33.084]                     }
[17:47:33.084]                     sendCondition <<- function(cond) NULL
[17:47:33.084]                   }
[17:47:33.084]                 })
[17:47:33.084]                 withCallingHandlers({
[17:47:33.084]                   NA
[17:47:33.084]                 }, immediateCondition = function(cond) {
[17:47:33.084]                   sendCondition <- ...future.makeSendCondition()
[17:47:33.084]                   sendCondition(cond)
[17:47:33.084]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.084]                   {
[17:47:33.084]                     inherits <- base::inherits
[17:47:33.084]                     invokeRestart <- base::invokeRestart
[17:47:33.084]                     is.null <- base::is.null
[17:47:33.084]                     muffled <- FALSE
[17:47:33.084]                     if (inherits(cond, "message")) {
[17:47:33.084]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:33.084]                       if (muffled) 
[17:47:33.084]                         invokeRestart("muffleMessage")
[17:47:33.084]                     }
[17:47:33.084]                     else if (inherits(cond, "warning")) {
[17:47:33.084]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:33.084]                       if (muffled) 
[17:47:33.084]                         invokeRestart("muffleWarning")
[17:47:33.084]                     }
[17:47:33.084]                     else if (inherits(cond, "condition")) {
[17:47:33.084]                       if (!is.null(pattern)) {
[17:47:33.084]                         computeRestarts <- base::computeRestarts
[17:47:33.084]                         grepl <- base::grepl
[17:47:33.084]                         restarts <- computeRestarts(cond)
[17:47:33.084]                         for (restart in restarts) {
[17:47:33.084]                           name <- restart$name
[17:47:33.084]                           if (is.null(name)) 
[17:47:33.084]                             next
[17:47:33.084]                           if (!grepl(pattern, name)) 
[17:47:33.084]                             next
[17:47:33.084]                           invokeRestart(restart)
[17:47:33.084]                           muffled <- TRUE
[17:47:33.084]                           break
[17:47:33.084]                         }
[17:47:33.084]                       }
[17:47:33.084]                     }
[17:47:33.084]                     invisible(muffled)
[17:47:33.084]                   }
[17:47:33.084]                   muffleCondition(cond)
[17:47:33.084]                 })
[17:47:33.084]             }))
[17:47:33.084]             future::FutureResult(value = ...future.value$value, 
[17:47:33.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.084]                   ...future.rng), globalenv = if (FALSE) 
[17:47:33.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:33.084]                     ...future.globalenv.names))
[17:47:33.084]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:33.084]         }, condition = base::local({
[17:47:33.084]             c <- base::c
[17:47:33.084]             inherits <- base::inherits
[17:47:33.084]             invokeRestart <- base::invokeRestart
[17:47:33.084]             length <- base::length
[17:47:33.084]             list <- base::list
[17:47:33.084]             seq.int <- base::seq.int
[17:47:33.084]             signalCondition <- base::signalCondition
[17:47:33.084]             sys.calls <- base::sys.calls
[17:47:33.084]             `[[` <- base::`[[`
[17:47:33.084]             `+` <- base::`+`
[17:47:33.084]             `<<-` <- base::`<<-`
[17:47:33.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:33.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:33.084]                   3L)]
[17:47:33.084]             }
[17:47:33.084]             function(cond) {
[17:47:33.084]                 is_error <- inherits(cond, "error")
[17:47:33.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:33.084]                   NULL)
[17:47:33.084]                 if (is_error) {
[17:47:33.084]                   sessionInformation <- function() {
[17:47:33.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:33.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:33.084]                       search = base::search(), system = base::Sys.info())
[17:47:33.084]                   }
[17:47:33.084]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:33.084]                     cond$call), session = sessionInformation(), 
[17:47:33.084]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:33.084]                   signalCondition(cond)
[17:47:33.084]                 }
[17:47:33.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:33.084]                 "immediateCondition"))) {
[17:47:33.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:33.084]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:33.084]                   if (TRUE && !signal) {
[17:47:33.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.084]                     {
[17:47:33.084]                       inherits <- base::inherits
[17:47:33.084]                       invokeRestart <- base::invokeRestart
[17:47:33.084]                       is.null <- base::is.null
[17:47:33.084]                       muffled <- FALSE
[17:47:33.084]                       if (inherits(cond, "message")) {
[17:47:33.084]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.084]                         if (muffled) 
[17:47:33.084]                           invokeRestart("muffleMessage")
[17:47:33.084]                       }
[17:47:33.084]                       else if (inherits(cond, "warning")) {
[17:47:33.084]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.084]                         if (muffled) 
[17:47:33.084]                           invokeRestart("muffleWarning")
[17:47:33.084]                       }
[17:47:33.084]                       else if (inherits(cond, "condition")) {
[17:47:33.084]                         if (!is.null(pattern)) {
[17:47:33.084]                           computeRestarts <- base::computeRestarts
[17:47:33.084]                           grepl <- base::grepl
[17:47:33.084]                           restarts <- computeRestarts(cond)
[17:47:33.084]                           for (restart in restarts) {
[17:47:33.084]                             name <- restart$name
[17:47:33.084]                             if (is.null(name)) 
[17:47:33.084]                               next
[17:47:33.084]                             if (!grepl(pattern, name)) 
[17:47:33.084]                               next
[17:47:33.084]                             invokeRestart(restart)
[17:47:33.084]                             muffled <- TRUE
[17:47:33.084]                             break
[17:47:33.084]                           }
[17:47:33.084]                         }
[17:47:33.084]                       }
[17:47:33.084]                       invisible(muffled)
[17:47:33.084]                     }
[17:47:33.084]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.084]                   }
[17:47:33.084]                 }
[17:47:33.084]                 else {
[17:47:33.084]                   if (TRUE) {
[17:47:33.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.084]                     {
[17:47:33.084]                       inherits <- base::inherits
[17:47:33.084]                       invokeRestart <- base::invokeRestart
[17:47:33.084]                       is.null <- base::is.null
[17:47:33.084]                       muffled <- FALSE
[17:47:33.084]                       if (inherits(cond, "message")) {
[17:47:33.084]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.084]                         if (muffled) 
[17:47:33.084]                           invokeRestart("muffleMessage")
[17:47:33.084]                       }
[17:47:33.084]                       else if (inherits(cond, "warning")) {
[17:47:33.084]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.084]                         if (muffled) 
[17:47:33.084]                           invokeRestart("muffleWarning")
[17:47:33.084]                       }
[17:47:33.084]                       else if (inherits(cond, "condition")) {
[17:47:33.084]                         if (!is.null(pattern)) {
[17:47:33.084]                           computeRestarts <- base::computeRestarts
[17:47:33.084]                           grepl <- base::grepl
[17:47:33.084]                           restarts <- computeRestarts(cond)
[17:47:33.084]                           for (restart in restarts) {
[17:47:33.084]                             name <- restart$name
[17:47:33.084]                             if (is.null(name)) 
[17:47:33.084]                               next
[17:47:33.084]                             if (!grepl(pattern, name)) 
[17:47:33.084]                               next
[17:47:33.084]                             invokeRestart(restart)
[17:47:33.084]                             muffled <- TRUE
[17:47:33.084]                             break
[17:47:33.084]                           }
[17:47:33.084]                         }
[17:47:33.084]                       }
[17:47:33.084]                       invisible(muffled)
[17:47:33.084]                     }
[17:47:33.084]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.084]                   }
[17:47:33.084]                 }
[17:47:33.084]             }
[17:47:33.084]         }))
[17:47:33.084]     }, error = function(ex) {
[17:47:33.084]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:33.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.084]                 ...future.rng), started = ...future.startTime, 
[17:47:33.084]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:33.084]             version = "1.8"), class = "FutureResult")
[17:47:33.084]     }, finally = {
[17:47:33.084]         if (!identical(...future.workdir, getwd())) 
[17:47:33.084]             setwd(...future.workdir)
[17:47:33.084]         {
[17:47:33.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:33.084]                 ...future.oldOptions$nwarnings <- NULL
[17:47:33.084]             }
[17:47:33.084]             base::options(...future.oldOptions)
[17:47:33.084]             if (.Platform$OS.type == "windows") {
[17:47:33.084]                 old_names <- names(...future.oldEnvVars)
[17:47:33.084]                 envs <- base::Sys.getenv()
[17:47:33.084]                 names <- names(envs)
[17:47:33.084]                 common <- intersect(names, old_names)
[17:47:33.084]                 added <- setdiff(names, old_names)
[17:47:33.084]                 removed <- setdiff(old_names, names)
[17:47:33.084]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:33.084]                   envs[common]]
[17:47:33.084]                 NAMES <- toupper(changed)
[17:47:33.084]                 args <- list()
[17:47:33.084]                 for (kk in seq_along(NAMES)) {
[17:47:33.084]                   name <- changed[[kk]]
[17:47:33.084]                   NAME <- NAMES[[kk]]
[17:47:33.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.084]                     next
[17:47:33.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.084]                 }
[17:47:33.084]                 NAMES <- toupper(added)
[17:47:33.084]                 for (kk in seq_along(NAMES)) {
[17:47:33.084]                   name <- added[[kk]]
[17:47:33.084]                   NAME <- NAMES[[kk]]
[17:47:33.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.084]                     next
[17:47:33.084]                   args[[name]] <- ""
[17:47:33.084]                 }
[17:47:33.084]                 NAMES <- toupper(removed)
[17:47:33.084]                 for (kk in seq_along(NAMES)) {
[17:47:33.084]                   name <- removed[[kk]]
[17:47:33.084]                   NAME <- NAMES[[kk]]
[17:47:33.084]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.084]                     next
[17:47:33.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.084]                 }
[17:47:33.084]                 if (length(args) > 0) 
[17:47:33.084]                   base::do.call(base::Sys.setenv, args = args)
[17:47:33.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:33.084]             }
[17:47:33.084]             else {
[17:47:33.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:33.084]             }
[17:47:33.084]             {
[17:47:33.084]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:33.084]                   0L) {
[17:47:33.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:33.084]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:33.084]                   base::options(opts)
[17:47:33.084]                 }
[17:47:33.084]                 {
[17:47:33.084]                   {
[17:47:33.084]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:33.084]                     NULL
[17:47:33.084]                   }
[17:47:33.084]                   options(future.plan = NULL)
[17:47:33.084]                   if (is.na(NA_character_)) 
[17:47:33.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:33.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:33.084]                     .init = FALSE)
[17:47:33.084]                 }
[17:47:33.084]             }
[17:47:33.084]         }
[17:47:33.084]     })
[17:47:33.084]     if (TRUE) {
[17:47:33.084]         base::sink(type = "output", split = FALSE)
[17:47:33.084]         if (TRUE) {
[17:47:33.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:33.084]         }
[17:47:33.084]         else {
[17:47:33.084]             ...future.result["stdout"] <- base::list(NULL)
[17:47:33.084]         }
[17:47:33.084]         base::close(...future.stdout)
[17:47:33.084]         ...future.stdout <- NULL
[17:47:33.084]     }
[17:47:33.084]     ...future.result$conditions <- ...future.conditions
[17:47:33.084]     ...future.result$finished <- base::Sys.time()
[17:47:33.084]     ...future.result
[17:47:33.084] }
[17:47:33.137] MultisessionFuture started
[17:47:33.137] result() for ClusterFuture ...
[17:47:33.137] receiveMessageFromWorker() for ClusterFuture ...
[17:47:33.137] - Validating connection of MultisessionFuture
[17:47:33.183] - received message: FutureResult
[17:47:33.184] - Received FutureResult
[17:47:33.184] - Erased future from FutureRegistry
[17:47:33.184] result() for ClusterFuture ...
[17:47:33.184] - result already collected: FutureResult
[17:47:33.184] result() for ClusterFuture ... done
[17:47:33.184] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:33.184] result() for ClusterFuture ... done
[17:47:33.185] result() for ClusterFuture ...
[17:47:33.185] - result already collected: FutureResult
[17:47:33.185] result() for ClusterFuture ... done
[17:47:33.185] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:47:33.188] plan(): nbrOfWorkers() = 2
[17:47:33.189] getGlobalsAndPackages() ...
[17:47:33.189] Searching for globals...
[17:47:33.206] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:33.206] Searching for globals ... DONE
[17:47:33.206] Resolving globals: FALSE
[17:47:33.207] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[17:47:33.208] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:33.208] - globals: [2] ‘nested’, ‘strategy2’
[17:47:33.208] - packages: [1] ‘future’
[17:47:33.208] getGlobalsAndPackages() ... DONE
[17:47:33.208] run() for ‘Future’ ...
[17:47:33.208] - state: ‘created’
[17:47:33.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:33.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:33.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:33.224]   - Field: ‘node’
[17:47:33.225]   - Field: ‘label’
[17:47:33.225]   - Field: ‘local’
[17:47:33.225]   - Field: ‘owner’
[17:47:33.225]   - Field: ‘envir’
[17:47:33.225]   - Field: ‘workers’
[17:47:33.225]   - Field: ‘packages’
[17:47:33.225]   - Field: ‘gc’
[17:47:33.225]   - Field: ‘conditions’
[17:47:33.225]   - Field: ‘persistent’
[17:47:33.225]   - Field: ‘expr’
[17:47:33.225]   - Field: ‘uuid’
[17:47:33.226]   - Field: ‘seed’
[17:47:33.226]   - Field: ‘version’
[17:47:33.226]   - Field: ‘result’
[17:47:33.226]   - Field: ‘asynchronous’
[17:47:33.226]   - Field: ‘calls’
[17:47:33.226]   - Field: ‘globals’
[17:47:33.226]   - Field: ‘stdout’
[17:47:33.226]   - Field: ‘earlySignal’
[17:47:33.226]   - Field: ‘lazy’
[17:47:33.226]   - Field: ‘state’
[17:47:33.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:33.227] - Launch lazy future ...
[17:47:33.227] Packages needed by the future expression (n = 1): ‘future’
[17:47:33.227] Packages needed by future strategies (n = 1): ‘future’
[17:47:33.228] {
[17:47:33.228]     {
[17:47:33.228]         {
[17:47:33.228]             ...future.startTime <- base::Sys.time()
[17:47:33.228]             {
[17:47:33.228]                 {
[17:47:33.228]                   {
[17:47:33.228]                     {
[17:47:33.228]                       {
[17:47:33.228]                         base::local({
[17:47:33.228]                           has_future <- base::requireNamespace("future", 
[17:47:33.228]                             quietly = TRUE)
[17:47:33.228]                           if (has_future) {
[17:47:33.228]                             ns <- base::getNamespace("future")
[17:47:33.228]                             version <- ns[[".package"]][["version"]]
[17:47:33.228]                             if (is.null(version)) 
[17:47:33.228]                               version <- utils::packageVersion("future")
[17:47:33.228]                           }
[17:47:33.228]                           else {
[17:47:33.228]                             version <- NULL
[17:47:33.228]                           }
[17:47:33.228]                           if (!has_future || version < "1.8.0") {
[17:47:33.228]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:33.228]                               "", base::R.version$version.string), 
[17:47:33.228]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:33.228]                                 base::R.version$platform, 8 * 
[17:47:33.228]                                   base::.Machine$sizeof.pointer), 
[17:47:33.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:33.228]                                 "release", "version")], collapse = " "), 
[17:47:33.228]                               hostname = base::Sys.info()[["nodename"]])
[17:47:33.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:33.228]                               info)
[17:47:33.228]                             info <- base::paste(info, collapse = "; ")
[17:47:33.228]                             if (!has_future) {
[17:47:33.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:33.228]                                 info)
[17:47:33.228]                             }
[17:47:33.228]                             else {
[17:47:33.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:33.228]                                 info, version)
[17:47:33.228]                             }
[17:47:33.228]                             base::stop(msg)
[17:47:33.228]                           }
[17:47:33.228]                         })
[17:47:33.228]                       }
[17:47:33.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:33.228]                       base::options(mc.cores = 1L)
[17:47:33.228]                     }
[17:47:33.228]                     base::local({
[17:47:33.228]                       for (pkg in "future") {
[17:47:33.228]                         base::loadNamespace(pkg)
[17:47:33.228]                         base::library(pkg, character.only = TRUE)
[17:47:33.228]                       }
[17:47:33.228]                     })
[17:47:33.228]                   }
[17:47:33.228]                   ...future.strategy.old <- future::plan("list")
[17:47:33.228]                   options(future.plan = NULL)
[17:47:33.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.228]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:33.228]                     envir = parent.frame()) 
[17:47:33.228]                   {
[17:47:33.228]                     default_workers <- missing(workers)
[17:47:33.228]                     if (is.function(workers)) 
[17:47:33.228]                       workers <- workers()
[17:47:33.228]                     workers <- structure(as.integer(workers), 
[17:47:33.228]                       class = class(workers))
[17:47:33.228]                     stop_if_not(is.finite(workers), workers >= 
[17:47:33.228]                       1L)
[17:47:33.228]                     if ((workers == 1L && !inherits(workers, 
[17:47:33.228]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:33.228]                       if (default_workers) 
[17:47:33.228]                         supportsMulticore(warn = TRUE)
[17:47:33.228]                       return(sequential(..., envir = envir))
[17:47:33.228]                     }
[17:47:33.228]                     oopts <- options(mc.cores = workers)
[17:47:33.228]                     on.exit(options(oopts))
[17:47:33.228]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:33.228]                       envir = envir)
[17:47:33.228]                     if (!future$lazy) 
[17:47:33.228]                       future <- run(future)
[17:47:33.228]                     invisible(future)
[17:47:33.228]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:33.228]                 }
[17:47:33.228]                 ...future.workdir <- getwd()
[17:47:33.228]             }
[17:47:33.228]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:33.228]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:33.228]         }
[17:47:33.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:33.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:33.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:33.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:33.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:33.228]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:33.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:33.228]             base::names(...future.oldOptions))
[17:47:33.228]     }
[17:47:33.228]     if (FALSE) {
[17:47:33.228]     }
[17:47:33.228]     else {
[17:47:33.228]         if (TRUE) {
[17:47:33.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:33.228]                 open = "w")
[17:47:33.228]         }
[17:47:33.228]         else {
[17:47:33.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:33.228]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:33.228]         }
[17:47:33.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:33.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:33.228]             base::sink(type = "output", split = FALSE)
[17:47:33.228]             base::close(...future.stdout)
[17:47:33.228]         }, add = TRUE)
[17:47:33.228]     }
[17:47:33.228]     ...future.frame <- base::sys.nframe()
[17:47:33.228]     ...future.conditions <- base::list()
[17:47:33.228]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:33.228]     if (FALSE) {
[17:47:33.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:33.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:33.228]     }
[17:47:33.228]     ...future.result <- base::tryCatch({
[17:47:33.228]         base::withCallingHandlers({
[17:47:33.228]             ...future.value <- base::withVisible(base::local({
[17:47:33.228]                 ...future.makeSendCondition <- base::local({
[17:47:33.228]                   sendCondition <- NULL
[17:47:33.228]                   function(frame = 1L) {
[17:47:33.228]                     if (is.function(sendCondition)) 
[17:47:33.228]                       return(sendCondition)
[17:47:33.228]                     ns <- getNamespace("parallel")
[17:47:33.228]                     if (exists("sendData", mode = "function", 
[17:47:33.228]                       envir = ns)) {
[17:47:33.228]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:33.228]                         envir = ns)
[17:47:33.228]                       envir <- sys.frame(frame)
[17:47:33.228]                       master <- NULL
[17:47:33.228]                       while (!identical(envir, .GlobalEnv) && 
[17:47:33.228]                         !identical(envir, emptyenv())) {
[17:47:33.228]                         if (exists("master", mode = "list", envir = envir, 
[17:47:33.228]                           inherits = FALSE)) {
[17:47:33.228]                           master <- get("master", mode = "list", 
[17:47:33.228]                             envir = envir, inherits = FALSE)
[17:47:33.228]                           if (inherits(master, c("SOCKnode", 
[17:47:33.228]                             "SOCK0node"))) {
[17:47:33.228]                             sendCondition <<- function(cond) {
[17:47:33.228]                               data <- list(type = "VALUE", value = cond, 
[17:47:33.228]                                 success = TRUE)
[17:47:33.228]                               parallel_sendData(master, data)
[17:47:33.228]                             }
[17:47:33.228]                             return(sendCondition)
[17:47:33.228]                           }
[17:47:33.228]                         }
[17:47:33.228]                         frame <- frame + 1L
[17:47:33.228]                         envir <- sys.frame(frame)
[17:47:33.228]                       }
[17:47:33.228]                     }
[17:47:33.228]                     sendCondition <<- function(cond) NULL
[17:47:33.228]                   }
[17:47:33.228]                 })
[17:47:33.228]                 withCallingHandlers({
[17:47:33.228]                   {
[17:47:33.228]                     a <- 1L
[17:47:33.228]                     plan_a <- unclass(future::plan("list"))
[17:47:33.228]                     nested_a <- nested[-1]
[17:47:33.228]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:33.228]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:33.228]                       strategy2))
[17:47:33.228]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:33.228]                       "init") <- NULL
[17:47:33.228]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:33.228]                       "init") <- NULL
[17:47:33.228]                     stopifnot(all.equal(plan_a, nested_a))
[17:47:33.228]                     y %<-% {
[17:47:33.228]                       b <- 2L
[17:47:33.228]                       plan_b <- future::plan("list")
[17:47:33.228]                       nested_b <- nested_a[-1]
[17:47:33.228]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:33.228]                         1L, inherits(plan_b[[1]], "future"), 
[17:47:33.228]                         inherits(future::plan("next"), "sequential"))
[17:47:33.228]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:33.228]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:33.228]                     }
[17:47:33.228]                     y
[17:47:33.228]                   }
[17:47:33.228]                 }, immediateCondition = function(cond) {
[17:47:33.228]                   sendCondition <- ...future.makeSendCondition()
[17:47:33.228]                   sendCondition(cond)
[17:47:33.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.228]                   {
[17:47:33.228]                     inherits <- base::inherits
[17:47:33.228]                     invokeRestart <- base::invokeRestart
[17:47:33.228]                     is.null <- base::is.null
[17:47:33.228]                     muffled <- FALSE
[17:47:33.228]                     if (inherits(cond, "message")) {
[17:47:33.228]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:33.228]                       if (muffled) 
[17:47:33.228]                         invokeRestart("muffleMessage")
[17:47:33.228]                     }
[17:47:33.228]                     else if (inherits(cond, "warning")) {
[17:47:33.228]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:33.228]                       if (muffled) 
[17:47:33.228]                         invokeRestart("muffleWarning")
[17:47:33.228]                     }
[17:47:33.228]                     else if (inherits(cond, "condition")) {
[17:47:33.228]                       if (!is.null(pattern)) {
[17:47:33.228]                         computeRestarts <- base::computeRestarts
[17:47:33.228]                         grepl <- base::grepl
[17:47:33.228]                         restarts <- computeRestarts(cond)
[17:47:33.228]                         for (restart in restarts) {
[17:47:33.228]                           name <- restart$name
[17:47:33.228]                           if (is.null(name)) 
[17:47:33.228]                             next
[17:47:33.228]                           if (!grepl(pattern, name)) 
[17:47:33.228]                             next
[17:47:33.228]                           invokeRestart(restart)
[17:47:33.228]                           muffled <- TRUE
[17:47:33.228]                           break
[17:47:33.228]                         }
[17:47:33.228]                       }
[17:47:33.228]                     }
[17:47:33.228]                     invisible(muffled)
[17:47:33.228]                   }
[17:47:33.228]                   muffleCondition(cond)
[17:47:33.228]                 })
[17:47:33.228]             }))
[17:47:33.228]             future::FutureResult(value = ...future.value$value, 
[17:47:33.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.228]                   ...future.rng), globalenv = if (FALSE) 
[17:47:33.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:33.228]                     ...future.globalenv.names))
[17:47:33.228]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:33.228]         }, condition = base::local({
[17:47:33.228]             c <- base::c
[17:47:33.228]             inherits <- base::inherits
[17:47:33.228]             invokeRestart <- base::invokeRestart
[17:47:33.228]             length <- base::length
[17:47:33.228]             list <- base::list
[17:47:33.228]             seq.int <- base::seq.int
[17:47:33.228]             signalCondition <- base::signalCondition
[17:47:33.228]             sys.calls <- base::sys.calls
[17:47:33.228]             `[[` <- base::`[[`
[17:47:33.228]             `+` <- base::`+`
[17:47:33.228]             `<<-` <- base::`<<-`
[17:47:33.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:33.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:33.228]                   3L)]
[17:47:33.228]             }
[17:47:33.228]             function(cond) {
[17:47:33.228]                 is_error <- inherits(cond, "error")
[17:47:33.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:33.228]                   NULL)
[17:47:33.228]                 if (is_error) {
[17:47:33.228]                   sessionInformation <- function() {
[17:47:33.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:33.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:33.228]                       search = base::search(), system = base::Sys.info())
[17:47:33.228]                   }
[17:47:33.228]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:33.228]                     cond$call), session = sessionInformation(), 
[17:47:33.228]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:33.228]                   signalCondition(cond)
[17:47:33.228]                 }
[17:47:33.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:33.228]                 "immediateCondition"))) {
[17:47:33.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:33.228]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:33.228]                   if (TRUE && !signal) {
[17:47:33.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.228]                     {
[17:47:33.228]                       inherits <- base::inherits
[17:47:33.228]                       invokeRestart <- base::invokeRestart
[17:47:33.228]                       is.null <- base::is.null
[17:47:33.228]                       muffled <- FALSE
[17:47:33.228]                       if (inherits(cond, "message")) {
[17:47:33.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.228]                         if (muffled) 
[17:47:33.228]                           invokeRestart("muffleMessage")
[17:47:33.228]                       }
[17:47:33.228]                       else if (inherits(cond, "warning")) {
[17:47:33.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.228]                         if (muffled) 
[17:47:33.228]                           invokeRestart("muffleWarning")
[17:47:33.228]                       }
[17:47:33.228]                       else if (inherits(cond, "condition")) {
[17:47:33.228]                         if (!is.null(pattern)) {
[17:47:33.228]                           computeRestarts <- base::computeRestarts
[17:47:33.228]                           grepl <- base::grepl
[17:47:33.228]                           restarts <- computeRestarts(cond)
[17:47:33.228]                           for (restart in restarts) {
[17:47:33.228]                             name <- restart$name
[17:47:33.228]                             if (is.null(name)) 
[17:47:33.228]                               next
[17:47:33.228]                             if (!grepl(pattern, name)) 
[17:47:33.228]                               next
[17:47:33.228]                             invokeRestart(restart)
[17:47:33.228]                             muffled <- TRUE
[17:47:33.228]                             break
[17:47:33.228]                           }
[17:47:33.228]                         }
[17:47:33.228]                       }
[17:47:33.228]                       invisible(muffled)
[17:47:33.228]                     }
[17:47:33.228]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.228]                   }
[17:47:33.228]                 }
[17:47:33.228]                 else {
[17:47:33.228]                   if (TRUE) {
[17:47:33.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.228]                     {
[17:47:33.228]                       inherits <- base::inherits
[17:47:33.228]                       invokeRestart <- base::invokeRestart
[17:47:33.228]                       is.null <- base::is.null
[17:47:33.228]                       muffled <- FALSE
[17:47:33.228]                       if (inherits(cond, "message")) {
[17:47:33.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.228]                         if (muffled) 
[17:47:33.228]                           invokeRestart("muffleMessage")
[17:47:33.228]                       }
[17:47:33.228]                       else if (inherits(cond, "warning")) {
[17:47:33.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.228]                         if (muffled) 
[17:47:33.228]                           invokeRestart("muffleWarning")
[17:47:33.228]                       }
[17:47:33.228]                       else if (inherits(cond, "condition")) {
[17:47:33.228]                         if (!is.null(pattern)) {
[17:47:33.228]                           computeRestarts <- base::computeRestarts
[17:47:33.228]                           grepl <- base::grepl
[17:47:33.228]                           restarts <- computeRestarts(cond)
[17:47:33.228]                           for (restart in restarts) {
[17:47:33.228]                             name <- restart$name
[17:47:33.228]                             if (is.null(name)) 
[17:47:33.228]                               next
[17:47:33.228]                             if (!grepl(pattern, name)) 
[17:47:33.228]                               next
[17:47:33.228]                             invokeRestart(restart)
[17:47:33.228]                             muffled <- TRUE
[17:47:33.228]                             break
[17:47:33.228]                           }
[17:47:33.228]                         }
[17:47:33.228]                       }
[17:47:33.228]                       invisible(muffled)
[17:47:33.228]                     }
[17:47:33.228]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.228]                   }
[17:47:33.228]                 }
[17:47:33.228]             }
[17:47:33.228]         }))
[17:47:33.228]     }, error = function(ex) {
[17:47:33.228]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:33.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.228]                 ...future.rng), started = ...future.startTime, 
[17:47:33.228]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:33.228]             version = "1.8"), class = "FutureResult")
[17:47:33.228]     }, finally = {
[17:47:33.228]         if (!identical(...future.workdir, getwd())) 
[17:47:33.228]             setwd(...future.workdir)
[17:47:33.228]         {
[17:47:33.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:33.228]                 ...future.oldOptions$nwarnings <- NULL
[17:47:33.228]             }
[17:47:33.228]             base::options(...future.oldOptions)
[17:47:33.228]             if (.Platform$OS.type == "windows") {
[17:47:33.228]                 old_names <- names(...future.oldEnvVars)
[17:47:33.228]                 envs <- base::Sys.getenv()
[17:47:33.228]                 names <- names(envs)
[17:47:33.228]                 common <- intersect(names, old_names)
[17:47:33.228]                 added <- setdiff(names, old_names)
[17:47:33.228]                 removed <- setdiff(old_names, names)
[17:47:33.228]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:33.228]                   envs[common]]
[17:47:33.228]                 NAMES <- toupper(changed)
[17:47:33.228]                 args <- list()
[17:47:33.228]                 for (kk in seq_along(NAMES)) {
[17:47:33.228]                   name <- changed[[kk]]
[17:47:33.228]                   NAME <- NAMES[[kk]]
[17:47:33.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.228]                     next
[17:47:33.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.228]                 }
[17:47:33.228]                 NAMES <- toupper(added)
[17:47:33.228]                 for (kk in seq_along(NAMES)) {
[17:47:33.228]                   name <- added[[kk]]
[17:47:33.228]                   NAME <- NAMES[[kk]]
[17:47:33.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.228]                     next
[17:47:33.228]                   args[[name]] <- ""
[17:47:33.228]                 }
[17:47:33.228]                 NAMES <- toupper(removed)
[17:47:33.228]                 for (kk in seq_along(NAMES)) {
[17:47:33.228]                   name <- removed[[kk]]
[17:47:33.228]                   NAME <- NAMES[[kk]]
[17:47:33.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.228]                     next
[17:47:33.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.228]                 }
[17:47:33.228]                 if (length(args) > 0) 
[17:47:33.228]                   base::do.call(base::Sys.setenv, args = args)
[17:47:33.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:33.228]             }
[17:47:33.228]             else {
[17:47:33.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:33.228]             }
[17:47:33.228]             {
[17:47:33.228]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:33.228]                   0L) {
[17:47:33.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:33.228]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:33.228]                   base::options(opts)
[17:47:33.228]                 }
[17:47:33.228]                 {
[17:47:33.228]                   {
[17:47:33.228]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:33.228]                     NULL
[17:47:33.228]                   }
[17:47:33.228]                   options(future.plan = NULL)
[17:47:33.228]                   if (is.na(NA_character_)) 
[17:47:33.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:33.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:33.228]                     .init = FALSE)
[17:47:33.228]                 }
[17:47:33.228]             }
[17:47:33.228]         }
[17:47:33.228]     })
[17:47:33.228]     if (TRUE) {
[17:47:33.228]         base::sink(type = "output", split = FALSE)
[17:47:33.228]         if (TRUE) {
[17:47:33.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:33.228]         }
[17:47:33.228]         else {
[17:47:33.228]             ...future.result["stdout"] <- base::list(NULL)
[17:47:33.228]         }
[17:47:33.228]         base::close(...future.stdout)
[17:47:33.228]         ...future.stdout <- NULL
[17:47:33.228]     }
[17:47:33.228]     ...future.result$conditions <- ...future.conditions
[17:47:33.228]     ...future.result$finished <- base::Sys.time()
[17:47:33.228]     ...future.result
[17:47:33.228] }
[17:47:33.230] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[17:47:33.231] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[17:47:33.272] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[17:47:33.272] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:47:33.272] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:47:33.272] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[17:47:33.273] MultisessionFuture started
[17:47:33.273] - Launch lazy future ... done
[17:47:33.273] run() for ‘MultisessionFuture’ ... done
[17:47:33.273] result() for ClusterFuture ...
[17:47:33.273] receiveMessageFromWorker() for ClusterFuture ...
[17:47:33.273] - Validating connection of MultisessionFuture
[17:47:33.345] - received message: FutureResult
[17:47:33.346] - Received FutureResult
[17:47:33.346] - Erased future from FutureRegistry
[17:47:33.346] result() for ClusterFuture ...
[17:47:33.346] - result already collected: FutureResult
[17:47:33.346] result() for ClusterFuture ... done
[17:47:33.346] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:33.346] result() for ClusterFuture ... done
[17:47:33.346] result() for ClusterFuture ...
[17:47:33.346] - result already collected: FutureResult
[17:47:33.347] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:33.352] getGlobalsAndPackages() ...
[17:47:33.352] Searching for globals...
[17:47:33.353] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:33.353] Searching for globals ... DONE
[17:47:33.353] Resolving globals: FALSE
[17:47:33.354] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:33.354] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:33.354] - globals: [1] ‘data’
[17:47:33.354] - packages: [1] ‘future’
[17:47:33.354] getGlobalsAndPackages() ... DONE
[17:47:33.355] run() for ‘Future’ ...
[17:47:33.355] - state: ‘created’
[17:47:33.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:33.369] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:33.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:33.369]   - Field: ‘node’
[17:47:33.369]   - Field: ‘label’
[17:47:33.369]   - Field: ‘local’
[17:47:33.369]   - Field: ‘owner’
[17:47:33.369]   - Field: ‘envir’
[17:47:33.369]   - Field: ‘workers’
[17:47:33.370]   - Field: ‘packages’
[17:47:33.370]   - Field: ‘gc’
[17:47:33.370]   - Field: ‘conditions’
[17:47:33.370]   - Field: ‘persistent’
[17:47:33.370]   - Field: ‘expr’
[17:47:33.370]   - Field: ‘uuid’
[17:47:33.370]   - Field: ‘seed’
[17:47:33.370]   - Field: ‘version’
[17:47:33.370]   - Field: ‘result’
[17:47:33.370]   - Field: ‘asynchronous’
[17:47:33.370]   - Field: ‘calls’
[17:47:33.371]   - Field: ‘globals’
[17:47:33.371]   - Field: ‘stdout’
[17:47:33.371]   - Field: ‘earlySignal’
[17:47:33.371]   - Field: ‘lazy’
[17:47:33.371]   - Field: ‘state’
[17:47:33.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:33.371] - Launch lazy future ...
[17:47:33.371] Packages needed by the future expression (n = 1): ‘future’
[17:47:33.371] Packages needed by future strategies (n = 1): ‘future’
[17:47:33.372] {
[17:47:33.372]     {
[17:47:33.372]         {
[17:47:33.372]             ...future.startTime <- base::Sys.time()
[17:47:33.372]             {
[17:47:33.372]                 {
[17:47:33.372]                   {
[17:47:33.372]                     {
[17:47:33.372]                       {
[17:47:33.372]                         base::local({
[17:47:33.372]                           has_future <- base::requireNamespace("future", 
[17:47:33.372]                             quietly = TRUE)
[17:47:33.372]                           if (has_future) {
[17:47:33.372]                             ns <- base::getNamespace("future")
[17:47:33.372]                             version <- ns[[".package"]][["version"]]
[17:47:33.372]                             if (is.null(version)) 
[17:47:33.372]                               version <- utils::packageVersion("future")
[17:47:33.372]                           }
[17:47:33.372]                           else {
[17:47:33.372]                             version <- NULL
[17:47:33.372]                           }
[17:47:33.372]                           if (!has_future || version < "1.8.0") {
[17:47:33.372]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:33.372]                               "", base::R.version$version.string), 
[17:47:33.372]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:33.372]                                 base::R.version$platform, 8 * 
[17:47:33.372]                                   base::.Machine$sizeof.pointer), 
[17:47:33.372]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:33.372]                                 "release", "version")], collapse = " "), 
[17:47:33.372]                               hostname = base::Sys.info()[["nodename"]])
[17:47:33.372]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:33.372]                               info)
[17:47:33.372]                             info <- base::paste(info, collapse = "; ")
[17:47:33.372]                             if (!has_future) {
[17:47:33.372]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:33.372]                                 info)
[17:47:33.372]                             }
[17:47:33.372]                             else {
[17:47:33.372]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:33.372]                                 info, version)
[17:47:33.372]                             }
[17:47:33.372]                             base::stop(msg)
[17:47:33.372]                           }
[17:47:33.372]                         })
[17:47:33.372]                       }
[17:47:33.372]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:33.372]                       base::options(mc.cores = 1L)
[17:47:33.372]                     }
[17:47:33.372]                     base::local({
[17:47:33.372]                       for (pkg in "future") {
[17:47:33.372]                         base::loadNamespace(pkg)
[17:47:33.372]                         base::library(pkg, character.only = TRUE)
[17:47:33.372]                       }
[17:47:33.372]                     })
[17:47:33.372]                   }
[17:47:33.372]                   ...future.strategy.old <- future::plan("list")
[17:47:33.372]                   options(future.plan = NULL)
[17:47:33.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.372]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:47:33.372]                     envir = parent.frame()) 
[17:47:33.372]                   {
[17:47:33.372]                     default_workers <- missing(workers)
[17:47:33.372]                     if (is.function(workers)) 
[17:47:33.372]                       workers <- workers()
[17:47:33.372]                     workers <- structure(as.integer(workers), 
[17:47:33.372]                       class = class(workers))
[17:47:33.372]                     stop_if_not(is.finite(workers), workers >= 
[17:47:33.372]                       1L)
[17:47:33.372]                     if ((workers == 1L && !inherits(workers, 
[17:47:33.372]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:47:33.372]                       if (default_workers) 
[17:47:33.372]                         supportsMulticore(warn = TRUE)
[17:47:33.372]                       return(sequential(..., envir = envir))
[17:47:33.372]                     }
[17:47:33.372]                     oopts <- options(mc.cores = workers)
[17:47:33.372]                     on.exit(options(oopts))
[17:47:33.372]                     future <- MulticoreFuture(..., workers = workers, 
[17:47:33.372]                       envir = envir)
[17:47:33.372]                     if (!future$lazy) 
[17:47:33.372]                       future <- run(future)
[17:47:33.372]                     invisible(future)
[17:47:33.372]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:33.372]                 }
[17:47:33.372]                 ...future.workdir <- getwd()
[17:47:33.372]             }
[17:47:33.372]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:33.372]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:33.372]         }
[17:47:33.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:33.372]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:33.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:33.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:33.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:33.372]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:33.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:33.372]             base::names(...future.oldOptions))
[17:47:33.372]     }
[17:47:33.372]     if (FALSE) {
[17:47:33.372]     }
[17:47:33.372]     else {
[17:47:33.372]         if (TRUE) {
[17:47:33.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:33.372]                 open = "w")
[17:47:33.372]         }
[17:47:33.372]         else {
[17:47:33.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:33.372]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:33.372]         }
[17:47:33.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:33.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:33.372]             base::sink(type = "output", split = FALSE)
[17:47:33.372]             base::close(...future.stdout)
[17:47:33.372]         }, add = TRUE)
[17:47:33.372]     }
[17:47:33.372]     ...future.frame <- base::sys.nframe()
[17:47:33.372]     ...future.conditions <- base::list()
[17:47:33.372]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:33.372]     if (FALSE) {
[17:47:33.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:33.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:33.372]     }
[17:47:33.372]     ...future.result <- base::tryCatch({
[17:47:33.372]         base::withCallingHandlers({
[17:47:33.372]             ...future.value <- base::withVisible(base::local({
[17:47:33.372]                 ...future.makeSendCondition <- base::local({
[17:47:33.372]                   sendCondition <- NULL
[17:47:33.372]                   function(frame = 1L) {
[17:47:33.372]                     if (is.function(sendCondition)) 
[17:47:33.372]                       return(sendCondition)
[17:47:33.372]                     ns <- getNamespace("parallel")
[17:47:33.372]                     if (exists("sendData", mode = "function", 
[17:47:33.372]                       envir = ns)) {
[17:47:33.372]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:33.372]                         envir = ns)
[17:47:33.372]                       envir <- sys.frame(frame)
[17:47:33.372]                       master <- NULL
[17:47:33.372]                       while (!identical(envir, .GlobalEnv) && 
[17:47:33.372]                         !identical(envir, emptyenv())) {
[17:47:33.372]                         if (exists("master", mode = "list", envir = envir, 
[17:47:33.372]                           inherits = FALSE)) {
[17:47:33.372]                           master <- get("master", mode = "list", 
[17:47:33.372]                             envir = envir, inherits = FALSE)
[17:47:33.372]                           if (inherits(master, c("SOCKnode", 
[17:47:33.372]                             "SOCK0node"))) {
[17:47:33.372]                             sendCondition <<- function(cond) {
[17:47:33.372]                               data <- list(type = "VALUE", value = cond, 
[17:47:33.372]                                 success = TRUE)
[17:47:33.372]                               parallel_sendData(master, data)
[17:47:33.372]                             }
[17:47:33.372]                             return(sendCondition)
[17:47:33.372]                           }
[17:47:33.372]                         }
[17:47:33.372]                         frame <- frame + 1L
[17:47:33.372]                         envir <- sys.frame(frame)
[17:47:33.372]                       }
[17:47:33.372]                     }
[17:47:33.372]                     sendCondition <<- function(cond) NULL
[17:47:33.372]                   }
[17:47:33.372]                 })
[17:47:33.372]                 withCallingHandlers({
[17:47:33.372]                   {
[17:47:33.372]                     value(future(subset(data, a == 2)))
[17:47:33.372]                   }
[17:47:33.372]                 }, immediateCondition = function(cond) {
[17:47:33.372]                   sendCondition <- ...future.makeSendCondition()
[17:47:33.372]                   sendCondition(cond)
[17:47:33.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.372]                   {
[17:47:33.372]                     inherits <- base::inherits
[17:47:33.372]                     invokeRestart <- base::invokeRestart
[17:47:33.372]                     is.null <- base::is.null
[17:47:33.372]                     muffled <- FALSE
[17:47:33.372]                     if (inherits(cond, "message")) {
[17:47:33.372]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:33.372]                       if (muffled) 
[17:47:33.372]                         invokeRestart("muffleMessage")
[17:47:33.372]                     }
[17:47:33.372]                     else if (inherits(cond, "warning")) {
[17:47:33.372]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:33.372]                       if (muffled) 
[17:47:33.372]                         invokeRestart("muffleWarning")
[17:47:33.372]                     }
[17:47:33.372]                     else if (inherits(cond, "condition")) {
[17:47:33.372]                       if (!is.null(pattern)) {
[17:47:33.372]                         computeRestarts <- base::computeRestarts
[17:47:33.372]                         grepl <- base::grepl
[17:47:33.372]                         restarts <- computeRestarts(cond)
[17:47:33.372]                         for (restart in restarts) {
[17:47:33.372]                           name <- restart$name
[17:47:33.372]                           if (is.null(name)) 
[17:47:33.372]                             next
[17:47:33.372]                           if (!grepl(pattern, name)) 
[17:47:33.372]                             next
[17:47:33.372]                           invokeRestart(restart)
[17:47:33.372]                           muffled <- TRUE
[17:47:33.372]                           break
[17:47:33.372]                         }
[17:47:33.372]                       }
[17:47:33.372]                     }
[17:47:33.372]                     invisible(muffled)
[17:47:33.372]                   }
[17:47:33.372]                   muffleCondition(cond)
[17:47:33.372]                 })
[17:47:33.372]             }))
[17:47:33.372]             future::FutureResult(value = ...future.value$value, 
[17:47:33.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.372]                   ...future.rng), globalenv = if (FALSE) 
[17:47:33.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:33.372]                     ...future.globalenv.names))
[17:47:33.372]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:33.372]         }, condition = base::local({
[17:47:33.372]             c <- base::c
[17:47:33.372]             inherits <- base::inherits
[17:47:33.372]             invokeRestart <- base::invokeRestart
[17:47:33.372]             length <- base::length
[17:47:33.372]             list <- base::list
[17:47:33.372]             seq.int <- base::seq.int
[17:47:33.372]             signalCondition <- base::signalCondition
[17:47:33.372]             sys.calls <- base::sys.calls
[17:47:33.372]             `[[` <- base::`[[`
[17:47:33.372]             `+` <- base::`+`
[17:47:33.372]             `<<-` <- base::`<<-`
[17:47:33.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:33.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:33.372]                   3L)]
[17:47:33.372]             }
[17:47:33.372]             function(cond) {
[17:47:33.372]                 is_error <- inherits(cond, "error")
[17:47:33.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:33.372]                   NULL)
[17:47:33.372]                 if (is_error) {
[17:47:33.372]                   sessionInformation <- function() {
[17:47:33.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:33.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:33.372]                       search = base::search(), system = base::Sys.info())
[17:47:33.372]                   }
[17:47:33.372]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:33.372]                     cond$call), session = sessionInformation(), 
[17:47:33.372]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:33.372]                   signalCondition(cond)
[17:47:33.372]                 }
[17:47:33.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:33.372]                 "immediateCondition"))) {
[17:47:33.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:33.372]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:33.372]                   if (TRUE && !signal) {
[17:47:33.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.372]                     {
[17:47:33.372]                       inherits <- base::inherits
[17:47:33.372]                       invokeRestart <- base::invokeRestart
[17:47:33.372]                       is.null <- base::is.null
[17:47:33.372]                       muffled <- FALSE
[17:47:33.372]                       if (inherits(cond, "message")) {
[17:47:33.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.372]                         if (muffled) 
[17:47:33.372]                           invokeRestart("muffleMessage")
[17:47:33.372]                       }
[17:47:33.372]                       else if (inherits(cond, "warning")) {
[17:47:33.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.372]                         if (muffled) 
[17:47:33.372]                           invokeRestart("muffleWarning")
[17:47:33.372]                       }
[17:47:33.372]                       else if (inherits(cond, "condition")) {
[17:47:33.372]                         if (!is.null(pattern)) {
[17:47:33.372]                           computeRestarts <- base::computeRestarts
[17:47:33.372]                           grepl <- base::grepl
[17:47:33.372]                           restarts <- computeRestarts(cond)
[17:47:33.372]                           for (restart in restarts) {
[17:47:33.372]                             name <- restart$name
[17:47:33.372]                             if (is.null(name)) 
[17:47:33.372]                               next
[17:47:33.372]                             if (!grepl(pattern, name)) 
[17:47:33.372]                               next
[17:47:33.372]                             invokeRestart(restart)
[17:47:33.372]                             muffled <- TRUE
[17:47:33.372]                             break
[17:47:33.372]                           }
[17:47:33.372]                         }
[17:47:33.372]                       }
[17:47:33.372]                       invisible(muffled)
[17:47:33.372]                     }
[17:47:33.372]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.372]                   }
[17:47:33.372]                 }
[17:47:33.372]                 else {
[17:47:33.372]                   if (TRUE) {
[17:47:33.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.372]                     {
[17:47:33.372]                       inherits <- base::inherits
[17:47:33.372]                       invokeRestart <- base::invokeRestart
[17:47:33.372]                       is.null <- base::is.null
[17:47:33.372]                       muffled <- FALSE
[17:47:33.372]                       if (inherits(cond, "message")) {
[17:47:33.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.372]                         if (muffled) 
[17:47:33.372]                           invokeRestart("muffleMessage")
[17:47:33.372]                       }
[17:47:33.372]                       else if (inherits(cond, "warning")) {
[17:47:33.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.372]                         if (muffled) 
[17:47:33.372]                           invokeRestart("muffleWarning")
[17:47:33.372]                       }
[17:47:33.372]                       else if (inherits(cond, "condition")) {
[17:47:33.372]                         if (!is.null(pattern)) {
[17:47:33.372]                           computeRestarts <- base::computeRestarts
[17:47:33.372]                           grepl <- base::grepl
[17:47:33.372]                           restarts <- computeRestarts(cond)
[17:47:33.372]                           for (restart in restarts) {
[17:47:33.372]                             name <- restart$name
[17:47:33.372]                             if (is.null(name)) 
[17:47:33.372]                               next
[17:47:33.372]                             if (!grepl(pattern, name)) 
[17:47:33.372]                               next
[17:47:33.372]                             invokeRestart(restart)
[17:47:33.372]                             muffled <- TRUE
[17:47:33.372]                             break
[17:47:33.372]                           }
[17:47:33.372]                         }
[17:47:33.372]                       }
[17:47:33.372]                       invisible(muffled)
[17:47:33.372]                     }
[17:47:33.372]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.372]                   }
[17:47:33.372]                 }
[17:47:33.372]             }
[17:47:33.372]         }))
[17:47:33.372]     }, error = function(ex) {
[17:47:33.372]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:33.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.372]                 ...future.rng), started = ...future.startTime, 
[17:47:33.372]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:33.372]             version = "1.8"), class = "FutureResult")
[17:47:33.372]     }, finally = {
[17:47:33.372]         if (!identical(...future.workdir, getwd())) 
[17:47:33.372]             setwd(...future.workdir)
[17:47:33.372]         {
[17:47:33.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:33.372]                 ...future.oldOptions$nwarnings <- NULL
[17:47:33.372]             }
[17:47:33.372]             base::options(...future.oldOptions)
[17:47:33.372]             if (.Platform$OS.type == "windows") {
[17:47:33.372]                 old_names <- names(...future.oldEnvVars)
[17:47:33.372]                 envs <- base::Sys.getenv()
[17:47:33.372]                 names <- names(envs)
[17:47:33.372]                 common <- intersect(names, old_names)
[17:47:33.372]                 added <- setdiff(names, old_names)
[17:47:33.372]                 removed <- setdiff(old_names, names)
[17:47:33.372]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:33.372]                   envs[common]]
[17:47:33.372]                 NAMES <- toupper(changed)
[17:47:33.372]                 args <- list()
[17:47:33.372]                 for (kk in seq_along(NAMES)) {
[17:47:33.372]                   name <- changed[[kk]]
[17:47:33.372]                   NAME <- NAMES[[kk]]
[17:47:33.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.372]                     next
[17:47:33.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.372]                 }
[17:47:33.372]                 NAMES <- toupper(added)
[17:47:33.372]                 for (kk in seq_along(NAMES)) {
[17:47:33.372]                   name <- added[[kk]]
[17:47:33.372]                   NAME <- NAMES[[kk]]
[17:47:33.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.372]                     next
[17:47:33.372]                   args[[name]] <- ""
[17:47:33.372]                 }
[17:47:33.372]                 NAMES <- toupper(removed)
[17:47:33.372]                 for (kk in seq_along(NAMES)) {
[17:47:33.372]                   name <- removed[[kk]]
[17:47:33.372]                   NAME <- NAMES[[kk]]
[17:47:33.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.372]                     next
[17:47:33.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.372]                 }
[17:47:33.372]                 if (length(args) > 0) 
[17:47:33.372]                   base::do.call(base::Sys.setenv, args = args)
[17:47:33.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:33.372]             }
[17:47:33.372]             else {
[17:47:33.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:33.372]             }
[17:47:33.372]             {
[17:47:33.372]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:33.372]                   0L) {
[17:47:33.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:33.372]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:33.372]                   base::options(opts)
[17:47:33.372]                 }
[17:47:33.372]                 {
[17:47:33.372]                   {
[17:47:33.372]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:33.372]                     NULL
[17:47:33.372]                   }
[17:47:33.372]                   options(future.plan = NULL)
[17:47:33.372]                   if (is.na(NA_character_)) 
[17:47:33.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:33.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:33.372]                     .init = FALSE)
[17:47:33.372]                 }
[17:47:33.372]             }
[17:47:33.372]         }
[17:47:33.372]     })
[17:47:33.372]     if (TRUE) {
[17:47:33.372]         base::sink(type = "output", split = FALSE)
[17:47:33.372]         if (TRUE) {
[17:47:33.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:33.372]         }
[17:47:33.372]         else {
[17:47:33.372]             ...future.result["stdout"] <- base::list(NULL)
[17:47:33.372]         }
[17:47:33.372]         base::close(...future.stdout)
[17:47:33.372]         ...future.stdout <- NULL
[17:47:33.372]     }
[17:47:33.372]     ...future.result$conditions <- ...future.conditions
[17:47:33.372]     ...future.result$finished <- base::Sys.time()
[17:47:33.372]     ...future.result
[17:47:33.372] }
[17:47:33.375] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:47:33.375] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:47:33.375] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:47:33.375] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:47:33.376] MultisessionFuture started
[17:47:33.376] - Launch lazy future ... done
[17:47:33.376] run() for ‘MultisessionFuture’ ... done
[17:47:33.376] result() for ClusterFuture ...
[17:47:33.377] receiveMessageFromWorker() for ClusterFuture ...
[17:47:33.377] - Validating connection of MultisessionFuture
[17:47:33.434] - received message: FutureResult
[17:47:33.435] - Received FutureResult
[17:47:33.435] - Erased future from FutureRegistry
[17:47:33.435] result() for ClusterFuture ...
[17:47:33.435] - result already collected: FutureResult
[17:47:33.435] result() for ClusterFuture ... done
[17:47:33.435] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:33.435] result() for ClusterFuture ... done
[17:47:33.435] result() for ClusterFuture ...
[17:47:33.435] - result already collected: FutureResult
[17:47:33.435] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[17:47:33.436] plan(): Setting new future strategy stack:
[17:47:33.436] List of future strategies:
[17:47:33.436] 1. multisession:
[17:47:33.436]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:33.436]    - tweaked: FALSE
[17:47:33.436]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:33.436] 2. multisession:
[17:47:33.436]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:33.436]    - tweaked: FALSE
[17:47:33.436]    - call: plan(list(a = strategy1, b = strategy2))
[17:47:33.437] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:47:33.437] multisession:
[17:47:33.437] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:33.437] - tweaked: FALSE
[17:47:33.437] - call: plan(list(a = strategy1, b = strategy2))
[17:47:33.442] getGlobalsAndPackages() ...
[17:47:33.442] Not searching for globals
[17:47:33.442] - globals: [0] <none>
[17:47:33.442] getGlobalsAndPackages() ... DONE
[17:47:33.443] [local output] makeClusterPSOCK() ...
[17:47:33.447] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:33.448] [local output] Base port: 11598
[17:47:33.448] [local output] Getting setup options for 2 cluster nodes ...
[17:47:33.449] [local output]  - Node 1 of 2 ...
[17:47:33.449] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:33.450] [local output] Rscript port: 11598

[17:47:33.450] [local output]  - Node 2 of 2 ...
[17:47:33.451] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:33.452] [local output] Rscript port: 11598

[17:47:33.452] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:33.452] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:33.452] [local output] Setting up PSOCK nodes in parallel
[17:47:33.452] List of 36
[17:47:33.452]  $ worker          : chr "localhost"
[17:47:33.452]   ..- attr(*, "localhost")= logi TRUE
[17:47:33.452]  $ master          : chr "localhost"
[17:47:33.452]  $ port            : int 11598
[17:47:33.452]  $ connectTimeout  : num 120
[17:47:33.452]  $ timeout         : num 2592000
[17:47:33.452]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:33.452]  $ homogeneous     : logi TRUE
[17:47:33.452]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:33.452]  $ rscript_envs    : NULL
[17:47:33.452]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:33.452]  $ rscript_startup : NULL
[17:47:33.452]  $ rscript_sh      : chr "sh"
[17:47:33.452]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:33.452]  $ methods         : logi TRUE
[17:47:33.452]  $ socketOptions   : chr "no-delay"
[17:47:33.452]  $ useXDR          : logi FALSE
[17:47:33.452]  $ outfile         : chr "/dev/null"
[17:47:33.452]  $ renice          : int NA
[17:47:33.452]  $ rshcmd          : NULL
[17:47:33.452]  $ user            : chr(0) 
[17:47:33.452]  $ revtunnel       : logi FALSE
[17:47:33.452]  $ rshlogfile      : NULL
[17:47:33.452]  $ rshopts         : chr(0) 
[17:47:33.452]  $ rank            : int 1
[17:47:33.452]  $ manual          : logi FALSE
[17:47:33.452]  $ dryrun          : logi FALSE
[17:47:33.452]  $ quiet           : logi FALSE
[17:47:33.452]  $ setup_strategy  : chr "parallel"
[17:47:33.452]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:33.452]  $ pidfile         : chr "/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b9176b97428e.pid"
[17:47:33.452]  $ rshcmd_label    : NULL
[17:47:33.452]  $ rsh_call        : NULL
[17:47:33.452]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:33.452]  $ localMachine    : logi TRUE
[17:47:33.452]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:33.452]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:33.452]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:33.452]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:33.452]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:33.452]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:33.452]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:33.452]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:33.452]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:33.452]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:33.452]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:33.452]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:33.452]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:33.452]  $ arguments       :List of 28
[17:47:33.452]   ..$ worker          : chr "localhost"
[17:47:33.452]   ..$ master          : NULL
[17:47:33.452]   ..$ port            : int 11598
[17:47:33.452]   ..$ connectTimeout  : num 120
[17:47:33.452]   ..$ timeout         : num 2592000
[17:47:33.452]   ..$ rscript         : NULL
[17:47:33.452]   ..$ homogeneous     : NULL
[17:47:33.452]   ..$ rscript_args    : NULL
[17:47:33.452]   ..$ rscript_envs    : NULL
[17:47:33.452]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:33.452]   ..$ rscript_startup : NULL
[17:47:33.452]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:33.452]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:33.452]   ..$ methods         : logi TRUE
[17:47:33.452]   ..$ socketOptions   : chr "no-delay"
[17:47:33.452]   ..$ useXDR          : logi FALSE
[17:47:33.452]   ..$ outfile         : chr "/dev/null"
[17:47:33.452]   ..$ renice          : int NA
[17:47:33.452]   ..$ rshcmd          : NULL
[17:47:33.452]   ..$ user            : NULL
[17:47:33.452]   ..$ revtunnel       : logi NA
[17:47:33.452]   ..$ rshlogfile      : NULL
[17:47:33.452]   ..$ rshopts         : NULL
[17:47:33.452]   ..$ rank            : int 1
[17:47:33.452]   ..$ manual          : logi FALSE
[17:47:33.452]   ..$ dryrun          : logi FALSE
[17:47:33.452]   ..$ quiet           : logi FALSE
[17:47:33.452]   ..$ setup_strategy  : chr "parallel"
[17:47:33.452]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:33.473] [local output] System call to launch all workers:
[17:47:33.473] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS8clGH/worker.rank=1.parallelly.parent=47383.b9176b97428e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11598 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:33.473] [local output] Starting PSOCK main server
[17:47:33.474] [local output] Workers launched
[17:47:33.475] [local output] Waiting for workers to connect back
[17:47:33.475]  - [local output] 0 workers out of 2 ready
[17:47:33.740]  - [local output] 0 workers out of 2 ready
[17:47:33.740]  - [local output] 1 workers out of 2 ready
[17:47:33.747]  - [local output] 1 workers out of 2 ready
[17:47:33.747]  - [local output] 2 workers out of 2 ready
[17:47:33.748] [local output] Launching of workers completed
[17:47:33.748] [local output] Collecting session information from workers
[17:47:33.748] [local output]  - Worker #1 of 2
[17:47:33.749] [local output]  - Worker #2 of 2
[17:47:33.749] [local output] makeClusterPSOCK() ... done
[17:47:33.760] Packages needed by the future expression (n = 0): <none>
[17:47:33.760] Packages needed by future strategies (n = 1): ‘future’
[17:47:33.760] {
[17:47:33.760]     {
[17:47:33.760]         {
[17:47:33.760]             ...future.startTime <- base::Sys.time()
[17:47:33.760]             {
[17:47:33.760]                 {
[17:47:33.760]                   {
[17:47:33.760]                     {
[17:47:33.760]                       {
[17:47:33.760]                         base::local({
[17:47:33.760]                           has_future <- base::requireNamespace("future", 
[17:47:33.760]                             quietly = TRUE)
[17:47:33.760]                           if (has_future) {
[17:47:33.760]                             ns <- base::getNamespace("future")
[17:47:33.760]                             version <- ns[[".package"]][["version"]]
[17:47:33.760]                             if (is.null(version)) 
[17:47:33.760]                               version <- utils::packageVersion("future")
[17:47:33.760]                           }
[17:47:33.760]                           else {
[17:47:33.760]                             version <- NULL
[17:47:33.760]                           }
[17:47:33.760]                           if (!has_future || version < "1.8.0") {
[17:47:33.760]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:33.760]                               "", base::R.version$version.string), 
[17:47:33.760]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:33.760]                                 base::R.version$platform, 8 * 
[17:47:33.760]                                   base::.Machine$sizeof.pointer), 
[17:47:33.760]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:33.760]                                 "release", "version")], collapse = " "), 
[17:47:33.760]                               hostname = base::Sys.info()[["nodename"]])
[17:47:33.760]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:33.760]                               info)
[17:47:33.760]                             info <- base::paste(info, collapse = "; ")
[17:47:33.760]                             if (!has_future) {
[17:47:33.760]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:33.760]                                 info)
[17:47:33.760]                             }
[17:47:33.760]                             else {
[17:47:33.760]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:33.760]                                 info, version)
[17:47:33.760]                             }
[17:47:33.760]                             base::stop(msg)
[17:47:33.760]                           }
[17:47:33.760]                         })
[17:47:33.760]                       }
[17:47:33.760]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:33.760]                       base::options(mc.cores = 1L)
[17:47:33.760]                     }
[17:47:33.760]                     base::local({
[17:47:33.760]                       for (pkg in "future") {
[17:47:33.760]                         base::loadNamespace(pkg)
[17:47:33.760]                         base::library(pkg, character.only = TRUE)
[17:47:33.760]                       }
[17:47:33.760]                     })
[17:47:33.760]                   }
[17:47:33.760]                   ...future.strategy.old <- future::plan("list")
[17:47:33.760]                   options(future.plan = NULL)
[17:47:33.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.760]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:33.760]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:33.760]                     envir = parent.frame()) 
[17:47:33.760]                   {
[17:47:33.760]                     if (is.function(workers)) 
[17:47:33.760]                       workers <- workers()
[17:47:33.760]                     workers <- structure(as.integer(workers), 
[17:47:33.760]                       class = class(workers))
[17:47:33.760]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:33.760]                       workers >= 1)
[17:47:33.760]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:33.760]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:33.760]                     }
[17:47:33.760]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:33.760]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:33.760]                       envir = envir)
[17:47:33.760]                     if (!future$lazy) 
[17:47:33.760]                       future <- run(future)
[17:47:33.760]                     invisible(future)
[17:47:33.760]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:33.760]                 }
[17:47:33.760]                 ...future.workdir <- getwd()
[17:47:33.760]             }
[17:47:33.760]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:33.760]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:33.760]         }
[17:47:33.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:33.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:33.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:33.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:33.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:33.760]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:33.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:33.760]             base::names(...future.oldOptions))
[17:47:33.760]     }
[17:47:33.760]     if (FALSE) {
[17:47:33.760]     }
[17:47:33.760]     else {
[17:47:33.760]         if (TRUE) {
[17:47:33.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:33.760]                 open = "w")
[17:47:33.760]         }
[17:47:33.760]         else {
[17:47:33.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:33.760]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:33.760]         }
[17:47:33.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:33.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:33.760]             base::sink(type = "output", split = FALSE)
[17:47:33.760]             base::close(...future.stdout)
[17:47:33.760]         }, add = TRUE)
[17:47:33.760]     }
[17:47:33.760]     ...future.frame <- base::sys.nframe()
[17:47:33.760]     ...future.conditions <- base::list()
[17:47:33.760]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:33.760]     if (FALSE) {
[17:47:33.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:33.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:33.760]     }
[17:47:33.760]     ...future.result <- base::tryCatch({
[17:47:33.760]         base::withCallingHandlers({
[17:47:33.760]             ...future.value <- base::withVisible(base::local({
[17:47:33.760]                 ...future.makeSendCondition <- base::local({
[17:47:33.760]                   sendCondition <- NULL
[17:47:33.760]                   function(frame = 1L) {
[17:47:33.760]                     if (is.function(sendCondition)) 
[17:47:33.760]                       return(sendCondition)
[17:47:33.760]                     ns <- getNamespace("parallel")
[17:47:33.760]                     if (exists("sendData", mode = "function", 
[17:47:33.760]                       envir = ns)) {
[17:47:33.760]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:33.760]                         envir = ns)
[17:47:33.760]                       envir <- sys.frame(frame)
[17:47:33.760]                       master <- NULL
[17:47:33.760]                       while (!identical(envir, .GlobalEnv) && 
[17:47:33.760]                         !identical(envir, emptyenv())) {
[17:47:33.760]                         if (exists("master", mode = "list", envir = envir, 
[17:47:33.760]                           inherits = FALSE)) {
[17:47:33.760]                           master <- get("master", mode = "list", 
[17:47:33.760]                             envir = envir, inherits = FALSE)
[17:47:33.760]                           if (inherits(master, c("SOCKnode", 
[17:47:33.760]                             "SOCK0node"))) {
[17:47:33.760]                             sendCondition <<- function(cond) {
[17:47:33.760]                               data <- list(type = "VALUE", value = cond, 
[17:47:33.760]                                 success = TRUE)
[17:47:33.760]                               parallel_sendData(master, data)
[17:47:33.760]                             }
[17:47:33.760]                             return(sendCondition)
[17:47:33.760]                           }
[17:47:33.760]                         }
[17:47:33.760]                         frame <- frame + 1L
[17:47:33.760]                         envir <- sys.frame(frame)
[17:47:33.760]                       }
[17:47:33.760]                     }
[17:47:33.760]                     sendCondition <<- function(cond) NULL
[17:47:33.760]                   }
[17:47:33.760]                 })
[17:47:33.760]                 withCallingHandlers({
[17:47:33.760]                   NA
[17:47:33.760]                 }, immediateCondition = function(cond) {
[17:47:33.760]                   sendCondition <- ...future.makeSendCondition()
[17:47:33.760]                   sendCondition(cond)
[17:47:33.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.760]                   {
[17:47:33.760]                     inherits <- base::inherits
[17:47:33.760]                     invokeRestart <- base::invokeRestart
[17:47:33.760]                     is.null <- base::is.null
[17:47:33.760]                     muffled <- FALSE
[17:47:33.760]                     if (inherits(cond, "message")) {
[17:47:33.760]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:33.760]                       if (muffled) 
[17:47:33.760]                         invokeRestart("muffleMessage")
[17:47:33.760]                     }
[17:47:33.760]                     else if (inherits(cond, "warning")) {
[17:47:33.760]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:33.760]                       if (muffled) 
[17:47:33.760]                         invokeRestart("muffleWarning")
[17:47:33.760]                     }
[17:47:33.760]                     else if (inherits(cond, "condition")) {
[17:47:33.760]                       if (!is.null(pattern)) {
[17:47:33.760]                         computeRestarts <- base::computeRestarts
[17:47:33.760]                         grepl <- base::grepl
[17:47:33.760]                         restarts <- computeRestarts(cond)
[17:47:33.760]                         for (restart in restarts) {
[17:47:33.760]                           name <- restart$name
[17:47:33.760]                           if (is.null(name)) 
[17:47:33.760]                             next
[17:47:33.760]                           if (!grepl(pattern, name)) 
[17:47:33.760]                             next
[17:47:33.760]                           invokeRestart(restart)
[17:47:33.760]                           muffled <- TRUE
[17:47:33.760]                           break
[17:47:33.760]                         }
[17:47:33.760]                       }
[17:47:33.760]                     }
[17:47:33.760]                     invisible(muffled)
[17:47:33.760]                   }
[17:47:33.760]                   muffleCondition(cond)
[17:47:33.760]                 })
[17:47:33.760]             }))
[17:47:33.760]             future::FutureResult(value = ...future.value$value, 
[17:47:33.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.760]                   ...future.rng), globalenv = if (FALSE) 
[17:47:33.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:33.760]                     ...future.globalenv.names))
[17:47:33.760]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:33.760]         }, condition = base::local({
[17:47:33.760]             c <- base::c
[17:47:33.760]             inherits <- base::inherits
[17:47:33.760]             invokeRestart <- base::invokeRestart
[17:47:33.760]             length <- base::length
[17:47:33.760]             list <- base::list
[17:47:33.760]             seq.int <- base::seq.int
[17:47:33.760]             signalCondition <- base::signalCondition
[17:47:33.760]             sys.calls <- base::sys.calls
[17:47:33.760]             `[[` <- base::`[[`
[17:47:33.760]             `+` <- base::`+`
[17:47:33.760]             `<<-` <- base::`<<-`
[17:47:33.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:33.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:33.760]                   3L)]
[17:47:33.760]             }
[17:47:33.760]             function(cond) {
[17:47:33.760]                 is_error <- inherits(cond, "error")
[17:47:33.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:33.760]                   NULL)
[17:47:33.760]                 if (is_error) {
[17:47:33.760]                   sessionInformation <- function() {
[17:47:33.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:33.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:33.760]                       search = base::search(), system = base::Sys.info())
[17:47:33.760]                   }
[17:47:33.760]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:33.760]                     cond$call), session = sessionInformation(), 
[17:47:33.760]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:33.760]                   signalCondition(cond)
[17:47:33.760]                 }
[17:47:33.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:33.760]                 "immediateCondition"))) {
[17:47:33.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:33.760]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:33.760]                   if (TRUE && !signal) {
[17:47:33.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.760]                     {
[17:47:33.760]                       inherits <- base::inherits
[17:47:33.760]                       invokeRestart <- base::invokeRestart
[17:47:33.760]                       is.null <- base::is.null
[17:47:33.760]                       muffled <- FALSE
[17:47:33.760]                       if (inherits(cond, "message")) {
[17:47:33.760]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.760]                         if (muffled) 
[17:47:33.760]                           invokeRestart("muffleMessage")
[17:47:33.760]                       }
[17:47:33.760]                       else if (inherits(cond, "warning")) {
[17:47:33.760]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.760]                         if (muffled) 
[17:47:33.760]                           invokeRestart("muffleWarning")
[17:47:33.760]                       }
[17:47:33.760]                       else if (inherits(cond, "condition")) {
[17:47:33.760]                         if (!is.null(pattern)) {
[17:47:33.760]                           computeRestarts <- base::computeRestarts
[17:47:33.760]                           grepl <- base::grepl
[17:47:33.760]                           restarts <- computeRestarts(cond)
[17:47:33.760]                           for (restart in restarts) {
[17:47:33.760]                             name <- restart$name
[17:47:33.760]                             if (is.null(name)) 
[17:47:33.760]                               next
[17:47:33.760]                             if (!grepl(pattern, name)) 
[17:47:33.760]                               next
[17:47:33.760]                             invokeRestart(restart)
[17:47:33.760]                             muffled <- TRUE
[17:47:33.760]                             break
[17:47:33.760]                           }
[17:47:33.760]                         }
[17:47:33.760]                       }
[17:47:33.760]                       invisible(muffled)
[17:47:33.760]                     }
[17:47:33.760]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.760]                   }
[17:47:33.760]                 }
[17:47:33.760]                 else {
[17:47:33.760]                   if (TRUE) {
[17:47:33.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.760]                     {
[17:47:33.760]                       inherits <- base::inherits
[17:47:33.760]                       invokeRestart <- base::invokeRestart
[17:47:33.760]                       is.null <- base::is.null
[17:47:33.760]                       muffled <- FALSE
[17:47:33.760]                       if (inherits(cond, "message")) {
[17:47:33.760]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.760]                         if (muffled) 
[17:47:33.760]                           invokeRestart("muffleMessage")
[17:47:33.760]                       }
[17:47:33.760]                       else if (inherits(cond, "warning")) {
[17:47:33.760]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.760]                         if (muffled) 
[17:47:33.760]                           invokeRestart("muffleWarning")
[17:47:33.760]                       }
[17:47:33.760]                       else if (inherits(cond, "condition")) {
[17:47:33.760]                         if (!is.null(pattern)) {
[17:47:33.760]                           computeRestarts <- base::computeRestarts
[17:47:33.760]                           grepl <- base::grepl
[17:47:33.760]                           restarts <- computeRestarts(cond)
[17:47:33.760]                           for (restart in restarts) {
[17:47:33.760]                             name <- restart$name
[17:47:33.760]                             if (is.null(name)) 
[17:47:33.760]                               next
[17:47:33.760]                             if (!grepl(pattern, name)) 
[17:47:33.760]                               next
[17:47:33.760]                             invokeRestart(restart)
[17:47:33.760]                             muffled <- TRUE
[17:47:33.760]                             break
[17:47:33.760]                           }
[17:47:33.760]                         }
[17:47:33.760]                       }
[17:47:33.760]                       invisible(muffled)
[17:47:33.760]                     }
[17:47:33.760]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.760]                   }
[17:47:33.760]                 }
[17:47:33.760]             }
[17:47:33.760]         }))
[17:47:33.760]     }, error = function(ex) {
[17:47:33.760]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:33.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.760]                 ...future.rng), started = ...future.startTime, 
[17:47:33.760]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:33.760]             version = "1.8"), class = "FutureResult")
[17:47:33.760]     }, finally = {
[17:47:33.760]         if (!identical(...future.workdir, getwd())) 
[17:47:33.760]             setwd(...future.workdir)
[17:47:33.760]         {
[17:47:33.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:33.760]                 ...future.oldOptions$nwarnings <- NULL
[17:47:33.760]             }
[17:47:33.760]             base::options(...future.oldOptions)
[17:47:33.760]             if (.Platform$OS.type == "windows") {
[17:47:33.760]                 old_names <- names(...future.oldEnvVars)
[17:47:33.760]                 envs <- base::Sys.getenv()
[17:47:33.760]                 names <- names(envs)
[17:47:33.760]                 common <- intersect(names, old_names)
[17:47:33.760]                 added <- setdiff(names, old_names)
[17:47:33.760]                 removed <- setdiff(old_names, names)
[17:47:33.760]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:33.760]                   envs[common]]
[17:47:33.760]                 NAMES <- toupper(changed)
[17:47:33.760]                 args <- list()
[17:47:33.760]                 for (kk in seq_along(NAMES)) {
[17:47:33.760]                   name <- changed[[kk]]
[17:47:33.760]                   NAME <- NAMES[[kk]]
[17:47:33.760]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.760]                     next
[17:47:33.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.760]                 }
[17:47:33.760]                 NAMES <- toupper(added)
[17:47:33.760]                 for (kk in seq_along(NAMES)) {
[17:47:33.760]                   name <- added[[kk]]
[17:47:33.760]                   NAME <- NAMES[[kk]]
[17:47:33.760]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.760]                     next
[17:47:33.760]                   args[[name]] <- ""
[17:47:33.760]                 }
[17:47:33.760]                 NAMES <- toupper(removed)
[17:47:33.760]                 for (kk in seq_along(NAMES)) {
[17:47:33.760]                   name <- removed[[kk]]
[17:47:33.760]                   NAME <- NAMES[[kk]]
[17:47:33.760]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.760]                     next
[17:47:33.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.760]                 }
[17:47:33.760]                 if (length(args) > 0) 
[17:47:33.760]                   base::do.call(base::Sys.setenv, args = args)
[17:47:33.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:33.760]             }
[17:47:33.760]             else {
[17:47:33.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:33.760]             }
[17:47:33.760]             {
[17:47:33.760]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:33.760]                   0L) {
[17:47:33.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:33.760]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:33.760]                   base::options(opts)
[17:47:33.760]                 }
[17:47:33.760]                 {
[17:47:33.760]                   {
[17:47:33.760]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:33.760]                     NULL
[17:47:33.760]                   }
[17:47:33.760]                   options(future.plan = NULL)
[17:47:33.760]                   if (is.na(NA_character_)) 
[17:47:33.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:33.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:33.760]                     .init = FALSE)
[17:47:33.760]                 }
[17:47:33.760]             }
[17:47:33.760]         }
[17:47:33.760]     })
[17:47:33.760]     if (TRUE) {
[17:47:33.760]         base::sink(type = "output", split = FALSE)
[17:47:33.760]         if (TRUE) {
[17:47:33.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:33.760]         }
[17:47:33.760]         else {
[17:47:33.760]             ...future.result["stdout"] <- base::list(NULL)
[17:47:33.760]         }
[17:47:33.760]         base::close(...future.stdout)
[17:47:33.760]         ...future.stdout <- NULL
[17:47:33.760]     }
[17:47:33.760]     ...future.result$conditions <- ...future.conditions
[17:47:33.760]     ...future.result$finished <- base::Sys.time()
[17:47:33.760]     ...future.result
[17:47:33.760] }
[17:47:33.812] MultisessionFuture started
[17:47:33.812] result() for ClusterFuture ...
[17:47:33.812] receiveMessageFromWorker() for ClusterFuture ...
[17:47:33.812] - Validating connection of MultisessionFuture
[17:47:33.857] - received message: FutureResult
[17:47:33.857] - Received FutureResult
[17:47:33.857] - Erased future from FutureRegistry
[17:47:33.857] result() for ClusterFuture ...
[17:47:33.857] - result already collected: FutureResult
[17:47:33.857] result() for ClusterFuture ... done
[17:47:33.857] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:33.857] result() for ClusterFuture ... done
[17:47:33.857] result() for ClusterFuture ...
[17:47:33.858] - result already collected: FutureResult
[17:47:33.858] result() for ClusterFuture ... done
[17:47:33.858] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:47:33.861] plan(): nbrOfWorkers() = 2
[17:47:33.861] getGlobalsAndPackages() ...
[17:47:33.862] Searching for globals...
[17:47:33.877] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:47:33.877] Searching for globals ... DONE
[17:47:33.877] Resolving globals: FALSE
[17:47:33.878] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[17:47:33.879] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:47:33.879] - globals: [2] ‘nested’, ‘strategy2’
[17:47:33.879] - packages: [1] ‘future’
[17:47:33.879] getGlobalsAndPackages() ... DONE
[17:47:33.879] run() for ‘Future’ ...
[17:47:33.880] - state: ‘created’
[17:47:33.880] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:33.893] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:33.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:33.893]   - Field: ‘node’
[17:47:33.893]   - Field: ‘label’
[17:47:33.893]   - Field: ‘local’
[17:47:33.894]   - Field: ‘owner’
[17:47:33.894]   - Field: ‘envir’
[17:47:33.894]   - Field: ‘workers’
[17:47:33.894]   - Field: ‘packages’
[17:47:33.894]   - Field: ‘gc’
[17:47:33.894]   - Field: ‘conditions’
[17:47:33.894]   - Field: ‘persistent’
[17:47:33.894]   - Field: ‘expr’
[17:47:33.894]   - Field: ‘uuid’
[17:47:33.894]   - Field: ‘seed’
[17:47:33.894]   - Field: ‘version’
[17:47:33.895]   - Field: ‘result’
[17:47:33.895]   - Field: ‘asynchronous’
[17:47:33.895]   - Field: ‘calls’
[17:47:33.895]   - Field: ‘globals’
[17:47:33.895]   - Field: ‘stdout’
[17:47:33.895]   - Field: ‘earlySignal’
[17:47:33.895]   - Field: ‘lazy’
[17:47:33.895]   - Field: ‘state’
[17:47:33.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:33.895] - Launch lazy future ...
[17:47:33.896] Packages needed by the future expression (n = 1): ‘future’
[17:47:33.896] Packages needed by future strategies (n = 1): ‘future’
[17:47:33.896] {
[17:47:33.896]     {
[17:47:33.896]         {
[17:47:33.896]             ...future.startTime <- base::Sys.time()
[17:47:33.896]             {
[17:47:33.896]                 {
[17:47:33.896]                   {
[17:47:33.896]                     {
[17:47:33.896]                       {
[17:47:33.896]                         base::local({
[17:47:33.896]                           has_future <- base::requireNamespace("future", 
[17:47:33.896]                             quietly = TRUE)
[17:47:33.896]                           if (has_future) {
[17:47:33.896]                             ns <- base::getNamespace("future")
[17:47:33.896]                             version <- ns[[".package"]][["version"]]
[17:47:33.896]                             if (is.null(version)) 
[17:47:33.896]                               version <- utils::packageVersion("future")
[17:47:33.896]                           }
[17:47:33.896]                           else {
[17:47:33.896]                             version <- NULL
[17:47:33.896]                           }
[17:47:33.896]                           if (!has_future || version < "1.8.0") {
[17:47:33.896]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:33.896]                               "", base::R.version$version.string), 
[17:47:33.896]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:33.896]                                 base::R.version$platform, 8 * 
[17:47:33.896]                                   base::.Machine$sizeof.pointer), 
[17:47:33.896]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:33.896]                                 "release", "version")], collapse = " "), 
[17:47:33.896]                               hostname = base::Sys.info()[["nodename"]])
[17:47:33.896]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:33.896]                               info)
[17:47:33.896]                             info <- base::paste(info, collapse = "; ")
[17:47:33.896]                             if (!has_future) {
[17:47:33.896]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:33.896]                                 info)
[17:47:33.896]                             }
[17:47:33.896]                             else {
[17:47:33.896]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:33.896]                                 info, version)
[17:47:33.896]                             }
[17:47:33.896]                             base::stop(msg)
[17:47:33.896]                           }
[17:47:33.896]                         })
[17:47:33.896]                       }
[17:47:33.896]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:33.896]                       base::options(mc.cores = 1L)
[17:47:33.896]                     }
[17:47:33.896]                     base::local({
[17:47:33.896]                       for (pkg in "future") {
[17:47:33.896]                         base::loadNamespace(pkg)
[17:47:33.896]                         base::library(pkg, character.only = TRUE)
[17:47:33.896]                       }
[17:47:33.896]                     })
[17:47:33.896]                   }
[17:47:33.896]                   ...future.strategy.old <- future::plan("list")
[17:47:33.896]                   options(future.plan = NULL)
[17:47:33.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.896]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:33.896]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:33.896]                     envir = parent.frame()) 
[17:47:33.896]                   {
[17:47:33.896]                     if (is.function(workers)) 
[17:47:33.896]                       workers <- workers()
[17:47:33.896]                     workers <- structure(as.integer(workers), 
[17:47:33.896]                       class = class(workers))
[17:47:33.896]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:33.896]                       workers >= 1)
[17:47:33.896]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:33.896]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:33.896]                     }
[17:47:33.896]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:33.896]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:33.896]                       envir = envir)
[17:47:33.896]                     if (!future$lazy) 
[17:47:33.896]                       future <- run(future)
[17:47:33.896]                     invisible(future)
[17:47:33.896]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:33.896]                 }
[17:47:33.896]                 ...future.workdir <- getwd()
[17:47:33.896]             }
[17:47:33.896]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:33.896]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:33.896]         }
[17:47:33.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:33.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:33.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:33.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:33.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:33.896]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:33.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:33.896]             base::names(...future.oldOptions))
[17:47:33.896]     }
[17:47:33.896]     if (FALSE) {
[17:47:33.896]     }
[17:47:33.896]     else {
[17:47:33.896]         if (TRUE) {
[17:47:33.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:33.896]                 open = "w")
[17:47:33.896]         }
[17:47:33.896]         else {
[17:47:33.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:33.896]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:33.896]         }
[17:47:33.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:33.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:33.896]             base::sink(type = "output", split = FALSE)
[17:47:33.896]             base::close(...future.stdout)
[17:47:33.896]         }, add = TRUE)
[17:47:33.896]     }
[17:47:33.896]     ...future.frame <- base::sys.nframe()
[17:47:33.896]     ...future.conditions <- base::list()
[17:47:33.896]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:33.896]     if (FALSE) {
[17:47:33.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:33.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:33.896]     }
[17:47:33.896]     ...future.result <- base::tryCatch({
[17:47:33.896]         base::withCallingHandlers({
[17:47:33.896]             ...future.value <- base::withVisible(base::local({
[17:47:33.896]                 ...future.makeSendCondition <- base::local({
[17:47:33.896]                   sendCondition <- NULL
[17:47:33.896]                   function(frame = 1L) {
[17:47:33.896]                     if (is.function(sendCondition)) 
[17:47:33.896]                       return(sendCondition)
[17:47:33.896]                     ns <- getNamespace("parallel")
[17:47:33.896]                     if (exists("sendData", mode = "function", 
[17:47:33.896]                       envir = ns)) {
[17:47:33.896]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:33.896]                         envir = ns)
[17:47:33.896]                       envir <- sys.frame(frame)
[17:47:33.896]                       master <- NULL
[17:47:33.896]                       while (!identical(envir, .GlobalEnv) && 
[17:47:33.896]                         !identical(envir, emptyenv())) {
[17:47:33.896]                         if (exists("master", mode = "list", envir = envir, 
[17:47:33.896]                           inherits = FALSE)) {
[17:47:33.896]                           master <- get("master", mode = "list", 
[17:47:33.896]                             envir = envir, inherits = FALSE)
[17:47:33.896]                           if (inherits(master, c("SOCKnode", 
[17:47:33.896]                             "SOCK0node"))) {
[17:47:33.896]                             sendCondition <<- function(cond) {
[17:47:33.896]                               data <- list(type = "VALUE", value = cond, 
[17:47:33.896]                                 success = TRUE)
[17:47:33.896]                               parallel_sendData(master, data)
[17:47:33.896]                             }
[17:47:33.896]                             return(sendCondition)
[17:47:33.896]                           }
[17:47:33.896]                         }
[17:47:33.896]                         frame <- frame + 1L
[17:47:33.896]                         envir <- sys.frame(frame)
[17:47:33.896]                       }
[17:47:33.896]                     }
[17:47:33.896]                     sendCondition <<- function(cond) NULL
[17:47:33.896]                   }
[17:47:33.896]                 })
[17:47:33.896]                 withCallingHandlers({
[17:47:33.896]                   {
[17:47:33.896]                     a <- 1L
[17:47:33.896]                     plan_a <- unclass(future::plan("list"))
[17:47:33.896]                     nested_a <- nested[-1]
[17:47:33.896]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:47:33.896]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:47:33.896]                       strategy2))
[17:47:33.896]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:47:33.896]                       "init") <- NULL
[17:47:33.896]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:47:33.896]                       "init") <- NULL
[17:47:33.896]                     stopifnot(all.equal(plan_a, nested_a))
[17:47:33.896]                     y %<-% {
[17:47:33.896]                       b <- 2L
[17:47:33.896]                       plan_b <- future::plan("list")
[17:47:33.896]                       nested_b <- nested_a[-1]
[17:47:33.896]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:47:33.896]                         1L, inherits(plan_b[[1]], "future"), 
[17:47:33.896]                         inherits(future::plan("next"), "sequential"))
[17:47:33.896]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:47:33.896]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:47:33.896]                     }
[17:47:33.896]                     y
[17:47:33.896]                   }
[17:47:33.896]                 }, immediateCondition = function(cond) {
[17:47:33.896]                   sendCondition <- ...future.makeSendCondition()
[17:47:33.896]                   sendCondition(cond)
[17:47:33.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.896]                   {
[17:47:33.896]                     inherits <- base::inherits
[17:47:33.896]                     invokeRestart <- base::invokeRestart
[17:47:33.896]                     is.null <- base::is.null
[17:47:33.896]                     muffled <- FALSE
[17:47:33.896]                     if (inherits(cond, "message")) {
[17:47:33.896]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:33.896]                       if (muffled) 
[17:47:33.896]                         invokeRestart("muffleMessage")
[17:47:33.896]                     }
[17:47:33.896]                     else if (inherits(cond, "warning")) {
[17:47:33.896]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:33.896]                       if (muffled) 
[17:47:33.896]                         invokeRestart("muffleWarning")
[17:47:33.896]                     }
[17:47:33.896]                     else if (inherits(cond, "condition")) {
[17:47:33.896]                       if (!is.null(pattern)) {
[17:47:33.896]                         computeRestarts <- base::computeRestarts
[17:47:33.896]                         grepl <- base::grepl
[17:47:33.896]                         restarts <- computeRestarts(cond)
[17:47:33.896]                         for (restart in restarts) {
[17:47:33.896]                           name <- restart$name
[17:47:33.896]                           if (is.null(name)) 
[17:47:33.896]                             next
[17:47:33.896]                           if (!grepl(pattern, name)) 
[17:47:33.896]                             next
[17:47:33.896]                           invokeRestart(restart)
[17:47:33.896]                           muffled <- TRUE
[17:47:33.896]                           break
[17:47:33.896]                         }
[17:47:33.896]                       }
[17:47:33.896]                     }
[17:47:33.896]                     invisible(muffled)
[17:47:33.896]                   }
[17:47:33.896]                   muffleCondition(cond)
[17:47:33.896]                 })
[17:47:33.896]             }))
[17:47:33.896]             future::FutureResult(value = ...future.value$value, 
[17:47:33.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.896]                   ...future.rng), globalenv = if (FALSE) 
[17:47:33.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:33.896]                     ...future.globalenv.names))
[17:47:33.896]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:33.896]         }, condition = base::local({
[17:47:33.896]             c <- base::c
[17:47:33.896]             inherits <- base::inherits
[17:47:33.896]             invokeRestart <- base::invokeRestart
[17:47:33.896]             length <- base::length
[17:47:33.896]             list <- base::list
[17:47:33.896]             seq.int <- base::seq.int
[17:47:33.896]             signalCondition <- base::signalCondition
[17:47:33.896]             sys.calls <- base::sys.calls
[17:47:33.896]             `[[` <- base::`[[`
[17:47:33.896]             `+` <- base::`+`
[17:47:33.896]             `<<-` <- base::`<<-`
[17:47:33.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:33.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:33.896]                   3L)]
[17:47:33.896]             }
[17:47:33.896]             function(cond) {
[17:47:33.896]                 is_error <- inherits(cond, "error")
[17:47:33.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:33.896]                   NULL)
[17:47:33.896]                 if (is_error) {
[17:47:33.896]                   sessionInformation <- function() {
[17:47:33.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:33.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:33.896]                       search = base::search(), system = base::Sys.info())
[17:47:33.896]                   }
[17:47:33.896]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:33.896]                     cond$call), session = sessionInformation(), 
[17:47:33.896]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:33.896]                   signalCondition(cond)
[17:47:33.896]                 }
[17:47:33.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:33.896]                 "immediateCondition"))) {
[17:47:33.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:33.896]                   ...future.conditions[[length(...future.conditions) + 
[17:47:33.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:33.896]                   if (TRUE && !signal) {
[17:47:33.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.896]                     {
[17:47:33.896]                       inherits <- base::inherits
[17:47:33.896]                       invokeRestart <- base::invokeRestart
[17:47:33.896]                       is.null <- base::is.null
[17:47:33.896]                       muffled <- FALSE
[17:47:33.896]                       if (inherits(cond, "message")) {
[17:47:33.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.896]                         if (muffled) 
[17:47:33.896]                           invokeRestart("muffleMessage")
[17:47:33.896]                       }
[17:47:33.896]                       else if (inherits(cond, "warning")) {
[17:47:33.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.896]                         if (muffled) 
[17:47:33.896]                           invokeRestart("muffleWarning")
[17:47:33.896]                       }
[17:47:33.896]                       else if (inherits(cond, "condition")) {
[17:47:33.896]                         if (!is.null(pattern)) {
[17:47:33.896]                           computeRestarts <- base::computeRestarts
[17:47:33.896]                           grepl <- base::grepl
[17:47:33.896]                           restarts <- computeRestarts(cond)
[17:47:33.896]                           for (restart in restarts) {
[17:47:33.896]                             name <- restart$name
[17:47:33.896]                             if (is.null(name)) 
[17:47:33.896]                               next
[17:47:33.896]                             if (!grepl(pattern, name)) 
[17:47:33.896]                               next
[17:47:33.896]                             invokeRestart(restart)
[17:47:33.896]                             muffled <- TRUE
[17:47:33.896]                             break
[17:47:33.896]                           }
[17:47:33.896]                         }
[17:47:33.896]                       }
[17:47:33.896]                       invisible(muffled)
[17:47:33.896]                     }
[17:47:33.896]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.896]                   }
[17:47:33.896]                 }
[17:47:33.896]                 else {
[17:47:33.896]                   if (TRUE) {
[17:47:33.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:33.896]                     {
[17:47:33.896]                       inherits <- base::inherits
[17:47:33.896]                       invokeRestart <- base::invokeRestart
[17:47:33.896]                       is.null <- base::is.null
[17:47:33.896]                       muffled <- FALSE
[17:47:33.896]                       if (inherits(cond, "message")) {
[17:47:33.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:33.896]                         if (muffled) 
[17:47:33.896]                           invokeRestart("muffleMessage")
[17:47:33.896]                       }
[17:47:33.896]                       else if (inherits(cond, "warning")) {
[17:47:33.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:33.896]                         if (muffled) 
[17:47:33.896]                           invokeRestart("muffleWarning")
[17:47:33.896]                       }
[17:47:33.896]                       else if (inherits(cond, "condition")) {
[17:47:33.896]                         if (!is.null(pattern)) {
[17:47:33.896]                           computeRestarts <- base::computeRestarts
[17:47:33.896]                           grepl <- base::grepl
[17:47:33.896]                           restarts <- computeRestarts(cond)
[17:47:33.896]                           for (restart in restarts) {
[17:47:33.896]                             name <- restart$name
[17:47:33.896]                             if (is.null(name)) 
[17:47:33.896]                               next
[17:47:33.896]                             if (!grepl(pattern, name)) 
[17:47:33.896]                               next
[17:47:33.896]                             invokeRestart(restart)
[17:47:33.896]                             muffled <- TRUE
[17:47:33.896]                             break
[17:47:33.896]                           }
[17:47:33.896]                         }
[17:47:33.896]                       }
[17:47:33.896]                       invisible(muffled)
[17:47:33.896]                     }
[17:47:33.896]                     muffleCondition(cond, pattern = "^muffle")
[17:47:33.896]                   }
[17:47:33.896]                 }
[17:47:33.896]             }
[17:47:33.896]         }))
[17:47:33.896]     }, error = function(ex) {
[17:47:33.896]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:33.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:33.896]                 ...future.rng), started = ...future.startTime, 
[17:47:33.896]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:33.896]             version = "1.8"), class = "FutureResult")
[17:47:33.896]     }, finally = {
[17:47:33.896]         if (!identical(...future.workdir, getwd())) 
[17:47:33.896]             setwd(...future.workdir)
[17:47:33.896]         {
[17:47:33.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:33.896]                 ...future.oldOptions$nwarnings <- NULL
[17:47:33.896]             }
[17:47:33.896]             base::options(...future.oldOptions)
[17:47:33.896]             if (.Platform$OS.type == "windows") {
[17:47:33.896]                 old_names <- names(...future.oldEnvVars)
[17:47:33.896]                 envs <- base::Sys.getenv()
[17:47:33.896]                 names <- names(envs)
[17:47:33.896]                 common <- intersect(names, old_names)
[17:47:33.896]                 added <- setdiff(names, old_names)
[17:47:33.896]                 removed <- setdiff(old_names, names)
[17:47:33.896]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:33.896]                   envs[common]]
[17:47:33.896]                 NAMES <- toupper(changed)
[17:47:33.896]                 args <- list()
[17:47:33.896]                 for (kk in seq_along(NAMES)) {
[17:47:33.896]                   name <- changed[[kk]]
[17:47:33.896]                   NAME <- NAMES[[kk]]
[17:47:33.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.896]                     next
[17:47:33.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.896]                 }
[17:47:33.896]                 NAMES <- toupper(added)
[17:47:33.896]                 for (kk in seq_along(NAMES)) {
[17:47:33.896]                   name <- added[[kk]]
[17:47:33.896]                   NAME <- NAMES[[kk]]
[17:47:33.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.896]                     next
[17:47:33.896]                   args[[name]] <- ""
[17:47:33.896]                 }
[17:47:33.896]                 NAMES <- toupper(removed)
[17:47:33.896]                 for (kk in seq_along(NAMES)) {
[17:47:33.896]                   name <- removed[[kk]]
[17:47:33.896]                   NAME <- NAMES[[kk]]
[17:47:33.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:33.896]                     next
[17:47:33.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:33.896]                 }
[17:47:33.896]                 if (length(args) > 0) 
[17:47:33.896]                   base::do.call(base::Sys.setenv, args = args)
[17:47:33.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:33.896]             }
[17:47:33.896]             else {
[17:47:33.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:33.896]             }
[17:47:33.896]             {
[17:47:33.896]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:33.896]                   0L) {
[17:47:33.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:33.896]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:33.896]                   base::options(opts)
[17:47:33.896]                 }
[17:47:33.896]                 {
[17:47:33.896]                   {
[17:47:33.896]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:33.896]                     NULL
[17:47:33.896]                   }
[17:47:33.896]                   options(future.plan = NULL)
[17:47:33.896]                   if (is.na(NA_character_)) 
[17:47:33.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:33.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:33.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:33.896]                     .init = FALSE)
[17:47:33.896]                 }
[17:47:33.896]             }
[17:47:33.896]         }
[17:47:33.896]     })
[17:47:33.896]     if (TRUE) {
[17:47:33.896]         base::sink(type = "output", split = FALSE)
[17:47:33.896]         if (TRUE) {
[17:47:33.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:33.896]         }
[17:47:33.896]         else {
[17:47:33.896]             ...future.result["stdout"] <- base::list(NULL)
[17:47:33.896]         }
[17:47:33.896]         base::close(...future.stdout)
[17:47:33.896]         ...future.stdout <- NULL
[17:47:33.896]     }
[17:47:33.896]     ...future.result$conditions <- ...future.conditions
[17:47:33.896]     ...future.result$finished <- base::Sys.time()
[17:47:33.896]     ...future.result
[17:47:33.896] }
[17:47:33.899] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[17:47:33.900] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[17:47:33.944] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[17:47:33.944] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:47:33.944] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:47:33.944] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[17:47:33.945] MultisessionFuture started
[17:47:33.945] - Launch lazy future ... done
[17:47:33.945] run() for ‘MultisessionFuture’ ... done
[17:47:33.945] result() for ClusterFuture ...
[17:47:33.946] receiveMessageFromWorker() for ClusterFuture ...
[17:47:33.946] - Validating connection of MultisessionFuture
[17:47:34.017] - received message: FutureResult
[17:47:34.017] - Received FutureResult
[17:47:34.017] - Erased future from FutureRegistry
[17:47:34.017] result() for ClusterFuture ...
[17:47:34.017] - result already collected: FutureResult
[17:47:34.017] result() for ClusterFuture ... done
[17:47:34.018] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:34.018] result() for ClusterFuture ... done
[17:47:34.018] result() for ClusterFuture ...
[17:47:34.018] - result already collected: FutureResult
[17:47:34.018] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:47:34.023] getGlobalsAndPackages() ...
[17:47:34.023] Searching for globals...
[17:47:34.025] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:47:34.025] Searching for globals ... DONE
[17:47:34.025] Resolving globals: FALSE
[17:47:34.026] The total size of the 1 globals is 128 bytes (128 bytes)
[17:47:34.026] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:47:34.026] - globals: [1] ‘data’
[17:47:34.026] - packages: [1] ‘future’
[17:47:34.026] getGlobalsAndPackages() ... DONE
[17:47:34.026] run() for ‘Future’ ...
[17:47:34.027] - state: ‘created’
[17:47:34.027] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:34.041] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:34.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:34.041]   - Field: ‘node’
[17:47:34.041]   - Field: ‘label’
[17:47:34.041]   - Field: ‘local’
[17:47:34.042]   - Field: ‘owner’
[17:47:34.042]   - Field: ‘envir’
[17:47:34.042]   - Field: ‘workers’
[17:47:34.042]   - Field: ‘packages’
[17:47:34.042]   - Field: ‘gc’
[17:47:34.042]   - Field: ‘conditions’
[17:47:34.042]   - Field: ‘persistent’
[17:47:34.042]   - Field: ‘expr’
[17:47:34.042]   - Field: ‘uuid’
[17:47:34.042]   - Field: ‘seed’
[17:47:34.042]   - Field: ‘version’
[17:47:34.043]   - Field: ‘result’
[17:47:34.043]   - Field: ‘asynchronous’
[17:47:34.043]   - Field: ‘calls’
[17:47:34.043]   - Field: ‘globals’
[17:47:34.043]   - Field: ‘stdout’
[17:47:34.043]   - Field: ‘earlySignal’
[17:47:34.043]   - Field: ‘lazy’
[17:47:34.043]   - Field: ‘state’
[17:47:34.043] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:34.043] - Launch lazy future ...
[17:47:34.044] Packages needed by the future expression (n = 1): ‘future’
[17:47:34.044] Packages needed by future strategies (n = 1): ‘future’
[17:47:34.044] {
[17:47:34.044]     {
[17:47:34.044]         {
[17:47:34.044]             ...future.startTime <- base::Sys.time()
[17:47:34.044]             {
[17:47:34.044]                 {
[17:47:34.044]                   {
[17:47:34.044]                     {
[17:47:34.044]                       {
[17:47:34.044]                         base::local({
[17:47:34.044]                           has_future <- base::requireNamespace("future", 
[17:47:34.044]                             quietly = TRUE)
[17:47:34.044]                           if (has_future) {
[17:47:34.044]                             ns <- base::getNamespace("future")
[17:47:34.044]                             version <- ns[[".package"]][["version"]]
[17:47:34.044]                             if (is.null(version)) 
[17:47:34.044]                               version <- utils::packageVersion("future")
[17:47:34.044]                           }
[17:47:34.044]                           else {
[17:47:34.044]                             version <- NULL
[17:47:34.044]                           }
[17:47:34.044]                           if (!has_future || version < "1.8.0") {
[17:47:34.044]                             info <- base::c(r_version = base::gsub("R version ", 
[17:47:34.044]                               "", base::R.version$version.string), 
[17:47:34.044]                               platform = base::sprintf("%s (%s-bit)", 
[17:47:34.044]                                 base::R.version$platform, 8 * 
[17:47:34.044]                                   base::.Machine$sizeof.pointer), 
[17:47:34.044]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:34.044]                                 "release", "version")], collapse = " "), 
[17:47:34.044]                               hostname = base::Sys.info()[["nodename"]])
[17:47:34.044]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:47:34.044]                               info)
[17:47:34.044]                             info <- base::paste(info, collapse = "; ")
[17:47:34.044]                             if (!has_future) {
[17:47:34.044]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:34.044]                                 info)
[17:47:34.044]                             }
[17:47:34.044]                             else {
[17:47:34.044]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:34.044]                                 info, version)
[17:47:34.044]                             }
[17:47:34.044]                             base::stop(msg)
[17:47:34.044]                           }
[17:47:34.044]                         })
[17:47:34.044]                       }
[17:47:34.044]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:34.044]                       base::options(mc.cores = 1L)
[17:47:34.044]                     }
[17:47:34.044]                     base::local({
[17:47:34.044]                       for (pkg in "future") {
[17:47:34.044]                         base::loadNamespace(pkg)
[17:47:34.044]                         base::library(pkg, character.only = TRUE)
[17:47:34.044]                       }
[17:47:34.044]                     })
[17:47:34.044]                   }
[17:47:34.044]                   ...future.strategy.old <- future::plan("list")
[17:47:34.044]                   options(future.plan = NULL)
[17:47:34.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:34.044]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:47:34.044]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:47:34.044]                     envir = parent.frame()) 
[17:47:34.044]                   {
[17:47:34.044]                     if (is.function(workers)) 
[17:47:34.044]                       workers <- workers()
[17:47:34.044]                     workers <- structure(as.integer(workers), 
[17:47:34.044]                       class = class(workers))
[17:47:34.044]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:47:34.044]                       workers >= 1)
[17:47:34.044]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:47:34.044]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:47:34.044]                     }
[17:47:34.044]                     future <- MultisessionFuture(..., workers = workers, 
[17:47:34.044]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:47:34.044]                       envir = envir)
[17:47:34.044]                     if (!future$lazy) 
[17:47:34.044]                       future <- run(future)
[17:47:34.044]                     invisible(future)
[17:47:34.044]                   }), .cleanup = FALSE, .init = FALSE)
[17:47:34.044]                 }
[17:47:34.044]                 ...future.workdir <- getwd()
[17:47:34.044]             }
[17:47:34.044]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:34.044]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:34.044]         }
[17:47:34.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:34.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:34.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:34.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:34.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:34.044]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:34.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:34.044]             base::names(...future.oldOptions))
[17:47:34.044]     }
[17:47:34.044]     if (FALSE) {
[17:47:34.044]     }
[17:47:34.044]     else {
[17:47:34.044]         if (TRUE) {
[17:47:34.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:34.044]                 open = "w")
[17:47:34.044]         }
[17:47:34.044]         else {
[17:47:34.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:34.044]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:34.044]         }
[17:47:34.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:34.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:34.044]             base::sink(type = "output", split = FALSE)
[17:47:34.044]             base::close(...future.stdout)
[17:47:34.044]         }, add = TRUE)
[17:47:34.044]     }
[17:47:34.044]     ...future.frame <- base::sys.nframe()
[17:47:34.044]     ...future.conditions <- base::list()
[17:47:34.044]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:34.044]     if (FALSE) {
[17:47:34.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:34.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:34.044]     }
[17:47:34.044]     ...future.result <- base::tryCatch({
[17:47:34.044]         base::withCallingHandlers({
[17:47:34.044]             ...future.value <- base::withVisible(base::local({
[17:47:34.044]                 ...future.makeSendCondition <- base::local({
[17:47:34.044]                   sendCondition <- NULL
[17:47:34.044]                   function(frame = 1L) {
[17:47:34.044]                     if (is.function(sendCondition)) 
[17:47:34.044]                       return(sendCondition)
[17:47:34.044]                     ns <- getNamespace("parallel")
[17:47:34.044]                     if (exists("sendData", mode = "function", 
[17:47:34.044]                       envir = ns)) {
[17:47:34.044]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:34.044]                         envir = ns)
[17:47:34.044]                       envir <- sys.frame(frame)
[17:47:34.044]                       master <- NULL
[17:47:34.044]                       while (!identical(envir, .GlobalEnv) && 
[17:47:34.044]                         !identical(envir, emptyenv())) {
[17:47:34.044]                         if (exists("master", mode = "list", envir = envir, 
[17:47:34.044]                           inherits = FALSE)) {
[17:47:34.044]                           master <- get("master", mode = "list", 
[17:47:34.044]                             envir = envir, inherits = FALSE)
[17:47:34.044]                           if (inherits(master, c("SOCKnode", 
[17:47:34.044]                             "SOCK0node"))) {
[17:47:34.044]                             sendCondition <<- function(cond) {
[17:47:34.044]                               data <- list(type = "VALUE", value = cond, 
[17:47:34.044]                                 success = TRUE)
[17:47:34.044]                               parallel_sendData(master, data)
[17:47:34.044]                             }
[17:47:34.044]                             return(sendCondition)
[17:47:34.044]                           }
[17:47:34.044]                         }
[17:47:34.044]                         frame <- frame + 1L
[17:47:34.044]                         envir <- sys.frame(frame)
[17:47:34.044]                       }
[17:47:34.044]                     }
[17:47:34.044]                     sendCondition <<- function(cond) NULL
[17:47:34.044]                   }
[17:47:34.044]                 })
[17:47:34.044]                 withCallingHandlers({
[17:47:34.044]                   {
[17:47:34.044]                     value(future(subset(data, a == 2)))
[17:47:34.044]                   }
[17:47:34.044]                 }, immediateCondition = function(cond) {
[17:47:34.044]                   sendCondition <- ...future.makeSendCondition()
[17:47:34.044]                   sendCondition(cond)
[17:47:34.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:34.044]                   {
[17:47:34.044]                     inherits <- base::inherits
[17:47:34.044]                     invokeRestart <- base::invokeRestart
[17:47:34.044]                     is.null <- base::is.null
[17:47:34.044]                     muffled <- FALSE
[17:47:34.044]                     if (inherits(cond, "message")) {
[17:47:34.044]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:34.044]                       if (muffled) 
[17:47:34.044]                         invokeRestart("muffleMessage")
[17:47:34.044]                     }
[17:47:34.044]                     else if (inherits(cond, "warning")) {
[17:47:34.044]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:34.044]                       if (muffled) 
[17:47:34.044]                         invokeRestart("muffleWarning")
[17:47:34.044]                     }
[17:47:34.044]                     else if (inherits(cond, "condition")) {
[17:47:34.044]                       if (!is.null(pattern)) {
[17:47:34.044]                         computeRestarts <- base::computeRestarts
[17:47:34.044]                         grepl <- base::grepl
[17:47:34.044]                         restarts <- computeRestarts(cond)
[17:47:34.044]                         for (restart in restarts) {
[17:47:34.044]                           name <- restart$name
[17:47:34.044]                           if (is.null(name)) 
[17:47:34.044]                             next
[17:47:34.044]                           if (!grepl(pattern, name)) 
[17:47:34.044]                             next
[17:47:34.044]                           invokeRestart(restart)
[17:47:34.044]                           muffled <- TRUE
[17:47:34.044]                           break
[17:47:34.044]                         }
[17:47:34.044]                       }
[17:47:34.044]                     }
[17:47:34.044]                     invisible(muffled)
[17:47:34.044]                   }
[17:47:34.044]                   muffleCondition(cond)
[17:47:34.044]                 })
[17:47:34.044]             }))
[17:47:34.044]             future::FutureResult(value = ...future.value$value, 
[17:47:34.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:34.044]                   ...future.rng), globalenv = if (FALSE) 
[17:47:34.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:34.044]                     ...future.globalenv.names))
[17:47:34.044]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:34.044]         }, condition = base::local({
[17:47:34.044]             c <- base::c
[17:47:34.044]             inherits <- base::inherits
[17:47:34.044]             invokeRestart <- base::invokeRestart
[17:47:34.044]             length <- base::length
[17:47:34.044]             list <- base::list
[17:47:34.044]             seq.int <- base::seq.int
[17:47:34.044]             signalCondition <- base::signalCondition
[17:47:34.044]             sys.calls <- base::sys.calls
[17:47:34.044]             `[[` <- base::`[[`
[17:47:34.044]             `+` <- base::`+`
[17:47:34.044]             `<<-` <- base::`<<-`
[17:47:34.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:34.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:34.044]                   3L)]
[17:47:34.044]             }
[17:47:34.044]             function(cond) {
[17:47:34.044]                 is_error <- inherits(cond, "error")
[17:47:34.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:34.044]                   NULL)
[17:47:34.044]                 if (is_error) {
[17:47:34.044]                   sessionInformation <- function() {
[17:47:34.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:34.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:34.044]                       search = base::search(), system = base::Sys.info())
[17:47:34.044]                   }
[17:47:34.044]                   ...future.conditions[[length(...future.conditions) + 
[17:47:34.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:34.044]                     cond$call), session = sessionInformation(), 
[17:47:34.044]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:34.044]                   signalCondition(cond)
[17:47:34.044]                 }
[17:47:34.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:34.044]                 "immediateCondition"))) {
[17:47:34.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:34.044]                   ...future.conditions[[length(...future.conditions) + 
[17:47:34.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:34.044]                   if (TRUE && !signal) {
[17:47:34.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:34.044]                     {
[17:47:34.044]                       inherits <- base::inherits
[17:47:34.044]                       invokeRestart <- base::invokeRestart
[17:47:34.044]                       is.null <- base::is.null
[17:47:34.044]                       muffled <- FALSE
[17:47:34.044]                       if (inherits(cond, "message")) {
[17:47:34.044]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:34.044]                         if (muffled) 
[17:47:34.044]                           invokeRestart("muffleMessage")
[17:47:34.044]                       }
[17:47:34.044]                       else if (inherits(cond, "warning")) {
[17:47:34.044]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:34.044]                         if (muffled) 
[17:47:34.044]                           invokeRestart("muffleWarning")
[17:47:34.044]                       }
[17:47:34.044]                       else if (inherits(cond, "condition")) {
[17:47:34.044]                         if (!is.null(pattern)) {
[17:47:34.044]                           computeRestarts <- base::computeRestarts
[17:47:34.044]                           grepl <- base::grepl
[17:47:34.044]                           restarts <- computeRestarts(cond)
[17:47:34.044]                           for (restart in restarts) {
[17:47:34.044]                             name <- restart$name
[17:47:34.044]                             if (is.null(name)) 
[17:47:34.044]                               next
[17:47:34.044]                             if (!grepl(pattern, name)) 
[17:47:34.044]                               next
[17:47:34.044]                             invokeRestart(restart)
[17:47:34.044]                             muffled <- TRUE
[17:47:34.044]                             break
[17:47:34.044]                           }
[17:47:34.044]                         }
[17:47:34.044]                       }
[17:47:34.044]                       invisible(muffled)
[17:47:34.044]                     }
[17:47:34.044]                     muffleCondition(cond, pattern = "^muffle")
[17:47:34.044]                   }
[17:47:34.044]                 }
[17:47:34.044]                 else {
[17:47:34.044]                   if (TRUE) {
[17:47:34.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:34.044]                     {
[17:47:34.044]                       inherits <- base::inherits
[17:47:34.044]                       invokeRestart <- base::invokeRestart
[17:47:34.044]                       is.null <- base::is.null
[17:47:34.044]                       muffled <- FALSE
[17:47:34.044]                       if (inherits(cond, "message")) {
[17:47:34.044]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:34.044]                         if (muffled) 
[17:47:34.044]                           invokeRestart("muffleMessage")
[17:47:34.044]                       }
[17:47:34.044]                       else if (inherits(cond, "warning")) {
[17:47:34.044]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:34.044]                         if (muffled) 
[17:47:34.044]                           invokeRestart("muffleWarning")
[17:47:34.044]                       }
[17:47:34.044]                       else if (inherits(cond, "condition")) {
[17:47:34.044]                         if (!is.null(pattern)) {
[17:47:34.044]                           computeRestarts <- base::computeRestarts
[17:47:34.044]                           grepl <- base::grepl
[17:47:34.044]                           restarts <- computeRestarts(cond)
[17:47:34.044]                           for (restart in restarts) {
[17:47:34.044]                             name <- restart$name
[17:47:34.044]                             if (is.null(name)) 
[17:47:34.044]                               next
[17:47:34.044]                             if (!grepl(pattern, name)) 
[17:47:34.044]                               next
[17:47:34.044]                             invokeRestart(restart)
[17:47:34.044]                             muffled <- TRUE
[17:47:34.044]                             break
[17:47:34.044]                           }
[17:47:34.044]                         }
[17:47:34.044]                       }
[17:47:34.044]                       invisible(muffled)
[17:47:34.044]                     }
[17:47:34.044]                     muffleCondition(cond, pattern = "^muffle")
[17:47:34.044]                   }
[17:47:34.044]                 }
[17:47:34.044]             }
[17:47:34.044]         }))
[17:47:34.044]     }, error = function(ex) {
[17:47:34.044]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:34.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:34.044]                 ...future.rng), started = ...future.startTime, 
[17:47:34.044]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:34.044]             version = "1.8"), class = "FutureResult")
[17:47:34.044]     }, finally = {
[17:47:34.044]         if (!identical(...future.workdir, getwd())) 
[17:47:34.044]             setwd(...future.workdir)
[17:47:34.044]         {
[17:47:34.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:34.044]                 ...future.oldOptions$nwarnings <- NULL
[17:47:34.044]             }
[17:47:34.044]             base::options(...future.oldOptions)
[17:47:34.044]             if (.Platform$OS.type == "windows") {
[17:47:34.044]                 old_names <- names(...future.oldEnvVars)
[17:47:34.044]                 envs <- base::Sys.getenv()
[17:47:34.044]                 names <- names(envs)
[17:47:34.044]                 common <- intersect(names, old_names)
[17:47:34.044]                 added <- setdiff(names, old_names)
[17:47:34.044]                 removed <- setdiff(old_names, names)
[17:47:34.044]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:34.044]                   envs[common]]
[17:47:34.044]                 NAMES <- toupper(changed)
[17:47:34.044]                 args <- list()
[17:47:34.044]                 for (kk in seq_along(NAMES)) {
[17:47:34.044]                   name <- changed[[kk]]
[17:47:34.044]                   NAME <- NAMES[[kk]]
[17:47:34.044]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:34.044]                     next
[17:47:34.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:34.044]                 }
[17:47:34.044]                 NAMES <- toupper(added)
[17:47:34.044]                 for (kk in seq_along(NAMES)) {
[17:47:34.044]                   name <- added[[kk]]
[17:47:34.044]                   NAME <- NAMES[[kk]]
[17:47:34.044]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:34.044]                     next
[17:47:34.044]                   args[[name]] <- ""
[17:47:34.044]                 }
[17:47:34.044]                 NAMES <- toupper(removed)
[17:47:34.044]                 for (kk in seq_along(NAMES)) {
[17:47:34.044]                   name <- removed[[kk]]
[17:47:34.044]                   NAME <- NAMES[[kk]]
[17:47:34.044]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:34.044]                     next
[17:47:34.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:34.044]                 }
[17:47:34.044]                 if (length(args) > 0) 
[17:47:34.044]                   base::do.call(base::Sys.setenv, args = args)
[17:47:34.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:34.044]             }
[17:47:34.044]             else {
[17:47:34.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:34.044]             }
[17:47:34.044]             {
[17:47:34.044]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:34.044]                   0L) {
[17:47:34.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:34.044]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:34.044]                   base::options(opts)
[17:47:34.044]                 }
[17:47:34.044]                 {
[17:47:34.044]                   {
[17:47:34.044]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:34.044]                     NULL
[17:47:34.044]                   }
[17:47:34.044]                   options(future.plan = NULL)
[17:47:34.044]                   if (is.na(NA_character_)) 
[17:47:34.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:34.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:34.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:34.044]                     .init = FALSE)
[17:47:34.044]                 }
[17:47:34.044]             }
[17:47:34.044]         }
[17:47:34.044]     })
[17:47:34.044]     if (TRUE) {
[17:47:34.044]         base::sink(type = "output", split = FALSE)
[17:47:34.044]         if (TRUE) {
[17:47:34.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:34.044]         }
[17:47:34.044]         else {
[17:47:34.044]             ...future.result["stdout"] <- base::list(NULL)
[17:47:34.044]         }
[17:47:34.044]         base::close(...future.stdout)
[17:47:34.044]         ...future.stdout <- NULL
[17:47:34.044]     }
[17:47:34.044]     ...future.result$conditions <- ...future.conditions
[17:47:34.044]     ...future.result$finished <- base::Sys.time()
[17:47:34.044]     ...future.result
[17:47:34.044] }
[17:47:34.047] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:47:34.047] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:47:34.048] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:47:34.048] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:47:34.049] MultisessionFuture started
[17:47:34.049] - Launch lazy future ... done
[17:47:34.049] run() for ‘MultisessionFuture’ ... done
[17:47:34.049] result() for ClusterFuture ...
[17:47:34.049] receiveMessageFromWorker() for ClusterFuture ...
[17:47:34.049] - Validating connection of MultisessionFuture
[17:47:34.107] - received message: FutureResult
[17:47:34.107] - Received FutureResult
[17:47:34.107] - Erased future from FutureRegistry
[17:47:34.107] result() for ClusterFuture ...
[17:47:34.108] - result already collected: FutureResult
[17:47:34.108] result() for ClusterFuture ... done
[17:47:34.108] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:34.108] result() for ClusterFuture ... done
[17:47:34.108] result() for ClusterFuture ...
[17:47:34.108] - result already collected: FutureResult
[17:47:34.108] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[17:47:34.109] plan(): Setting new future strategy stack:
[17:47:34.109] List of future strategies:
[17:47:34.109] 1. FutureStrategy:
[17:47:34.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:34.109]    - tweaked: FALSE
[17:47:34.109]    - call: future::plan(oplan)
[17:47:34.110] plan(): nbrOfWorkers() = 1
> 
