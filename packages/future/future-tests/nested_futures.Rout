
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:05:33.680] plan(): Setting new future strategy stack:
[18:05:33.681] List of future strategies:
[18:05:33.681] 1. sequential:
[18:05:33.681]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:33.681]    - tweaked: FALSE
[18:05:33.681]    - call: future::plan("sequential")
[18:05:33.705] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[18:05:33.814] plan(): Setting new future strategy stack:
[18:05:33.815] List of future strategies:
[18:05:33.815] 1. sequential:
[18:05:33.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:33.815]    - tweaked: FALSE
[18:05:33.815]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:33.815] 2. sequential:
[18:05:33.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:33.815]    - tweaked: FALSE
[18:05:33.815]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:33.839] plan(): nbrOfWorkers() = 1
[18:05:33.845] getGlobalsAndPackages() ...
[18:05:33.845] Searching for globals...
[18:05:33.890] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:33.890] Searching for globals ... DONE
[18:05:33.891] Resolving globals: FALSE
[18:05:33.894] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[18:05:33.895] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:33.898] - globals: [2] ‘nested’, ‘strategy2’
[18:05:33.898] - packages: [1] ‘future’
[18:05:33.899] getGlobalsAndPackages() ... DONE
[18:05:33.900] run() for ‘Future’ ...
[18:05:33.900] - state: ‘created’
[18:05:33.900] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:33.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:33.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:33.902]   - Field: ‘label’
[18:05:33.902]   - Field: ‘local’
[18:05:33.902]   - Field: ‘owner’
[18:05:33.902]   - Field: ‘envir’
[18:05:33.902]   - Field: ‘packages’
[18:05:33.902]   - Field: ‘gc’
[18:05:33.903]   - Field: ‘conditions’
[18:05:33.903]   - Field: ‘expr’
[18:05:33.903]   - Field: ‘uuid’
[18:05:33.903]   - Field: ‘seed’
[18:05:33.903]   - Field: ‘version’
[18:05:33.904]   - Field: ‘result’
[18:05:33.904]   - Field: ‘asynchronous’
[18:05:33.904]   - Field: ‘calls’
[18:05:33.904]   - Field: ‘globals’
[18:05:33.904]   - Field: ‘stdout’
[18:05:33.905]   - Field: ‘earlySignal’
[18:05:33.905]   - Field: ‘lazy’
[18:05:33.905]   - Field: ‘state’
[18:05:33.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:33.905] - Launch lazy future ...
[18:05:33.907] Packages needed by the future expression (n = 1): ‘future’
[18:05:33.907] Packages needed by future strategies (n = 1): ‘future’
[18:05:33.909] {
[18:05:33.909]     {
[18:05:33.909]         {
[18:05:33.909]             ...future.startTime <- base::Sys.time()
[18:05:33.909]             {
[18:05:33.909]                 {
[18:05:33.909]                   {
[18:05:33.909]                     {
[18:05:33.909]                       base::local({
[18:05:33.909]                         has_future <- base::requireNamespace("future", 
[18:05:33.909]                           quietly = TRUE)
[18:05:33.909]                         if (has_future) {
[18:05:33.909]                           ns <- base::getNamespace("future")
[18:05:33.909]                           version <- ns[[".package"]][["version"]]
[18:05:33.909]                           if (is.null(version)) 
[18:05:33.909]                             version <- utils::packageVersion("future")
[18:05:33.909]                         }
[18:05:33.909]                         else {
[18:05:33.909]                           version <- NULL
[18:05:33.909]                         }
[18:05:33.909]                         if (!has_future || version < "1.8.0") {
[18:05:33.909]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:33.909]                             "", base::R.version$version.string), 
[18:05:33.909]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:33.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:33.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:33.909]                               "release", "version")], collapse = " "), 
[18:05:33.909]                             hostname = base::Sys.info()[["nodename"]])
[18:05:33.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:33.909]                             info)
[18:05:33.909]                           info <- base::paste(info, collapse = "; ")
[18:05:33.909]                           if (!has_future) {
[18:05:33.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:33.909]                               info)
[18:05:33.909]                           }
[18:05:33.909]                           else {
[18:05:33.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:33.909]                               info, version)
[18:05:33.909]                           }
[18:05:33.909]                           base::stop(msg)
[18:05:33.909]                         }
[18:05:33.909]                       })
[18:05:33.909]                     }
[18:05:33.909]                     base::local({
[18:05:33.909]                       for (pkg in "future") {
[18:05:33.909]                         base::loadNamespace(pkg)
[18:05:33.909]                         base::library(pkg, character.only = TRUE)
[18:05:33.909]                       }
[18:05:33.909]                     })
[18:05:33.909]                   }
[18:05:33.909]                   ...future.strategy.old <- future::plan("list")
[18:05:33.909]                   options(future.plan = NULL)
[18:05:33.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:33.909]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:33.909]                   {
[18:05:33.909]                     future <- SequentialFuture(..., envir = envir)
[18:05:33.909]                     if (!future$lazy) 
[18:05:33.909]                       future <- run(future)
[18:05:33.909]                     invisible(future)
[18:05:33.909]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:33.909]                 }
[18:05:33.909]                 ...future.workdir <- getwd()
[18:05:33.909]             }
[18:05:33.909]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:33.909]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:33.909]         }
[18:05:33.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:33.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:33.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:33.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:33.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:33.909]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:33.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:33.909]             base::names(...future.oldOptions))
[18:05:33.909]     }
[18:05:33.909]     if (FALSE) {
[18:05:33.909]     }
[18:05:33.909]     else {
[18:05:33.909]         if (TRUE) {
[18:05:33.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:33.909]                 open = "w")
[18:05:33.909]         }
[18:05:33.909]         else {
[18:05:33.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:33.909]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:33.909]         }
[18:05:33.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:33.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:33.909]             base::sink(type = "output", split = FALSE)
[18:05:33.909]             base::close(...future.stdout)
[18:05:33.909]         }, add = TRUE)
[18:05:33.909]     }
[18:05:33.909]     ...future.frame <- base::sys.nframe()
[18:05:33.909]     ...future.conditions <- base::list()
[18:05:33.909]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:33.909]     if (FALSE) {
[18:05:33.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:33.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:33.909]     }
[18:05:33.909]     ...future.result <- base::tryCatch({
[18:05:33.909]         base::withCallingHandlers({
[18:05:33.909]             ...future.value <- base::withVisible(base::local({
[18:05:33.909]                 a <- 1L
[18:05:33.909]                 plan_a <- unclass(future::plan("list"))
[18:05:33.909]                 nested_a <- nested[-1]
[18:05:33.909]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:33.909]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:33.909]                   strategy2))
[18:05:33.909]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:33.909]                   "init") <- NULL
[18:05:33.909]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:33.909]                   "init") <- NULL
[18:05:33.909]                 stopifnot(all.equal(plan_a, nested_a))
[18:05:33.909]                 y %<-% {
[18:05:33.909]                   b <- 2L
[18:05:33.909]                   plan_b <- future::plan("list")
[18:05:33.909]                   nested_b <- nested_a[-1]
[18:05:33.909]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:33.909]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:33.909]                     "sequential"))
[18:05:33.909]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:33.909]                     b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:33.909]                 }
[18:05:33.909]                 y
[18:05:33.909]             }))
[18:05:33.909]             future::FutureResult(value = ...future.value$value, 
[18:05:33.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:33.909]                   ...future.rng), globalenv = if (FALSE) 
[18:05:33.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:33.909]                     ...future.globalenv.names))
[18:05:33.909]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:33.909]         }, condition = base::local({
[18:05:33.909]             c <- base::c
[18:05:33.909]             inherits <- base::inherits
[18:05:33.909]             invokeRestart <- base::invokeRestart
[18:05:33.909]             length <- base::length
[18:05:33.909]             list <- base::list
[18:05:33.909]             seq.int <- base::seq.int
[18:05:33.909]             signalCondition <- base::signalCondition
[18:05:33.909]             sys.calls <- base::sys.calls
[18:05:33.909]             `[[` <- base::`[[`
[18:05:33.909]             `+` <- base::`+`
[18:05:33.909]             `<<-` <- base::`<<-`
[18:05:33.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:33.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:33.909]                   3L)]
[18:05:33.909]             }
[18:05:33.909]             function(cond) {
[18:05:33.909]                 is_error <- inherits(cond, "error")
[18:05:33.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:33.909]                   NULL)
[18:05:33.909]                 if (is_error) {
[18:05:33.909]                   sessionInformation <- function() {
[18:05:33.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:33.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:33.909]                       search = base::search(), system = base::Sys.info())
[18:05:33.909]                   }
[18:05:33.909]                   ...future.conditions[[length(...future.conditions) + 
[18:05:33.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:33.909]                     cond$call), session = sessionInformation(), 
[18:05:33.909]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:33.909]                   signalCondition(cond)
[18:05:33.909]                 }
[18:05:33.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:33.909]                 "immediateCondition"))) {
[18:05:33.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:33.909]                   ...future.conditions[[length(...future.conditions) + 
[18:05:33.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:33.909]                   if (TRUE && !signal) {
[18:05:33.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:33.909]                     {
[18:05:33.909]                       inherits <- base::inherits
[18:05:33.909]                       invokeRestart <- base::invokeRestart
[18:05:33.909]                       is.null <- base::is.null
[18:05:33.909]                       muffled <- FALSE
[18:05:33.909]                       if (inherits(cond, "message")) {
[18:05:33.909]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:33.909]                         if (muffled) 
[18:05:33.909]                           invokeRestart("muffleMessage")
[18:05:33.909]                       }
[18:05:33.909]                       else if (inherits(cond, "warning")) {
[18:05:33.909]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:33.909]                         if (muffled) 
[18:05:33.909]                           invokeRestart("muffleWarning")
[18:05:33.909]                       }
[18:05:33.909]                       else if (inherits(cond, "condition")) {
[18:05:33.909]                         if (!is.null(pattern)) {
[18:05:33.909]                           computeRestarts <- base::computeRestarts
[18:05:33.909]                           grepl <- base::grepl
[18:05:33.909]                           restarts <- computeRestarts(cond)
[18:05:33.909]                           for (restart in restarts) {
[18:05:33.909]                             name <- restart$name
[18:05:33.909]                             if (is.null(name)) 
[18:05:33.909]                               next
[18:05:33.909]                             if (!grepl(pattern, name)) 
[18:05:33.909]                               next
[18:05:33.909]                             invokeRestart(restart)
[18:05:33.909]                             muffled <- TRUE
[18:05:33.909]                             break
[18:05:33.909]                           }
[18:05:33.909]                         }
[18:05:33.909]                       }
[18:05:33.909]                       invisible(muffled)
[18:05:33.909]                     }
[18:05:33.909]                     muffleCondition(cond, pattern = "^muffle")
[18:05:33.909]                   }
[18:05:33.909]                 }
[18:05:33.909]                 else {
[18:05:33.909]                   if (TRUE) {
[18:05:33.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:33.909]                     {
[18:05:33.909]                       inherits <- base::inherits
[18:05:33.909]                       invokeRestart <- base::invokeRestart
[18:05:33.909]                       is.null <- base::is.null
[18:05:33.909]                       muffled <- FALSE
[18:05:33.909]                       if (inherits(cond, "message")) {
[18:05:33.909]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:33.909]                         if (muffled) 
[18:05:33.909]                           invokeRestart("muffleMessage")
[18:05:33.909]                       }
[18:05:33.909]                       else if (inherits(cond, "warning")) {
[18:05:33.909]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:33.909]                         if (muffled) 
[18:05:33.909]                           invokeRestart("muffleWarning")
[18:05:33.909]                       }
[18:05:33.909]                       else if (inherits(cond, "condition")) {
[18:05:33.909]                         if (!is.null(pattern)) {
[18:05:33.909]                           computeRestarts <- base::computeRestarts
[18:05:33.909]                           grepl <- base::grepl
[18:05:33.909]                           restarts <- computeRestarts(cond)
[18:05:33.909]                           for (restart in restarts) {
[18:05:33.909]                             name <- restart$name
[18:05:33.909]                             if (is.null(name)) 
[18:05:33.909]                               next
[18:05:33.909]                             if (!grepl(pattern, name)) 
[18:05:33.909]                               next
[18:05:33.909]                             invokeRestart(restart)
[18:05:33.909]                             muffled <- TRUE
[18:05:33.909]                             break
[18:05:33.909]                           }
[18:05:33.909]                         }
[18:05:33.909]                       }
[18:05:33.909]                       invisible(muffled)
[18:05:33.909]                     }
[18:05:33.909]                     muffleCondition(cond, pattern = "^muffle")
[18:05:33.909]                   }
[18:05:33.909]                 }
[18:05:33.909]             }
[18:05:33.909]         }))
[18:05:33.909]     }, error = function(ex) {
[18:05:33.909]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:33.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:33.909]                 ...future.rng), started = ...future.startTime, 
[18:05:33.909]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:33.909]             version = "1.8"), class = "FutureResult")
[18:05:33.909]     }, finally = {
[18:05:33.909]         if (!identical(...future.workdir, getwd())) 
[18:05:33.909]             setwd(...future.workdir)
[18:05:33.909]         {
[18:05:33.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:33.909]                 ...future.oldOptions$nwarnings <- NULL
[18:05:33.909]             }
[18:05:33.909]             base::options(...future.oldOptions)
[18:05:33.909]             if (.Platform$OS.type == "windows") {
[18:05:33.909]                 old_names <- names(...future.oldEnvVars)
[18:05:33.909]                 envs <- base::Sys.getenv()
[18:05:33.909]                 names <- names(envs)
[18:05:33.909]                 common <- intersect(names, old_names)
[18:05:33.909]                 added <- setdiff(names, old_names)
[18:05:33.909]                 removed <- setdiff(old_names, names)
[18:05:33.909]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:33.909]                   envs[common]]
[18:05:33.909]                 NAMES <- toupper(changed)
[18:05:33.909]                 args <- list()
[18:05:33.909]                 for (kk in seq_along(NAMES)) {
[18:05:33.909]                   name <- changed[[kk]]
[18:05:33.909]                   NAME <- NAMES[[kk]]
[18:05:33.909]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:33.909]                     next
[18:05:33.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:33.909]                 }
[18:05:33.909]                 NAMES <- toupper(added)
[18:05:33.909]                 for (kk in seq_along(NAMES)) {
[18:05:33.909]                   name <- added[[kk]]
[18:05:33.909]                   NAME <- NAMES[[kk]]
[18:05:33.909]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:33.909]                     next
[18:05:33.909]                   args[[name]] <- ""
[18:05:33.909]                 }
[18:05:33.909]                 NAMES <- toupper(removed)
[18:05:33.909]                 for (kk in seq_along(NAMES)) {
[18:05:33.909]                   name <- removed[[kk]]
[18:05:33.909]                   NAME <- NAMES[[kk]]
[18:05:33.909]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:33.909]                     next
[18:05:33.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:33.909]                 }
[18:05:33.909]                 if (length(args) > 0) 
[18:05:33.909]                   base::do.call(base::Sys.setenv, args = args)
[18:05:33.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:33.909]             }
[18:05:33.909]             else {
[18:05:33.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:33.909]             }
[18:05:33.909]             {
[18:05:33.909]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:33.909]                   0L) {
[18:05:33.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:33.909]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:33.909]                   base::options(opts)
[18:05:33.909]                 }
[18:05:33.909]                 {
[18:05:33.909]                   {
[18:05:33.909]                     NULL
[18:05:33.909]                     RNGkind("Mersenne-Twister")
[18:05:33.909]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:33.909]                       inherits = FALSE)
[18:05:33.909]                   }
[18:05:33.909]                   options(future.plan = NULL)
[18:05:33.909]                   if (is.na(NA_character_)) 
[18:05:33.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:33.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:33.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:33.909]                     .init = FALSE)
[18:05:33.909]                 }
[18:05:33.909]             }
[18:05:33.909]         }
[18:05:33.909]     })
[18:05:33.909]     if (TRUE) {
[18:05:33.909]         base::sink(type = "output", split = FALSE)
[18:05:33.909]         if (TRUE) {
[18:05:33.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:33.909]         }
[18:05:33.909]         else {
[18:05:33.909]             ...future.result["stdout"] <- base::list(NULL)
[18:05:33.909]         }
[18:05:33.909]         base::close(...future.stdout)
[18:05:33.909]         ...future.stdout <- NULL
[18:05:33.909]     }
[18:05:33.909]     ...future.result$conditions <- ...future.conditions
[18:05:33.909]     ...future.result$finished <- base::Sys.time()
[18:05:33.909]     ...future.result
[18:05:33.909] }
[18:05:33.912] assign_globals() ...
[18:05:33.913] List of 2
[18:05:33.913]  $ nested   :List of 2
[18:05:33.913]   ..$ a:function (..., envir = parent.frame())  
[18:05:33.913]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:33.913]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:33.913]   ..$ b:function (..., envir = parent.frame())  
[18:05:33.913]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:33.913]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:33.913]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:33.913]  $ strategy2: chr "sequential"
[18:05:33.913]  - attr(*, "where")=List of 2
[18:05:33.913]   ..$ nested   :<environment: R_EmptyEnv> 
[18:05:33.913]   ..$ strategy2:<environment: R_EmptyEnv> 
[18:05:33.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:33.913]  - attr(*, "resolved")= logi FALSE
[18:05:33.913]  - attr(*, "total_size")= num 23144
[18:05:33.913]  - attr(*, "already-done")= logi TRUE
[18:05:33.926] - copied ‘nested’ to environment
[18:05:33.926] - copied ‘strategy2’ to environment
[18:05:33.926] assign_globals() ... done
[18:05:33.927] plan(): Setting new future strategy stack:
[18:05:33.927] List of future strategies:
[18:05:33.927] 1. sequential:
[18:05:33.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:33.927]    - tweaked: FALSE
[18:05:33.927]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:33.928] plan(): nbrOfWorkers() = 1
[18:05:34.005] plan(): Setting new future strategy stack:
[18:05:34.006] List of future strategies:
[18:05:34.006] 1. sequential:
[18:05:34.006]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.006]    - tweaked: FALSE
[18:05:34.006]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.006] 2. sequential:
[18:05:34.006]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.006]    - tweaked: FALSE
[18:05:34.006]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.007] plan(): nbrOfWorkers() = 1
[18:05:34.007] SequentialFuture started (and completed)
[18:05:34.010] signalConditions() ...
[18:05:34.010]  - include = ‘immediateCondition’
[18:05:34.010]  - exclude = 
[18:05:34.011]  - resignal = FALSE
[18:05:34.011]  - Number of conditions: 54
[18:05:34.011] signalConditions() ... done
[18:05:34.011] - Launch lazy future ... done
[18:05:34.011] run() for ‘SequentialFuture’ ... done
[18:05:34.012] signalConditions() ...
[18:05:34.012]  - include = ‘immediateCondition’
[18:05:34.012]  - exclude = 
[18:05:34.012]  - resignal = FALSE
[18:05:34.012]  - Number of conditions: 54
[18:05:34.013] signalConditions() ... done
[18:05:34.013] Future state: ‘finished’
[18:05:34.013] signalConditions() ...
[18:05:34.013]  - include = ‘condition’
[18:05:34.014]  - exclude = ‘immediateCondition’
[18:05:34.014]  - resignal = TRUE
[18:05:34.014]  - Number of conditions: 54
[18:05:34.014]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.930] getGlobalsAndPackages() ...
[18:05:34.014]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.931] Searching for globals...
[18:05:34.015]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.971] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[18:05:34.015]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.972] Searching for globals ... DONE
[18:05:34.015]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.972] Resolving globals: FALSE
[18:05:34.015]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.974] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[18:05:34.016]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.975] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[18:05:34.016]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.975] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[18:05:34.016]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.975] 
[18:05:34.017]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.975] getGlobalsAndPackages() ... DONE
[18:05:34.017]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.976] run() for ‘Future’ ...
[18:05:34.017]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.976] - state: ‘created’
[18:05:34.017]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.977] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:34.018]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:34.018]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:34.018]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.978]   - Field: ‘label’
[18:05:34.018]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.978]   - Field: ‘local’
[18:05:34.019]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.978]   - Field: ‘owner’
[18:05:34.019]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.978]   - Field: ‘envir’
[18:05:34.019]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.979]   - Field: ‘packages’
[18:05:34.020]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.979]   - Field: ‘gc’
[18:05:34.020]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.979]   - Field: ‘conditions’
[18:05:34.020]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.979]   - Field: ‘expr’
[18:05:34.020]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.979]   - Field: ‘uuid’
[18:05:34.021]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.980]   - Field: ‘seed’
[18:05:34.021]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.980]   - Field: ‘version’
[18:05:34.021]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.980]   - Field: ‘result’
[18:05:34.021]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.980]   - Field: ‘asynchronous’
[18:05:34.022]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.981]   - Field: ‘calls’
[18:05:34.022]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.981]   - Field: ‘globals’
[18:05:34.022]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.981]   - Field: ‘stdout’
[18:05:34.023]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.981]   - Field: ‘earlySignal’
[18:05:34.023]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.981]   - Field: ‘lazy’
[18:05:34.023]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.982]   - Field: ‘state’
[18:05:34.023]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:34.024]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.982] - Launch lazy future ...
[18:05:34.024]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.983] Packages needed by the future expression (n = 0): <none>
[18:05:34.024]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.983] Packages needed by future strategies (n = 0): <none>
[18:05:34.024]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.984] {
[18:05:33.984]     {
[18:05:33.984]         {
[18:05:33.984]             ...future.startTime <- base::Sys.time()
[18:05:33.984]             {
[18:05:33.984]                 {
[18:05:33.984]                   {
[18:05:33.984]                     base::local({
[18:05:33.984]                       has_future <- base::requireNamespace("future", 
[18:05:33.984]                         quietly = TRUE)
[18:05:33.984]                       if (has_future) {
[18:05:33.984]                         ns <- base::getNamespace("future")
[18:05:33.984]                         version <- ns[[".package"]][["version"]]
[18:05:33.984]                         if (is.null(version)) 
[18:05:33.984]                           version <- utils::packageVersion("future")
[18:05:33.984]                       }
[18:05:33.984]                       else {
[18:05:33.984]                         version <- NULL
[18:05:33.984]                       }
[18:05:33.984]                       if (!has_future || version < "1.8.0") {
[18:05:33.984]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:33.984]                           "", base::R.version$version.string), 
[18:05:33.984]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:33.984]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:33.984]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:33.984]                             "release", "version")], collapse = " "), 
[18:05:33.984]                           hostname = base::Sys.info()[["nodename"]])
[18:05:33.984]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:33.984]                           info)
[18:05:33.984]                         info <- base::paste(info, collapse = "; ")
[18:05:33.984]                         if (!has_future) {
[18:05:33.984]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:33.984]                             info)
[18:05:33.984]                         }
[18:05:33.984]                         else {
[18:05:33.984]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:33.984]                             info, version)
[18:05:33.984]                         }
[18:05:33.984]                         base::stop(msg)
[18:05:33.984]                       }
[18:05:33.984]                     })
[18:05:33.984]                   }
[18:05:33.984]                   ...future.strategy.old <- future::plan("list")
[18:05:33.984]                   options(future.plan = NULL)
[18:05:33.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:33.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:33.984]                 }
[18:05:33.984]                 ...future.workdir <- getwd()
[18:05:33.984]             }
[18:05:33.984]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:33.984]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:33.984]         }
[18:05:33.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:33.984]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:33.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:33.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:33.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:33.984]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:33.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:33.984]             base::names(...future.oldOptions))
[18:05:33.984]     }
[18:05:33.984]     if (FALSE) {
[18:05:33.984]     }
[18:05:33.984]     else {
[18:05:33.984]         if (TRUE) {
[18:05:33.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:33.984]                 open = "w")
[18:05:33.984]         }
[18:05:33.984]         else {
[18:05:33.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:33.984]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:33.984]         }
[18:05:33.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:33.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:33.984]             base::sink(type = "output", split = FALSE)
[18:05:33.984]             base::close(...future.stdout)
[18:05:33.984]         }, add = TRUE)
[18:05:33.984]     }
[18:05:33.984]     ...future.frame <- base::sys.nframe()
[18:05:33.984]     ...future.conditions <- base::list()
[18:05:33.984]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:33.984]     if (FALSE) {
[18:05:33.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:33.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:33.984]     }
[18:05:33.984]     ...future.result <- base::tryCatch({
[18:05:33.984]         base::withCallingHandlers({
[18:05:33.984]             ...future.value <- base::withVisible(base::local({
[18:05:33.984]                 b <- 2L
[18:05:33.984]                 plan_b <- future::plan("list")
[18:05:33.984]                 nested_b <- nested_a[-1]
[18:05:33.984]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:33.984]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:33.984]                   "sequential"))
[18:05:33.984]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:33.984]                   b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:33.984]             }))
[18:05:33.984]             future::FutureResult(value = ...future.value$value, 
[18:05:33.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:33.984]                   ...future.rng), globalenv = if (FALSE) 
[18:05:33.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:33.984]                     ...future.globalenv.names))
[18:05:33.984]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:33.984]         }, condition = base::local({
[18:05:33.984]             c <- base::c
[18:05:33.984]             inherits <- base::inherits
[18:05:33.984]             invokeRestart <- base::invokeRestart
[18:05:33.984]             length <- base::length
[18:05:33.984]             list <- base::list
[18:05:33.984]             seq.int <- base::seq.int
[18:05:33.984]             signalCondition <- base::signalCondition
[18:05:33.984]             sys.calls <- base::sys.calls
[18:05:33.984]             `[[` <- base::`[[`
[18:05:33.984]             `+` <- base::`+`
[18:05:33.984]             `<<-` <- base::`<<-`
[18:05:33.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:33.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:33.984]                   3L)]
[18:05:33.984]             }
[18:05:33.984]             function(cond) {
[18:05:33.984]                 is_error <- inherits(cond, "error")
[18:05:33.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:33.984]                   NULL)
[18:05:33.984]                 if (is_error) {
[18:05:33.984]                   sessionInformation <- function() {
[18:05:33.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:33.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:33.984]                       search = base::search(), system = base::Sys.info())
[18:05:33.984]                   }
[18:05:33.984]                   ...future.conditions[[length(...future.conditions) + 
[18:05:33.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:33.984]                     cond$call), session = sessionInformation(), 
[18:05:33.984]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:33.984]                   signalCondition(cond)
[18:05:33.984]                 }
[18:05:33.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:33.984]                 "immediateCondition"))) {
[18:05:33.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:33.984]                   ...future.conditions[[length(...future.conditions) + 
[18:05:33.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:33.984]                   if (TRUE && !signal) {
[18:05:33.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:33.984]                     {
[18:05:33.984]                       inherits <- base::inherits
[18:05:33.984]                       invokeRestart <- base::invokeRestart
[18:05:33.984]                       is.null <- base::is.null
[18:05:33.984]                       muffled <- FALSE
[18:05:33.984]                       if (inherits(cond, "message")) {
[18:05:33.984]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:33.984]                         if (muffled) 
[18:05:33.984]                           invokeRestart("muffleMessage")
[18:05:33.984]                       }
[18:05:33.984]                       else if (inherits(cond, "warning")) {
[18:05:33.984]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:33.984]                         if (muffled) 
[18:05:33.984]                           invokeRestart("muffleWarning")
[18:05:33.984]                       }
[18:05:33.984]                       else if (inherits(cond, "condition")) {
[18:05:33.984]                         if (!is.null(pattern)) {
[18:05:33.984]                           computeRestarts <- base::computeRestarts
[18:05:33.984]                           grepl <- base::grepl
[18:05:33.984]                           restarts <- computeRestarts(cond)
[18:05:33.984]                           for (restart in restarts) {
[18:05:33.984]                             name <- restart$name
[18:05:33.984]                             if (is.null(name)) 
[18:05:33.984]                               next
[18:05:33.984]                             if (!grepl(pattern, name)) 
[18:05:33.984]                               next
[18:05:33.984]                             invokeRestart(restart)
[18:05:33.984]                             muffled <- TRUE
[18:05:33.984]                             break
[18:05:33.984]                           }
[18:05:33.984]                         }
[18:05:33.984]                       }
[18:05:33.984]                       invisible(muffled)
[18:05:33.984]                     }
[18:05:33.984]                     muffleCondition(cond, pattern = "^muffle")
[18:05:33.984]                   }
[18:05:33.984]                 }
[18:05:33.984]                 else {
[18:05:33.984]                   if (TRUE) {
[18:05:33.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:33.984]                     {
[18:05:33.984]                       inherits <- base::inherits
[18:05:33.984]                       invokeRestart <- base::invokeRestart
[18:05:33.984]                       is.null <- base::is.null
[18:05:33.984]                       muffled <- FALSE
[18:05:33.984]                       if (inherits(cond, "message")) {
[18:05:33.984]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:33.984]                         if (muffled) 
[18:05:33.984]                           invokeRestart("muffleMessage")
[18:05:33.984]                       }
[18:05:33.984]                       else if (inherits(cond, "warning")) {
[18:05:33.984]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:33.984]                         if (muffled) 
[18:05:33.984]                           invokeRestart("muffleWarning")
[18:05:33.984]                       }
[18:05:33.984]                       else if (inherits(cond, "condition")) {
[18:05:33.984]                         if (!is.null(pattern)) {
[18:05:33.984]                           computeRestarts <- base::computeRestarts
[18:05:33.984]                           grepl <- base::grepl
[18:05:33.984]                           restarts <- computeRestarts(cond)
[18:05:33.984]                           for (restart in restarts) {
[18:05:33.984]                             name <- restart$name
[18:05:33.984]                             if (is.null(name)) 
[18:05:33.984]                               next
[18:05:33.984]                             if (!grepl(pattern, name)) 
[18:05:33.984]                               next
[18:05:33.984]                             invokeRestart(restart)
[18:05:33.984]                             muffled <- TRUE
[18:05:33.984]                             break
[18:05:33.984]                           }
[18:05:33.984]                         }
[18:05:33.984]                       }
[18:05:33.984]                       invisible(muffled)
[18:05:33.984]                     }
[18:05:33.984]                     muffleCondition(cond, pattern = "^muffle")
[18:05:33.984]                   }
[18:05:33.984]                 }
[18:05:33.984]             }
[18:05:33.984]         }))
[18:05:33.984]     }, error = function(ex) {
[18:05:33.984]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:33.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:33.984]                 ...future.rng), started = ...future.startTime, 
[18:05:33.984]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:33.984]             version = "1.8"), class = "FutureResult")
[18:05:33.984]     }, finally = {
[18:05:33.984]         if (!identical(...future.workdir, getwd())) 
[18:05:33.984]             setwd(...future.workdir)
[18:05:33.984]         {
[18:05:33.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:33.984]                 ...future.oldOptions$nwarnings <- NULL
[18:05:33.984]             }
[18:05:33.984]             base::options(...future.oldOptions)
[18:05:33.984]             if (.Platform$OS.type == "windows") {
[18:05:33.984]                 old_names <- names(...future.oldEnvVars)
[18:05:33.984]                 envs <- base::Sys.getenv()
[18:05:33.984]                 names <- names(envs)
[18:05:33.984]                 common <- intersect(names, old_names)
[18:05:33.984]                 added <- setdiff(names, old_names)
[18:05:33.984]                 removed <- setdiff(old_names, names)
[18:05:33.984]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:33.984]                   envs[common]]
[18:05:33.984]                 NAMES <- toupper(changed)
[18:05:33.984]                 args <- list()
[18:05:33.984]                 for (kk in seq_along(NAMES)) {
[18:05:33.984]                   name <- changed[[kk]]
[18:05:33.984]                   NAME <- NAMES[[kk]]
[18:05:33.984]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:33.984]                     next
[18:05:33.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:33.984]                 }
[18:05:33.984]                 NAMES <- toupper(added)
[18:05:33.984]                 for (kk in seq_along(NAMES)) {
[18:05:33.984]                   name <- added[[kk]]
[18:05:33.984]                   NAME <- NAMES[[kk]]
[18:05:33.984]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:33.984]                     next
[18:05:33.984]                   args[[name]] <- ""
[18:05:33.984]                 }
[18:05:33.984]                 NAMES <- toupper(removed)
[18:05:33.984]                 for (kk in seq_along(NAMES)) {
[18:05:33.984]                   name <- removed[[kk]]
[18:05:33.984]                   NAME <- NAMES[[kk]]
[18:05:33.984]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:33.984]                     next
[18:05:33.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:33.984]                 }
[18:05:33.984]                 if (length(args) > 0) 
[18:05:33.984]                   base::do.call(base::Sys.setenv, args = args)
[18:05:33.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:33.984]             }
[18:05:33.984]             else {
[18:05:33.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:33.984]             }
[18:05:33.984]             {
[18:05:33.984]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:33.984]                   0L) {
[18:05:33.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:33.984]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:33.984]                   base::options(opts)
[18:05:33.984]                 }
[18:05:33.984]                 {
[18:05:33.984]                   {
[18:05:33.984]                     NULL
[18:05:33.984]                     RNGkind("Mersenne-Twister")
[18:05:33.984]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:33.984]                       inherits = FALSE)
[18:05:33.984]                   }
[18:05:33.984]                   options(future.plan = NULL)
[18:05:33.984]                   if (is.na(NA_character_)) 
[18:05:33.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:33.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:33.984]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:33.984]                     .init = FALSE)
[18:05:33.984]                 }
[18:05:33.984]             }
[18:05:33.984]         }
[18:05:33.984]     })
[18:05:33.984]     if (TRUE) {
[18:05:33.984]         base::sink(type = "output", split = FALSE)
[18:05:33.984]         if (TRUE) {
[18:05:33.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:33.984]         }
[18:05:33.984]         else {
[18:05:33.984]             ...future.result["stdout"] <- base::list(NULL)
[18:05:33.984]         }
[18:05:33.984]         base::close(...future.stdout)
[18:05:33.984]         ...future.stdout <- NULL
[18:05:33.984]     }
[18:05:33.984]     ...future.result$conditions <- ...future.conditions
[18:05:33.984]     ...future.result$finished <- base::Sys.time()
[18:05:33.984]     ...future.result
[18:05:33.984] }
[18:05:34.025]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.987] assign_globals() ...
[18:05:34.025]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.987] List of 3
[18:05:33.987]  $ nested_a:List of 1
[18:05:33.987]   ..$ b:function (..., envir = parent.frame())  
[18:05:33.987]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:33.987]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:33.987]  $ a       : int 1
[18:05:33.987]  $ plan_a  :List of 1
[18:05:33.987]   ..$ b:function (..., envir = parent.frame())  
[18:05:33.987]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:33.987]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:33.987]  - attr(*, "where")=List of 3
[18:05:33.987]   ..$ nested_a:<environment: R_EmptyEnv> 
[18:05:33.987]   ..$ a       :<environment: R_EmptyEnv> 
[18:05:33.987]   ..$ plan_a  :<environment: R_EmptyEnv> 
[18:05:33.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:33.987]  - attr(*, "resolved")= logi FALSE
[18:05:33.987]  - attr(*, "total_size")= num 23080
[18:05:33.987]  - attr(*, "already-done")= logi TRUE
[18:05:34.025]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.997] - copied ‘nested_a’ to environment
[18:05:34.026]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.997] - copied ‘a’ to environment
[18:05:34.026]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.997] - copied ‘plan_a’ to environment
[18:05:34.026]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.998] assign_globals() ... done
[18:05:34.026]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.998] plan(): Setting new future strategy stack:
[18:05:34.027]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.998] List of future strategies:
[18:05:33.998] 1. sequential:
[18:05:33.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:33.998]    - tweaked: FALSE
[18:05:33.998]    - call: NULL
[18:05:34.027]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:33.999] plan(): nbrOfWorkers() = 1
[18:05:34.027]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.001] plan(): Setting new future strategy stack:
[18:05:34.028]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.002] List of future strategies:
[18:05:34.002] 1. sequential:
[18:05:34.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.002]    - tweaked: FALSE
[18:05:34.002]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.028]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.003] plan(): nbrOfWorkers() = 1
[18:05:34.028]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.003] SequentialFuture started (and completed)
[18:05:34.028]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.004] - Launch lazy future ... done
[18:05:34.029]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.004] run() for ‘SequentialFuture’ ... done
[18:05:34.029] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:34.039] getGlobalsAndPackages() ...
[18:05:34.039] Searching for globals...
[18:05:34.041] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:34.042] Searching for globals ... DONE
[18:05:34.042] Resolving globals: FALSE
[18:05:34.043] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:34.044] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:34.044] - globals: [1] ‘data’
[18:05:34.044] - packages: [1] ‘future’
[18:05:34.044] getGlobalsAndPackages() ... DONE
[18:05:34.045] run() for ‘Future’ ...
[18:05:34.045] - state: ‘created’
[18:05:34.045] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:34.046] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:34.046] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:34.046]   - Field: ‘label’
[18:05:34.047]   - Field: ‘local’
[18:05:34.047]   - Field: ‘owner’
[18:05:34.047]   - Field: ‘envir’
[18:05:34.047]   - Field: ‘packages’
[18:05:34.047]   - Field: ‘gc’
[18:05:34.047]   - Field: ‘conditions’
[18:05:34.048]   - Field: ‘expr’
[18:05:34.048]   - Field: ‘uuid’
[18:05:34.048]   - Field: ‘seed’
[18:05:34.048]   - Field: ‘version’
[18:05:34.048]   - Field: ‘result’
[18:05:34.049]   - Field: ‘asynchronous’
[18:05:34.049]   - Field: ‘calls’
[18:05:34.049]   - Field: ‘globals’
[18:05:34.049]   - Field: ‘stdout’
[18:05:34.049]   - Field: ‘earlySignal’
[18:05:34.050]   - Field: ‘lazy’
[18:05:34.050]   - Field: ‘state’
[18:05:34.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:34.050] - Launch lazy future ...
[18:05:34.051] Packages needed by the future expression (n = 1): ‘future’
[18:05:34.051] Packages needed by future strategies (n = 1): ‘future’
[18:05:34.052] {
[18:05:34.052]     {
[18:05:34.052]         {
[18:05:34.052]             ...future.startTime <- base::Sys.time()
[18:05:34.052]             {
[18:05:34.052]                 {
[18:05:34.052]                   {
[18:05:34.052]                     {
[18:05:34.052]                       base::local({
[18:05:34.052]                         has_future <- base::requireNamespace("future", 
[18:05:34.052]                           quietly = TRUE)
[18:05:34.052]                         if (has_future) {
[18:05:34.052]                           ns <- base::getNamespace("future")
[18:05:34.052]                           version <- ns[[".package"]][["version"]]
[18:05:34.052]                           if (is.null(version)) 
[18:05:34.052]                             version <- utils::packageVersion("future")
[18:05:34.052]                         }
[18:05:34.052]                         else {
[18:05:34.052]                           version <- NULL
[18:05:34.052]                         }
[18:05:34.052]                         if (!has_future || version < "1.8.0") {
[18:05:34.052]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.052]                             "", base::R.version$version.string), 
[18:05:34.052]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:34.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.052]                               "release", "version")], collapse = " "), 
[18:05:34.052]                             hostname = base::Sys.info()[["nodename"]])
[18:05:34.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.052]                             info)
[18:05:34.052]                           info <- base::paste(info, collapse = "; ")
[18:05:34.052]                           if (!has_future) {
[18:05:34.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.052]                               info)
[18:05:34.052]                           }
[18:05:34.052]                           else {
[18:05:34.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.052]                               info, version)
[18:05:34.052]                           }
[18:05:34.052]                           base::stop(msg)
[18:05:34.052]                         }
[18:05:34.052]                       })
[18:05:34.052]                     }
[18:05:34.052]                     base::local({
[18:05:34.052]                       for (pkg in "future") {
[18:05:34.052]                         base::loadNamespace(pkg)
[18:05:34.052]                         base::library(pkg, character.only = TRUE)
[18:05:34.052]                       }
[18:05:34.052]                     })
[18:05:34.052]                   }
[18:05:34.052]                   ...future.strategy.old <- future::plan("list")
[18:05:34.052]                   options(future.plan = NULL)
[18:05:34.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.052]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:34.052]                   {
[18:05:34.052]                     future <- SequentialFuture(..., envir = envir)
[18:05:34.052]                     if (!future$lazy) 
[18:05:34.052]                       future <- run(future)
[18:05:34.052]                     invisible(future)
[18:05:34.052]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:34.052]                 }
[18:05:34.052]                 ...future.workdir <- getwd()
[18:05:34.052]             }
[18:05:34.052]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.052]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.052]         }
[18:05:34.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.052]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.052]             base::names(...future.oldOptions))
[18:05:34.052]     }
[18:05:34.052]     if (FALSE) {
[18:05:34.052]     }
[18:05:34.052]     else {
[18:05:34.052]         if (TRUE) {
[18:05:34.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.052]                 open = "w")
[18:05:34.052]         }
[18:05:34.052]         else {
[18:05:34.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.052]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.052]         }
[18:05:34.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.052]             base::sink(type = "output", split = FALSE)
[18:05:34.052]             base::close(...future.stdout)
[18:05:34.052]         }, add = TRUE)
[18:05:34.052]     }
[18:05:34.052]     ...future.frame <- base::sys.nframe()
[18:05:34.052]     ...future.conditions <- base::list()
[18:05:34.052]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.052]     if (FALSE) {
[18:05:34.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.052]     }
[18:05:34.052]     ...future.result <- base::tryCatch({
[18:05:34.052]         base::withCallingHandlers({
[18:05:34.052]             ...future.value <- base::withVisible(base::local({
[18:05:34.052]                 value(future(subset(data, a == 2)))
[18:05:34.052]             }))
[18:05:34.052]             future::FutureResult(value = ...future.value$value, 
[18:05:34.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.052]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.052]                     ...future.globalenv.names))
[18:05:34.052]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.052]         }, condition = base::local({
[18:05:34.052]             c <- base::c
[18:05:34.052]             inherits <- base::inherits
[18:05:34.052]             invokeRestart <- base::invokeRestart
[18:05:34.052]             length <- base::length
[18:05:34.052]             list <- base::list
[18:05:34.052]             seq.int <- base::seq.int
[18:05:34.052]             signalCondition <- base::signalCondition
[18:05:34.052]             sys.calls <- base::sys.calls
[18:05:34.052]             `[[` <- base::`[[`
[18:05:34.052]             `+` <- base::`+`
[18:05:34.052]             `<<-` <- base::`<<-`
[18:05:34.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.052]                   3L)]
[18:05:34.052]             }
[18:05:34.052]             function(cond) {
[18:05:34.052]                 is_error <- inherits(cond, "error")
[18:05:34.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.052]                   NULL)
[18:05:34.052]                 if (is_error) {
[18:05:34.052]                   sessionInformation <- function() {
[18:05:34.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.052]                       search = base::search(), system = base::Sys.info())
[18:05:34.052]                   }
[18:05:34.052]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.052]                     cond$call), session = sessionInformation(), 
[18:05:34.052]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.052]                   signalCondition(cond)
[18:05:34.052]                 }
[18:05:34.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.052]                 "immediateCondition"))) {
[18:05:34.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.052]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.052]                   if (TRUE && !signal) {
[18:05:34.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.052]                     {
[18:05:34.052]                       inherits <- base::inherits
[18:05:34.052]                       invokeRestart <- base::invokeRestart
[18:05:34.052]                       is.null <- base::is.null
[18:05:34.052]                       muffled <- FALSE
[18:05:34.052]                       if (inherits(cond, "message")) {
[18:05:34.052]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.052]                         if (muffled) 
[18:05:34.052]                           invokeRestart("muffleMessage")
[18:05:34.052]                       }
[18:05:34.052]                       else if (inherits(cond, "warning")) {
[18:05:34.052]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.052]                         if (muffled) 
[18:05:34.052]                           invokeRestart("muffleWarning")
[18:05:34.052]                       }
[18:05:34.052]                       else if (inherits(cond, "condition")) {
[18:05:34.052]                         if (!is.null(pattern)) {
[18:05:34.052]                           computeRestarts <- base::computeRestarts
[18:05:34.052]                           grepl <- base::grepl
[18:05:34.052]                           restarts <- computeRestarts(cond)
[18:05:34.052]                           for (restart in restarts) {
[18:05:34.052]                             name <- restart$name
[18:05:34.052]                             if (is.null(name)) 
[18:05:34.052]                               next
[18:05:34.052]                             if (!grepl(pattern, name)) 
[18:05:34.052]                               next
[18:05:34.052]                             invokeRestart(restart)
[18:05:34.052]                             muffled <- TRUE
[18:05:34.052]                             break
[18:05:34.052]                           }
[18:05:34.052]                         }
[18:05:34.052]                       }
[18:05:34.052]                       invisible(muffled)
[18:05:34.052]                     }
[18:05:34.052]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.052]                   }
[18:05:34.052]                 }
[18:05:34.052]                 else {
[18:05:34.052]                   if (TRUE) {
[18:05:34.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.052]                     {
[18:05:34.052]                       inherits <- base::inherits
[18:05:34.052]                       invokeRestart <- base::invokeRestart
[18:05:34.052]                       is.null <- base::is.null
[18:05:34.052]                       muffled <- FALSE
[18:05:34.052]                       if (inherits(cond, "message")) {
[18:05:34.052]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.052]                         if (muffled) 
[18:05:34.052]                           invokeRestart("muffleMessage")
[18:05:34.052]                       }
[18:05:34.052]                       else if (inherits(cond, "warning")) {
[18:05:34.052]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.052]                         if (muffled) 
[18:05:34.052]                           invokeRestart("muffleWarning")
[18:05:34.052]                       }
[18:05:34.052]                       else if (inherits(cond, "condition")) {
[18:05:34.052]                         if (!is.null(pattern)) {
[18:05:34.052]                           computeRestarts <- base::computeRestarts
[18:05:34.052]                           grepl <- base::grepl
[18:05:34.052]                           restarts <- computeRestarts(cond)
[18:05:34.052]                           for (restart in restarts) {
[18:05:34.052]                             name <- restart$name
[18:05:34.052]                             if (is.null(name)) 
[18:05:34.052]                               next
[18:05:34.052]                             if (!grepl(pattern, name)) 
[18:05:34.052]                               next
[18:05:34.052]                             invokeRestart(restart)
[18:05:34.052]                             muffled <- TRUE
[18:05:34.052]                             break
[18:05:34.052]                           }
[18:05:34.052]                         }
[18:05:34.052]                       }
[18:05:34.052]                       invisible(muffled)
[18:05:34.052]                     }
[18:05:34.052]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.052]                   }
[18:05:34.052]                 }
[18:05:34.052]             }
[18:05:34.052]         }))
[18:05:34.052]     }, error = function(ex) {
[18:05:34.052]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.052]                 ...future.rng), started = ...future.startTime, 
[18:05:34.052]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.052]             version = "1.8"), class = "FutureResult")
[18:05:34.052]     }, finally = {
[18:05:34.052]         if (!identical(...future.workdir, getwd())) 
[18:05:34.052]             setwd(...future.workdir)
[18:05:34.052]         {
[18:05:34.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.052]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.052]             }
[18:05:34.052]             base::options(...future.oldOptions)
[18:05:34.052]             if (.Platform$OS.type == "windows") {
[18:05:34.052]                 old_names <- names(...future.oldEnvVars)
[18:05:34.052]                 envs <- base::Sys.getenv()
[18:05:34.052]                 names <- names(envs)
[18:05:34.052]                 common <- intersect(names, old_names)
[18:05:34.052]                 added <- setdiff(names, old_names)
[18:05:34.052]                 removed <- setdiff(old_names, names)
[18:05:34.052]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.052]                   envs[common]]
[18:05:34.052]                 NAMES <- toupper(changed)
[18:05:34.052]                 args <- list()
[18:05:34.052]                 for (kk in seq_along(NAMES)) {
[18:05:34.052]                   name <- changed[[kk]]
[18:05:34.052]                   NAME <- NAMES[[kk]]
[18:05:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.052]                     next
[18:05:34.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.052]                 }
[18:05:34.052]                 NAMES <- toupper(added)
[18:05:34.052]                 for (kk in seq_along(NAMES)) {
[18:05:34.052]                   name <- added[[kk]]
[18:05:34.052]                   NAME <- NAMES[[kk]]
[18:05:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.052]                     next
[18:05:34.052]                   args[[name]] <- ""
[18:05:34.052]                 }
[18:05:34.052]                 NAMES <- toupper(removed)
[18:05:34.052]                 for (kk in seq_along(NAMES)) {
[18:05:34.052]                   name <- removed[[kk]]
[18:05:34.052]                   NAME <- NAMES[[kk]]
[18:05:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.052]                     next
[18:05:34.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.052]                 }
[18:05:34.052]                 if (length(args) > 0) 
[18:05:34.052]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.052]             }
[18:05:34.052]             else {
[18:05:34.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.052]             }
[18:05:34.052]             {
[18:05:34.052]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.052]                   0L) {
[18:05:34.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.052]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.052]                   base::options(opts)
[18:05:34.052]                 }
[18:05:34.052]                 {
[18:05:34.052]                   {
[18:05:34.052]                     NULL
[18:05:34.052]                     RNGkind("Mersenne-Twister")
[18:05:34.052]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:34.052]                       inherits = FALSE)
[18:05:34.052]                   }
[18:05:34.052]                   options(future.plan = NULL)
[18:05:34.052]                   if (is.na(NA_character_)) 
[18:05:34.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.052]                     .init = FALSE)
[18:05:34.052]                 }
[18:05:34.052]             }
[18:05:34.052]         }
[18:05:34.052]     })
[18:05:34.052]     if (TRUE) {
[18:05:34.052]         base::sink(type = "output", split = FALSE)
[18:05:34.052]         if (TRUE) {
[18:05:34.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.052]         }
[18:05:34.052]         else {
[18:05:34.052]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.052]         }
[18:05:34.052]         base::close(...future.stdout)
[18:05:34.052]         ...future.stdout <- NULL
[18:05:34.052]     }
[18:05:34.052]     ...future.result$conditions <- ...future.conditions
[18:05:34.052]     ...future.result$finished <- base::Sys.time()
[18:05:34.052]     ...future.result
[18:05:34.052] }
[18:05:34.055] assign_globals() ...
[18:05:34.055] List of 1
[18:05:34.055]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:34.055]   ..$ a: int [1:3] 1 2 3
[18:05:34.055]   ..$ b: int [1:3] 3 2 1
[18:05:34.055]  - attr(*, "where")=List of 1
[18:05:34.055]   ..$ data:<environment: R_EmptyEnv> 
[18:05:34.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.055]  - attr(*, "resolved")= logi FALSE
[18:05:34.055]  - attr(*, "total_size")= num 128
[18:05:34.055]  - attr(*, "already-done")= logi TRUE
[18:05:34.064] - copied ‘data’ to environment
[18:05:34.064] assign_globals() ... done
[18:05:34.065] plan(): Setting new future strategy stack:
[18:05:34.065] List of future strategies:
[18:05:34.065] 1. sequential:
[18:05:34.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.065]    - tweaked: FALSE
[18:05:34.065]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.066] plan(): nbrOfWorkers() = 1
[18:05:34.128] plan(): Setting new future strategy stack:
[18:05:34.129] List of future strategies:
[18:05:34.129] 1. sequential:
[18:05:34.129]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.129]    - tweaked: FALSE
[18:05:34.129]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.129] 2. sequential:
[18:05:34.129]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.129]    - tweaked: FALSE
[18:05:34.129]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.130] plan(): nbrOfWorkers() = 1
[18:05:34.130] SequentialFuture started (and completed)
[18:05:34.131] signalConditions() ...
[18:05:34.131]  - include = ‘immediateCondition’
[18:05:34.131]  - exclude = 
[18:05:34.131]  - resignal = FALSE
[18:05:34.132]  - Number of conditions: 52
[18:05:34.132] signalConditions() ... done
[18:05:34.132] - Launch lazy future ... done
[18:05:34.132] run() for ‘SequentialFuture’ ... done
[18:05:34.133] signalConditions() ...
[18:05:34.133]  - include = ‘immediateCondition’
[18:05:34.133]  - exclude = 
[18:05:34.133]  - resignal = FALSE
[18:05:34.133]  - Number of conditions: 52
[18:05:34.134] signalConditions() ... done
[18:05:34.134] Future state: ‘finished’
[18:05:34.134] signalConditions() ...
[18:05:34.134]  - include = ‘condition’
[18:05:34.135]  - exclude = ‘immediateCondition’
[18:05:34.135]  - resignal = TRUE
[18:05:34.135]  - Number of conditions: 52
[18:05:34.135]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.067] getGlobalsAndPackages() ...
[18:05:34.135]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.068] Searching for globals...
[18:05:34.136]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.098] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:34.136]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.098] Searching for globals ... DONE
[18:05:34.136]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.098] Resolving globals: FALSE
[18:05:34.137]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.099] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:34.137]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.100] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:34.137]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.100] - globals: [1] ‘data’
[18:05:34.137]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.100] 
[18:05:34.138]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.100] getGlobalsAndPackages() ... DONE
[18:05:34.138]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.101] run() for ‘Future’ ...
[18:05:34.138]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.101] - state: ‘created’
[18:05:34.139]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.102] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:34.139]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:34.139]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:34.139]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.103]   - Field: ‘label’
[18:05:34.140]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.103]   - Field: ‘local’
[18:05:34.140]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.103]   - Field: ‘owner’
[18:05:34.140]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.103]   - Field: ‘envir’
[18:05:34.141]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.104]   - Field: ‘packages’
[18:05:34.142]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.104]   - Field: ‘gc’
[18:05:34.142]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.104]   - Field: ‘conditions’
[18:05:34.142]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.104]   - Field: ‘expr’
[18:05:34.143]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.104]   - Field: ‘uuid’
[18:05:34.143]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.105]   - Field: ‘seed’
[18:05:34.143]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.105]   - Field: ‘version’
[18:05:34.144]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.105]   - Field: ‘result’
[18:05:34.144]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.105]   - Field: ‘asynchronous’
[18:05:34.144]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.106]   - Field: ‘calls’
[18:05:34.144]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.106]   - Field: ‘globals’
[18:05:34.145]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.106]   - Field: ‘stdout’
[18:05:34.145]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.106]   - Field: ‘earlySignal’
[18:05:34.145]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.106]   - Field: ‘lazy’
[18:05:34.145]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.107]   - Field: ‘state’
[18:05:34.146]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.107] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:34.146]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.109] - Launch lazy future ...
[18:05:34.146]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.110] Packages needed by the future expression (n = 0): <none>
[18:05:34.147]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.110] Packages needed by future strategies (n = 0): <none>
[18:05:34.147]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.111] {
[18:05:34.111]     {
[18:05:34.111]         {
[18:05:34.111]             ...future.startTime <- base::Sys.time()
[18:05:34.111]             {
[18:05:34.111]                 {
[18:05:34.111]                   {
[18:05:34.111]                     base::local({
[18:05:34.111]                       has_future <- base::requireNamespace("future", 
[18:05:34.111]                         quietly = TRUE)
[18:05:34.111]                       if (has_future) {
[18:05:34.111]                         ns <- base::getNamespace("future")
[18:05:34.111]                         version <- ns[[".package"]][["version"]]
[18:05:34.111]                         if (is.null(version)) 
[18:05:34.111]                           version <- utils::packageVersion("future")
[18:05:34.111]                       }
[18:05:34.111]                       else {
[18:05:34.111]                         version <- NULL
[18:05:34.111]                       }
[18:05:34.111]                       if (!has_future || version < "1.8.0") {
[18:05:34.111]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.111]                           "", base::R.version$version.string), 
[18:05:34.111]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:34.111]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.111]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.111]                             "release", "version")], collapse = " "), 
[18:05:34.111]                           hostname = base::Sys.info()[["nodename"]])
[18:05:34.111]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.111]                           info)
[18:05:34.111]                         info <- base::paste(info, collapse = "; ")
[18:05:34.111]                         if (!has_future) {
[18:05:34.111]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.111]                             info)
[18:05:34.111]                         }
[18:05:34.111]                         else {
[18:05:34.111]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.111]                             info, version)
[18:05:34.111]                         }
[18:05:34.111]                         base::stop(msg)
[18:05:34.111]                       }
[18:05:34.111]                     })
[18:05:34.111]                   }
[18:05:34.111]                   ...future.strategy.old <- future::plan("list")
[18:05:34.111]                   options(future.plan = NULL)
[18:05:34.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:34.111]                 }
[18:05:34.111]                 ...future.workdir <- getwd()
[18:05:34.111]             }
[18:05:34.111]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.111]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.111]         }
[18:05:34.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.111]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.111]             base::names(...future.oldOptions))
[18:05:34.111]     }
[18:05:34.111]     if (FALSE) {
[18:05:34.111]     }
[18:05:34.111]     else {
[18:05:34.111]         if (TRUE) {
[18:05:34.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.111]                 open = "w")
[18:05:34.111]         }
[18:05:34.111]         else {
[18:05:34.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.111]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.111]         }
[18:05:34.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.111]             base::sink(type = "output", split = FALSE)
[18:05:34.111]             base::close(...future.stdout)
[18:05:34.111]         }, add = TRUE)
[18:05:34.111]     }
[18:05:34.111]     ...future.frame <- base::sys.nframe()
[18:05:34.111]     ...future.conditions <- base::list()
[18:05:34.111]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.111]     if (FALSE) {
[18:05:34.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.111]     }
[18:05:34.111]     ...future.result <- base::tryCatch({
[18:05:34.111]         base::withCallingHandlers({
[18:05:34.111]             ...future.value <- base::withVisible(base::local(subset(data, 
[18:05:34.111]                 a == 2)))
[18:05:34.111]             future::FutureResult(value = ...future.value$value, 
[18:05:34.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.111]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.111]                     ...future.globalenv.names))
[18:05:34.111]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.111]         }, condition = base::local({
[18:05:34.111]             c <- base::c
[18:05:34.111]             inherits <- base::inherits
[18:05:34.111]             invokeRestart <- base::invokeRestart
[18:05:34.111]             length <- base::length
[18:05:34.111]             list <- base::list
[18:05:34.111]             seq.int <- base::seq.int
[18:05:34.111]             signalCondition <- base::signalCondition
[18:05:34.111]             sys.calls <- base::sys.calls
[18:05:34.111]             `[[` <- base::`[[`
[18:05:34.111]             `+` <- base::`+`
[18:05:34.111]             `<<-` <- base::`<<-`
[18:05:34.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.111]                   3L)]
[18:05:34.111]             }
[18:05:34.111]             function(cond) {
[18:05:34.111]                 is_error <- inherits(cond, "error")
[18:05:34.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.111]                   NULL)
[18:05:34.111]                 if (is_error) {
[18:05:34.111]                   sessionInformation <- function() {
[18:05:34.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.111]                       search = base::search(), system = base::Sys.info())
[18:05:34.111]                   }
[18:05:34.111]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.111]                     cond$call), session = sessionInformation(), 
[18:05:34.111]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.111]                   signalCondition(cond)
[18:05:34.111]                 }
[18:05:34.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.111]                 "immediateCondition"))) {
[18:05:34.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.111]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.111]                   if (TRUE && !signal) {
[18:05:34.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.111]                     {
[18:05:34.111]                       inherits <- base::inherits
[18:05:34.111]                       invokeRestart <- base::invokeRestart
[18:05:34.111]                       is.null <- base::is.null
[18:05:34.111]                       muffled <- FALSE
[18:05:34.111]                       if (inherits(cond, "message")) {
[18:05:34.111]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.111]                         if (muffled) 
[18:05:34.111]                           invokeRestart("muffleMessage")
[18:05:34.111]                       }
[18:05:34.111]                       else if (inherits(cond, "warning")) {
[18:05:34.111]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.111]                         if (muffled) 
[18:05:34.111]                           invokeRestart("muffleWarning")
[18:05:34.111]                       }
[18:05:34.111]                       else if (inherits(cond, "condition")) {
[18:05:34.111]                         if (!is.null(pattern)) {
[18:05:34.111]                           computeRestarts <- base::computeRestarts
[18:05:34.111]                           grepl <- base::grepl
[18:05:34.111]                           restarts <- computeRestarts(cond)
[18:05:34.111]                           for (restart in restarts) {
[18:05:34.111]                             name <- restart$name
[18:05:34.111]                             if (is.null(name)) 
[18:05:34.111]                               next
[18:05:34.111]                             if (!grepl(pattern, name)) 
[18:05:34.111]                               next
[18:05:34.111]                             invokeRestart(restart)
[18:05:34.111]                             muffled <- TRUE
[18:05:34.111]                             break
[18:05:34.111]                           }
[18:05:34.111]                         }
[18:05:34.111]                       }
[18:05:34.111]                       invisible(muffled)
[18:05:34.111]                     }
[18:05:34.111]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.111]                   }
[18:05:34.111]                 }
[18:05:34.111]                 else {
[18:05:34.111]                   if (TRUE) {
[18:05:34.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.111]                     {
[18:05:34.111]                       inherits <- base::inherits
[18:05:34.111]                       invokeRestart <- base::invokeRestart
[18:05:34.111]                       is.null <- base::is.null
[18:05:34.111]                       muffled <- FALSE
[18:05:34.111]                       if (inherits(cond, "message")) {
[18:05:34.111]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.111]                         if (muffled) 
[18:05:34.111]                           invokeRestart("muffleMessage")
[18:05:34.111]                       }
[18:05:34.111]                       else if (inherits(cond, "warning")) {
[18:05:34.111]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.111]                         if (muffled) 
[18:05:34.111]                           invokeRestart("muffleWarning")
[18:05:34.111]                       }
[18:05:34.111]                       else if (inherits(cond, "condition")) {
[18:05:34.111]                         if (!is.null(pattern)) {
[18:05:34.111]                           computeRestarts <- base::computeRestarts
[18:05:34.111]                           grepl <- base::grepl
[18:05:34.111]                           restarts <- computeRestarts(cond)
[18:05:34.111]                           for (restart in restarts) {
[18:05:34.111]                             name <- restart$name
[18:05:34.111]                             if (is.null(name)) 
[18:05:34.111]                               next
[18:05:34.111]                             if (!grepl(pattern, name)) 
[18:05:34.111]                               next
[18:05:34.111]                             invokeRestart(restart)
[18:05:34.111]                             muffled <- TRUE
[18:05:34.111]                             break
[18:05:34.111]                           }
[18:05:34.111]                         }
[18:05:34.111]                       }
[18:05:34.111]                       invisible(muffled)
[18:05:34.111]                     }
[18:05:34.111]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.111]                   }
[18:05:34.111]                 }
[18:05:34.111]             }
[18:05:34.111]         }))
[18:05:34.111]     }, error = function(ex) {
[18:05:34.111]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.111]                 ...future.rng), started = ...future.startTime, 
[18:05:34.111]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.111]             version = "1.8"), class = "FutureResult")
[18:05:34.111]     }, finally = {
[18:05:34.111]         if (!identical(...future.workdir, getwd())) 
[18:05:34.111]             setwd(...future.workdir)
[18:05:34.111]         {
[18:05:34.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.111]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.111]             }
[18:05:34.111]             base::options(...future.oldOptions)
[18:05:34.111]             if (.Platform$OS.type == "windows") {
[18:05:34.111]                 old_names <- names(...future.oldEnvVars)
[18:05:34.111]                 envs <- base::Sys.getenv()
[18:05:34.111]                 names <- names(envs)
[18:05:34.111]                 common <- intersect(names, old_names)
[18:05:34.111]                 added <- setdiff(names, old_names)
[18:05:34.111]                 removed <- setdiff(old_names, names)
[18:05:34.111]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.111]                   envs[common]]
[18:05:34.111]                 NAMES <- toupper(changed)
[18:05:34.111]                 args <- list()
[18:05:34.111]                 for (kk in seq_along(NAMES)) {
[18:05:34.111]                   name <- changed[[kk]]
[18:05:34.111]                   NAME <- NAMES[[kk]]
[18:05:34.111]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.111]                     next
[18:05:34.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.111]                 }
[18:05:34.111]                 NAMES <- toupper(added)
[18:05:34.111]                 for (kk in seq_along(NAMES)) {
[18:05:34.111]                   name <- added[[kk]]
[18:05:34.111]                   NAME <- NAMES[[kk]]
[18:05:34.111]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.111]                     next
[18:05:34.111]                   args[[name]] <- ""
[18:05:34.111]                 }
[18:05:34.111]                 NAMES <- toupper(removed)
[18:05:34.111]                 for (kk in seq_along(NAMES)) {
[18:05:34.111]                   name <- removed[[kk]]
[18:05:34.111]                   NAME <- NAMES[[kk]]
[18:05:34.111]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.111]                     next
[18:05:34.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.111]                 }
[18:05:34.111]                 if (length(args) > 0) 
[18:05:34.111]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.111]             }
[18:05:34.111]             else {
[18:05:34.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.111]             }
[18:05:34.111]             {
[18:05:34.111]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.111]                   0L) {
[18:05:34.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.111]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.111]                   base::options(opts)
[18:05:34.111]                 }
[18:05:34.111]                 {
[18:05:34.111]                   {
[18:05:34.111]                     NULL
[18:05:34.111]                     RNGkind("Mersenne-Twister")
[18:05:34.111]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:34.111]                       inherits = FALSE)
[18:05:34.111]                   }
[18:05:34.111]                   options(future.plan = NULL)
[18:05:34.111]                   if (is.na(NA_character_)) 
[18:05:34.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.111]                     .init = FALSE)
[18:05:34.111]                 }
[18:05:34.111]             }
[18:05:34.111]         }
[18:05:34.111]     })
[18:05:34.111]     if (TRUE) {
[18:05:34.111]         base::sink(type = "output", split = FALSE)
[18:05:34.111]         if (TRUE) {
[18:05:34.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.111]         }
[18:05:34.111]         else {
[18:05:34.111]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.111]         }
[18:05:34.111]         base::close(...future.stdout)
[18:05:34.111]         ...future.stdout <- NULL
[18:05:34.111]     }
[18:05:34.111]     ...future.result$conditions <- ...future.conditions
[18:05:34.111]     ...future.result$finished <- base::Sys.time()
[18:05:34.111]     ...future.result
[18:05:34.111] }
[18:05:34.147]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.114] assign_globals() ...
[18:05:34.147]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.114] List of 1
[18:05:34.114]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:34.114]   ..$ a: int [1:3] 1 2 3
[18:05:34.114]   ..$ b: int [1:3] 3 2 1
[18:05:34.114]  - attr(*, "where")=List of 1
[18:05:34.114]   ..$ data:<environment: R_EmptyEnv> 
[18:05:34.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.114]  - attr(*, "resolved")= logi FALSE
[18:05:34.114]  - attr(*, "total_size")= num 128
[18:05:34.114]  - attr(*, "already-done")= logi TRUE
[18:05:34.148]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.121] - copied ‘data’ to environment
[18:05:34.148]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.121] assign_globals() ... done
[18:05:34.148]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.122] plan(): Setting new future strategy stack:
[18:05:34.149]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.122] List of future strategies:
[18:05:34.122] 1. sequential:
[18:05:34.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.122]    - tweaked: FALSE
[18:05:34.122]    - call: NULL
[18:05:34.149]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.123] plan(): nbrOfWorkers() = 1
[18:05:34.149]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.125] plan(): Setting new future strategy stack:
[18:05:34.149]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.125] List of future strategies:
[18:05:34.125] 1. sequential:
[18:05:34.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.125]    - tweaked: FALSE
[18:05:34.125]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.150]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.126] plan(): nbrOfWorkers() = 1
[18:05:34.150]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.127] SequentialFuture started (and completed)
[18:05:34.150]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.127] - Launch lazy future ... done
[18:05:34.150]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.127] run() for ‘SequentialFuture’ ... done
[18:05:34.151] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[18:05:34.152] plan(): Setting new future strategy stack:
[18:05:34.152] List of future strategies:
[18:05:34.152] 1. sequential:
[18:05:34.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.152]    - tweaked: FALSE
[18:05:34.152]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.152] 2. multicore:
[18:05:34.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:34.152]    - tweaked: FALSE
[18:05:34.152]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.153] plan(): nbrOfWorkers() = 1
[18:05:34.154] getGlobalsAndPackages() ...
[18:05:34.154] Searching for globals...
[18:05:34.191] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:34.191] Searching for globals ... DONE
[18:05:34.191] Resolving globals: FALSE
[18:05:34.193] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[18:05:34.194] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:34.194] - globals: [2] ‘nested’, ‘strategy2’
[18:05:34.195] - packages: [1] ‘future’
[18:05:34.195] getGlobalsAndPackages() ... DONE
[18:05:34.195] run() for ‘Future’ ...
[18:05:34.196] - state: ‘created’
[18:05:34.196] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:34.196] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:34.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:34.197]   - Field: ‘label’
[18:05:34.197]   - Field: ‘local’
[18:05:34.197]   - Field: ‘owner’
[18:05:34.197]   - Field: ‘envir’
[18:05:34.198]   - Field: ‘packages’
[18:05:34.198]   - Field: ‘gc’
[18:05:34.198]   - Field: ‘conditions’
[18:05:34.198]   - Field: ‘expr’
[18:05:34.198]   - Field: ‘uuid’
[18:05:34.199]   - Field: ‘seed’
[18:05:34.199]   - Field: ‘version’
[18:05:34.199]   - Field: ‘result’
[18:05:34.199]   - Field: ‘asynchronous’
[18:05:34.199]   - Field: ‘calls’
[18:05:34.200]   - Field: ‘globals’
[18:05:34.200]   - Field: ‘stdout’
[18:05:34.200]   - Field: ‘earlySignal’
[18:05:34.200]   - Field: ‘lazy’
[18:05:34.200]   - Field: ‘state’
[18:05:34.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:34.201] - Launch lazy future ...
[18:05:34.201] Packages needed by the future expression (n = 1): ‘future’
[18:05:34.201] Packages needed by future strategies (n = 1): ‘future’
[18:05:34.204] {
[18:05:34.204]     {
[18:05:34.204]         {
[18:05:34.204]             ...future.startTime <- base::Sys.time()
[18:05:34.204]             {
[18:05:34.204]                 {
[18:05:34.204]                   {
[18:05:34.204]                     {
[18:05:34.204]                       base::local({
[18:05:34.204]                         has_future <- base::requireNamespace("future", 
[18:05:34.204]                           quietly = TRUE)
[18:05:34.204]                         if (has_future) {
[18:05:34.204]                           ns <- base::getNamespace("future")
[18:05:34.204]                           version <- ns[[".package"]][["version"]]
[18:05:34.204]                           if (is.null(version)) 
[18:05:34.204]                             version <- utils::packageVersion("future")
[18:05:34.204]                         }
[18:05:34.204]                         else {
[18:05:34.204]                           version <- NULL
[18:05:34.204]                         }
[18:05:34.204]                         if (!has_future || version < "1.8.0") {
[18:05:34.204]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.204]                             "", base::R.version$version.string), 
[18:05:34.204]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:34.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.204]                               "release", "version")], collapse = " "), 
[18:05:34.204]                             hostname = base::Sys.info()[["nodename"]])
[18:05:34.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.204]                             info)
[18:05:34.204]                           info <- base::paste(info, collapse = "; ")
[18:05:34.204]                           if (!has_future) {
[18:05:34.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.204]                               info)
[18:05:34.204]                           }
[18:05:34.204]                           else {
[18:05:34.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.204]                               info, version)
[18:05:34.204]                           }
[18:05:34.204]                           base::stop(msg)
[18:05:34.204]                         }
[18:05:34.204]                       })
[18:05:34.204]                     }
[18:05:34.204]                     base::local({
[18:05:34.204]                       for (pkg in "future") {
[18:05:34.204]                         base::loadNamespace(pkg)
[18:05:34.204]                         base::library(pkg, character.only = TRUE)
[18:05:34.204]                       }
[18:05:34.204]                     })
[18:05:34.204]                   }
[18:05:34.204]                   ...future.strategy.old <- future::plan("list")
[18:05:34.204]                   options(future.plan = NULL)
[18:05:34.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.204]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:34.204]                     envir = parent.frame()) 
[18:05:34.204]                   {
[18:05:34.204]                     default_workers <- missing(workers)
[18:05:34.204]                     if (is.function(workers)) 
[18:05:34.204]                       workers <- workers()
[18:05:34.204]                     workers <- structure(as.integer(workers), 
[18:05:34.204]                       class = class(workers))
[18:05:34.204]                     stop_if_not(is.finite(workers), workers >= 
[18:05:34.204]                       1L)
[18:05:34.204]                     if ((workers == 1L && !inherits(workers, 
[18:05:34.204]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:34.204]                       if (default_workers) 
[18:05:34.204]                         supportsMulticore(warn = TRUE)
[18:05:34.204]                       return(sequential(..., envir = envir))
[18:05:34.204]                     }
[18:05:34.204]                     oopts <- options(mc.cores = workers)
[18:05:34.204]                     on.exit(options(oopts))
[18:05:34.204]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:34.204]                       envir = envir)
[18:05:34.204]                     if (!future$lazy) 
[18:05:34.204]                       future <- run(future)
[18:05:34.204]                     invisible(future)
[18:05:34.204]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:34.204]                 }
[18:05:34.204]                 ...future.workdir <- getwd()
[18:05:34.204]             }
[18:05:34.204]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.204]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.204]         }
[18:05:34.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.204]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.204]             base::names(...future.oldOptions))
[18:05:34.204]     }
[18:05:34.204]     if (FALSE) {
[18:05:34.204]     }
[18:05:34.204]     else {
[18:05:34.204]         if (TRUE) {
[18:05:34.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.204]                 open = "w")
[18:05:34.204]         }
[18:05:34.204]         else {
[18:05:34.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.204]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.204]         }
[18:05:34.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.204]             base::sink(type = "output", split = FALSE)
[18:05:34.204]             base::close(...future.stdout)
[18:05:34.204]         }, add = TRUE)
[18:05:34.204]     }
[18:05:34.204]     ...future.frame <- base::sys.nframe()
[18:05:34.204]     ...future.conditions <- base::list()
[18:05:34.204]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.204]     if (FALSE) {
[18:05:34.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.204]     }
[18:05:34.204]     ...future.result <- base::tryCatch({
[18:05:34.204]         base::withCallingHandlers({
[18:05:34.204]             ...future.value <- base::withVisible(base::local({
[18:05:34.204]                 a <- 1L
[18:05:34.204]                 plan_a <- unclass(future::plan("list"))
[18:05:34.204]                 nested_a <- nested[-1]
[18:05:34.204]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:34.204]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:34.204]                   strategy2))
[18:05:34.204]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:34.204]                   "init") <- NULL
[18:05:34.204]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:34.204]                   "init") <- NULL
[18:05:34.204]                 stopifnot(all.equal(plan_a, nested_a))
[18:05:34.204]                 y %<-% {
[18:05:34.204]                   b <- 2L
[18:05:34.204]                   plan_b <- future::plan("list")
[18:05:34.204]                   nested_b <- nested_a[-1]
[18:05:34.204]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:34.204]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:34.204]                     "sequential"))
[18:05:34.204]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:34.204]                     b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:34.204]                 }
[18:05:34.204]                 y
[18:05:34.204]             }))
[18:05:34.204]             future::FutureResult(value = ...future.value$value, 
[18:05:34.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.204]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.204]                     ...future.globalenv.names))
[18:05:34.204]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.204]         }, condition = base::local({
[18:05:34.204]             c <- base::c
[18:05:34.204]             inherits <- base::inherits
[18:05:34.204]             invokeRestart <- base::invokeRestart
[18:05:34.204]             length <- base::length
[18:05:34.204]             list <- base::list
[18:05:34.204]             seq.int <- base::seq.int
[18:05:34.204]             signalCondition <- base::signalCondition
[18:05:34.204]             sys.calls <- base::sys.calls
[18:05:34.204]             `[[` <- base::`[[`
[18:05:34.204]             `+` <- base::`+`
[18:05:34.204]             `<<-` <- base::`<<-`
[18:05:34.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.204]                   3L)]
[18:05:34.204]             }
[18:05:34.204]             function(cond) {
[18:05:34.204]                 is_error <- inherits(cond, "error")
[18:05:34.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.204]                   NULL)
[18:05:34.204]                 if (is_error) {
[18:05:34.204]                   sessionInformation <- function() {
[18:05:34.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.204]                       search = base::search(), system = base::Sys.info())
[18:05:34.204]                   }
[18:05:34.204]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.204]                     cond$call), session = sessionInformation(), 
[18:05:34.204]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.204]                   signalCondition(cond)
[18:05:34.204]                 }
[18:05:34.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.204]                 "immediateCondition"))) {
[18:05:34.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.204]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.204]                   if (TRUE && !signal) {
[18:05:34.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.204]                     {
[18:05:34.204]                       inherits <- base::inherits
[18:05:34.204]                       invokeRestart <- base::invokeRestart
[18:05:34.204]                       is.null <- base::is.null
[18:05:34.204]                       muffled <- FALSE
[18:05:34.204]                       if (inherits(cond, "message")) {
[18:05:34.204]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.204]                         if (muffled) 
[18:05:34.204]                           invokeRestart("muffleMessage")
[18:05:34.204]                       }
[18:05:34.204]                       else if (inherits(cond, "warning")) {
[18:05:34.204]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.204]                         if (muffled) 
[18:05:34.204]                           invokeRestart("muffleWarning")
[18:05:34.204]                       }
[18:05:34.204]                       else if (inherits(cond, "condition")) {
[18:05:34.204]                         if (!is.null(pattern)) {
[18:05:34.204]                           computeRestarts <- base::computeRestarts
[18:05:34.204]                           grepl <- base::grepl
[18:05:34.204]                           restarts <- computeRestarts(cond)
[18:05:34.204]                           for (restart in restarts) {
[18:05:34.204]                             name <- restart$name
[18:05:34.204]                             if (is.null(name)) 
[18:05:34.204]                               next
[18:05:34.204]                             if (!grepl(pattern, name)) 
[18:05:34.204]                               next
[18:05:34.204]                             invokeRestart(restart)
[18:05:34.204]                             muffled <- TRUE
[18:05:34.204]                             break
[18:05:34.204]                           }
[18:05:34.204]                         }
[18:05:34.204]                       }
[18:05:34.204]                       invisible(muffled)
[18:05:34.204]                     }
[18:05:34.204]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.204]                   }
[18:05:34.204]                 }
[18:05:34.204]                 else {
[18:05:34.204]                   if (TRUE) {
[18:05:34.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.204]                     {
[18:05:34.204]                       inherits <- base::inherits
[18:05:34.204]                       invokeRestart <- base::invokeRestart
[18:05:34.204]                       is.null <- base::is.null
[18:05:34.204]                       muffled <- FALSE
[18:05:34.204]                       if (inherits(cond, "message")) {
[18:05:34.204]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.204]                         if (muffled) 
[18:05:34.204]                           invokeRestart("muffleMessage")
[18:05:34.204]                       }
[18:05:34.204]                       else if (inherits(cond, "warning")) {
[18:05:34.204]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.204]                         if (muffled) 
[18:05:34.204]                           invokeRestart("muffleWarning")
[18:05:34.204]                       }
[18:05:34.204]                       else if (inherits(cond, "condition")) {
[18:05:34.204]                         if (!is.null(pattern)) {
[18:05:34.204]                           computeRestarts <- base::computeRestarts
[18:05:34.204]                           grepl <- base::grepl
[18:05:34.204]                           restarts <- computeRestarts(cond)
[18:05:34.204]                           for (restart in restarts) {
[18:05:34.204]                             name <- restart$name
[18:05:34.204]                             if (is.null(name)) 
[18:05:34.204]                               next
[18:05:34.204]                             if (!grepl(pattern, name)) 
[18:05:34.204]                               next
[18:05:34.204]                             invokeRestart(restart)
[18:05:34.204]                             muffled <- TRUE
[18:05:34.204]                             break
[18:05:34.204]                           }
[18:05:34.204]                         }
[18:05:34.204]                       }
[18:05:34.204]                       invisible(muffled)
[18:05:34.204]                     }
[18:05:34.204]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.204]                   }
[18:05:34.204]                 }
[18:05:34.204]             }
[18:05:34.204]         }))
[18:05:34.204]     }, error = function(ex) {
[18:05:34.204]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.204]                 ...future.rng), started = ...future.startTime, 
[18:05:34.204]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.204]             version = "1.8"), class = "FutureResult")
[18:05:34.204]     }, finally = {
[18:05:34.204]         if (!identical(...future.workdir, getwd())) 
[18:05:34.204]             setwd(...future.workdir)
[18:05:34.204]         {
[18:05:34.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.204]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.204]             }
[18:05:34.204]             base::options(...future.oldOptions)
[18:05:34.204]             if (.Platform$OS.type == "windows") {
[18:05:34.204]                 old_names <- names(...future.oldEnvVars)
[18:05:34.204]                 envs <- base::Sys.getenv()
[18:05:34.204]                 names <- names(envs)
[18:05:34.204]                 common <- intersect(names, old_names)
[18:05:34.204]                 added <- setdiff(names, old_names)
[18:05:34.204]                 removed <- setdiff(old_names, names)
[18:05:34.204]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.204]                   envs[common]]
[18:05:34.204]                 NAMES <- toupper(changed)
[18:05:34.204]                 args <- list()
[18:05:34.204]                 for (kk in seq_along(NAMES)) {
[18:05:34.204]                   name <- changed[[kk]]
[18:05:34.204]                   NAME <- NAMES[[kk]]
[18:05:34.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.204]                     next
[18:05:34.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.204]                 }
[18:05:34.204]                 NAMES <- toupper(added)
[18:05:34.204]                 for (kk in seq_along(NAMES)) {
[18:05:34.204]                   name <- added[[kk]]
[18:05:34.204]                   NAME <- NAMES[[kk]]
[18:05:34.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.204]                     next
[18:05:34.204]                   args[[name]] <- ""
[18:05:34.204]                 }
[18:05:34.204]                 NAMES <- toupper(removed)
[18:05:34.204]                 for (kk in seq_along(NAMES)) {
[18:05:34.204]                   name <- removed[[kk]]
[18:05:34.204]                   NAME <- NAMES[[kk]]
[18:05:34.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.204]                     next
[18:05:34.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.204]                 }
[18:05:34.204]                 if (length(args) > 0) 
[18:05:34.204]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.204]             }
[18:05:34.204]             else {
[18:05:34.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.204]             }
[18:05:34.204]             {
[18:05:34.204]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.204]                   0L) {
[18:05:34.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.204]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.204]                   base::options(opts)
[18:05:34.204]                 }
[18:05:34.204]                 {
[18:05:34.204]                   {
[18:05:34.204]                     NULL
[18:05:34.204]                     RNGkind("Mersenne-Twister")
[18:05:34.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:34.204]                       inherits = FALSE)
[18:05:34.204]                   }
[18:05:34.204]                   options(future.plan = NULL)
[18:05:34.204]                   if (is.na(NA_character_)) 
[18:05:34.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.204]                     .init = FALSE)
[18:05:34.204]                 }
[18:05:34.204]             }
[18:05:34.204]         }
[18:05:34.204]     })
[18:05:34.204]     if (TRUE) {
[18:05:34.204]         base::sink(type = "output", split = FALSE)
[18:05:34.204]         if (TRUE) {
[18:05:34.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.204]         }
[18:05:34.204]         else {
[18:05:34.204]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.204]         }
[18:05:34.204]         base::close(...future.stdout)
[18:05:34.204]         ...future.stdout <- NULL
[18:05:34.204]     }
[18:05:34.204]     ...future.result$conditions <- ...future.conditions
[18:05:34.204]     ...future.result$finished <- base::Sys.time()
[18:05:34.204]     ...future.result
[18:05:34.204] }
[18:05:34.208] assign_globals() ...
[18:05:34.208] List of 2
[18:05:34.208]  $ nested   :List of 2
[18:05:34.208]   ..$ a:function (..., envir = parent.frame())  
[18:05:34.208]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:34.208]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:34.208]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:34.208]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:34.208]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:34.208]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:34.208]  $ strategy2: chr "multicore"
[18:05:34.208]  - attr(*, "where")=List of 2
[18:05:34.208]   ..$ nested   :<environment: R_EmptyEnv> 
[18:05:34.208]   ..$ strategy2:<environment: R_EmptyEnv> 
[18:05:34.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.208]  - attr(*, "resolved")= logi FALSE
[18:05:34.208]  - attr(*, "total_size")= num 59224
[18:05:34.208]  - attr(*, "already-done")= logi TRUE
[18:05:34.217] - copied ‘nested’ to environment
[18:05:34.218] - copied ‘strategy2’ to environment
[18:05:34.218] assign_globals() ... done
[18:05:34.219] plan(): Setting new future strategy stack:
[18:05:34.219] List of future strategies:
[18:05:34.219] 1. multicore:
[18:05:34.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:34.219]    - tweaked: FALSE
[18:05:34.219]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.225] plan(): nbrOfWorkers() = 2
[18:05:34.355] plan(): Setting new future strategy stack:
[18:05:34.355] List of future strategies:
[18:05:34.355] 1. sequential:
[18:05:34.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.355]    - tweaked: FALSE
[18:05:34.355]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.355] 2. multicore:
[18:05:34.355]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:34.355]    - tweaked: FALSE
[18:05:34.355]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.357] plan(): nbrOfWorkers() = 1
[18:05:34.357] SequentialFuture started (and completed)
[18:05:34.358] signalConditions() ...
[18:05:34.358]  - include = ‘immediateCondition’
[18:05:34.358]  - exclude = 
[18:05:34.358]  - resignal = FALSE
[18:05:34.359]  - Number of conditions: 57
[18:05:34.359] signalConditions() ... done
[18:05:34.359] - Launch lazy future ... done
[18:05:34.360] run() for ‘SequentialFuture’ ... done
[18:05:34.360] signalConditions() ...
[18:05:34.360]  - include = ‘immediateCondition’
[18:05:34.360]  - exclude = 
[18:05:34.361]  - resignal = FALSE
[18:05:34.361]  - Number of conditions: 57
[18:05:34.361] signalConditions() ... done
[18:05:34.362] Future state: ‘finished’
[18:05:34.362] signalConditions() ...
[18:05:34.362]  - include = ‘condition’
[18:05:34.362]  - exclude = ‘immediateCondition’
[18:05:34.362]  - resignal = TRUE
[18:05:34.363]  - Number of conditions: 57
[18:05:34.363]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.227] getGlobalsAndPackages() ...
[18:05:34.363]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.227] Searching for globals...
[18:05:34.364]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.267] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[18:05:34.364]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.267] Searching for globals ... DONE
[18:05:34.364]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.268] Resolving globals: FALSE
[18:05:34.365]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.269] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[18:05:34.365]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.270] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[18:05:34.365]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.270] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[18:05:34.366]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.270] 
[18:05:34.366]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.271] getGlobalsAndPackages() ... DONE
[18:05:34.366]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.271] run() for ‘Future’ ...
[18:05:34.367]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.271] - state: ‘created’
[18:05:34.367]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.272] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:34.367]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.278] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:34.368]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:34.368]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.279]   - Field: ‘label’
[18:05:34.368]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.279]   - Field: ‘local’
[18:05:34.369]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.279]   - Field: ‘owner’
[18:05:34.369]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.280]   - Field: ‘envir’
[18:05:34.369]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.280]   - Field: ‘workers’
[18:05:34.370]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.280]   - Field: ‘packages’
[18:05:34.370]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.280]   - Field: ‘gc’
[18:05:34.370]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.281]   - Field: ‘job’
[18:05:34.371]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.281]   - Field: ‘conditions’
[18:05:34.371]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.281]   - Field: ‘expr’
[18:05:34.371]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.281]   - Field: ‘uuid’
[18:05:34.372]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.282]   - Field: ‘seed’
[18:05:34.372]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.282]   - Field: ‘version’
[18:05:34.372]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.282]   - Field: ‘result’
[18:05:34.373]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.282]   - Field: ‘asynchronous’
[18:05:34.373]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.282]   - Field: ‘calls’
[18:05:34.373]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.283]   - Field: ‘globals’
[18:05:34.374]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.283]   - Field: ‘stdout’
[18:05:34.374]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.283]   - Field: ‘earlySignal’
[18:05:34.374]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.283]   - Field: ‘lazy’
[18:05:34.375]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.284]   - Field: ‘state’
[18:05:34.375]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:34.375]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.284] - Launch lazy future ...
[18:05:34.375]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.286] Packages needed by the future expression (n = 0): <none>
[18:05:34.376]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.286] Packages needed by future strategies (n = 0): <none>
[18:05:34.376]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.287] {
[18:05:34.287]     {
[18:05:34.287]         {
[18:05:34.287]             ...future.startTime <- base::Sys.time()
[18:05:34.287]             {
[18:05:34.287]                 {
[18:05:34.287]                   {
[18:05:34.287]                     {
[18:05:34.287]                       base::local({
[18:05:34.287]                         has_future <- base::requireNamespace("future", 
[18:05:34.287]                           quietly = TRUE)
[18:05:34.287]                         if (has_future) {
[18:05:34.287]                           ns <- base::getNamespace("future")
[18:05:34.287]                           version <- ns[[".package"]][["version"]]
[18:05:34.287]                           if (is.null(version)) 
[18:05:34.287]                             version <- utils::packageVersion("future")
[18:05:34.287]                         }
[18:05:34.287]                         else {
[18:05:34.287]                           version <- NULL
[18:05:34.287]                         }
[18:05:34.287]                         if (!has_future || version < "1.8.0") {
[18:05:34.287]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.287]                             "", base::R.version$version.string), 
[18:05:34.287]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:34.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.287]                               "release", "version")], collapse = " "), 
[18:05:34.287]                             hostname = base::Sys.info()[["nodename"]])
[18:05:34.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.287]                             info)
[18:05:34.287]                           info <- base::paste(info, collapse = "; ")
[18:05:34.287]                           if (!has_future) {
[18:05:34.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.287]                               info)
[18:05:34.287]                           }
[18:05:34.287]                           else {
[18:05:34.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.287]                               info, version)
[18:05:34.287]                           }
[18:05:34.287]                           base::stop(msg)
[18:05:34.287]                         }
[18:05:34.287]                       })
[18:05:34.287]                     }
[18:05:34.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:34.287]                     base::options(mc.cores = 1L)
[18:05:34.287]                   }
[18:05:34.287]                   ...future.strategy.old <- future::plan("list")
[18:05:34.287]                   options(future.plan = NULL)
[18:05:34.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:34.287]                 }
[18:05:34.287]                 ...future.workdir <- getwd()
[18:05:34.287]             }
[18:05:34.287]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.287]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.287]         }
[18:05:34.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.287]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.287]             base::names(...future.oldOptions))
[18:05:34.287]     }
[18:05:34.287]     if (FALSE) {
[18:05:34.287]     }
[18:05:34.287]     else {
[18:05:34.287]         if (TRUE) {
[18:05:34.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.287]                 open = "w")
[18:05:34.287]         }
[18:05:34.287]         else {
[18:05:34.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.287]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.287]         }
[18:05:34.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.287]             base::sink(type = "output", split = FALSE)
[18:05:34.287]             base::close(...future.stdout)
[18:05:34.287]         }, add = TRUE)
[18:05:34.287]     }
[18:05:34.287]     ...future.frame <- base::sys.nframe()
[18:05:34.287]     ...future.conditions <- base::list()
[18:05:34.287]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.287]     if (FALSE) {
[18:05:34.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.287]     }
[18:05:34.287]     ...future.result <- base::tryCatch({
[18:05:34.287]         base::withCallingHandlers({
[18:05:34.287]             ...future.value <- base::withVisible(base::local({
[18:05:34.287]                 withCallingHandlers({
[18:05:34.287]                   {
[18:05:34.287]                     b <- 2L
[18:05:34.287]                     plan_b <- future::plan("list")
[18:05:34.287]                     nested_b <- nested_a[-1]
[18:05:34.287]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:34.287]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:34.287]                       "sequential"))
[18:05:34.287]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:34.287]                       b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:34.287]                   }
[18:05:34.287]                 }, immediateCondition = function(cond) {
[18:05:34.287]                   save_rds <- function (object, pathname, ...) 
[18:05:34.287]                   {
[18:05:34.287]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:34.287]                     if (file_test("-f", pathname_tmp)) {
[18:05:34.287]                       fi_tmp <- file.info(pathname_tmp)
[18:05:34.287]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:34.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:34.287]                         fi_tmp[["mtime"]])
[18:05:34.287]                     }
[18:05:34.287]                     tryCatch({
[18:05:34.287]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:34.287]                     }, error = function(ex) {
[18:05:34.287]                       msg <- conditionMessage(ex)
[18:05:34.287]                       fi_tmp <- file.info(pathname_tmp)
[18:05:34.287]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:34.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:34.287]                         fi_tmp[["mtime"]], msg)
[18:05:34.287]                       ex$message <- msg
[18:05:34.287]                       stop(ex)
[18:05:34.287]                     })
[18:05:34.287]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:34.287]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:34.287]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:34.287]                       fi_tmp <- file.info(pathname_tmp)
[18:05:34.287]                       fi <- file.info(pathname)
[18:05:34.287]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:34.287]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:34.287]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:34.287]                         fi[["size"]], fi[["mtime"]])
[18:05:34.287]                       stop(msg)
[18:05:34.287]                     }
[18:05:34.287]                     invisible(pathname)
[18:05:34.287]                   }
[18:05:34.287]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:34.287]                     rootPath = tempdir()) 
[18:05:34.287]                   {
[18:05:34.287]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:34.287]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:34.287]                       tmpdir = path, fileext = ".rds")
[18:05:34.287]                     save_rds(obj, file)
[18:05:34.287]                   }
[18:05:34.287]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:34.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.287]                   {
[18:05:34.287]                     inherits <- base::inherits
[18:05:34.287]                     invokeRestart <- base::invokeRestart
[18:05:34.287]                     is.null <- base::is.null
[18:05:34.287]                     muffled <- FALSE
[18:05:34.287]                     if (inherits(cond, "message")) {
[18:05:34.287]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:34.287]                       if (muffled) 
[18:05:34.287]                         invokeRestart("muffleMessage")
[18:05:34.287]                     }
[18:05:34.287]                     else if (inherits(cond, "warning")) {
[18:05:34.287]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:34.287]                       if (muffled) 
[18:05:34.287]                         invokeRestart("muffleWarning")
[18:05:34.287]                     }
[18:05:34.287]                     else if (inherits(cond, "condition")) {
[18:05:34.287]                       if (!is.null(pattern)) {
[18:05:34.287]                         computeRestarts <- base::computeRestarts
[18:05:34.287]                         grepl <- base::grepl
[18:05:34.287]                         restarts <- computeRestarts(cond)
[18:05:34.287]                         for (restart in restarts) {
[18:05:34.287]                           name <- restart$name
[18:05:34.287]                           if (is.null(name)) 
[18:05:34.287]                             next
[18:05:34.287]                           if (!grepl(pattern, name)) 
[18:05:34.287]                             next
[18:05:34.287]                           invokeRestart(restart)
[18:05:34.287]                           muffled <- TRUE
[18:05:34.287]                           break
[18:05:34.287]                         }
[18:05:34.287]                       }
[18:05:34.287]                     }
[18:05:34.287]                     invisible(muffled)
[18:05:34.287]                   }
[18:05:34.287]                   muffleCondition(cond)
[18:05:34.287]                 })
[18:05:34.287]             }))
[18:05:34.287]             future::FutureResult(value = ...future.value$value, 
[18:05:34.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.287]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.287]                     ...future.globalenv.names))
[18:05:34.287]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.287]         }, condition = base::local({
[18:05:34.287]             c <- base::c
[18:05:34.287]             inherits <- base::inherits
[18:05:34.287]             invokeRestart <- base::invokeRestart
[18:05:34.287]             length <- base::length
[18:05:34.287]             list <- base::list
[18:05:34.287]             seq.int <- base::seq.int
[18:05:34.287]             signalCondition <- base::signalCondition
[18:05:34.287]             sys.calls <- base::sys.calls
[18:05:34.287]             `[[` <- base::`[[`
[18:05:34.287]             `+` <- base::`+`
[18:05:34.287]             `<<-` <- base::`<<-`
[18:05:34.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.287]                   3L)]
[18:05:34.287]             }
[18:05:34.287]             function(cond) {
[18:05:34.287]                 is_error <- inherits(cond, "error")
[18:05:34.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.287]                   NULL)
[18:05:34.287]                 if (is_error) {
[18:05:34.287]                   sessionInformation <- function() {
[18:05:34.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.287]                       search = base::search(), system = base::Sys.info())
[18:05:34.287]                   }
[18:05:34.287]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.287]                     cond$call), session = sessionInformation(), 
[18:05:34.287]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.287]                   signalCondition(cond)
[18:05:34.287]                 }
[18:05:34.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.287]                 "immediateCondition"))) {
[18:05:34.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.287]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.287]                   if (TRUE && !signal) {
[18:05:34.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.287]                     {
[18:05:34.287]                       inherits <- base::inherits
[18:05:34.287]                       invokeRestart <- base::invokeRestart
[18:05:34.287]                       is.null <- base::is.null
[18:05:34.287]                       muffled <- FALSE
[18:05:34.287]                       if (inherits(cond, "message")) {
[18:05:34.287]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.287]                         if (muffled) 
[18:05:34.287]                           invokeRestart("muffleMessage")
[18:05:34.287]                       }
[18:05:34.287]                       else if (inherits(cond, "warning")) {
[18:05:34.287]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.287]                         if (muffled) 
[18:05:34.287]                           invokeRestart("muffleWarning")
[18:05:34.287]                       }
[18:05:34.287]                       else if (inherits(cond, "condition")) {
[18:05:34.287]                         if (!is.null(pattern)) {
[18:05:34.287]                           computeRestarts <- base::computeRestarts
[18:05:34.287]                           grepl <- base::grepl
[18:05:34.287]                           restarts <- computeRestarts(cond)
[18:05:34.287]                           for (restart in restarts) {
[18:05:34.287]                             name <- restart$name
[18:05:34.287]                             if (is.null(name)) 
[18:05:34.287]                               next
[18:05:34.287]                             if (!grepl(pattern, name)) 
[18:05:34.287]                               next
[18:05:34.287]                             invokeRestart(restart)
[18:05:34.287]                             muffled <- TRUE
[18:05:34.287]                             break
[18:05:34.287]                           }
[18:05:34.287]                         }
[18:05:34.287]                       }
[18:05:34.287]                       invisible(muffled)
[18:05:34.287]                     }
[18:05:34.287]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.287]                   }
[18:05:34.287]                 }
[18:05:34.287]                 else {
[18:05:34.287]                   if (TRUE) {
[18:05:34.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.287]                     {
[18:05:34.287]                       inherits <- base::inherits
[18:05:34.287]                       invokeRestart <- base::invokeRestart
[18:05:34.287]                       is.null <- base::is.null
[18:05:34.287]                       muffled <- FALSE
[18:05:34.287]                       if (inherits(cond, "message")) {
[18:05:34.287]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.287]                         if (muffled) 
[18:05:34.287]                           invokeRestart("muffleMessage")
[18:05:34.287]                       }
[18:05:34.287]                       else if (inherits(cond, "warning")) {
[18:05:34.287]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.287]                         if (muffled) 
[18:05:34.287]                           invokeRestart("muffleWarning")
[18:05:34.287]                       }
[18:05:34.287]                       else if (inherits(cond, "condition")) {
[18:05:34.287]                         if (!is.null(pattern)) {
[18:05:34.287]                           computeRestarts <- base::computeRestarts
[18:05:34.287]                           grepl <- base::grepl
[18:05:34.287]                           restarts <- computeRestarts(cond)
[18:05:34.287]                           for (restart in restarts) {
[18:05:34.287]                             name <- restart$name
[18:05:34.287]                             if (is.null(name)) 
[18:05:34.287]                               next
[18:05:34.287]                             if (!grepl(pattern, name)) 
[18:05:34.287]                               next
[18:05:34.287]                             invokeRestart(restart)
[18:05:34.287]                             muffled <- TRUE
[18:05:34.287]                             break
[18:05:34.287]                           }
[18:05:34.287]                         }
[18:05:34.287]                       }
[18:05:34.287]                       invisible(muffled)
[18:05:34.287]                     }
[18:05:34.287]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.287]                   }
[18:05:34.287]                 }
[18:05:34.287]             }
[18:05:34.287]         }))
[18:05:34.287]     }, error = function(ex) {
[18:05:34.287]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.287]                 ...future.rng), started = ...future.startTime, 
[18:05:34.287]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.287]             version = "1.8"), class = "FutureResult")
[18:05:34.287]     }, finally = {
[18:05:34.287]         if (!identical(...future.workdir, getwd())) 
[18:05:34.287]             setwd(...future.workdir)
[18:05:34.287]         {
[18:05:34.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.287]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.287]             }
[18:05:34.287]             base::options(...future.oldOptions)
[18:05:34.287]             if (.Platform$OS.type == "windows") {
[18:05:34.287]                 old_names <- names(...future.oldEnvVars)
[18:05:34.287]                 envs <- base::Sys.getenv()
[18:05:34.287]                 names <- names(envs)
[18:05:34.287]                 common <- intersect(names, old_names)
[18:05:34.287]                 added <- setdiff(names, old_names)
[18:05:34.287]                 removed <- setdiff(old_names, names)
[18:05:34.287]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.287]                   envs[common]]
[18:05:34.287]                 NAMES <- toupper(changed)
[18:05:34.287]                 args <- list()
[18:05:34.287]                 for (kk in seq_along(NAMES)) {
[18:05:34.287]                   name <- changed[[kk]]
[18:05:34.287]                   NAME <- NAMES[[kk]]
[18:05:34.287]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.287]                     next
[18:05:34.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.287]                 }
[18:05:34.287]                 NAMES <- toupper(added)
[18:05:34.287]                 for (kk in seq_along(NAMES)) {
[18:05:34.287]                   name <- added[[kk]]
[18:05:34.287]                   NAME <- NAMES[[kk]]
[18:05:34.287]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.287]                     next
[18:05:34.287]                   args[[name]] <- ""
[18:05:34.287]                 }
[18:05:34.287]                 NAMES <- toupper(removed)
[18:05:34.287]                 for (kk in seq_along(NAMES)) {
[18:05:34.287]                   name <- removed[[kk]]
[18:05:34.287]                   NAME <- NAMES[[kk]]
[18:05:34.287]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.287]                     next
[18:05:34.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.287]                 }
[18:05:34.287]                 if (length(args) > 0) 
[18:05:34.287]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.287]             }
[18:05:34.287]             else {
[18:05:34.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.287]             }
[18:05:34.287]             {
[18:05:34.287]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.287]                   0L) {
[18:05:34.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.287]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.287]                   base::options(opts)
[18:05:34.287]                 }
[18:05:34.287]                 {
[18:05:34.287]                   {
[18:05:34.287]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:34.287]                     NULL
[18:05:34.287]                   }
[18:05:34.287]                   options(future.plan = NULL)
[18:05:34.287]                   if (is.na(NA_character_)) 
[18:05:34.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.287]                     .init = FALSE)
[18:05:34.287]                 }
[18:05:34.287]             }
[18:05:34.287]         }
[18:05:34.287]     })
[18:05:34.287]     if (TRUE) {
[18:05:34.287]         base::sink(type = "output", split = FALSE)
[18:05:34.287]         if (TRUE) {
[18:05:34.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.287]         }
[18:05:34.287]         else {
[18:05:34.287]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.287]         }
[18:05:34.287]         base::close(...future.stdout)
[18:05:34.287]         ...future.stdout <- NULL
[18:05:34.287]     }
[18:05:34.287]     ...future.result$conditions <- ...future.conditions
[18:05:34.287]     ...future.result$finished <- base::Sys.time()
[18:05:34.287]     ...future.result
[18:05:34.287] }
[18:05:34.376]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.292] assign_globals() ...
[18:05:34.377]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.292] List of 3
[18:05:34.292]  $ nested_a:List of 1
[18:05:34.292]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:34.292]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:34.292]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:34.292]  $ a       : int 1
[18:05:34.292]  $ plan_a  :List of 1
[18:05:34.292]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:34.292]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:34.292]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:34.292]  - attr(*, "where")=List of 3
[18:05:34.292]   ..$ nested_a:<environment: R_EmptyEnv> 
[18:05:34.292]   ..$ a       :<environment: R_EmptyEnv> 
[18:05:34.292]   ..$ plan_a  :<environment: R_EmptyEnv> 
[18:05:34.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.292]  - attr(*, "resolved")= logi FALSE
[18:05:34.292]  - attr(*, "total_size")= num 95240
[18:05:34.292]  - attr(*, "already-done")= logi TRUE
[18:05:34.378]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.302] - copied ‘nested_a’ to environment
[18:05:34.378]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.302] - copied ‘a’ to environment
[18:05:34.378]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.302] - copied ‘plan_a’ to environment
[18:05:34.378]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.302] assign_globals() ... done
[18:05:34.379]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.303] requestCore(): workers = 2
[18:05:34.379]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.307] MulticoreFuture started
[18:05:34.379]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.308] - Launch lazy future ... done
[18:05:34.380]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.309] run() for ‘MulticoreFuture’ ... done
[18:05:34.380]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.311] result() for MulticoreFuture ...
[18:05:34.380]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.352] result() for MulticoreFuture ...
[18:05:34.381]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.353] result() for MulticoreFuture ... done
[18:05:34.381]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.353] result() for MulticoreFuture ... done
[18:05:34.381]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.353] result() for MulticoreFuture ...
[18:05:34.381]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.354] result() for MulticoreFuture ... done
[18:05:34.382] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:34.393] getGlobalsAndPackages() ...
[18:05:34.393] Searching for globals...
[18:05:34.396] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:34.396] Searching for globals ... DONE
[18:05:34.396] Resolving globals: FALSE
[18:05:34.398] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:34.399] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:34.399] - globals: [1] ‘data’
[18:05:34.400] - packages: [1] ‘future’
[18:05:34.400] getGlobalsAndPackages() ... DONE
[18:05:34.400] run() for ‘Future’ ...
[18:05:34.401] - state: ‘created’
[18:05:34.401] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:34.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:34.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:34.405]   - Field: ‘label’
[18:05:34.405]   - Field: ‘local’
[18:05:34.405]   - Field: ‘owner’
[18:05:34.405]   - Field: ‘envir’
[18:05:34.405]   - Field: ‘packages’
[18:05:34.406]   - Field: ‘gc’
[18:05:34.406]   - Field: ‘conditions’
[18:05:34.406]   - Field: ‘expr’
[18:05:34.406]   - Field: ‘uuid’
[18:05:34.406]   - Field: ‘seed’
[18:05:34.407]   - Field: ‘version’
[18:05:34.407]   - Field: ‘result’
[18:05:34.407]   - Field: ‘asynchronous’
[18:05:34.407]   - Field: ‘calls’
[18:05:34.407]   - Field: ‘globals’
[18:05:34.408]   - Field: ‘stdout’
[18:05:34.408]   - Field: ‘earlySignal’
[18:05:34.408]   - Field: ‘lazy’
[18:05:34.408]   - Field: ‘state’
[18:05:34.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:34.409] - Launch lazy future ...
[18:05:34.409] Packages needed by the future expression (n = 1): ‘future’
[18:05:34.409] Packages needed by future strategies (n = 1): ‘future’
[18:05:34.410] {
[18:05:34.410]     {
[18:05:34.410]         {
[18:05:34.410]             ...future.startTime <- base::Sys.time()
[18:05:34.410]             {
[18:05:34.410]                 {
[18:05:34.410]                   {
[18:05:34.410]                     {
[18:05:34.410]                       base::local({
[18:05:34.410]                         has_future <- base::requireNamespace("future", 
[18:05:34.410]                           quietly = TRUE)
[18:05:34.410]                         if (has_future) {
[18:05:34.410]                           ns <- base::getNamespace("future")
[18:05:34.410]                           version <- ns[[".package"]][["version"]]
[18:05:34.410]                           if (is.null(version)) 
[18:05:34.410]                             version <- utils::packageVersion("future")
[18:05:34.410]                         }
[18:05:34.410]                         else {
[18:05:34.410]                           version <- NULL
[18:05:34.410]                         }
[18:05:34.410]                         if (!has_future || version < "1.8.0") {
[18:05:34.410]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.410]                             "", base::R.version$version.string), 
[18:05:34.410]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:34.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.410]                               "release", "version")], collapse = " "), 
[18:05:34.410]                             hostname = base::Sys.info()[["nodename"]])
[18:05:34.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.410]                             info)
[18:05:34.410]                           info <- base::paste(info, collapse = "; ")
[18:05:34.410]                           if (!has_future) {
[18:05:34.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.410]                               info)
[18:05:34.410]                           }
[18:05:34.410]                           else {
[18:05:34.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.410]                               info, version)
[18:05:34.410]                           }
[18:05:34.410]                           base::stop(msg)
[18:05:34.410]                         }
[18:05:34.410]                       })
[18:05:34.410]                     }
[18:05:34.410]                     base::local({
[18:05:34.410]                       for (pkg in "future") {
[18:05:34.410]                         base::loadNamespace(pkg)
[18:05:34.410]                         base::library(pkg, character.only = TRUE)
[18:05:34.410]                       }
[18:05:34.410]                     })
[18:05:34.410]                   }
[18:05:34.410]                   ...future.strategy.old <- future::plan("list")
[18:05:34.410]                   options(future.plan = NULL)
[18:05:34.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.410]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:34.410]                     envir = parent.frame()) 
[18:05:34.410]                   {
[18:05:34.410]                     default_workers <- missing(workers)
[18:05:34.410]                     if (is.function(workers)) 
[18:05:34.410]                       workers <- workers()
[18:05:34.410]                     workers <- structure(as.integer(workers), 
[18:05:34.410]                       class = class(workers))
[18:05:34.410]                     stop_if_not(is.finite(workers), workers >= 
[18:05:34.410]                       1L)
[18:05:34.410]                     if ((workers == 1L && !inherits(workers, 
[18:05:34.410]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:34.410]                       if (default_workers) 
[18:05:34.410]                         supportsMulticore(warn = TRUE)
[18:05:34.410]                       return(sequential(..., envir = envir))
[18:05:34.410]                     }
[18:05:34.410]                     oopts <- options(mc.cores = workers)
[18:05:34.410]                     on.exit(options(oopts))
[18:05:34.410]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:34.410]                       envir = envir)
[18:05:34.410]                     if (!future$lazy) 
[18:05:34.410]                       future <- run(future)
[18:05:34.410]                     invisible(future)
[18:05:34.410]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:34.410]                 }
[18:05:34.410]                 ...future.workdir <- getwd()
[18:05:34.410]             }
[18:05:34.410]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.410]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.410]         }
[18:05:34.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.410]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.410]             base::names(...future.oldOptions))
[18:05:34.410]     }
[18:05:34.410]     if (FALSE) {
[18:05:34.410]     }
[18:05:34.410]     else {
[18:05:34.410]         if (TRUE) {
[18:05:34.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.410]                 open = "w")
[18:05:34.410]         }
[18:05:34.410]         else {
[18:05:34.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.410]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.410]         }
[18:05:34.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.410]             base::sink(type = "output", split = FALSE)
[18:05:34.410]             base::close(...future.stdout)
[18:05:34.410]         }, add = TRUE)
[18:05:34.410]     }
[18:05:34.410]     ...future.frame <- base::sys.nframe()
[18:05:34.410]     ...future.conditions <- base::list()
[18:05:34.410]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.410]     if (FALSE) {
[18:05:34.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.410]     }
[18:05:34.410]     ...future.result <- base::tryCatch({
[18:05:34.410]         base::withCallingHandlers({
[18:05:34.410]             ...future.value <- base::withVisible(base::local({
[18:05:34.410]                 value(future(subset(data, a == 2)))
[18:05:34.410]             }))
[18:05:34.410]             future::FutureResult(value = ...future.value$value, 
[18:05:34.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.410]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.410]                     ...future.globalenv.names))
[18:05:34.410]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.410]         }, condition = base::local({
[18:05:34.410]             c <- base::c
[18:05:34.410]             inherits <- base::inherits
[18:05:34.410]             invokeRestart <- base::invokeRestart
[18:05:34.410]             length <- base::length
[18:05:34.410]             list <- base::list
[18:05:34.410]             seq.int <- base::seq.int
[18:05:34.410]             signalCondition <- base::signalCondition
[18:05:34.410]             sys.calls <- base::sys.calls
[18:05:34.410]             `[[` <- base::`[[`
[18:05:34.410]             `+` <- base::`+`
[18:05:34.410]             `<<-` <- base::`<<-`
[18:05:34.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.410]                   3L)]
[18:05:34.410]             }
[18:05:34.410]             function(cond) {
[18:05:34.410]                 is_error <- inherits(cond, "error")
[18:05:34.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.410]                   NULL)
[18:05:34.410]                 if (is_error) {
[18:05:34.410]                   sessionInformation <- function() {
[18:05:34.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.410]                       search = base::search(), system = base::Sys.info())
[18:05:34.410]                   }
[18:05:34.410]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.410]                     cond$call), session = sessionInformation(), 
[18:05:34.410]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.410]                   signalCondition(cond)
[18:05:34.410]                 }
[18:05:34.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.410]                 "immediateCondition"))) {
[18:05:34.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.410]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.410]                   if (TRUE && !signal) {
[18:05:34.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.410]                     {
[18:05:34.410]                       inherits <- base::inherits
[18:05:34.410]                       invokeRestart <- base::invokeRestart
[18:05:34.410]                       is.null <- base::is.null
[18:05:34.410]                       muffled <- FALSE
[18:05:34.410]                       if (inherits(cond, "message")) {
[18:05:34.410]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.410]                         if (muffled) 
[18:05:34.410]                           invokeRestart("muffleMessage")
[18:05:34.410]                       }
[18:05:34.410]                       else if (inherits(cond, "warning")) {
[18:05:34.410]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.410]                         if (muffled) 
[18:05:34.410]                           invokeRestart("muffleWarning")
[18:05:34.410]                       }
[18:05:34.410]                       else if (inherits(cond, "condition")) {
[18:05:34.410]                         if (!is.null(pattern)) {
[18:05:34.410]                           computeRestarts <- base::computeRestarts
[18:05:34.410]                           grepl <- base::grepl
[18:05:34.410]                           restarts <- computeRestarts(cond)
[18:05:34.410]                           for (restart in restarts) {
[18:05:34.410]                             name <- restart$name
[18:05:34.410]                             if (is.null(name)) 
[18:05:34.410]                               next
[18:05:34.410]                             if (!grepl(pattern, name)) 
[18:05:34.410]                               next
[18:05:34.410]                             invokeRestart(restart)
[18:05:34.410]                             muffled <- TRUE
[18:05:34.410]                             break
[18:05:34.410]                           }
[18:05:34.410]                         }
[18:05:34.410]                       }
[18:05:34.410]                       invisible(muffled)
[18:05:34.410]                     }
[18:05:34.410]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.410]                   }
[18:05:34.410]                 }
[18:05:34.410]                 else {
[18:05:34.410]                   if (TRUE) {
[18:05:34.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.410]                     {
[18:05:34.410]                       inherits <- base::inherits
[18:05:34.410]                       invokeRestart <- base::invokeRestart
[18:05:34.410]                       is.null <- base::is.null
[18:05:34.410]                       muffled <- FALSE
[18:05:34.410]                       if (inherits(cond, "message")) {
[18:05:34.410]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.410]                         if (muffled) 
[18:05:34.410]                           invokeRestart("muffleMessage")
[18:05:34.410]                       }
[18:05:34.410]                       else if (inherits(cond, "warning")) {
[18:05:34.410]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.410]                         if (muffled) 
[18:05:34.410]                           invokeRestart("muffleWarning")
[18:05:34.410]                       }
[18:05:34.410]                       else if (inherits(cond, "condition")) {
[18:05:34.410]                         if (!is.null(pattern)) {
[18:05:34.410]                           computeRestarts <- base::computeRestarts
[18:05:34.410]                           grepl <- base::grepl
[18:05:34.410]                           restarts <- computeRestarts(cond)
[18:05:34.410]                           for (restart in restarts) {
[18:05:34.410]                             name <- restart$name
[18:05:34.410]                             if (is.null(name)) 
[18:05:34.410]                               next
[18:05:34.410]                             if (!grepl(pattern, name)) 
[18:05:34.410]                               next
[18:05:34.410]                             invokeRestart(restart)
[18:05:34.410]                             muffled <- TRUE
[18:05:34.410]                             break
[18:05:34.410]                           }
[18:05:34.410]                         }
[18:05:34.410]                       }
[18:05:34.410]                       invisible(muffled)
[18:05:34.410]                     }
[18:05:34.410]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.410]                   }
[18:05:34.410]                 }
[18:05:34.410]             }
[18:05:34.410]         }))
[18:05:34.410]     }, error = function(ex) {
[18:05:34.410]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.410]                 ...future.rng), started = ...future.startTime, 
[18:05:34.410]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.410]             version = "1.8"), class = "FutureResult")
[18:05:34.410]     }, finally = {
[18:05:34.410]         if (!identical(...future.workdir, getwd())) 
[18:05:34.410]             setwd(...future.workdir)
[18:05:34.410]         {
[18:05:34.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.410]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.410]             }
[18:05:34.410]             base::options(...future.oldOptions)
[18:05:34.410]             if (.Platform$OS.type == "windows") {
[18:05:34.410]                 old_names <- names(...future.oldEnvVars)
[18:05:34.410]                 envs <- base::Sys.getenv()
[18:05:34.410]                 names <- names(envs)
[18:05:34.410]                 common <- intersect(names, old_names)
[18:05:34.410]                 added <- setdiff(names, old_names)
[18:05:34.410]                 removed <- setdiff(old_names, names)
[18:05:34.410]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.410]                   envs[common]]
[18:05:34.410]                 NAMES <- toupper(changed)
[18:05:34.410]                 args <- list()
[18:05:34.410]                 for (kk in seq_along(NAMES)) {
[18:05:34.410]                   name <- changed[[kk]]
[18:05:34.410]                   NAME <- NAMES[[kk]]
[18:05:34.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.410]                     next
[18:05:34.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.410]                 }
[18:05:34.410]                 NAMES <- toupper(added)
[18:05:34.410]                 for (kk in seq_along(NAMES)) {
[18:05:34.410]                   name <- added[[kk]]
[18:05:34.410]                   NAME <- NAMES[[kk]]
[18:05:34.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.410]                     next
[18:05:34.410]                   args[[name]] <- ""
[18:05:34.410]                 }
[18:05:34.410]                 NAMES <- toupper(removed)
[18:05:34.410]                 for (kk in seq_along(NAMES)) {
[18:05:34.410]                   name <- removed[[kk]]
[18:05:34.410]                   NAME <- NAMES[[kk]]
[18:05:34.410]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.410]                     next
[18:05:34.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.410]                 }
[18:05:34.410]                 if (length(args) > 0) 
[18:05:34.410]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.410]             }
[18:05:34.410]             else {
[18:05:34.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.410]             }
[18:05:34.410]             {
[18:05:34.410]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.410]                   0L) {
[18:05:34.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.410]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.410]                   base::options(opts)
[18:05:34.410]                 }
[18:05:34.410]                 {
[18:05:34.410]                   {
[18:05:34.410]                     NULL
[18:05:34.410]                     RNGkind("Mersenne-Twister")
[18:05:34.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:34.410]                       inherits = FALSE)
[18:05:34.410]                   }
[18:05:34.410]                   options(future.plan = NULL)
[18:05:34.410]                   if (is.na(NA_character_)) 
[18:05:34.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.410]                     .init = FALSE)
[18:05:34.410]                 }
[18:05:34.410]             }
[18:05:34.410]         }
[18:05:34.410]     })
[18:05:34.410]     if (TRUE) {
[18:05:34.410]         base::sink(type = "output", split = FALSE)
[18:05:34.410]         if (TRUE) {
[18:05:34.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.410]         }
[18:05:34.410]         else {
[18:05:34.410]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.410]         }
[18:05:34.410]         base::close(...future.stdout)
[18:05:34.410]         ...future.stdout <- NULL
[18:05:34.410]     }
[18:05:34.410]     ...future.result$conditions <- ...future.conditions
[18:05:34.410]     ...future.result$finished <- base::Sys.time()
[18:05:34.410]     ...future.result
[18:05:34.410] }
[18:05:34.414] assign_globals() ...
[18:05:34.414] List of 1
[18:05:34.414]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:34.414]   ..$ a: int [1:3] 1 2 3
[18:05:34.414]   ..$ b: int [1:3] 3 2 1
[18:05:34.414]  - attr(*, "where")=List of 1
[18:05:34.414]   ..$ data:<environment: R_EmptyEnv> 
[18:05:34.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.414]  - attr(*, "resolved")= logi FALSE
[18:05:34.414]  - attr(*, "total_size")= num 128
[18:05:34.414]  - attr(*, "already-done")= logi TRUE
[18:05:34.420] - copied ‘data’ to environment
[18:05:34.420] assign_globals() ... done
[18:05:34.421] plan(): Setting new future strategy stack:
[18:05:34.421] List of future strategies:
[18:05:34.421] 1. multicore:
[18:05:34.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:34.421]    - tweaked: FALSE
[18:05:34.421]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.427] plan(): nbrOfWorkers() = 2
[18:05:34.518] plan(): Setting new future strategy stack:
[18:05:34.519] List of future strategies:
[18:05:34.519] 1. sequential:
[18:05:34.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.519]    - tweaked: FALSE
[18:05:34.519]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.519] 2. multicore:
[18:05:34.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:34.519]    - tweaked: FALSE
[18:05:34.519]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.520] plan(): nbrOfWorkers() = 1
[18:05:34.521] SequentialFuture started (and completed)
[18:05:34.521] signalConditions() ...
[18:05:34.521]  - include = ‘immediateCondition’
[18:05:34.521]  - exclude = 
[18:05:34.521]  - resignal = FALSE
[18:05:34.522]  - Number of conditions: 55
[18:05:34.522] signalConditions() ... done
[18:05:34.522] - Launch lazy future ... done
[18:05:34.523] run() for ‘SequentialFuture’ ... done
[18:05:34.523] signalConditions() ...
[18:05:34.523]  - include = ‘immediateCondition’
[18:05:34.523]  - exclude = 
[18:05:34.524]  - resignal = FALSE
[18:05:34.524]  - Number of conditions: 55
[18:05:34.524] signalConditions() ... done
[18:05:34.524] Future state: ‘finished’
[18:05:34.525] signalConditions() ...
[18:05:34.525]  - include = ‘condition’
[18:05:34.525]  - exclude = ‘immediateCondition’
[18:05:34.525]  - resignal = TRUE
[18:05:34.525]  - Number of conditions: 55
[18:05:34.526]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.429] getGlobalsAndPackages() ...
[18:05:34.526]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.429] Searching for globals...
[18:05:34.526]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.461] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:34.527]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.462] Searching for globals ... DONE
[18:05:34.527]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.462] Resolving globals: FALSE
[18:05:34.527]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.463] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:34.528]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.464] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:34.528]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.464] - globals: [1] ‘data’
[18:05:34.528]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.464] 
[18:05:34.529]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.464] getGlobalsAndPackages() ... DONE
[18:05:34.529]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.465] run() for ‘Future’ ...
[18:05:34.529]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.465] - state: ‘created’
[18:05:34.530]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:34.530]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.472] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:34.530]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:34.531]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.473]   - Field: ‘label’
[18:05:34.531]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.473]   - Field: ‘local’
[18:05:34.531]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.473]   - Field: ‘owner’
[18:05:34.532]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.473]   - Field: ‘envir’
[18:05:34.536]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.474]   - Field: ‘workers’
[18:05:34.536]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.474]   - Field: ‘packages’
[18:05:34.536]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.474]   - Field: ‘gc’
[18:05:34.537]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.474]   - Field: ‘job’
[18:05:34.537]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.475]   - Field: ‘conditions’
[18:05:34.537]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.475]   - Field: ‘expr’
[18:05:34.538]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.475]   - Field: ‘uuid’
[18:05:34.538]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.475]   - Field: ‘seed’
[18:05:34.539]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.476]   - Field: ‘version’
[18:05:34.539]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.476]   - Field: ‘result’
[18:05:34.539]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.476]   - Field: ‘asynchronous’
[18:05:34.540]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.476]   - Field: ‘calls’
[18:05:34.540]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.476]   - Field: ‘globals’
[18:05:34.540]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.477]   - Field: ‘stdout’
[18:05:34.541]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.477]   - Field: ‘earlySignal’
[18:05:34.541]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.477]   - Field: ‘lazy’
[18:05:34.541]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.477]   - Field: ‘state’
[18:05:34.542]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:34.542]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.478] - Launch lazy future ...
[18:05:34.542]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.478] Packages needed by the future expression (n = 0): <none>
[18:05:34.543]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.479] Packages needed by future strategies (n = 0): <none>
[18:05:34.543]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.480] {
[18:05:34.480]     {
[18:05:34.480]         {
[18:05:34.480]             ...future.startTime <- base::Sys.time()
[18:05:34.480]             {
[18:05:34.480]                 {
[18:05:34.480]                   {
[18:05:34.480]                     {
[18:05:34.480]                       base::local({
[18:05:34.480]                         has_future <- base::requireNamespace("future", 
[18:05:34.480]                           quietly = TRUE)
[18:05:34.480]                         if (has_future) {
[18:05:34.480]                           ns <- base::getNamespace("future")
[18:05:34.480]                           version <- ns[[".package"]][["version"]]
[18:05:34.480]                           if (is.null(version)) 
[18:05:34.480]                             version <- utils::packageVersion("future")
[18:05:34.480]                         }
[18:05:34.480]                         else {
[18:05:34.480]                           version <- NULL
[18:05:34.480]                         }
[18:05:34.480]                         if (!has_future || version < "1.8.0") {
[18:05:34.480]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.480]                             "", base::R.version$version.string), 
[18:05:34.480]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:34.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.480]                               "release", "version")], collapse = " "), 
[18:05:34.480]                             hostname = base::Sys.info()[["nodename"]])
[18:05:34.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.480]                             info)
[18:05:34.480]                           info <- base::paste(info, collapse = "; ")
[18:05:34.480]                           if (!has_future) {
[18:05:34.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.480]                               info)
[18:05:34.480]                           }
[18:05:34.480]                           else {
[18:05:34.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.480]                               info, version)
[18:05:34.480]                           }
[18:05:34.480]                           base::stop(msg)
[18:05:34.480]                         }
[18:05:34.480]                       })
[18:05:34.480]                     }
[18:05:34.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:34.480]                     base::options(mc.cores = 1L)
[18:05:34.480]                   }
[18:05:34.480]                   ...future.strategy.old <- future::plan("list")
[18:05:34.480]                   options(future.plan = NULL)
[18:05:34.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:34.480]                 }
[18:05:34.480]                 ...future.workdir <- getwd()
[18:05:34.480]             }
[18:05:34.480]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.480]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.480]         }
[18:05:34.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.480]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.480]             base::names(...future.oldOptions))
[18:05:34.480]     }
[18:05:34.480]     if (FALSE) {
[18:05:34.480]     }
[18:05:34.480]     else {
[18:05:34.480]         if (TRUE) {
[18:05:34.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.480]                 open = "w")
[18:05:34.480]         }
[18:05:34.480]         else {
[18:05:34.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.480]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.480]         }
[18:05:34.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.480]             base::sink(type = "output", split = FALSE)
[18:05:34.480]             base::close(...future.stdout)
[18:05:34.480]         }, add = TRUE)
[18:05:34.480]     }
[18:05:34.480]     ...future.frame <- base::sys.nframe()
[18:05:34.480]     ...future.conditions <- base::list()
[18:05:34.480]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.480]     if (FALSE) {
[18:05:34.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.480]     }
[18:05:34.480]     ...future.result <- base::tryCatch({
[18:05:34.480]         base::withCallingHandlers({
[18:05:34.480]             ...future.value <- base::withVisible(base::local({
[18:05:34.480]                 withCallingHandlers({
[18:05:34.480]                   subset(data, a == 2)
[18:05:34.480]                 }, immediateCondition = function(cond) {
[18:05:34.480]                   save_rds <- function (object, pathname, ...) 
[18:05:34.480]                   {
[18:05:34.480]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:34.480]                     if (file_test("-f", pathname_tmp)) {
[18:05:34.480]                       fi_tmp <- file.info(pathname_tmp)
[18:05:34.480]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:34.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:34.480]                         fi_tmp[["mtime"]])
[18:05:34.480]                     }
[18:05:34.480]                     tryCatch({
[18:05:34.480]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:34.480]                     }, error = function(ex) {
[18:05:34.480]                       msg <- conditionMessage(ex)
[18:05:34.480]                       fi_tmp <- file.info(pathname_tmp)
[18:05:34.480]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:34.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:34.480]                         fi_tmp[["mtime"]], msg)
[18:05:34.480]                       ex$message <- msg
[18:05:34.480]                       stop(ex)
[18:05:34.480]                     })
[18:05:34.480]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:34.480]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:34.480]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:34.480]                       fi_tmp <- file.info(pathname_tmp)
[18:05:34.480]                       fi <- file.info(pathname)
[18:05:34.480]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:34.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:34.480]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:34.480]                         fi[["size"]], fi[["mtime"]])
[18:05:34.480]                       stop(msg)
[18:05:34.480]                     }
[18:05:34.480]                     invisible(pathname)
[18:05:34.480]                   }
[18:05:34.480]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:34.480]                     rootPath = tempdir()) 
[18:05:34.480]                   {
[18:05:34.480]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:34.480]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:34.480]                       tmpdir = path, fileext = ".rds")
[18:05:34.480]                     save_rds(obj, file)
[18:05:34.480]                   }
[18:05:34.480]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:34.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.480]                   {
[18:05:34.480]                     inherits <- base::inherits
[18:05:34.480]                     invokeRestart <- base::invokeRestart
[18:05:34.480]                     is.null <- base::is.null
[18:05:34.480]                     muffled <- FALSE
[18:05:34.480]                     if (inherits(cond, "message")) {
[18:05:34.480]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:34.480]                       if (muffled) 
[18:05:34.480]                         invokeRestart("muffleMessage")
[18:05:34.480]                     }
[18:05:34.480]                     else if (inherits(cond, "warning")) {
[18:05:34.480]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:34.480]                       if (muffled) 
[18:05:34.480]                         invokeRestart("muffleWarning")
[18:05:34.480]                     }
[18:05:34.480]                     else if (inherits(cond, "condition")) {
[18:05:34.480]                       if (!is.null(pattern)) {
[18:05:34.480]                         computeRestarts <- base::computeRestarts
[18:05:34.480]                         grepl <- base::grepl
[18:05:34.480]                         restarts <- computeRestarts(cond)
[18:05:34.480]                         for (restart in restarts) {
[18:05:34.480]                           name <- restart$name
[18:05:34.480]                           if (is.null(name)) 
[18:05:34.480]                             next
[18:05:34.480]                           if (!grepl(pattern, name)) 
[18:05:34.480]                             next
[18:05:34.480]                           invokeRestart(restart)
[18:05:34.480]                           muffled <- TRUE
[18:05:34.480]                           break
[18:05:34.480]                         }
[18:05:34.480]                       }
[18:05:34.480]                     }
[18:05:34.480]                     invisible(muffled)
[18:05:34.480]                   }
[18:05:34.480]                   muffleCondition(cond)
[18:05:34.480]                 })
[18:05:34.480]             }))
[18:05:34.480]             future::FutureResult(value = ...future.value$value, 
[18:05:34.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.480]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.480]                     ...future.globalenv.names))
[18:05:34.480]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.480]         }, condition = base::local({
[18:05:34.480]             c <- base::c
[18:05:34.480]             inherits <- base::inherits
[18:05:34.480]             invokeRestart <- base::invokeRestart
[18:05:34.480]             length <- base::length
[18:05:34.480]             list <- base::list
[18:05:34.480]             seq.int <- base::seq.int
[18:05:34.480]             signalCondition <- base::signalCondition
[18:05:34.480]             sys.calls <- base::sys.calls
[18:05:34.480]             `[[` <- base::`[[`
[18:05:34.480]             `+` <- base::`+`
[18:05:34.480]             `<<-` <- base::`<<-`
[18:05:34.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.480]                   3L)]
[18:05:34.480]             }
[18:05:34.480]             function(cond) {
[18:05:34.480]                 is_error <- inherits(cond, "error")
[18:05:34.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.480]                   NULL)
[18:05:34.480]                 if (is_error) {
[18:05:34.480]                   sessionInformation <- function() {
[18:05:34.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.480]                       search = base::search(), system = base::Sys.info())
[18:05:34.480]                   }
[18:05:34.480]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.480]                     cond$call), session = sessionInformation(), 
[18:05:34.480]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.480]                   signalCondition(cond)
[18:05:34.480]                 }
[18:05:34.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.480]                 "immediateCondition"))) {
[18:05:34.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.480]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.480]                   if (TRUE && !signal) {
[18:05:34.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.480]                     {
[18:05:34.480]                       inherits <- base::inherits
[18:05:34.480]                       invokeRestart <- base::invokeRestart
[18:05:34.480]                       is.null <- base::is.null
[18:05:34.480]                       muffled <- FALSE
[18:05:34.480]                       if (inherits(cond, "message")) {
[18:05:34.480]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.480]                         if (muffled) 
[18:05:34.480]                           invokeRestart("muffleMessage")
[18:05:34.480]                       }
[18:05:34.480]                       else if (inherits(cond, "warning")) {
[18:05:34.480]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.480]                         if (muffled) 
[18:05:34.480]                           invokeRestart("muffleWarning")
[18:05:34.480]                       }
[18:05:34.480]                       else if (inherits(cond, "condition")) {
[18:05:34.480]                         if (!is.null(pattern)) {
[18:05:34.480]                           computeRestarts <- base::computeRestarts
[18:05:34.480]                           grepl <- base::grepl
[18:05:34.480]                           restarts <- computeRestarts(cond)
[18:05:34.480]                           for (restart in restarts) {
[18:05:34.480]                             name <- restart$name
[18:05:34.480]                             if (is.null(name)) 
[18:05:34.480]                               next
[18:05:34.480]                             if (!grepl(pattern, name)) 
[18:05:34.480]                               next
[18:05:34.480]                             invokeRestart(restart)
[18:05:34.480]                             muffled <- TRUE
[18:05:34.480]                             break
[18:05:34.480]                           }
[18:05:34.480]                         }
[18:05:34.480]                       }
[18:05:34.480]                       invisible(muffled)
[18:05:34.480]                     }
[18:05:34.480]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.480]                   }
[18:05:34.480]                 }
[18:05:34.480]                 else {
[18:05:34.480]                   if (TRUE) {
[18:05:34.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.480]                     {
[18:05:34.480]                       inherits <- base::inherits
[18:05:34.480]                       invokeRestart <- base::invokeRestart
[18:05:34.480]                       is.null <- base::is.null
[18:05:34.480]                       muffled <- FALSE
[18:05:34.480]                       if (inherits(cond, "message")) {
[18:05:34.480]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.480]                         if (muffled) 
[18:05:34.480]                           invokeRestart("muffleMessage")
[18:05:34.480]                       }
[18:05:34.480]                       else if (inherits(cond, "warning")) {
[18:05:34.480]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.480]                         if (muffled) 
[18:05:34.480]                           invokeRestart("muffleWarning")
[18:05:34.480]                       }
[18:05:34.480]                       else if (inherits(cond, "condition")) {
[18:05:34.480]                         if (!is.null(pattern)) {
[18:05:34.480]                           computeRestarts <- base::computeRestarts
[18:05:34.480]                           grepl <- base::grepl
[18:05:34.480]                           restarts <- computeRestarts(cond)
[18:05:34.480]                           for (restart in restarts) {
[18:05:34.480]                             name <- restart$name
[18:05:34.480]                             if (is.null(name)) 
[18:05:34.480]                               next
[18:05:34.480]                             if (!grepl(pattern, name)) 
[18:05:34.480]                               next
[18:05:34.480]                             invokeRestart(restart)
[18:05:34.480]                             muffled <- TRUE
[18:05:34.480]                             break
[18:05:34.480]                           }
[18:05:34.480]                         }
[18:05:34.480]                       }
[18:05:34.480]                       invisible(muffled)
[18:05:34.480]                     }
[18:05:34.480]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.480]                   }
[18:05:34.480]                 }
[18:05:34.480]             }
[18:05:34.480]         }))
[18:05:34.480]     }, error = function(ex) {
[18:05:34.480]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.480]                 ...future.rng), started = ...future.startTime, 
[18:05:34.480]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.480]             version = "1.8"), class = "FutureResult")
[18:05:34.480]     }, finally = {
[18:05:34.480]         if (!identical(...future.workdir, getwd())) 
[18:05:34.480]             setwd(...future.workdir)
[18:05:34.480]         {
[18:05:34.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.480]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.480]             }
[18:05:34.480]             base::options(...future.oldOptions)
[18:05:34.480]             if (.Platform$OS.type == "windows") {
[18:05:34.480]                 old_names <- names(...future.oldEnvVars)
[18:05:34.480]                 envs <- base::Sys.getenv()
[18:05:34.480]                 names <- names(envs)
[18:05:34.480]                 common <- intersect(names, old_names)
[18:05:34.480]                 added <- setdiff(names, old_names)
[18:05:34.480]                 removed <- setdiff(old_names, names)
[18:05:34.480]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.480]                   envs[common]]
[18:05:34.480]                 NAMES <- toupper(changed)
[18:05:34.480]                 args <- list()
[18:05:34.480]                 for (kk in seq_along(NAMES)) {
[18:05:34.480]                   name <- changed[[kk]]
[18:05:34.480]                   NAME <- NAMES[[kk]]
[18:05:34.480]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.480]                     next
[18:05:34.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.480]                 }
[18:05:34.480]                 NAMES <- toupper(added)
[18:05:34.480]                 for (kk in seq_along(NAMES)) {
[18:05:34.480]                   name <- added[[kk]]
[18:05:34.480]                   NAME <- NAMES[[kk]]
[18:05:34.480]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.480]                     next
[18:05:34.480]                   args[[name]] <- ""
[18:05:34.480]                 }
[18:05:34.480]                 NAMES <- toupper(removed)
[18:05:34.480]                 for (kk in seq_along(NAMES)) {
[18:05:34.480]                   name <- removed[[kk]]
[18:05:34.480]                   NAME <- NAMES[[kk]]
[18:05:34.480]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.480]                     next
[18:05:34.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.480]                 }
[18:05:34.480]                 if (length(args) > 0) 
[18:05:34.480]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.480]             }
[18:05:34.480]             else {
[18:05:34.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.480]             }
[18:05:34.480]             {
[18:05:34.480]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.480]                   0L) {
[18:05:34.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.480]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.480]                   base::options(opts)
[18:05:34.480]                 }
[18:05:34.480]                 {
[18:05:34.480]                   {
[18:05:34.480]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:34.480]                     NULL
[18:05:34.480]                   }
[18:05:34.480]                   options(future.plan = NULL)
[18:05:34.480]                   if (is.na(NA_character_)) 
[18:05:34.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.480]                     .init = FALSE)
[18:05:34.480]                 }
[18:05:34.480]             }
[18:05:34.480]         }
[18:05:34.480]     })
[18:05:34.480]     if (TRUE) {
[18:05:34.480]         base::sink(type = "output", split = FALSE)
[18:05:34.480]         if (TRUE) {
[18:05:34.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.480]         }
[18:05:34.480]         else {
[18:05:34.480]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.480]         }
[18:05:34.480]         base::close(...future.stdout)
[18:05:34.480]         ...future.stdout <- NULL
[18:05:34.480]     }
[18:05:34.480]     ...future.result$conditions <- ...future.conditions
[18:05:34.480]     ...future.result$finished <- base::Sys.time()
[18:05:34.480]     ...future.result
[18:05:34.480] }
[18:05:34.543]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.484] assign_globals() ...
[18:05:34.544]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.484] List of 1
[18:05:34.484]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:34.484]   ..$ a: int [1:3] 1 2 3
[18:05:34.484]   ..$ b: int [1:3] 3 2 1
[18:05:34.484]  - attr(*, "where")=List of 1
[18:05:34.484]   ..$ data:<environment: R_EmptyEnv> 
[18:05:34.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.484]  - attr(*, "resolved")= logi FALSE
[18:05:34.484]  - attr(*, "total_size")= num 128
[18:05:34.484]  - attr(*, "already-done")= logi TRUE
[18:05:34.544]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.490] - copied ‘data’ to environment
[18:05:34.544]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.490] assign_globals() ... done
[18:05:34.545]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.491] requestCore(): workers = 2
[18:05:34.545]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.494] MulticoreFuture started
[18:05:34.545]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.495] - Launch lazy future ... done
[18:05:34.546]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.496] run() for ‘MulticoreFuture’ ... done
[18:05:34.546]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.497] result() for MulticoreFuture ...
[18:05:34.546]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.515] result() for MulticoreFuture ...
[18:05:34.547]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.516] result() for MulticoreFuture ... done
[18:05:34.547]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.516] result() for MulticoreFuture ... done
[18:05:34.547]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.517] result() for MulticoreFuture ...
[18:05:34.548]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.517] result() for MulticoreFuture ... done
[18:05:34.548] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[18:05:34.549] plan(): Setting new future strategy stack:
[18:05:34.549] List of future strategies:
[18:05:34.549] 1. sequential:
[18:05:34.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:34.549]    - tweaked: FALSE
[18:05:34.549]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.549] 2. multisession:
[18:05:34.549]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:34.549]    - tweaked: FALSE
[18:05:34.549]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.550] plan(): nbrOfWorkers() = 1
[18:05:34.551] getGlobalsAndPackages() ...
[18:05:34.551] Searching for globals...
[18:05:34.591] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:34.591] Searching for globals ... DONE
[18:05:34.592] Resolving globals: FALSE
[18:05:34.594] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[18:05:34.595] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:34.596] - globals: [2] ‘nested’, ‘strategy2’
[18:05:34.596] - packages: [1] ‘future’
[18:05:34.596] getGlobalsAndPackages() ... DONE
[18:05:34.597] run() for ‘Future’ ...
[18:05:34.597] - state: ‘created’
[18:05:34.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:34.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:34.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:34.599]   - Field: ‘label’
[18:05:34.599]   - Field: ‘local’
[18:05:34.599]   - Field: ‘owner’
[18:05:34.599]   - Field: ‘envir’
[18:05:34.600]   - Field: ‘packages’
[18:05:34.600]   - Field: ‘gc’
[18:05:34.600]   - Field: ‘conditions’
[18:05:34.600]   - Field: ‘expr’
[18:05:34.600]   - Field: ‘uuid’
[18:05:34.601]   - Field: ‘seed’
[18:05:34.601]   - Field: ‘version’
[18:05:34.601]   - Field: ‘result’
[18:05:34.601]   - Field: ‘asynchronous’
[18:05:34.601]   - Field: ‘calls’
[18:05:34.602]   - Field: ‘globals’
[18:05:34.602]   - Field: ‘stdout’
[18:05:34.602]   - Field: ‘earlySignal’
[18:05:34.602]   - Field: ‘lazy’
[18:05:34.602]   - Field: ‘state’
[18:05:34.603] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:34.603] - Launch lazy future ...
[18:05:34.603] Packages needed by the future expression (n = 1): ‘future’
[18:05:34.604] Packages needed by future strategies (n = 1): ‘future’
[18:05:34.605] {
[18:05:34.605]     {
[18:05:34.605]         {
[18:05:34.605]             ...future.startTime <- base::Sys.time()
[18:05:34.605]             {
[18:05:34.605]                 {
[18:05:34.605]                   {
[18:05:34.605]                     {
[18:05:34.605]                       base::local({
[18:05:34.605]                         has_future <- base::requireNamespace("future", 
[18:05:34.605]                           quietly = TRUE)
[18:05:34.605]                         if (has_future) {
[18:05:34.605]                           ns <- base::getNamespace("future")
[18:05:34.605]                           version <- ns[[".package"]][["version"]]
[18:05:34.605]                           if (is.null(version)) 
[18:05:34.605]                             version <- utils::packageVersion("future")
[18:05:34.605]                         }
[18:05:34.605]                         else {
[18:05:34.605]                           version <- NULL
[18:05:34.605]                         }
[18:05:34.605]                         if (!has_future || version < "1.8.0") {
[18:05:34.605]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:34.605]                             "", base::R.version$version.string), 
[18:05:34.605]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:34.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:34.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:34.605]                               "release", "version")], collapse = " "), 
[18:05:34.605]                             hostname = base::Sys.info()[["nodename"]])
[18:05:34.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:34.605]                             info)
[18:05:34.605]                           info <- base::paste(info, collapse = "; ")
[18:05:34.605]                           if (!has_future) {
[18:05:34.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:34.605]                               info)
[18:05:34.605]                           }
[18:05:34.605]                           else {
[18:05:34.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:34.605]                               info, version)
[18:05:34.605]                           }
[18:05:34.605]                           base::stop(msg)
[18:05:34.605]                         }
[18:05:34.605]                       })
[18:05:34.605]                     }
[18:05:34.605]                     base::local({
[18:05:34.605]                       for (pkg in "future") {
[18:05:34.605]                         base::loadNamespace(pkg)
[18:05:34.605]                         base::library(pkg, character.only = TRUE)
[18:05:34.605]                       }
[18:05:34.605]                     })
[18:05:34.605]                   }
[18:05:34.605]                   ...future.strategy.old <- future::plan("list")
[18:05:34.605]                   options(future.plan = NULL)
[18:05:34.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.605]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:34.605]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:34.605]                     envir = parent.frame()) 
[18:05:34.605]                   {
[18:05:34.605]                     if (is.function(workers)) 
[18:05:34.605]                       workers <- workers()
[18:05:34.605]                     workers <- structure(as.integer(workers), 
[18:05:34.605]                       class = class(workers))
[18:05:34.605]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:34.605]                       workers >= 1)
[18:05:34.605]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:34.605]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:34.605]                     }
[18:05:34.605]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:34.605]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:34.605]                       envir = envir)
[18:05:34.605]                     if (!future$lazy) 
[18:05:34.605]                       future <- run(future)
[18:05:34.605]                     invisible(future)
[18:05:34.605]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:34.605]                 }
[18:05:34.605]                 ...future.workdir <- getwd()
[18:05:34.605]             }
[18:05:34.605]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:34.605]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:34.605]         }
[18:05:34.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:34.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:34.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:34.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:34.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:34.605]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:34.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:34.605]             base::names(...future.oldOptions))
[18:05:34.605]     }
[18:05:34.605]     if (FALSE) {
[18:05:34.605]     }
[18:05:34.605]     else {
[18:05:34.605]         if (TRUE) {
[18:05:34.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:34.605]                 open = "w")
[18:05:34.605]         }
[18:05:34.605]         else {
[18:05:34.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:34.605]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:34.605]         }
[18:05:34.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:34.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:34.605]             base::sink(type = "output", split = FALSE)
[18:05:34.605]             base::close(...future.stdout)
[18:05:34.605]         }, add = TRUE)
[18:05:34.605]     }
[18:05:34.605]     ...future.frame <- base::sys.nframe()
[18:05:34.605]     ...future.conditions <- base::list()
[18:05:34.605]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:34.605]     if (FALSE) {
[18:05:34.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:34.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:34.605]     }
[18:05:34.605]     ...future.result <- base::tryCatch({
[18:05:34.605]         base::withCallingHandlers({
[18:05:34.605]             ...future.value <- base::withVisible(base::local({
[18:05:34.605]                 a <- 1L
[18:05:34.605]                 plan_a <- unclass(future::plan("list"))
[18:05:34.605]                 nested_a <- nested[-1]
[18:05:34.605]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:34.605]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:34.605]                   strategy2))
[18:05:34.605]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:34.605]                   "init") <- NULL
[18:05:34.605]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:34.605]                   "init") <- NULL
[18:05:34.605]                 stopifnot(all.equal(plan_a, nested_a))
[18:05:34.605]                 y %<-% {
[18:05:34.605]                   b <- 2L
[18:05:34.605]                   plan_b <- future::plan("list")
[18:05:34.605]                   nested_b <- nested_a[-1]
[18:05:34.605]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:34.605]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:34.605]                     "sequential"))
[18:05:34.605]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:34.605]                     b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:34.605]                 }
[18:05:34.605]                 y
[18:05:34.605]             }))
[18:05:34.605]             future::FutureResult(value = ...future.value$value, 
[18:05:34.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.605]                   ...future.rng), globalenv = if (FALSE) 
[18:05:34.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:34.605]                     ...future.globalenv.names))
[18:05:34.605]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:34.605]         }, condition = base::local({
[18:05:34.605]             c <- base::c
[18:05:34.605]             inherits <- base::inherits
[18:05:34.605]             invokeRestart <- base::invokeRestart
[18:05:34.605]             length <- base::length
[18:05:34.605]             list <- base::list
[18:05:34.605]             seq.int <- base::seq.int
[18:05:34.605]             signalCondition <- base::signalCondition
[18:05:34.605]             sys.calls <- base::sys.calls
[18:05:34.605]             `[[` <- base::`[[`
[18:05:34.605]             `+` <- base::`+`
[18:05:34.605]             `<<-` <- base::`<<-`
[18:05:34.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:34.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:34.605]                   3L)]
[18:05:34.605]             }
[18:05:34.605]             function(cond) {
[18:05:34.605]                 is_error <- inherits(cond, "error")
[18:05:34.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:34.605]                   NULL)
[18:05:34.605]                 if (is_error) {
[18:05:34.605]                   sessionInformation <- function() {
[18:05:34.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:34.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:34.605]                       search = base::search(), system = base::Sys.info())
[18:05:34.605]                   }
[18:05:34.605]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:34.605]                     cond$call), session = sessionInformation(), 
[18:05:34.605]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:34.605]                   signalCondition(cond)
[18:05:34.605]                 }
[18:05:34.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:34.605]                 "immediateCondition"))) {
[18:05:34.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:34.605]                   ...future.conditions[[length(...future.conditions) + 
[18:05:34.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:34.605]                   if (TRUE && !signal) {
[18:05:34.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.605]                     {
[18:05:34.605]                       inherits <- base::inherits
[18:05:34.605]                       invokeRestart <- base::invokeRestart
[18:05:34.605]                       is.null <- base::is.null
[18:05:34.605]                       muffled <- FALSE
[18:05:34.605]                       if (inherits(cond, "message")) {
[18:05:34.605]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.605]                         if (muffled) 
[18:05:34.605]                           invokeRestart("muffleMessage")
[18:05:34.605]                       }
[18:05:34.605]                       else if (inherits(cond, "warning")) {
[18:05:34.605]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.605]                         if (muffled) 
[18:05:34.605]                           invokeRestart("muffleWarning")
[18:05:34.605]                       }
[18:05:34.605]                       else if (inherits(cond, "condition")) {
[18:05:34.605]                         if (!is.null(pattern)) {
[18:05:34.605]                           computeRestarts <- base::computeRestarts
[18:05:34.605]                           grepl <- base::grepl
[18:05:34.605]                           restarts <- computeRestarts(cond)
[18:05:34.605]                           for (restart in restarts) {
[18:05:34.605]                             name <- restart$name
[18:05:34.605]                             if (is.null(name)) 
[18:05:34.605]                               next
[18:05:34.605]                             if (!grepl(pattern, name)) 
[18:05:34.605]                               next
[18:05:34.605]                             invokeRestart(restart)
[18:05:34.605]                             muffled <- TRUE
[18:05:34.605]                             break
[18:05:34.605]                           }
[18:05:34.605]                         }
[18:05:34.605]                       }
[18:05:34.605]                       invisible(muffled)
[18:05:34.605]                     }
[18:05:34.605]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.605]                   }
[18:05:34.605]                 }
[18:05:34.605]                 else {
[18:05:34.605]                   if (TRUE) {
[18:05:34.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:34.605]                     {
[18:05:34.605]                       inherits <- base::inherits
[18:05:34.605]                       invokeRestart <- base::invokeRestart
[18:05:34.605]                       is.null <- base::is.null
[18:05:34.605]                       muffled <- FALSE
[18:05:34.605]                       if (inherits(cond, "message")) {
[18:05:34.605]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:34.605]                         if (muffled) 
[18:05:34.605]                           invokeRestart("muffleMessage")
[18:05:34.605]                       }
[18:05:34.605]                       else if (inherits(cond, "warning")) {
[18:05:34.605]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:34.605]                         if (muffled) 
[18:05:34.605]                           invokeRestart("muffleWarning")
[18:05:34.605]                       }
[18:05:34.605]                       else if (inherits(cond, "condition")) {
[18:05:34.605]                         if (!is.null(pattern)) {
[18:05:34.605]                           computeRestarts <- base::computeRestarts
[18:05:34.605]                           grepl <- base::grepl
[18:05:34.605]                           restarts <- computeRestarts(cond)
[18:05:34.605]                           for (restart in restarts) {
[18:05:34.605]                             name <- restart$name
[18:05:34.605]                             if (is.null(name)) 
[18:05:34.605]                               next
[18:05:34.605]                             if (!grepl(pattern, name)) 
[18:05:34.605]                               next
[18:05:34.605]                             invokeRestart(restart)
[18:05:34.605]                             muffled <- TRUE
[18:05:34.605]                             break
[18:05:34.605]                           }
[18:05:34.605]                         }
[18:05:34.605]                       }
[18:05:34.605]                       invisible(muffled)
[18:05:34.605]                     }
[18:05:34.605]                     muffleCondition(cond, pattern = "^muffle")
[18:05:34.605]                   }
[18:05:34.605]                 }
[18:05:34.605]             }
[18:05:34.605]         }))
[18:05:34.605]     }, error = function(ex) {
[18:05:34.605]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:34.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:34.605]                 ...future.rng), started = ...future.startTime, 
[18:05:34.605]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:34.605]             version = "1.8"), class = "FutureResult")
[18:05:34.605]     }, finally = {
[18:05:34.605]         if (!identical(...future.workdir, getwd())) 
[18:05:34.605]             setwd(...future.workdir)
[18:05:34.605]         {
[18:05:34.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:34.605]                 ...future.oldOptions$nwarnings <- NULL
[18:05:34.605]             }
[18:05:34.605]             base::options(...future.oldOptions)
[18:05:34.605]             if (.Platform$OS.type == "windows") {
[18:05:34.605]                 old_names <- names(...future.oldEnvVars)
[18:05:34.605]                 envs <- base::Sys.getenv()
[18:05:34.605]                 names <- names(envs)
[18:05:34.605]                 common <- intersect(names, old_names)
[18:05:34.605]                 added <- setdiff(names, old_names)
[18:05:34.605]                 removed <- setdiff(old_names, names)
[18:05:34.605]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:34.605]                   envs[common]]
[18:05:34.605]                 NAMES <- toupper(changed)
[18:05:34.605]                 args <- list()
[18:05:34.605]                 for (kk in seq_along(NAMES)) {
[18:05:34.605]                   name <- changed[[kk]]
[18:05:34.605]                   NAME <- NAMES[[kk]]
[18:05:34.605]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.605]                     next
[18:05:34.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.605]                 }
[18:05:34.605]                 NAMES <- toupper(added)
[18:05:34.605]                 for (kk in seq_along(NAMES)) {
[18:05:34.605]                   name <- added[[kk]]
[18:05:34.605]                   NAME <- NAMES[[kk]]
[18:05:34.605]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.605]                     next
[18:05:34.605]                   args[[name]] <- ""
[18:05:34.605]                 }
[18:05:34.605]                 NAMES <- toupper(removed)
[18:05:34.605]                 for (kk in seq_along(NAMES)) {
[18:05:34.605]                   name <- removed[[kk]]
[18:05:34.605]                   NAME <- NAMES[[kk]]
[18:05:34.605]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:34.605]                     next
[18:05:34.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:34.605]                 }
[18:05:34.605]                 if (length(args) > 0) 
[18:05:34.605]                   base::do.call(base::Sys.setenv, args = args)
[18:05:34.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:34.605]             }
[18:05:34.605]             else {
[18:05:34.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:34.605]             }
[18:05:34.605]             {
[18:05:34.605]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:34.605]                   0L) {
[18:05:34.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:34.605]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:34.605]                   base::options(opts)
[18:05:34.605]                 }
[18:05:34.605]                 {
[18:05:34.605]                   {
[18:05:34.605]                     NULL
[18:05:34.605]                     RNGkind("Mersenne-Twister")
[18:05:34.605]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:34.605]                       inherits = FALSE)
[18:05:34.605]                   }
[18:05:34.605]                   options(future.plan = NULL)
[18:05:34.605]                   if (is.na(NA_character_)) 
[18:05:34.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:34.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:34.605]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:34.605]                     .init = FALSE)
[18:05:34.605]                 }
[18:05:34.605]             }
[18:05:34.605]         }
[18:05:34.605]     })
[18:05:34.605]     if (TRUE) {
[18:05:34.605]         base::sink(type = "output", split = FALSE)
[18:05:34.605]         if (TRUE) {
[18:05:34.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:34.605]         }
[18:05:34.605]         else {
[18:05:34.605]             ...future.result["stdout"] <- base::list(NULL)
[18:05:34.605]         }
[18:05:34.605]         base::close(...future.stdout)
[18:05:34.605]         ...future.stdout <- NULL
[18:05:34.605]     }
[18:05:34.605]     ...future.result$conditions <- ...future.conditions
[18:05:34.605]     ...future.result$finished <- base::Sys.time()
[18:05:34.605]     ...future.result
[18:05:34.605] }
[18:05:34.609] assign_globals() ...
[18:05:34.609] List of 2
[18:05:34.609]  $ nested   :List of 2
[18:05:34.609]   ..$ a:function (..., envir = parent.frame())  
[18:05:34.609]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:34.609]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:34.609]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:34.609]     envir = parent.frame())  
[18:05:34.609]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[18:05:34.609]   .. ..- attr(*, "init")= logi TRUE
[18:05:34.609]   .. ..- attr(*, "untweakable")= chr "persistent"
[18:05:34.609]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:34.609]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:34.609]  $ strategy2: chr "multisession"
[18:05:34.609]  - attr(*, "where")=List of 2
[18:05:34.609]   ..$ nested   :<environment: R_EmptyEnv> 
[18:05:34.609]   ..$ strategy2:<environment: R_EmptyEnv> 
[18:05:34.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:34.609]  - attr(*, "resolved")= logi FALSE
[18:05:34.609]  - attr(*, "total_size")= num 56736
[18:05:34.609]  - attr(*, "already-done")= logi TRUE
[18:05:34.621] - copied ‘nested’ to environment
[18:05:34.621] - copied ‘strategy2’ to environment
[18:05:34.621] assign_globals() ... done
[18:05:34.622] plan(): Setting new future strategy stack:
[18:05:34.622] List of future strategies:
[18:05:34.622] 1. multisession:
[18:05:34.622]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:34.622]    - tweaked: FALSE
[18:05:34.622]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:34.629] plan(): nbrOfWorkers() = 2
[18:05:35.711] plan(): Setting new future strategy stack:
[18:05:35.711] List of future strategies:
[18:05:35.711] 1. sequential:
[18:05:35.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:35.711]    - tweaked: FALSE
[18:05:35.711]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.711] 2. multisession:
[18:05:35.711]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:35.711]    - tweaked: FALSE
[18:05:35.711]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.713] plan(): nbrOfWorkers() = 1
[18:05:35.713] SequentialFuture started (and completed)
[18:05:35.714] signalConditions() ...
[18:05:35.714]  - include = ‘immediateCondition’
[18:05:35.714]  - exclude = 
[18:05:35.714]  - resignal = FALSE
[18:05:35.715]  - Number of conditions: 98
[18:05:35.715] signalConditions() ... done
[18:05:35.715] - Launch lazy future ... done
[18:05:35.716] run() for ‘SequentialFuture’ ... done
[18:05:35.716] signalConditions() ...
[18:05:35.716]  - include = ‘immediateCondition’
[18:05:35.717]  - exclude = 
[18:05:35.717]  - resignal = FALSE
[18:05:35.717]  - Number of conditions: 98
[18:05:35.718] signalConditions() ... done
[18:05:35.718] Future state: ‘finished’
[18:05:35.719] signalConditions() ...
[18:05:35.719]  - include = ‘condition’
[18:05:35.719]  - exclude = ‘immediateCondition’
[18:05:35.719]  - resignal = TRUE
[18:05:35.720]  - Number of conditions: 98
[18:05:35.720]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.633] getGlobalsAndPackages() ...
[18:05:35.720]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.634] Searching for globals...
[18:05:35.721]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.676] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[18:05:35.721]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.676] Searching for globals ... DONE
[18:05:35.721]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.676] Resolving globals: FALSE
[18:05:35.722]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.678] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[18:05:35.722]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.679] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[18:05:35.723]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.679] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[18:05:35.723]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.679] 
[18:05:35.723]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.679] getGlobalsAndPackages() ... DONE
[18:05:35.724]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.680] run() for ‘Future’ ...
[18:05:35.724]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.680] - state: ‘created’
[18:05:35.724]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:35.725]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.690] [local output] makeClusterPSOCK() ...
[18:05:35.725]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.750] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:35.726]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.752] [local output] Base port: 11298
[18:05:35.726]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.752] [local output] Getting setup options for 2 cluster nodes ...
[18:05:35.726]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.752] [local output]  - Node 1 of 2 ...
[18:05:35.727]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.753] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:35.727]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:34.754] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e4400df503.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e4400df503.pid")'’
[18:05:35.728]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.017] - Possible to infer worker's PID: TRUE
[18:05:35.728]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.017] [local output] Rscript port: 11298

[18:05:35.728]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.018] [local output]  - Node 2 of 2 ...
[18:05:35.729]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.018] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:35.729]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.020] [local output] Rscript port: 11298

[18:05:35.730]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.020] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:35.730]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.020] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:35.730]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.021] [local output] Setting up PSOCK nodes in parallel
[18:05:35.731]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.022] List of 36
[18:05:35.022]  $ worker          : chr "localhost"
[18:05:35.022]   ..- attr(*, "localhost")= logi TRUE
[18:05:35.022]  $ master          : chr "localhost"
[18:05:35.022]  $ port            : int 11298
[18:05:35.022]  $ connectTimeout  : num 120
[18:05:35.022]  $ timeout         : num 2592000
[18:05:35.022]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:35.022]  $ homogeneous     : logi TRUE
[18:05:35.022]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:35.022]  $ rscript_envs    : NULL
[18:05:35.022]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:35.022]  $ rscript_startup : NULL
[18:05:35.022]  $ rscript_sh      : chr "sh"
[18:05:35.022]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:35.022]  $ methods         : logi TRUE
[18:05:35.022]  $ socketOptions   : chr "no-delay"
[18:05:35.022]  $ useXDR          : logi FALSE
[18:05:35.022]  $ outfile         : chr "/dev/null"
[18:05:35.022]  $ renice          : int NA
[18:05:35.022]  $ rshcmd          : NULL
[18:05:35.022]  $ user            : chr(0) 
[18:05:35.022]  $ revtunnel       : logi FALSE
[18:05:35.022]  $ rshlogfile      : NULL
[18:05:35.022]  $ rshopts         : chr(0) 
[18:05:35.022]  $ rank            : int 1
[18:05:35.022]  $ manual          : logi FALSE
[18:05:35.022]  $ dryrun          : logi FALSE
[18:05:35.022]  $ quiet           : logi FALSE
[18:05:35.022]  $ setup_strategy  : chr "parallel"
[18:05:35.022]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:35.022]  $ pidfile         : chr "/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e4400df503.pid"
[18:05:35.022]  $ rshcmd_label    : NULL
[18:05:35.022]  $ rsh_call        : NULL
[18:05:35.022]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:35.022]  $ localMachine    : logi TRUE
[18:05:35.022]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:35.022]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:35.022]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:35.022]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:35.022]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:35.022]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:35.022]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:35.022]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:35.022]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:35.022]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:35.022]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:35.022]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:35.022]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:35.022]  $ arguments       :List of 28
[18:05:35.022]   ..$ worker          : chr "localhost"
[18:05:35.022]   ..$ master          : NULL
[18:05:35.022]   ..$ port            : int 11298
[18:05:35.022]   ..$ connectTimeout  : num 120
[18:05:35.022]   ..$ timeout         : num 2592000
[18:05:35.022]   ..$ rscript         : NULL
[18:05:35.022]   ..$ homogeneous     : NULL
[18:05:35.022]   ..$ rscript_args    : NULL
[18:05:35.022]   ..$ rscript_envs    : NULL
[18:05:35.022]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:35.022]   ..$ rscript_startup : NULL
[18:05:35.022]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:35.022]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:35.022]   ..$ methods         : logi TRUE
[18:05:35.022]   ..$ socketOptions   : chr "no-delay"
[18:05:35.022]   ..$ useXDR          : logi FALSE
[18:05:35.022]   ..$ outfile         : chr "/dev/null"
[18:05:35.022]   ..$ renice          : int NA
[18:05:35.022]   ..$ rshcmd          : NULL
[18:05:35.022]   ..$ user            : NULL
[18:05:35.022]   ..$ revtunnel       : logi NA
[18:05:35.022]   ..$ rshlogfile      : NULL
[18:05:35.022]   ..$ rshopts         : NULL
[18:05:35.022]   ..$ rank            : int 1
[18:05:35.022]   ..$ manual          : logi FALSE
[18:05:35.022]   ..$ dryrun          : logi FALSE
[18:05:35.022]   ..$ quiet           : logi FALSE
[18:05:35.022]   ..$ setup_strategy  : chr "parallel"
[18:05:35.022]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:35.731]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.055] [local output] System call to launch all workers:
[18:05:35.732]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.055] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e4400df503.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11298 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:35.732]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.056] [local output] Starting PSOCK main server
[18:05:35.732]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.064] [local output] Workers launched
[18:05:35.733]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.064] [local output] Waiting for workers to connect back
[18:05:35.733]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.065]  - [local output] 0 workers out of 2 ready
[18:05:35.734]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.405]  - [local output] 0 workers out of 2 ready
[18:05:35.734]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.406]  - [local output] 1 workers out of 2 ready
[18:05:35.734]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.416]  - [local output] 1 workers out of 2 ready
[18:05:35.735]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.417]  - [local output] 2 workers out of 2 ready
[18:05:35.735]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.417] [local output] Launching of workers completed
[18:05:35.735]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.417] [local output] Collecting session information from workers
[18:05:35.736]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.419] [local output]  - Worker #1 of 2
[18:05:35.736]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.420] [local output]  - Worker #2 of 2
[18:05:35.737]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.420] [local output] makeClusterPSOCK() ... done
[18:05:35.737]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.439] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:35.737]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:35.738]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.440]   - Field: ‘node’
[18:05:35.738]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.440]   - Field: ‘label’
[18:05:35.738]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.440]   - Field: ‘local’
[18:05:35.739]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.440]   - Field: ‘owner’
[18:05:35.739]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.441]   - Field: ‘envir’
[18:05:35.739]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.441]   - Field: ‘workers’
[18:05:35.740]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.441]   - Field: ‘packages’
[18:05:35.740]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.441]   - Field: ‘gc’
[18:05:35.740]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.442]   - Field: ‘conditions’
[18:05:35.741]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.442]   - Field: ‘persistent’
[18:05:35.741]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.442]   - Field: ‘expr’
[18:05:35.741]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.442]   - Field: ‘uuid’
[18:05:35.742]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.443]   - Field: ‘seed’
[18:05:35.742]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.443]   - Field: ‘version’
[18:05:35.742]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.443]   - Field: ‘result’
[18:05:35.743]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.444]   - Field: ‘asynchronous’
[18:05:35.743]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.444]   - Field: ‘calls’
[18:05:35.743]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.444]   - Field: ‘globals’
[18:05:35.744]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.444]   - Field: ‘stdout’
[18:05:35.744]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.445]   - Field: ‘earlySignal’
[18:05:35.744]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.445]   - Field: ‘lazy’
[18:05:35.745]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.445]   - Field: ‘state’
[18:05:35.745]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:35.745]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.446] - Launch lazy future ...
[18:05:35.746]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.447] Packages needed by the future expression (n = 0): <none>
[18:05:35.746]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.447] Packages needed by future strategies (n = 0): <none>
[18:05:35.746]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.448] {
[18:05:35.448]     {
[18:05:35.448]         {
[18:05:35.448]             ...future.startTime <- base::Sys.time()
[18:05:35.448]             {
[18:05:35.448]                 {
[18:05:35.448]                   {
[18:05:35.448]                     {
[18:05:35.448]                       base::local({
[18:05:35.448]                         has_future <- base::requireNamespace("future", 
[18:05:35.448]                           quietly = TRUE)
[18:05:35.448]                         if (has_future) {
[18:05:35.448]                           ns <- base::getNamespace("future")
[18:05:35.448]                           version <- ns[[".package"]][["version"]]
[18:05:35.448]                           if (is.null(version)) 
[18:05:35.448]                             version <- utils::packageVersion("future")
[18:05:35.448]                         }
[18:05:35.448]                         else {
[18:05:35.448]                           version <- NULL
[18:05:35.448]                         }
[18:05:35.448]                         if (!has_future || version < "1.8.0") {
[18:05:35.448]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:35.448]                             "", base::R.version$version.string), 
[18:05:35.448]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:35.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:35.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:35.448]                               "release", "version")], collapse = " "), 
[18:05:35.448]                             hostname = base::Sys.info()[["nodename"]])
[18:05:35.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:35.448]                             info)
[18:05:35.448]                           info <- base::paste(info, collapse = "; ")
[18:05:35.448]                           if (!has_future) {
[18:05:35.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:35.448]                               info)
[18:05:35.448]                           }
[18:05:35.448]                           else {
[18:05:35.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:35.448]                               info, version)
[18:05:35.448]                           }
[18:05:35.448]                           base::stop(msg)
[18:05:35.448]                         }
[18:05:35.448]                       })
[18:05:35.448]                     }
[18:05:35.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:35.448]                     base::options(mc.cores = 1L)
[18:05:35.448]                   }
[18:05:35.448]                   ...future.strategy.old <- future::plan("list")
[18:05:35.448]                   options(future.plan = NULL)
[18:05:35.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:35.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:35.448]                 }
[18:05:35.448]                 ...future.workdir <- getwd()
[18:05:35.448]             }
[18:05:35.448]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:35.448]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:35.448]         }
[18:05:35.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:35.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:35.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:35.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:35.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:35.448]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:35.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:35.448]             base::names(...future.oldOptions))
[18:05:35.448]     }
[18:05:35.448]     if (FALSE) {
[18:05:35.448]     }
[18:05:35.448]     else {
[18:05:35.448]         if (TRUE) {
[18:05:35.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:35.448]                 open = "w")
[18:05:35.448]         }
[18:05:35.448]         else {
[18:05:35.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:35.448]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:35.448]         }
[18:05:35.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:35.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:35.448]             base::sink(type = "output", split = FALSE)
[18:05:35.448]             base::close(...future.stdout)
[18:05:35.448]         }, add = TRUE)
[18:05:35.448]     }
[18:05:35.448]     ...future.frame <- base::sys.nframe()
[18:05:35.448]     ...future.conditions <- base::list()
[18:05:35.448]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:35.448]     if (FALSE) {
[18:05:35.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:35.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:35.448]     }
[18:05:35.448]     ...future.result <- base::tryCatch({
[18:05:35.448]         base::withCallingHandlers({
[18:05:35.448]             ...future.value <- base::withVisible(base::local({
[18:05:35.448]                 ...future.makeSendCondition <- base::local({
[18:05:35.448]                   sendCondition <- NULL
[18:05:35.448]                   function(frame = 1L) {
[18:05:35.448]                     if (is.function(sendCondition)) 
[18:05:35.448]                       return(sendCondition)
[18:05:35.448]                     ns <- getNamespace("parallel")
[18:05:35.448]                     if (exists("sendData", mode = "function", 
[18:05:35.448]                       envir = ns)) {
[18:05:35.448]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:35.448]                         envir = ns)
[18:05:35.448]                       envir <- sys.frame(frame)
[18:05:35.448]                       master <- NULL
[18:05:35.448]                       while (!identical(envir, .GlobalEnv) && 
[18:05:35.448]                         !identical(envir, emptyenv())) {
[18:05:35.448]                         if (exists("master", mode = "list", envir = envir, 
[18:05:35.448]                           inherits = FALSE)) {
[18:05:35.448]                           master <- get("master", mode = "list", 
[18:05:35.448]                             envir = envir, inherits = FALSE)
[18:05:35.448]                           if (inherits(master, c("SOCKnode", 
[18:05:35.448]                             "SOCK0node"))) {
[18:05:35.448]                             sendCondition <<- function(cond) {
[18:05:35.448]                               data <- list(type = "VALUE", value = cond, 
[18:05:35.448]                                 success = TRUE)
[18:05:35.448]                               parallel_sendData(master, data)
[18:05:35.448]                             }
[18:05:35.448]                             return(sendCondition)
[18:05:35.448]                           }
[18:05:35.448]                         }
[18:05:35.448]                         frame <- frame + 1L
[18:05:35.448]                         envir <- sys.frame(frame)
[18:05:35.448]                       }
[18:05:35.448]                     }
[18:05:35.448]                     sendCondition <<- function(cond) NULL
[18:05:35.448]                   }
[18:05:35.448]                 })
[18:05:35.448]                 withCallingHandlers({
[18:05:35.448]                   {
[18:05:35.448]                     b <- 2L
[18:05:35.448]                     plan_b <- future::plan("list")
[18:05:35.448]                     nested_b <- nested_a[-1]
[18:05:35.448]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:35.448]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:35.448]                       "sequential"))
[18:05:35.448]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:35.448]                       b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:35.448]                   }
[18:05:35.448]                 }, immediateCondition = function(cond) {
[18:05:35.448]                   sendCondition <- ...future.makeSendCondition()
[18:05:35.448]                   sendCondition(cond)
[18:05:35.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.448]                   {
[18:05:35.448]                     inherits <- base::inherits
[18:05:35.448]                     invokeRestart <- base::invokeRestart
[18:05:35.448]                     is.null <- base::is.null
[18:05:35.448]                     muffled <- FALSE
[18:05:35.448]                     if (inherits(cond, "message")) {
[18:05:35.448]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:35.448]                       if (muffled) 
[18:05:35.448]                         invokeRestart("muffleMessage")
[18:05:35.448]                     }
[18:05:35.448]                     else if (inherits(cond, "warning")) {
[18:05:35.448]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:35.448]                       if (muffled) 
[18:05:35.448]                         invokeRestart("muffleWarning")
[18:05:35.448]                     }
[18:05:35.448]                     else if (inherits(cond, "condition")) {
[18:05:35.448]                       if (!is.null(pattern)) {
[18:05:35.448]                         computeRestarts <- base::computeRestarts
[18:05:35.448]                         grepl <- base::grepl
[18:05:35.448]                         restarts <- computeRestarts(cond)
[18:05:35.448]                         for (restart in restarts) {
[18:05:35.448]                           name <- restart$name
[18:05:35.448]                           if (is.null(name)) 
[18:05:35.448]                             next
[18:05:35.448]                           if (!grepl(pattern, name)) 
[18:05:35.448]                             next
[18:05:35.448]                           invokeRestart(restart)
[18:05:35.448]                           muffled <- TRUE
[18:05:35.448]                           break
[18:05:35.448]                         }
[18:05:35.448]                       }
[18:05:35.448]                     }
[18:05:35.448]                     invisible(muffled)
[18:05:35.448]                   }
[18:05:35.448]                   muffleCondition(cond)
[18:05:35.448]                 })
[18:05:35.448]             }))
[18:05:35.448]             future::FutureResult(value = ...future.value$value, 
[18:05:35.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:35.448]                   ...future.rng), globalenv = if (FALSE) 
[18:05:35.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:35.448]                     ...future.globalenv.names))
[18:05:35.448]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:35.448]         }, condition = base::local({
[18:05:35.448]             c <- base::c
[18:05:35.448]             inherits <- base::inherits
[18:05:35.448]             invokeRestart <- base::invokeRestart
[18:05:35.448]             length <- base::length
[18:05:35.448]             list <- base::list
[18:05:35.448]             seq.int <- base::seq.int
[18:05:35.448]             signalCondition <- base::signalCondition
[18:05:35.448]             sys.calls <- base::sys.calls
[18:05:35.448]             `[[` <- base::`[[`
[18:05:35.448]             `+` <- base::`+`
[18:05:35.448]             `<<-` <- base::`<<-`
[18:05:35.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:35.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:35.448]                   3L)]
[18:05:35.448]             }
[18:05:35.448]             function(cond) {
[18:05:35.448]                 is_error <- inherits(cond, "error")
[18:05:35.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:35.448]                   NULL)
[18:05:35.448]                 if (is_error) {
[18:05:35.448]                   sessionInformation <- function() {
[18:05:35.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:35.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:35.448]                       search = base::search(), system = base::Sys.info())
[18:05:35.448]                   }
[18:05:35.448]                   ...future.conditions[[length(...future.conditions) + 
[18:05:35.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:35.448]                     cond$call), session = sessionInformation(), 
[18:05:35.448]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:35.448]                   signalCondition(cond)
[18:05:35.448]                 }
[18:05:35.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:35.448]                 "immediateCondition"))) {
[18:05:35.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:35.448]                   ...future.conditions[[length(...future.conditions) + 
[18:05:35.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:35.448]                   if (TRUE && !signal) {
[18:05:35.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.448]                     {
[18:05:35.448]                       inherits <- base::inherits
[18:05:35.448]                       invokeRestart <- base::invokeRestart
[18:05:35.448]                       is.null <- base::is.null
[18:05:35.448]                       muffled <- FALSE
[18:05:35.448]                       if (inherits(cond, "message")) {
[18:05:35.448]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:35.448]                         if (muffled) 
[18:05:35.448]                           invokeRestart("muffleMessage")
[18:05:35.448]                       }
[18:05:35.448]                       else if (inherits(cond, "warning")) {
[18:05:35.448]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:35.448]                         if (muffled) 
[18:05:35.448]                           invokeRestart("muffleWarning")
[18:05:35.448]                       }
[18:05:35.448]                       else if (inherits(cond, "condition")) {
[18:05:35.448]                         if (!is.null(pattern)) {
[18:05:35.448]                           computeRestarts <- base::computeRestarts
[18:05:35.448]                           grepl <- base::grepl
[18:05:35.448]                           restarts <- computeRestarts(cond)
[18:05:35.448]                           for (restart in restarts) {
[18:05:35.448]                             name <- restart$name
[18:05:35.448]                             if (is.null(name)) 
[18:05:35.448]                               next
[18:05:35.448]                             if (!grepl(pattern, name)) 
[18:05:35.448]                               next
[18:05:35.448]                             invokeRestart(restart)
[18:05:35.448]                             muffled <- TRUE
[18:05:35.448]                             break
[18:05:35.448]                           }
[18:05:35.448]                         }
[18:05:35.448]                       }
[18:05:35.448]                       invisible(muffled)
[18:05:35.448]                     }
[18:05:35.448]                     muffleCondition(cond, pattern = "^muffle")
[18:05:35.448]                   }
[18:05:35.448]                 }
[18:05:35.448]                 else {
[18:05:35.448]                   if (TRUE) {
[18:05:35.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.448]                     {
[18:05:35.448]                       inherits <- base::inherits
[18:05:35.448]                       invokeRestart <- base::invokeRestart
[18:05:35.448]                       is.null <- base::is.null
[18:05:35.448]                       muffled <- FALSE
[18:05:35.448]                       if (inherits(cond, "message")) {
[18:05:35.448]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:35.448]                         if (muffled) 
[18:05:35.448]                           invokeRestart("muffleMessage")
[18:05:35.448]                       }
[18:05:35.448]                       else if (inherits(cond, "warning")) {
[18:05:35.448]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:35.448]                         if (muffled) 
[18:05:35.448]                           invokeRestart("muffleWarning")
[18:05:35.448]                       }
[18:05:35.448]                       else if (inherits(cond, "condition")) {
[18:05:35.448]                         if (!is.null(pattern)) {
[18:05:35.448]                           computeRestarts <- base::computeRestarts
[18:05:35.448]                           grepl <- base::grepl
[18:05:35.448]                           restarts <- computeRestarts(cond)
[18:05:35.448]                           for (restart in restarts) {
[18:05:35.448]                             name <- restart$name
[18:05:35.448]                             if (is.null(name)) 
[18:05:35.448]                               next
[18:05:35.448]                             if (!grepl(pattern, name)) 
[18:05:35.448]                               next
[18:05:35.448]                             invokeRestart(restart)
[18:05:35.448]                             muffled <- TRUE
[18:05:35.448]                             break
[18:05:35.448]                           }
[18:05:35.448]                         }
[18:05:35.448]                       }
[18:05:35.448]                       invisible(muffled)
[18:05:35.448]                     }
[18:05:35.448]                     muffleCondition(cond, pattern = "^muffle")
[18:05:35.448]                   }
[18:05:35.448]                 }
[18:05:35.448]             }
[18:05:35.448]         }))
[18:05:35.448]     }, error = function(ex) {
[18:05:35.448]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:35.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:35.448]                 ...future.rng), started = ...future.startTime, 
[18:05:35.448]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:35.448]             version = "1.8"), class = "FutureResult")
[18:05:35.448]     }, finally = {
[18:05:35.448]         if (!identical(...future.workdir, getwd())) 
[18:05:35.448]             setwd(...future.workdir)
[18:05:35.448]         {
[18:05:35.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:35.448]                 ...future.oldOptions$nwarnings <- NULL
[18:05:35.448]             }
[18:05:35.448]             base::options(...future.oldOptions)
[18:05:35.448]             if (.Platform$OS.type == "windows") {
[18:05:35.448]                 old_names <- names(...future.oldEnvVars)
[18:05:35.448]                 envs <- base::Sys.getenv()
[18:05:35.448]                 names <- names(envs)
[18:05:35.448]                 common <- intersect(names, old_names)
[18:05:35.448]                 added <- setdiff(names, old_names)
[18:05:35.448]                 removed <- setdiff(old_names, names)
[18:05:35.448]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:35.448]                   envs[common]]
[18:05:35.448]                 NAMES <- toupper(changed)
[18:05:35.448]                 args <- list()
[18:05:35.448]                 for (kk in seq_along(NAMES)) {
[18:05:35.448]                   name <- changed[[kk]]
[18:05:35.448]                   NAME <- NAMES[[kk]]
[18:05:35.448]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.448]                     next
[18:05:35.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:35.448]                 }
[18:05:35.448]                 NAMES <- toupper(added)
[18:05:35.448]                 for (kk in seq_along(NAMES)) {
[18:05:35.448]                   name <- added[[kk]]
[18:05:35.448]                   NAME <- NAMES[[kk]]
[18:05:35.448]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.448]                     next
[18:05:35.448]                   args[[name]] <- ""
[18:05:35.448]                 }
[18:05:35.448]                 NAMES <- toupper(removed)
[18:05:35.448]                 for (kk in seq_along(NAMES)) {
[18:05:35.448]                   name <- removed[[kk]]
[18:05:35.448]                   NAME <- NAMES[[kk]]
[18:05:35.448]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.448]                     next
[18:05:35.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:35.448]                 }
[18:05:35.448]                 if (length(args) > 0) 
[18:05:35.448]                   base::do.call(base::Sys.setenv, args = args)
[18:05:35.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:35.448]             }
[18:05:35.448]             else {
[18:05:35.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:35.448]             }
[18:05:35.448]             {
[18:05:35.448]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:35.448]                   0L) {
[18:05:35.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:35.448]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:35.448]                   base::options(opts)
[18:05:35.448]                 }
[18:05:35.448]                 {
[18:05:35.448]                   {
[18:05:35.448]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:35.448]                     NULL
[18:05:35.448]                   }
[18:05:35.448]                   options(future.plan = NULL)
[18:05:35.448]                   if (is.na(NA_character_)) 
[18:05:35.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:35.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:35.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:35.448]                     .init = FALSE)
[18:05:35.448]                 }
[18:05:35.448]             }
[18:05:35.448]         }
[18:05:35.448]     })
[18:05:35.448]     if (TRUE) {
[18:05:35.448]         base::sink(type = "output", split = FALSE)
[18:05:35.448]         if (TRUE) {
[18:05:35.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:35.448]         }
[18:05:35.448]         else {
[18:05:35.448]             ...future.result["stdout"] <- base::list(NULL)
[18:05:35.448]         }
[18:05:35.448]         base::close(...future.stdout)
[18:05:35.448]         ...future.stdout <- NULL
[18:05:35.448]     }
[18:05:35.448]     ...future.result$conditions <- ...future.conditions
[18:05:35.448]     ...future.result$finished <- base::Sys.time()
[18:05:35.448]     ...future.result
[18:05:35.448] }
[18:05:35.747]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.546] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[18:05:35.747]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.546] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[18:05:35.748]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.547] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[18:05:35.748]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.548] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[18:05:35.748]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.549] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[18:05:35.749]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.550] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[18:05:35.749]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.591] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[18:05:35.749]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.592] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[18:05:35.750]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.594] MultisessionFuture started
[18:05:35.750]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.594] - Launch lazy future ... done
[18:05:35.750]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.595] run() for ‘MultisessionFuture’ ... done
[18:05:35.751]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.596] result() for ClusterFuture ...
[18:05:35.751]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.597] receiveMessageFromWorker() for ClusterFuture ...
[18:05:35.751]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.598] - Validating connection of MultisessionFuture
[18:05:35.752]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.706] - received message: FutureResult
[18:05:35.752]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.706] - Received FutureResult
[18:05:35.752]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.707] - Erased future from FutureRegistry
[18:05:35.753]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.707] result() for ClusterFuture ...
[18:05:35.753]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.707] - result already collected: FutureResult
[18:05:35.753]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.708] result() for ClusterFuture ... done
[18:05:35.754]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.708] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:35.754]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.708] result() for ClusterFuture ... done
[18:05:35.754]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.709] result() for ClusterFuture ...
[18:05:35.755]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.709] - result already collected: FutureResult
[18:05:35.755]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.709] result() for ClusterFuture ... done
[18:05:35.755] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:35.771] getGlobalsAndPackages() ...
[18:05:35.771] Searching for globals...
[18:05:35.774] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:35.775] Searching for globals ... DONE
[18:05:35.775] Resolving globals: FALSE
[18:05:35.776] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:35.777] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:35.777] - globals: [1] ‘data’
[18:05:35.778] - packages: [1] ‘future’
[18:05:35.778] getGlobalsAndPackages() ... DONE
[18:05:35.778] run() for ‘Future’ ...
[18:05:35.779] - state: ‘created’
[18:05:35.779] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:35.780] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:35.780] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:35.780]   - Field: ‘label’
[18:05:35.780]   - Field: ‘local’
[18:05:35.781]   - Field: ‘owner’
[18:05:35.781]   - Field: ‘envir’
[18:05:35.781]   - Field: ‘packages’
[18:05:35.781]   - Field: ‘gc’
[18:05:35.782]   - Field: ‘conditions’
[18:05:35.782]   - Field: ‘expr’
[18:05:35.782]   - Field: ‘uuid’
[18:05:35.782]   - Field: ‘seed’
[18:05:35.782]   - Field: ‘version’
[18:05:35.783]   - Field: ‘result’
[18:05:35.783]   - Field: ‘asynchronous’
[18:05:35.783]   - Field: ‘calls’
[18:05:35.783]   - Field: ‘globals’
[18:05:35.784]   - Field: ‘stdout’
[18:05:35.784]   - Field: ‘earlySignal’
[18:05:35.784]   - Field: ‘lazy’
[18:05:35.784]   - Field: ‘state’
[18:05:35.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:35.785] - Launch lazy future ...
[18:05:35.785] Packages needed by the future expression (n = 1): ‘future’
[18:05:35.786] Packages needed by future strategies (n = 1): ‘future’
[18:05:35.787] {
[18:05:35.787]     {
[18:05:35.787]         {
[18:05:35.787]             ...future.startTime <- base::Sys.time()
[18:05:35.787]             {
[18:05:35.787]                 {
[18:05:35.787]                   {
[18:05:35.787]                     {
[18:05:35.787]                       base::local({
[18:05:35.787]                         has_future <- base::requireNamespace("future", 
[18:05:35.787]                           quietly = TRUE)
[18:05:35.787]                         if (has_future) {
[18:05:35.787]                           ns <- base::getNamespace("future")
[18:05:35.787]                           version <- ns[[".package"]][["version"]]
[18:05:35.787]                           if (is.null(version)) 
[18:05:35.787]                             version <- utils::packageVersion("future")
[18:05:35.787]                         }
[18:05:35.787]                         else {
[18:05:35.787]                           version <- NULL
[18:05:35.787]                         }
[18:05:35.787]                         if (!has_future || version < "1.8.0") {
[18:05:35.787]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:35.787]                             "", base::R.version$version.string), 
[18:05:35.787]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:35.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:35.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:35.787]                               "release", "version")], collapse = " "), 
[18:05:35.787]                             hostname = base::Sys.info()[["nodename"]])
[18:05:35.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:35.787]                             info)
[18:05:35.787]                           info <- base::paste(info, collapse = "; ")
[18:05:35.787]                           if (!has_future) {
[18:05:35.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:35.787]                               info)
[18:05:35.787]                           }
[18:05:35.787]                           else {
[18:05:35.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:35.787]                               info, version)
[18:05:35.787]                           }
[18:05:35.787]                           base::stop(msg)
[18:05:35.787]                         }
[18:05:35.787]                       })
[18:05:35.787]                     }
[18:05:35.787]                     base::local({
[18:05:35.787]                       for (pkg in "future") {
[18:05:35.787]                         base::loadNamespace(pkg)
[18:05:35.787]                         base::library(pkg, character.only = TRUE)
[18:05:35.787]                       }
[18:05:35.787]                     })
[18:05:35.787]                   }
[18:05:35.787]                   ...future.strategy.old <- future::plan("list")
[18:05:35.787]                   options(future.plan = NULL)
[18:05:35.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:35.787]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:35.787]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:35.787]                     envir = parent.frame()) 
[18:05:35.787]                   {
[18:05:35.787]                     if (is.function(workers)) 
[18:05:35.787]                       workers <- workers()
[18:05:35.787]                     workers <- structure(as.integer(workers), 
[18:05:35.787]                       class = class(workers))
[18:05:35.787]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:35.787]                       workers >= 1)
[18:05:35.787]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:35.787]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:35.787]                     }
[18:05:35.787]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:35.787]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:35.787]                       envir = envir)
[18:05:35.787]                     if (!future$lazy) 
[18:05:35.787]                       future <- run(future)
[18:05:35.787]                     invisible(future)
[18:05:35.787]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:35.787]                 }
[18:05:35.787]                 ...future.workdir <- getwd()
[18:05:35.787]             }
[18:05:35.787]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:35.787]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:35.787]         }
[18:05:35.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:35.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:35.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:35.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:35.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:35.787]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:35.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:35.787]             base::names(...future.oldOptions))
[18:05:35.787]     }
[18:05:35.787]     if (FALSE) {
[18:05:35.787]     }
[18:05:35.787]     else {
[18:05:35.787]         if (TRUE) {
[18:05:35.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:35.787]                 open = "w")
[18:05:35.787]         }
[18:05:35.787]         else {
[18:05:35.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:35.787]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:35.787]         }
[18:05:35.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:35.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:35.787]             base::sink(type = "output", split = FALSE)
[18:05:35.787]             base::close(...future.stdout)
[18:05:35.787]         }, add = TRUE)
[18:05:35.787]     }
[18:05:35.787]     ...future.frame <- base::sys.nframe()
[18:05:35.787]     ...future.conditions <- base::list()
[18:05:35.787]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:35.787]     if (FALSE) {
[18:05:35.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:35.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:35.787]     }
[18:05:35.787]     ...future.result <- base::tryCatch({
[18:05:35.787]         base::withCallingHandlers({
[18:05:35.787]             ...future.value <- base::withVisible(base::local({
[18:05:35.787]                 value(future(subset(data, a == 2)))
[18:05:35.787]             }))
[18:05:35.787]             future::FutureResult(value = ...future.value$value, 
[18:05:35.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:35.787]                   ...future.rng), globalenv = if (FALSE) 
[18:05:35.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:35.787]                     ...future.globalenv.names))
[18:05:35.787]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:35.787]         }, condition = base::local({
[18:05:35.787]             c <- base::c
[18:05:35.787]             inherits <- base::inherits
[18:05:35.787]             invokeRestart <- base::invokeRestart
[18:05:35.787]             length <- base::length
[18:05:35.787]             list <- base::list
[18:05:35.787]             seq.int <- base::seq.int
[18:05:35.787]             signalCondition <- base::signalCondition
[18:05:35.787]             sys.calls <- base::sys.calls
[18:05:35.787]             `[[` <- base::`[[`
[18:05:35.787]             `+` <- base::`+`
[18:05:35.787]             `<<-` <- base::`<<-`
[18:05:35.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:35.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:35.787]                   3L)]
[18:05:35.787]             }
[18:05:35.787]             function(cond) {
[18:05:35.787]                 is_error <- inherits(cond, "error")
[18:05:35.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:35.787]                   NULL)
[18:05:35.787]                 if (is_error) {
[18:05:35.787]                   sessionInformation <- function() {
[18:05:35.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:35.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:35.787]                       search = base::search(), system = base::Sys.info())
[18:05:35.787]                   }
[18:05:35.787]                   ...future.conditions[[length(...future.conditions) + 
[18:05:35.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:35.787]                     cond$call), session = sessionInformation(), 
[18:05:35.787]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:35.787]                   signalCondition(cond)
[18:05:35.787]                 }
[18:05:35.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:35.787]                 "immediateCondition"))) {
[18:05:35.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:35.787]                   ...future.conditions[[length(...future.conditions) + 
[18:05:35.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:35.787]                   if (TRUE && !signal) {
[18:05:35.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.787]                     {
[18:05:35.787]                       inherits <- base::inherits
[18:05:35.787]                       invokeRestart <- base::invokeRestart
[18:05:35.787]                       is.null <- base::is.null
[18:05:35.787]                       muffled <- FALSE
[18:05:35.787]                       if (inherits(cond, "message")) {
[18:05:35.787]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:35.787]                         if (muffled) 
[18:05:35.787]                           invokeRestart("muffleMessage")
[18:05:35.787]                       }
[18:05:35.787]                       else if (inherits(cond, "warning")) {
[18:05:35.787]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:35.787]                         if (muffled) 
[18:05:35.787]                           invokeRestart("muffleWarning")
[18:05:35.787]                       }
[18:05:35.787]                       else if (inherits(cond, "condition")) {
[18:05:35.787]                         if (!is.null(pattern)) {
[18:05:35.787]                           computeRestarts <- base::computeRestarts
[18:05:35.787]                           grepl <- base::grepl
[18:05:35.787]                           restarts <- computeRestarts(cond)
[18:05:35.787]                           for (restart in restarts) {
[18:05:35.787]                             name <- restart$name
[18:05:35.787]                             if (is.null(name)) 
[18:05:35.787]                               next
[18:05:35.787]                             if (!grepl(pattern, name)) 
[18:05:35.787]                               next
[18:05:35.787]                             invokeRestart(restart)
[18:05:35.787]                             muffled <- TRUE
[18:05:35.787]                             break
[18:05:35.787]                           }
[18:05:35.787]                         }
[18:05:35.787]                       }
[18:05:35.787]                       invisible(muffled)
[18:05:35.787]                     }
[18:05:35.787]                     muffleCondition(cond, pattern = "^muffle")
[18:05:35.787]                   }
[18:05:35.787]                 }
[18:05:35.787]                 else {
[18:05:35.787]                   if (TRUE) {
[18:05:35.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.787]                     {
[18:05:35.787]                       inherits <- base::inherits
[18:05:35.787]                       invokeRestart <- base::invokeRestart
[18:05:35.787]                       is.null <- base::is.null
[18:05:35.787]                       muffled <- FALSE
[18:05:35.787]                       if (inherits(cond, "message")) {
[18:05:35.787]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:35.787]                         if (muffled) 
[18:05:35.787]                           invokeRestart("muffleMessage")
[18:05:35.787]                       }
[18:05:35.787]                       else if (inherits(cond, "warning")) {
[18:05:35.787]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:35.787]                         if (muffled) 
[18:05:35.787]                           invokeRestart("muffleWarning")
[18:05:35.787]                       }
[18:05:35.787]                       else if (inherits(cond, "condition")) {
[18:05:35.787]                         if (!is.null(pattern)) {
[18:05:35.787]                           computeRestarts <- base::computeRestarts
[18:05:35.787]                           grepl <- base::grepl
[18:05:35.787]                           restarts <- computeRestarts(cond)
[18:05:35.787]                           for (restart in restarts) {
[18:05:35.787]                             name <- restart$name
[18:05:35.787]                             if (is.null(name)) 
[18:05:35.787]                               next
[18:05:35.787]                             if (!grepl(pattern, name)) 
[18:05:35.787]                               next
[18:05:35.787]                             invokeRestart(restart)
[18:05:35.787]                             muffled <- TRUE
[18:05:35.787]                             break
[18:05:35.787]                           }
[18:05:35.787]                         }
[18:05:35.787]                       }
[18:05:35.787]                       invisible(muffled)
[18:05:35.787]                     }
[18:05:35.787]                     muffleCondition(cond, pattern = "^muffle")
[18:05:35.787]                   }
[18:05:35.787]                 }
[18:05:35.787]             }
[18:05:35.787]         }))
[18:05:35.787]     }, error = function(ex) {
[18:05:35.787]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:35.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:35.787]                 ...future.rng), started = ...future.startTime, 
[18:05:35.787]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:35.787]             version = "1.8"), class = "FutureResult")
[18:05:35.787]     }, finally = {
[18:05:35.787]         if (!identical(...future.workdir, getwd())) 
[18:05:35.787]             setwd(...future.workdir)
[18:05:35.787]         {
[18:05:35.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:35.787]                 ...future.oldOptions$nwarnings <- NULL
[18:05:35.787]             }
[18:05:35.787]             base::options(...future.oldOptions)
[18:05:35.787]             if (.Platform$OS.type == "windows") {
[18:05:35.787]                 old_names <- names(...future.oldEnvVars)
[18:05:35.787]                 envs <- base::Sys.getenv()
[18:05:35.787]                 names <- names(envs)
[18:05:35.787]                 common <- intersect(names, old_names)
[18:05:35.787]                 added <- setdiff(names, old_names)
[18:05:35.787]                 removed <- setdiff(old_names, names)
[18:05:35.787]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:35.787]                   envs[common]]
[18:05:35.787]                 NAMES <- toupper(changed)
[18:05:35.787]                 args <- list()
[18:05:35.787]                 for (kk in seq_along(NAMES)) {
[18:05:35.787]                   name <- changed[[kk]]
[18:05:35.787]                   NAME <- NAMES[[kk]]
[18:05:35.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.787]                     next
[18:05:35.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:35.787]                 }
[18:05:35.787]                 NAMES <- toupper(added)
[18:05:35.787]                 for (kk in seq_along(NAMES)) {
[18:05:35.787]                   name <- added[[kk]]
[18:05:35.787]                   NAME <- NAMES[[kk]]
[18:05:35.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.787]                     next
[18:05:35.787]                   args[[name]] <- ""
[18:05:35.787]                 }
[18:05:35.787]                 NAMES <- toupper(removed)
[18:05:35.787]                 for (kk in seq_along(NAMES)) {
[18:05:35.787]                   name <- removed[[kk]]
[18:05:35.787]                   NAME <- NAMES[[kk]]
[18:05:35.787]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.787]                     next
[18:05:35.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:35.787]                 }
[18:05:35.787]                 if (length(args) > 0) 
[18:05:35.787]                   base::do.call(base::Sys.setenv, args = args)
[18:05:35.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:35.787]             }
[18:05:35.787]             else {
[18:05:35.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:35.787]             }
[18:05:35.787]             {
[18:05:35.787]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:35.787]                   0L) {
[18:05:35.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:35.787]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:35.787]                   base::options(opts)
[18:05:35.787]                 }
[18:05:35.787]                 {
[18:05:35.787]                   {
[18:05:35.787]                     NULL
[18:05:35.787]                     RNGkind("Mersenne-Twister")
[18:05:35.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:35.787]                       inherits = FALSE)
[18:05:35.787]                   }
[18:05:35.787]                   options(future.plan = NULL)
[18:05:35.787]                   if (is.na(NA_character_)) 
[18:05:35.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:35.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:35.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:35.787]                     .init = FALSE)
[18:05:35.787]                 }
[18:05:35.787]             }
[18:05:35.787]         }
[18:05:35.787]     })
[18:05:35.787]     if (TRUE) {
[18:05:35.787]         base::sink(type = "output", split = FALSE)
[18:05:35.787]         if (TRUE) {
[18:05:35.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:35.787]         }
[18:05:35.787]         else {
[18:05:35.787]             ...future.result["stdout"] <- base::list(NULL)
[18:05:35.787]         }
[18:05:35.787]         base::close(...future.stdout)
[18:05:35.787]         ...future.stdout <- NULL
[18:05:35.787]     }
[18:05:35.787]     ...future.result$conditions <- ...future.conditions
[18:05:35.787]     ...future.result$finished <- base::Sys.time()
[18:05:35.787]     ...future.result
[18:05:35.787] }
[18:05:35.790] assign_globals() ...
[18:05:35.791] List of 1
[18:05:35.791]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:35.791]   ..$ a: int [1:3] 1 2 3
[18:05:35.791]   ..$ b: int [1:3] 3 2 1
[18:05:35.791]  - attr(*, "where")=List of 1
[18:05:35.791]   ..$ data:<environment: R_EmptyEnv> 
[18:05:35.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:35.791]  - attr(*, "resolved")= logi FALSE
[18:05:35.791]  - attr(*, "total_size")= num 128
[18:05:35.791]  - attr(*, "already-done")= logi TRUE
[18:05:35.802] - copied ‘data’ to environment
[18:05:35.802] assign_globals() ... done
[18:05:35.802] plan(): Setting new future strategy stack:
[18:05:35.803] List of future strategies:
[18:05:35.803] 1. multisession:
[18:05:35.803]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:35.803]    - tweaked: FALSE
[18:05:35.803]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.809] plan(): nbrOfWorkers() = 2
[18:05:35.929] plan(): Setting new future strategy stack:
[18:05:35.929] List of future strategies:
[18:05:35.929] 1. sequential:
[18:05:35.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:35.929]    - tweaked: FALSE
[18:05:35.929]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.929] 2. multisession:
[18:05:35.929]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:35.929]    - tweaked: FALSE
[18:05:35.929]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.931] plan(): nbrOfWorkers() = 1
[18:05:35.931] SequentialFuture started (and completed)
[18:05:35.931] signalConditions() ...
[18:05:35.931]  - include = ‘immediateCondition’
[18:05:35.932]  - exclude = 
[18:05:35.932]  - resignal = FALSE
[18:05:35.932]  - Number of conditions: 63
[18:05:35.932] signalConditions() ... done
[18:05:35.933] - Launch lazy future ... done
[18:05:35.933] run() for ‘SequentialFuture’ ... done
[18:05:35.933] signalConditions() ...
[18:05:35.933]  - include = ‘immediateCondition’
[18:05:35.934]  - exclude = 
[18:05:35.934]  - resignal = FALSE
[18:05:35.934]  - Number of conditions: 63
[18:05:35.934] signalConditions() ... done
[18:05:35.934] Future state: ‘finished’
[18:05:35.935] signalConditions() ...
[18:05:35.935]  - include = ‘condition’
[18:05:35.935]  - exclude = ‘immediateCondition’
[18:05:35.935]  - resignal = TRUE
[18:05:35.935]  - Number of conditions: 63
[18:05:35.936]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.810] getGlobalsAndPackages() ...
[18:05:35.936]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.810] Searching for globals...
[18:05:35.936]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.838] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:35.937]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.839] Searching for globals ... DONE
[18:05:35.937]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.839] Resolving globals: FALSE
[18:05:35.937]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.840] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:35.937]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.840] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:35.938]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.841] - globals: [1] ‘data’
[18:05:35.938]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.841] 
[18:05:35.938]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.841] getGlobalsAndPackages() ... DONE
[18:05:35.939]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.842] run() for ‘Future’ ...
[18:05:35.939]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.842] - state: ‘created’
[18:05:35.939]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:35.939]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:35.940]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:35.940]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.866]   - Field: ‘node’
[18:05:35.940]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.867]   - Field: ‘label’
[18:05:35.941]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.867]   - Field: ‘local’
[18:05:35.941]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.867]   - Field: ‘owner’
[18:05:35.941]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.867]   - Field: ‘envir’
[18:05:35.941]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.868]   - Field: ‘workers’
[18:05:35.942]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.868]   - Field: ‘packages’
[18:05:35.942]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.868]   - Field: ‘gc’
[18:05:35.942]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.868]   - Field: ‘conditions’
[18:05:35.942]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.869]   - Field: ‘persistent’
[18:05:35.943]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.869]   - Field: ‘expr’
[18:05:35.943]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.869]   - Field: ‘uuid’
[18:05:35.943]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.869]   - Field: ‘seed’
[18:05:35.944]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.869]   - Field: ‘version’
[18:05:35.944]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.870]   - Field: ‘result’
[18:05:35.944]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.870]   - Field: ‘asynchronous’
[18:05:35.944]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.870]   - Field: ‘calls’
[18:05:35.945]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.870]   - Field: ‘globals’
[18:05:35.945]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.871]   - Field: ‘stdout’
[18:05:35.945]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.871]   - Field: ‘earlySignal’
[18:05:35.945]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.871]   - Field: ‘lazy’
[18:05:35.946]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.871]   - Field: ‘state’
[18:05:35.946]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:35.946]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.872] - Launch lazy future ...
[18:05:35.947]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.872] Packages needed by the future expression (n = 0): <none>
[18:05:35.947]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.873] Packages needed by future strategies (n = 0): <none>
[18:05:35.947]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.874] {
[18:05:35.874]     {
[18:05:35.874]         {
[18:05:35.874]             ...future.startTime <- base::Sys.time()
[18:05:35.874]             {
[18:05:35.874]                 {
[18:05:35.874]                   {
[18:05:35.874]                     {
[18:05:35.874]                       base::local({
[18:05:35.874]                         has_future <- base::requireNamespace("future", 
[18:05:35.874]                           quietly = TRUE)
[18:05:35.874]                         if (has_future) {
[18:05:35.874]                           ns <- base::getNamespace("future")
[18:05:35.874]                           version <- ns[[".package"]][["version"]]
[18:05:35.874]                           if (is.null(version)) 
[18:05:35.874]                             version <- utils::packageVersion("future")
[18:05:35.874]                         }
[18:05:35.874]                         else {
[18:05:35.874]                           version <- NULL
[18:05:35.874]                         }
[18:05:35.874]                         if (!has_future || version < "1.8.0") {
[18:05:35.874]                           info <- base::c(r_version = base::gsub("R version ", 
[18:05:35.874]                             "", base::R.version$version.string), 
[18:05:35.874]                             platform = base::sprintf("%s (%s-bit)", 
[18:05:35.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:35.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:35.874]                               "release", "version")], collapse = " "), 
[18:05:35.874]                             hostname = base::Sys.info()[["nodename"]])
[18:05:35.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:05:35.874]                             info)
[18:05:35.874]                           info <- base::paste(info, collapse = "; ")
[18:05:35.874]                           if (!has_future) {
[18:05:35.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:35.874]                               info)
[18:05:35.874]                           }
[18:05:35.874]                           else {
[18:05:35.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:35.874]                               info, version)
[18:05:35.874]                           }
[18:05:35.874]                           base::stop(msg)
[18:05:35.874]                         }
[18:05:35.874]                       })
[18:05:35.874]                     }
[18:05:35.874]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:35.874]                     base::options(mc.cores = 1L)
[18:05:35.874]                   }
[18:05:35.874]                   ...future.strategy.old <- future::plan("list")
[18:05:35.874]                   options(future.plan = NULL)
[18:05:35.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:35.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:35.874]                 }
[18:05:35.874]                 ...future.workdir <- getwd()
[18:05:35.874]             }
[18:05:35.874]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:35.874]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:35.874]         }
[18:05:35.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:35.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:35.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:35.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:35.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:35.874]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:35.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:35.874]             base::names(...future.oldOptions))
[18:05:35.874]     }
[18:05:35.874]     if (FALSE) {
[18:05:35.874]     }
[18:05:35.874]     else {
[18:05:35.874]         if (TRUE) {
[18:05:35.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:35.874]                 open = "w")
[18:05:35.874]         }
[18:05:35.874]         else {
[18:05:35.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:35.874]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:35.874]         }
[18:05:35.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:35.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:35.874]             base::sink(type = "output", split = FALSE)
[18:05:35.874]             base::close(...future.stdout)
[18:05:35.874]         }, add = TRUE)
[18:05:35.874]     }
[18:05:35.874]     ...future.frame <- base::sys.nframe()
[18:05:35.874]     ...future.conditions <- base::list()
[18:05:35.874]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:35.874]     if (FALSE) {
[18:05:35.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:35.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:35.874]     }
[18:05:35.874]     ...future.result <- base::tryCatch({
[18:05:35.874]         base::withCallingHandlers({
[18:05:35.874]             ...future.value <- base::withVisible(base::local({
[18:05:35.874]                 ...future.makeSendCondition <- base::local({
[18:05:35.874]                   sendCondition <- NULL
[18:05:35.874]                   function(frame = 1L) {
[18:05:35.874]                     if (is.function(sendCondition)) 
[18:05:35.874]                       return(sendCondition)
[18:05:35.874]                     ns <- getNamespace("parallel")
[18:05:35.874]                     if (exists("sendData", mode = "function", 
[18:05:35.874]                       envir = ns)) {
[18:05:35.874]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:35.874]                         envir = ns)
[18:05:35.874]                       envir <- sys.frame(frame)
[18:05:35.874]                       master <- NULL
[18:05:35.874]                       while (!identical(envir, .GlobalEnv) && 
[18:05:35.874]                         !identical(envir, emptyenv())) {
[18:05:35.874]                         if (exists("master", mode = "list", envir = envir, 
[18:05:35.874]                           inherits = FALSE)) {
[18:05:35.874]                           master <- get("master", mode = "list", 
[18:05:35.874]                             envir = envir, inherits = FALSE)
[18:05:35.874]                           if (inherits(master, c("SOCKnode", 
[18:05:35.874]                             "SOCK0node"))) {
[18:05:35.874]                             sendCondition <<- function(cond) {
[18:05:35.874]                               data <- list(type = "VALUE", value = cond, 
[18:05:35.874]                                 success = TRUE)
[18:05:35.874]                               parallel_sendData(master, data)
[18:05:35.874]                             }
[18:05:35.874]                             return(sendCondition)
[18:05:35.874]                           }
[18:05:35.874]                         }
[18:05:35.874]                         frame <- frame + 1L
[18:05:35.874]                         envir <- sys.frame(frame)
[18:05:35.874]                       }
[18:05:35.874]                     }
[18:05:35.874]                     sendCondition <<- function(cond) NULL
[18:05:35.874]                   }
[18:05:35.874]                 })
[18:05:35.874]                 withCallingHandlers({
[18:05:35.874]                   subset(data, a == 2)
[18:05:35.874]                 }, immediateCondition = function(cond) {
[18:05:35.874]                   sendCondition <- ...future.makeSendCondition()
[18:05:35.874]                   sendCondition(cond)
[18:05:35.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.874]                   {
[18:05:35.874]                     inherits <- base::inherits
[18:05:35.874]                     invokeRestart <- base::invokeRestart
[18:05:35.874]                     is.null <- base::is.null
[18:05:35.874]                     muffled <- FALSE
[18:05:35.874]                     if (inherits(cond, "message")) {
[18:05:35.874]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:35.874]                       if (muffled) 
[18:05:35.874]                         invokeRestart("muffleMessage")
[18:05:35.874]                     }
[18:05:35.874]                     else if (inherits(cond, "warning")) {
[18:05:35.874]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:35.874]                       if (muffled) 
[18:05:35.874]                         invokeRestart("muffleWarning")
[18:05:35.874]                     }
[18:05:35.874]                     else if (inherits(cond, "condition")) {
[18:05:35.874]                       if (!is.null(pattern)) {
[18:05:35.874]                         computeRestarts <- base::computeRestarts
[18:05:35.874]                         grepl <- base::grepl
[18:05:35.874]                         restarts <- computeRestarts(cond)
[18:05:35.874]                         for (restart in restarts) {
[18:05:35.874]                           name <- restart$name
[18:05:35.874]                           if (is.null(name)) 
[18:05:35.874]                             next
[18:05:35.874]                           if (!grepl(pattern, name)) 
[18:05:35.874]                             next
[18:05:35.874]                           invokeRestart(restart)
[18:05:35.874]                           muffled <- TRUE
[18:05:35.874]                           break
[18:05:35.874]                         }
[18:05:35.874]                       }
[18:05:35.874]                     }
[18:05:35.874]                     invisible(muffled)
[18:05:35.874]                   }
[18:05:35.874]                   muffleCondition(cond)
[18:05:35.874]                 })
[18:05:35.874]             }))
[18:05:35.874]             future::FutureResult(value = ...future.value$value, 
[18:05:35.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:35.874]                   ...future.rng), globalenv = if (FALSE) 
[18:05:35.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:35.874]                     ...future.globalenv.names))
[18:05:35.874]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:35.874]         }, condition = base::local({
[18:05:35.874]             c <- base::c
[18:05:35.874]             inherits <- base::inherits
[18:05:35.874]             invokeRestart <- base::invokeRestart
[18:05:35.874]             length <- base::length
[18:05:35.874]             list <- base::list
[18:05:35.874]             seq.int <- base::seq.int
[18:05:35.874]             signalCondition <- base::signalCondition
[18:05:35.874]             sys.calls <- base::sys.calls
[18:05:35.874]             `[[` <- base::`[[`
[18:05:35.874]             `+` <- base::`+`
[18:05:35.874]             `<<-` <- base::`<<-`
[18:05:35.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:35.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:35.874]                   3L)]
[18:05:35.874]             }
[18:05:35.874]             function(cond) {
[18:05:35.874]                 is_error <- inherits(cond, "error")
[18:05:35.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:35.874]                   NULL)
[18:05:35.874]                 if (is_error) {
[18:05:35.874]                   sessionInformation <- function() {
[18:05:35.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:35.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:35.874]                       search = base::search(), system = base::Sys.info())
[18:05:35.874]                   }
[18:05:35.874]                   ...future.conditions[[length(...future.conditions) + 
[18:05:35.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:35.874]                     cond$call), session = sessionInformation(), 
[18:05:35.874]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:35.874]                   signalCondition(cond)
[18:05:35.874]                 }
[18:05:35.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:35.874]                 "immediateCondition"))) {
[18:05:35.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:35.874]                   ...future.conditions[[length(...future.conditions) + 
[18:05:35.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:35.874]                   if (TRUE && !signal) {
[18:05:35.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.874]                     {
[18:05:35.874]                       inherits <- base::inherits
[18:05:35.874]                       invokeRestart <- base::invokeRestart
[18:05:35.874]                       is.null <- base::is.null
[18:05:35.874]                       muffled <- FALSE
[18:05:35.874]                       if (inherits(cond, "message")) {
[18:05:35.874]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:35.874]                         if (muffled) 
[18:05:35.874]                           invokeRestart("muffleMessage")
[18:05:35.874]                       }
[18:05:35.874]                       else if (inherits(cond, "warning")) {
[18:05:35.874]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:35.874]                         if (muffled) 
[18:05:35.874]                           invokeRestart("muffleWarning")
[18:05:35.874]                       }
[18:05:35.874]                       else if (inherits(cond, "condition")) {
[18:05:35.874]                         if (!is.null(pattern)) {
[18:05:35.874]                           computeRestarts <- base::computeRestarts
[18:05:35.874]                           grepl <- base::grepl
[18:05:35.874]                           restarts <- computeRestarts(cond)
[18:05:35.874]                           for (restart in restarts) {
[18:05:35.874]                             name <- restart$name
[18:05:35.874]                             if (is.null(name)) 
[18:05:35.874]                               next
[18:05:35.874]                             if (!grepl(pattern, name)) 
[18:05:35.874]                               next
[18:05:35.874]                             invokeRestart(restart)
[18:05:35.874]                             muffled <- TRUE
[18:05:35.874]                             break
[18:05:35.874]                           }
[18:05:35.874]                         }
[18:05:35.874]                       }
[18:05:35.874]                       invisible(muffled)
[18:05:35.874]                     }
[18:05:35.874]                     muffleCondition(cond, pattern = "^muffle")
[18:05:35.874]                   }
[18:05:35.874]                 }
[18:05:35.874]                 else {
[18:05:35.874]                   if (TRUE) {
[18:05:35.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:35.874]                     {
[18:05:35.874]                       inherits <- base::inherits
[18:05:35.874]                       invokeRestart <- base::invokeRestart
[18:05:35.874]                       is.null <- base::is.null
[18:05:35.874]                       muffled <- FALSE
[18:05:35.874]                       if (inherits(cond, "message")) {
[18:05:35.874]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:35.874]                         if (muffled) 
[18:05:35.874]                           invokeRestart("muffleMessage")
[18:05:35.874]                       }
[18:05:35.874]                       else if (inherits(cond, "warning")) {
[18:05:35.874]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:35.874]                         if (muffled) 
[18:05:35.874]                           invokeRestart("muffleWarning")
[18:05:35.874]                       }
[18:05:35.874]                       else if (inherits(cond, "condition")) {
[18:05:35.874]                         if (!is.null(pattern)) {
[18:05:35.874]                           computeRestarts <- base::computeRestarts
[18:05:35.874]                           grepl <- base::grepl
[18:05:35.874]                           restarts <- computeRestarts(cond)
[18:05:35.874]                           for (restart in restarts) {
[18:05:35.874]                             name <- restart$name
[18:05:35.874]                             if (is.null(name)) 
[18:05:35.874]                               next
[18:05:35.874]                             if (!grepl(pattern, name)) 
[18:05:35.874]                               next
[18:05:35.874]                             invokeRestart(restart)
[18:05:35.874]                             muffled <- TRUE
[18:05:35.874]                             break
[18:05:35.874]                           }
[18:05:35.874]                         }
[18:05:35.874]                       }
[18:05:35.874]                       invisible(muffled)
[18:05:35.874]                     }
[18:05:35.874]                     muffleCondition(cond, pattern = "^muffle")
[18:05:35.874]                   }
[18:05:35.874]                 }
[18:05:35.874]             }
[18:05:35.874]         }))
[18:05:35.874]     }, error = function(ex) {
[18:05:35.874]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:35.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:35.874]                 ...future.rng), started = ...future.startTime, 
[18:05:35.874]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:35.874]             version = "1.8"), class = "FutureResult")
[18:05:35.874]     }, finally = {
[18:05:35.874]         if (!identical(...future.workdir, getwd())) 
[18:05:35.874]             setwd(...future.workdir)
[18:05:35.874]         {
[18:05:35.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:35.874]                 ...future.oldOptions$nwarnings <- NULL
[18:05:35.874]             }
[18:05:35.874]             base::options(...future.oldOptions)
[18:05:35.874]             if (.Platform$OS.type == "windows") {
[18:05:35.874]                 old_names <- names(...future.oldEnvVars)
[18:05:35.874]                 envs <- base::Sys.getenv()
[18:05:35.874]                 names <- names(envs)
[18:05:35.874]                 common <- intersect(names, old_names)
[18:05:35.874]                 added <- setdiff(names, old_names)
[18:05:35.874]                 removed <- setdiff(old_names, names)
[18:05:35.874]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:35.874]                   envs[common]]
[18:05:35.874]                 NAMES <- toupper(changed)
[18:05:35.874]                 args <- list()
[18:05:35.874]                 for (kk in seq_along(NAMES)) {
[18:05:35.874]                   name <- changed[[kk]]
[18:05:35.874]                   NAME <- NAMES[[kk]]
[18:05:35.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.874]                     next
[18:05:35.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:35.874]                 }
[18:05:35.874]                 NAMES <- toupper(added)
[18:05:35.874]                 for (kk in seq_along(NAMES)) {
[18:05:35.874]                   name <- added[[kk]]
[18:05:35.874]                   NAME <- NAMES[[kk]]
[18:05:35.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.874]                     next
[18:05:35.874]                   args[[name]] <- ""
[18:05:35.874]                 }
[18:05:35.874]                 NAMES <- toupper(removed)
[18:05:35.874]                 for (kk in seq_along(NAMES)) {
[18:05:35.874]                   name <- removed[[kk]]
[18:05:35.874]                   NAME <- NAMES[[kk]]
[18:05:35.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:35.874]                     next
[18:05:35.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:35.874]                 }
[18:05:35.874]                 if (length(args) > 0) 
[18:05:35.874]                   base::do.call(base::Sys.setenv, args = args)
[18:05:35.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:35.874]             }
[18:05:35.874]             else {
[18:05:35.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:35.874]             }
[18:05:35.874]             {
[18:05:35.874]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:35.874]                   0L) {
[18:05:35.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:35.874]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:35.874]                   base::options(opts)
[18:05:35.874]                 }
[18:05:35.874]                 {
[18:05:35.874]                   {
[18:05:35.874]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:35.874]                     NULL
[18:05:35.874]                   }
[18:05:35.874]                   options(future.plan = NULL)
[18:05:35.874]                   if (is.na(NA_character_)) 
[18:05:35.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:35.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:35.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:35.874]                     .init = FALSE)
[18:05:35.874]                 }
[18:05:35.874]             }
[18:05:35.874]         }
[18:05:35.874]     })
[18:05:35.874]     if (TRUE) {
[18:05:35.874]         base::sink(type = "output", split = FALSE)
[18:05:35.874]         if (TRUE) {
[18:05:35.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:35.874]         }
[18:05:35.874]         else {
[18:05:35.874]             ...future.result["stdout"] <- base::list(NULL)
[18:05:35.874]         }
[18:05:35.874]         base::close(...future.stdout)
[18:05:35.874]         ...future.stdout <- NULL
[18:05:35.874]     }
[18:05:35.874]     ...future.result$conditions <- ...future.conditions
[18:05:35.874]     ...future.result$finished <- base::Sys.time()
[18:05:35.874]     ...future.result
[18:05:35.874] }
[18:05:35.947]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.878] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[18:05:35.948]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.879] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[18:05:35.948]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.880] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[18:05:35.948]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.880] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[18:05:35.949]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.881] MultisessionFuture started
[18:05:35.949]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.881] - Launch lazy future ... done
[18:05:35.949]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.881] run() for ‘MultisessionFuture’ ... done
[18:05:35.949]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.882] result() for ClusterFuture ...
[18:05:35.950]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.882] receiveMessageFromWorker() for ClusterFuture ...
[18:05:35.950]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.882] - Validating connection of MultisessionFuture
[18:05:35.950]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.925] - received message: FutureResult
[18:05:35.950]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.926] - Received FutureResult
[18:05:35.951]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.926] - Erased future from FutureRegistry
[18:05:35.951]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.926] result() for ClusterFuture ...
[18:05:35.951]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.927] - result already collected: FutureResult
[18:05:35.952]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.927] result() for ClusterFuture ... done
[18:05:35.952]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.927] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:35.952]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.927] result() for ClusterFuture ... done
[18:05:35.952]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.928] result() for ClusterFuture ...
[18:05:35.953]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.928] - result already collected: FutureResult
[18:05:35.953]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:35.928] result() for ClusterFuture ... done
[18:05:35.953] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[18:05:35.954] plan(): Setting new future strategy stack:
[18:05:35.954] List of future strategies:
[18:05:35.954] 1. multicore:
[18:05:35.954]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:35.954]    - tweaked: FALSE
[18:05:35.954]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.954] 2. sequential:
[18:05:35.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:35.954]    - tweaked: FALSE
[18:05:35.954]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:35.967] plan(): nbrOfWorkers() = 2
[18:05:35.968] getGlobalsAndPackages() ...
[18:05:35.968] Searching for globals...
[18:05:36.011] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:36.012] Searching for globals ... DONE
[18:05:36.012] Resolving globals: FALSE
[18:05:36.014] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[18:05:36.015] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:36.015] - globals: [2] ‘nested’, ‘strategy2’
[18:05:36.015] - packages: [1] ‘future’
[18:05:36.015] getGlobalsAndPackages() ... DONE
[18:05:36.016] run() for ‘Future’ ...
[18:05:36.016] - state: ‘created’
[18:05:36.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.023] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:36.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:36.023]   - Field: ‘label’
[18:05:36.023]   - Field: ‘local’
[18:05:36.024]   - Field: ‘owner’
[18:05:36.024]   - Field: ‘envir’
[18:05:36.024]   - Field: ‘workers’
[18:05:36.024]   - Field: ‘packages’
[18:05:36.024]   - Field: ‘gc’
[18:05:36.025]   - Field: ‘job’
[18:05:36.025]   - Field: ‘conditions’
[18:05:36.025]   - Field: ‘expr’
[18:05:36.025]   - Field: ‘uuid’
[18:05:36.025]   - Field: ‘seed’
[18:05:36.026]   - Field: ‘version’
[18:05:36.026]   - Field: ‘result’
[18:05:36.026]   - Field: ‘asynchronous’
[18:05:36.026]   - Field: ‘calls’
[18:05:36.026]   - Field: ‘globals’
[18:05:36.026]   - Field: ‘stdout’
[18:05:36.027]   - Field: ‘earlySignal’
[18:05:36.027]   - Field: ‘lazy’
[18:05:36.027]   - Field: ‘state’
[18:05:36.027] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:36.027] - Launch lazy future ...
[18:05:36.028] Packages needed by the future expression (n = 1): ‘future’
[18:05:36.028] Packages needed by future strategies (n = 1): ‘future’
[18:05:36.029] {
[18:05:36.029]     {
[18:05:36.029]         {
[18:05:36.029]             ...future.startTime <- base::Sys.time()
[18:05:36.029]             {
[18:05:36.029]                 {
[18:05:36.029]                   {
[18:05:36.029]                     {
[18:05:36.029]                       {
[18:05:36.029]                         base::local({
[18:05:36.029]                           has_future <- base::requireNamespace("future", 
[18:05:36.029]                             quietly = TRUE)
[18:05:36.029]                           if (has_future) {
[18:05:36.029]                             ns <- base::getNamespace("future")
[18:05:36.029]                             version <- ns[[".package"]][["version"]]
[18:05:36.029]                             if (is.null(version)) 
[18:05:36.029]                               version <- utils::packageVersion("future")
[18:05:36.029]                           }
[18:05:36.029]                           else {
[18:05:36.029]                             version <- NULL
[18:05:36.029]                           }
[18:05:36.029]                           if (!has_future || version < "1.8.0") {
[18:05:36.029]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.029]                               "", base::R.version$version.string), 
[18:05:36.029]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:36.029]                                 base::R.version$platform, 8 * 
[18:05:36.029]                                   base::.Machine$sizeof.pointer), 
[18:05:36.029]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.029]                                 "release", "version")], collapse = " "), 
[18:05:36.029]                               hostname = base::Sys.info()[["nodename"]])
[18:05:36.029]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.029]                               info)
[18:05:36.029]                             info <- base::paste(info, collapse = "; ")
[18:05:36.029]                             if (!has_future) {
[18:05:36.029]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.029]                                 info)
[18:05:36.029]                             }
[18:05:36.029]                             else {
[18:05:36.029]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.029]                                 info, version)
[18:05:36.029]                             }
[18:05:36.029]                             base::stop(msg)
[18:05:36.029]                           }
[18:05:36.029]                         })
[18:05:36.029]                       }
[18:05:36.029]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:36.029]                       base::options(mc.cores = 1L)
[18:05:36.029]                     }
[18:05:36.029]                     base::local({
[18:05:36.029]                       for (pkg in "future") {
[18:05:36.029]                         base::loadNamespace(pkg)
[18:05:36.029]                         base::library(pkg, character.only = TRUE)
[18:05:36.029]                       }
[18:05:36.029]                     })
[18:05:36.029]                   }
[18:05:36.029]                   ...future.strategy.old <- future::plan("list")
[18:05:36.029]                   options(future.plan = NULL)
[18:05:36.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.029]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:36.029]                   {
[18:05:36.029]                     future <- SequentialFuture(..., envir = envir)
[18:05:36.029]                     if (!future$lazy) 
[18:05:36.029]                       future <- run(future)
[18:05:36.029]                     invisible(future)
[18:05:36.029]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:36.029]                 }
[18:05:36.029]                 ...future.workdir <- getwd()
[18:05:36.029]             }
[18:05:36.029]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.029]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.029]         }
[18:05:36.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.029]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.029]             base::names(...future.oldOptions))
[18:05:36.029]     }
[18:05:36.029]     if (FALSE) {
[18:05:36.029]     }
[18:05:36.029]     else {
[18:05:36.029]         if (TRUE) {
[18:05:36.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.029]                 open = "w")
[18:05:36.029]         }
[18:05:36.029]         else {
[18:05:36.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.029]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.029]         }
[18:05:36.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.029]             base::sink(type = "output", split = FALSE)
[18:05:36.029]             base::close(...future.stdout)
[18:05:36.029]         }, add = TRUE)
[18:05:36.029]     }
[18:05:36.029]     ...future.frame <- base::sys.nframe()
[18:05:36.029]     ...future.conditions <- base::list()
[18:05:36.029]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.029]     if (FALSE) {
[18:05:36.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.029]     }
[18:05:36.029]     ...future.result <- base::tryCatch({
[18:05:36.029]         base::withCallingHandlers({
[18:05:36.029]             ...future.value <- base::withVisible(base::local({
[18:05:36.029]                 withCallingHandlers({
[18:05:36.029]                   {
[18:05:36.029]                     a <- 1L
[18:05:36.029]                     plan_a <- unclass(future::plan("list"))
[18:05:36.029]                     nested_a <- nested[-1]
[18:05:36.029]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:36.029]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:36.029]                       strategy2))
[18:05:36.029]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:36.029]                       "init") <- NULL
[18:05:36.029]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:36.029]                       "init") <- NULL
[18:05:36.029]                     stopifnot(all.equal(plan_a, nested_a))
[18:05:36.029]                     y %<-% {
[18:05:36.029]                       b <- 2L
[18:05:36.029]                       plan_b <- future::plan("list")
[18:05:36.029]                       nested_b <- nested_a[-1]
[18:05:36.029]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:36.029]                         1L, inherits(plan_b[[1]], "future"), 
[18:05:36.029]                         inherits(future::plan("next"), "sequential"))
[18:05:36.029]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:36.029]                         b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:36.029]                     }
[18:05:36.029]                     y
[18:05:36.029]                   }
[18:05:36.029]                 }, immediateCondition = function(cond) {
[18:05:36.029]                   save_rds <- function (object, pathname, ...) 
[18:05:36.029]                   {
[18:05:36.029]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:36.029]                     if (file_test("-f", pathname_tmp)) {
[18:05:36.029]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.029]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:36.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.029]                         fi_tmp[["mtime"]])
[18:05:36.029]                     }
[18:05:36.029]                     tryCatch({
[18:05:36.029]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:36.029]                     }, error = function(ex) {
[18:05:36.029]                       msg <- conditionMessage(ex)
[18:05:36.029]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.029]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:36.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.029]                         fi_tmp[["mtime"]], msg)
[18:05:36.029]                       ex$message <- msg
[18:05:36.029]                       stop(ex)
[18:05:36.029]                     })
[18:05:36.029]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:36.029]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:36.029]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:36.029]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.029]                       fi <- file.info(pathname)
[18:05:36.029]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:36.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.029]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:36.029]                         fi[["size"]], fi[["mtime"]])
[18:05:36.029]                       stop(msg)
[18:05:36.029]                     }
[18:05:36.029]                     invisible(pathname)
[18:05:36.029]                   }
[18:05:36.029]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:36.029]                     rootPath = tempdir()) 
[18:05:36.029]                   {
[18:05:36.029]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:36.029]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:36.029]                       tmpdir = path, fileext = ".rds")
[18:05:36.029]                     save_rds(obj, file)
[18:05:36.029]                   }
[18:05:36.029]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:36.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.029]                   {
[18:05:36.029]                     inherits <- base::inherits
[18:05:36.029]                     invokeRestart <- base::invokeRestart
[18:05:36.029]                     is.null <- base::is.null
[18:05:36.029]                     muffled <- FALSE
[18:05:36.029]                     if (inherits(cond, "message")) {
[18:05:36.029]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:36.029]                       if (muffled) 
[18:05:36.029]                         invokeRestart("muffleMessage")
[18:05:36.029]                     }
[18:05:36.029]                     else if (inherits(cond, "warning")) {
[18:05:36.029]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:36.029]                       if (muffled) 
[18:05:36.029]                         invokeRestart("muffleWarning")
[18:05:36.029]                     }
[18:05:36.029]                     else if (inherits(cond, "condition")) {
[18:05:36.029]                       if (!is.null(pattern)) {
[18:05:36.029]                         computeRestarts <- base::computeRestarts
[18:05:36.029]                         grepl <- base::grepl
[18:05:36.029]                         restarts <- computeRestarts(cond)
[18:05:36.029]                         for (restart in restarts) {
[18:05:36.029]                           name <- restart$name
[18:05:36.029]                           if (is.null(name)) 
[18:05:36.029]                             next
[18:05:36.029]                           if (!grepl(pattern, name)) 
[18:05:36.029]                             next
[18:05:36.029]                           invokeRestart(restart)
[18:05:36.029]                           muffled <- TRUE
[18:05:36.029]                           break
[18:05:36.029]                         }
[18:05:36.029]                       }
[18:05:36.029]                     }
[18:05:36.029]                     invisible(muffled)
[18:05:36.029]                   }
[18:05:36.029]                   muffleCondition(cond)
[18:05:36.029]                 })
[18:05:36.029]             }))
[18:05:36.029]             future::FutureResult(value = ...future.value$value, 
[18:05:36.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.029]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.029]                     ...future.globalenv.names))
[18:05:36.029]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.029]         }, condition = base::local({
[18:05:36.029]             c <- base::c
[18:05:36.029]             inherits <- base::inherits
[18:05:36.029]             invokeRestart <- base::invokeRestart
[18:05:36.029]             length <- base::length
[18:05:36.029]             list <- base::list
[18:05:36.029]             seq.int <- base::seq.int
[18:05:36.029]             signalCondition <- base::signalCondition
[18:05:36.029]             sys.calls <- base::sys.calls
[18:05:36.029]             `[[` <- base::`[[`
[18:05:36.029]             `+` <- base::`+`
[18:05:36.029]             `<<-` <- base::`<<-`
[18:05:36.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.029]                   3L)]
[18:05:36.029]             }
[18:05:36.029]             function(cond) {
[18:05:36.029]                 is_error <- inherits(cond, "error")
[18:05:36.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.029]                   NULL)
[18:05:36.029]                 if (is_error) {
[18:05:36.029]                   sessionInformation <- function() {
[18:05:36.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.029]                       search = base::search(), system = base::Sys.info())
[18:05:36.029]                   }
[18:05:36.029]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.029]                     cond$call), session = sessionInformation(), 
[18:05:36.029]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.029]                   signalCondition(cond)
[18:05:36.029]                 }
[18:05:36.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.029]                 "immediateCondition"))) {
[18:05:36.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.029]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.029]                   if (TRUE && !signal) {
[18:05:36.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.029]                     {
[18:05:36.029]                       inherits <- base::inherits
[18:05:36.029]                       invokeRestart <- base::invokeRestart
[18:05:36.029]                       is.null <- base::is.null
[18:05:36.029]                       muffled <- FALSE
[18:05:36.029]                       if (inherits(cond, "message")) {
[18:05:36.029]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.029]                         if (muffled) 
[18:05:36.029]                           invokeRestart("muffleMessage")
[18:05:36.029]                       }
[18:05:36.029]                       else if (inherits(cond, "warning")) {
[18:05:36.029]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.029]                         if (muffled) 
[18:05:36.029]                           invokeRestart("muffleWarning")
[18:05:36.029]                       }
[18:05:36.029]                       else if (inherits(cond, "condition")) {
[18:05:36.029]                         if (!is.null(pattern)) {
[18:05:36.029]                           computeRestarts <- base::computeRestarts
[18:05:36.029]                           grepl <- base::grepl
[18:05:36.029]                           restarts <- computeRestarts(cond)
[18:05:36.029]                           for (restart in restarts) {
[18:05:36.029]                             name <- restart$name
[18:05:36.029]                             if (is.null(name)) 
[18:05:36.029]                               next
[18:05:36.029]                             if (!grepl(pattern, name)) 
[18:05:36.029]                               next
[18:05:36.029]                             invokeRestart(restart)
[18:05:36.029]                             muffled <- TRUE
[18:05:36.029]                             break
[18:05:36.029]                           }
[18:05:36.029]                         }
[18:05:36.029]                       }
[18:05:36.029]                       invisible(muffled)
[18:05:36.029]                     }
[18:05:36.029]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.029]                   }
[18:05:36.029]                 }
[18:05:36.029]                 else {
[18:05:36.029]                   if (TRUE) {
[18:05:36.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.029]                     {
[18:05:36.029]                       inherits <- base::inherits
[18:05:36.029]                       invokeRestart <- base::invokeRestart
[18:05:36.029]                       is.null <- base::is.null
[18:05:36.029]                       muffled <- FALSE
[18:05:36.029]                       if (inherits(cond, "message")) {
[18:05:36.029]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.029]                         if (muffled) 
[18:05:36.029]                           invokeRestart("muffleMessage")
[18:05:36.029]                       }
[18:05:36.029]                       else if (inherits(cond, "warning")) {
[18:05:36.029]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.029]                         if (muffled) 
[18:05:36.029]                           invokeRestart("muffleWarning")
[18:05:36.029]                       }
[18:05:36.029]                       else if (inherits(cond, "condition")) {
[18:05:36.029]                         if (!is.null(pattern)) {
[18:05:36.029]                           computeRestarts <- base::computeRestarts
[18:05:36.029]                           grepl <- base::grepl
[18:05:36.029]                           restarts <- computeRestarts(cond)
[18:05:36.029]                           for (restart in restarts) {
[18:05:36.029]                             name <- restart$name
[18:05:36.029]                             if (is.null(name)) 
[18:05:36.029]                               next
[18:05:36.029]                             if (!grepl(pattern, name)) 
[18:05:36.029]                               next
[18:05:36.029]                             invokeRestart(restart)
[18:05:36.029]                             muffled <- TRUE
[18:05:36.029]                             break
[18:05:36.029]                           }
[18:05:36.029]                         }
[18:05:36.029]                       }
[18:05:36.029]                       invisible(muffled)
[18:05:36.029]                     }
[18:05:36.029]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.029]                   }
[18:05:36.029]                 }
[18:05:36.029]             }
[18:05:36.029]         }))
[18:05:36.029]     }, error = function(ex) {
[18:05:36.029]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.029]                 ...future.rng), started = ...future.startTime, 
[18:05:36.029]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.029]             version = "1.8"), class = "FutureResult")
[18:05:36.029]     }, finally = {
[18:05:36.029]         if (!identical(...future.workdir, getwd())) 
[18:05:36.029]             setwd(...future.workdir)
[18:05:36.029]         {
[18:05:36.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.029]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.029]             }
[18:05:36.029]             base::options(...future.oldOptions)
[18:05:36.029]             if (.Platform$OS.type == "windows") {
[18:05:36.029]                 old_names <- names(...future.oldEnvVars)
[18:05:36.029]                 envs <- base::Sys.getenv()
[18:05:36.029]                 names <- names(envs)
[18:05:36.029]                 common <- intersect(names, old_names)
[18:05:36.029]                 added <- setdiff(names, old_names)
[18:05:36.029]                 removed <- setdiff(old_names, names)
[18:05:36.029]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.029]                   envs[common]]
[18:05:36.029]                 NAMES <- toupper(changed)
[18:05:36.029]                 args <- list()
[18:05:36.029]                 for (kk in seq_along(NAMES)) {
[18:05:36.029]                   name <- changed[[kk]]
[18:05:36.029]                   NAME <- NAMES[[kk]]
[18:05:36.029]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.029]                     next
[18:05:36.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.029]                 }
[18:05:36.029]                 NAMES <- toupper(added)
[18:05:36.029]                 for (kk in seq_along(NAMES)) {
[18:05:36.029]                   name <- added[[kk]]
[18:05:36.029]                   NAME <- NAMES[[kk]]
[18:05:36.029]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.029]                     next
[18:05:36.029]                   args[[name]] <- ""
[18:05:36.029]                 }
[18:05:36.029]                 NAMES <- toupper(removed)
[18:05:36.029]                 for (kk in seq_along(NAMES)) {
[18:05:36.029]                   name <- removed[[kk]]
[18:05:36.029]                   NAME <- NAMES[[kk]]
[18:05:36.029]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.029]                     next
[18:05:36.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.029]                 }
[18:05:36.029]                 if (length(args) > 0) 
[18:05:36.029]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.029]             }
[18:05:36.029]             else {
[18:05:36.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.029]             }
[18:05:36.029]             {
[18:05:36.029]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.029]                   0L) {
[18:05:36.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.029]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.029]                   base::options(opts)
[18:05:36.029]                 }
[18:05:36.029]                 {
[18:05:36.029]                   {
[18:05:36.029]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:36.029]                     NULL
[18:05:36.029]                   }
[18:05:36.029]                   options(future.plan = NULL)
[18:05:36.029]                   if (is.na(NA_character_)) 
[18:05:36.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.029]                     .init = FALSE)
[18:05:36.029]                 }
[18:05:36.029]             }
[18:05:36.029]         }
[18:05:36.029]     })
[18:05:36.029]     if (TRUE) {
[18:05:36.029]         base::sink(type = "output", split = FALSE)
[18:05:36.029]         if (TRUE) {
[18:05:36.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.029]         }
[18:05:36.029]         else {
[18:05:36.029]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.029]         }
[18:05:36.029]         base::close(...future.stdout)
[18:05:36.029]         ...future.stdout <- NULL
[18:05:36.029]     }
[18:05:36.029]     ...future.result$conditions <- ...future.conditions
[18:05:36.029]     ...future.result$finished <- base::Sys.time()
[18:05:36.029]     ...future.result
[18:05:36.029] }
[18:05:36.034] assign_globals() ...
[18:05:36.034] List of 2
[18:05:36.034]  $ nested   :List of 2
[18:05:36.034]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:36.034]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:36.034]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.034]   ..$ b:function (..., envir = parent.frame())  
[18:05:36.034]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:36.034]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.034]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:36.034]  $ strategy2: chr "sequential"
[18:05:36.034]  - attr(*, "where")=List of 2
[18:05:36.034]   ..$ nested   :<environment: R_EmptyEnv> 
[18:05:36.034]   ..$ strategy2:<environment: R_EmptyEnv> 
[18:05:36.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.034]  - attr(*, "resolved")= logi FALSE
[18:05:36.034]  - attr(*, "total_size")= num 59224
[18:05:36.034]  - attr(*, "already-done")= logi TRUE
[18:05:36.043] - copied ‘nested’ to environment
[18:05:36.043] - copied ‘strategy2’ to environment
[18:05:36.043] assign_globals() ... done
[18:05:36.044] requestCore(): workers = 2
[18:05:36.048] MulticoreFuture started
[18:05:36.049] - Launch lazy future ... done
[18:05:36.049] run() for ‘MulticoreFuture’ ... done
[18:05:36.050] result() for MulticoreFuture ...
[18:05:36.050] plan(): Setting new future strategy stack:
[18:05:36.051] List of future strategies:
[18:05:36.051] 1. sequential:
[18:05:36.051]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.051]    - tweaked: FALSE
[18:05:36.051]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.053] plan(): nbrOfWorkers() = 1
[18:05:36.134] plan(): Setting new future strategy stack:
[18:05:36.135] List of future strategies:
[18:05:36.135] 1. multicore:
[18:05:36.135]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.135]    - tweaked: FALSE
[18:05:36.135]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.135] 2. sequential:
[18:05:36.135]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.135]    - tweaked: FALSE
[18:05:36.135]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.144] plan(): nbrOfWorkers() = 2
[18:05:36.146] result() for MulticoreFuture ...
[18:05:36.149] result() for MulticoreFuture ... done
[18:05:36.149] signalConditions() ...
[18:05:36.150]  - include = ‘immediateCondition’
[18:05:36.152]  - exclude = 
[18:05:36.152]  - resignal = FALSE
[18:05:36.152]  - Number of conditions: 54
[18:05:36.153] signalConditions() ... done
[18:05:36.153] result() for MulticoreFuture ... done
[18:05:36.154] result() for MulticoreFuture ...
[18:05:36.154] result() for MulticoreFuture ... done
[18:05:36.154] signalConditions() ...
[18:05:36.154]  - include = ‘immediateCondition’
[18:05:36.155]  - exclude = 
[18:05:36.155]  - resignal = FALSE
[18:05:36.156]  - Number of conditions: 54
[18:05:36.156] signalConditions() ... done
[18:05:36.156] Future state: ‘finished’
[18:05:36.157] result() for MulticoreFuture ...
[18:05:36.157] result() for MulticoreFuture ... done
[18:05:36.157] signalConditions() ...
[18:05:36.157]  - include = ‘condition’
[18:05:36.158]  - exclude = ‘immediateCondition’
[18:05:36.158]  - resignal = TRUE
[18:05:36.158]  - Number of conditions: 54
[18:05:36.159]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.058] getGlobalsAndPackages() ...
[18:05:36.159]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.059] Searching for globals...
[18:05:36.159]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.083] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[18:05:36.160]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.083] Searching for globals ... DONE
[18:05:36.160]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.084] Resolving globals: FALSE
[18:05:36.160]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.087] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[18:05:36.161]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.089] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[18:05:36.161]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.089] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[18:05:36.161]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.089] 
[18:05:36.162]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.090] getGlobalsAndPackages() ... DONE
[18:05:36.162]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.091] run() for ‘Future’ ...
[18:05:36.163]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.092] - state: ‘created’
[18:05:36.163]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.092] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:36.163]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.093] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:36.164]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:36.164]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.094]   - Field: ‘label’
[18:05:36.164]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.095]   - Field: ‘local’
[18:05:36.165]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.095]   - Field: ‘owner’
[18:05:36.165]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.095]   - Field: ‘envir’
[18:05:36.165]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.096]   - Field: ‘packages’
[18:05:36.166]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.096]   - Field: ‘gc’
[18:05:36.166]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.096]   - Field: ‘conditions’
[18:05:36.167]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.097]   - Field: ‘expr’
[18:05:36.167]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.097]   - Field: ‘uuid’
[18:05:36.167]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.098]   - Field: ‘seed’
[18:05:36.168]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.098]   - Field: ‘version’
[18:05:36.168]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.098]   - Field: ‘result’
[18:05:36.169]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.099]   - Field: ‘asynchronous’
[18:05:36.169]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.099]   - Field: ‘calls’
[18:05:36.169]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.099]   - Field: ‘globals’
[18:05:36.170]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.100]   - Field: ‘stdout’
[18:05:36.170]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.100]   - Field: ‘earlySignal’
[18:05:36.170]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.101]   - Field: ‘lazy’
[18:05:36.171]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.101]   - Field: ‘state’
[18:05:36.171]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:36.171]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.102] - Launch lazy future ...
[18:05:36.172]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.102] Packages needed by the future expression (n = 0): <none>
[18:05:36.172]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.103] Packages needed by future strategies (n = 0): <none>
[18:05:36.172]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.104] {
[18:05:36.104]     {
[18:05:36.104]         {
[18:05:36.104]             ...future.startTime <- base::Sys.time()
[18:05:36.104]             {
[18:05:36.104]                 {
[18:05:36.104]                   {
[18:05:36.104]                     base::local({
[18:05:36.104]                       has_future <- base::requireNamespace("future", 
[18:05:36.104]                         quietly = TRUE)
[18:05:36.104]                       if (has_future) {
[18:05:36.104]                         ns <- base::getNamespace("future")
[18:05:36.104]                         version <- ns[[".package"]][["version"]]
[18:05:36.104]                         if (is.null(version)) 
[18:05:36.104]                           version <- utils::packageVersion("future")
[18:05:36.104]                       }
[18:05:36.104]                       else {
[18:05:36.104]                         version <- NULL
[18:05:36.104]                       }
[18:05:36.104]                       if (!has_future || version < "1.8.0") {
[18:05:36.104]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.104]                           "", base::R.version$version.string), 
[18:05:36.104]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:36.104]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:36.104]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.104]                             "release", "version")], collapse = " "), 
[18:05:36.104]                           hostname = base::Sys.info()[["nodename"]])
[18:05:36.104]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.104]                           info)
[18:05:36.104]                         info <- base::paste(info, collapse = "; ")
[18:05:36.104]                         if (!has_future) {
[18:05:36.104]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.104]                             info)
[18:05:36.104]                         }
[18:05:36.104]                         else {
[18:05:36.104]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.104]                             info, version)
[18:05:36.104]                         }
[18:05:36.104]                         base::stop(msg)
[18:05:36.104]                       }
[18:05:36.104]                     })
[18:05:36.104]                   }
[18:05:36.104]                   ...future.strategy.old <- future::plan("list")
[18:05:36.104]                   options(future.plan = NULL)
[18:05:36.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:36.104]                 }
[18:05:36.104]                 ...future.workdir <- getwd()
[18:05:36.104]             }
[18:05:36.104]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.104]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.104]         }
[18:05:36.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.104]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.104]             base::names(...future.oldOptions))
[18:05:36.104]     }
[18:05:36.104]     if (FALSE) {
[18:05:36.104]     }
[18:05:36.104]     else {
[18:05:36.104]         if (TRUE) {
[18:05:36.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.104]                 open = "w")
[18:05:36.104]         }
[18:05:36.104]         else {
[18:05:36.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.104]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.104]         }
[18:05:36.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.104]             base::sink(type = "output", split = FALSE)
[18:05:36.104]             base::close(...future.stdout)
[18:05:36.104]         }, add = TRUE)
[18:05:36.104]     }
[18:05:36.104]     ...future.frame <- base::sys.nframe()
[18:05:36.104]     ...future.conditions <- base::list()
[18:05:36.104]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.104]     if (FALSE) {
[18:05:36.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.104]     }
[18:05:36.104]     ...future.result <- base::tryCatch({
[18:05:36.104]         base::withCallingHandlers({
[18:05:36.104]             ...future.value <- base::withVisible(base::local({
[18:05:36.104]                 b <- 2L
[18:05:36.104]                 plan_b <- future::plan("list")
[18:05:36.104]                 nested_b <- nested_a[-1]
[18:05:36.104]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:36.104]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:36.104]                   "sequential"))
[18:05:36.104]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:36.104]                   b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:36.104]             }))
[18:05:36.104]             future::FutureResult(value = ...future.value$value, 
[18:05:36.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.104]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.104]                     ...future.globalenv.names))
[18:05:36.104]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.104]         }, condition = base::local({
[18:05:36.104]             c <- base::c
[18:05:36.104]             inherits <- base::inherits
[18:05:36.104]             invokeRestart <- base::invokeRestart
[18:05:36.104]             length <- base::length
[18:05:36.104]             list <- base::list
[18:05:36.104]             seq.int <- base::seq.int
[18:05:36.104]             signalCondition <- base::signalCondition
[18:05:36.104]             sys.calls <- base::sys.calls
[18:05:36.104]             `[[` <- base::`[[`
[18:05:36.104]             `+` <- base::`+`
[18:05:36.104]             `<<-` <- base::`<<-`
[18:05:36.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.104]                   3L)]
[18:05:36.104]             }
[18:05:36.104]             function(cond) {
[18:05:36.104]                 is_error <- inherits(cond, "error")
[18:05:36.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.104]                   NULL)
[18:05:36.104]                 if (is_error) {
[18:05:36.104]                   sessionInformation <- function() {
[18:05:36.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.104]                       search = base::search(), system = base::Sys.info())
[18:05:36.104]                   }
[18:05:36.104]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.104]                     cond$call), session = sessionInformation(), 
[18:05:36.104]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.104]                   signalCondition(cond)
[18:05:36.104]                 }
[18:05:36.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.104]                 "immediateCondition"))) {
[18:05:36.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.104]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.104]                   if (TRUE && !signal) {
[18:05:36.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.104]                     {
[18:05:36.104]                       inherits <- base::inherits
[18:05:36.104]                       invokeRestart <- base::invokeRestart
[18:05:36.104]                       is.null <- base::is.null
[18:05:36.104]                       muffled <- FALSE
[18:05:36.104]                       if (inherits(cond, "message")) {
[18:05:36.104]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.104]                         if (muffled) 
[18:05:36.104]                           invokeRestart("muffleMessage")
[18:05:36.104]                       }
[18:05:36.104]                       else if (inherits(cond, "warning")) {
[18:05:36.104]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.104]                         if (muffled) 
[18:05:36.104]                           invokeRestart("muffleWarning")
[18:05:36.104]                       }
[18:05:36.104]                       else if (inherits(cond, "condition")) {
[18:05:36.104]                         if (!is.null(pattern)) {
[18:05:36.104]                           computeRestarts <- base::computeRestarts
[18:05:36.104]                           grepl <- base::grepl
[18:05:36.104]                           restarts <- computeRestarts(cond)
[18:05:36.104]                           for (restart in restarts) {
[18:05:36.104]                             name <- restart$name
[18:05:36.104]                             if (is.null(name)) 
[18:05:36.104]                               next
[18:05:36.104]                             if (!grepl(pattern, name)) 
[18:05:36.104]                               next
[18:05:36.104]                             invokeRestart(restart)
[18:05:36.104]                             muffled <- TRUE
[18:05:36.104]                             break
[18:05:36.104]                           }
[18:05:36.104]                         }
[18:05:36.104]                       }
[18:05:36.104]                       invisible(muffled)
[18:05:36.104]                     }
[18:05:36.104]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.104]                   }
[18:05:36.104]                 }
[18:05:36.104]                 else {
[18:05:36.104]                   if (TRUE) {
[18:05:36.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.104]                     {
[18:05:36.104]                       inherits <- base::inherits
[18:05:36.104]                       invokeRestart <- base::invokeRestart
[18:05:36.104]                       is.null <- base::is.null
[18:05:36.104]                       muffled <- FALSE
[18:05:36.104]                       if (inherits(cond, "message")) {
[18:05:36.104]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.104]                         if (muffled) 
[18:05:36.104]                           invokeRestart("muffleMessage")
[18:05:36.104]                       }
[18:05:36.104]                       else if (inherits(cond, "warning")) {
[18:05:36.104]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.104]                         if (muffled) 
[18:05:36.104]                           invokeRestart("muffleWarning")
[18:05:36.104]                       }
[18:05:36.104]                       else if (inherits(cond, "condition")) {
[18:05:36.104]                         if (!is.null(pattern)) {
[18:05:36.104]                           computeRestarts <- base::computeRestarts
[18:05:36.104]                           grepl <- base::grepl
[18:05:36.104]                           restarts <- computeRestarts(cond)
[18:05:36.104]                           for (restart in restarts) {
[18:05:36.104]                             name <- restart$name
[18:05:36.104]                             if (is.null(name)) 
[18:05:36.104]                               next
[18:05:36.104]                             if (!grepl(pattern, name)) 
[18:05:36.104]                               next
[18:05:36.104]                             invokeRestart(restart)
[18:05:36.104]                             muffled <- TRUE
[18:05:36.104]                             break
[18:05:36.104]                           }
[18:05:36.104]                         }
[18:05:36.104]                       }
[18:05:36.104]                       invisible(muffled)
[18:05:36.104]                     }
[18:05:36.104]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.104]                   }
[18:05:36.104]                 }
[18:05:36.104]             }
[18:05:36.104]         }))
[18:05:36.104]     }, error = function(ex) {
[18:05:36.104]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.104]                 ...future.rng), started = ...future.startTime, 
[18:05:36.104]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.104]             version = "1.8"), class = "FutureResult")
[18:05:36.104]     }, finally = {
[18:05:36.104]         if (!identical(...future.workdir, getwd())) 
[18:05:36.104]             setwd(...future.workdir)
[18:05:36.104]         {
[18:05:36.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.104]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.104]             }
[18:05:36.104]             base::options(...future.oldOptions)
[18:05:36.104]             if (.Platform$OS.type == "windows") {
[18:05:36.104]                 old_names <- names(...future.oldEnvVars)
[18:05:36.104]                 envs <- base::Sys.getenv()
[18:05:36.104]                 names <- names(envs)
[18:05:36.104]                 common <- intersect(names, old_names)
[18:05:36.104]                 added <- setdiff(names, old_names)
[18:05:36.104]                 removed <- setdiff(old_names, names)
[18:05:36.104]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.104]                   envs[common]]
[18:05:36.104]                 NAMES <- toupper(changed)
[18:05:36.104]                 args <- list()
[18:05:36.104]                 for (kk in seq_along(NAMES)) {
[18:05:36.104]                   name <- changed[[kk]]
[18:05:36.104]                   NAME <- NAMES[[kk]]
[18:05:36.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.104]                     next
[18:05:36.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.104]                 }
[18:05:36.104]                 NAMES <- toupper(added)
[18:05:36.104]                 for (kk in seq_along(NAMES)) {
[18:05:36.104]                   name <- added[[kk]]
[18:05:36.104]                   NAME <- NAMES[[kk]]
[18:05:36.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.104]                     next
[18:05:36.104]                   args[[name]] <- ""
[18:05:36.104]                 }
[18:05:36.104]                 NAMES <- toupper(removed)
[18:05:36.104]                 for (kk in seq_along(NAMES)) {
[18:05:36.104]                   name <- removed[[kk]]
[18:05:36.104]                   NAME <- NAMES[[kk]]
[18:05:36.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.104]                     next
[18:05:36.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.104]                 }
[18:05:36.104]                 if (length(args) > 0) 
[18:05:36.104]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.104]             }
[18:05:36.104]             else {
[18:05:36.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.104]             }
[18:05:36.104]             {
[18:05:36.104]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.104]                   0L) {
[18:05:36.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.104]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.104]                   base::options(opts)
[18:05:36.104]                 }
[18:05:36.104]                 {
[18:05:36.104]                   {
[18:05:36.104]                     NULL
[18:05:36.104]                     RNGkind("Mersenne-Twister")
[18:05:36.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:36.104]                       inherits = FALSE)
[18:05:36.104]                   }
[18:05:36.104]                   options(future.plan = NULL)
[18:05:36.104]                   if (is.na(NA_character_)) 
[18:05:36.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.104]                     .init = FALSE)
[18:05:36.104]                 }
[18:05:36.104]             }
[18:05:36.104]         }
[18:05:36.104]     })
[18:05:36.104]     if (TRUE) {
[18:05:36.104]         base::sink(type = "output", split = FALSE)
[18:05:36.104]         if (TRUE) {
[18:05:36.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.104]         }
[18:05:36.104]         else {
[18:05:36.104]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.104]         }
[18:05:36.104]         base::close(...future.stdout)
[18:05:36.104]         ...future.stdout <- NULL
[18:05:36.104]     }
[18:05:36.104]     ...future.result$conditions <- ...future.conditions
[18:05:36.104]     ...future.result$finished <- base::Sys.time()
[18:05:36.104]     ...future.result
[18:05:36.104] }
[18:05:36.173]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.109] assign_globals() ...
[18:05:36.173]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.110] List of 3
[18:05:36.110]  $ nested_a:List of 1
[18:05:36.110]   ..$ b:function (..., envir = parent.frame())  
[18:05:36.110]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:36.110]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.110]  $ a       : int 1
[18:05:36.110]  $ plan_a  :List of 1
[18:05:36.110]   ..$ b:function (..., envir = parent.frame())  
[18:05:36.110]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[18:05:36.110]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.110]  - attr(*, "where")=List of 3
[18:05:36.110]   ..$ nested_a:<environment: R_EmptyEnv> 
[18:05:36.110]   ..$ a       :<environment: R_EmptyEnv> 
[18:05:36.110]   ..$ plan_a  :<environment: R_EmptyEnv> 
[18:05:36.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.110]  - attr(*, "resolved")= logi FALSE
[18:05:36.110]  - attr(*, "total_size")= num 23080
[18:05:36.110]  - attr(*, "already-done")= logi TRUE
[18:05:36.173]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.124] - copied ‘nested_a’ to environment
[18:05:36.174]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.124] - copied ‘a’ to environment
[18:05:36.174]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.125] - copied ‘plan_a’ to environment
[18:05:36.174]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.125] assign_globals() ... done
[18:05:36.175]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.126] plan(): Setting new future strategy stack:
[18:05:36.175]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.126] List of future strategies:
[18:05:36.126] 1. sequential:
[18:05:36.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.126]    - tweaked: FALSE
[18:05:36.126]    - call: NULL
[18:05:36.175]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.128] plan(): nbrOfWorkers() = 1
[18:05:36.176]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.130] plan(): Setting new future strategy stack:
[18:05:36.176]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.130] List of future strategies:
[18:05:36.130] 1. sequential:
[18:05:36.130]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.130]    - tweaked: FALSE
[18:05:36.130]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.177]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.132] plan(): nbrOfWorkers() = 1
[18:05:36.177]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.132] SequentialFuture started (and completed)
[18:05:36.177]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.133] - Launch lazy future ... done
[18:05:36.178]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.133] run() for ‘SequentialFuture’ ... done
[18:05:36.178] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:36.191] getGlobalsAndPackages() ...
[18:05:36.191] Searching for globals...
[18:05:36.194] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:36.195] Searching for globals ... DONE
[18:05:36.195] Resolving globals: FALSE
[18:05:36.196] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:36.197] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:36.197] - globals: [1] ‘data’
[18:05:36.198] - packages: [1] ‘future’
[18:05:36.198] getGlobalsAndPackages() ... DONE
[18:05:36.199] run() for ‘Future’ ...
[18:05:36.199] - state: ‘created’
[18:05:36.199] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.206] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:36.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:36.206]   - Field: ‘label’
[18:05:36.207]   - Field: ‘local’
[18:05:36.207]   - Field: ‘owner’
[18:05:36.207]   - Field: ‘envir’
[18:05:36.207]   - Field: ‘workers’
[18:05:36.208]   - Field: ‘packages’
[18:05:36.208]   - Field: ‘gc’
[18:05:36.208]   - Field: ‘job’
[18:05:36.208]   - Field: ‘conditions’
[18:05:36.209]   - Field: ‘expr’
[18:05:36.209]   - Field: ‘uuid’
[18:05:36.209]   - Field: ‘seed’
[18:05:36.209]   - Field: ‘version’
[18:05:36.209]   - Field: ‘result’
[18:05:36.210]   - Field: ‘asynchronous’
[18:05:36.210]   - Field: ‘calls’
[18:05:36.210]   - Field: ‘globals’
[18:05:36.210]   - Field: ‘stdout’
[18:05:36.211]   - Field: ‘earlySignal’
[18:05:36.211]   - Field: ‘lazy’
[18:05:36.211]   - Field: ‘state’
[18:05:36.211] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:36.212] - Launch lazy future ...
[18:05:36.212] Packages needed by the future expression (n = 1): ‘future’
[18:05:36.213] Packages needed by future strategies (n = 1): ‘future’
[18:05:36.214] {
[18:05:36.214]     {
[18:05:36.214]         {
[18:05:36.214]             ...future.startTime <- base::Sys.time()
[18:05:36.214]             {
[18:05:36.214]                 {
[18:05:36.214]                   {
[18:05:36.214]                     {
[18:05:36.214]                       {
[18:05:36.214]                         base::local({
[18:05:36.214]                           has_future <- base::requireNamespace("future", 
[18:05:36.214]                             quietly = TRUE)
[18:05:36.214]                           if (has_future) {
[18:05:36.214]                             ns <- base::getNamespace("future")
[18:05:36.214]                             version <- ns[[".package"]][["version"]]
[18:05:36.214]                             if (is.null(version)) 
[18:05:36.214]                               version <- utils::packageVersion("future")
[18:05:36.214]                           }
[18:05:36.214]                           else {
[18:05:36.214]                             version <- NULL
[18:05:36.214]                           }
[18:05:36.214]                           if (!has_future || version < "1.8.0") {
[18:05:36.214]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.214]                               "", base::R.version$version.string), 
[18:05:36.214]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:36.214]                                 base::R.version$platform, 8 * 
[18:05:36.214]                                   base::.Machine$sizeof.pointer), 
[18:05:36.214]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.214]                                 "release", "version")], collapse = " "), 
[18:05:36.214]                               hostname = base::Sys.info()[["nodename"]])
[18:05:36.214]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.214]                               info)
[18:05:36.214]                             info <- base::paste(info, collapse = "; ")
[18:05:36.214]                             if (!has_future) {
[18:05:36.214]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.214]                                 info)
[18:05:36.214]                             }
[18:05:36.214]                             else {
[18:05:36.214]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.214]                                 info, version)
[18:05:36.214]                             }
[18:05:36.214]                             base::stop(msg)
[18:05:36.214]                           }
[18:05:36.214]                         })
[18:05:36.214]                       }
[18:05:36.214]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:36.214]                       base::options(mc.cores = 1L)
[18:05:36.214]                     }
[18:05:36.214]                     base::local({
[18:05:36.214]                       for (pkg in "future") {
[18:05:36.214]                         base::loadNamespace(pkg)
[18:05:36.214]                         base::library(pkg, character.only = TRUE)
[18:05:36.214]                       }
[18:05:36.214]                     })
[18:05:36.214]                   }
[18:05:36.214]                   ...future.strategy.old <- future::plan("list")
[18:05:36.214]                   options(future.plan = NULL)
[18:05:36.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.214]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:36.214]                   {
[18:05:36.214]                     future <- SequentialFuture(..., envir = envir)
[18:05:36.214]                     if (!future$lazy) 
[18:05:36.214]                       future <- run(future)
[18:05:36.214]                     invisible(future)
[18:05:36.214]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:36.214]                 }
[18:05:36.214]                 ...future.workdir <- getwd()
[18:05:36.214]             }
[18:05:36.214]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.214]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.214]         }
[18:05:36.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.214]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.214]             base::names(...future.oldOptions))
[18:05:36.214]     }
[18:05:36.214]     if (FALSE) {
[18:05:36.214]     }
[18:05:36.214]     else {
[18:05:36.214]         if (TRUE) {
[18:05:36.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.214]                 open = "w")
[18:05:36.214]         }
[18:05:36.214]         else {
[18:05:36.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.214]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.214]         }
[18:05:36.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.214]             base::sink(type = "output", split = FALSE)
[18:05:36.214]             base::close(...future.stdout)
[18:05:36.214]         }, add = TRUE)
[18:05:36.214]     }
[18:05:36.214]     ...future.frame <- base::sys.nframe()
[18:05:36.214]     ...future.conditions <- base::list()
[18:05:36.214]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.214]     if (FALSE) {
[18:05:36.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.214]     }
[18:05:36.214]     ...future.result <- base::tryCatch({
[18:05:36.214]         base::withCallingHandlers({
[18:05:36.214]             ...future.value <- base::withVisible(base::local({
[18:05:36.214]                 withCallingHandlers({
[18:05:36.214]                   {
[18:05:36.214]                     value(future(subset(data, a == 2)))
[18:05:36.214]                   }
[18:05:36.214]                 }, immediateCondition = function(cond) {
[18:05:36.214]                   save_rds <- function (object, pathname, ...) 
[18:05:36.214]                   {
[18:05:36.214]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:36.214]                     if (file_test("-f", pathname_tmp)) {
[18:05:36.214]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.214]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:36.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.214]                         fi_tmp[["mtime"]])
[18:05:36.214]                     }
[18:05:36.214]                     tryCatch({
[18:05:36.214]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:36.214]                     }, error = function(ex) {
[18:05:36.214]                       msg <- conditionMessage(ex)
[18:05:36.214]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.214]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:36.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.214]                         fi_tmp[["mtime"]], msg)
[18:05:36.214]                       ex$message <- msg
[18:05:36.214]                       stop(ex)
[18:05:36.214]                     })
[18:05:36.214]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:36.214]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:36.214]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:36.214]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.214]                       fi <- file.info(pathname)
[18:05:36.214]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:36.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.214]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:36.214]                         fi[["size"]], fi[["mtime"]])
[18:05:36.214]                       stop(msg)
[18:05:36.214]                     }
[18:05:36.214]                     invisible(pathname)
[18:05:36.214]                   }
[18:05:36.214]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:36.214]                     rootPath = tempdir()) 
[18:05:36.214]                   {
[18:05:36.214]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:36.214]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:36.214]                       tmpdir = path, fileext = ".rds")
[18:05:36.214]                     save_rds(obj, file)
[18:05:36.214]                   }
[18:05:36.214]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:36.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.214]                   {
[18:05:36.214]                     inherits <- base::inherits
[18:05:36.214]                     invokeRestart <- base::invokeRestart
[18:05:36.214]                     is.null <- base::is.null
[18:05:36.214]                     muffled <- FALSE
[18:05:36.214]                     if (inherits(cond, "message")) {
[18:05:36.214]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:36.214]                       if (muffled) 
[18:05:36.214]                         invokeRestart("muffleMessage")
[18:05:36.214]                     }
[18:05:36.214]                     else if (inherits(cond, "warning")) {
[18:05:36.214]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:36.214]                       if (muffled) 
[18:05:36.214]                         invokeRestart("muffleWarning")
[18:05:36.214]                     }
[18:05:36.214]                     else if (inherits(cond, "condition")) {
[18:05:36.214]                       if (!is.null(pattern)) {
[18:05:36.214]                         computeRestarts <- base::computeRestarts
[18:05:36.214]                         grepl <- base::grepl
[18:05:36.214]                         restarts <- computeRestarts(cond)
[18:05:36.214]                         for (restart in restarts) {
[18:05:36.214]                           name <- restart$name
[18:05:36.214]                           if (is.null(name)) 
[18:05:36.214]                             next
[18:05:36.214]                           if (!grepl(pattern, name)) 
[18:05:36.214]                             next
[18:05:36.214]                           invokeRestart(restart)
[18:05:36.214]                           muffled <- TRUE
[18:05:36.214]                           break
[18:05:36.214]                         }
[18:05:36.214]                       }
[18:05:36.214]                     }
[18:05:36.214]                     invisible(muffled)
[18:05:36.214]                   }
[18:05:36.214]                   muffleCondition(cond)
[18:05:36.214]                 })
[18:05:36.214]             }))
[18:05:36.214]             future::FutureResult(value = ...future.value$value, 
[18:05:36.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.214]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.214]                     ...future.globalenv.names))
[18:05:36.214]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.214]         }, condition = base::local({
[18:05:36.214]             c <- base::c
[18:05:36.214]             inherits <- base::inherits
[18:05:36.214]             invokeRestart <- base::invokeRestart
[18:05:36.214]             length <- base::length
[18:05:36.214]             list <- base::list
[18:05:36.214]             seq.int <- base::seq.int
[18:05:36.214]             signalCondition <- base::signalCondition
[18:05:36.214]             sys.calls <- base::sys.calls
[18:05:36.214]             `[[` <- base::`[[`
[18:05:36.214]             `+` <- base::`+`
[18:05:36.214]             `<<-` <- base::`<<-`
[18:05:36.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.214]                   3L)]
[18:05:36.214]             }
[18:05:36.214]             function(cond) {
[18:05:36.214]                 is_error <- inherits(cond, "error")
[18:05:36.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.214]                   NULL)
[18:05:36.214]                 if (is_error) {
[18:05:36.214]                   sessionInformation <- function() {
[18:05:36.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.214]                       search = base::search(), system = base::Sys.info())
[18:05:36.214]                   }
[18:05:36.214]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.214]                     cond$call), session = sessionInformation(), 
[18:05:36.214]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.214]                   signalCondition(cond)
[18:05:36.214]                 }
[18:05:36.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.214]                 "immediateCondition"))) {
[18:05:36.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.214]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.214]                   if (TRUE && !signal) {
[18:05:36.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.214]                     {
[18:05:36.214]                       inherits <- base::inherits
[18:05:36.214]                       invokeRestart <- base::invokeRestart
[18:05:36.214]                       is.null <- base::is.null
[18:05:36.214]                       muffled <- FALSE
[18:05:36.214]                       if (inherits(cond, "message")) {
[18:05:36.214]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.214]                         if (muffled) 
[18:05:36.214]                           invokeRestart("muffleMessage")
[18:05:36.214]                       }
[18:05:36.214]                       else if (inherits(cond, "warning")) {
[18:05:36.214]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.214]                         if (muffled) 
[18:05:36.214]                           invokeRestart("muffleWarning")
[18:05:36.214]                       }
[18:05:36.214]                       else if (inherits(cond, "condition")) {
[18:05:36.214]                         if (!is.null(pattern)) {
[18:05:36.214]                           computeRestarts <- base::computeRestarts
[18:05:36.214]                           grepl <- base::grepl
[18:05:36.214]                           restarts <- computeRestarts(cond)
[18:05:36.214]                           for (restart in restarts) {
[18:05:36.214]                             name <- restart$name
[18:05:36.214]                             if (is.null(name)) 
[18:05:36.214]                               next
[18:05:36.214]                             if (!grepl(pattern, name)) 
[18:05:36.214]                               next
[18:05:36.214]                             invokeRestart(restart)
[18:05:36.214]                             muffled <- TRUE
[18:05:36.214]                             break
[18:05:36.214]                           }
[18:05:36.214]                         }
[18:05:36.214]                       }
[18:05:36.214]                       invisible(muffled)
[18:05:36.214]                     }
[18:05:36.214]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.214]                   }
[18:05:36.214]                 }
[18:05:36.214]                 else {
[18:05:36.214]                   if (TRUE) {
[18:05:36.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.214]                     {
[18:05:36.214]                       inherits <- base::inherits
[18:05:36.214]                       invokeRestart <- base::invokeRestart
[18:05:36.214]                       is.null <- base::is.null
[18:05:36.214]                       muffled <- FALSE
[18:05:36.214]                       if (inherits(cond, "message")) {
[18:05:36.214]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.214]                         if (muffled) 
[18:05:36.214]                           invokeRestart("muffleMessage")
[18:05:36.214]                       }
[18:05:36.214]                       else if (inherits(cond, "warning")) {
[18:05:36.214]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.214]                         if (muffled) 
[18:05:36.214]                           invokeRestart("muffleWarning")
[18:05:36.214]                       }
[18:05:36.214]                       else if (inherits(cond, "condition")) {
[18:05:36.214]                         if (!is.null(pattern)) {
[18:05:36.214]                           computeRestarts <- base::computeRestarts
[18:05:36.214]                           grepl <- base::grepl
[18:05:36.214]                           restarts <- computeRestarts(cond)
[18:05:36.214]                           for (restart in restarts) {
[18:05:36.214]                             name <- restart$name
[18:05:36.214]                             if (is.null(name)) 
[18:05:36.214]                               next
[18:05:36.214]                             if (!grepl(pattern, name)) 
[18:05:36.214]                               next
[18:05:36.214]                             invokeRestart(restart)
[18:05:36.214]                             muffled <- TRUE
[18:05:36.214]                             break
[18:05:36.214]                           }
[18:05:36.214]                         }
[18:05:36.214]                       }
[18:05:36.214]                       invisible(muffled)
[18:05:36.214]                     }
[18:05:36.214]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.214]                   }
[18:05:36.214]                 }
[18:05:36.214]             }
[18:05:36.214]         }))
[18:05:36.214]     }, error = function(ex) {
[18:05:36.214]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.214]                 ...future.rng), started = ...future.startTime, 
[18:05:36.214]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.214]             version = "1.8"), class = "FutureResult")
[18:05:36.214]     }, finally = {
[18:05:36.214]         if (!identical(...future.workdir, getwd())) 
[18:05:36.214]             setwd(...future.workdir)
[18:05:36.214]         {
[18:05:36.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.214]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.214]             }
[18:05:36.214]             base::options(...future.oldOptions)
[18:05:36.214]             if (.Platform$OS.type == "windows") {
[18:05:36.214]                 old_names <- names(...future.oldEnvVars)
[18:05:36.214]                 envs <- base::Sys.getenv()
[18:05:36.214]                 names <- names(envs)
[18:05:36.214]                 common <- intersect(names, old_names)
[18:05:36.214]                 added <- setdiff(names, old_names)
[18:05:36.214]                 removed <- setdiff(old_names, names)
[18:05:36.214]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.214]                   envs[common]]
[18:05:36.214]                 NAMES <- toupper(changed)
[18:05:36.214]                 args <- list()
[18:05:36.214]                 for (kk in seq_along(NAMES)) {
[18:05:36.214]                   name <- changed[[kk]]
[18:05:36.214]                   NAME <- NAMES[[kk]]
[18:05:36.214]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.214]                     next
[18:05:36.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.214]                 }
[18:05:36.214]                 NAMES <- toupper(added)
[18:05:36.214]                 for (kk in seq_along(NAMES)) {
[18:05:36.214]                   name <- added[[kk]]
[18:05:36.214]                   NAME <- NAMES[[kk]]
[18:05:36.214]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.214]                     next
[18:05:36.214]                   args[[name]] <- ""
[18:05:36.214]                 }
[18:05:36.214]                 NAMES <- toupper(removed)
[18:05:36.214]                 for (kk in seq_along(NAMES)) {
[18:05:36.214]                   name <- removed[[kk]]
[18:05:36.214]                   NAME <- NAMES[[kk]]
[18:05:36.214]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.214]                     next
[18:05:36.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.214]                 }
[18:05:36.214]                 if (length(args) > 0) 
[18:05:36.214]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.214]             }
[18:05:36.214]             else {
[18:05:36.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.214]             }
[18:05:36.214]             {
[18:05:36.214]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.214]                   0L) {
[18:05:36.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.214]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.214]                   base::options(opts)
[18:05:36.214]                 }
[18:05:36.214]                 {
[18:05:36.214]                   {
[18:05:36.214]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:36.214]                     NULL
[18:05:36.214]                   }
[18:05:36.214]                   options(future.plan = NULL)
[18:05:36.214]                   if (is.na(NA_character_)) 
[18:05:36.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.214]                     .init = FALSE)
[18:05:36.214]                 }
[18:05:36.214]             }
[18:05:36.214]         }
[18:05:36.214]     })
[18:05:36.214]     if (TRUE) {
[18:05:36.214]         base::sink(type = "output", split = FALSE)
[18:05:36.214]         if (TRUE) {
[18:05:36.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.214]         }
[18:05:36.214]         else {
[18:05:36.214]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.214]         }
[18:05:36.214]         base::close(...future.stdout)
[18:05:36.214]         ...future.stdout <- NULL
[18:05:36.214]     }
[18:05:36.214]     ...future.result$conditions <- ...future.conditions
[18:05:36.214]     ...future.result$finished <- base::Sys.time()
[18:05:36.214]     ...future.result
[18:05:36.214] }
[18:05:36.219] assign_globals() ...
[18:05:36.220] List of 1
[18:05:36.220]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:36.220]   ..$ a: int [1:3] 1 2 3
[18:05:36.220]   ..$ b: int [1:3] 3 2 1
[18:05:36.220]  - attr(*, "where")=List of 1
[18:05:36.220]   ..$ data:<environment: R_EmptyEnv> 
[18:05:36.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.220]  - attr(*, "resolved")= logi FALSE
[18:05:36.220]  - attr(*, "total_size")= num 128
[18:05:36.220]  - attr(*, "already-done")= logi TRUE
[18:05:36.228] - copied ‘data’ to environment
[18:05:36.228] assign_globals() ... done
[18:05:36.229] requestCore(): workers = 2
[18:05:36.235] MulticoreFuture started
[18:05:36.236] - Launch lazy future ... done
[18:05:36.236] run() for ‘MulticoreFuture’ ... done
[18:05:36.239] result() for MulticoreFuture ...
[18:05:36.238] plan(): Setting new future strategy stack:
[18:05:36.241] List of future strategies:
[18:05:36.241] 1. sequential:
[18:05:36.241]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.241]    - tweaked: FALSE
[18:05:36.241]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.243] plan(): nbrOfWorkers() = 1
[18:05:36.299] plan(): Setting new future strategy stack:
[18:05:36.299] List of future strategies:
[18:05:36.299] 1. multicore:
[18:05:36.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.299]    - tweaked: FALSE
[18:05:36.299]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.299] 2. sequential:
[18:05:36.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.299]    - tweaked: FALSE
[18:05:36.299]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.308] plan(): nbrOfWorkers() = 2
[18:05:36.312] result() for MulticoreFuture ...
[18:05:36.313] result() for MulticoreFuture ... done
[18:05:36.313] signalConditions() ...
[18:05:36.313]  - include = ‘immediateCondition’
[18:05:36.313]  - exclude = 
[18:05:36.314]  - resignal = FALSE
[18:05:36.314]  - Number of conditions: 52
[18:05:36.316] signalConditions() ... done
[18:05:36.317] result() for MulticoreFuture ... done
[18:05:36.317] result() for MulticoreFuture ...
[18:05:36.317] result() for MulticoreFuture ... done
[18:05:36.317] signalConditions() ...
[18:05:36.318]  - include = ‘immediateCondition’
[18:05:36.318]  - exclude = 
[18:05:36.318]  - resignal = FALSE
[18:05:36.318]  - Number of conditions: 52
[18:05:36.319] signalConditions() ... done
[18:05:36.319] Future state: ‘finished’
[18:05:36.319] result() for MulticoreFuture ...
[18:05:36.320] result() for MulticoreFuture ... done
[18:05:36.320] signalConditions() ...
[18:05:36.320]  - include = ‘condition’
[18:05:36.321]  - exclude = ‘immediateCondition’
[18:05:36.321]  - resignal = TRUE
[18:05:36.321]  - Number of conditions: 52
[18:05:36.321]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.245] getGlobalsAndPackages() ...
[18:05:36.322]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.246] Searching for globals...
[18:05:36.322]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.250] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:36.322]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.251] Searching for globals ... DONE
[18:05:36.323]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.251] Resolving globals: FALSE
[18:05:36.323]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.254] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:36.324]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.255] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:36.324]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.256] - globals: [1] ‘data’
[18:05:36.324]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.256] 
[18:05:36.325]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.257] getGlobalsAndPackages() ... DONE
[18:05:36.325]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.258] run() for ‘Future’ ...
[18:05:36.325]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.259] - state: ‘created’
[18:05:36.326]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.259] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:05:36.326]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.261] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:36.326]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:36.327]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.261]   - Field: ‘label’
[18:05:36.327]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.262]   - Field: ‘local’
[18:05:36.327]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.262]   - Field: ‘owner’
[18:05:36.328]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.263]   - Field: ‘envir’
[18:05:36.330]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.263]   - Field: ‘packages’
[18:05:36.331]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.263]   - Field: ‘gc’
[18:05:36.333]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.264]   - Field: ‘conditions’
[18:05:36.334]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.264]   - Field: ‘expr’
[18:05:36.338]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.264]   - Field: ‘uuid’
[18:05:36.338]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.265]   - Field: ‘seed’
[18:05:36.339]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.265]   - Field: ‘version’
[18:05:36.339]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.266]   - Field: ‘result’
[18:05:36.339]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.266]   - Field: ‘asynchronous’
[18:05:36.346]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.266]   - Field: ‘calls’
[18:05:36.347]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.267]   - Field: ‘globals’
[18:05:36.349]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.267]   - Field: ‘stdout’
[18:05:36.352]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.267]   - Field: ‘earlySignal’
[18:05:36.353]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.268]   - Field: ‘lazy’
[18:05:36.353]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.268]   - Field: ‘state’
[18:05:36.353]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:36.354]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.269] - Launch lazy future ...
[18:05:36.357]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.270] Packages needed by the future expression (n = 0): <none>
[18:05:36.358]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.270] Packages needed by future strategies (n = 0): <none>
[18:05:36.358]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.272] {
[18:05:36.272]     {
[18:05:36.272]         {
[18:05:36.272]             ...future.startTime <- base::Sys.time()
[18:05:36.272]             {
[18:05:36.272]                 {
[18:05:36.272]                   {
[18:05:36.272]                     base::local({
[18:05:36.272]                       has_future <- base::requireNamespace("future", 
[18:05:36.272]                         quietly = TRUE)
[18:05:36.272]                       if (has_future) {
[18:05:36.272]                         ns <- base::getNamespace("future")
[18:05:36.272]                         version <- ns[[".package"]][["version"]]
[18:05:36.272]                         if (is.null(version)) 
[18:05:36.272]                           version <- utils::packageVersion("future")
[18:05:36.272]                       }
[18:05:36.272]                       else {
[18:05:36.272]                         version <- NULL
[18:05:36.272]                       }
[18:05:36.272]                       if (!has_future || version < "1.8.0") {
[18:05:36.272]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.272]                           "", base::R.version$version.string), 
[18:05:36.272]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:36.272]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:36.272]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.272]                             "release", "version")], collapse = " "), 
[18:05:36.272]                           hostname = base::Sys.info()[["nodename"]])
[18:05:36.272]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.272]                           info)
[18:05:36.272]                         info <- base::paste(info, collapse = "; ")
[18:05:36.272]                         if (!has_future) {
[18:05:36.272]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.272]                             info)
[18:05:36.272]                         }
[18:05:36.272]                         else {
[18:05:36.272]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.272]                             info, version)
[18:05:36.272]                         }
[18:05:36.272]                         base::stop(msg)
[18:05:36.272]                       }
[18:05:36.272]                     })
[18:05:36.272]                   }
[18:05:36.272]                   ...future.strategy.old <- future::plan("list")
[18:05:36.272]                   options(future.plan = NULL)
[18:05:36.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:36.272]                 }
[18:05:36.272]                 ...future.workdir <- getwd()
[18:05:36.272]             }
[18:05:36.272]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.272]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.272]         }
[18:05:36.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.272]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.272]             base::names(...future.oldOptions))
[18:05:36.272]     }
[18:05:36.272]     if (FALSE) {
[18:05:36.272]     }
[18:05:36.272]     else {
[18:05:36.272]         if (TRUE) {
[18:05:36.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.272]                 open = "w")
[18:05:36.272]         }
[18:05:36.272]         else {
[18:05:36.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.272]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.272]         }
[18:05:36.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.272]             base::sink(type = "output", split = FALSE)
[18:05:36.272]             base::close(...future.stdout)
[18:05:36.272]         }, add = TRUE)
[18:05:36.272]     }
[18:05:36.272]     ...future.frame <- base::sys.nframe()
[18:05:36.272]     ...future.conditions <- base::list()
[18:05:36.272]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.272]     if (FALSE) {
[18:05:36.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.272]     }
[18:05:36.272]     ...future.result <- base::tryCatch({
[18:05:36.272]         base::withCallingHandlers({
[18:05:36.272]             ...future.value <- base::withVisible(base::local(subset(data, 
[18:05:36.272]                 a == 2)))
[18:05:36.272]             future::FutureResult(value = ...future.value$value, 
[18:05:36.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.272]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.272]                     ...future.globalenv.names))
[18:05:36.272]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.272]         }, condition = base::local({
[18:05:36.272]             c <- base::c
[18:05:36.272]             inherits <- base::inherits
[18:05:36.272]             invokeRestart <- base::invokeRestart
[18:05:36.272]             length <- base::length
[18:05:36.272]             list <- base::list
[18:05:36.272]             seq.int <- base::seq.int
[18:05:36.272]             signalCondition <- base::signalCondition
[18:05:36.272]             sys.calls <- base::sys.calls
[18:05:36.272]             `[[` <- base::`[[`
[18:05:36.272]             `+` <- base::`+`
[18:05:36.272]             `<<-` <- base::`<<-`
[18:05:36.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.272]                   3L)]
[18:05:36.272]             }
[18:05:36.272]             function(cond) {
[18:05:36.272]                 is_error <- inherits(cond, "error")
[18:05:36.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.272]                   NULL)
[18:05:36.272]                 if (is_error) {
[18:05:36.272]                   sessionInformation <- function() {
[18:05:36.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.272]                       search = base::search(), system = base::Sys.info())
[18:05:36.272]                   }
[18:05:36.272]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.272]                     cond$call), session = sessionInformation(), 
[18:05:36.272]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.272]                   signalCondition(cond)
[18:05:36.272]                 }
[18:05:36.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.272]                 "immediateCondition"))) {
[18:05:36.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.272]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.272]                   if (TRUE && !signal) {
[18:05:36.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.272]                     {
[18:05:36.272]                       inherits <- base::inherits
[18:05:36.272]                       invokeRestart <- base::invokeRestart
[18:05:36.272]                       is.null <- base::is.null
[18:05:36.272]                       muffled <- FALSE
[18:05:36.272]                       if (inherits(cond, "message")) {
[18:05:36.272]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.272]                         if (muffled) 
[18:05:36.272]                           invokeRestart("muffleMessage")
[18:05:36.272]                       }
[18:05:36.272]                       else if (inherits(cond, "warning")) {
[18:05:36.272]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.272]                         if (muffled) 
[18:05:36.272]                           invokeRestart("muffleWarning")
[18:05:36.272]                       }
[18:05:36.272]                       else if (inherits(cond, "condition")) {
[18:05:36.272]                         if (!is.null(pattern)) {
[18:05:36.272]                           computeRestarts <- base::computeRestarts
[18:05:36.272]                           grepl <- base::grepl
[18:05:36.272]                           restarts <- computeRestarts(cond)
[18:05:36.272]                           for (restart in restarts) {
[18:05:36.272]                             name <- restart$name
[18:05:36.272]                             if (is.null(name)) 
[18:05:36.272]                               next
[18:05:36.272]                             if (!grepl(pattern, name)) 
[18:05:36.272]                               next
[18:05:36.272]                             invokeRestart(restart)
[18:05:36.272]                             muffled <- TRUE
[18:05:36.272]                             break
[18:05:36.272]                           }
[18:05:36.272]                         }
[18:05:36.272]                       }
[18:05:36.272]                       invisible(muffled)
[18:05:36.272]                     }
[18:05:36.272]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.272]                   }
[18:05:36.272]                 }
[18:05:36.272]                 else {
[18:05:36.272]                   if (TRUE) {
[18:05:36.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.272]                     {
[18:05:36.272]                       inherits <- base::inherits
[18:05:36.272]                       invokeRestart <- base::invokeRestart
[18:05:36.272]                       is.null <- base::is.null
[18:05:36.272]                       muffled <- FALSE
[18:05:36.272]                       if (inherits(cond, "message")) {
[18:05:36.272]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.272]                         if (muffled) 
[18:05:36.272]                           invokeRestart("muffleMessage")
[18:05:36.272]                       }
[18:05:36.272]                       else if (inherits(cond, "warning")) {
[18:05:36.272]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.272]                         if (muffled) 
[18:05:36.272]                           invokeRestart("muffleWarning")
[18:05:36.272]                       }
[18:05:36.272]                       else if (inherits(cond, "condition")) {
[18:05:36.272]                         if (!is.null(pattern)) {
[18:05:36.272]                           computeRestarts <- base::computeRestarts
[18:05:36.272]                           grepl <- base::grepl
[18:05:36.272]                           restarts <- computeRestarts(cond)
[18:05:36.272]                           for (restart in restarts) {
[18:05:36.272]                             name <- restart$name
[18:05:36.272]                             if (is.null(name)) 
[18:05:36.272]                               next
[18:05:36.272]                             if (!grepl(pattern, name)) 
[18:05:36.272]                               next
[18:05:36.272]                             invokeRestart(restart)
[18:05:36.272]                             muffled <- TRUE
[18:05:36.272]                             break
[18:05:36.272]                           }
[18:05:36.272]                         }
[18:05:36.272]                       }
[18:05:36.272]                       invisible(muffled)
[18:05:36.272]                     }
[18:05:36.272]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.272]                   }
[18:05:36.272]                 }
[18:05:36.272]             }
[18:05:36.272]         }))
[18:05:36.272]     }, error = function(ex) {
[18:05:36.272]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.272]                 ...future.rng), started = ...future.startTime, 
[18:05:36.272]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.272]             version = "1.8"), class = "FutureResult")
[18:05:36.272]     }, finally = {
[18:05:36.272]         if (!identical(...future.workdir, getwd())) 
[18:05:36.272]             setwd(...future.workdir)
[18:05:36.272]         {
[18:05:36.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.272]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.272]             }
[18:05:36.272]             base::options(...future.oldOptions)
[18:05:36.272]             if (.Platform$OS.type == "windows") {
[18:05:36.272]                 old_names <- names(...future.oldEnvVars)
[18:05:36.272]                 envs <- base::Sys.getenv()
[18:05:36.272]                 names <- names(envs)
[18:05:36.272]                 common <- intersect(names, old_names)
[18:05:36.272]                 added <- setdiff(names, old_names)
[18:05:36.272]                 removed <- setdiff(old_names, names)
[18:05:36.272]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.272]                   envs[common]]
[18:05:36.272]                 NAMES <- toupper(changed)
[18:05:36.272]                 args <- list()
[18:05:36.272]                 for (kk in seq_along(NAMES)) {
[18:05:36.272]                   name <- changed[[kk]]
[18:05:36.272]                   NAME <- NAMES[[kk]]
[18:05:36.272]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.272]                     next
[18:05:36.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.272]                 }
[18:05:36.272]                 NAMES <- toupper(added)
[18:05:36.272]                 for (kk in seq_along(NAMES)) {
[18:05:36.272]                   name <- added[[kk]]
[18:05:36.272]                   NAME <- NAMES[[kk]]
[18:05:36.272]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.272]                     next
[18:05:36.272]                   args[[name]] <- ""
[18:05:36.272]                 }
[18:05:36.272]                 NAMES <- toupper(removed)
[18:05:36.272]                 for (kk in seq_along(NAMES)) {
[18:05:36.272]                   name <- removed[[kk]]
[18:05:36.272]                   NAME <- NAMES[[kk]]
[18:05:36.272]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.272]                     next
[18:05:36.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.272]                 }
[18:05:36.272]                 if (length(args) > 0) 
[18:05:36.272]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.272]             }
[18:05:36.272]             else {
[18:05:36.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.272]             }
[18:05:36.272]             {
[18:05:36.272]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.272]                   0L) {
[18:05:36.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.272]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.272]                   base::options(opts)
[18:05:36.272]                 }
[18:05:36.272]                 {
[18:05:36.272]                   {
[18:05:36.272]                     NULL
[18:05:36.272]                     RNGkind("Mersenne-Twister")
[18:05:36.272]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:36.272]                       inherits = FALSE)
[18:05:36.272]                   }
[18:05:36.272]                   options(future.plan = NULL)
[18:05:36.272]                   if (is.na(NA_character_)) 
[18:05:36.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.272]                     .init = FALSE)
[18:05:36.272]                 }
[18:05:36.272]             }
[18:05:36.272]         }
[18:05:36.272]     })
[18:05:36.272]     if (TRUE) {
[18:05:36.272]         base::sink(type = "output", split = FALSE)
[18:05:36.272]         if (TRUE) {
[18:05:36.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.272]         }
[18:05:36.272]         else {
[18:05:36.272]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.272]         }
[18:05:36.272]         base::close(...future.stdout)
[18:05:36.272]         ...future.stdout <- NULL
[18:05:36.272]     }
[18:05:36.272]     ...future.result$conditions <- ...future.conditions
[18:05:36.272]     ...future.result$finished <- base::Sys.time()
[18:05:36.272]     ...future.result
[18:05:36.272] }
[18:05:36.359]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.277] assign_globals() ...
[18:05:36.359]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.277] List of 1
[18:05:36.277]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:36.277]   ..$ a: int [1:3] 1 2 3
[18:05:36.277]   ..$ b: int [1:3] 3 2 1
[18:05:36.277]  - attr(*, "where")=List of 1
[18:05:36.277]   ..$ data:<environment: R_EmptyEnv> 
[18:05:36.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.277]  - attr(*, "resolved")= logi FALSE
[18:05:36.277]  - attr(*, "total_size")= num 128
[18:05:36.277]  - attr(*, "already-done")= logi TRUE
[18:05:36.360]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.288] - copied ‘data’ to environment
[18:05:36.360]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.289] assign_globals() ... done
[18:05:36.360]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.290] plan(): Setting new future strategy stack:
[18:05:36.361]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.290] List of future strategies:
[18:05:36.290] 1. sequential:
[18:05:36.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.290]    - tweaked: FALSE
[18:05:36.290]    - call: NULL
[18:05:36.361]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.291] plan(): nbrOfWorkers() = 1
[18:05:36.362]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.294] plan(): Setting new future strategy stack:
[18:05:36.362]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.294] List of future strategies:
[18:05:36.294] 1. sequential:
[18:05:36.294]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.294]    - tweaked: FALSE
[18:05:36.294]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.363]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.296] plan(): nbrOfWorkers() = 1
[18:05:36.363]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.296] SequentialFuture started (and completed)
[18:05:36.363]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.297] - Launch lazy future ... done
[18:05:36.364]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.297] run() for ‘SequentialFuture’ ... done
[18:05:36.364] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[18:05:36.365] plan(): Setting new future strategy stack:
[18:05:36.365] List of future strategies:
[18:05:36.365] 1. multicore:
[18:05:36.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.365]    - tweaked: FALSE
[18:05:36.365]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.365] 2. multicore:
[18:05:36.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.365]    - tweaked: FALSE
[18:05:36.365]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.374] plan(): nbrOfWorkers() = 2
[18:05:36.375] getGlobalsAndPackages() ...
[18:05:36.375] Searching for globals...
[18:05:36.425] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:36.425] Searching for globals ... DONE
[18:05:36.426] Resolving globals: FALSE
[18:05:36.428] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[18:05:36.429] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:36.429] - globals: [2] ‘nested’, ‘strategy2’
[18:05:36.429] - packages: [1] ‘future’
[18:05:36.430] getGlobalsAndPackages() ... DONE
[18:05:36.430] run() for ‘Future’ ...
[18:05:36.430] - state: ‘created’
[18:05:36.431] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.437] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:36.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:36.438]   - Field: ‘label’
[18:05:36.438]   - Field: ‘local’
[18:05:36.438]   - Field: ‘owner’
[18:05:36.438]   - Field: ‘envir’
[18:05:36.439]   - Field: ‘workers’
[18:05:36.439]   - Field: ‘packages’
[18:05:36.439]   - Field: ‘gc’
[18:05:36.439]   - Field: ‘job’
[18:05:36.440]   - Field: ‘conditions’
[18:05:36.440]   - Field: ‘expr’
[18:05:36.440]   - Field: ‘uuid’
[18:05:36.440]   - Field: ‘seed’
[18:05:36.440]   - Field: ‘version’
[18:05:36.441]   - Field: ‘result’
[18:05:36.441]   - Field: ‘asynchronous’
[18:05:36.441]   - Field: ‘calls’
[18:05:36.441]   - Field: ‘globals’
[18:05:36.442]   - Field: ‘stdout’
[18:05:36.442]   - Field: ‘earlySignal’
[18:05:36.442]   - Field: ‘lazy’
[18:05:36.442]   - Field: ‘state’
[18:05:36.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:36.443] - Launch lazy future ...
[18:05:36.443] Packages needed by the future expression (n = 1): ‘future’
[18:05:36.444] Packages needed by future strategies (n = 1): ‘future’
[18:05:36.445] {
[18:05:36.445]     {
[18:05:36.445]         {
[18:05:36.445]             ...future.startTime <- base::Sys.time()
[18:05:36.445]             {
[18:05:36.445]                 {
[18:05:36.445]                   {
[18:05:36.445]                     {
[18:05:36.445]                       {
[18:05:36.445]                         base::local({
[18:05:36.445]                           has_future <- base::requireNamespace("future", 
[18:05:36.445]                             quietly = TRUE)
[18:05:36.445]                           if (has_future) {
[18:05:36.445]                             ns <- base::getNamespace("future")
[18:05:36.445]                             version <- ns[[".package"]][["version"]]
[18:05:36.445]                             if (is.null(version)) 
[18:05:36.445]                               version <- utils::packageVersion("future")
[18:05:36.445]                           }
[18:05:36.445]                           else {
[18:05:36.445]                             version <- NULL
[18:05:36.445]                           }
[18:05:36.445]                           if (!has_future || version < "1.8.0") {
[18:05:36.445]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.445]                               "", base::R.version$version.string), 
[18:05:36.445]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:36.445]                                 base::R.version$platform, 8 * 
[18:05:36.445]                                   base::.Machine$sizeof.pointer), 
[18:05:36.445]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.445]                                 "release", "version")], collapse = " "), 
[18:05:36.445]                               hostname = base::Sys.info()[["nodename"]])
[18:05:36.445]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.445]                               info)
[18:05:36.445]                             info <- base::paste(info, collapse = "; ")
[18:05:36.445]                             if (!has_future) {
[18:05:36.445]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.445]                                 info)
[18:05:36.445]                             }
[18:05:36.445]                             else {
[18:05:36.445]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.445]                                 info, version)
[18:05:36.445]                             }
[18:05:36.445]                             base::stop(msg)
[18:05:36.445]                           }
[18:05:36.445]                         })
[18:05:36.445]                       }
[18:05:36.445]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:36.445]                       base::options(mc.cores = 1L)
[18:05:36.445]                     }
[18:05:36.445]                     base::local({
[18:05:36.445]                       for (pkg in "future") {
[18:05:36.445]                         base::loadNamespace(pkg)
[18:05:36.445]                         base::library(pkg, character.only = TRUE)
[18:05:36.445]                       }
[18:05:36.445]                     })
[18:05:36.445]                   }
[18:05:36.445]                   ...future.strategy.old <- future::plan("list")
[18:05:36.445]                   options(future.plan = NULL)
[18:05:36.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.445]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:36.445]                     envir = parent.frame()) 
[18:05:36.445]                   {
[18:05:36.445]                     default_workers <- missing(workers)
[18:05:36.445]                     if (is.function(workers)) 
[18:05:36.445]                       workers <- workers()
[18:05:36.445]                     workers <- structure(as.integer(workers), 
[18:05:36.445]                       class = class(workers))
[18:05:36.445]                     stop_if_not(is.finite(workers), workers >= 
[18:05:36.445]                       1L)
[18:05:36.445]                     if ((workers == 1L && !inherits(workers, 
[18:05:36.445]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:36.445]                       if (default_workers) 
[18:05:36.445]                         supportsMulticore(warn = TRUE)
[18:05:36.445]                       return(sequential(..., envir = envir))
[18:05:36.445]                     }
[18:05:36.445]                     oopts <- options(mc.cores = workers)
[18:05:36.445]                     on.exit(options(oopts))
[18:05:36.445]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:36.445]                       envir = envir)
[18:05:36.445]                     if (!future$lazy) 
[18:05:36.445]                       future <- run(future)
[18:05:36.445]                     invisible(future)
[18:05:36.445]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:36.445]                 }
[18:05:36.445]                 ...future.workdir <- getwd()
[18:05:36.445]             }
[18:05:36.445]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.445]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.445]         }
[18:05:36.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.445]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.445]             base::names(...future.oldOptions))
[18:05:36.445]     }
[18:05:36.445]     if (FALSE) {
[18:05:36.445]     }
[18:05:36.445]     else {
[18:05:36.445]         if (TRUE) {
[18:05:36.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.445]                 open = "w")
[18:05:36.445]         }
[18:05:36.445]         else {
[18:05:36.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.445]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.445]         }
[18:05:36.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.445]             base::sink(type = "output", split = FALSE)
[18:05:36.445]             base::close(...future.stdout)
[18:05:36.445]         }, add = TRUE)
[18:05:36.445]     }
[18:05:36.445]     ...future.frame <- base::sys.nframe()
[18:05:36.445]     ...future.conditions <- base::list()
[18:05:36.445]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.445]     if (FALSE) {
[18:05:36.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.445]     }
[18:05:36.445]     ...future.result <- base::tryCatch({
[18:05:36.445]         base::withCallingHandlers({
[18:05:36.445]             ...future.value <- base::withVisible(base::local({
[18:05:36.445]                 withCallingHandlers({
[18:05:36.445]                   {
[18:05:36.445]                     a <- 1L
[18:05:36.445]                     plan_a <- unclass(future::plan("list"))
[18:05:36.445]                     nested_a <- nested[-1]
[18:05:36.445]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:36.445]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:36.445]                       strategy2))
[18:05:36.445]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:36.445]                       "init") <- NULL
[18:05:36.445]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:36.445]                       "init") <- NULL
[18:05:36.445]                     stopifnot(all.equal(plan_a, nested_a))
[18:05:36.445]                     y %<-% {
[18:05:36.445]                       b <- 2L
[18:05:36.445]                       plan_b <- future::plan("list")
[18:05:36.445]                       nested_b <- nested_a[-1]
[18:05:36.445]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:36.445]                         1L, inherits(plan_b[[1]], "future"), 
[18:05:36.445]                         inherits(future::plan("next"), "sequential"))
[18:05:36.445]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:36.445]                         b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:36.445]                     }
[18:05:36.445]                     y
[18:05:36.445]                   }
[18:05:36.445]                 }, immediateCondition = function(cond) {
[18:05:36.445]                   save_rds <- function (object, pathname, ...) 
[18:05:36.445]                   {
[18:05:36.445]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:36.445]                     if (file_test("-f", pathname_tmp)) {
[18:05:36.445]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.445]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:36.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.445]                         fi_tmp[["mtime"]])
[18:05:36.445]                     }
[18:05:36.445]                     tryCatch({
[18:05:36.445]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:36.445]                     }, error = function(ex) {
[18:05:36.445]                       msg <- conditionMessage(ex)
[18:05:36.445]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.445]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:36.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.445]                         fi_tmp[["mtime"]], msg)
[18:05:36.445]                       ex$message <- msg
[18:05:36.445]                       stop(ex)
[18:05:36.445]                     })
[18:05:36.445]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:36.445]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:36.445]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:36.445]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.445]                       fi <- file.info(pathname)
[18:05:36.445]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:36.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.445]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:36.445]                         fi[["size"]], fi[["mtime"]])
[18:05:36.445]                       stop(msg)
[18:05:36.445]                     }
[18:05:36.445]                     invisible(pathname)
[18:05:36.445]                   }
[18:05:36.445]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:36.445]                     rootPath = tempdir()) 
[18:05:36.445]                   {
[18:05:36.445]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:36.445]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:36.445]                       tmpdir = path, fileext = ".rds")
[18:05:36.445]                     save_rds(obj, file)
[18:05:36.445]                   }
[18:05:36.445]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:36.445]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.445]                   {
[18:05:36.445]                     inherits <- base::inherits
[18:05:36.445]                     invokeRestart <- base::invokeRestart
[18:05:36.445]                     is.null <- base::is.null
[18:05:36.445]                     muffled <- FALSE
[18:05:36.445]                     if (inherits(cond, "message")) {
[18:05:36.445]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:36.445]                       if (muffled) 
[18:05:36.445]                         invokeRestart("muffleMessage")
[18:05:36.445]                     }
[18:05:36.445]                     else if (inherits(cond, "warning")) {
[18:05:36.445]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:36.445]                       if (muffled) 
[18:05:36.445]                         invokeRestart("muffleWarning")
[18:05:36.445]                     }
[18:05:36.445]                     else if (inherits(cond, "condition")) {
[18:05:36.445]                       if (!is.null(pattern)) {
[18:05:36.445]                         computeRestarts <- base::computeRestarts
[18:05:36.445]                         grepl <- base::grepl
[18:05:36.445]                         restarts <- computeRestarts(cond)
[18:05:36.445]                         for (restart in restarts) {
[18:05:36.445]                           name <- restart$name
[18:05:36.445]                           if (is.null(name)) 
[18:05:36.445]                             next
[18:05:36.445]                           if (!grepl(pattern, name)) 
[18:05:36.445]                             next
[18:05:36.445]                           invokeRestart(restart)
[18:05:36.445]                           muffled <- TRUE
[18:05:36.445]                           break
[18:05:36.445]                         }
[18:05:36.445]                       }
[18:05:36.445]                     }
[18:05:36.445]                     invisible(muffled)
[18:05:36.445]                   }
[18:05:36.445]                   muffleCondition(cond)
[18:05:36.445]                 })
[18:05:36.445]             }))
[18:05:36.445]             future::FutureResult(value = ...future.value$value, 
[18:05:36.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.445]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.445]                     ...future.globalenv.names))
[18:05:36.445]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.445]         }, condition = base::local({
[18:05:36.445]             c <- base::c
[18:05:36.445]             inherits <- base::inherits
[18:05:36.445]             invokeRestart <- base::invokeRestart
[18:05:36.445]             length <- base::length
[18:05:36.445]             list <- base::list
[18:05:36.445]             seq.int <- base::seq.int
[18:05:36.445]             signalCondition <- base::signalCondition
[18:05:36.445]             sys.calls <- base::sys.calls
[18:05:36.445]             `[[` <- base::`[[`
[18:05:36.445]             `+` <- base::`+`
[18:05:36.445]             `<<-` <- base::`<<-`
[18:05:36.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.445]                   3L)]
[18:05:36.445]             }
[18:05:36.445]             function(cond) {
[18:05:36.445]                 is_error <- inherits(cond, "error")
[18:05:36.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.445]                   NULL)
[18:05:36.445]                 if (is_error) {
[18:05:36.445]                   sessionInformation <- function() {
[18:05:36.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.445]                       search = base::search(), system = base::Sys.info())
[18:05:36.445]                   }
[18:05:36.445]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.445]                     cond$call), session = sessionInformation(), 
[18:05:36.445]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.445]                   signalCondition(cond)
[18:05:36.445]                 }
[18:05:36.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.445]                 "immediateCondition"))) {
[18:05:36.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.445]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.445]                   if (TRUE && !signal) {
[18:05:36.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.445]                     {
[18:05:36.445]                       inherits <- base::inherits
[18:05:36.445]                       invokeRestart <- base::invokeRestart
[18:05:36.445]                       is.null <- base::is.null
[18:05:36.445]                       muffled <- FALSE
[18:05:36.445]                       if (inherits(cond, "message")) {
[18:05:36.445]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.445]                         if (muffled) 
[18:05:36.445]                           invokeRestart("muffleMessage")
[18:05:36.445]                       }
[18:05:36.445]                       else if (inherits(cond, "warning")) {
[18:05:36.445]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.445]                         if (muffled) 
[18:05:36.445]                           invokeRestart("muffleWarning")
[18:05:36.445]                       }
[18:05:36.445]                       else if (inherits(cond, "condition")) {
[18:05:36.445]                         if (!is.null(pattern)) {
[18:05:36.445]                           computeRestarts <- base::computeRestarts
[18:05:36.445]                           grepl <- base::grepl
[18:05:36.445]                           restarts <- computeRestarts(cond)
[18:05:36.445]                           for (restart in restarts) {
[18:05:36.445]                             name <- restart$name
[18:05:36.445]                             if (is.null(name)) 
[18:05:36.445]                               next
[18:05:36.445]                             if (!grepl(pattern, name)) 
[18:05:36.445]                               next
[18:05:36.445]                             invokeRestart(restart)
[18:05:36.445]                             muffled <- TRUE
[18:05:36.445]                             break
[18:05:36.445]                           }
[18:05:36.445]                         }
[18:05:36.445]                       }
[18:05:36.445]                       invisible(muffled)
[18:05:36.445]                     }
[18:05:36.445]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.445]                   }
[18:05:36.445]                 }
[18:05:36.445]                 else {
[18:05:36.445]                   if (TRUE) {
[18:05:36.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.445]                     {
[18:05:36.445]                       inherits <- base::inherits
[18:05:36.445]                       invokeRestart <- base::invokeRestart
[18:05:36.445]                       is.null <- base::is.null
[18:05:36.445]                       muffled <- FALSE
[18:05:36.445]                       if (inherits(cond, "message")) {
[18:05:36.445]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.445]                         if (muffled) 
[18:05:36.445]                           invokeRestart("muffleMessage")
[18:05:36.445]                       }
[18:05:36.445]                       else if (inherits(cond, "warning")) {
[18:05:36.445]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.445]                         if (muffled) 
[18:05:36.445]                           invokeRestart("muffleWarning")
[18:05:36.445]                       }
[18:05:36.445]                       else if (inherits(cond, "condition")) {
[18:05:36.445]                         if (!is.null(pattern)) {
[18:05:36.445]                           computeRestarts <- base::computeRestarts
[18:05:36.445]                           grepl <- base::grepl
[18:05:36.445]                           restarts <- computeRestarts(cond)
[18:05:36.445]                           for (restart in restarts) {
[18:05:36.445]                             name <- restart$name
[18:05:36.445]                             if (is.null(name)) 
[18:05:36.445]                               next
[18:05:36.445]                             if (!grepl(pattern, name)) 
[18:05:36.445]                               next
[18:05:36.445]                             invokeRestart(restart)
[18:05:36.445]                             muffled <- TRUE
[18:05:36.445]                             break
[18:05:36.445]                           }
[18:05:36.445]                         }
[18:05:36.445]                       }
[18:05:36.445]                       invisible(muffled)
[18:05:36.445]                     }
[18:05:36.445]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.445]                   }
[18:05:36.445]                 }
[18:05:36.445]             }
[18:05:36.445]         }))
[18:05:36.445]     }, error = function(ex) {
[18:05:36.445]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.445]                 ...future.rng), started = ...future.startTime, 
[18:05:36.445]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.445]             version = "1.8"), class = "FutureResult")
[18:05:36.445]     }, finally = {
[18:05:36.445]         if (!identical(...future.workdir, getwd())) 
[18:05:36.445]             setwd(...future.workdir)
[18:05:36.445]         {
[18:05:36.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.445]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.445]             }
[18:05:36.445]             base::options(...future.oldOptions)
[18:05:36.445]             if (.Platform$OS.type == "windows") {
[18:05:36.445]                 old_names <- names(...future.oldEnvVars)
[18:05:36.445]                 envs <- base::Sys.getenv()
[18:05:36.445]                 names <- names(envs)
[18:05:36.445]                 common <- intersect(names, old_names)
[18:05:36.445]                 added <- setdiff(names, old_names)
[18:05:36.445]                 removed <- setdiff(old_names, names)
[18:05:36.445]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.445]                   envs[common]]
[18:05:36.445]                 NAMES <- toupper(changed)
[18:05:36.445]                 args <- list()
[18:05:36.445]                 for (kk in seq_along(NAMES)) {
[18:05:36.445]                   name <- changed[[kk]]
[18:05:36.445]                   NAME <- NAMES[[kk]]
[18:05:36.445]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.445]                     next
[18:05:36.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.445]                 }
[18:05:36.445]                 NAMES <- toupper(added)
[18:05:36.445]                 for (kk in seq_along(NAMES)) {
[18:05:36.445]                   name <- added[[kk]]
[18:05:36.445]                   NAME <- NAMES[[kk]]
[18:05:36.445]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.445]                     next
[18:05:36.445]                   args[[name]] <- ""
[18:05:36.445]                 }
[18:05:36.445]                 NAMES <- toupper(removed)
[18:05:36.445]                 for (kk in seq_along(NAMES)) {
[18:05:36.445]                   name <- removed[[kk]]
[18:05:36.445]                   NAME <- NAMES[[kk]]
[18:05:36.445]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.445]                     next
[18:05:36.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.445]                 }
[18:05:36.445]                 if (length(args) > 0) 
[18:05:36.445]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.445]             }
[18:05:36.445]             else {
[18:05:36.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.445]             }
[18:05:36.445]             {
[18:05:36.445]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.445]                   0L) {
[18:05:36.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.445]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.445]                   base::options(opts)
[18:05:36.445]                 }
[18:05:36.445]                 {
[18:05:36.445]                   {
[18:05:36.445]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:36.445]                     NULL
[18:05:36.445]                   }
[18:05:36.445]                   options(future.plan = NULL)
[18:05:36.445]                   if (is.na(NA_character_)) 
[18:05:36.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.445]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.445]                     .init = FALSE)
[18:05:36.445]                 }
[18:05:36.445]             }
[18:05:36.445]         }
[18:05:36.445]     })
[18:05:36.445]     if (TRUE) {
[18:05:36.445]         base::sink(type = "output", split = FALSE)
[18:05:36.445]         if (TRUE) {
[18:05:36.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.445]         }
[18:05:36.445]         else {
[18:05:36.445]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.445]         }
[18:05:36.445]         base::close(...future.stdout)
[18:05:36.445]         ...future.stdout <- NULL
[18:05:36.445]     }
[18:05:36.445]     ...future.result$conditions <- ...future.conditions
[18:05:36.445]     ...future.result$finished <- base::Sys.time()
[18:05:36.445]     ...future.result
[18:05:36.445] }
[18:05:36.450] assign_globals() ...
[18:05:36.450] List of 2
[18:05:36.450]  $ nested   :List of 2
[18:05:36.450]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:36.450]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:36.450]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.450]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:36.450]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:36.450]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.450]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:36.450]  $ strategy2: chr "multicore"
[18:05:36.450]  - attr(*, "where")=List of 2
[18:05:36.450]   ..$ nested   :<environment: R_EmptyEnv> 
[18:05:36.450]   ..$ strategy2:<environment: R_EmptyEnv> 
[18:05:36.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.450]  - attr(*, "resolved")= logi FALSE
[18:05:36.450]  - attr(*, "total_size")= num 95304
[18:05:36.450]  - attr(*, "already-done")= logi TRUE
[18:05:36.461] - copied ‘nested’ to environment
[18:05:36.461] - copied ‘strategy2’ to environment
[18:05:36.462] assign_globals() ... done
[18:05:36.462] requestCore(): workers = 2
[18:05:36.466] MulticoreFuture started
[18:05:36.467] - Launch lazy future ... done
[18:05:36.467] run() for ‘MulticoreFuture’ ... done
[18:05:36.468] result() for MulticoreFuture ...
[18:05:36.469] plan(): Setting new future strategy stack:
[18:05:36.469] List of future strategies:
[18:05:36.469] 1. multicore:
[18:05:36.469]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.469]    - tweaked: FALSE
[18:05:36.469]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.479] plan(): nbrOfWorkers() = 1
[18:05:36.567] plan(): Setting new future strategy stack:
[18:05:36.567] List of future strategies:
[18:05:36.567] 1. multicore:
[18:05:36.567]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.567]    - tweaked: FALSE
[18:05:36.567]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.567] 2. multicore:
[18:05:36.567]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.567]    - tweaked: FALSE
[18:05:36.567]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.575] plan(): nbrOfWorkers() = 2
[18:05:36.580] result() for MulticoreFuture ...
[18:05:36.580] result() for MulticoreFuture ... done
[18:05:36.580] signalConditions() ...
[18:05:36.580]  - include = ‘immediateCondition’
[18:05:36.581]  - exclude = 
[18:05:36.581]  - resignal = FALSE
[18:05:36.581]  - Number of conditions: 54
[18:05:36.582] signalConditions() ... done
[18:05:36.584] result() for MulticoreFuture ... done
[18:05:36.584] result() for MulticoreFuture ...
[18:05:36.585] result() for MulticoreFuture ... done
[18:05:36.585] signalConditions() ...
[18:05:36.585]  - include = ‘immediateCondition’
[18:05:36.586]  - exclude = 
[18:05:36.586]  - resignal = FALSE
[18:05:36.586]  - Number of conditions: 54
[18:05:36.587] signalConditions() ... done
[18:05:36.587] Future state: ‘finished’
[18:05:36.587] result() for MulticoreFuture ...
[18:05:36.588] result() for MulticoreFuture ... done
[18:05:36.588] signalConditions() ...
[18:05:36.588]  - include = ‘condition’
[18:05:36.588]  - exclude = ‘immediateCondition’
[18:05:36.589]  - resignal = TRUE
[18:05:36.589]  - Number of conditions: 54
[18:05:36.589]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.483] getGlobalsAndPackages() ...
[18:05:36.589]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.484] Searching for globals...
[18:05:36.590]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.502] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[18:05:36.590]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.503] Searching for globals ... DONE
[18:05:36.591]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.503] Resolving globals: FALSE
[18:05:36.591]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.506] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[18:05:36.591]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.508] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[18:05:36.592]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.508] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[18:05:36.592]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.509] 
[18:05:36.592]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.509] getGlobalsAndPackages() ... DONE
[18:05:36.593]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.510] run() for ‘Future’ ...
[18:05:36.593]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.511] - state: ‘created’
[18:05:36.593]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.594]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:36.595]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:36.595]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.520]   - Field: ‘label’
[18:05:36.595]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.520]   - Field: ‘local’
[18:05:36.596]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.520]   - Field: ‘owner’
[18:05:36.596]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.521]   - Field: ‘envir’
[18:05:36.596]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.521]   - Field: ‘packages’
[18:05:36.597]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.522]   - Field: ‘gc’
[18:05:36.597]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.522]   - Field: ‘conditions’
[18:05:36.597]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.522]   - Field: ‘expr’
[18:05:36.598]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.523]   - Field: ‘uuid’
[18:05:36.598]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.523]   - Field: ‘seed’
[18:05:36.598]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.523]   - Field: ‘version’
[18:05:36.599]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.524]   - Field: ‘result’
[18:05:36.599]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.524]   - Field: ‘asynchronous’
[18:05:36.599]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.524]   - Field: ‘calls’
[18:05:36.600]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.525]   - Field: ‘globals’
[18:05:36.600]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.525]   - Field: ‘stdout’
[18:05:36.600]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.526]   - Field: ‘earlySignal’
[18:05:36.601]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.526]   - Field: ‘lazy’
[18:05:36.601]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.526]   - Field: ‘state’
[18:05:36.601]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:36.602]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.527] - Launch lazy future ...
[18:05:36.602]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.528] Packages needed by the future expression (n = 0): <none>
[18:05:36.602]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.528] Packages needed by future strategies (n = 0): <none>
[18:05:36.603]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.530] {
[18:05:36.530]     {
[18:05:36.530]         {
[18:05:36.530]             ...future.startTime <- base::Sys.time()
[18:05:36.530]             {
[18:05:36.530]                 {
[18:05:36.530]                   {
[18:05:36.530]                     base::local({
[18:05:36.530]                       has_future <- base::requireNamespace("future", 
[18:05:36.530]                         quietly = TRUE)
[18:05:36.530]                       if (has_future) {
[18:05:36.530]                         ns <- base::getNamespace("future")
[18:05:36.530]                         version <- ns[[".package"]][["version"]]
[18:05:36.530]                         if (is.null(version)) 
[18:05:36.530]                           version <- utils::packageVersion("future")
[18:05:36.530]                       }
[18:05:36.530]                       else {
[18:05:36.530]                         version <- NULL
[18:05:36.530]                       }
[18:05:36.530]                       if (!has_future || version < "1.8.0") {
[18:05:36.530]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.530]                           "", base::R.version$version.string), 
[18:05:36.530]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:36.530]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:36.530]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.530]                             "release", "version")], collapse = " "), 
[18:05:36.530]                           hostname = base::Sys.info()[["nodename"]])
[18:05:36.530]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.530]                           info)
[18:05:36.530]                         info <- base::paste(info, collapse = "; ")
[18:05:36.530]                         if (!has_future) {
[18:05:36.530]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.530]                             info)
[18:05:36.530]                         }
[18:05:36.530]                         else {
[18:05:36.530]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.530]                             info, version)
[18:05:36.530]                         }
[18:05:36.530]                         base::stop(msg)
[18:05:36.530]                       }
[18:05:36.530]                     })
[18:05:36.530]                   }
[18:05:36.530]                   ...future.strategy.old <- future::plan("list")
[18:05:36.530]                   options(future.plan = NULL)
[18:05:36.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:36.530]                 }
[18:05:36.530]                 ...future.workdir <- getwd()
[18:05:36.530]             }
[18:05:36.530]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.530]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.530]         }
[18:05:36.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.530]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.530]             base::names(...future.oldOptions))
[18:05:36.530]     }
[18:05:36.530]     if (FALSE) {
[18:05:36.530]     }
[18:05:36.530]     else {
[18:05:36.530]         if (TRUE) {
[18:05:36.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.530]                 open = "w")
[18:05:36.530]         }
[18:05:36.530]         else {
[18:05:36.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.530]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.530]         }
[18:05:36.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.530]             base::sink(type = "output", split = FALSE)
[18:05:36.530]             base::close(...future.stdout)
[18:05:36.530]         }, add = TRUE)
[18:05:36.530]     }
[18:05:36.530]     ...future.frame <- base::sys.nframe()
[18:05:36.530]     ...future.conditions <- base::list()
[18:05:36.530]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.530]     if (FALSE) {
[18:05:36.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.530]     }
[18:05:36.530]     ...future.result <- base::tryCatch({
[18:05:36.530]         base::withCallingHandlers({
[18:05:36.530]             ...future.value <- base::withVisible(base::local({
[18:05:36.530]                 b <- 2L
[18:05:36.530]                 plan_b <- future::plan("list")
[18:05:36.530]                 nested_b <- nested_a[-1]
[18:05:36.530]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:36.530]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:36.530]                   "sequential"))
[18:05:36.530]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:36.530]                   b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:36.530]             }))
[18:05:36.530]             future::FutureResult(value = ...future.value$value, 
[18:05:36.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.530]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.530]                     ...future.globalenv.names))
[18:05:36.530]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.530]         }, condition = base::local({
[18:05:36.530]             c <- base::c
[18:05:36.530]             inherits <- base::inherits
[18:05:36.530]             invokeRestart <- base::invokeRestart
[18:05:36.530]             length <- base::length
[18:05:36.530]             list <- base::list
[18:05:36.530]             seq.int <- base::seq.int
[18:05:36.530]             signalCondition <- base::signalCondition
[18:05:36.530]             sys.calls <- base::sys.calls
[18:05:36.530]             `[[` <- base::`[[`
[18:05:36.530]             `+` <- base::`+`
[18:05:36.530]             `<<-` <- base::`<<-`
[18:05:36.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.530]                   3L)]
[18:05:36.530]             }
[18:05:36.530]             function(cond) {
[18:05:36.530]                 is_error <- inherits(cond, "error")
[18:05:36.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.530]                   NULL)
[18:05:36.530]                 if (is_error) {
[18:05:36.530]                   sessionInformation <- function() {
[18:05:36.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.530]                       search = base::search(), system = base::Sys.info())
[18:05:36.530]                   }
[18:05:36.530]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.530]                     cond$call), session = sessionInformation(), 
[18:05:36.530]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.530]                   signalCondition(cond)
[18:05:36.530]                 }
[18:05:36.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.530]                 "immediateCondition"))) {
[18:05:36.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.530]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.530]                   if (TRUE && !signal) {
[18:05:36.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.530]                     {
[18:05:36.530]                       inherits <- base::inherits
[18:05:36.530]                       invokeRestart <- base::invokeRestart
[18:05:36.530]                       is.null <- base::is.null
[18:05:36.530]                       muffled <- FALSE
[18:05:36.530]                       if (inherits(cond, "message")) {
[18:05:36.530]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.530]                         if (muffled) 
[18:05:36.530]                           invokeRestart("muffleMessage")
[18:05:36.530]                       }
[18:05:36.530]                       else if (inherits(cond, "warning")) {
[18:05:36.530]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.530]                         if (muffled) 
[18:05:36.530]                           invokeRestart("muffleWarning")
[18:05:36.530]                       }
[18:05:36.530]                       else if (inherits(cond, "condition")) {
[18:05:36.530]                         if (!is.null(pattern)) {
[18:05:36.530]                           computeRestarts <- base::computeRestarts
[18:05:36.530]                           grepl <- base::grepl
[18:05:36.530]                           restarts <- computeRestarts(cond)
[18:05:36.530]                           for (restart in restarts) {
[18:05:36.530]                             name <- restart$name
[18:05:36.530]                             if (is.null(name)) 
[18:05:36.530]                               next
[18:05:36.530]                             if (!grepl(pattern, name)) 
[18:05:36.530]                               next
[18:05:36.530]                             invokeRestart(restart)
[18:05:36.530]                             muffled <- TRUE
[18:05:36.530]                             break
[18:05:36.530]                           }
[18:05:36.530]                         }
[18:05:36.530]                       }
[18:05:36.530]                       invisible(muffled)
[18:05:36.530]                     }
[18:05:36.530]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.530]                   }
[18:05:36.530]                 }
[18:05:36.530]                 else {
[18:05:36.530]                   if (TRUE) {
[18:05:36.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.530]                     {
[18:05:36.530]                       inherits <- base::inherits
[18:05:36.530]                       invokeRestart <- base::invokeRestart
[18:05:36.530]                       is.null <- base::is.null
[18:05:36.530]                       muffled <- FALSE
[18:05:36.530]                       if (inherits(cond, "message")) {
[18:05:36.530]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.530]                         if (muffled) 
[18:05:36.530]                           invokeRestart("muffleMessage")
[18:05:36.530]                       }
[18:05:36.530]                       else if (inherits(cond, "warning")) {
[18:05:36.530]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.530]                         if (muffled) 
[18:05:36.530]                           invokeRestart("muffleWarning")
[18:05:36.530]                       }
[18:05:36.530]                       else if (inherits(cond, "condition")) {
[18:05:36.530]                         if (!is.null(pattern)) {
[18:05:36.530]                           computeRestarts <- base::computeRestarts
[18:05:36.530]                           grepl <- base::grepl
[18:05:36.530]                           restarts <- computeRestarts(cond)
[18:05:36.530]                           for (restart in restarts) {
[18:05:36.530]                             name <- restart$name
[18:05:36.530]                             if (is.null(name)) 
[18:05:36.530]                               next
[18:05:36.530]                             if (!grepl(pattern, name)) 
[18:05:36.530]                               next
[18:05:36.530]                             invokeRestart(restart)
[18:05:36.530]                             muffled <- TRUE
[18:05:36.530]                             break
[18:05:36.530]                           }
[18:05:36.530]                         }
[18:05:36.530]                       }
[18:05:36.530]                       invisible(muffled)
[18:05:36.530]                     }
[18:05:36.530]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.530]                   }
[18:05:36.530]                 }
[18:05:36.530]             }
[18:05:36.530]         }))
[18:05:36.530]     }, error = function(ex) {
[18:05:36.530]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.530]                 ...future.rng), started = ...future.startTime, 
[18:05:36.530]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.530]             version = "1.8"), class = "FutureResult")
[18:05:36.530]     }, finally = {
[18:05:36.530]         if (!identical(...future.workdir, getwd())) 
[18:05:36.530]             setwd(...future.workdir)
[18:05:36.530]         {
[18:05:36.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.530]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.530]             }
[18:05:36.530]             base::options(...future.oldOptions)
[18:05:36.530]             if (.Platform$OS.type == "windows") {
[18:05:36.530]                 old_names <- names(...future.oldEnvVars)
[18:05:36.530]                 envs <- base::Sys.getenv()
[18:05:36.530]                 names <- names(envs)
[18:05:36.530]                 common <- intersect(names, old_names)
[18:05:36.530]                 added <- setdiff(names, old_names)
[18:05:36.530]                 removed <- setdiff(old_names, names)
[18:05:36.530]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.530]                   envs[common]]
[18:05:36.530]                 NAMES <- toupper(changed)
[18:05:36.530]                 args <- list()
[18:05:36.530]                 for (kk in seq_along(NAMES)) {
[18:05:36.530]                   name <- changed[[kk]]
[18:05:36.530]                   NAME <- NAMES[[kk]]
[18:05:36.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.530]                     next
[18:05:36.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.530]                 }
[18:05:36.530]                 NAMES <- toupper(added)
[18:05:36.530]                 for (kk in seq_along(NAMES)) {
[18:05:36.530]                   name <- added[[kk]]
[18:05:36.530]                   NAME <- NAMES[[kk]]
[18:05:36.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.530]                     next
[18:05:36.530]                   args[[name]] <- ""
[18:05:36.530]                 }
[18:05:36.530]                 NAMES <- toupper(removed)
[18:05:36.530]                 for (kk in seq_along(NAMES)) {
[18:05:36.530]                   name <- removed[[kk]]
[18:05:36.530]                   NAME <- NAMES[[kk]]
[18:05:36.530]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.530]                     next
[18:05:36.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.530]                 }
[18:05:36.530]                 if (length(args) > 0) 
[18:05:36.530]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.530]             }
[18:05:36.530]             else {
[18:05:36.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.530]             }
[18:05:36.530]             {
[18:05:36.530]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.530]                   0L) {
[18:05:36.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.530]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.530]                   base::options(opts)
[18:05:36.530]                 }
[18:05:36.530]                 {
[18:05:36.530]                   {
[18:05:36.530]                     NULL
[18:05:36.530]                     RNGkind("Mersenne-Twister")
[18:05:36.530]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:36.530]                       inherits = FALSE)
[18:05:36.530]                   }
[18:05:36.530]                   options(future.plan = NULL)
[18:05:36.530]                   if (is.na(NA_character_)) 
[18:05:36.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.530]                     .init = FALSE)
[18:05:36.530]                 }
[18:05:36.530]             }
[18:05:36.530]         }
[18:05:36.530]     })
[18:05:36.530]     if (TRUE) {
[18:05:36.530]         base::sink(type = "output", split = FALSE)
[18:05:36.530]         if (TRUE) {
[18:05:36.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.530]         }
[18:05:36.530]         else {
[18:05:36.530]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.530]         }
[18:05:36.530]         base::close(...future.stdout)
[18:05:36.530]         ...future.stdout <- NULL
[18:05:36.530]     }
[18:05:36.530]     ...future.result$conditions <- ...future.conditions
[18:05:36.530]     ...future.result$finished <- base::Sys.time()
[18:05:36.530]     ...future.result
[18:05:36.530] }
[18:05:36.603]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.535] assign_globals() ...
[18:05:36.603]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.535] List of 3
[18:05:36.535]  $ nested_a:List of 1
[18:05:36.535]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:36.535]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:36.535]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.535]  $ a       : int 1
[18:05:36.535]  $ plan_a  :List of 1
[18:05:36.535]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:36.535]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:36.535]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.535]  - attr(*, "where")=List of 3
[18:05:36.535]   ..$ nested_a:<environment: R_EmptyEnv> 
[18:05:36.535]   ..$ a       :<environment: R_EmptyEnv> 
[18:05:36.535]   ..$ plan_a  :<environment: R_EmptyEnv> 
[18:05:36.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.535]  - attr(*, "resolved")= logi FALSE
[18:05:36.535]  - attr(*, "total_size")= num 95240
[18:05:36.535]  - attr(*, "already-done")= logi TRUE
[18:05:36.604]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.551] - copied ‘nested_a’ to environment
[18:05:36.604]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.551] - copied ‘a’ to environment
[18:05:36.604]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.551] - copied ‘plan_a’ to environment
[18:05:36.605]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.552] assign_globals() ... done
[18:05:36.605]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.552] plan(): Setting new future strategy stack:
[18:05:36.605]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.553] List of future strategies:
[18:05:36.553] 1. sequential:
[18:05:36.553]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.553]    - tweaked: FALSE
[18:05:36.553]    - call: NULL
[18:05:36.606]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.554] plan(): nbrOfWorkers() = 1
[18:05:36.606]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.556] plan(): Setting new future strategy stack:
[18:05:36.606]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.557] List of future strategies:
[18:05:36.557] 1. multicore:
[18:05:36.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.557]    - tweaked: FALSE
[18:05:36.557]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.607]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.564] plan(): nbrOfWorkers() = 1
[18:05:36.607]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.564] SequentialFuture started (and completed)
[18:05:36.607]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.565] - Launch lazy future ... done
[18:05:36.607]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.565] run() for ‘SequentialFuture’ ... done
[18:05:36.608] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:36.619] getGlobalsAndPackages() ...
[18:05:36.619] Searching for globals...
[18:05:36.622] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:36.623] Searching for globals ... DONE
[18:05:36.623] Resolving globals: FALSE
[18:05:36.624] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:36.625] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:36.625] - globals: [1] ‘data’
[18:05:36.626] - packages: [1] ‘future’
[18:05:36.626] getGlobalsAndPackages() ... DONE
[18:05:36.627] run() for ‘Future’ ...
[18:05:36.627] - state: ‘created’
[18:05:36.627] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:36.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:36.635]   - Field: ‘label’
[18:05:36.635]   - Field: ‘local’
[18:05:36.635]   - Field: ‘owner’
[18:05:36.636]   - Field: ‘envir’
[18:05:36.636]   - Field: ‘workers’
[18:05:36.636]   - Field: ‘packages’
[18:05:36.636]   - Field: ‘gc’
[18:05:36.637]   - Field: ‘job’
[18:05:36.637]   - Field: ‘conditions’
[18:05:36.637]   - Field: ‘expr’
[18:05:36.637]   - Field: ‘uuid’
[18:05:36.637]   - Field: ‘seed’
[18:05:36.638]   - Field: ‘version’
[18:05:36.638]   - Field: ‘result’
[18:05:36.638]   - Field: ‘asynchronous’
[18:05:36.638]   - Field: ‘calls’
[18:05:36.639]   - Field: ‘globals’
[18:05:36.639]   - Field: ‘stdout’
[18:05:36.639]   - Field: ‘earlySignal’
[18:05:36.639]   - Field: ‘lazy’
[18:05:36.639]   - Field: ‘state’
[18:05:36.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:36.640] - Launch lazy future ...
[18:05:36.640] Packages needed by the future expression (n = 1): ‘future’
[18:05:36.641] Packages needed by future strategies (n = 1): ‘future’
[18:05:36.642] {
[18:05:36.642]     {
[18:05:36.642]         {
[18:05:36.642]             ...future.startTime <- base::Sys.time()
[18:05:36.642]             {
[18:05:36.642]                 {
[18:05:36.642]                   {
[18:05:36.642]                     {
[18:05:36.642]                       {
[18:05:36.642]                         base::local({
[18:05:36.642]                           has_future <- base::requireNamespace("future", 
[18:05:36.642]                             quietly = TRUE)
[18:05:36.642]                           if (has_future) {
[18:05:36.642]                             ns <- base::getNamespace("future")
[18:05:36.642]                             version <- ns[[".package"]][["version"]]
[18:05:36.642]                             if (is.null(version)) 
[18:05:36.642]                               version <- utils::packageVersion("future")
[18:05:36.642]                           }
[18:05:36.642]                           else {
[18:05:36.642]                             version <- NULL
[18:05:36.642]                           }
[18:05:36.642]                           if (!has_future || version < "1.8.0") {
[18:05:36.642]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.642]                               "", base::R.version$version.string), 
[18:05:36.642]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:36.642]                                 base::R.version$platform, 8 * 
[18:05:36.642]                                   base::.Machine$sizeof.pointer), 
[18:05:36.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.642]                                 "release", "version")], collapse = " "), 
[18:05:36.642]                               hostname = base::Sys.info()[["nodename"]])
[18:05:36.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.642]                               info)
[18:05:36.642]                             info <- base::paste(info, collapse = "; ")
[18:05:36.642]                             if (!has_future) {
[18:05:36.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.642]                                 info)
[18:05:36.642]                             }
[18:05:36.642]                             else {
[18:05:36.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.642]                                 info, version)
[18:05:36.642]                             }
[18:05:36.642]                             base::stop(msg)
[18:05:36.642]                           }
[18:05:36.642]                         })
[18:05:36.642]                       }
[18:05:36.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:36.642]                       base::options(mc.cores = 1L)
[18:05:36.642]                     }
[18:05:36.642]                     base::local({
[18:05:36.642]                       for (pkg in "future") {
[18:05:36.642]                         base::loadNamespace(pkg)
[18:05:36.642]                         base::library(pkg, character.only = TRUE)
[18:05:36.642]                       }
[18:05:36.642]                     })
[18:05:36.642]                   }
[18:05:36.642]                   ...future.strategy.old <- future::plan("list")
[18:05:36.642]                   options(future.plan = NULL)
[18:05:36.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.642]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:36.642]                     envir = parent.frame()) 
[18:05:36.642]                   {
[18:05:36.642]                     default_workers <- missing(workers)
[18:05:36.642]                     if (is.function(workers)) 
[18:05:36.642]                       workers <- workers()
[18:05:36.642]                     workers <- structure(as.integer(workers), 
[18:05:36.642]                       class = class(workers))
[18:05:36.642]                     stop_if_not(is.finite(workers), workers >= 
[18:05:36.642]                       1L)
[18:05:36.642]                     if ((workers == 1L && !inherits(workers, 
[18:05:36.642]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:36.642]                       if (default_workers) 
[18:05:36.642]                         supportsMulticore(warn = TRUE)
[18:05:36.642]                       return(sequential(..., envir = envir))
[18:05:36.642]                     }
[18:05:36.642]                     oopts <- options(mc.cores = workers)
[18:05:36.642]                     on.exit(options(oopts))
[18:05:36.642]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:36.642]                       envir = envir)
[18:05:36.642]                     if (!future$lazy) 
[18:05:36.642]                       future <- run(future)
[18:05:36.642]                     invisible(future)
[18:05:36.642]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:36.642]                 }
[18:05:36.642]                 ...future.workdir <- getwd()
[18:05:36.642]             }
[18:05:36.642]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.642]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.642]         }
[18:05:36.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.642]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.642]             base::names(...future.oldOptions))
[18:05:36.642]     }
[18:05:36.642]     if (FALSE) {
[18:05:36.642]     }
[18:05:36.642]     else {
[18:05:36.642]         if (TRUE) {
[18:05:36.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.642]                 open = "w")
[18:05:36.642]         }
[18:05:36.642]         else {
[18:05:36.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.642]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.642]         }
[18:05:36.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.642]             base::sink(type = "output", split = FALSE)
[18:05:36.642]             base::close(...future.stdout)
[18:05:36.642]         }, add = TRUE)
[18:05:36.642]     }
[18:05:36.642]     ...future.frame <- base::sys.nframe()
[18:05:36.642]     ...future.conditions <- base::list()
[18:05:36.642]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.642]     if (FALSE) {
[18:05:36.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.642]     }
[18:05:36.642]     ...future.result <- base::tryCatch({
[18:05:36.642]         base::withCallingHandlers({
[18:05:36.642]             ...future.value <- base::withVisible(base::local({
[18:05:36.642]                 withCallingHandlers({
[18:05:36.642]                   {
[18:05:36.642]                     value(future(subset(data, a == 2)))
[18:05:36.642]                   }
[18:05:36.642]                 }, immediateCondition = function(cond) {
[18:05:36.642]                   save_rds <- function (object, pathname, ...) 
[18:05:36.642]                   {
[18:05:36.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:36.642]                     if (file_test("-f", pathname_tmp)) {
[18:05:36.642]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:36.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.642]                         fi_tmp[["mtime"]])
[18:05:36.642]                     }
[18:05:36.642]                     tryCatch({
[18:05:36.642]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:36.642]                     }, error = function(ex) {
[18:05:36.642]                       msg <- conditionMessage(ex)
[18:05:36.642]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:36.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.642]                         fi_tmp[["mtime"]], msg)
[18:05:36.642]                       ex$message <- msg
[18:05:36.642]                       stop(ex)
[18:05:36.642]                     })
[18:05:36.642]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:36.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:36.642]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:36.642]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.642]                       fi <- file.info(pathname)
[18:05:36.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:36.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:36.642]                         fi[["size"]], fi[["mtime"]])
[18:05:36.642]                       stop(msg)
[18:05:36.642]                     }
[18:05:36.642]                     invisible(pathname)
[18:05:36.642]                   }
[18:05:36.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:36.642]                     rootPath = tempdir()) 
[18:05:36.642]                   {
[18:05:36.642]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:36.642]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:36.642]                       tmpdir = path, fileext = ".rds")
[18:05:36.642]                     save_rds(obj, file)
[18:05:36.642]                   }
[18:05:36.642]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:36.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.642]                   {
[18:05:36.642]                     inherits <- base::inherits
[18:05:36.642]                     invokeRestart <- base::invokeRestart
[18:05:36.642]                     is.null <- base::is.null
[18:05:36.642]                     muffled <- FALSE
[18:05:36.642]                     if (inherits(cond, "message")) {
[18:05:36.642]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:36.642]                       if (muffled) 
[18:05:36.642]                         invokeRestart("muffleMessage")
[18:05:36.642]                     }
[18:05:36.642]                     else if (inherits(cond, "warning")) {
[18:05:36.642]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:36.642]                       if (muffled) 
[18:05:36.642]                         invokeRestart("muffleWarning")
[18:05:36.642]                     }
[18:05:36.642]                     else if (inherits(cond, "condition")) {
[18:05:36.642]                       if (!is.null(pattern)) {
[18:05:36.642]                         computeRestarts <- base::computeRestarts
[18:05:36.642]                         grepl <- base::grepl
[18:05:36.642]                         restarts <- computeRestarts(cond)
[18:05:36.642]                         for (restart in restarts) {
[18:05:36.642]                           name <- restart$name
[18:05:36.642]                           if (is.null(name)) 
[18:05:36.642]                             next
[18:05:36.642]                           if (!grepl(pattern, name)) 
[18:05:36.642]                             next
[18:05:36.642]                           invokeRestart(restart)
[18:05:36.642]                           muffled <- TRUE
[18:05:36.642]                           break
[18:05:36.642]                         }
[18:05:36.642]                       }
[18:05:36.642]                     }
[18:05:36.642]                     invisible(muffled)
[18:05:36.642]                   }
[18:05:36.642]                   muffleCondition(cond)
[18:05:36.642]                 })
[18:05:36.642]             }))
[18:05:36.642]             future::FutureResult(value = ...future.value$value, 
[18:05:36.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.642]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.642]                     ...future.globalenv.names))
[18:05:36.642]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.642]         }, condition = base::local({
[18:05:36.642]             c <- base::c
[18:05:36.642]             inherits <- base::inherits
[18:05:36.642]             invokeRestart <- base::invokeRestart
[18:05:36.642]             length <- base::length
[18:05:36.642]             list <- base::list
[18:05:36.642]             seq.int <- base::seq.int
[18:05:36.642]             signalCondition <- base::signalCondition
[18:05:36.642]             sys.calls <- base::sys.calls
[18:05:36.642]             `[[` <- base::`[[`
[18:05:36.642]             `+` <- base::`+`
[18:05:36.642]             `<<-` <- base::`<<-`
[18:05:36.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.642]                   3L)]
[18:05:36.642]             }
[18:05:36.642]             function(cond) {
[18:05:36.642]                 is_error <- inherits(cond, "error")
[18:05:36.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.642]                   NULL)
[18:05:36.642]                 if (is_error) {
[18:05:36.642]                   sessionInformation <- function() {
[18:05:36.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.642]                       search = base::search(), system = base::Sys.info())
[18:05:36.642]                   }
[18:05:36.642]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.642]                     cond$call), session = sessionInformation(), 
[18:05:36.642]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.642]                   signalCondition(cond)
[18:05:36.642]                 }
[18:05:36.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.642]                 "immediateCondition"))) {
[18:05:36.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.642]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.642]                   if (TRUE && !signal) {
[18:05:36.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.642]                     {
[18:05:36.642]                       inherits <- base::inherits
[18:05:36.642]                       invokeRestart <- base::invokeRestart
[18:05:36.642]                       is.null <- base::is.null
[18:05:36.642]                       muffled <- FALSE
[18:05:36.642]                       if (inherits(cond, "message")) {
[18:05:36.642]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.642]                         if (muffled) 
[18:05:36.642]                           invokeRestart("muffleMessage")
[18:05:36.642]                       }
[18:05:36.642]                       else if (inherits(cond, "warning")) {
[18:05:36.642]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.642]                         if (muffled) 
[18:05:36.642]                           invokeRestart("muffleWarning")
[18:05:36.642]                       }
[18:05:36.642]                       else if (inherits(cond, "condition")) {
[18:05:36.642]                         if (!is.null(pattern)) {
[18:05:36.642]                           computeRestarts <- base::computeRestarts
[18:05:36.642]                           grepl <- base::grepl
[18:05:36.642]                           restarts <- computeRestarts(cond)
[18:05:36.642]                           for (restart in restarts) {
[18:05:36.642]                             name <- restart$name
[18:05:36.642]                             if (is.null(name)) 
[18:05:36.642]                               next
[18:05:36.642]                             if (!grepl(pattern, name)) 
[18:05:36.642]                               next
[18:05:36.642]                             invokeRestart(restart)
[18:05:36.642]                             muffled <- TRUE
[18:05:36.642]                             break
[18:05:36.642]                           }
[18:05:36.642]                         }
[18:05:36.642]                       }
[18:05:36.642]                       invisible(muffled)
[18:05:36.642]                     }
[18:05:36.642]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.642]                   }
[18:05:36.642]                 }
[18:05:36.642]                 else {
[18:05:36.642]                   if (TRUE) {
[18:05:36.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.642]                     {
[18:05:36.642]                       inherits <- base::inherits
[18:05:36.642]                       invokeRestart <- base::invokeRestart
[18:05:36.642]                       is.null <- base::is.null
[18:05:36.642]                       muffled <- FALSE
[18:05:36.642]                       if (inherits(cond, "message")) {
[18:05:36.642]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.642]                         if (muffled) 
[18:05:36.642]                           invokeRestart("muffleMessage")
[18:05:36.642]                       }
[18:05:36.642]                       else if (inherits(cond, "warning")) {
[18:05:36.642]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.642]                         if (muffled) 
[18:05:36.642]                           invokeRestart("muffleWarning")
[18:05:36.642]                       }
[18:05:36.642]                       else if (inherits(cond, "condition")) {
[18:05:36.642]                         if (!is.null(pattern)) {
[18:05:36.642]                           computeRestarts <- base::computeRestarts
[18:05:36.642]                           grepl <- base::grepl
[18:05:36.642]                           restarts <- computeRestarts(cond)
[18:05:36.642]                           for (restart in restarts) {
[18:05:36.642]                             name <- restart$name
[18:05:36.642]                             if (is.null(name)) 
[18:05:36.642]                               next
[18:05:36.642]                             if (!grepl(pattern, name)) 
[18:05:36.642]                               next
[18:05:36.642]                             invokeRestart(restart)
[18:05:36.642]                             muffled <- TRUE
[18:05:36.642]                             break
[18:05:36.642]                           }
[18:05:36.642]                         }
[18:05:36.642]                       }
[18:05:36.642]                       invisible(muffled)
[18:05:36.642]                     }
[18:05:36.642]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.642]                   }
[18:05:36.642]                 }
[18:05:36.642]             }
[18:05:36.642]         }))
[18:05:36.642]     }, error = function(ex) {
[18:05:36.642]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.642]                 ...future.rng), started = ...future.startTime, 
[18:05:36.642]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.642]             version = "1.8"), class = "FutureResult")
[18:05:36.642]     }, finally = {
[18:05:36.642]         if (!identical(...future.workdir, getwd())) 
[18:05:36.642]             setwd(...future.workdir)
[18:05:36.642]         {
[18:05:36.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.642]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.642]             }
[18:05:36.642]             base::options(...future.oldOptions)
[18:05:36.642]             if (.Platform$OS.type == "windows") {
[18:05:36.642]                 old_names <- names(...future.oldEnvVars)
[18:05:36.642]                 envs <- base::Sys.getenv()
[18:05:36.642]                 names <- names(envs)
[18:05:36.642]                 common <- intersect(names, old_names)
[18:05:36.642]                 added <- setdiff(names, old_names)
[18:05:36.642]                 removed <- setdiff(old_names, names)
[18:05:36.642]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.642]                   envs[common]]
[18:05:36.642]                 NAMES <- toupper(changed)
[18:05:36.642]                 args <- list()
[18:05:36.642]                 for (kk in seq_along(NAMES)) {
[18:05:36.642]                   name <- changed[[kk]]
[18:05:36.642]                   NAME <- NAMES[[kk]]
[18:05:36.642]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.642]                     next
[18:05:36.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.642]                 }
[18:05:36.642]                 NAMES <- toupper(added)
[18:05:36.642]                 for (kk in seq_along(NAMES)) {
[18:05:36.642]                   name <- added[[kk]]
[18:05:36.642]                   NAME <- NAMES[[kk]]
[18:05:36.642]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.642]                     next
[18:05:36.642]                   args[[name]] <- ""
[18:05:36.642]                 }
[18:05:36.642]                 NAMES <- toupper(removed)
[18:05:36.642]                 for (kk in seq_along(NAMES)) {
[18:05:36.642]                   name <- removed[[kk]]
[18:05:36.642]                   NAME <- NAMES[[kk]]
[18:05:36.642]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.642]                     next
[18:05:36.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.642]                 }
[18:05:36.642]                 if (length(args) > 0) 
[18:05:36.642]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.642]             }
[18:05:36.642]             else {
[18:05:36.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.642]             }
[18:05:36.642]             {
[18:05:36.642]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.642]                   0L) {
[18:05:36.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.642]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.642]                   base::options(opts)
[18:05:36.642]                 }
[18:05:36.642]                 {
[18:05:36.642]                   {
[18:05:36.642]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:36.642]                     NULL
[18:05:36.642]                   }
[18:05:36.642]                   options(future.plan = NULL)
[18:05:36.642]                   if (is.na(NA_character_)) 
[18:05:36.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.642]                     .init = FALSE)
[18:05:36.642]                 }
[18:05:36.642]             }
[18:05:36.642]         }
[18:05:36.642]     })
[18:05:36.642]     if (TRUE) {
[18:05:36.642]         base::sink(type = "output", split = FALSE)
[18:05:36.642]         if (TRUE) {
[18:05:36.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.642]         }
[18:05:36.642]         else {
[18:05:36.642]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.642]         }
[18:05:36.642]         base::close(...future.stdout)
[18:05:36.642]         ...future.stdout <- NULL
[18:05:36.642]     }
[18:05:36.642]     ...future.result$conditions <- ...future.conditions
[18:05:36.642]     ...future.result$finished <- base::Sys.time()
[18:05:36.642]     ...future.result
[18:05:36.642] }
[18:05:36.647] assign_globals() ...
[18:05:36.648] List of 1
[18:05:36.648]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:36.648]   ..$ a: int [1:3] 1 2 3
[18:05:36.648]   ..$ b: int [1:3] 3 2 1
[18:05:36.648]  - attr(*, "where")=List of 1
[18:05:36.648]   ..$ data:<environment: R_EmptyEnv> 
[18:05:36.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.648]  - attr(*, "resolved")= logi FALSE
[18:05:36.648]  - attr(*, "total_size")= num 128
[18:05:36.648]  - attr(*, "already-done")= logi TRUE
[18:05:36.655] - copied ‘data’ to environment
[18:05:36.655] assign_globals() ... done
[18:05:36.655] requestCore(): workers = 2
[18:05:36.659] MulticoreFuture started
[18:05:36.660] - Launch lazy future ... done
[18:05:36.660] run() for ‘MulticoreFuture’ ... done
[18:05:36.661] result() for MulticoreFuture ...
[18:05:36.661] plan(): Setting new future strategy stack:
[18:05:36.662] List of future strategies:
[18:05:36.662] 1. multicore:
[18:05:36.662]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.662]    - tweaked: FALSE
[18:05:36.662]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.674] plan(): nbrOfWorkers() = 1
[18:05:36.749] plan(): Setting new future strategy stack:
[18:05:36.749] List of future strategies:
[18:05:36.749] 1. multicore:
[18:05:36.749]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.749]    - tweaked: FALSE
[18:05:36.749]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.749] 2. multicore:
[18:05:36.749]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.749]    - tweaked: FALSE
[18:05:36.749]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.757] plan(): nbrOfWorkers() = 2
[18:05:36.760] result() for MulticoreFuture ...
[18:05:36.760] result() for MulticoreFuture ... done
[18:05:36.760] signalConditions() ...
[18:05:36.760]  - include = ‘immediateCondition’
[18:05:36.761]  - exclude = 
[18:05:36.761]  - resignal = FALSE
[18:05:36.761]  - Number of conditions: 52
[18:05:36.762] signalConditions() ... done
[18:05:36.762] result() for MulticoreFuture ... done
[18:05:36.762] result() for MulticoreFuture ...
[18:05:36.762] result() for MulticoreFuture ... done
[18:05:36.762] signalConditions() ...
[18:05:36.763]  - include = ‘immediateCondition’
[18:05:36.763]  - exclude = 
[18:05:36.763]  - resignal = FALSE
[18:05:36.763]  - Number of conditions: 52
[18:05:36.764] signalConditions() ... done
[18:05:36.764] Future state: ‘finished’
[18:05:36.764] result() for MulticoreFuture ...
[18:05:36.764] result() for MulticoreFuture ... done
[18:05:36.765] signalConditions() ...
[18:05:36.765]  - include = ‘condition’
[18:05:36.765]  - exclude = ‘immediateCondition’
[18:05:36.765]  - resignal = TRUE
[18:05:36.766]  - Number of conditions: 52
[18:05:36.766]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.676] getGlobalsAndPackages() ...
[18:05:36.766]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.677] Searching for globals...
[18:05:36.766]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.681] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:36.767]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.682] Searching for globals ... DONE
[18:05:36.767]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.682] Resolving globals: FALSE
[18:05:36.767]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.684] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:36.768]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.686] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:36.768]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.686] - globals: [1] ‘data’
[18:05:36.768]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.687] 
[18:05:36.769]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.687] getGlobalsAndPackages() ... DONE
[18:05:36.769]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.689] run() for ‘Future’ ...
[18:05:36.769]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.689] - state: ‘created’
[18:05:36.770]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.690] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.770]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:36.770]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:36.771]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.699]   - Field: ‘label’
[18:05:36.771]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.699]   - Field: ‘local’
[18:05:36.771]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.700]   - Field: ‘owner’
[18:05:36.772]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.700]   - Field: ‘envir’
[18:05:36.772]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.701]   - Field: ‘packages’
[18:05:36.772]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.701]   - Field: ‘gc’
[18:05:36.773]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.701]   - Field: ‘conditions’
[18:05:36.773]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.702]   - Field: ‘expr’
[18:05:36.773]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.702]   - Field: ‘uuid’
[18:05:36.774]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.703]   - Field: ‘seed’
[18:05:36.774]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.703]   - Field: ‘version’
[18:05:36.774]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.703]   - Field: ‘result’
[18:05:36.775]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.704]   - Field: ‘asynchronous’
[18:05:36.775]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.704]   - Field: ‘calls’
[18:05:36.775]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.704]   - Field: ‘globals’
[18:05:36.775]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.705]   - Field: ‘stdout’
[18:05:36.776]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.705]   - Field: ‘earlySignal’
[18:05:36.776]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.706]   - Field: ‘lazy’
[18:05:36.776]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.706]   - Field: ‘state’
[18:05:36.777]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:36.777]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.707] - Launch lazy future ...
[18:05:36.777]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.708] Packages needed by the future expression (n = 0): <none>
[18:05:36.778]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.708] Packages needed by future strategies (n = 0): <none>
[18:05:36.778]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.709] {
[18:05:36.709]     {
[18:05:36.709]         {
[18:05:36.709]             ...future.startTime <- base::Sys.time()
[18:05:36.709]             {
[18:05:36.709]                 {
[18:05:36.709]                   {
[18:05:36.709]                     base::local({
[18:05:36.709]                       has_future <- base::requireNamespace("future", 
[18:05:36.709]                         quietly = TRUE)
[18:05:36.709]                       if (has_future) {
[18:05:36.709]                         ns <- base::getNamespace("future")
[18:05:36.709]                         version <- ns[[".package"]][["version"]]
[18:05:36.709]                         if (is.null(version)) 
[18:05:36.709]                           version <- utils::packageVersion("future")
[18:05:36.709]                       }
[18:05:36.709]                       else {
[18:05:36.709]                         version <- NULL
[18:05:36.709]                       }
[18:05:36.709]                       if (!has_future || version < "1.8.0") {
[18:05:36.709]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.709]                           "", base::R.version$version.string), 
[18:05:36.709]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:36.709]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:36.709]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.709]                             "release", "version")], collapse = " "), 
[18:05:36.709]                           hostname = base::Sys.info()[["nodename"]])
[18:05:36.709]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.709]                           info)
[18:05:36.709]                         info <- base::paste(info, collapse = "; ")
[18:05:36.709]                         if (!has_future) {
[18:05:36.709]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.709]                             info)
[18:05:36.709]                         }
[18:05:36.709]                         else {
[18:05:36.709]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.709]                             info, version)
[18:05:36.709]                         }
[18:05:36.709]                         base::stop(msg)
[18:05:36.709]                       }
[18:05:36.709]                     })
[18:05:36.709]                   }
[18:05:36.709]                   ...future.strategy.old <- future::plan("list")
[18:05:36.709]                   options(future.plan = NULL)
[18:05:36.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:36.709]                 }
[18:05:36.709]                 ...future.workdir <- getwd()
[18:05:36.709]             }
[18:05:36.709]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.709]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.709]         }
[18:05:36.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.709]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.709]             base::names(...future.oldOptions))
[18:05:36.709]     }
[18:05:36.709]     if (FALSE) {
[18:05:36.709]     }
[18:05:36.709]     else {
[18:05:36.709]         if (TRUE) {
[18:05:36.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.709]                 open = "w")
[18:05:36.709]         }
[18:05:36.709]         else {
[18:05:36.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.709]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.709]         }
[18:05:36.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.709]             base::sink(type = "output", split = FALSE)
[18:05:36.709]             base::close(...future.stdout)
[18:05:36.709]         }, add = TRUE)
[18:05:36.709]     }
[18:05:36.709]     ...future.frame <- base::sys.nframe()
[18:05:36.709]     ...future.conditions <- base::list()
[18:05:36.709]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.709]     if (FALSE) {
[18:05:36.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.709]     }
[18:05:36.709]     ...future.result <- base::tryCatch({
[18:05:36.709]         base::withCallingHandlers({
[18:05:36.709]             ...future.value <- base::withVisible(base::local(subset(data, 
[18:05:36.709]                 a == 2)))
[18:05:36.709]             future::FutureResult(value = ...future.value$value, 
[18:05:36.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.709]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.709]                     ...future.globalenv.names))
[18:05:36.709]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.709]         }, condition = base::local({
[18:05:36.709]             c <- base::c
[18:05:36.709]             inherits <- base::inherits
[18:05:36.709]             invokeRestart <- base::invokeRestart
[18:05:36.709]             length <- base::length
[18:05:36.709]             list <- base::list
[18:05:36.709]             seq.int <- base::seq.int
[18:05:36.709]             signalCondition <- base::signalCondition
[18:05:36.709]             sys.calls <- base::sys.calls
[18:05:36.709]             `[[` <- base::`[[`
[18:05:36.709]             `+` <- base::`+`
[18:05:36.709]             `<<-` <- base::`<<-`
[18:05:36.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.709]                   3L)]
[18:05:36.709]             }
[18:05:36.709]             function(cond) {
[18:05:36.709]                 is_error <- inherits(cond, "error")
[18:05:36.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.709]                   NULL)
[18:05:36.709]                 if (is_error) {
[18:05:36.709]                   sessionInformation <- function() {
[18:05:36.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.709]                       search = base::search(), system = base::Sys.info())
[18:05:36.709]                   }
[18:05:36.709]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.709]                     cond$call), session = sessionInformation(), 
[18:05:36.709]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.709]                   signalCondition(cond)
[18:05:36.709]                 }
[18:05:36.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.709]                 "immediateCondition"))) {
[18:05:36.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.709]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.709]                   if (TRUE && !signal) {
[18:05:36.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.709]                     {
[18:05:36.709]                       inherits <- base::inherits
[18:05:36.709]                       invokeRestart <- base::invokeRestart
[18:05:36.709]                       is.null <- base::is.null
[18:05:36.709]                       muffled <- FALSE
[18:05:36.709]                       if (inherits(cond, "message")) {
[18:05:36.709]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.709]                         if (muffled) 
[18:05:36.709]                           invokeRestart("muffleMessage")
[18:05:36.709]                       }
[18:05:36.709]                       else if (inherits(cond, "warning")) {
[18:05:36.709]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.709]                         if (muffled) 
[18:05:36.709]                           invokeRestart("muffleWarning")
[18:05:36.709]                       }
[18:05:36.709]                       else if (inherits(cond, "condition")) {
[18:05:36.709]                         if (!is.null(pattern)) {
[18:05:36.709]                           computeRestarts <- base::computeRestarts
[18:05:36.709]                           grepl <- base::grepl
[18:05:36.709]                           restarts <- computeRestarts(cond)
[18:05:36.709]                           for (restart in restarts) {
[18:05:36.709]                             name <- restart$name
[18:05:36.709]                             if (is.null(name)) 
[18:05:36.709]                               next
[18:05:36.709]                             if (!grepl(pattern, name)) 
[18:05:36.709]                               next
[18:05:36.709]                             invokeRestart(restart)
[18:05:36.709]                             muffled <- TRUE
[18:05:36.709]                             break
[18:05:36.709]                           }
[18:05:36.709]                         }
[18:05:36.709]                       }
[18:05:36.709]                       invisible(muffled)
[18:05:36.709]                     }
[18:05:36.709]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.709]                   }
[18:05:36.709]                 }
[18:05:36.709]                 else {
[18:05:36.709]                   if (TRUE) {
[18:05:36.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.709]                     {
[18:05:36.709]                       inherits <- base::inherits
[18:05:36.709]                       invokeRestart <- base::invokeRestart
[18:05:36.709]                       is.null <- base::is.null
[18:05:36.709]                       muffled <- FALSE
[18:05:36.709]                       if (inherits(cond, "message")) {
[18:05:36.709]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.709]                         if (muffled) 
[18:05:36.709]                           invokeRestart("muffleMessage")
[18:05:36.709]                       }
[18:05:36.709]                       else if (inherits(cond, "warning")) {
[18:05:36.709]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.709]                         if (muffled) 
[18:05:36.709]                           invokeRestart("muffleWarning")
[18:05:36.709]                       }
[18:05:36.709]                       else if (inherits(cond, "condition")) {
[18:05:36.709]                         if (!is.null(pattern)) {
[18:05:36.709]                           computeRestarts <- base::computeRestarts
[18:05:36.709]                           grepl <- base::grepl
[18:05:36.709]                           restarts <- computeRestarts(cond)
[18:05:36.709]                           for (restart in restarts) {
[18:05:36.709]                             name <- restart$name
[18:05:36.709]                             if (is.null(name)) 
[18:05:36.709]                               next
[18:05:36.709]                             if (!grepl(pattern, name)) 
[18:05:36.709]                               next
[18:05:36.709]                             invokeRestart(restart)
[18:05:36.709]                             muffled <- TRUE
[18:05:36.709]                             break
[18:05:36.709]                           }
[18:05:36.709]                         }
[18:05:36.709]                       }
[18:05:36.709]                       invisible(muffled)
[18:05:36.709]                     }
[18:05:36.709]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.709]                   }
[18:05:36.709]                 }
[18:05:36.709]             }
[18:05:36.709]         }))
[18:05:36.709]     }, error = function(ex) {
[18:05:36.709]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.709]                 ...future.rng), started = ...future.startTime, 
[18:05:36.709]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.709]             version = "1.8"), class = "FutureResult")
[18:05:36.709]     }, finally = {
[18:05:36.709]         if (!identical(...future.workdir, getwd())) 
[18:05:36.709]             setwd(...future.workdir)
[18:05:36.709]         {
[18:05:36.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.709]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.709]             }
[18:05:36.709]             base::options(...future.oldOptions)
[18:05:36.709]             if (.Platform$OS.type == "windows") {
[18:05:36.709]                 old_names <- names(...future.oldEnvVars)
[18:05:36.709]                 envs <- base::Sys.getenv()
[18:05:36.709]                 names <- names(envs)
[18:05:36.709]                 common <- intersect(names, old_names)
[18:05:36.709]                 added <- setdiff(names, old_names)
[18:05:36.709]                 removed <- setdiff(old_names, names)
[18:05:36.709]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.709]                   envs[common]]
[18:05:36.709]                 NAMES <- toupper(changed)
[18:05:36.709]                 args <- list()
[18:05:36.709]                 for (kk in seq_along(NAMES)) {
[18:05:36.709]                   name <- changed[[kk]]
[18:05:36.709]                   NAME <- NAMES[[kk]]
[18:05:36.709]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.709]                     next
[18:05:36.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.709]                 }
[18:05:36.709]                 NAMES <- toupper(added)
[18:05:36.709]                 for (kk in seq_along(NAMES)) {
[18:05:36.709]                   name <- added[[kk]]
[18:05:36.709]                   NAME <- NAMES[[kk]]
[18:05:36.709]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.709]                     next
[18:05:36.709]                   args[[name]] <- ""
[18:05:36.709]                 }
[18:05:36.709]                 NAMES <- toupper(removed)
[18:05:36.709]                 for (kk in seq_along(NAMES)) {
[18:05:36.709]                   name <- removed[[kk]]
[18:05:36.709]                   NAME <- NAMES[[kk]]
[18:05:36.709]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.709]                     next
[18:05:36.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.709]                 }
[18:05:36.709]                 if (length(args) > 0) 
[18:05:36.709]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.709]             }
[18:05:36.709]             else {
[18:05:36.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.709]             }
[18:05:36.709]             {
[18:05:36.709]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.709]                   0L) {
[18:05:36.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.709]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.709]                   base::options(opts)
[18:05:36.709]                 }
[18:05:36.709]                 {
[18:05:36.709]                   {
[18:05:36.709]                     NULL
[18:05:36.709]                     RNGkind("Mersenne-Twister")
[18:05:36.709]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:36.709]                       inherits = FALSE)
[18:05:36.709]                   }
[18:05:36.709]                   options(future.plan = NULL)
[18:05:36.709]                   if (is.na(NA_character_)) 
[18:05:36.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.709]                     .init = FALSE)
[18:05:36.709]                 }
[18:05:36.709]             }
[18:05:36.709]         }
[18:05:36.709]     })
[18:05:36.709]     if (TRUE) {
[18:05:36.709]         base::sink(type = "output", split = FALSE)
[18:05:36.709]         if (TRUE) {
[18:05:36.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.709]         }
[18:05:36.709]         else {
[18:05:36.709]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.709]         }
[18:05:36.709]         base::close(...future.stdout)
[18:05:36.709]         ...future.stdout <- NULL
[18:05:36.709]     }
[18:05:36.709]     ...future.result$conditions <- ...future.conditions
[18:05:36.709]     ...future.result$finished <- base::Sys.time()
[18:05:36.709]     ...future.result
[18:05:36.709] }
[18:05:36.778]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.714] assign_globals() ...
[18:05:36.779]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.715] List of 1
[18:05:36.715]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:36.715]   ..$ a: int [1:3] 1 2 3
[18:05:36.715]   ..$ b: int [1:3] 3 2 1
[18:05:36.715]  - attr(*, "where")=List of 1
[18:05:36.715]   ..$ data:<environment: R_EmptyEnv> 
[18:05:36.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.715]  - attr(*, "resolved")= logi FALSE
[18:05:36.715]  - attr(*, "total_size")= num 128
[18:05:36.715]  - attr(*, "already-done")= logi TRUE
[18:05:36.779]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.725] - copied ‘data’ to environment
[18:05:36.779]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.725] assign_globals() ... done
[18:05:36.780]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.726] plan(): Setting new future strategy stack:
[18:05:36.780]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.726] List of future strategies:
[18:05:36.726] 1. sequential:
[18:05:36.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.726]    - tweaked: FALSE
[18:05:36.726]    - call: NULL
[18:05:36.780]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.727] plan(): nbrOfWorkers() = 1
[18:05:36.781]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.730] plan(): Setting new future strategy stack:
[18:05:36.781]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.730] List of future strategies:
[18:05:36.730] 1. multicore:
[18:05:36.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.730]    - tweaked: FALSE
[18:05:36.730]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.781]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.737] plan(): nbrOfWorkers() = 1
[18:05:36.781]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.738] SequentialFuture started (and completed)
[18:05:36.782]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.746] - Launch lazy future ... done
[18:05:36.782]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.747] run() for ‘SequentialFuture’ ... done
[18:05:36.782] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[18:05:36.783] plan(): Setting new future strategy stack:
[18:05:36.784] List of future strategies:
[18:05:36.784] 1. multicore:
[18:05:36.784]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.784]    - tweaked: FALSE
[18:05:36.784]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.784] 2. multisession:
[18:05:36.784]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:36.784]    - tweaked: FALSE
[18:05:36.784]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.791] plan(): nbrOfWorkers() = 2
[18:05:36.792] getGlobalsAndPackages() ...
[18:05:36.792] Searching for globals...
[18:05:36.838] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:36.838] Searching for globals ... DONE
[18:05:36.838] Resolving globals: FALSE
[18:05:36.841] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[18:05:36.842] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:36.842] - globals: [2] ‘nested’, ‘strategy2’
[18:05:36.843] - packages: [1] ‘future’
[18:05:36.843] getGlobalsAndPackages() ... DONE
[18:05:36.843] run() for ‘Future’ ...
[18:05:36.844] - state: ‘created’
[18:05:36.844] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:36.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:36.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:36.852]   - Field: ‘label’
[18:05:36.852]   - Field: ‘local’
[18:05:36.852]   - Field: ‘owner’
[18:05:36.852]   - Field: ‘envir’
[18:05:36.853]   - Field: ‘workers’
[18:05:36.853]   - Field: ‘packages’
[18:05:36.853]   - Field: ‘gc’
[18:05:36.853]   - Field: ‘job’
[18:05:36.854]   - Field: ‘conditions’
[18:05:36.854]   - Field: ‘expr’
[18:05:36.854]   - Field: ‘uuid’
[18:05:36.854]   - Field: ‘seed’
[18:05:36.855]   - Field: ‘version’
[18:05:36.855]   - Field: ‘result’
[18:05:36.855]   - Field: ‘asynchronous’
[18:05:36.855]   - Field: ‘calls’
[18:05:36.856]   - Field: ‘globals’
[18:05:36.856]   - Field: ‘stdout’
[18:05:36.856]   - Field: ‘earlySignal’
[18:05:36.856]   - Field: ‘lazy’
[18:05:36.856]   - Field: ‘state’
[18:05:36.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:36.857] - Launch lazy future ...
[18:05:36.858] Packages needed by the future expression (n = 1): ‘future’
[18:05:36.858] Packages needed by future strategies (n = 1): ‘future’
[18:05:36.859] {
[18:05:36.859]     {
[18:05:36.859]         {
[18:05:36.859]             ...future.startTime <- base::Sys.time()
[18:05:36.859]             {
[18:05:36.859]                 {
[18:05:36.859]                   {
[18:05:36.859]                     {
[18:05:36.859]                       {
[18:05:36.859]                         base::local({
[18:05:36.859]                           has_future <- base::requireNamespace("future", 
[18:05:36.859]                             quietly = TRUE)
[18:05:36.859]                           if (has_future) {
[18:05:36.859]                             ns <- base::getNamespace("future")
[18:05:36.859]                             version <- ns[[".package"]][["version"]]
[18:05:36.859]                             if (is.null(version)) 
[18:05:36.859]                               version <- utils::packageVersion("future")
[18:05:36.859]                           }
[18:05:36.859]                           else {
[18:05:36.859]                             version <- NULL
[18:05:36.859]                           }
[18:05:36.859]                           if (!has_future || version < "1.8.0") {
[18:05:36.859]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.859]                               "", base::R.version$version.string), 
[18:05:36.859]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:36.859]                                 base::R.version$platform, 8 * 
[18:05:36.859]                                   base::.Machine$sizeof.pointer), 
[18:05:36.859]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.859]                                 "release", "version")], collapse = " "), 
[18:05:36.859]                               hostname = base::Sys.info()[["nodename"]])
[18:05:36.859]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.859]                               info)
[18:05:36.859]                             info <- base::paste(info, collapse = "; ")
[18:05:36.859]                             if (!has_future) {
[18:05:36.859]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.859]                                 info)
[18:05:36.859]                             }
[18:05:36.859]                             else {
[18:05:36.859]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.859]                                 info, version)
[18:05:36.859]                             }
[18:05:36.859]                             base::stop(msg)
[18:05:36.859]                           }
[18:05:36.859]                         })
[18:05:36.859]                       }
[18:05:36.859]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:36.859]                       base::options(mc.cores = 1L)
[18:05:36.859]                     }
[18:05:36.859]                     base::local({
[18:05:36.859]                       for (pkg in "future") {
[18:05:36.859]                         base::loadNamespace(pkg)
[18:05:36.859]                         base::library(pkg, character.only = TRUE)
[18:05:36.859]                       }
[18:05:36.859]                     })
[18:05:36.859]                   }
[18:05:36.859]                   ...future.strategy.old <- future::plan("list")
[18:05:36.859]                   options(future.plan = NULL)
[18:05:36.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.859]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:36.859]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:36.859]                     envir = parent.frame()) 
[18:05:36.859]                   {
[18:05:36.859]                     if (is.function(workers)) 
[18:05:36.859]                       workers <- workers()
[18:05:36.859]                     workers <- structure(as.integer(workers), 
[18:05:36.859]                       class = class(workers))
[18:05:36.859]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:36.859]                       workers >= 1)
[18:05:36.859]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:36.859]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:36.859]                     }
[18:05:36.859]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:36.859]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:36.859]                       envir = envir)
[18:05:36.859]                     if (!future$lazy) 
[18:05:36.859]                       future <- run(future)
[18:05:36.859]                     invisible(future)
[18:05:36.859]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:36.859]                 }
[18:05:36.859]                 ...future.workdir <- getwd()
[18:05:36.859]             }
[18:05:36.859]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.859]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.859]         }
[18:05:36.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.859]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.859]             base::names(...future.oldOptions))
[18:05:36.859]     }
[18:05:36.859]     if (FALSE) {
[18:05:36.859]     }
[18:05:36.859]     else {
[18:05:36.859]         if (TRUE) {
[18:05:36.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.859]                 open = "w")
[18:05:36.859]         }
[18:05:36.859]         else {
[18:05:36.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.859]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.859]         }
[18:05:36.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.859]             base::sink(type = "output", split = FALSE)
[18:05:36.859]             base::close(...future.stdout)
[18:05:36.859]         }, add = TRUE)
[18:05:36.859]     }
[18:05:36.859]     ...future.frame <- base::sys.nframe()
[18:05:36.859]     ...future.conditions <- base::list()
[18:05:36.859]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.859]     if (FALSE) {
[18:05:36.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.859]     }
[18:05:36.859]     ...future.result <- base::tryCatch({
[18:05:36.859]         base::withCallingHandlers({
[18:05:36.859]             ...future.value <- base::withVisible(base::local({
[18:05:36.859]                 withCallingHandlers({
[18:05:36.859]                   {
[18:05:36.859]                     a <- 1L
[18:05:36.859]                     plan_a <- unclass(future::plan("list"))
[18:05:36.859]                     nested_a <- nested[-1]
[18:05:36.859]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:36.859]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:36.859]                       strategy2))
[18:05:36.859]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:36.859]                       "init") <- NULL
[18:05:36.859]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:36.859]                       "init") <- NULL
[18:05:36.859]                     stopifnot(all.equal(plan_a, nested_a))
[18:05:36.859]                     y %<-% {
[18:05:36.859]                       b <- 2L
[18:05:36.859]                       plan_b <- future::plan("list")
[18:05:36.859]                       nested_b <- nested_a[-1]
[18:05:36.859]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:36.859]                         1L, inherits(plan_b[[1]], "future"), 
[18:05:36.859]                         inherits(future::plan("next"), "sequential"))
[18:05:36.859]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:36.859]                         b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:36.859]                     }
[18:05:36.859]                     y
[18:05:36.859]                   }
[18:05:36.859]                 }, immediateCondition = function(cond) {
[18:05:36.859]                   save_rds <- function (object, pathname, ...) 
[18:05:36.859]                   {
[18:05:36.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:36.859]                     if (file_test("-f", pathname_tmp)) {
[18:05:36.859]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:36.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.859]                         fi_tmp[["mtime"]])
[18:05:36.859]                     }
[18:05:36.859]                     tryCatch({
[18:05:36.859]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:36.859]                     }, error = function(ex) {
[18:05:36.859]                       msg <- conditionMessage(ex)
[18:05:36.859]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:36.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.859]                         fi_tmp[["mtime"]], msg)
[18:05:36.859]                       ex$message <- msg
[18:05:36.859]                       stop(ex)
[18:05:36.859]                     })
[18:05:36.859]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:36.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:36.859]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:36.859]                       fi_tmp <- file.info(pathname_tmp)
[18:05:36.859]                       fi <- file.info(pathname)
[18:05:36.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:36.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:36.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:36.859]                         fi[["size"]], fi[["mtime"]])
[18:05:36.859]                       stop(msg)
[18:05:36.859]                     }
[18:05:36.859]                     invisible(pathname)
[18:05:36.859]                   }
[18:05:36.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:36.859]                     rootPath = tempdir()) 
[18:05:36.859]                   {
[18:05:36.859]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:36.859]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:36.859]                       tmpdir = path, fileext = ".rds")
[18:05:36.859]                     save_rds(obj, file)
[18:05:36.859]                   }
[18:05:36.859]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:36.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.859]                   {
[18:05:36.859]                     inherits <- base::inherits
[18:05:36.859]                     invokeRestart <- base::invokeRestart
[18:05:36.859]                     is.null <- base::is.null
[18:05:36.859]                     muffled <- FALSE
[18:05:36.859]                     if (inherits(cond, "message")) {
[18:05:36.859]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:36.859]                       if (muffled) 
[18:05:36.859]                         invokeRestart("muffleMessage")
[18:05:36.859]                     }
[18:05:36.859]                     else if (inherits(cond, "warning")) {
[18:05:36.859]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:36.859]                       if (muffled) 
[18:05:36.859]                         invokeRestart("muffleWarning")
[18:05:36.859]                     }
[18:05:36.859]                     else if (inherits(cond, "condition")) {
[18:05:36.859]                       if (!is.null(pattern)) {
[18:05:36.859]                         computeRestarts <- base::computeRestarts
[18:05:36.859]                         grepl <- base::grepl
[18:05:36.859]                         restarts <- computeRestarts(cond)
[18:05:36.859]                         for (restart in restarts) {
[18:05:36.859]                           name <- restart$name
[18:05:36.859]                           if (is.null(name)) 
[18:05:36.859]                             next
[18:05:36.859]                           if (!grepl(pattern, name)) 
[18:05:36.859]                             next
[18:05:36.859]                           invokeRestart(restart)
[18:05:36.859]                           muffled <- TRUE
[18:05:36.859]                           break
[18:05:36.859]                         }
[18:05:36.859]                       }
[18:05:36.859]                     }
[18:05:36.859]                     invisible(muffled)
[18:05:36.859]                   }
[18:05:36.859]                   muffleCondition(cond)
[18:05:36.859]                 })
[18:05:36.859]             }))
[18:05:36.859]             future::FutureResult(value = ...future.value$value, 
[18:05:36.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.859]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.859]                     ...future.globalenv.names))
[18:05:36.859]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.859]         }, condition = base::local({
[18:05:36.859]             c <- base::c
[18:05:36.859]             inherits <- base::inherits
[18:05:36.859]             invokeRestart <- base::invokeRestart
[18:05:36.859]             length <- base::length
[18:05:36.859]             list <- base::list
[18:05:36.859]             seq.int <- base::seq.int
[18:05:36.859]             signalCondition <- base::signalCondition
[18:05:36.859]             sys.calls <- base::sys.calls
[18:05:36.859]             `[[` <- base::`[[`
[18:05:36.859]             `+` <- base::`+`
[18:05:36.859]             `<<-` <- base::`<<-`
[18:05:36.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.859]                   3L)]
[18:05:36.859]             }
[18:05:36.859]             function(cond) {
[18:05:36.859]                 is_error <- inherits(cond, "error")
[18:05:36.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.859]                   NULL)
[18:05:36.859]                 if (is_error) {
[18:05:36.859]                   sessionInformation <- function() {
[18:05:36.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.859]                       search = base::search(), system = base::Sys.info())
[18:05:36.859]                   }
[18:05:36.859]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.859]                     cond$call), session = sessionInformation(), 
[18:05:36.859]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.859]                   signalCondition(cond)
[18:05:36.859]                 }
[18:05:36.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.859]                 "immediateCondition"))) {
[18:05:36.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.859]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.859]                   if (TRUE && !signal) {
[18:05:36.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.859]                     {
[18:05:36.859]                       inherits <- base::inherits
[18:05:36.859]                       invokeRestart <- base::invokeRestart
[18:05:36.859]                       is.null <- base::is.null
[18:05:36.859]                       muffled <- FALSE
[18:05:36.859]                       if (inherits(cond, "message")) {
[18:05:36.859]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.859]                         if (muffled) 
[18:05:36.859]                           invokeRestart("muffleMessage")
[18:05:36.859]                       }
[18:05:36.859]                       else if (inherits(cond, "warning")) {
[18:05:36.859]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.859]                         if (muffled) 
[18:05:36.859]                           invokeRestart("muffleWarning")
[18:05:36.859]                       }
[18:05:36.859]                       else if (inherits(cond, "condition")) {
[18:05:36.859]                         if (!is.null(pattern)) {
[18:05:36.859]                           computeRestarts <- base::computeRestarts
[18:05:36.859]                           grepl <- base::grepl
[18:05:36.859]                           restarts <- computeRestarts(cond)
[18:05:36.859]                           for (restart in restarts) {
[18:05:36.859]                             name <- restart$name
[18:05:36.859]                             if (is.null(name)) 
[18:05:36.859]                               next
[18:05:36.859]                             if (!grepl(pattern, name)) 
[18:05:36.859]                               next
[18:05:36.859]                             invokeRestart(restart)
[18:05:36.859]                             muffled <- TRUE
[18:05:36.859]                             break
[18:05:36.859]                           }
[18:05:36.859]                         }
[18:05:36.859]                       }
[18:05:36.859]                       invisible(muffled)
[18:05:36.859]                     }
[18:05:36.859]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.859]                   }
[18:05:36.859]                 }
[18:05:36.859]                 else {
[18:05:36.859]                   if (TRUE) {
[18:05:36.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.859]                     {
[18:05:36.859]                       inherits <- base::inherits
[18:05:36.859]                       invokeRestart <- base::invokeRestart
[18:05:36.859]                       is.null <- base::is.null
[18:05:36.859]                       muffled <- FALSE
[18:05:36.859]                       if (inherits(cond, "message")) {
[18:05:36.859]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.859]                         if (muffled) 
[18:05:36.859]                           invokeRestart("muffleMessage")
[18:05:36.859]                       }
[18:05:36.859]                       else if (inherits(cond, "warning")) {
[18:05:36.859]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.859]                         if (muffled) 
[18:05:36.859]                           invokeRestart("muffleWarning")
[18:05:36.859]                       }
[18:05:36.859]                       else if (inherits(cond, "condition")) {
[18:05:36.859]                         if (!is.null(pattern)) {
[18:05:36.859]                           computeRestarts <- base::computeRestarts
[18:05:36.859]                           grepl <- base::grepl
[18:05:36.859]                           restarts <- computeRestarts(cond)
[18:05:36.859]                           for (restart in restarts) {
[18:05:36.859]                             name <- restart$name
[18:05:36.859]                             if (is.null(name)) 
[18:05:36.859]                               next
[18:05:36.859]                             if (!grepl(pattern, name)) 
[18:05:36.859]                               next
[18:05:36.859]                             invokeRestart(restart)
[18:05:36.859]                             muffled <- TRUE
[18:05:36.859]                             break
[18:05:36.859]                           }
[18:05:36.859]                         }
[18:05:36.859]                       }
[18:05:36.859]                       invisible(muffled)
[18:05:36.859]                     }
[18:05:36.859]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.859]                   }
[18:05:36.859]                 }
[18:05:36.859]             }
[18:05:36.859]         }))
[18:05:36.859]     }, error = function(ex) {
[18:05:36.859]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.859]                 ...future.rng), started = ...future.startTime, 
[18:05:36.859]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.859]             version = "1.8"), class = "FutureResult")
[18:05:36.859]     }, finally = {
[18:05:36.859]         if (!identical(...future.workdir, getwd())) 
[18:05:36.859]             setwd(...future.workdir)
[18:05:36.859]         {
[18:05:36.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.859]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.859]             }
[18:05:36.859]             base::options(...future.oldOptions)
[18:05:36.859]             if (.Platform$OS.type == "windows") {
[18:05:36.859]                 old_names <- names(...future.oldEnvVars)
[18:05:36.859]                 envs <- base::Sys.getenv()
[18:05:36.859]                 names <- names(envs)
[18:05:36.859]                 common <- intersect(names, old_names)
[18:05:36.859]                 added <- setdiff(names, old_names)
[18:05:36.859]                 removed <- setdiff(old_names, names)
[18:05:36.859]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.859]                   envs[common]]
[18:05:36.859]                 NAMES <- toupper(changed)
[18:05:36.859]                 args <- list()
[18:05:36.859]                 for (kk in seq_along(NAMES)) {
[18:05:36.859]                   name <- changed[[kk]]
[18:05:36.859]                   NAME <- NAMES[[kk]]
[18:05:36.859]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.859]                     next
[18:05:36.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.859]                 }
[18:05:36.859]                 NAMES <- toupper(added)
[18:05:36.859]                 for (kk in seq_along(NAMES)) {
[18:05:36.859]                   name <- added[[kk]]
[18:05:36.859]                   NAME <- NAMES[[kk]]
[18:05:36.859]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.859]                     next
[18:05:36.859]                   args[[name]] <- ""
[18:05:36.859]                 }
[18:05:36.859]                 NAMES <- toupper(removed)
[18:05:36.859]                 for (kk in seq_along(NAMES)) {
[18:05:36.859]                   name <- removed[[kk]]
[18:05:36.859]                   NAME <- NAMES[[kk]]
[18:05:36.859]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.859]                     next
[18:05:36.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.859]                 }
[18:05:36.859]                 if (length(args) > 0) 
[18:05:36.859]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.859]             }
[18:05:36.859]             else {
[18:05:36.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.859]             }
[18:05:36.859]             {
[18:05:36.859]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.859]                   0L) {
[18:05:36.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.859]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.859]                   base::options(opts)
[18:05:36.859]                 }
[18:05:36.859]                 {
[18:05:36.859]                   {
[18:05:36.859]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:36.859]                     NULL
[18:05:36.859]                   }
[18:05:36.859]                   options(future.plan = NULL)
[18:05:36.859]                   if (is.na(NA_character_)) 
[18:05:36.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.859]                     .init = FALSE)
[18:05:36.859]                 }
[18:05:36.859]             }
[18:05:36.859]         }
[18:05:36.859]     })
[18:05:36.859]     if (TRUE) {
[18:05:36.859]         base::sink(type = "output", split = FALSE)
[18:05:36.859]         if (TRUE) {
[18:05:36.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.859]         }
[18:05:36.859]         else {
[18:05:36.859]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.859]         }
[18:05:36.859]         base::close(...future.stdout)
[18:05:36.859]         ...future.stdout <- NULL
[18:05:36.859]     }
[18:05:36.859]     ...future.result$conditions <- ...future.conditions
[18:05:36.859]     ...future.result$finished <- base::Sys.time()
[18:05:36.859]     ...future.result
[18:05:36.859] }
[18:05:36.865] assign_globals() ...
[18:05:36.865] List of 2
[18:05:36.865]  $ nested   :List of 2
[18:05:36.865]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[18:05:36.865]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[18:05:36.865]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.865]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:36.865]     envir = parent.frame())  
[18:05:36.865]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[18:05:36.865]   .. ..- attr(*, "init")= logi TRUE
[18:05:36.865]   .. ..- attr(*, "untweakable")= chr "persistent"
[18:05:36.865]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.865]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:36.865]  $ strategy2: chr "multisession"
[18:05:36.865]  - attr(*, "where")=List of 2
[18:05:36.865]   ..$ nested   :<environment: R_EmptyEnv> 
[18:05:36.865]   ..$ strategy2:<environment: R_EmptyEnv> 
[18:05:36.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.865]  - attr(*, "resolved")= logi FALSE
[18:05:36.865]  - attr(*, "total_size")= num 92816
[18:05:36.865]  - attr(*, "already-done")= logi TRUE
[18:05:36.878] - copied ‘nested’ to environment
[18:05:36.878] - copied ‘strategy2’ to environment
[18:05:36.878] assign_globals() ... done
[18:05:36.878] requestCore(): workers = 2
[18:05:36.882] MulticoreFuture started
[18:05:36.883] - Launch lazy future ... done
[18:05:36.884] run() for ‘MulticoreFuture’ ... done
[18:05:36.885] result() for MulticoreFuture ...
[18:05:36.885] plan(): Setting new future strategy stack:
[18:05:36.885] List of future strategies:
[18:05:36.885] 1. multisession:
[18:05:36.885]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:36.885]    - tweaked: FALSE
[18:05:36.885]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.895] plan(): nbrOfWorkers() = 1
[18:05:36.982] plan(): Setting new future strategy stack:
[18:05:36.982] List of future strategies:
[18:05:36.982] 1. multicore:
[18:05:36.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:36.982]    - tweaked: FALSE
[18:05:36.982]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.982] 2. multisession:
[18:05:36.982]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:36.982]    - tweaked: FALSE
[18:05:36.982]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:36.990] plan(): nbrOfWorkers() = 2
[18:05:36.993] result() for MulticoreFuture ...
[18:05:36.993] result() for MulticoreFuture ... done
[18:05:36.993] signalConditions() ...
[18:05:36.993]  - include = ‘immediateCondition’
[18:05:36.994]  - exclude = 
[18:05:36.994]  - resignal = FALSE
[18:05:36.994]  - Number of conditions: 54
[18:05:36.995] signalConditions() ... done
[18:05:36.995] result() for MulticoreFuture ... done
[18:05:36.995] result() for MulticoreFuture ...
[18:05:36.995] result() for MulticoreFuture ... done
[18:05:36.996] signalConditions() ...
[18:05:36.996]  - include = ‘immediateCondition’
[18:05:36.996]  - exclude = 
[18:05:36.996]  - resignal = FALSE
[18:05:36.997]  - Number of conditions: 54
[18:05:36.997] signalConditions() ... done
[18:05:36.997] Future state: ‘finished’
[18:05:36.997] result() for MulticoreFuture ...
[18:05:36.998] result() for MulticoreFuture ... done
[18:05:36.998] signalConditions() ...
[18:05:36.998]  - include = ‘condition’
[18:05:36.998]  - exclude = ‘immediateCondition’
[18:05:36.999]  - resignal = TRUE
[18:05:36.999]  - Number of conditions: 54
[18:05:36.999]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.899] getGlobalsAndPackages() ...
[18:05:36.999]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.900] Searching for globals...
[18:05:37.000]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.917] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[18:05:37.000]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.917] Searching for globals ... DONE
[18:05:37.000]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.918] Resolving globals: FALSE
[18:05:37.001]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.920] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[18:05:37.001]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.922] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[18:05:37.001]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.922] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[18:05:37.002]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.923] 
[18:05:37.002]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.923] getGlobalsAndPackages() ... DONE
[18:05:37.002]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.925] run() for ‘Future’ ...
[18:05:37.003]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.925] - state: ‘created’
[18:05:37.003]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:37.003]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.933] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:37.004]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:37.004]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.934]   - Field: ‘label’
[18:05:37.004]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.934]   - Field: ‘local’
[18:05:37.005]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.934]   - Field: ‘owner’
[18:05:37.005]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.935]   - Field: ‘envir’
[18:05:37.005]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.935]   - Field: ‘packages’
[18:05:37.005]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.935]   - Field: ‘gc’
[18:05:37.006]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.936]   - Field: ‘conditions’
[18:05:37.006]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.936]   - Field: ‘expr’
[18:05:37.006]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.936]   - Field: ‘uuid’
[18:05:37.007]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.937]   - Field: ‘seed’
[18:05:37.007]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.937]   - Field: ‘version’
[18:05:37.007]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.938]   - Field: ‘result’
[18:05:37.008]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.938]   - Field: ‘asynchronous’
[18:05:37.008]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.938]   - Field: ‘calls’
[18:05:37.008]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.939]   - Field: ‘globals’
[18:05:37.009]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.939]   - Field: ‘stdout’
[18:05:37.009]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.939]   - Field: ‘earlySignal’
[18:05:37.009]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.940]   - Field: ‘lazy’
[18:05:37.010]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.940]   - Field: ‘state’
[18:05:37.010]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:37.010]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.941] - Launch lazy future ...
[18:05:37.011]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.941] Packages needed by the future expression (n = 0): <none>
[18:05:37.011]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.942] Packages needed by future strategies (n = 0): <none>
[18:05:37.011]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.943] {
[18:05:36.943]     {
[18:05:36.943]         {
[18:05:36.943]             ...future.startTime <- base::Sys.time()
[18:05:36.943]             {
[18:05:36.943]                 {
[18:05:36.943]                   {
[18:05:36.943]                     base::local({
[18:05:36.943]                       has_future <- base::requireNamespace("future", 
[18:05:36.943]                         quietly = TRUE)
[18:05:36.943]                       if (has_future) {
[18:05:36.943]                         ns <- base::getNamespace("future")
[18:05:36.943]                         version <- ns[[".package"]][["version"]]
[18:05:36.943]                         if (is.null(version)) 
[18:05:36.943]                           version <- utils::packageVersion("future")
[18:05:36.943]                       }
[18:05:36.943]                       else {
[18:05:36.943]                         version <- NULL
[18:05:36.943]                       }
[18:05:36.943]                       if (!has_future || version < "1.8.0") {
[18:05:36.943]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:36.943]                           "", base::R.version$version.string), 
[18:05:36.943]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:36.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:36.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:36.943]                             "release", "version")], collapse = " "), 
[18:05:36.943]                           hostname = base::Sys.info()[["nodename"]])
[18:05:36.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:36.943]                           info)
[18:05:36.943]                         info <- base::paste(info, collapse = "; ")
[18:05:36.943]                         if (!has_future) {
[18:05:36.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:36.943]                             info)
[18:05:36.943]                         }
[18:05:36.943]                         else {
[18:05:36.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:36.943]                             info, version)
[18:05:36.943]                         }
[18:05:36.943]                         base::stop(msg)
[18:05:36.943]                       }
[18:05:36.943]                     })
[18:05:36.943]                   }
[18:05:36.943]                   ...future.strategy.old <- future::plan("list")
[18:05:36.943]                   options(future.plan = NULL)
[18:05:36.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:36.943]                 }
[18:05:36.943]                 ...future.workdir <- getwd()
[18:05:36.943]             }
[18:05:36.943]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:36.943]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:36.943]         }
[18:05:36.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:36.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:36.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:36.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:36.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:36.943]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:36.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:36.943]             base::names(...future.oldOptions))
[18:05:36.943]     }
[18:05:36.943]     if (FALSE) {
[18:05:36.943]     }
[18:05:36.943]     else {
[18:05:36.943]         if (TRUE) {
[18:05:36.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:36.943]                 open = "w")
[18:05:36.943]         }
[18:05:36.943]         else {
[18:05:36.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:36.943]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:36.943]         }
[18:05:36.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:36.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:36.943]             base::sink(type = "output", split = FALSE)
[18:05:36.943]             base::close(...future.stdout)
[18:05:36.943]         }, add = TRUE)
[18:05:36.943]     }
[18:05:36.943]     ...future.frame <- base::sys.nframe()
[18:05:36.943]     ...future.conditions <- base::list()
[18:05:36.943]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:36.943]     if (FALSE) {
[18:05:36.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:36.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:36.943]     }
[18:05:36.943]     ...future.result <- base::tryCatch({
[18:05:36.943]         base::withCallingHandlers({
[18:05:36.943]             ...future.value <- base::withVisible(base::local({
[18:05:36.943]                 b <- 2L
[18:05:36.943]                 plan_b <- future::plan("list")
[18:05:36.943]                 nested_b <- nested_a[-1]
[18:05:36.943]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:36.943]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[18:05:36.943]                   "sequential"))
[18:05:36.943]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:36.943]                   b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:36.943]             }))
[18:05:36.943]             future::FutureResult(value = ...future.value$value, 
[18:05:36.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.943]                   ...future.rng), globalenv = if (FALSE) 
[18:05:36.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:36.943]                     ...future.globalenv.names))
[18:05:36.943]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:36.943]         }, condition = base::local({
[18:05:36.943]             c <- base::c
[18:05:36.943]             inherits <- base::inherits
[18:05:36.943]             invokeRestart <- base::invokeRestart
[18:05:36.943]             length <- base::length
[18:05:36.943]             list <- base::list
[18:05:36.943]             seq.int <- base::seq.int
[18:05:36.943]             signalCondition <- base::signalCondition
[18:05:36.943]             sys.calls <- base::sys.calls
[18:05:36.943]             `[[` <- base::`[[`
[18:05:36.943]             `+` <- base::`+`
[18:05:36.943]             `<<-` <- base::`<<-`
[18:05:36.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:36.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:36.943]                   3L)]
[18:05:36.943]             }
[18:05:36.943]             function(cond) {
[18:05:36.943]                 is_error <- inherits(cond, "error")
[18:05:36.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:36.943]                   NULL)
[18:05:36.943]                 if (is_error) {
[18:05:36.943]                   sessionInformation <- function() {
[18:05:36.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:36.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:36.943]                       search = base::search(), system = base::Sys.info())
[18:05:36.943]                   }
[18:05:36.943]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:36.943]                     cond$call), session = sessionInformation(), 
[18:05:36.943]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:36.943]                   signalCondition(cond)
[18:05:36.943]                 }
[18:05:36.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:36.943]                 "immediateCondition"))) {
[18:05:36.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:36.943]                   ...future.conditions[[length(...future.conditions) + 
[18:05:36.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:36.943]                   if (TRUE && !signal) {
[18:05:36.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.943]                     {
[18:05:36.943]                       inherits <- base::inherits
[18:05:36.943]                       invokeRestart <- base::invokeRestart
[18:05:36.943]                       is.null <- base::is.null
[18:05:36.943]                       muffled <- FALSE
[18:05:36.943]                       if (inherits(cond, "message")) {
[18:05:36.943]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.943]                         if (muffled) 
[18:05:36.943]                           invokeRestart("muffleMessage")
[18:05:36.943]                       }
[18:05:36.943]                       else if (inherits(cond, "warning")) {
[18:05:36.943]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.943]                         if (muffled) 
[18:05:36.943]                           invokeRestart("muffleWarning")
[18:05:36.943]                       }
[18:05:36.943]                       else if (inherits(cond, "condition")) {
[18:05:36.943]                         if (!is.null(pattern)) {
[18:05:36.943]                           computeRestarts <- base::computeRestarts
[18:05:36.943]                           grepl <- base::grepl
[18:05:36.943]                           restarts <- computeRestarts(cond)
[18:05:36.943]                           for (restart in restarts) {
[18:05:36.943]                             name <- restart$name
[18:05:36.943]                             if (is.null(name)) 
[18:05:36.943]                               next
[18:05:36.943]                             if (!grepl(pattern, name)) 
[18:05:36.943]                               next
[18:05:36.943]                             invokeRestart(restart)
[18:05:36.943]                             muffled <- TRUE
[18:05:36.943]                             break
[18:05:36.943]                           }
[18:05:36.943]                         }
[18:05:36.943]                       }
[18:05:36.943]                       invisible(muffled)
[18:05:36.943]                     }
[18:05:36.943]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.943]                   }
[18:05:36.943]                 }
[18:05:36.943]                 else {
[18:05:36.943]                   if (TRUE) {
[18:05:36.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:36.943]                     {
[18:05:36.943]                       inherits <- base::inherits
[18:05:36.943]                       invokeRestart <- base::invokeRestart
[18:05:36.943]                       is.null <- base::is.null
[18:05:36.943]                       muffled <- FALSE
[18:05:36.943]                       if (inherits(cond, "message")) {
[18:05:36.943]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:36.943]                         if (muffled) 
[18:05:36.943]                           invokeRestart("muffleMessage")
[18:05:36.943]                       }
[18:05:36.943]                       else if (inherits(cond, "warning")) {
[18:05:36.943]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:36.943]                         if (muffled) 
[18:05:36.943]                           invokeRestart("muffleWarning")
[18:05:36.943]                       }
[18:05:36.943]                       else if (inherits(cond, "condition")) {
[18:05:36.943]                         if (!is.null(pattern)) {
[18:05:36.943]                           computeRestarts <- base::computeRestarts
[18:05:36.943]                           grepl <- base::grepl
[18:05:36.943]                           restarts <- computeRestarts(cond)
[18:05:36.943]                           for (restart in restarts) {
[18:05:36.943]                             name <- restart$name
[18:05:36.943]                             if (is.null(name)) 
[18:05:36.943]                               next
[18:05:36.943]                             if (!grepl(pattern, name)) 
[18:05:36.943]                               next
[18:05:36.943]                             invokeRestart(restart)
[18:05:36.943]                             muffled <- TRUE
[18:05:36.943]                             break
[18:05:36.943]                           }
[18:05:36.943]                         }
[18:05:36.943]                       }
[18:05:36.943]                       invisible(muffled)
[18:05:36.943]                     }
[18:05:36.943]                     muffleCondition(cond, pattern = "^muffle")
[18:05:36.943]                   }
[18:05:36.943]                 }
[18:05:36.943]             }
[18:05:36.943]         }))
[18:05:36.943]     }, error = function(ex) {
[18:05:36.943]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:36.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:36.943]                 ...future.rng), started = ...future.startTime, 
[18:05:36.943]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:36.943]             version = "1.8"), class = "FutureResult")
[18:05:36.943]     }, finally = {
[18:05:36.943]         if (!identical(...future.workdir, getwd())) 
[18:05:36.943]             setwd(...future.workdir)
[18:05:36.943]         {
[18:05:36.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:36.943]                 ...future.oldOptions$nwarnings <- NULL
[18:05:36.943]             }
[18:05:36.943]             base::options(...future.oldOptions)
[18:05:36.943]             if (.Platform$OS.type == "windows") {
[18:05:36.943]                 old_names <- names(...future.oldEnvVars)
[18:05:36.943]                 envs <- base::Sys.getenv()
[18:05:36.943]                 names <- names(envs)
[18:05:36.943]                 common <- intersect(names, old_names)
[18:05:36.943]                 added <- setdiff(names, old_names)
[18:05:36.943]                 removed <- setdiff(old_names, names)
[18:05:36.943]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:36.943]                   envs[common]]
[18:05:36.943]                 NAMES <- toupper(changed)
[18:05:36.943]                 args <- list()
[18:05:36.943]                 for (kk in seq_along(NAMES)) {
[18:05:36.943]                   name <- changed[[kk]]
[18:05:36.943]                   NAME <- NAMES[[kk]]
[18:05:36.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.943]                     next
[18:05:36.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.943]                 }
[18:05:36.943]                 NAMES <- toupper(added)
[18:05:36.943]                 for (kk in seq_along(NAMES)) {
[18:05:36.943]                   name <- added[[kk]]
[18:05:36.943]                   NAME <- NAMES[[kk]]
[18:05:36.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.943]                     next
[18:05:36.943]                   args[[name]] <- ""
[18:05:36.943]                 }
[18:05:36.943]                 NAMES <- toupper(removed)
[18:05:36.943]                 for (kk in seq_along(NAMES)) {
[18:05:36.943]                   name <- removed[[kk]]
[18:05:36.943]                   NAME <- NAMES[[kk]]
[18:05:36.943]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:36.943]                     next
[18:05:36.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:36.943]                 }
[18:05:36.943]                 if (length(args) > 0) 
[18:05:36.943]                   base::do.call(base::Sys.setenv, args = args)
[18:05:36.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:36.943]             }
[18:05:36.943]             else {
[18:05:36.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:36.943]             }
[18:05:36.943]             {
[18:05:36.943]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:36.943]                   0L) {
[18:05:36.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:36.943]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:36.943]                   base::options(opts)
[18:05:36.943]                 }
[18:05:36.943]                 {
[18:05:36.943]                   {
[18:05:36.943]                     NULL
[18:05:36.943]                     RNGkind("Mersenne-Twister")
[18:05:36.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:36.943]                       inherits = FALSE)
[18:05:36.943]                   }
[18:05:36.943]                   options(future.plan = NULL)
[18:05:36.943]                   if (is.na(NA_character_)) 
[18:05:36.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:36.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:36.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:36.943]                     .init = FALSE)
[18:05:36.943]                 }
[18:05:36.943]             }
[18:05:36.943]         }
[18:05:36.943]     })
[18:05:36.943]     if (TRUE) {
[18:05:36.943]         base::sink(type = "output", split = FALSE)
[18:05:36.943]         if (TRUE) {
[18:05:36.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:36.943]         }
[18:05:36.943]         else {
[18:05:36.943]             ...future.result["stdout"] <- base::list(NULL)
[18:05:36.943]         }
[18:05:36.943]         base::close(...future.stdout)
[18:05:36.943]         ...future.stdout <- NULL
[18:05:36.943]     }
[18:05:36.943]     ...future.result$conditions <- ...future.conditions
[18:05:36.943]     ...future.result$finished <- base::Sys.time()
[18:05:36.943]     ...future.result
[18:05:36.943] }
[18:05:37.012]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.948] assign_globals() ...
[18:05:37.012]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.948] List of 3
[18:05:36.948]  $ nested_a:List of 1
[18:05:36.948]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:36.948]     envir = parent.frame())  
[18:05:36.948]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[18:05:36.948]   .. ..- attr(*, "untweakable")= chr "persistent"
[18:05:36.948]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.948]  $ a       : int 1
[18:05:36.948]  $ plan_a  :List of 1
[18:05:36.948]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:36.948]     envir = parent.frame())  
[18:05:36.948]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[18:05:36.948]   .. ..- attr(*, "untweakable")= chr "persistent"
[18:05:36.948]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[18:05:36.948]  - attr(*, "where")=List of 3
[18:05:36.948]   ..$ nested_a:<environment: R_EmptyEnv> 
[18:05:36.948]   ..$ a       :<environment: R_EmptyEnv> 
[18:05:36.948]   ..$ plan_a  :<environment: R_EmptyEnv> 
[18:05:36.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:36.948]  - attr(*, "resolved")= logi FALSE
[18:05:36.948]  - attr(*, "total_size")= num 89928
[18:05:36.948]  - attr(*, "already-done")= logi TRUE
[18:05:37.012]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.965] - copied ‘nested_a’ to environment
[18:05:37.013]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.966] - copied ‘a’ to environment
[18:05:37.013]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.966] - copied ‘plan_a’ to environment
[18:05:37.013]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.966] assign_globals() ... done
[18:05:37.014]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.967] plan(): Setting new future strategy stack:
[18:05:37.014]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.967] List of future strategies:
[18:05:36.967] 1. sequential:
[18:05:36.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:36.967]    - tweaked: FALSE
[18:05:36.967]    - call: NULL
[18:05:37.014]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.969] plan(): nbrOfWorkers() = 1
[18:05:37.015]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.971] plan(): Setting new future strategy stack:
[18:05:37.015]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.971] List of future strategies:
[18:05:36.971] 1. multisession:
[18:05:36.971]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:36.971]    - tweaked: FALSE
[18:05:36.971]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.015]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.979] plan(): nbrOfWorkers() = 1
[18:05:37.015]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.980] SequentialFuture started (and completed)
[18:05:37.016]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.980] - Launch lazy future ... done
[18:05:37.016]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:36.981] run() for ‘SequentialFuture’ ... done
[18:05:37.016] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:37.030] getGlobalsAndPackages() ...
[18:05:37.030] Searching for globals...
[18:05:37.033] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:37.033] Searching for globals ... DONE
[18:05:37.034] Resolving globals: FALSE
[18:05:37.035] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:37.036] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:37.036] - globals: [1] ‘data’
[18:05:37.036] - packages: [1] ‘future’
[18:05:37.037] getGlobalsAndPackages() ... DONE
[18:05:37.037] run() for ‘Future’ ...
[18:05:37.037] - state: ‘created’
[18:05:37.038] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:05:37.045] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:37.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:05:37.046]   - Field: ‘label’
[18:05:37.046]   - Field: ‘local’
[18:05:37.046]   - Field: ‘owner’
[18:05:37.046]   - Field: ‘envir’
[18:05:37.047]   - Field: ‘workers’
[18:05:37.047]   - Field: ‘packages’
[18:05:37.047]   - Field: ‘gc’
[18:05:37.047]   - Field: ‘job’
[18:05:37.047]   - Field: ‘conditions’
[18:05:37.048]   - Field: ‘expr’
[18:05:37.048]   - Field: ‘uuid’
[18:05:37.048]   - Field: ‘seed’
[18:05:37.048]   - Field: ‘version’
[18:05:37.049]   - Field: ‘result’
[18:05:37.049]   - Field: ‘asynchronous’
[18:05:37.049]   - Field: ‘calls’
[18:05:37.049]   - Field: ‘globals’
[18:05:37.050]   - Field: ‘stdout’
[18:05:37.050]   - Field: ‘earlySignal’
[18:05:37.050]   - Field: ‘lazy’
[18:05:37.050]   - Field: ‘state’
[18:05:37.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:05:37.051] - Launch lazy future ...
[18:05:37.051] Packages needed by the future expression (n = 1): ‘future’
[18:05:37.052] Packages needed by future strategies (n = 1): ‘future’
[18:05:37.053] {
[18:05:37.053]     {
[18:05:37.053]         {
[18:05:37.053]             ...future.startTime <- base::Sys.time()
[18:05:37.053]             {
[18:05:37.053]                 {
[18:05:37.053]                   {
[18:05:37.053]                     {
[18:05:37.053]                       {
[18:05:37.053]                         base::local({
[18:05:37.053]                           has_future <- base::requireNamespace("future", 
[18:05:37.053]                             quietly = TRUE)
[18:05:37.053]                           if (has_future) {
[18:05:37.053]                             ns <- base::getNamespace("future")
[18:05:37.053]                             version <- ns[[".package"]][["version"]]
[18:05:37.053]                             if (is.null(version)) 
[18:05:37.053]                               version <- utils::packageVersion("future")
[18:05:37.053]                           }
[18:05:37.053]                           else {
[18:05:37.053]                             version <- NULL
[18:05:37.053]                           }
[18:05:37.053]                           if (!has_future || version < "1.8.0") {
[18:05:37.053]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:37.053]                               "", base::R.version$version.string), 
[18:05:37.053]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:37.053]                                 base::R.version$platform, 8 * 
[18:05:37.053]                                   base::.Machine$sizeof.pointer), 
[18:05:37.053]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:37.053]                                 "release", "version")], collapse = " "), 
[18:05:37.053]                               hostname = base::Sys.info()[["nodename"]])
[18:05:37.053]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:37.053]                               info)
[18:05:37.053]                             info <- base::paste(info, collapse = "; ")
[18:05:37.053]                             if (!has_future) {
[18:05:37.053]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:37.053]                                 info)
[18:05:37.053]                             }
[18:05:37.053]                             else {
[18:05:37.053]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:37.053]                                 info, version)
[18:05:37.053]                             }
[18:05:37.053]                             base::stop(msg)
[18:05:37.053]                           }
[18:05:37.053]                         })
[18:05:37.053]                       }
[18:05:37.053]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:37.053]                       base::options(mc.cores = 1L)
[18:05:37.053]                     }
[18:05:37.053]                     base::local({
[18:05:37.053]                       for (pkg in "future") {
[18:05:37.053]                         base::loadNamespace(pkg)
[18:05:37.053]                         base::library(pkg, character.only = TRUE)
[18:05:37.053]                       }
[18:05:37.053]                     })
[18:05:37.053]                   }
[18:05:37.053]                   ...future.strategy.old <- future::plan("list")
[18:05:37.053]                   options(future.plan = NULL)
[18:05:37.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.053]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:37.053]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:37.053]                     envir = parent.frame()) 
[18:05:37.053]                   {
[18:05:37.053]                     if (is.function(workers)) 
[18:05:37.053]                       workers <- workers()
[18:05:37.053]                     workers <- structure(as.integer(workers), 
[18:05:37.053]                       class = class(workers))
[18:05:37.053]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:37.053]                       workers >= 1)
[18:05:37.053]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:37.053]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:37.053]                     }
[18:05:37.053]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:37.053]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:37.053]                       envir = envir)
[18:05:37.053]                     if (!future$lazy) 
[18:05:37.053]                       future <- run(future)
[18:05:37.053]                     invisible(future)
[18:05:37.053]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:37.053]                 }
[18:05:37.053]                 ...future.workdir <- getwd()
[18:05:37.053]             }
[18:05:37.053]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:37.053]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:37.053]         }
[18:05:37.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:37.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:37.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:37.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:37.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:37.053]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:37.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:37.053]             base::names(...future.oldOptions))
[18:05:37.053]     }
[18:05:37.053]     if (FALSE) {
[18:05:37.053]     }
[18:05:37.053]     else {
[18:05:37.053]         if (TRUE) {
[18:05:37.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:37.053]                 open = "w")
[18:05:37.053]         }
[18:05:37.053]         else {
[18:05:37.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:37.053]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:37.053]         }
[18:05:37.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:37.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:37.053]             base::sink(type = "output", split = FALSE)
[18:05:37.053]             base::close(...future.stdout)
[18:05:37.053]         }, add = TRUE)
[18:05:37.053]     }
[18:05:37.053]     ...future.frame <- base::sys.nframe()
[18:05:37.053]     ...future.conditions <- base::list()
[18:05:37.053]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:37.053]     if (FALSE) {
[18:05:37.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:37.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:37.053]     }
[18:05:37.053]     ...future.result <- base::tryCatch({
[18:05:37.053]         base::withCallingHandlers({
[18:05:37.053]             ...future.value <- base::withVisible(base::local({
[18:05:37.053]                 withCallingHandlers({
[18:05:37.053]                   {
[18:05:37.053]                     value(future(subset(data, a == 2)))
[18:05:37.053]                   }
[18:05:37.053]                 }, immediateCondition = function(cond) {
[18:05:37.053]                   save_rds <- function (object, pathname, ...) 
[18:05:37.053]                   {
[18:05:37.053]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:05:37.053]                     if (file_test("-f", pathname_tmp)) {
[18:05:37.053]                       fi_tmp <- file.info(pathname_tmp)
[18:05:37.053]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:05:37.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:37.053]                         fi_tmp[["mtime"]])
[18:05:37.053]                     }
[18:05:37.053]                     tryCatch({
[18:05:37.053]                       saveRDS(object, file = pathname_tmp, ...)
[18:05:37.053]                     }, error = function(ex) {
[18:05:37.053]                       msg <- conditionMessage(ex)
[18:05:37.053]                       fi_tmp <- file.info(pathname_tmp)
[18:05:37.053]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:05:37.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:37.053]                         fi_tmp[["mtime"]], msg)
[18:05:37.053]                       ex$message <- msg
[18:05:37.053]                       stop(ex)
[18:05:37.053]                     })
[18:05:37.053]                     stopifnot(file_test("-f", pathname_tmp))
[18:05:37.053]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:05:37.053]                     if (!res || file_test("-f", pathname_tmp)) {
[18:05:37.053]                       fi_tmp <- file.info(pathname_tmp)
[18:05:37.053]                       fi <- file.info(pathname)
[18:05:37.053]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:05:37.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:05:37.053]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:05:37.053]                         fi[["size"]], fi[["mtime"]])
[18:05:37.053]                       stop(msg)
[18:05:37.053]                     }
[18:05:37.053]                     invisible(pathname)
[18:05:37.053]                   }
[18:05:37.053]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:05:37.053]                     rootPath = tempdir()) 
[18:05:37.053]                   {
[18:05:37.053]                     obj <- list(time = Sys.time(), condition = cond)
[18:05:37.053]                     file <- tempfile(pattern = class(cond)[1], 
[18:05:37.053]                       tmpdir = path, fileext = ".rds")
[18:05:37.053]                     save_rds(obj, file)
[18:05:37.053]                   }
[18:05:37.053]                   saveImmediateCondition(cond, path = "/tmp/Rtmp6WFnRS/.future/immediateConditions")
[18:05:37.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.053]                   {
[18:05:37.053]                     inherits <- base::inherits
[18:05:37.053]                     invokeRestart <- base::invokeRestart
[18:05:37.053]                     is.null <- base::is.null
[18:05:37.053]                     muffled <- FALSE
[18:05:37.053]                     if (inherits(cond, "message")) {
[18:05:37.053]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:37.053]                       if (muffled) 
[18:05:37.053]                         invokeRestart("muffleMessage")
[18:05:37.053]                     }
[18:05:37.053]                     else if (inherits(cond, "warning")) {
[18:05:37.053]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:37.053]                       if (muffled) 
[18:05:37.053]                         invokeRestart("muffleWarning")
[18:05:37.053]                     }
[18:05:37.053]                     else if (inherits(cond, "condition")) {
[18:05:37.053]                       if (!is.null(pattern)) {
[18:05:37.053]                         computeRestarts <- base::computeRestarts
[18:05:37.053]                         grepl <- base::grepl
[18:05:37.053]                         restarts <- computeRestarts(cond)
[18:05:37.053]                         for (restart in restarts) {
[18:05:37.053]                           name <- restart$name
[18:05:37.053]                           if (is.null(name)) 
[18:05:37.053]                             next
[18:05:37.053]                           if (!grepl(pattern, name)) 
[18:05:37.053]                             next
[18:05:37.053]                           invokeRestart(restart)
[18:05:37.053]                           muffled <- TRUE
[18:05:37.053]                           break
[18:05:37.053]                         }
[18:05:37.053]                       }
[18:05:37.053]                     }
[18:05:37.053]                     invisible(muffled)
[18:05:37.053]                   }
[18:05:37.053]                   muffleCondition(cond)
[18:05:37.053]                 })
[18:05:37.053]             }))
[18:05:37.053]             future::FutureResult(value = ...future.value$value, 
[18:05:37.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.053]                   ...future.rng), globalenv = if (FALSE) 
[18:05:37.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:37.053]                     ...future.globalenv.names))
[18:05:37.053]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:37.053]         }, condition = base::local({
[18:05:37.053]             c <- base::c
[18:05:37.053]             inherits <- base::inherits
[18:05:37.053]             invokeRestart <- base::invokeRestart
[18:05:37.053]             length <- base::length
[18:05:37.053]             list <- base::list
[18:05:37.053]             seq.int <- base::seq.int
[18:05:37.053]             signalCondition <- base::signalCondition
[18:05:37.053]             sys.calls <- base::sys.calls
[18:05:37.053]             `[[` <- base::`[[`
[18:05:37.053]             `+` <- base::`+`
[18:05:37.053]             `<<-` <- base::`<<-`
[18:05:37.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:37.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:37.053]                   3L)]
[18:05:37.053]             }
[18:05:37.053]             function(cond) {
[18:05:37.053]                 is_error <- inherits(cond, "error")
[18:05:37.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:37.053]                   NULL)
[18:05:37.053]                 if (is_error) {
[18:05:37.053]                   sessionInformation <- function() {
[18:05:37.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:37.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:37.053]                       search = base::search(), system = base::Sys.info())
[18:05:37.053]                   }
[18:05:37.053]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:37.053]                     cond$call), session = sessionInformation(), 
[18:05:37.053]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:37.053]                   signalCondition(cond)
[18:05:37.053]                 }
[18:05:37.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:37.053]                 "immediateCondition"))) {
[18:05:37.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:37.053]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:37.053]                   if (TRUE && !signal) {
[18:05:37.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.053]                     {
[18:05:37.053]                       inherits <- base::inherits
[18:05:37.053]                       invokeRestart <- base::invokeRestart
[18:05:37.053]                       is.null <- base::is.null
[18:05:37.053]                       muffled <- FALSE
[18:05:37.053]                       if (inherits(cond, "message")) {
[18:05:37.053]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.053]                         if (muffled) 
[18:05:37.053]                           invokeRestart("muffleMessage")
[18:05:37.053]                       }
[18:05:37.053]                       else if (inherits(cond, "warning")) {
[18:05:37.053]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.053]                         if (muffled) 
[18:05:37.053]                           invokeRestart("muffleWarning")
[18:05:37.053]                       }
[18:05:37.053]                       else if (inherits(cond, "condition")) {
[18:05:37.053]                         if (!is.null(pattern)) {
[18:05:37.053]                           computeRestarts <- base::computeRestarts
[18:05:37.053]                           grepl <- base::grepl
[18:05:37.053]                           restarts <- computeRestarts(cond)
[18:05:37.053]                           for (restart in restarts) {
[18:05:37.053]                             name <- restart$name
[18:05:37.053]                             if (is.null(name)) 
[18:05:37.053]                               next
[18:05:37.053]                             if (!grepl(pattern, name)) 
[18:05:37.053]                               next
[18:05:37.053]                             invokeRestart(restart)
[18:05:37.053]                             muffled <- TRUE
[18:05:37.053]                             break
[18:05:37.053]                           }
[18:05:37.053]                         }
[18:05:37.053]                       }
[18:05:37.053]                       invisible(muffled)
[18:05:37.053]                     }
[18:05:37.053]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.053]                   }
[18:05:37.053]                 }
[18:05:37.053]                 else {
[18:05:37.053]                   if (TRUE) {
[18:05:37.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.053]                     {
[18:05:37.053]                       inherits <- base::inherits
[18:05:37.053]                       invokeRestart <- base::invokeRestart
[18:05:37.053]                       is.null <- base::is.null
[18:05:37.053]                       muffled <- FALSE
[18:05:37.053]                       if (inherits(cond, "message")) {
[18:05:37.053]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.053]                         if (muffled) 
[18:05:37.053]                           invokeRestart("muffleMessage")
[18:05:37.053]                       }
[18:05:37.053]                       else if (inherits(cond, "warning")) {
[18:05:37.053]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.053]                         if (muffled) 
[18:05:37.053]                           invokeRestart("muffleWarning")
[18:05:37.053]                       }
[18:05:37.053]                       else if (inherits(cond, "condition")) {
[18:05:37.053]                         if (!is.null(pattern)) {
[18:05:37.053]                           computeRestarts <- base::computeRestarts
[18:05:37.053]                           grepl <- base::grepl
[18:05:37.053]                           restarts <- computeRestarts(cond)
[18:05:37.053]                           for (restart in restarts) {
[18:05:37.053]                             name <- restart$name
[18:05:37.053]                             if (is.null(name)) 
[18:05:37.053]                               next
[18:05:37.053]                             if (!grepl(pattern, name)) 
[18:05:37.053]                               next
[18:05:37.053]                             invokeRestart(restart)
[18:05:37.053]                             muffled <- TRUE
[18:05:37.053]                             break
[18:05:37.053]                           }
[18:05:37.053]                         }
[18:05:37.053]                       }
[18:05:37.053]                       invisible(muffled)
[18:05:37.053]                     }
[18:05:37.053]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.053]                   }
[18:05:37.053]                 }
[18:05:37.053]             }
[18:05:37.053]         }))
[18:05:37.053]     }, error = function(ex) {
[18:05:37.053]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:37.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.053]                 ...future.rng), started = ...future.startTime, 
[18:05:37.053]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:37.053]             version = "1.8"), class = "FutureResult")
[18:05:37.053]     }, finally = {
[18:05:37.053]         if (!identical(...future.workdir, getwd())) 
[18:05:37.053]             setwd(...future.workdir)
[18:05:37.053]         {
[18:05:37.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:37.053]                 ...future.oldOptions$nwarnings <- NULL
[18:05:37.053]             }
[18:05:37.053]             base::options(...future.oldOptions)
[18:05:37.053]             if (.Platform$OS.type == "windows") {
[18:05:37.053]                 old_names <- names(...future.oldEnvVars)
[18:05:37.053]                 envs <- base::Sys.getenv()
[18:05:37.053]                 names <- names(envs)
[18:05:37.053]                 common <- intersect(names, old_names)
[18:05:37.053]                 added <- setdiff(names, old_names)
[18:05:37.053]                 removed <- setdiff(old_names, names)
[18:05:37.053]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:37.053]                   envs[common]]
[18:05:37.053]                 NAMES <- toupper(changed)
[18:05:37.053]                 args <- list()
[18:05:37.053]                 for (kk in seq_along(NAMES)) {
[18:05:37.053]                   name <- changed[[kk]]
[18:05:37.053]                   NAME <- NAMES[[kk]]
[18:05:37.053]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.053]                     next
[18:05:37.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.053]                 }
[18:05:37.053]                 NAMES <- toupper(added)
[18:05:37.053]                 for (kk in seq_along(NAMES)) {
[18:05:37.053]                   name <- added[[kk]]
[18:05:37.053]                   NAME <- NAMES[[kk]]
[18:05:37.053]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.053]                     next
[18:05:37.053]                   args[[name]] <- ""
[18:05:37.053]                 }
[18:05:37.053]                 NAMES <- toupper(removed)
[18:05:37.053]                 for (kk in seq_along(NAMES)) {
[18:05:37.053]                   name <- removed[[kk]]
[18:05:37.053]                   NAME <- NAMES[[kk]]
[18:05:37.053]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.053]                     next
[18:05:37.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.053]                 }
[18:05:37.053]                 if (length(args) > 0) 
[18:05:37.053]                   base::do.call(base::Sys.setenv, args = args)
[18:05:37.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:37.053]             }
[18:05:37.053]             else {
[18:05:37.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:37.053]             }
[18:05:37.053]             {
[18:05:37.053]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:37.053]                   0L) {
[18:05:37.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:37.053]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:37.053]                   base::options(opts)
[18:05:37.053]                 }
[18:05:37.053]                 {
[18:05:37.053]                   {
[18:05:37.053]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:37.053]                     NULL
[18:05:37.053]                   }
[18:05:37.053]                   options(future.plan = NULL)
[18:05:37.053]                   if (is.na(NA_character_)) 
[18:05:37.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:37.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:37.053]                     .init = FALSE)
[18:05:37.053]                 }
[18:05:37.053]             }
[18:05:37.053]         }
[18:05:37.053]     })
[18:05:37.053]     if (TRUE) {
[18:05:37.053]         base::sink(type = "output", split = FALSE)
[18:05:37.053]         if (TRUE) {
[18:05:37.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:37.053]         }
[18:05:37.053]         else {
[18:05:37.053]             ...future.result["stdout"] <- base::list(NULL)
[18:05:37.053]         }
[18:05:37.053]         base::close(...future.stdout)
[18:05:37.053]         ...future.stdout <- NULL
[18:05:37.053]     }
[18:05:37.053]     ...future.result$conditions <- ...future.conditions
[18:05:37.053]     ...future.result$finished <- base::Sys.time()
[18:05:37.053]     ...future.result
[18:05:37.053] }
[18:05:37.058] assign_globals() ...
[18:05:37.058] List of 1
[18:05:37.058]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:37.058]   ..$ a: int [1:3] 1 2 3
[18:05:37.058]   ..$ b: int [1:3] 3 2 1
[18:05:37.058]  - attr(*, "where")=List of 1
[18:05:37.058]   ..$ data:<environment: R_EmptyEnv> 
[18:05:37.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:37.058]  - attr(*, "resolved")= logi FALSE
[18:05:37.058]  - attr(*, "total_size")= num 128
[18:05:37.058]  - attr(*, "already-done")= logi TRUE
[18:05:37.066] - copied ‘data’ to environment
[18:05:37.066] assign_globals() ... done
[18:05:37.066] requestCore(): workers = 2
[18:05:37.071] MulticoreFuture started
[18:05:37.071] - Launch lazy future ... done
[18:05:37.074] run() for ‘MulticoreFuture’ ... done
[18:05:37.075] result() for MulticoreFuture ...
[18:05:37.077] plan(): Setting new future strategy stack:
[18:05:37.077] List of future strategies:
[18:05:37.077] 1. multisession:
[18:05:37.077]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:37.077]    - tweaked: FALSE
[18:05:37.077]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.088] plan(): nbrOfWorkers() = 1
[18:05:37.162] plan(): Setting new future strategy stack:
[18:05:37.162] List of future strategies:
[18:05:37.162] 1. multicore:
[18:05:37.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:37.162]    - tweaked: FALSE
[18:05:37.162]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.162] 2. multisession:
[18:05:37.162]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:37.162]    - tweaked: FALSE
[18:05:37.162]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.170] plan(): nbrOfWorkers() = 2
[18:05:37.172] result() for MulticoreFuture ...
[18:05:37.173] result() for MulticoreFuture ... done
[18:05:37.173] signalConditions() ...
[18:05:37.173]  - include = ‘immediateCondition’
[18:05:37.173]  - exclude = 
[18:05:37.174]  - resignal = FALSE
[18:05:37.174]  - Number of conditions: 52
[18:05:37.174] signalConditions() ... done
[18:05:37.175] result() for MulticoreFuture ... done
[18:05:37.175] result() for MulticoreFuture ...
[18:05:37.175] result() for MulticoreFuture ... done
[18:05:37.175] signalConditions() ...
[18:05:37.175]  - include = ‘immediateCondition’
[18:05:37.176]  - exclude = 
[18:05:37.176]  - resignal = FALSE
[18:05:37.176]  - Number of conditions: 52
[18:05:37.176] signalConditions() ... done
[18:05:37.177] Future state: ‘finished’
[18:05:37.177] result() for MulticoreFuture ...
[18:05:37.177] result() for MulticoreFuture ... done
[18:05:37.177] signalConditions() ...
[18:05:37.178]  - include = ‘condition’
[18:05:37.178]  - exclude = ‘immediateCondition’
[18:05:37.178]  - resignal = TRUE
[18:05:37.178]  - Number of conditions: 52
[18:05:37.179]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.090] getGlobalsAndPackages() ...
[18:05:37.179]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.091] Searching for globals...
[18:05:37.179]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.094] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:37.180]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.095] Searching for globals ... DONE
[18:05:37.180]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.096] Resolving globals: FALSE
[18:05:37.180]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.098] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:37.180]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.099] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:37.181]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.099] - globals: [1] ‘data’
[18:05:37.181]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.100] 
[18:05:37.181]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.100] getGlobalsAndPackages() ... DONE
[18:05:37.182]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.102] run() for ‘Future’ ...
[18:05:37.182]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.102] - state: ‘created’
[18:05:37.182]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:37.183]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.120] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:05:37.183]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.120] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:05:37.188]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.121]   - Field: ‘label’
[18:05:37.189]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.121]   - Field: ‘local’
[18:05:37.189]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.121]   - Field: ‘owner’
[18:05:37.190]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.122]   - Field: ‘envir’
[18:05:37.190]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.122]   - Field: ‘packages’
[18:05:37.190]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.123]   - Field: ‘gc’
[18:05:37.191]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.124]   - Field: ‘conditions’
[18:05:37.191]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.124]   - Field: ‘expr’
[18:05:37.191]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.124]   - Field: ‘uuid’
[18:05:37.192]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.125]   - Field: ‘seed’
[18:05:37.192]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.125]   - Field: ‘version’
[18:05:37.192]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.125]   - Field: ‘result’
[18:05:37.193]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.126]   - Field: ‘asynchronous’
[18:05:37.193]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.126]   - Field: ‘calls’
[18:05:37.193]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.126]   - Field: ‘globals’
[18:05:37.194]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.127]   - Field: ‘stdout’
[18:05:37.194]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.127]   - Field: ‘earlySignal’
[18:05:37.194]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.127]   - Field: ‘lazy’
[18:05:37.195]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.128]   - Field: ‘state’
[18:05:37.195]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:05:37.195]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.128] - Launch lazy future ...
[18:05:37.195]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.129] Packages needed by the future expression (n = 0): <none>
[18:05:37.196]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.130] Packages needed by future strategies (n = 0): <none>
[18:05:37.196]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.131] {
[18:05:37.131]     {
[18:05:37.131]         {
[18:05:37.131]             ...future.startTime <- base::Sys.time()
[18:05:37.131]             {
[18:05:37.131]                 {
[18:05:37.131]                   {
[18:05:37.131]                     base::local({
[18:05:37.131]                       has_future <- base::requireNamespace("future", 
[18:05:37.131]                         quietly = TRUE)
[18:05:37.131]                       if (has_future) {
[18:05:37.131]                         ns <- base::getNamespace("future")
[18:05:37.131]                         version <- ns[[".package"]][["version"]]
[18:05:37.131]                         if (is.null(version)) 
[18:05:37.131]                           version <- utils::packageVersion("future")
[18:05:37.131]                       }
[18:05:37.131]                       else {
[18:05:37.131]                         version <- NULL
[18:05:37.131]                       }
[18:05:37.131]                       if (!has_future || version < "1.8.0") {
[18:05:37.131]                         info <- base::c(r_version = base::gsub("R version ", 
[18:05:37.131]                           "", base::R.version$version.string), 
[18:05:37.131]                           platform = base::sprintf("%s (%s-bit)", 
[18:05:37.131]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:05:37.131]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:37.131]                             "release", "version")], collapse = " "), 
[18:05:37.131]                           hostname = base::Sys.info()[["nodename"]])
[18:05:37.131]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:05:37.131]                           info)
[18:05:37.131]                         info <- base::paste(info, collapse = "; ")
[18:05:37.131]                         if (!has_future) {
[18:05:37.131]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:37.131]                             info)
[18:05:37.131]                         }
[18:05:37.131]                         else {
[18:05:37.131]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:37.131]                             info, version)
[18:05:37.131]                         }
[18:05:37.131]                         base::stop(msg)
[18:05:37.131]                       }
[18:05:37.131]                     })
[18:05:37.131]                   }
[18:05:37.131]                   ...future.strategy.old <- future::plan("list")
[18:05:37.131]                   options(future.plan = NULL)
[18:05:37.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:05:37.131]                 }
[18:05:37.131]                 ...future.workdir <- getwd()
[18:05:37.131]             }
[18:05:37.131]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:37.131]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:37.131]         }
[18:05:37.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:37.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:37.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:37.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:37.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:37.131]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:37.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:37.131]             base::names(...future.oldOptions))
[18:05:37.131]     }
[18:05:37.131]     if (FALSE) {
[18:05:37.131]     }
[18:05:37.131]     else {
[18:05:37.131]         if (TRUE) {
[18:05:37.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:37.131]                 open = "w")
[18:05:37.131]         }
[18:05:37.131]         else {
[18:05:37.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:37.131]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:37.131]         }
[18:05:37.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:37.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:37.131]             base::sink(type = "output", split = FALSE)
[18:05:37.131]             base::close(...future.stdout)
[18:05:37.131]         }, add = TRUE)
[18:05:37.131]     }
[18:05:37.131]     ...future.frame <- base::sys.nframe()
[18:05:37.131]     ...future.conditions <- base::list()
[18:05:37.131]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:37.131]     if (FALSE) {
[18:05:37.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:37.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:37.131]     }
[18:05:37.131]     ...future.result <- base::tryCatch({
[18:05:37.131]         base::withCallingHandlers({
[18:05:37.131]             ...future.value <- base::withVisible(base::local(subset(data, 
[18:05:37.131]                 a == 2)))
[18:05:37.131]             future::FutureResult(value = ...future.value$value, 
[18:05:37.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.131]                   ...future.rng), globalenv = if (FALSE) 
[18:05:37.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:37.131]                     ...future.globalenv.names))
[18:05:37.131]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:37.131]         }, condition = base::local({
[18:05:37.131]             c <- base::c
[18:05:37.131]             inherits <- base::inherits
[18:05:37.131]             invokeRestart <- base::invokeRestart
[18:05:37.131]             length <- base::length
[18:05:37.131]             list <- base::list
[18:05:37.131]             seq.int <- base::seq.int
[18:05:37.131]             signalCondition <- base::signalCondition
[18:05:37.131]             sys.calls <- base::sys.calls
[18:05:37.131]             `[[` <- base::`[[`
[18:05:37.131]             `+` <- base::`+`
[18:05:37.131]             `<<-` <- base::`<<-`
[18:05:37.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:37.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:37.131]                   3L)]
[18:05:37.131]             }
[18:05:37.131]             function(cond) {
[18:05:37.131]                 is_error <- inherits(cond, "error")
[18:05:37.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:37.131]                   NULL)
[18:05:37.131]                 if (is_error) {
[18:05:37.131]                   sessionInformation <- function() {
[18:05:37.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:37.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:37.131]                       search = base::search(), system = base::Sys.info())
[18:05:37.131]                   }
[18:05:37.131]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:37.131]                     cond$call), session = sessionInformation(), 
[18:05:37.131]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:37.131]                   signalCondition(cond)
[18:05:37.131]                 }
[18:05:37.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:37.131]                 "immediateCondition"))) {
[18:05:37.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:37.131]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:37.131]                   if (TRUE && !signal) {
[18:05:37.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.131]                     {
[18:05:37.131]                       inherits <- base::inherits
[18:05:37.131]                       invokeRestart <- base::invokeRestart
[18:05:37.131]                       is.null <- base::is.null
[18:05:37.131]                       muffled <- FALSE
[18:05:37.131]                       if (inherits(cond, "message")) {
[18:05:37.131]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.131]                         if (muffled) 
[18:05:37.131]                           invokeRestart("muffleMessage")
[18:05:37.131]                       }
[18:05:37.131]                       else if (inherits(cond, "warning")) {
[18:05:37.131]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.131]                         if (muffled) 
[18:05:37.131]                           invokeRestart("muffleWarning")
[18:05:37.131]                       }
[18:05:37.131]                       else if (inherits(cond, "condition")) {
[18:05:37.131]                         if (!is.null(pattern)) {
[18:05:37.131]                           computeRestarts <- base::computeRestarts
[18:05:37.131]                           grepl <- base::grepl
[18:05:37.131]                           restarts <- computeRestarts(cond)
[18:05:37.131]                           for (restart in restarts) {
[18:05:37.131]                             name <- restart$name
[18:05:37.131]                             if (is.null(name)) 
[18:05:37.131]                               next
[18:05:37.131]                             if (!grepl(pattern, name)) 
[18:05:37.131]                               next
[18:05:37.131]                             invokeRestart(restart)
[18:05:37.131]                             muffled <- TRUE
[18:05:37.131]                             break
[18:05:37.131]                           }
[18:05:37.131]                         }
[18:05:37.131]                       }
[18:05:37.131]                       invisible(muffled)
[18:05:37.131]                     }
[18:05:37.131]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.131]                   }
[18:05:37.131]                 }
[18:05:37.131]                 else {
[18:05:37.131]                   if (TRUE) {
[18:05:37.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.131]                     {
[18:05:37.131]                       inherits <- base::inherits
[18:05:37.131]                       invokeRestart <- base::invokeRestart
[18:05:37.131]                       is.null <- base::is.null
[18:05:37.131]                       muffled <- FALSE
[18:05:37.131]                       if (inherits(cond, "message")) {
[18:05:37.131]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.131]                         if (muffled) 
[18:05:37.131]                           invokeRestart("muffleMessage")
[18:05:37.131]                       }
[18:05:37.131]                       else if (inherits(cond, "warning")) {
[18:05:37.131]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.131]                         if (muffled) 
[18:05:37.131]                           invokeRestart("muffleWarning")
[18:05:37.131]                       }
[18:05:37.131]                       else if (inherits(cond, "condition")) {
[18:05:37.131]                         if (!is.null(pattern)) {
[18:05:37.131]                           computeRestarts <- base::computeRestarts
[18:05:37.131]                           grepl <- base::grepl
[18:05:37.131]                           restarts <- computeRestarts(cond)
[18:05:37.131]                           for (restart in restarts) {
[18:05:37.131]                             name <- restart$name
[18:05:37.131]                             if (is.null(name)) 
[18:05:37.131]                               next
[18:05:37.131]                             if (!grepl(pattern, name)) 
[18:05:37.131]                               next
[18:05:37.131]                             invokeRestart(restart)
[18:05:37.131]                             muffled <- TRUE
[18:05:37.131]                             break
[18:05:37.131]                           }
[18:05:37.131]                         }
[18:05:37.131]                       }
[18:05:37.131]                       invisible(muffled)
[18:05:37.131]                     }
[18:05:37.131]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.131]                   }
[18:05:37.131]                 }
[18:05:37.131]             }
[18:05:37.131]         }))
[18:05:37.131]     }, error = function(ex) {
[18:05:37.131]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:37.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.131]                 ...future.rng), started = ...future.startTime, 
[18:05:37.131]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:37.131]             version = "1.8"), class = "FutureResult")
[18:05:37.131]     }, finally = {
[18:05:37.131]         if (!identical(...future.workdir, getwd())) 
[18:05:37.131]             setwd(...future.workdir)
[18:05:37.131]         {
[18:05:37.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:37.131]                 ...future.oldOptions$nwarnings <- NULL
[18:05:37.131]             }
[18:05:37.131]             base::options(...future.oldOptions)
[18:05:37.131]             if (.Platform$OS.type == "windows") {
[18:05:37.131]                 old_names <- names(...future.oldEnvVars)
[18:05:37.131]                 envs <- base::Sys.getenv()
[18:05:37.131]                 names <- names(envs)
[18:05:37.131]                 common <- intersect(names, old_names)
[18:05:37.131]                 added <- setdiff(names, old_names)
[18:05:37.131]                 removed <- setdiff(old_names, names)
[18:05:37.131]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:37.131]                   envs[common]]
[18:05:37.131]                 NAMES <- toupper(changed)
[18:05:37.131]                 args <- list()
[18:05:37.131]                 for (kk in seq_along(NAMES)) {
[18:05:37.131]                   name <- changed[[kk]]
[18:05:37.131]                   NAME <- NAMES[[kk]]
[18:05:37.131]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.131]                     next
[18:05:37.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.131]                 }
[18:05:37.131]                 NAMES <- toupper(added)
[18:05:37.131]                 for (kk in seq_along(NAMES)) {
[18:05:37.131]                   name <- added[[kk]]
[18:05:37.131]                   NAME <- NAMES[[kk]]
[18:05:37.131]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.131]                     next
[18:05:37.131]                   args[[name]] <- ""
[18:05:37.131]                 }
[18:05:37.131]                 NAMES <- toupper(removed)
[18:05:37.131]                 for (kk in seq_along(NAMES)) {
[18:05:37.131]                   name <- removed[[kk]]
[18:05:37.131]                   NAME <- NAMES[[kk]]
[18:05:37.131]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.131]                     next
[18:05:37.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.131]                 }
[18:05:37.131]                 if (length(args) > 0) 
[18:05:37.131]                   base::do.call(base::Sys.setenv, args = args)
[18:05:37.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:37.131]             }
[18:05:37.131]             else {
[18:05:37.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:37.131]             }
[18:05:37.131]             {
[18:05:37.131]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:37.131]                   0L) {
[18:05:37.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:37.131]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:37.131]                   base::options(opts)
[18:05:37.131]                 }
[18:05:37.131]                 {
[18:05:37.131]                   {
[18:05:37.131]                     NULL
[18:05:37.131]                     RNGkind("Mersenne-Twister")
[18:05:37.131]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:05:37.131]                       inherits = FALSE)
[18:05:37.131]                   }
[18:05:37.131]                   options(future.plan = NULL)
[18:05:37.131]                   if (is.na(NA_character_)) 
[18:05:37.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:37.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:37.131]                     .init = FALSE)
[18:05:37.131]                 }
[18:05:37.131]             }
[18:05:37.131]         }
[18:05:37.131]     })
[18:05:37.131]     if (TRUE) {
[18:05:37.131]         base::sink(type = "output", split = FALSE)
[18:05:37.131]         if (TRUE) {
[18:05:37.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:37.131]         }
[18:05:37.131]         else {
[18:05:37.131]             ...future.result["stdout"] <- base::list(NULL)
[18:05:37.131]         }
[18:05:37.131]         base::close(...future.stdout)
[18:05:37.131]         ...future.stdout <- NULL
[18:05:37.131]     }
[18:05:37.131]     ...future.result$conditions <- ...future.conditions
[18:05:37.131]     ...future.result$finished <- base::Sys.time()
[18:05:37.131]     ...future.result
[18:05:37.131] }
[18:05:37.196]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.135] assign_globals() ...
[18:05:37.197]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.135] List of 1
[18:05:37.135]  $ data:'data.frame':	3 obs. of  2 variables:
[18:05:37.135]   ..$ a: int [1:3] 1 2 3
[18:05:37.135]   ..$ b: int [1:3] 3 2 1
[18:05:37.135]  - attr(*, "where")=List of 1
[18:05:37.135]   ..$ data:<environment: R_EmptyEnv> 
[18:05:37.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:05:37.135]  - attr(*, "resolved")= logi FALSE
[18:05:37.135]  - attr(*, "total_size")= num 128
[18:05:37.135]  - attr(*, "already-done")= logi TRUE
[18:05:37.197]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.146] - copied ‘data’ to environment
[18:05:37.197]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.147] assign_globals() ... done
[18:05:37.198]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.147] plan(): Setting new future strategy stack:
[18:05:37.198]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.148] List of future strategies:
[18:05:37.148] 1. sequential:
[18:05:37.148]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:37.148]    - tweaked: FALSE
[18:05:37.148]    - call: NULL
[18:05:37.198]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.149] plan(): nbrOfWorkers() = 1
[18:05:37.199]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.152] plan(): Setting new future strategy stack:
[18:05:37.199]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.152] List of future strategies:
[18:05:37.152] 1. multisession:
[18:05:37.152]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:37.152]    - tweaked: FALSE
[18:05:37.152]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.199]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.159] plan(): nbrOfWorkers() = 1
[18:05:37.200]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.160] SequentialFuture started (and completed)
[18:05:37.200]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.161] - Launch lazy future ... done
[18:05:37.200]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:05:37.161] run() for ‘SequentialFuture’ ... done
[18:05:37.201] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[18:05:37.201] plan(): Setting new future strategy stack:
[18:05:37.202] List of future strategies:
[18:05:37.202] 1. multisession:
[18:05:37.202]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:37.202]    - tweaked: FALSE
[18:05:37.202]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.202] 2. sequential:
[18:05:37.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:37.202]    - tweaked: FALSE
[18:05:37.202]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.203] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:05:37.203] multisession:
[18:05:37.203] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:37.203] - tweaked: FALSE
[18:05:37.203] - call: plan(list(a = strategy1, b = strategy2))
[18:05:37.210] getGlobalsAndPackages() ...
[18:05:37.210] Not searching for globals
[18:05:37.211] - globals: [0] <none>
[18:05:37.211] getGlobalsAndPackages() ... DONE
[18:05:37.212] [local output] makeClusterPSOCK() ...
[18:05:37.218] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:37.219] [local output] Base port: 11577
[18:05:37.219] [local output] Getting setup options for 2 cluster nodes ...
[18:05:37.219] [local output]  - Node 1 of 2 ...
[18:05:37.220] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:37.221] [local output] Rscript port: 11577

[18:05:37.222] [local output]  - Node 2 of 2 ...
[18:05:37.223] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:37.224] [local output] Rscript port: 11577

[18:05:37.225] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:37.225] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:37.225] [local output] Setting up PSOCK nodes in parallel
[18:05:37.226] List of 36
[18:05:37.226]  $ worker          : chr "localhost"
[18:05:37.226]   ..- attr(*, "localhost")= logi TRUE
[18:05:37.226]  $ master          : chr "localhost"
[18:05:37.226]  $ port            : int 11577
[18:05:37.226]  $ connectTimeout  : num 120
[18:05:37.226]  $ timeout         : num 2592000
[18:05:37.226]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:37.226]  $ homogeneous     : logi TRUE
[18:05:37.226]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:37.226]  $ rscript_envs    : NULL
[18:05:37.226]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:37.226]  $ rscript_startup : NULL
[18:05:37.226]  $ rscript_sh      : chr "sh"
[18:05:37.226]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:37.226]  $ methods         : logi TRUE
[18:05:37.226]  $ socketOptions   : chr "no-delay"
[18:05:37.226]  $ useXDR          : logi FALSE
[18:05:37.226]  $ outfile         : chr "/dev/null"
[18:05:37.226]  $ renice          : int NA
[18:05:37.226]  $ rshcmd          : NULL
[18:05:37.226]  $ user            : chr(0) 
[18:05:37.226]  $ revtunnel       : logi FALSE
[18:05:37.226]  $ rshlogfile      : NULL
[18:05:37.226]  $ rshopts         : chr(0) 
[18:05:37.226]  $ rank            : int 1
[18:05:37.226]  $ manual          : logi FALSE
[18:05:37.226]  $ dryrun          : logi FALSE
[18:05:37.226]  $ quiet           : logi FALSE
[18:05:37.226]  $ setup_strategy  : chr "parallel"
[18:05:37.226]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:37.226]  $ pidfile         : chr "/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e49b37a88.pid"
[18:05:37.226]  $ rshcmd_label    : NULL
[18:05:37.226]  $ rsh_call        : NULL
[18:05:37.226]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:37.226]  $ localMachine    : logi TRUE
[18:05:37.226]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:37.226]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:37.226]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:37.226]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:37.226]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:37.226]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:37.226]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:37.226]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:37.226]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:37.226]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:37.226]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:37.226]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:37.226]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:37.226]  $ arguments       :List of 28
[18:05:37.226]   ..$ worker          : chr "localhost"
[18:05:37.226]   ..$ master          : NULL
[18:05:37.226]   ..$ port            : int 11577
[18:05:37.226]   ..$ connectTimeout  : num 120
[18:05:37.226]   ..$ timeout         : num 2592000
[18:05:37.226]   ..$ rscript         : NULL
[18:05:37.226]   ..$ homogeneous     : NULL
[18:05:37.226]   ..$ rscript_args    : NULL
[18:05:37.226]   ..$ rscript_envs    : NULL
[18:05:37.226]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:37.226]   ..$ rscript_startup : NULL
[18:05:37.226]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:37.226]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:37.226]   ..$ methods         : logi TRUE
[18:05:37.226]   ..$ socketOptions   : chr "no-delay"
[18:05:37.226]   ..$ useXDR          : logi FALSE
[18:05:37.226]   ..$ outfile         : chr "/dev/null"
[18:05:37.226]   ..$ renice          : int NA
[18:05:37.226]   ..$ rshcmd          : NULL
[18:05:37.226]   ..$ user            : NULL
[18:05:37.226]   ..$ revtunnel       : logi NA
[18:05:37.226]   ..$ rshlogfile      : NULL
[18:05:37.226]   ..$ rshopts         : NULL
[18:05:37.226]   ..$ rank            : int 1
[18:05:37.226]   ..$ manual          : logi FALSE
[18:05:37.226]   ..$ dryrun          : logi FALSE
[18:05:37.226]   ..$ quiet           : logi FALSE
[18:05:37.226]   ..$ setup_strategy  : chr "parallel"
[18:05:37.226]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:37.265] [local output] System call to launch all workers:
[18:05:37.266] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e49b37a88.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11577 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:37.266] [local output] Starting PSOCK main server
[18:05:37.270] [local output] Workers launched
[18:05:37.270] [local output] Waiting for workers to connect back
[18:05:37.270]  - [local output] 0 workers out of 2 ready
[18:05:37.625]  - [local output] 0 workers out of 2 ready
[18:05:37.627]  - [local output] 1 workers out of 2 ready
[18:05:37.652]  - [local output] 1 workers out of 2 ready
[18:05:37.654]  - [local output] 2 workers out of 2 ready
[18:05:37.655] [local output] Launching of workers completed
[18:05:37.655] [local output] Collecting session information from workers
[18:05:37.656] [local output]  - Worker #1 of 2
[18:05:37.658] [local output]  - Worker #2 of 2
[18:05:37.658] [local output] makeClusterPSOCK() ... done
[18:05:37.680] Packages needed by the future expression (n = 0): <none>
[18:05:37.680] Packages needed by future strategies (n = 1): ‘future’
[18:05:37.683] {
[18:05:37.683]     {
[18:05:37.683]         {
[18:05:37.683]             ...future.startTime <- base::Sys.time()
[18:05:37.683]             {
[18:05:37.683]                 {
[18:05:37.683]                   {
[18:05:37.683]                     {
[18:05:37.683]                       {
[18:05:37.683]                         base::local({
[18:05:37.683]                           has_future <- base::requireNamespace("future", 
[18:05:37.683]                             quietly = TRUE)
[18:05:37.683]                           if (has_future) {
[18:05:37.683]                             ns <- base::getNamespace("future")
[18:05:37.683]                             version <- ns[[".package"]][["version"]]
[18:05:37.683]                             if (is.null(version)) 
[18:05:37.683]                               version <- utils::packageVersion("future")
[18:05:37.683]                           }
[18:05:37.683]                           else {
[18:05:37.683]                             version <- NULL
[18:05:37.683]                           }
[18:05:37.683]                           if (!has_future || version < "1.8.0") {
[18:05:37.683]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:37.683]                               "", base::R.version$version.string), 
[18:05:37.683]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:37.683]                                 base::R.version$platform, 8 * 
[18:05:37.683]                                   base::.Machine$sizeof.pointer), 
[18:05:37.683]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:37.683]                                 "release", "version")], collapse = " "), 
[18:05:37.683]                               hostname = base::Sys.info()[["nodename"]])
[18:05:37.683]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:37.683]                               info)
[18:05:37.683]                             info <- base::paste(info, collapse = "; ")
[18:05:37.683]                             if (!has_future) {
[18:05:37.683]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:37.683]                                 info)
[18:05:37.683]                             }
[18:05:37.683]                             else {
[18:05:37.683]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:37.683]                                 info, version)
[18:05:37.683]                             }
[18:05:37.683]                             base::stop(msg)
[18:05:37.683]                           }
[18:05:37.683]                         })
[18:05:37.683]                       }
[18:05:37.683]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:37.683]                       base::options(mc.cores = 1L)
[18:05:37.683]                     }
[18:05:37.683]                     base::local({
[18:05:37.683]                       for (pkg in "future") {
[18:05:37.683]                         base::loadNamespace(pkg)
[18:05:37.683]                         base::library(pkg, character.only = TRUE)
[18:05:37.683]                       }
[18:05:37.683]                     })
[18:05:37.683]                   }
[18:05:37.683]                   ...future.strategy.old <- future::plan("list")
[18:05:37.683]                   options(future.plan = NULL)
[18:05:37.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.683]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:37.683]                   {
[18:05:37.683]                     future <- SequentialFuture(..., envir = envir)
[18:05:37.683]                     if (!future$lazy) 
[18:05:37.683]                       future <- run(future)
[18:05:37.683]                     invisible(future)
[18:05:37.683]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:37.683]                 }
[18:05:37.683]                 ...future.workdir <- getwd()
[18:05:37.683]             }
[18:05:37.683]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:37.683]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:37.683]         }
[18:05:37.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:37.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:37.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:37.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:37.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:37.683]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:37.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:37.683]             base::names(...future.oldOptions))
[18:05:37.683]     }
[18:05:37.683]     if (FALSE) {
[18:05:37.683]     }
[18:05:37.683]     else {
[18:05:37.683]         if (TRUE) {
[18:05:37.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:37.683]                 open = "w")
[18:05:37.683]         }
[18:05:37.683]         else {
[18:05:37.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:37.683]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:37.683]         }
[18:05:37.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:37.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:37.683]             base::sink(type = "output", split = FALSE)
[18:05:37.683]             base::close(...future.stdout)
[18:05:37.683]         }, add = TRUE)
[18:05:37.683]     }
[18:05:37.683]     ...future.frame <- base::sys.nframe()
[18:05:37.683]     ...future.conditions <- base::list()
[18:05:37.683]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:37.683]     if (FALSE) {
[18:05:37.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:37.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:37.683]     }
[18:05:37.683]     ...future.result <- base::tryCatch({
[18:05:37.683]         base::withCallingHandlers({
[18:05:37.683]             ...future.value <- base::withVisible(base::local({
[18:05:37.683]                 ...future.makeSendCondition <- base::local({
[18:05:37.683]                   sendCondition <- NULL
[18:05:37.683]                   function(frame = 1L) {
[18:05:37.683]                     if (is.function(sendCondition)) 
[18:05:37.683]                       return(sendCondition)
[18:05:37.683]                     ns <- getNamespace("parallel")
[18:05:37.683]                     if (exists("sendData", mode = "function", 
[18:05:37.683]                       envir = ns)) {
[18:05:37.683]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:37.683]                         envir = ns)
[18:05:37.683]                       envir <- sys.frame(frame)
[18:05:37.683]                       master <- NULL
[18:05:37.683]                       while (!identical(envir, .GlobalEnv) && 
[18:05:37.683]                         !identical(envir, emptyenv())) {
[18:05:37.683]                         if (exists("master", mode = "list", envir = envir, 
[18:05:37.683]                           inherits = FALSE)) {
[18:05:37.683]                           master <- get("master", mode = "list", 
[18:05:37.683]                             envir = envir, inherits = FALSE)
[18:05:37.683]                           if (inherits(master, c("SOCKnode", 
[18:05:37.683]                             "SOCK0node"))) {
[18:05:37.683]                             sendCondition <<- function(cond) {
[18:05:37.683]                               data <- list(type = "VALUE", value = cond, 
[18:05:37.683]                                 success = TRUE)
[18:05:37.683]                               parallel_sendData(master, data)
[18:05:37.683]                             }
[18:05:37.683]                             return(sendCondition)
[18:05:37.683]                           }
[18:05:37.683]                         }
[18:05:37.683]                         frame <- frame + 1L
[18:05:37.683]                         envir <- sys.frame(frame)
[18:05:37.683]                       }
[18:05:37.683]                     }
[18:05:37.683]                     sendCondition <<- function(cond) NULL
[18:05:37.683]                   }
[18:05:37.683]                 })
[18:05:37.683]                 withCallingHandlers({
[18:05:37.683]                   NA
[18:05:37.683]                 }, immediateCondition = function(cond) {
[18:05:37.683]                   sendCondition <- ...future.makeSendCondition()
[18:05:37.683]                   sendCondition(cond)
[18:05:37.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.683]                   {
[18:05:37.683]                     inherits <- base::inherits
[18:05:37.683]                     invokeRestart <- base::invokeRestart
[18:05:37.683]                     is.null <- base::is.null
[18:05:37.683]                     muffled <- FALSE
[18:05:37.683]                     if (inherits(cond, "message")) {
[18:05:37.683]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:37.683]                       if (muffled) 
[18:05:37.683]                         invokeRestart("muffleMessage")
[18:05:37.683]                     }
[18:05:37.683]                     else if (inherits(cond, "warning")) {
[18:05:37.683]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:37.683]                       if (muffled) 
[18:05:37.683]                         invokeRestart("muffleWarning")
[18:05:37.683]                     }
[18:05:37.683]                     else if (inherits(cond, "condition")) {
[18:05:37.683]                       if (!is.null(pattern)) {
[18:05:37.683]                         computeRestarts <- base::computeRestarts
[18:05:37.683]                         grepl <- base::grepl
[18:05:37.683]                         restarts <- computeRestarts(cond)
[18:05:37.683]                         for (restart in restarts) {
[18:05:37.683]                           name <- restart$name
[18:05:37.683]                           if (is.null(name)) 
[18:05:37.683]                             next
[18:05:37.683]                           if (!grepl(pattern, name)) 
[18:05:37.683]                             next
[18:05:37.683]                           invokeRestart(restart)
[18:05:37.683]                           muffled <- TRUE
[18:05:37.683]                           break
[18:05:37.683]                         }
[18:05:37.683]                       }
[18:05:37.683]                     }
[18:05:37.683]                     invisible(muffled)
[18:05:37.683]                   }
[18:05:37.683]                   muffleCondition(cond)
[18:05:37.683]                 })
[18:05:37.683]             }))
[18:05:37.683]             future::FutureResult(value = ...future.value$value, 
[18:05:37.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.683]                   ...future.rng), globalenv = if (FALSE) 
[18:05:37.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:37.683]                     ...future.globalenv.names))
[18:05:37.683]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:37.683]         }, condition = base::local({
[18:05:37.683]             c <- base::c
[18:05:37.683]             inherits <- base::inherits
[18:05:37.683]             invokeRestart <- base::invokeRestart
[18:05:37.683]             length <- base::length
[18:05:37.683]             list <- base::list
[18:05:37.683]             seq.int <- base::seq.int
[18:05:37.683]             signalCondition <- base::signalCondition
[18:05:37.683]             sys.calls <- base::sys.calls
[18:05:37.683]             `[[` <- base::`[[`
[18:05:37.683]             `+` <- base::`+`
[18:05:37.683]             `<<-` <- base::`<<-`
[18:05:37.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:37.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:37.683]                   3L)]
[18:05:37.683]             }
[18:05:37.683]             function(cond) {
[18:05:37.683]                 is_error <- inherits(cond, "error")
[18:05:37.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:37.683]                   NULL)
[18:05:37.683]                 if (is_error) {
[18:05:37.683]                   sessionInformation <- function() {
[18:05:37.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:37.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:37.683]                       search = base::search(), system = base::Sys.info())
[18:05:37.683]                   }
[18:05:37.683]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:37.683]                     cond$call), session = sessionInformation(), 
[18:05:37.683]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:37.683]                   signalCondition(cond)
[18:05:37.683]                 }
[18:05:37.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:37.683]                 "immediateCondition"))) {
[18:05:37.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:37.683]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:37.683]                   if (TRUE && !signal) {
[18:05:37.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.683]                     {
[18:05:37.683]                       inherits <- base::inherits
[18:05:37.683]                       invokeRestart <- base::invokeRestart
[18:05:37.683]                       is.null <- base::is.null
[18:05:37.683]                       muffled <- FALSE
[18:05:37.683]                       if (inherits(cond, "message")) {
[18:05:37.683]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.683]                         if (muffled) 
[18:05:37.683]                           invokeRestart("muffleMessage")
[18:05:37.683]                       }
[18:05:37.683]                       else if (inherits(cond, "warning")) {
[18:05:37.683]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.683]                         if (muffled) 
[18:05:37.683]                           invokeRestart("muffleWarning")
[18:05:37.683]                       }
[18:05:37.683]                       else if (inherits(cond, "condition")) {
[18:05:37.683]                         if (!is.null(pattern)) {
[18:05:37.683]                           computeRestarts <- base::computeRestarts
[18:05:37.683]                           grepl <- base::grepl
[18:05:37.683]                           restarts <- computeRestarts(cond)
[18:05:37.683]                           for (restart in restarts) {
[18:05:37.683]                             name <- restart$name
[18:05:37.683]                             if (is.null(name)) 
[18:05:37.683]                               next
[18:05:37.683]                             if (!grepl(pattern, name)) 
[18:05:37.683]                               next
[18:05:37.683]                             invokeRestart(restart)
[18:05:37.683]                             muffled <- TRUE
[18:05:37.683]                             break
[18:05:37.683]                           }
[18:05:37.683]                         }
[18:05:37.683]                       }
[18:05:37.683]                       invisible(muffled)
[18:05:37.683]                     }
[18:05:37.683]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.683]                   }
[18:05:37.683]                 }
[18:05:37.683]                 else {
[18:05:37.683]                   if (TRUE) {
[18:05:37.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.683]                     {
[18:05:37.683]                       inherits <- base::inherits
[18:05:37.683]                       invokeRestart <- base::invokeRestart
[18:05:37.683]                       is.null <- base::is.null
[18:05:37.683]                       muffled <- FALSE
[18:05:37.683]                       if (inherits(cond, "message")) {
[18:05:37.683]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.683]                         if (muffled) 
[18:05:37.683]                           invokeRestart("muffleMessage")
[18:05:37.683]                       }
[18:05:37.683]                       else if (inherits(cond, "warning")) {
[18:05:37.683]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.683]                         if (muffled) 
[18:05:37.683]                           invokeRestart("muffleWarning")
[18:05:37.683]                       }
[18:05:37.683]                       else if (inherits(cond, "condition")) {
[18:05:37.683]                         if (!is.null(pattern)) {
[18:05:37.683]                           computeRestarts <- base::computeRestarts
[18:05:37.683]                           grepl <- base::grepl
[18:05:37.683]                           restarts <- computeRestarts(cond)
[18:05:37.683]                           for (restart in restarts) {
[18:05:37.683]                             name <- restart$name
[18:05:37.683]                             if (is.null(name)) 
[18:05:37.683]                               next
[18:05:37.683]                             if (!grepl(pattern, name)) 
[18:05:37.683]                               next
[18:05:37.683]                             invokeRestart(restart)
[18:05:37.683]                             muffled <- TRUE
[18:05:37.683]                             break
[18:05:37.683]                           }
[18:05:37.683]                         }
[18:05:37.683]                       }
[18:05:37.683]                       invisible(muffled)
[18:05:37.683]                     }
[18:05:37.683]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.683]                   }
[18:05:37.683]                 }
[18:05:37.683]             }
[18:05:37.683]         }))
[18:05:37.683]     }, error = function(ex) {
[18:05:37.683]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:37.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.683]                 ...future.rng), started = ...future.startTime, 
[18:05:37.683]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:37.683]             version = "1.8"), class = "FutureResult")
[18:05:37.683]     }, finally = {
[18:05:37.683]         if (!identical(...future.workdir, getwd())) 
[18:05:37.683]             setwd(...future.workdir)
[18:05:37.683]         {
[18:05:37.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:37.683]                 ...future.oldOptions$nwarnings <- NULL
[18:05:37.683]             }
[18:05:37.683]             base::options(...future.oldOptions)
[18:05:37.683]             if (.Platform$OS.type == "windows") {
[18:05:37.683]                 old_names <- names(...future.oldEnvVars)
[18:05:37.683]                 envs <- base::Sys.getenv()
[18:05:37.683]                 names <- names(envs)
[18:05:37.683]                 common <- intersect(names, old_names)
[18:05:37.683]                 added <- setdiff(names, old_names)
[18:05:37.683]                 removed <- setdiff(old_names, names)
[18:05:37.683]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:37.683]                   envs[common]]
[18:05:37.683]                 NAMES <- toupper(changed)
[18:05:37.683]                 args <- list()
[18:05:37.683]                 for (kk in seq_along(NAMES)) {
[18:05:37.683]                   name <- changed[[kk]]
[18:05:37.683]                   NAME <- NAMES[[kk]]
[18:05:37.683]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.683]                     next
[18:05:37.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.683]                 }
[18:05:37.683]                 NAMES <- toupper(added)
[18:05:37.683]                 for (kk in seq_along(NAMES)) {
[18:05:37.683]                   name <- added[[kk]]
[18:05:37.683]                   NAME <- NAMES[[kk]]
[18:05:37.683]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.683]                     next
[18:05:37.683]                   args[[name]] <- ""
[18:05:37.683]                 }
[18:05:37.683]                 NAMES <- toupper(removed)
[18:05:37.683]                 for (kk in seq_along(NAMES)) {
[18:05:37.683]                   name <- removed[[kk]]
[18:05:37.683]                   NAME <- NAMES[[kk]]
[18:05:37.683]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.683]                     next
[18:05:37.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.683]                 }
[18:05:37.683]                 if (length(args) > 0) 
[18:05:37.683]                   base::do.call(base::Sys.setenv, args = args)
[18:05:37.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:37.683]             }
[18:05:37.683]             else {
[18:05:37.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:37.683]             }
[18:05:37.683]             {
[18:05:37.683]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:37.683]                   0L) {
[18:05:37.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:37.683]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:37.683]                   base::options(opts)
[18:05:37.683]                 }
[18:05:37.683]                 {
[18:05:37.683]                   {
[18:05:37.683]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:37.683]                     NULL
[18:05:37.683]                   }
[18:05:37.683]                   options(future.plan = NULL)
[18:05:37.683]                   if (is.na(NA_character_)) 
[18:05:37.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:37.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:37.683]                     .init = FALSE)
[18:05:37.683]                 }
[18:05:37.683]             }
[18:05:37.683]         }
[18:05:37.683]     })
[18:05:37.683]     if (TRUE) {
[18:05:37.683]         base::sink(type = "output", split = FALSE)
[18:05:37.683]         if (TRUE) {
[18:05:37.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:37.683]         }
[18:05:37.683]         else {
[18:05:37.683]             ...future.result["stdout"] <- base::list(NULL)
[18:05:37.683]         }
[18:05:37.683]         base::close(...future.stdout)
[18:05:37.683]         ...future.stdout <- NULL
[18:05:37.683]     }
[18:05:37.683]     ...future.result$conditions <- ...future.conditions
[18:05:37.683]     ...future.result$finished <- base::Sys.time()
[18:05:37.683]     ...future.result
[18:05:37.683] }
[18:05:37.814] MultisessionFuture started
[18:05:37.814] result() for ClusterFuture ...
[18:05:37.815] receiveMessageFromWorker() for ClusterFuture ...
[18:05:37.815] - Validating connection of MultisessionFuture
[18:05:37.884] - received message: FutureResult
[18:05:37.885] - Received FutureResult
[18:05:37.885] - Erased future from FutureRegistry
[18:05:37.886] result() for ClusterFuture ...
[18:05:37.886] - result already collected: FutureResult
[18:05:37.886] result() for ClusterFuture ... done
[18:05:37.886] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:37.887] result() for ClusterFuture ... done
[18:05:37.887] result() for ClusterFuture ...
[18:05:37.888] - result already collected: FutureResult
[18:05:37.888] result() for ClusterFuture ... done
[18:05:37.888] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:05:37.895] plan(): nbrOfWorkers() = 2
[18:05:37.896] getGlobalsAndPackages() ...
[18:05:37.896] Searching for globals...
[18:05:37.937] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:37.937] Searching for globals ... DONE
[18:05:37.937] Resolving globals: FALSE
[18:05:37.940] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[18:05:37.941] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:37.941] - globals: [2] ‘nested’, ‘strategy2’
[18:05:37.941] - packages: [1] ‘future’
[18:05:37.942] getGlobalsAndPackages() ... DONE
[18:05:37.942] run() for ‘Future’ ...
[18:05:37.943] - state: ‘created’
[18:05:37.943] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:37.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:37.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:37.970]   - Field: ‘node’
[18:05:37.970]   - Field: ‘label’
[18:05:37.970]   - Field: ‘local’
[18:05:37.970]   - Field: ‘owner’
[18:05:37.970]   - Field: ‘envir’
[18:05:37.971]   - Field: ‘workers’
[18:05:37.971]   - Field: ‘packages’
[18:05:37.971]   - Field: ‘gc’
[18:05:37.971]   - Field: ‘conditions’
[18:05:37.971]   - Field: ‘persistent’
[18:05:37.972]   - Field: ‘expr’
[18:05:37.972]   - Field: ‘uuid’
[18:05:37.972]   - Field: ‘seed’
[18:05:37.972]   - Field: ‘version’
[18:05:37.972]   - Field: ‘result’
[18:05:37.972]   - Field: ‘asynchronous’
[18:05:37.973]   - Field: ‘calls’
[18:05:37.973]   - Field: ‘globals’
[18:05:37.973]   - Field: ‘stdout’
[18:05:37.973]   - Field: ‘earlySignal’
[18:05:37.973]   - Field: ‘lazy’
[18:05:37.974]   - Field: ‘state’
[18:05:37.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:37.974] - Launch lazy future ...
[18:05:37.975] Packages needed by the future expression (n = 1): ‘future’
[18:05:37.975] Packages needed by future strategies (n = 1): ‘future’
[18:05:37.976] {
[18:05:37.976]     {
[18:05:37.976]         {
[18:05:37.976]             ...future.startTime <- base::Sys.time()
[18:05:37.976]             {
[18:05:37.976]                 {
[18:05:37.976]                   {
[18:05:37.976]                     {
[18:05:37.976]                       {
[18:05:37.976]                         base::local({
[18:05:37.976]                           has_future <- base::requireNamespace("future", 
[18:05:37.976]                             quietly = TRUE)
[18:05:37.976]                           if (has_future) {
[18:05:37.976]                             ns <- base::getNamespace("future")
[18:05:37.976]                             version <- ns[[".package"]][["version"]]
[18:05:37.976]                             if (is.null(version)) 
[18:05:37.976]                               version <- utils::packageVersion("future")
[18:05:37.976]                           }
[18:05:37.976]                           else {
[18:05:37.976]                             version <- NULL
[18:05:37.976]                           }
[18:05:37.976]                           if (!has_future || version < "1.8.0") {
[18:05:37.976]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:37.976]                               "", base::R.version$version.string), 
[18:05:37.976]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:37.976]                                 base::R.version$platform, 8 * 
[18:05:37.976]                                   base::.Machine$sizeof.pointer), 
[18:05:37.976]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:37.976]                                 "release", "version")], collapse = " "), 
[18:05:37.976]                               hostname = base::Sys.info()[["nodename"]])
[18:05:37.976]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:37.976]                               info)
[18:05:37.976]                             info <- base::paste(info, collapse = "; ")
[18:05:37.976]                             if (!has_future) {
[18:05:37.976]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:37.976]                                 info)
[18:05:37.976]                             }
[18:05:37.976]                             else {
[18:05:37.976]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:37.976]                                 info, version)
[18:05:37.976]                             }
[18:05:37.976]                             base::stop(msg)
[18:05:37.976]                           }
[18:05:37.976]                         })
[18:05:37.976]                       }
[18:05:37.976]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:37.976]                       base::options(mc.cores = 1L)
[18:05:37.976]                     }
[18:05:37.976]                     base::local({
[18:05:37.976]                       for (pkg in "future") {
[18:05:37.976]                         base::loadNamespace(pkg)
[18:05:37.976]                         base::library(pkg, character.only = TRUE)
[18:05:37.976]                       }
[18:05:37.976]                     })
[18:05:37.976]                   }
[18:05:37.976]                   ...future.strategy.old <- future::plan("list")
[18:05:37.976]                   options(future.plan = NULL)
[18:05:37.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.976]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:37.976]                   {
[18:05:37.976]                     future <- SequentialFuture(..., envir = envir)
[18:05:37.976]                     if (!future$lazy) 
[18:05:37.976]                       future <- run(future)
[18:05:37.976]                     invisible(future)
[18:05:37.976]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:37.976]                 }
[18:05:37.976]                 ...future.workdir <- getwd()
[18:05:37.976]             }
[18:05:37.976]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:37.976]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:37.976]         }
[18:05:37.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:37.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:37.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:37.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:37.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:37.976]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:37.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:37.976]             base::names(...future.oldOptions))
[18:05:37.976]     }
[18:05:37.976]     if (FALSE) {
[18:05:37.976]     }
[18:05:37.976]     else {
[18:05:37.976]         if (TRUE) {
[18:05:37.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:37.976]                 open = "w")
[18:05:37.976]         }
[18:05:37.976]         else {
[18:05:37.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:37.976]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:37.976]         }
[18:05:37.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:37.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:37.976]             base::sink(type = "output", split = FALSE)
[18:05:37.976]             base::close(...future.stdout)
[18:05:37.976]         }, add = TRUE)
[18:05:37.976]     }
[18:05:37.976]     ...future.frame <- base::sys.nframe()
[18:05:37.976]     ...future.conditions <- base::list()
[18:05:37.976]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:37.976]     if (FALSE) {
[18:05:37.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:37.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:37.976]     }
[18:05:37.976]     ...future.result <- base::tryCatch({
[18:05:37.976]         base::withCallingHandlers({
[18:05:37.976]             ...future.value <- base::withVisible(base::local({
[18:05:37.976]                 ...future.makeSendCondition <- base::local({
[18:05:37.976]                   sendCondition <- NULL
[18:05:37.976]                   function(frame = 1L) {
[18:05:37.976]                     if (is.function(sendCondition)) 
[18:05:37.976]                       return(sendCondition)
[18:05:37.976]                     ns <- getNamespace("parallel")
[18:05:37.976]                     if (exists("sendData", mode = "function", 
[18:05:37.976]                       envir = ns)) {
[18:05:37.976]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:37.976]                         envir = ns)
[18:05:37.976]                       envir <- sys.frame(frame)
[18:05:37.976]                       master <- NULL
[18:05:37.976]                       while (!identical(envir, .GlobalEnv) && 
[18:05:37.976]                         !identical(envir, emptyenv())) {
[18:05:37.976]                         if (exists("master", mode = "list", envir = envir, 
[18:05:37.976]                           inherits = FALSE)) {
[18:05:37.976]                           master <- get("master", mode = "list", 
[18:05:37.976]                             envir = envir, inherits = FALSE)
[18:05:37.976]                           if (inherits(master, c("SOCKnode", 
[18:05:37.976]                             "SOCK0node"))) {
[18:05:37.976]                             sendCondition <<- function(cond) {
[18:05:37.976]                               data <- list(type = "VALUE", value = cond, 
[18:05:37.976]                                 success = TRUE)
[18:05:37.976]                               parallel_sendData(master, data)
[18:05:37.976]                             }
[18:05:37.976]                             return(sendCondition)
[18:05:37.976]                           }
[18:05:37.976]                         }
[18:05:37.976]                         frame <- frame + 1L
[18:05:37.976]                         envir <- sys.frame(frame)
[18:05:37.976]                       }
[18:05:37.976]                     }
[18:05:37.976]                     sendCondition <<- function(cond) NULL
[18:05:37.976]                   }
[18:05:37.976]                 })
[18:05:37.976]                 withCallingHandlers({
[18:05:37.976]                   {
[18:05:37.976]                     a <- 1L
[18:05:37.976]                     plan_a <- unclass(future::plan("list"))
[18:05:37.976]                     nested_a <- nested[-1]
[18:05:37.976]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:37.976]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:37.976]                       strategy2))
[18:05:37.976]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:37.976]                       "init") <- NULL
[18:05:37.976]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:37.976]                       "init") <- NULL
[18:05:37.976]                     stopifnot(all.equal(plan_a, nested_a))
[18:05:37.976]                     y %<-% {
[18:05:37.976]                       b <- 2L
[18:05:37.976]                       plan_b <- future::plan("list")
[18:05:37.976]                       nested_b <- nested_a[-1]
[18:05:37.976]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:37.976]                         1L, inherits(plan_b[[1]], "future"), 
[18:05:37.976]                         inherits(future::plan("next"), "sequential"))
[18:05:37.976]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:37.976]                         b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:37.976]                     }
[18:05:37.976]                     y
[18:05:37.976]                   }
[18:05:37.976]                 }, immediateCondition = function(cond) {
[18:05:37.976]                   sendCondition <- ...future.makeSendCondition()
[18:05:37.976]                   sendCondition(cond)
[18:05:37.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.976]                   {
[18:05:37.976]                     inherits <- base::inherits
[18:05:37.976]                     invokeRestart <- base::invokeRestart
[18:05:37.976]                     is.null <- base::is.null
[18:05:37.976]                     muffled <- FALSE
[18:05:37.976]                     if (inherits(cond, "message")) {
[18:05:37.976]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:37.976]                       if (muffled) 
[18:05:37.976]                         invokeRestart("muffleMessage")
[18:05:37.976]                     }
[18:05:37.976]                     else if (inherits(cond, "warning")) {
[18:05:37.976]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:37.976]                       if (muffled) 
[18:05:37.976]                         invokeRestart("muffleWarning")
[18:05:37.976]                     }
[18:05:37.976]                     else if (inherits(cond, "condition")) {
[18:05:37.976]                       if (!is.null(pattern)) {
[18:05:37.976]                         computeRestarts <- base::computeRestarts
[18:05:37.976]                         grepl <- base::grepl
[18:05:37.976]                         restarts <- computeRestarts(cond)
[18:05:37.976]                         for (restart in restarts) {
[18:05:37.976]                           name <- restart$name
[18:05:37.976]                           if (is.null(name)) 
[18:05:37.976]                             next
[18:05:37.976]                           if (!grepl(pattern, name)) 
[18:05:37.976]                             next
[18:05:37.976]                           invokeRestart(restart)
[18:05:37.976]                           muffled <- TRUE
[18:05:37.976]                           break
[18:05:37.976]                         }
[18:05:37.976]                       }
[18:05:37.976]                     }
[18:05:37.976]                     invisible(muffled)
[18:05:37.976]                   }
[18:05:37.976]                   muffleCondition(cond)
[18:05:37.976]                 })
[18:05:37.976]             }))
[18:05:37.976]             future::FutureResult(value = ...future.value$value, 
[18:05:37.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.976]                   ...future.rng), globalenv = if (FALSE) 
[18:05:37.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:37.976]                     ...future.globalenv.names))
[18:05:37.976]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:37.976]         }, condition = base::local({
[18:05:37.976]             c <- base::c
[18:05:37.976]             inherits <- base::inherits
[18:05:37.976]             invokeRestart <- base::invokeRestart
[18:05:37.976]             length <- base::length
[18:05:37.976]             list <- base::list
[18:05:37.976]             seq.int <- base::seq.int
[18:05:37.976]             signalCondition <- base::signalCondition
[18:05:37.976]             sys.calls <- base::sys.calls
[18:05:37.976]             `[[` <- base::`[[`
[18:05:37.976]             `+` <- base::`+`
[18:05:37.976]             `<<-` <- base::`<<-`
[18:05:37.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:37.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:37.976]                   3L)]
[18:05:37.976]             }
[18:05:37.976]             function(cond) {
[18:05:37.976]                 is_error <- inherits(cond, "error")
[18:05:37.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:37.976]                   NULL)
[18:05:37.976]                 if (is_error) {
[18:05:37.976]                   sessionInformation <- function() {
[18:05:37.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:37.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:37.976]                       search = base::search(), system = base::Sys.info())
[18:05:37.976]                   }
[18:05:37.976]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:37.976]                     cond$call), session = sessionInformation(), 
[18:05:37.976]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:37.976]                   signalCondition(cond)
[18:05:37.976]                 }
[18:05:37.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:37.976]                 "immediateCondition"))) {
[18:05:37.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:37.976]                   ...future.conditions[[length(...future.conditions) + 
[18:05:37.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:37.976]                   if (TRUE && !signal) {
[18:05:37.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.976]                     {
[18:05:37.976]                       inherits <- base::inherits
[18:05:37.976]                       invokeRestart <- base::invokeRestart
[18:05:37.976]                       is.null <- base::is.null
[18:05:37.976]                       muffled <- FALSE
[18:05:37.976]                       if (inherits(cond, "message")) {
[18:05:37.976]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.976]                         if (muffled) 
[18:05:37.976]                           invokeRestart("muffleMessage")
[18:05:37.976]                       }
[18:05:37.976]                       else if (inherits(cond, "warning")) {
[18:05:37.976]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.976]                         if (muffled) 
[18:05:37.976]                           invokeRestart("muffleWarning")
[18:05:37.976]                       }
[18:05:37.976]                       else if (inherits(cond, "condition")) {
[18:05:37.976]                         if (!is.null(pattern)) {
[18:05:37.976]                           computeRestarts <- base::computeRestarts
[18:05:37.976]                           grepl <- base::grepl
[18:05:37.976]                           restarts <- computeRestarts(cond)
[18:05:37.976]                           for (restart in restarts) {
[18:05:37.976]                             name <- restart$name
[18:05:37.976]                             if (is.null(name)) 
[18:05:37.976]                               next
[18:05:37.976]                             if (!grepl(pattern, name)) 
[18:05:37.976]                               next
[18:05:37.976]                             invokeRestart(restart)
[18:05:37.976]                             muffled <- TRUE
[18:05:37.976]                             break
[18:05:37.976]                           }
[18:05:37.976]                         }
[18:05:37.976]                       }
[18:05:37.976]                       invisible(muffled)
[18:05:37.976]                     }
[18:05:37.976]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.976]                   }
[18:05:37.976]                 }
[18:05:37.976]                 else {
[18:05:37.976]                   if (TRUE) {
[18:05:37.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:37.976]                     {
[18:05:37.976]                       inherits <- base::inherits
[18:05:37.976]                       invokeRestart <- base::invokeRestart
[18:05:37.976]                       is.null <- base::is.null
[18:05:37.976]                       muffled <- FALSE
[18:05:37.976]                       if (inherits(cond, "message")) {
[18:05:37.976]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:37.976]                         if (muffled) 
[18:05:37.976]                           invokeRestart("muffleMessage")
[18:05:37.976]                       }
[18:05:37.976]                       else if (inherits(cond, "warning")) {
[18:05:37.976]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:37.976]                         if (muffled) 
[18:05:37.976]                           invokeRestart("muffleWarning")
[18:05:37.976]                       }
[18:05:37.976]                       else if (inherits(cond, "condition")) {
[18:05:37.976]                         if (!is.null(pattern)) {
[18:05:37.976]                           computeRestarts <- base::computeRestarts
[18:05:37.976]                           grepl <- base::grepl
[18:05:37.976]                           restarts <- computeRestarts(cond)
[18:05:37.976]                           for (restart in restarts) {
[18:05:37.976]                             name <- restart$name
[18:05:37.976]                             if (is.null(name)) 
[18:05:37.976]                               next
[18:05:37.976]                             if (!grepl(pattern, name)) 
[18:05:37.976]                               next
[18:05:37.976]                             invokeRestart(restart)
[18:05:37.976]                             muffled <- TRUE
[18:05:37.976]                             break
[18:05:37.976]                           }
[18:05:37.976]                         }
[18:05:37.976]                       }
[18:05:37.976]                       invisible(muffled)
[18:05:37.976]                     }
[18:05:37.976]                     muffleCondition(cond, pattern = "^muffle")
[18:05:37.976]                   }
[18:05:37.976]                 }
[18:05:37.976]             }
[18:05:37.976]         }))
[18:05:37.976]     }, error = function(ex) {
[18:05:37.976]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:37.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:37.976]                 ...future.rng), started = ...future.startTime, 
[18:05:37.976]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:37.976]             version = "1.8"), class = "FutureResult")
[18:05:37.976]     }, finally = {
[18:05:37.976]         if (!identical(...future.workdir, getwd())) 
[18:05:37.976]             setwd(...future.workdir)
[18:05:37.976]         {
[18:05:37.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:37.976]                 ...future.oldOptions$nwarnings <- NULL
[18:05:37.976]             }
[18:05:37.976]             base::options(...future.oldOptions)
[18:05:37.976]             if (.Platform$OS.type == "windows") {
[18:05:37.976]                 old_names <- names(...future.oldEnvVars)
[18:05:37.976]                 envs <- base::Sys.getenv()
[18:05:37.976]                 names <- names(envs)
[18:05:37.976]                 common <- intersect(names, old_names)
[18:05:37.976]                 added <- setdiff(names, old_names)
[18:05:37.976]                 removed <- setdiff(old_names, names)
[18:05:37.976]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:37.976]                   envs[common]]
[18:05:37.976]                 NAMES <- toupper(changed)
[18:05:37.976]                 args <- list()
[18:05:37.976]                 for (kk in seq_along(NAMES)) {
[18:05:37.976]                   name <- changed[[kk]]
[18:05:37.976]                   NAME <- NAMES[[kk]]
[18:05:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.976]                     next
[18:05:37.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.976]                 }
[18:05:37.976]                 NAMES <- toupper(added)
[18:05:37.976]                 for (kk in seq_along(NAMES)) {
[18:05:37.976]                   name <- added[[kk]]
[18:05:37.976]                   NAME <- NAMES[[kk]]
[18:05:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.976]                     next
[18:05:37.976]                   args[[name]] <- ""
[18:05:37.976]                 }
[18:05:37.976]                 NAMES <- toupper(removed)
[18:05:37.976]                 for (kk in seq_along(NAMES)) {
[18:05:37.976]                   name <- removed[[kk]]
[18:05:37.976]                   NAME <- NAMES[[kk]]
[18:05:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:37.976]                     next
[18:05:37.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:37.976]                 }
[18:05:37.976]                 if (length(args) > 0) 
[18:05:37.976]                   base::do.call(base::Sys.setenv, args = args)
[18:05:37.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:37.976]             }
[18:05:37.976]             else {
[18:05:37.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:37.976]             }
[18:05:37.976]             {
[18:05:37.976]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:37.976]                   0L) {
[18:05:37.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:37.976]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:37.976]                   base::options(opts)
[18:05:37.976]                 }
[18:05:37.976]                 {
[18:05:37.976]                   {
[18:05:37.976]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:37.976]                     NULL
[18:05:37.976]                   }
[18:05:37.976]                   options(future.plan = NULL)
[18:05:37.976]                   if (is.na(NA_character_)) 
[18:05:37.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:37.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:37.976]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:37.976]                     .init = FALSE)
[18:05:37.976]                 }
[18:05:37.976]             }
[18:05:37.976]         }
[18:05:37.976]     })
[18:05:37.976]     if (TRUE) {
[18:05:37.976]         base::sink(type = "output", split = FALSE)
[18:05:37.976]         if (TRUE) {
[18:05:37.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:37.976]         }
[18:05:37.976]         else {
[18:05:37.976]             ...future.result["stdout"] <- base::list(NULL)
[18:05:37.976]         }
[18:05:37.976]         base::close(...future.stdout)
[18:05:37.976]         ...future.stdout <- NULL
[18:05:37.976]     }
[18:05:37.976]     ...future.result$conditions <- ...future.conditions
[18:05:37.976]     ...future.result$finished <- base::Sys.time()
[18:05:37.976]     ...future.result
[18:05:37.976] }
[18:05:37.981] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[18:05:37.982] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[18:05:38.023] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[18:05:38.024] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[18:05:38.025] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[18:05:38.025] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[18:05:38.027] MultisessionFuture started
[18:05:38.027] - Launch lazy future ... done
[18:05:38.027] run() for ‘MultisessionFuture’ ... done
[18:05:38.027] result() for ClusterFuture ...
[18:05:38.028] receiveMessageFromWorker() for ClusterFuture ...
[18:05:38.028] - Validating connection of MultisessionFuture
[18:05:38.131] - received message: FutureResult
[18:05:38.131] - Received FutureResult
[18:05:38.132] - Erased future from FutureRegistry
[18:05:38.132] result() for ClusterFuture ...
[18:05:38.132] - result already collected: FutureResult
[18:05:38.132] result() for ClusterFuture ... done
[18:05:38.133] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:38.133] result() for ClusterFuture ... done
[18:05:38.133] result() for ClusterFuture ...
[18:05:38.133] - result already collected: FutureResult
[18:05:38.134] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:38.146] getGlobalsAndPackages() ...
[18:05:38.146] Searching for globals...
[18:05:38.151] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:38.151] Searching for globals ... DONE
[18:05:38.151] Resolving globals: FALSE
[18:05:38.153] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:38.153] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:38.154] - globals: [1] ‘data’
[18:05:38.154] - packages: [1] ‘future’
[18:05:38.154] getGlobalsAndPackages() ... DONE
[18:05:38.155] run() for ‘Future’ ...
[18:05:38.156] - state: ‘created’
[18:05:38.156] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:38.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:38.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:38.190]   - Field: ‘node’
[18:05:38.190]   - Field: ‘label’
[18:05:38.190]   - Field: ‘local’
[18:05:38.191]   - Field: ‘owner’
[18:05:38.191]   - Field: ‘envir’
[18:05:38.191]   - Field: ‘workers’
[18:05:38.191]   - Field: ‘packages’
[18:05:38.192]   - Field: ‘gc’
[18:05:38.192]   - Field: ‘conditions’
[18:05:38.192]   - Field: ‘persistent’
[18:05:38.192]   - Field: ‘expr’
[18:05:38.192]   - Field: ‘uuid’
[18:05:38.192]   - Field: ‘seed’
[18:05:38.193]   - Field: ‘version’
[18:05:38.193]   - Field: ‘result’
[18:05:38.193]   - Field: ‘asynchronous’
[18:05:38.193]   - Field: ‘calls’
[18:05:38.193]   - Field: ‘globals’
[18:05:38.194]   - Field: ‘stdout’
[18:05:38.194]   - Field: ‘earlySignal’
[18:05:38.194]   - Field: ‘lazy’
[18:05:38.194]   - Field: ‘state’
[18:05:38.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:38.195] - Launch lazy future ...
[18:05:38.195] Packages needed by the future expression (n = 1): ‘future’
[18:05:38.195] Packages needed by future strategies (n = 1): ‘future’
[18:05:38.196] {
[18:05:38.196]     {
[18:05:38.196]         {
[18:05:38.196]             ...future.startTime <- base::Sys.time()
[18:05:38.196]             {
[18:05:38.196]                 {
[18:05:38.196]                   {
[18:05:38.196]                     {
[18:05:38.196]                       {
[18:05:38.196]                         base::local({
[18:05:38.196]                           has_future <- base::requireNamespace("future", 
[18:05:38.196]                             quietly = TRUE)
[18:05:38.196]                           if (has_future) {
[18:05:38.196]                             ns <- base::getNamespace("future")
[18:05:38.196]                             version <- ns[[".package"]][["version"]]
[18:05:38.196]                             if (is.null(version)) 
[18:05:38.196]                               version <- utils::packageVersion("future")
[18:05:38.196]                           }
[18:05:38.196]                           else {
[18:05:38.196]                             version <- NULL
[18:05:38.196]                           }
[18:05:38.196]                           if (!has_future || version < "1.8.0") {
[18:05:38.196]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:38.196]                               "", base::R.version$version.string), 
[18:05:38.196]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:38.196]                                 base::R.version$platform, 8 * 
[18:05:38.196]                                   base::.Machine$sizeof.pointer), 
[18:05:38.196]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:38.196]                                 "release", "version")], collapse = " "), 
[18:05:38.196]                               hostname = base::Sys.info()[["nodename"]])
[18:05:38.196]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:38.196]                               info)
[18:05:38.196]                             info <- base::paste(info, collapse = "; ")
[18:05:38.196]                             if (!has_future) {
[18:05:38.196]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:38.196]                                 info)
[18:05:38.196]                             }
[18:05:38.196]                             else {
[18:05:38.196]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:38.196]                                 info, version)
[18:05:38.196]                             }
[18:05:38.196]                             base::stop(msg)
[18:05:38.196]                           }
[18:05:38.196]                         })
[18:05:38.196]                       }
[18:05:38.196]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:38.196]                       base::options(mc.cores = 1L)
[18:05:38.196]                     }
[18:05:38.196]                     base::local({
[18:05:38.196]                       for (pkg in "future") {
[18:05:38.196]                         base::loadNamespace(pkg)
[18:05:38.196]                         base::library(pkg, character.only = TRUE)
[18:05:38.196]                       }
[18:05:38.196]                     })
[18:05:38.196]                   }
[18:05:38.196]                   ...future.strategy.old <- future::plan("list")
[18:05:38.196]                   options(future.plan = NULL)
[18:05:38.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:38.196]                   future::plan(list(b = function (..., envir = parent.frame()) 
[18:05:38.196]                   {
[18:05:38.196]                     future <- SequentialFuture(..., envir = envir)
[18:05:38.196]                     if (!future$lazy) 
[18:05:38.196]                       future <- run(future)
[18:05:38.196]                     invisible(future)
[18:05:38.196]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:38.196]                 }
[18:05:38.196]                 ...future.workdir <- getwd()
[18:05:38.196]             }
[18:05:38.196]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:38.196]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:38.196]         }
[18:05:38.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:38.196]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:38.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:38.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:38.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:38.196]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:38.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:38.196]             base::names(...future.oldOptions))
[18:05:38.196]     }
[18:05:38.196]     if (FALSE) {
[18:05:38.196]     }
[18:05:38.196]     else {
[18:05:38.196]         if (TRUE) {
[18:05:38.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:38.196]                 open = "w")
[18:05:38.196]         }
[18:05:38.196]         else {
[18:05:38.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:38.196]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:38.196]         }
[18:05:38.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:38.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:38.196]             base::sink(type = "output", split = FALSE)
[18:05:38.196]             base::close(...future.stdout)
[18:05:38.196]         }, add = TRUE)
[18:05:38.196]     }
[18:05:38.196]     ...future.frame <- base::sys.nframe()
[18:05:38.196]     ...future.conditions <- base::list()
[18:05:38.196]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:38.196]     if (FALSE) {
[18:05:38.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:38.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:38.196]     }
[18:05:38.196]     ...future.result <- base::tryCatch({
[18:05:38.196]         base::withCallingHandlers({
[18:05:38.196]             ...future.value <- base::withVisible(base::local({
[18:05:38.196]                 ...future.makeSendCondition <- base::local({
[18:05:38.196]                   sendCondition <- NULL
[18:05:38.196]                   function(frame = 1L) {
[18:05:38.196]                     if (is.function(sendCondition)) 
[18:05:38.196]                       return(sendCondition)
[18:05:38.196]                     ns <- getNamespace("parallel")
[18:05:38.196]                     if (exists("sendData", mode = "function", 
[18:05:38.196]                       envir = ns)) {
[18:05:38.196]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:38.196]                         envir = ns)
[18:05:38.196]                       envir <- sys.frame(frame)
[18:05:38.196]                       master <- NULL
[18:05:38.196]                       while (!identical(envir, .GlobalEnv) && 
[18:05:38.196]                         !identical(envir, emptyenv())) {
[18:05:38.196]                         if (exists("master", mode = "list", envir = envir, 
[18:05:38.196]                           inherits = FALSE)) {
[18:05:38.196]                           master <- get("master", mode = "list", 
[18:05:38.196]                             envir = envir, inherits = FALSE)
[18:05:38.196]                           if (inherits(master, c("SOCKnode", 
[18:05:38.196]                             "SOCK0node"))) {
[18:05:38.196]                             sendCondition <<- function(cond) {
[18:05:38.196]                               data <- list(type = "VALUE", value = cond, 
[18:05:38.196]                                 success = TRUE)
[18:05:38.196]                               parallel_sendData(master, data)
[18:05:38.196]                             }
[18:05:38.196]                             return(sendCondition)
[18:05:38.196]                           }
[18:05:38.196]                         }
[18:05:38.196]                         frame <- frame + 1L
[18:05:38.196]                         envir <- sys.frame(frame)
[18:05:38.196]                       }
[18:05:38.196]                     }
[18:05:38.196]                     sendCondition <<- function(cond) NULL
[18:05:38.196]                   }
[18:05:38.196]                 })
[18:05:38.196]                 withCallingHandlers({
[18:05:38.196]                   {
[18:05:38.196]                     value(future(subset(data, a == 2)))
[18:05:38.196]                   }
[18:05:38.196]                 }, immediateCondition = function(cond) {
[18:05:38.196]                   sendCondition <- ...future.makeSendCondition()
[18:05:38.196]                   sendCondition(cond)
[18:05:38.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:38.196]                   {
[18:05:38.196]                     inherits <- base::inherits
[18:05:38.196]                     invokeRestart <- base::invokeRestart
[18:05:38.196]                     is.null <- base::is.null
[18:05:38.196]                     muffled <- FALSE
[18:05:38.196]                     if (inherits(cond, "message")) {
[18:05:38.196]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:38.196]                       if (muffled) 
[18:05:38.196]                         invokeRestart("muffleMessage")
[18:05:38.196]                     }
[18:05:38.196]                     else if (inherits(cond, "warning")) {
[18:05:38.196]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:38.196]                       if (muffled) 
[18:05:38.196]                         invokeRestart("muffleWarning")
[18:05:38.196]                     }
[18:05:38.196]                     else if (inherits(cond, "condition")) {
[18:05:38.196]                       if (!is.null(pattern)) {
[18:05:38.196]                         computeRestarts <- base::computeRestarts
[18:05:38.196]                         grepl <- base::grepl
[18:05:38.196]                         restarts <- computeRestarts(cond)
[18:05:38.196]                         for (restart in restarts) {
[18:05:38.196]                           name <- restart$name
[18:05:38.196]                           if (is.null(name)) 
[18:05:38.196]                             next
[18:05:38.196]                           if (!grepl(pattern, name)) 
[18:05:38.196]                             next
[18:05:38.196]                           invokeRestart(restart)
[18:05:38.196]                           muffled <- TRUE
[18:05:38.196]                           break
[18:05:38.196]                         }
[18:05:38.196]                       }
[18:05:38.196]                     }
[18:05:38.196]                     invisible(muffled)
[18:05:38.196]                   }
[18:05:38.196]                   muffleCondition(cond)
[18:05:38.196]                 })
[18:05:38.196]             }))
[18:05:38.196]             future::FutureResult(value = ...future.value$value, 
[18:05:38.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:38.196]                   ...future.rng), globalenv = if (FALSE) 
[18:05:38.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:38.196]                     ...future.globalenv.names))
[18:05:38.196]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:38.196]         }, condition = base::local({
[18:05:38.196]             c <- base::c
[18:05:38.196]             inherits <- base::inherits
[18:05:38.196]             invokeRestart <- base::invokeRestart
[18:05:38.196]             length <- base::length
[18:05:38.196]             list <- base::list
[18:05:38.196]             seq.int <- base::seq.int
[18:05:38.196]             signalCondition <- base::signalCondition
[18:05:38.196]             sys.calls <- base::sys.calls
[18:05:38.196]             `[[` <- base::`[[`
[18:05:38.196]             `+` <- base::`+`
[18:05:38.196]             `<<-` <- base::`<<-`
[18:05:38.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:38.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:38.196]                   3L)]
[18:05:38.196]             }
[18:05:38.196]             function(cond) {
[18:05:38.196]                 is_error <- inherits(cond, "error")
[18:05:38.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:38.196]                   NULL)
[18:05:38.196]                 if (is_error) {
[18:05:38.196]                   sessionInformation <- function() {
[18:05:38.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:38.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:38.196]                       search = base::search(), system = base::Sys.info())
[18:05:38.196]                   }
[18:05:38.196]                   ...future.conditions[[length(...future.conditions) + 
[18:05:38.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:38.196]                     cond$call), session = sessionInformation(), 
[18:05:38.196]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:38.196]                   signalCondition(cond)
[18:05:38.196]                 }
[18:05:38.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:38.196]                 "immediateCondition"))) {
[18:05:38.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:38.196]                   ...future.conditions[[length(...future.conditions) + 
[18:05:38.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:38.196]                   if (TRUE && !signal) {
[18:05:38.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:38.196]                     {
[18:05:38.196]                       inherits <- base::inherits
[18:05:38.196]                       invokeRestart <- base::invokeRestart
[18:05:38.196]                       is.null <- base::is.null
[18:05:38.196]                       muffled <- FALSE
[18:05:38.196]                       if (inherits(cond, "message")) {
[18:05:38.196]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:38.196]                         if (muffled) 
[18:05:38.196]                           invokeRestart("muffleMessage")
[18:05:38.196]                       }
[18:05:38.196]                       else if (inherits(cond, "warning")) {
[18:05:38.196]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:38.196]                         if (muffled) 
[18:05:38.196]                           invokeRestart("muffleWarning")
[18:05:38.196]                       }
[18:05:38.196]                       else if (inherits(cond, "condition")) {
[18:05:38.196]                         if (!is.null(pattern)) {
[18:05:38.196]                           computeRestarts <- base::computeRestarts
[18:05:38.196]                           grepl <- base::grepl
[18:05:38.196]                           restarts <- computeRestarts(cond)
[18:05:38.196]                           for (restart in restarts) {
[18:05:38.196]                             name <- restart$name
[18:05:38.196]                             if (is.null(name)) 
[18:05:38.196]                               next
[18:05:38.196]                             if (!grepl(pattern, name)) 
[18:05:38.196]                               next
[18:05:38.196]                             invokeRestart(restart)
[18:05:38.196]                             muffled <- TRUE
[18:05:38.196]                             break
[18:05:38.196]                           }
[18:05:38.196]                         }
[18:05:38.196]                       }
[18:05:38.196]                       invisible(muffled)
[18:05:38.196]                     }
[18:05:38.196]                     muffleCondition(cond, pattern = "^muffle")
[18:05:38.196]                   }
[18:05:38.196]                 }
[18:05:38.196]                 else {
[18:05:38.196]                   if (TRUE) {
[18:05:38.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:38.196]                     {
[18:05:38.196]                       inherits <- base::inherits
[18:05:38.196]                       invokeRestart <- base::invokeRestart
[18:05:38.196]                       is.null <- base::is.null
[18:05:38.196]                       muffled <- FALSE
[18:05:38.196]                       if (inherits(cond, "message")) {
[18:05:38.196]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:38.196]                         if (muffled) 
[18:05:38.196]                           invokeRestart("muffleMessage")
[18:05:38.196]                       }
[18:05:38.196]                       else if (inherits(cond, "warning")) {
[18:05:38.196]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:38.196]                         if (muffled) 
[18:05:38.196]                           invokeRestart("muffleWarning")
[18:05:38.196]                       }
[18:05:38.196]                       else if (inherits(cond, "condition")) {
[18:05:38.196]                         if (!is.null(pattern)) {
[18:05:38.196]                           computeRestarts <- base::computeRestarts
[18:05:38.196]                           grepl <- base::grepl
[18:05:38.196]                           restarts <- computeRestarts(cond)
[18:05:38.196]                           for (restart in restarts) {
[18:05:38.196]                             name <- restart$name
[18:05:38.196]                             if (is.null(name)) 
[18:05:38.196]                               next
[18:05:38.196]                             if (!grepl(pattern, name)) 
[18:05:38.196]                               next
[18:05:38.196]                             invokeRestart(restart)
[18:05:38.196]                             muffled <- TRUE
[18:05:38.196]                             break
[18:05:38.196]                           }
[18:05:38.196]                         }
[18:05:38.196]                       }
[18:05:38.196]                       invisible(muffled)
[18:05:38.196]                     }
[18:05:38.196]                     muffleCondition(cond, pattern = "^muffle")
[18:05:38.196]                   }
[18:05:38.196]                 }
[18:05:38.196]             }
[18:05:38.196]         }))
[18:05:38.196]     }, error = function(ex) {
[18:05:38.196]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:38.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:38.196]                 ...future.rng), started = ...future.startTime, 
[18:05:38.196]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:38.196]             version = "1.8"), class = "FutureResult")
[18:05:38.196]     }, finally = {
[18:05:38.196]         if (!identical(...future.workdir, getwd())) 
[18:05:38.196]             setwd(...future.workdir)
[18:05:38.196]         {
[18:05:38.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:38.196]                 ...future.oldOptions$nwarnings <- NULL
[18:05:38.196]             }
[18:05:38.196]             base::options(...future.oldOptions)
[18:05:38.196]             if (.Platform$OS.type == "windows") {
[18:05:38.196]                 old_names <- names(...future.oldEnvVars)
[18:05:38.196]                 envs <- base::Sys.getenv()
[18:05:38.196]                 names <- names(envs)
[18:05:38.196]                 common <- intersect(names, old_names)
[18:05:38.196]                 added <- setdiff(names, old_names)
[18:05:38.196]                 removed <- setdiff(old_names, names)
[18:05:38.196]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:38.196]                   envs[common]]
[18:05:38.196]                 NAMES <- toupper(changed)
[18:05:38.196]                 args <- list()
[18:05:38.196]                 for (kk in seq_along(NAMES)) {
[18:05:38.196]                   name <- changed[[kk]]
[18:05:38.196]                   NAME <- NAMES[[kk]]
[18:05:38.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:38.196]                     next
[18:05:38.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:38.196]                 }
[18:05:38.196]                 NAMES <- toupper(added)
[18:05:38.196]                 for (kk in seq_along(NAMES)) {
[18:05:38.196]                   name <- added[[kk]]
[18:05:38.196]                   NAME <- NAMES[[kk]]
[18:05:38.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:38.196]                     next
[18:05:38.196]                   args[[name]] <- ""
[18:05:38.196]                 }
[18:05:38.196]                 NAMES <- toupper(removed)
[18:05:38.196]                 for (kk in seq_along(NAMES)) {
[18:05:38.196]                   name <- removed[[kk]]
[18:05:38.196]                   NAME <- NAMES[[kk]]
[18:05:38.196]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:38.196]                     next
[18:05:38.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:38.196]                 }
[18:05:38.196]                 if (length(args) > 0) 
[18:05:38.196]                   base::do.call(base::Sys.setenv, args = args)
[18:05:38.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:38.196]             }
[18:05:38.196]             else {
[18:05:38.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:38.196]             }
[18:05:38.196]             {
[18:05:38.196]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:38.196]                   0L) {
[18:05:38.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:38.196]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:38.196]                   base::options(opts)
[18:05:38.196]                 }
[18:05:38.196]                 {
[18:05:38.196]                   {
[18:05:38.196]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:38.196]                     NULL
[18:05:38.196]                   }
[18:05:38.196]                   options(future.plan = NULL)
[18:05:38.196]                   if (is.na(NA_character_)) 
[18:05:38.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:38.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:38.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:38.196]                     .init = FALSE)
[18:05:38.196]                 }
[18:05:38.196]             }
[18:05:38.196]         }
[18:05:38.196]     })
[18:05:38.196]     if (TRUE) {
[18:05:38.196]         base::sink(type = "output", split = FALSE)
[18:05:38.196]         if (TRUE) {
[18:05:38.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:38.196]         }
[18:05:38.196]         else {
[18:05:38.196]             ...future.result["stdout"] <- base::list(NULL)
[18:05:38.196]         }
[18:05:38.196]         base::close(...future.stdout)
[18:05:38.196]         ...future.stdout <- NULL
[18:05:38.196]     }
[18:05:38.196]     ...future.result$conditions <- ...future.conditions
[18:05:38.196]     ...future.result$finished <- base::Sys.time()
[18:05:38.196]     ...future.result
[18:05:38.196] }
[18:05:38.202] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[18:05:38.202] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[18:05:38.203] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[18:05:38.204] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[18:05:38.206] MultisessionFuture started
[18:05:38.206] - Launch lazy future ... done
[18:05:38.206] run() for ‘MultisessionFuture’ ... done
[18:05:38.206] result() for ClusterFuture ...
[18:05:38.207] receiveMessageFromWorker() for ClusterFuture ...
[18:05:38.207] - Validating connection of MultisessionFuture
[18:05:38.257] - received message: FutureResult
[18:05:38.257] - Received FutureResult
[18:05:38.257] - Erased future from FutureRegistry
[18:05:38.258] result() for ClusterFuture ...
[18:05:38.258] - result already collected: FutureResult
[18:05:38.258] result() for ClusterFuture ... done
[18:05:38.258] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:38.258] result() for ClusterFuture ... done
[18:05:38.259] result() for ClusterFuture ...
[18:05:38.259] - result already collected: FutureResult
[18:05:38.259] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[18:05:38.260] plan(): Setting new future strategy stack:
[18:05:38.260] List of future strategies:
[18:05:38.260] 1. multisession:
[18:05:38.260]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:38.260]    - tweaked: FALSE
[18:05:38.260]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:38.260] 2. multicore:
[18:05:38.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:05:38.260]    - tweaked: FALSE
[18:05:38.260]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:38.263] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:05:38.263] multisession:
[18:05:38.263] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:38.263] - tweaked: FALSE
[18:05:38.263] - call: plan(list(a = strategy1, b = strategy2))
[18:05:38.283] getGlobalsAndPackages() ...
[18:05:38.284] Not searching for globals
[18:05:38.284] - globals: [0] <none>
[18:05:38.284] getGlobalsAndPackages() ... DONE
[18:05:38.285] [local output] makeClusterPSOCK() ...
[18:05:38.301] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:38.302] [local output] Base port: 11151
[18:05:38.302] [local output] Getting setup options for 2 cluster nodes ...
[18:05:38.303] [local output]  - Node 1 of 2 ...
[18:05:38.303] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:38.305] [local output] Rscript port: 11151

[18:05:38.305] [local output]  - Node 2 of 2 ...
[18:05:38.306] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:38.307] [local output] Rscript port: 11151

[18:05:38.308] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:38.308] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:38.309] [local output] Setting up PSOCK nodes in parallel
[18:05:38.309] List of 36
[18:05:38.309]  $ worker          : chr "localhost"
[18:05:38.309]   ..- attr(*, "localhost")= logi TRUE
[18:05:38.309]  $ master          : chr "localhost"
[18:05:38.309]  $ port            : int 11151
[18:05:38.309]  $ connectTimeout  : num 120
[18:05:38.309]  $ timeout         : num 2592000
[18:05:38.309]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:38.309]  $ homogeneous     : logi TRUE
[18:05:38.309]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:38.309]  $ rscript_envs    : NULL
[18:05:38.309]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:38.309]  $ rscript_startup : NULL
[18:05:38.309]  $ rscript_sh      : chr "sh"
[18:05:38.309]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:38.309]  $ methods         : logi TRUE
[18:05:38.309]  $ socketOptions   : chr "no-delay"
[18:05:38.309]  $ useXDR          : logi FALSE
[18:05:38.309]  $ outfile         : chr "/dev/null"
[18:05:38.309]  $ renice          : int NA
[18:05:38.309]  $ rshcmd          : NULL
[18:05:38.309]  $ user            : chr(0) 
[18:05:38.309]  $ revtunnel       : logi FALSE
[18:05:38.309]  $ rshlogfile      : NULL
[18:05:38.309]  $ rshopts         : chr(0) 
[18:05:38.309]  $ rank            : int 1
[18:05:38.309]  $ manual          : logi FALSE
[18:05:38.309]  $ dryrun          : logi FALSE
[18:05:38.309]  $ quiet           : logi FALSE
[18:05:38.309]  $ setup_strategy  : chr "parallel"
[18:05:38.309]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:38.309]  $ pidfile         : chr "/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e44ad41a1a.pid"
[18:05:38.309]  $ rshcmd_label    : NULL
[18:05:38.309]  $ rsh_call        : NULL
[18:05:38.309]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:38.309]  $ localMachine    : logi TRUE
[18:05:38.309]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:38.309]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:38.309]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:38.309]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:38.309]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:38.309]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:38.309]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:38.309]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:38.309]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:38.309]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:38.309]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:38.309]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:38.309]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:38.309]  $ arguments       :List of 28
[18:05:38.309]   ..$ worker          : chr "localhost"
[18:05:38.309]   ..$ master          : NULL
[18:05:38.309]   ..$ port            : int 11151
[18:05:38.309]   ..$ connectTimeout  : num 120
[18:05:38.309]   ..$ timeout         : num 2592000
[18:05:38.309]   ..$ rscript         : NULL
[18:05:38.309]   ..$ homogeneous     : NULL
[18:05:38.309]   ..$ rscript_args    : NULL
[18:05:38.309]   ..$ rscript_envs    : NULL
[18:05:38.309]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:38.309]   ..$ rscript_startup : NULL
[18:05:38.309]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:38.309]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:38.309]   ..$ methods         : logi TRUE
[18:05:38.309]   ..$ socketOptions   : chr "no-delay"
[18:05:38.309]   ..$ useXDR          : logi FALSE
[18:05:38.309]   ..$ outfile         : chr "/dev/null"
[18:05:38.309]   ..$ renice          : int NA
[18:05:38.309]   ..$ rshcmd          : NULL
[18:05:38.309]   ..$ user            : NULL
[18:05:38.309]   ..$ revtunnel       : logi NA
[18:05:38.309]   ..$ rshlogfile      : NULL
[18:05:38.309]   ..$ rshopts         : NULL
[18:05:38.309]   ..$ rank            : int 1
[18:05:38.309]   ..$ manual          : logi FALSE
[18:05:38.309]   ..$ dryrun          : logi FALSE
[18:05:38.309]   ..$ quiet           : logi FALSE
[18:05:38.309]   ..$ setup_strategy  : chr "parallel"
[18:05:38.309]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:38.345] [local output] System call to launch all workers:
[18:05:38.345] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e44ad41a1a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11151 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:38.346] [local output] Starting PSOCK main server
[18:05:38.351] [local output] Workers launched
[18:05:38.351] [local output] Waiting for workers to connect back
[18:05:38.351]  - [local output] 0 workers out of 2 ready
[18:05:38.754]  - [local output] 0 workers out of 2 ready
[18:05:38.758]  - [local output] 1 workers out of 2 ready
[18:05:38.811]  - [local output] 1 workers out of 2 ready
[18:05:38.814]  - [local output] 2 workers out of 2 ready
[18:05:38.814] [local output] Launching of workers completed
[18:05:38.815] [local output] Collecting session information from workers
[18:05:38.817] [local output]  - Worker #1 of 2
[18:05:38.818] [local output]  - Worker #2 of 2
[18:05:38.819] [local output] makeClusterPSOCK() ... done
[18:05:38.845] Packages needed by the future expression (n = 0): <none>
[18:05:38.845] Packages needed by future strategies (n = 1): ‘future’
[18:05:38.846] {
[18:05:38.846]     {
[18:05:38.846]         {
[18:05:38.846]             ...future.startTime <- base::Sys.time()
[18:05:38.846]             {
[18:05:38.846]                 {
[18:05:38.846]                   {
[18:05:38.846]                     {
[18:05:38.846]                       {
[18:05:38.846]                         base::local({
[18:05:38.846]                           has_future <- base::requireNamespace("future", 
[18:05:38.846]                             quietly = TRUE)
[18:05:38.846]                           if (has_future) {
[18:05:38.846]                             ns <- base::getNamespace("future")
[18:05:38.846]                             version <- ns[[".package"]][["version"]]
[18:05:38.846]                             if (is.null(version)) 
[18:05:38.846]                               version <- utils::packageVersion("future")
[18:05:38.846]                           }
[18:05:38.846]                           else {
[18:05:38.846]                             version <- NULL
[18:05:38.846]                           }
[18:05:38.846]                           if (!has_future || version < "1.8.0") {
[18:05:38.846]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:38.846]                               "", base::R.version$version.string), 
[18:05:38.846]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:38.846]                                 base::R.version$platform, 8 * 
[18:05:38.846]                                   base::.Machine$sizeof.pointer), 
[18:05:38.846]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:38.846]                                 "release", "version")], collapse = " "), 
[18:05:38.846]                               hostname = base::Sys.info()[["nodename"]])
[18:05:38.846]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:38.846]                               info)
[18:05:38.846]                             info <- base::paste(info, collapse = "; ")
[18:05:38.846]                             if (!has_future) {
[18:05:38.846]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:38.846]                                 info)
[18:05:38.846]                             }
[18:05:38.846]                             else {
[18:05:38.846]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:38.846]                                 info, version)
[18:05:38.846]                             }
[18:05:38.846]                             base::stop(msg)
[18:05:38.846]                           }
[18:05:38.846]                         })
[18:05:38.846]                       }
[18:05:38.846]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:38.846]                       base::options(mc.cores = 1L)
[18:05:38.846]                     }
[18:05:38.846]                     base::local({
[18:05:38.846]                       for (pkg in "future") {
[18:05:38.846]                         base::loadNamespace(pkg)
[18:05:38.846]                         base::library(pkg, character.only = TRUE)
[18:05:38.846]                       }
[18:05:38.846]                     })
[18:05:38.846]                   }
[18:05:38.846]                   ...future.strategy.old <- future::plan("list")
[18:05:38.846]                   options(future.plan = NULL)
[18:05:38.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:38.846]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:38.846]                     envir = parent.frame()) 
[18:05:38.846]                   {
[18:05:38.846]                     default_workers <- missing(workers)
[18:05:38.846]                     if (is.function(workers)) 
[18:05:38.846]                       workers <- workers()
[18:05:38.846]                     workers <- structure(as.integer(workers), 
[18:05:38.846]                       class = class(workers))
[18:05:38.846]                     stop_if_not(is.finite(workers), workers >= 
[18:05:38.846]                       1L)
[18:05:38.846]                     if ((workers == 1L && !inherits(workers, 
[18:05:38.846]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:38.846]                       if (default_workers) 
[18:05:38.846]                         supportsMulticore(warn = TRUE)
[18:05:38.846]                       return(sequential(..., envir = envir))
[18:05:38.846]                     }
[18:05:38.846]                     oopts <- options(mc.cores = workers)
[18:05:38.846]                     on.exit(options(oopts))
[18:05:38.846]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:38.846]                       envir = envir)
[18:05:38.846]                     if (!future$lazy) 
[18:05:38.846]                       future <- run(future)
[18:05:38.846]                     invisible(future)
[18:05:38.846]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:38.846]                 }
[18:05:38.846]                 ...future.workdir <- getwd()
[18:05:38.846]             }
[18:05:38.846]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:38.846]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:38.846]         }
[18:05:38.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:38.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:38.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:38.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:38.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:38.846]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:38.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:38.846]             base::names(...future.oldOptions))
[18:05:38.846]     }
[18:05:38.846]     if (FALSE) {
[18:05:38.846]     }
[18:05:38.846]     else {
[18:05:38.846]         if (TRUE) {
[18:05:38.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:38.846]                 open = "w")
[18:05:38.846]         }
[18:05:38.846]         else {
[18:05:38.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:38.846]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:38.846]         }
[18:05:38.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:38.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:38.846]             base::sink(type = "output", split = FALSE)
[18:05:38.846]             base::close(...future.stdout)
[18:05:38.846]         }, add = TRUE)
[18:05:38.846]     }
[18:05:38.846]     ...future.frame <- base::sys.nframe()
[18:05:38.846]     ...future.conditions <- base::list()
[18:05:38.846]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:38.846]     if (FALSE) {
[18:05:38.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:38.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:38.846]     }
[18:05:38.846]     ...future.result <- base::tryCatch({
[18:05:38.846]         base::withCallingHandlers({
[18:05:38.846]             ...future.value <- base::withVisible(base::local({
[18:05:38.846]                 ...future.makeSendCondition <- base::local({
[18:05:38.846]                   sendCondition <- NULL
[18:05:38.846]                   function(frame = 1L) {
[18:05:38.846]                     if (is.function(sendCondition)) 
[18:05:38.846]                       return(sendCondition)
[18:05:38.846]                     ns <- getNamespace("parallel")
[18:05:38.846]                     if (exists("sendData", mode = "function", 
[18:05:38.846]                       envir = ns)) {
[18:05:38.846]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:38.846]                         envir = ns)
[18:05:38.846]                       envir <- sys.frame(frame)
[18:05:38.846]                       master <- NULL
[18:05:38.846]                       while (!identical(envir, .GlobalEnv) && 
[18:05:38.846]                         !identical(envir, emptyenv())) {
[18:05:38.846]                         if (exists("master", mode = "list", envir = envir, 
[18:05:38.846]                           inherits = FALSE)) {
[18:05:38.846]                           master <- get("master", mode = "list", 
[18:05:38.846]                             envir = envir, inherits = FALSE)
[18:05:38.846]                           if (inherits(master, c("SOCKnode", 
[18:05:38.846]                             "SOCK0node"))) {
[18:05:38.846]                             sendCondition <<- function(cond) {
[18:05:38.846]                               data <- list(type = "VALUE", value = cond, 
[18:05:38.846]                                 success = TRUE)
[18:05:38.846]                               parallel_sendData(master, data)
[18:05:38.846]                             }
[18:05:38.846]                             return(sendCondition)
[18:05:38.846]                           }
[18:05:38.846]                         }
[18:05:38.846]                         frame <- frame + 1L
[18:05:38.846]                         envir <- sys.frame(frame)
[18:05:38.846]                       }
[18:05:38.846]                     }
[18:05:38.846]                     sendCondition <<- function(cond) NULL
[18:05:38.846]                   }
[18:05:38.846]                 })
[18:05:38.846]                 withCallingHandlers({
[18:05:38.846]                   NA
[18:05:38.846]                 }, immediateCondition = function(cond) {
[18:05:38.846]                   sendCondition <- ...future.makeSendCondition()
[18:05:38.846]                   sendCondition(cond)
[18:05:38.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:38.846]                   {
[18:05:38.846]                     inherits <- base::inherits
[18:05:38.846]                     invokeRestart <- base::invokeRestart
[18:05:38.846]                     is.null <- base::is.null
[18:05:38.846]                     muffled <- FALSE
[18:05:38.846]                     if (inherits(cond, "message")) {
[18:05:38.846]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:38.846]                       if (muffled) 
[18:05:38.846]                         invokeRestart("muffleMessage")
[18:05:38.846]                     }
[18:05:38.846]                     else if (inherits(cond, "warning")) {
[18:05:38.846]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:38.846]                       if (muffled) 
[18:05:38.846]                         invokeRestart("muffleWarning")
[18:05:38.846]                     }
[18:05:38.846]                     else if (inherits(cond, "condition")) {
[18:05:38.846]                       if (!is.null(pattern)) {
[18:05:38.846]                         computeRestarts <- base::computeRestarts
[18:05:38.846]                         grepl <- base::grepl
[18:05:38.846]                         restarts <- computeRestarts(cond)
[18:05:38.846]                         for (restart in restarts) {
[18:05:38.846]                           name <- restart$name
[18:05:38.846]                           if (is.null(name)) 
[18:05:38.846]                             next
[18:05:38.846]                           if (!grepl(pattern, name)) 
[18:05:38.846]                             next
[18:05:38.846]                           invokeRestart(restart)
[18:05:38.846]                           muffled <- TRUE
[18:05:38.846]                           break
[18:05:38.846]                         }
[18:05:38.846]                       }
[18:05:38.846]                     }
[18:05:38.846]                     invisible(muffled)
[18:05:38.846]                   }
[18:05:38.846]                   muffleCondition(cond)
[18:05:38.846]                 })
[18:05:38.846]             }))
[18:05:38.846]             future::FutureResult(value = ...future.value$value, 
[18:05:38.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:38.846]                   ...future.rng), globalenv = if (FALSE) 
[18:05:38.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:38.846]                     ...future.globalenv.names))
[18:05:38.846]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:38.846]         }, condition = base::local({
[18:05:38.846]             c <- base::c
[18:05:38.846]             inherits <- base::inherits
[18:05:38.846]             invokeRestart <- base::invokeRestart
[18:05:38.846]             length <- base::length
[18:05:38.846]             list <- base::list
[18:05:38.846]             seq.int <- base::seq.int
[18:05:38.846]             signalCondition <- base::signalCondition
[18:05:38.846]             sys.calls <- base::sys.calls
[18:05:38.846]             `[[` <- base::`[[`
[18:05:38.846]             `+` <- base::`+`
[18:05:38.846]             `<<-` <- base::`<<-`
[18:05:38.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:38.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:38.846]                   3L)]
[18:05:38.846]             }
[18:05:38.846]             function(cond) {
[18:05:38.846]                 is_error <- inherits(cond, "error")
[18:05:38.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:38.846]                   NULL)
[18:05:38.846]                 if (is_error) {
[18:05:38.846]                   sessionInformation <- function() {
[18:05:38.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:38.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:38.846]                       search = base::search(), system = base::Sys.info())
[18:05:38.846]                   }
[18:05:38.846]                   ...future.conditions[[length(...future.conditions) + 
[18:05:38.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:38.846]                     cond$call), session = sessionInformation(), 
[18:05:38.846]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:38.846]                   signalCondition(cond)
[18:05:38.846]                 }
[18:05:38.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:38.846]                 "immediateCondition"))) {
[18:05:38.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:38.846]                   ...future.conditions[[length(...future.conditions) + 
[18:05:38.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:38.846]                   if (TRUE && !signal) {
[18:05:38.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:38.846]                     {
[18:05:38.846]                       inherits <- base::inherits
[18:05:38.846]                       invokeRestart <- base::invokeRestart
[18:05:38.846]                       is.null <- base::is.null
[18:05:38.846]                       muffled <- FALSE
[18:05:38.846]                       if (inherits(cond, "message")) {
[18:05:38.846]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:38.846]                         if (muffled) 
[18:05:38.846]                           invokeRestart("muffleMessage")
[18:05:38.846]                       }
[18:05:38.846]                       else if (inherits(cond, "warning")) {
[18:05:38.846]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:38.846]                         if (muffled) 
[18:05:38.846]                           invokeRestart("muffleWarning")
[18:05:38.846]                       }
[18:05:38.846]                       else if (inherits(cond, "condition")) {
[18:05:38.846]                         if (!is.null(pattern)) {
[18:05:38.846]                           computeRestarts <- base::computeRestarts
[18:05:38.846]                           grepl <- base::grepl
[18:05:38.846]                           restarts <- computeRestarts(cond)
[18:05:38.846]                           for (restart in restarts) {
[18:05:38.846]                             name <- restart$name
[18:05:38.846]                             if (is.null(name)) 
[18:05:38.846]                               next
[18:05:38.846]                             if (!grepl(pattern, name)) 
[18:05:38.846]                               next
[18:05:38.846]                             invokeRestart(restart)
[18:05:38.846]                             muffled <- TRUE
[18:05:38.846]                             break
[18:05:38.846]                           }
[18:05:38.846]                         }
[18:05:38.846]                       }
[18:05:38.846]                       invisible(muffled)
[18:05:38.846]                     }
[18:05:38.846]                     muffleCondition(cond, pattern = "^muffle")
[18:05:38.846]                   }
[18:05:38.846]                 }
[18:05:38.846]                 else {
[18:05:38.846]                   if (TRUE) {
[18:05:38.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:38.846]                     {
[18:05:38.846]                       inherits <- base::inherits
[18:05:38.846]                       invokeRestart <- base::invokeRestart
[18:05:38.846]                       is.null <- base::is.null
[18:05:38.846]                       muffled <- FALSE
[18:05:38.846]                       if (inherits(cond, "message")) {
[18:05:38.846]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:38.846]                         if (muffled) 
[18:05:38.846]                           invokeRestart("muffleMessage")
[18:05:38.846]                       }
[18:05:38.846]                       else if (inherits(cond, "warning")) {
[18:05:38.846]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:38.846]                         if (muffled) 
[18:05:38.846]                           invokeRestart("muffleWarning")
[18:05:38.846]                       }
[18:05:38.846]                       else if (inherits(cond, "condition")) {
[18:05:38.846]                         if (!is.null(pattern)) {
[18:05:38.846]                           computeRestarts <- base::computeRestarts
[18:05:38.846]                           grepl <- base::grepl
[18:05:38.846]                           restarts <- computeRestarts(cond)
[18:05:38.846]                           for (restart in restarts) {
[18:05:38.846]                             name <- restart$name
[18:05:38.846]                             if (is.null(name)) 
[18:05:38.846]                               next
[18:05:38.846]                             if (!grepl(pattern, name)) 
[18:05:38.846]                               next
[18:05:38.846]                             invokeRestart(restart)
[18:05:38.846]                             muffled <- TRUE
[18:05:38.846]                             break
[18:05:38.846]                           }
[18:05:38.846]                         }
[18:05:38.846]                       }
[18:05:38.846]                       invisible(muffled)
[18:05:38.846]                     }
[18:05:38.846]                     muffleCondition(cond, pattern = "^muffle")
[18:05:38.846]                   }
[18:05:38.846]                 }
[18:05:38.846]             }
[18:05:38.846]         }))
[18:05:38.846]     }, error = function(ex) {
[18:05:38.846]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:38.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:38.846]                 ...future.rng), started = ...future.startTime, 
[18:05:38.846]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:38.846]             version = "1.8"), class = "FutureResult")
[18:05:38.846]     }, finally = {
[18:05:38.846]         if (!identical(...future.workdir, getwd())) 
[18:05:38.846]             setwd(...future.workdir)
[18:05:38.846]         {
[18:05:38.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:38.846]                 ...future.oldOptions$nwarnings <- NULL
[18:05:38.846]             }
[18:05:38.846]             base::options(...future.oldOptions)
[18:05:38.846]             if (.Platform$OS.type == "windows") {
[18:05:38.846]                 old_names <- names(...future.oldEnvVars)
[18:05:38.846]                 envs <- base::Sys.getenv()
[18:05:38.846]                 names <- names(envs)
[18:05:38.846]                 common <- intersect(names, old_names)
[18:05:38.846]                 added <- setdiff(names, old_names)
[18:05:38.846]                 removed <- setdiff(old_names, names)
[18:05:38.846]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:38.846]                   envs[common]]
[18:05:38.846]                 NAMES <- toupper(changed)
[18:05:38.846]                 args <- list()
[18:05:38.846]                 for (kk in seq_along(NAMES)) {
[18:05:38.846]                   name <- changed[[kk]]
[18:05:38.846]                   NAME <- NAMES[[kk]]
[18:05:38.846]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:38.846]                     next
[18:05:38.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:38.846]                 }
[18:05:38.846]                 NAMES <- toupper(added)
[18:05:38.846]                 for (kk in seq_along(NAMES)) {
[18:05:38.846]                   name <- added[[kk]]
[18:05:38.846]                   NAME <- NAMES[[kk]]
[18:05:38.846]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:38.846]                     next
[18:05:38.846]                   args[[name]] <- ""
[18:05:38.846]                 }
[18:05:38.846]                 NAMES <- toupper(removed)
[18:05:38.846]                 for (kk in seq_along(NAMES)) {
[18:05:38.846]                   name <- removed[[kk]]
[18:05:38.846]                   NAME <- NAMES[[kk]]
[18:05:38.846]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:38.846]                     next
[18:05:38.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:38.846]                 }
[18:05:38.846]                 if (length(args) > 0) 
[18:05:38.846]                   base::do.call(base::Sys.setenv, args = args)
[18:05:38.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:38.846]             }
[18:05:38.846]             else {
[18:05:38.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:38.846]             }
[18:05:38.846]             {
[18:05:38.846]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:38.846]                   0L) {
[18:05:38.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:38.846]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:38.846]                   base::options(opts)
[18:05:38.846]                 }
[18:05:38.846]                 {
[18:05:38.846]                   {
[18:05:38.846]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:38.846]                     NULL
[18:05:38.846]                   }
[18:05:38.846]                   options(future.plan = NULL)
[18:05:38.846]                   if (is.na(NA_character_)) 
[18:05:38.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:38.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:38.846]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:38.846]                     .init = FALSE)
[18:05:38.846]                 }
[18:05:38.846]             }
[18:05:38.846]         }
[18:05:38.846]     })
[18:05:38.846]     if (TRUE) {
[18:05:38.846]         base::sink(type = "output", split = FALSE)
[18:05:38.846]         if (TRUE) {
[18:05:38.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:38.846]         }
[18:05:38.846]         else {
[18:05:38.846]             ...future.result["stdout"] <- base::list(NULL)
[18:05:38.846]         }
[18:05:38.846]         base::close(...future.stdout)
[18:05:38.846]         ...future.stdout <- NULL
[18:05:38.846]     }
[18:05:38.846]     ...future.result$conditions <- ...future.conditions
[18:05:38.846]     ...future.result$finished <- base::Sys.time()
[18:05:38.846]     ...future.result
[18:05:38.846] }
[18:05:38.970] MultisessionFuture started
[18:05:38.973] result() for ClusterFuture ...
[18:05:38.973] receiveMessageFromWorker() for ClusterFuture ...
[18:05:38.973] - Validating connection of MultisessionFuture
[18:05:39.067] - received message: FutureResult
[18:05:39.067] - Received FutureResult
[18:05:39.068] - Erased future from FutureRegistry
[18:05:39.068] result() for ClusterFuture ...
[18:05:39.068] - result already collected: FutureResult
[18:05:39.068] result() for ClusterFuture ... done
[18:05:39.068] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:39.069] result() for ClusterFuture ... done
[18:05:39.069] result() for ClusterFuture ...
[18:05:39.069] - result already collected: FutureResult
[18:05:39.069] result() for ClusterFuture ... done
[18:05:39.070] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:05:39.076] plan(): nbrOfWorkers() = 2
[18:05:39.076] getGlobalsAndPackages() ...
[18:05:39.076] Searching for globals...
[18:05:39.115] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:39.115] Searching for globals ... DONE
[18:05:39.116] Resolving globals: FALSE
[18:05:39.118] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[18:05:39.119] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:39.119] - globals: [2] ‘nested’, ‘strategy2’
[18:05:39.119] - packages: [1] ‘future’
[18:05:39.119] getGlobalsAndPackages() ... DONE
[18:05:39.120] run() for ‘Future’ ...
[18:05:39.120] - state: ‘created’
[18:05:39.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:39.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:39.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:39.146]   - Field: ‘node’
[18:05:39.146]   - Field: ‘label’
[18:05:39.146]   - Field: ‘local’
[18:05:39.146]   - Field: ‘owner’
[18:05:39.147]   - Field: ‘envir’
[18:05:39.147]   - Field: ‘workers’
[18:05:39.147]   - Field: ‘packages’
[18:05:39.147]   - Field: ‘gc’
[18:05:39.148]   - Field: ‘conditions’
[18:05:39.148]   - Field: ‘persistent’
[18:05:39.148]   - Field: ‘expr’
[18:05:39.148]   - Field: ‘uuid’
[18:05:39.148]   - Field: ‘seed’
[18:05:39.149]   - Field: ‘version’
[18:05:39.149]   - Field: ‘result’
[18:05:39.149]   - Field: ‘asynchronous’
[18:05:39.149]   - Field: ‘calls’
[18:05:39.149]   - Field: ‘globals’
[18:05:39.150]   - Field: ‘stdout’
[18:05:39.150]   - Field: ‘earlySignal’
[18:05:39.150]   - Field: ‘lazy’
[18:05:39.150]   - Field: ‘state’
[18:05:39.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:39.151] - Launch lazy future ...
[18:05:39.151] Packages needed by the future expression (n = 1): ‘future’
[18:05:39.152] Packages needed by future strategies (n = 1): ‘future’
[18:05:39.153] {
[18:05:39.153]     {
[18:05:39.153]         {
[18:05:39.153]             ...future.startTime <- base::Sys.time()
[18:05:39.153]             {
[18:05:39.153]                 {
[18:05:39.153]                   {
[18:05:39.153]                     {
[18:05:39.153]                       {
[18:05:39.153]                         base::local({
[18:05:39.153]                           has_future <- base::requireNamespace("future", 
[18:05:39.153]                             quietly = TRUE)
[18:05:39.153]                           if (has_future) {
[18:05:39.153]                             ns <- base::getNamespace("future")
[18:05:39.153]                             version <- ns[[".package"]][["version"]]
[18:05:39.153]                             if (is.null(version)) 
[18:05:39.153]                               version <- utils::packageVersion("future")
[18:05:39.153]                           }
[18:05:39.153]                           else {
[18:05:39.153]                             version <- NULL
[18:05:39.153]                           }
[18:05:39.153]                           if (!has_future || version < "1.8.0") {
[18:05:39.153]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:39.153]                               "", base::R.version$version.string), 
[18:05:39.153]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:39.153]                                 base::R.version$platform, 8 * 
[18:05:39.153]                                   base::.Machine$sizeof.pointer), 
[18:05:39.153]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:39.153]                                 "release", "version")], collapse = " "), 
[18:05:39.153]                               hostname = base::Sys.info()[["nodename"]])
[18:05:39.153]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:39.153]                               info)
[18:05:39.153]                             info <- base::paste(info, collapse = "; ")
[18:05:39.153]                             if (!has_future) {
[18:05:39.153]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:39.153]                                 info)
[18:05:39.153]                             }
[18:05:39.153]                             else {
[18:05:39.153]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:39.153]                                 info, version)
[18:05:39.153]                             }
[18:05:39.153]                             base::stop(msg)
[18:05:39.153]                           }
[18:05:39.153]                         })
[18:05:39.153]                       }
[18:05:39.153]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:39.153]                       base::options(mc.cores = 1L)
[18:05:39.153]                     }
[18:05:39.153]                     base::local({
[18:05:39.153]                       for (pkg in "future") {
[18:05:39.153]                         base::loadNamespace(pkg)
[18:05:39.153]                         base::library(pkg, character.only = TRUE)
[18:05:39.153]                       }
[18:05:39.153]                     })
[18:05:39.153]                   }
[18:05:39.153]                   ...future.strategy.old <- future::plan("list")
[18:05:39.153]                   options(future.plan = NULL)
[18:05:39.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:39.153]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:39.153]                     envir = parent.frame()) 
[18:05:39.153]                   {
[18:05:39.153]                     default_workers <- missing(workers)
[18:05:39.153]                     if (is.function(workers)) 
[18:05:39.153]                       workers <- workers()
[18:05:39.153]                     workers <- structure(as.integer(workers), 
[18:05:39.153]                       class = class(workers))
[18:05:39.153]                     stop_if_not(is.finite(workers), workers >= 
[18:05:39.153]                       1L)
[18:05:39.153]                     if ((workers == 1L && !inherits(workers, 
[18:05:39.153]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:39.153]                       if (default_workers) 
[18:05:39.153]                         supportsMulticore(warn = TRUE)
[18:05:39.153]                       return(sequential(..., envir = envir))
[18:05:39.153]                     }
[18:05:39.153]                     oopts <- options(mc.cores = workers)
[18:05:39.153]                     on.exit(options(oopts))
[18:05:39.153]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:39.153]                       envir = envir)
[18:05:39.153]                     if (!future$lazy) 
[18:05:39.153]                       future <- run(future)
[18:05:39.153]                     invisible(future)
[18:05:39.153]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:39.153]                 }
[18:05:39.153]                 ...future.workdir <- getwd()
[18:05:39.153]             }
[18:05:39.153]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:39.153]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:39.153]         }
[18:05:39.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:39.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:39.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:39.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:39.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:39.153]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:39.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:39.153]             base::names(...future.oldOptions))
[18:05:39.153]     }
[18:05:39.153]     if (FALSE) {
[18:05:39.153]     }
[18:05:39.153]     else {
[18:05:39.153]         if (TRUE) {
[18:05:39.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:39.153]                 open = "w")
[18:05:39.153]         }
[18:05:39.153]         else {
[18:05:39.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:39.153]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:39.153]         }
[18:05:39.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:39.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:39.153]             base::sink(type = "output", split = FALSE)
[18:05:39.153]             base::close(...future.stdout)
[18:05:39.153]         }, add = TRUE)
[18:05:39.153]     }
[18:05:39.153]     ...future.frame <- base::sys.nframe()
[18:05:39.153]     ...future.conditions <- base::list()
[18:05:39.153]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:39.153]     if (FALSE) {
[18:05:39.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:39.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:39.153]     }
[18:05:39.153]     ...future.result <- base::tryCatch({
[18:05:39.153]         base::withCallingHandlers({
[18:05:39.153]             ...future.value <- base::withVisible(base::local({
[18:05:39.153]                 ...future.makeSendCondition <- base::local({
[18:05:39.153]                   sendCondition <- NULL
[18:05:39.153]                   function(frame = 1L) {
[18:05:39.153]                     if (is.function(sendCondition)) 
[18:05:39.153]                       return(sendCondition)
[18:05:39.153]                     ns <- getNamespace("parallel")
[18:05:39.153]                     if (exists("sendData", mode = "function", 
[18:05:39.153]                       envir = ns)) {
[18:05:39.153]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:39.153]                         envir = ns)
[18:05:39.153]                       envir <- sys.frame(frame)
[18:05:39.153]                       master <- NULL
[18:05:39.153]                       while (!identical(envir, .GlobalEnv) && 
[18:05:39.153]                         !identical(envir, emptyenv())) {
[18:05:39.153]                         if (exists("master", mode = "list", envir = envir, 
[18:05:39.153]                           inherits = FALSE)) {
[18:05:39.153]                           master <- get("master", mode = "list", 
[18:05:39.153]                             envir = envir, inherits = FALSE)
[18:05:39.153]                           if (inherits(master, c("SOCKnode", 
[18:05:39.153]                             "SOCK0node"))) {
[18:05:39.153]                             sendCondition <<- function(cond) {
[18:05:39.153]                               data <- list(type = "VALUE", value = cond, 
[18:05:39.153]                                 success = TRUE)
[18:05:39.153]                               parallel_sendData(master, data)
[18:05:39.153]                             }
[18:05:39.153]                             return(sendCondition)
[18:05:39.153]                           }
[18:05:39.153]                         }
[18:05:39.153]                         frame <- frame + 1L
[18:05:39.153]                         envir <- sys.frame(frame)
[18:05:39.153]                       }
[18:05:39.153]                     }
[18:05:39.153]                     sendCondition <<- function(cond) NULL
[18:05:39.153]                   }
[18:05:39.153]                 })
[18:05:39.153]                 withCallingHandlers({
[18:05:39.153]                   {
[18:05:39.153]                     a <- 1L
[18:05:39.153]                     plan_a <- unclass(future::plan("list"))
[18:05:39.153]                     nested_a <- nested[-1]
[18:05:39.153]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:39.153]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:39.153]                       strategy2))
[18:05:39.153]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:39.153]                       "init") <- NULL
[18:05:39.153]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:39.153]                       "init") <- NULL
[18:05:39.153]                     stopifnot(all.equal(plan_a, nested_a))
[18:05:39.153]                     y %<-% {
[18:05:39.153]                       b <- 2L
[18:05:39.153]                       plan_b <- future::plan("list")
[18:05:39.153]                       nested_b <- nested_a[-1]
[18:05:39.153]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:39.153]                         1L, inherits(plan_b[[1]], "future"), 
[18:05:39.153]                         inherits(future::plan("next"), "sequential"))
[18:05:39.153]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:39.153]                         b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:39.153]                     }
[18:05:39.153]                     y
[18:05:39.153]                   }
[18:05:39.153]                 }, immediateCondition = function(cond) {
[18:05:39.153]                   sendCondition <- ...future.makeSendCondition()
[18:05:39.153]                   sendCondition(cond)
[18:05:39.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.153]                   {
[18:05:39.153]                     inherits <- base::inherits
[18:05:39.153]                     invokeRestart <- base::invokeRestart
[18:05:39.153]                     is.null <- base::is.null
[18:05:39.153]                     muffled <- FALSE
[18:05:39.153]                     if (inherits(cond, "message")) {
[18:05:39.153]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:39.153]                       if (muffled) 
[18:05:39.153]                         invokeRestart("muffleMessage")
[18:05:39.153]                     }
[18:05:39.153]                     else if (inherits(cond, "warning")) {
[18:05:39.153]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:39.153]                       if (muffled) 
[18:05:39.153]                         invokeRestart("muffleWarning")
[18:05:39.153]                     }
[18:05:39.153]                     else if (inherits(cond, "condition")) {
[18:05:39.153]                       if (!is.null(pattern)) {
[18:05:39.153]                         computeRestarts <- base::computeRestarts
[18:05:39.153]                         grepl <- base::grepl
[18:05:39.153]                         restarts <- computeRestarts(cond)
[18:05:39.153]                         for (restart in restarts) {
[18:05:39.153]                           name <- restart$name
[18:05:39.153]                           if (is.null(name)) 
[18:05:39.153]                             next
[18:05:39.153]                           if (!grepl(pattern, name)) 
[18:05:39.153]                             next
[18:05:39.153]                           invokeRestart(restart)
[18:05:39.153]                           muffled <- TRUE
[18:05:39.153]                           break
[18:05:39.153]                         }
[18:05:39.153]                       }
[18:05:39.153]                     }
[18:05:39.153]                     invisible(muffled)
[18:05:39.153]                   }
[18:05:39.153]                   muffleCondition(cond)
[18:05:39.153]                 })
[18:05:39.153]             }))
[18:05:39.153]             future::FutureResult(value = ...future.value$value, 
[18:05:39.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:39.153]                   ...future.rng), globalenv = if (FALSE) 
[18:05:39.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:39.153]                     ...future.globalenv.names))
[18:05:39.153]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:39.153]         }, condition = base::local({
[18:05:39.153]             c <- base::c
[18:05:39.153]             inherits <- base::inherits
[18:05:39.153]             invokeRestart <- base::invokeRestart
[18:05:39.153]             length <- base::length
[18:05:39.153]             list <- base::list
[18:05:39.153]             seq.int <- base::seq.int
[18:05:39.153]             signalCondition <- base::signalCondition
[18:05:39.153]             sys.calls <- base::sys.calls
[18:05:39.153]             `[[` <- base::`[[`
[18:05:39.153]             `+` <- base::`+`
[18:05:39.153]             `<<-` <- base::`<<-`
[18:05:39.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:39.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:39.153]                   3L)]
[18:05:39.153]             }
[18:05:39.153]             function(cond) {
[18:05:39.153]                 is_error <- inherits(cond, "error")
[18:05:39.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:39.153]                   NULL)
[18:05:39.153]                 if (is_error) {
[18:05:39.153]                   sessionInformation <- function() {
[18:05:39.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:39.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:39.153]                       search = base::search(), system = base::Sys.info())
[18:05:39.153]                   }
[18:05:39.153]                   ...future.conditions[[length(...future.conditions) + 
[18:05:39.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:39.153]                     cond$call), session = sessionInformation(), 
[18:05:39.153]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:39.153]                   signalCondition(cond)
[18:05:39.153]                 }
[18:05:39.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:39.153]                 "immediateCondition"))) {
[18:05:39.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:39.153]                   ...future.conditions[[length(...future.conditions) + 
[18:05:39.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:39.153]                   if (TRUE && !signal) {
[18:05:39.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.153]                     {
[18:05:39.153]                       inherits <- base::inherits
[18:05:39.153]                       invokeRestart <- base::invokeRestart
[18:05:39.153]                       is.null <- base::is.null
[18:05:39.153]                       muffled <- FALSE
[18:05:39.153]                       if (inherits(cond, "message")) {
[18:05:39.153]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:39.153]                         if (muffled) 
[18:05:39.153]                           invokeRestart("muffleMessage")
[18:05:39.153]                       }
[18:05:39.153]                       else if (inherits(cond, "warning")) {
[18:05:39.153]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:39.153]                         if (muffled) 
[18:05:39.153]                           invokeRestart("muffleWarning")
[18:05:39.153]                       }
[18:05:39.153]                       else if (inherits(cond, "condition")) {
[18:05:39.153]                         if (!is.null(pattern)) {
[18:05:39.153]                           computeRestarts <- base::computeRestarts
[18:05:39.153]                           grepl <- base::grepl
[18:05:39.153]                           restarts <- computeRestarts(cond)
[18:05:39.153]                           for (restart in restarts) {
[18:05:39.153]                             name <- restart$name
[18:05:39.153]                             if (is.null(name)) 
[18:05:39.153]                               next
[18:05:39.153]                             if (!grepl(pattern, name)) 
[18:05:39.153]                               next
[18:05:39.153]                             invokeRestart(restart)
[18:05:39.153]                             muffled <- TRUE
[18:05:39.153]                             break
[18:05:39.153]                           }
[18:05:39.153]                         }
[18:05:39.153]                       }
[18:05:39.153]                       invisible(muffled)
[18:05:39.153]                     }
[18:05:39.153]                     muffleCondition(cond, pattern = "^muffle")
[18:05:39.153]                   }
[18:05:39.153]                 }
[18:05:39.153]                 else {
[18:05:39.153]                   if (TRUE) {
[18:05:39.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.153]                     {
[18:05:39.153]                       inherits <- base::inherits
[18:05:39.153]                       invokeRestart <- base::invokeRestart
[18:05:39.153]                       is.null <- base::is.null
[18:05:39.153]                       muffled <- FALSE
[18:05:39.153]                       if (inherits(cond, "message")) {
[18:05:39.153]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:39.153]                         if (muffled) 
[18:05:39.153]                           invokeRestart("muffleMessage")
[18:05:39.153]                       }
[18:05:39.153]                       else if (inherits(cond, "warning")) {
[18:05:39.153]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:39.153]                         if (muffled) 
[18:05:39.153]                           invokeRestart("muffleWarning")
[18:05:39.153]                       }
[18:05:39.153]                       else if (inherits(cond, "condition")) {
[18:05:39.153]                         if (!is.null(pattern)) {
[18:05:39.153]                           computeRestarts <- base::computeRestarts
[18:05:39.153]                           grepl <- base::grepl
[18:05:39.153]                           restarts <- computeRestarts(cond)
[18:05:39.153]                           for (restart in restarts) {
[18:05:39.153]                             name <- restart$name
[18:05:39.153]                             if (is.null(name)) 
[18:05:39.153]                               next
[18:05:39.153]                             if (!grepl(pattern, name)) 
[18:05:39.153]                               next
[18:05:39.153]                             invokeRestart(restart)
[18:05:39.153]                             muffled <- TRUE
[18:05:39.153]                             break
[18:05:39.153]                           }
[18:05:39.153]                         }
[18:05:39.153]                       }
[18:05:39.153]                       invisible(muffled)
[18:05:39.153]                     }
[18:05:39.153]                     muffleCondition(cond, pattern = "^muffle")
[18:05:39.153]                   }
[18:05:39.153]                 }
[18:05:39.153]             }
[18:05:39.153]         }))
[18:05:39.153]     }, error = function(ex) {
[18:05:39.153]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:39.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:39.153]                 ...future.rng), started = ...future.startTime, 
[18:05:39.153]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:39.153]             version = "1.8"), class = "FutureResult")
[18:05:39.153]     }, finally = {
[18:05:39.153]         if (!identical(...future.workdir, getwd())) 
[18:05:39.153]             setwd(...future.workdir)
[18:05:39.153]         {
[18:05:39.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:39.153]                 ...future.oldOptions$nwarnings <- NULL
[18:05:39.153]             }
[18:05:39.153]             base::options(...future.oldOptions)
[18:05:39.153]             if (.Platform$OS.type == "windows") {
[18:05:39.153]                 old_names <- names(...future.oldEnvVars)
[18:05:39.153]                 envs <- base::Sys.getenv()
[18:05:39.153]                 names <- names(envs)
[18:05:39.153]                 common <- intersect(names, old_names)
[18:05:39.153]                 added <- setdiff(names, old_names)
[18:05:39.153]                 removed <- setdiff(old_names, names)
[18:05:39.153]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:39.153]                   envs[common]]
[18:05:39.153]                 NAMES <- toupper(changed)
[18:05:39.153]                 args <- list()
[18:05:39.153]                 for (kk in seq_along(NAMES)) {
[18:05:39.153]                   name <- changed[[kk]]
[18:05:39.153]                   NAME <- NAMES[[kk]]
[18:05:39.153]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.153]                     next
[18:05:39.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:39.153]                 }
[18:05:39.153]                 NAMES <- toupper(added)
[18:05:39.153]                 for (kk in seq_along(NAMES)) {
[18:05:39.153]                   name <- added[[kk]]
[18:05:39.153]                   NAME <- NAMES[[kk]]
[18:05:39.153]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.153]                     next
[18:05:39.153]                   args[[name]] <- ""
[18:05:39.153]                 }
[18:05:39.153]                 NAMES <- toupper(removed)
[18:05:39.153]                 for (kk in seq_along(NAMES)) {
[18:05:39.153]                   name <- removed[[kk]]
[18:05:39.153]                   NAME <- NAMES[[kk]]
[18:05:39.153]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.153]                     next
[18:05:39.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:39.153]                 }
[18:05:39.153]                 if (length(args) > 0) 
[18:05:39.153]                   base::do.call(base::Sys.setenv, args = args)
[18:05:39.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:39.153]             }
[18:05:39.153]             else {
[18:05:39.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:39.153]             }
[18:05:39.153]             {
[18:05:39.153]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:39.153]                   0L) {
[18:05:39.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:39.153]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:39.153]                   base::options(opts)
[18:05:39.153]                 }
[18:05:39.153]                 {
[18:05:39.153]                   {
[18:05:39.153]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:39.153]                     NULL
[18:05:39.153]                   }
[18:05:39.153]                   options(future.plan = NULL)
[18:05:39.153]                   if (is.na(NA_character_)) 
[18:05:39.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:39.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:39.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:39.153]                     .init = FALSE)
[18:05:39.153]                 }
[18:05:39.153]             }
[18:05:39.153]         }
[18:05:39.153]     })
[18:05:39.153]     if (TRUE) {
[18:05:39.153]         base::sink(type = "output", split = FALSE)
[18:05:39.153]         if (TRUE) {
[18:05:39.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:39.153]         }
[18:05:39.153]         else {
[18:05:39.153]             ...future.result["stdout"] <- base::list(NULL)
[18:05:39.153]         }
[18:05:39.153]         base::close(...future.stdout)
[18:05:39.153]         ...future.stdout <- NULL
[18:05:39.153]     }
[18:05:39.153]     ...future.result$conditions <- ...future.conditions
[18:05:39.153]     ...future.result$finished <- base::Sys.time()
[18:05:39.153]     ...future.result
[18:05:39.153] }
[18:05:39.159] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[18:05:39.159] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[18:05:39.200] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[18:05:39.201] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[18:05:39.202] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[18:05:39.202] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[18:05:39.204] MultisessionFuture started
[18:05:39.205] - Launch lazy future ... done
[18:05:39.205] run() for ‘MultisessionFuture’ ... done
[18:05:39.206] result() for ClusterFuture ...
[18:05:39.206] receiveMessageFromWorker() for ClusterFuture ...
[18:05:39.206] - Validating connection of MultisessionFuture
[18:05:39.306] - received message: FutureResult
[18:05:39.307] - Received FutureResult
[18:05:39.307] - Erased future from FutureRegistry
[18:05:39.307] result() for ClusterFuture ...
[18:05:39.307] - result already collected: FutureResult
[18:05:39.307] result() for ClusterFuture ... done
[18:05:39.308] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:39.308] result() for ClusterFuture ... done
[18:05:39.308] result() for ClusterFuture ...
[18:05:39.308] - result already collected: FutureResult
[18:05:39.308] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:39.318] getGlobalsAndPackages() ...
[18:05:39.319] Searching for globals...
[18:05:39.321] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:39.321] Searching for globals ... DONE
[18:05:39.322] Resolving globals: FALSE
[18:05:39.323] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:39.323] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:39.324] - globals: [1] ‘data’
[18:05:39.324] - packages: [1] ‘future’
[18:05:39.324] getGlobalsAndPackages() ... DONE
[18:05:39.325] run() for ‘Future’ ...
[18:05:39.325] - state: ‘created’
[18:05:39.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:39.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:39.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:39.350]   - Field: ‘node’
[18:05:39.350]   - Field: ‘label’
[18:05:39.350]   - Field: ‘local’
[18:05:39.350]   - Field: ‘owner’
[18:05:39.351]   - Field: ‘envir’
[18:05:39.351]   - Field: ‘workers’
[18:05:39.351]   - Field: ‘packages’
[18:05:39.351]   - Field: ‘gc’
[18:05:39.351]   - Field: ‘conditions’
[18:05:39.352]   - Field: ‘persistent’
[18:05:39.352]   - Field: ‘expr’
[18:05:39.352]   - Field: ‘uuid’
[18:05:39.352]   - Field: ‘seed’
[18:05:39.352]   - Field: ‘version’
[18:05:39.353]   - Field: ‘result’
[18:05:39.353]   - Field: ‘asynchronous’
[18:05:39.353]   - Field: ‘calls’
[18:05:39.353]   - Field: ‘globals’
[18:05:39.353]   - Field: ‘stdout’
[18:05:39.354]   - Field: ‘earlySignal’
[18:05:39.354]   - Field: ‘lazy’
[18:05:39.354]   - Field: ‘state’
[18:05:39.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:39.354] - Launch lazy future ...
[18:05:39.355] Packages needed by the future expression (n = 1): ‘future’
[18:05:39.355] Packages needed by future strategies (n = 1): ‘future’
[18:05:39.356] {
[18:05:39.356]     {
[18:05:39.356]         {
[18:05:39.356]             ...future.startTime <- base::Sys.time()
[18:05:39.356]             {
[18:05:39.356]                 {
[18:05:39.356]                   {
[18:05:39.356]                     {
[18:05:39.356]                       {
[18:05:39.356]                         base::local({
[18:05:39.356]                           has_future <- base::requireNamespace("future", 
[18:05:39.356]                             quietly = TRUE)
[18:05:39.356]                           if (has_future) {
[18:05:39.356]                             ns <- base::getNamespace("future")
[18:05:39.356]                             version <- ns[[".package"]][["version"]]
[18:05:39.356]                             if (is.null(version)) 
[18:05:39.356]                               version <- utils::packageVersion("future")
[18:05:39.356]                           }
[18:05:39.356]                           else {
[18:05:39.356]                             version <- NULL
[18:05:39.356]                           }
[18:05:39.356]                           if (!has_future || version < "1.8.0") {
[18:05:39.356]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:39.356]                               "", base::R.version$version.string), 
[18:05:39.356]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:39.356]                                 base::R.version$platform, 8 * 
[18:05:39.356]                                   base::.Machine$sizeof.pointer), 
[18:05:39.356]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:39.356]                                 "release", "version")], collapse = " "), 
[18:05:39.356]                               hostname = base::Sys.info()[["nodename"]])
[18:05:39.356]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:39.356]                               info)
[18:05:39.356]                             info <- base::paste(info, collapse = "; ")
[18:05:39.356]                             if (!has_future) {
[18:05:39.356]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:39.356]                                 info)
[18:05:39.356]                             }
[18:05:39.356]                             else {
[18:05:39.356]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:39.356]                                 info, version)
[18:05:39.356]                             }
[18:05:39.356]                             base::stop(msg)
[18:05:39.356]                           }
[18:05:39.356]                         })
[18:05:39.356]                       }
[18:05:39.356]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:39.356]                       base::options(mc.cores = 1L)
[18:05:39.356]                     }
[18:05:39.356]                     base::local({
[18:05:39.356]                       for (pkg in "future") {
[18:05:39.356]                         base::loadNamespace(pkg)
[18:05:39.356]                         base::library(pkg, character.only = TRUE)
[18:05:39.356]                       }
[18:05:39.356]                     })
[18:05:39.356]                   }
[18:05:39.356]                   ...future.strategy.old <- future::plan("list")
[18:05:39.356]                   options(future.plan = NULL)
[18:05:39.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:39.356]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[18:05:39.356]                     envir = parent.frame()) 
[18:05:39.356]                   {
[18:05:39.356]                     default_workers <- missing(workers)
[18:05:39.356]                     if (is.function(workers)) 
[18:05:39.356]                       workers <- workers()
[18:05:39.356]                     workers <- structure(as.integer(workers), 
[18:05:39.356]                       class = class(workers))
[18:05:39.356]                     stop_if_not(is.finite(workers), workers >= 
[18:05:39.356]                       1L)
[18:05:39.356]                     if ((workers == 1L && !inherits(workers, 
[18:05:39.356]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:05:39.356]                       if (default_workers) 
[18:05:39.356]                         supportsMulticore(warn = TRUE)
[18:05:39.356]                       return(sequential(..., envir = envir))
[18:05:39.356]                     }
[18:05:39.356]                     oopts <- options(mc.cores = workers)
[18:05:39.356]                     on.exit(options(oopts))
[18:05:39.356]                     future <- MulticoreFuture(..., workers = workers, 
[18:05:39.356]                       envir = envir)
[18:05:39.356]                     if (!future$lazy) 
[18:05:39.356]                       future <- run(future)
[18:05:39.356]                     invisible(future)
[18:05:39.356]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:39.356]                 }
[18:05:39.356]                 ...future.workdir <- getwd()
[18:05:39.356]             }
[18:05:39.356]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:39.356]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:39.356]         }
[18:05:39.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:39.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:39.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:39.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:39.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:39.356]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:39.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:39.356]             base::names(...future.oldOptions))
[18:05:39.356]     }
[18:05:39.356]     if (FALSE) {
[18:05:39.356]     }
[18:05:39.356]     else {
[18:05:39.356]         if (TRUE) {
[18:05:39.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:39.356]                 open = "w")
[18:05:39.356]         }
[18:05:39.356]         else {
[18:05:39.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:39.356]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:39.356]         }
[18:05:39.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:39.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:39.356]             base::sink(type = "output", split = FALSE)
[18:05:39.356]             base::close(...future.stdout)
[18:05:39.356]         }, add = TRUE)
[18:05:39.356]     }
[18:05:39.356]     ...future.frame <- base::sys.nframe()
[18:05:39.356]     ...future.conditions <- base::list()
[18:05:39.356]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:39.356]     if (FALSE) {
[18:05:39.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:39.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:39.356]     }
[18:05:39.356]     ...future.result <- base::tryCatch({
[18:05:39.356]         base::withCallingHandlers({
[18:05:39.356]             ...future.value <- base::withVisible(base::local({
[18:05:39.356]                 ...future.makeSendCondition <- base::local({
[18:05:39.356]                   sendCondition <- NULL
[18:05:39.356]                   function(frame = 1L) {
[18:05:39.356]                     if (is.function(sendCondition)) 
[18:05:39.356]                       return(sendCondition)
[18:05:39.356]                     ns <- getNamespace("parallel")
[18:05:39.356]                     if (exists("sendData", mode = "function", 
[18:05:39.356]                       envir = ns)) {
[18:05:39.356]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:39.356]                         envir = ns)
[18:05:39.356]                       envir <- sys.frame(frame)
[18:05:39.356]                       master <- NULL
[18:05:39.356]                       while (!identical(envir, .GlobalEnv) && 
[18:05:39.356]                         !identical(envir, emptyenv())) {
[18:05:39.356]                         if (exists("master", mode = "list", envir = envir, 
[18:05:39.356]                           inherits = FALSE)) {
[18:05:39.356]                           master <- get("master", mode = "list", 
[18:05:39.356]                             envir = envir, inherits = FALSE)
[18:05:39.356]                           if (inherits(master, c("SOCKnode", 
[18:05:39.356]                             "SOCK0node"))) {
[18:05:39.356]                             sendCondition <<- function(cond) {
[18:05:39.356]                               data <- list(type = "VALUE", value = cond, 
[18:05:39.356]                                 success = TRUE)
[18:05:39.356]                               parallel_sendData(master, data)
[18:05:39.356]                             }
[18:05:39.356]                             return(sendCondition)
[18:05:39.356]                           }
[18:05:39.356]                         }
[18:05:39.356]                         frame <- frame + 1L
[18:05:39.356]                         envir <- sys.frame(frame)
[18:05:39.356]                       }
[18:05:39.356]                     }
[18:05:39.356]                     sendCondition <<- function(cond) NULL
[18:05:39.356]                   }
[18:05:39.356]                 })
[18:05:39.356]                 withCallingHandlers({
[18:05:39.356]                   {
[18:05:39.356]                     value(future(subset(data, a == 2)))
[18:05:39.356]                   }
[18:05:39.356]                 }, immediateCondition = function(cond) {
[18:05:39.356]                   sendCondition <- ...future.makeSendCondition()
[18:05:39.356]                   sendCondition(cond)
[18:05:39.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.356]                   {
[18:05:39.356]                     inherits <- base::inherits
[18:05:39.356]                     invokeRestart <- base::invokeRestart
[18:05:39.356]                     is.null <- base::is.null
[18:05:39.356]                     muffled <- FALSE
[18:05:39.356]                     if (inherits(cond, "message")) {
[18:05:39.356]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:39.356]                       if (muffled) 
[18:05:39.356]                         invokeRestart("muffleMessage")
[18:05:39.356]                     }
[18:05:39.356]                     else if (inherits(cond, "warning")) {
[18:05:39.356]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:39.356]                       if (muffled) 
[18:05:39.356]                         invokeRestart("muffleWarning")
[18:05:39.356]                     }
[18:05:39.356]                     else if (inherits(cond, "condition")) {
[18:05:39.356]                       if (!is.null(pattern)) {
[18:05:39.356]                         computeRestarts <- base::computeRestarts
[18:05:39.356]                         grepl <- base::grepl
[18:05:39.356]                         restarts <- computeRestarts(cond)
[18:05:39.356]                         for (restart in restarts) {
[18:05:39.356]                           name <- restart$name
[18:05:39.356]                           if (is.null(name)) 
[18:05:39.356]                             next
[18:05:39.356]                           if (!grepl(pattern, name)) 
[18:05:39.356]                             next
[18:05:39.356]                           invokeRestart(restart)
[18:05:39.356]                           muffled <- TRUE
[18:05:39.356]                           break
[18:05:39.356]                         }
[18:05:39.356]                       }
[18:05:39.356]                     }
[18:05:39.356]                     invisible(muffled)
[18:05:39.356]                   }
[18:05:39.356]                   muffleCondition(cond)
[18:05:39.356]                 })
[18:05:39.356]             }))
[18:05:39.356]             future::FutureResult(value = ...future.value$value, 
[18:05:39.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:39.356]                   ...future.rng), globalenv = if (FALSE) 
[18:05:39.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:39.356]                     ...future.globalenv.names))
[18:05:39.356]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:39.356]         }, condition = base::local({
[18:05:39.356]             c <- base::c
[18:05:39.356]             inherits <- base::inherits
[18:05:39.356]             invokeRestart <- base::invokeRestart
[18:05:39.356]             length <- base::length
[18:05:39.356]             list <- base::list
[18:05:39.356]             seq.int <- base::seq.int
[18:05:39.356]             signalCondition <- base::signalCondition
[18:05:39.356]             sys.calls <- base::sys.calls
[18:05:39.356]             `[[` <- base::`[[`
[18:05:39.356]             `+` <- base::`+`
[18:05:39.356]             `<<-` <- base::`<<-`
[18:05:39.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:39.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:39.356]                   3L)]
[18:05:39.356]             }
[18:05:39.356]             function(cond) {
[18:05:39.356]                 is_error <- inherits(cond, "error")
[18:05:39.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:39.356]                   NULL)
[18:05:39.356]                 if (is_error) {
[18:05:39.356]                   sessionInformation <- function() {
[18:05:39.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:39.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:39.356]                       search = base::search(), system = base::Sys.info())
[18:05:39.356]                   }
[18:05:39.356]                   ...future.conditions[[length(...future.conditions) + 
[18:05:39.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:39.356]                     cond$call), session = sessionInformation(), 
[18:05:39.356]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:39.356]                   signalCondition(cond)
[18:05:39.356]                 }
[18:05:39.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:39.356]                 "immediateCondition"))) {
[18:05:39.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:39.356]                   ...future.conditions[[length(...future.conditions) + 
[18:05:39.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:39.356]                   if (TRUE && !signal) {
[18:05:39.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.356]                     {
[18:05:39.356]                       inherits <- base::inherits
[18:05:39.356]                       invokeRestart <- base::invokeRestart
[18:05:39.356]                       is.null <- base::is.null
[18:05:39.356]                       muffled <- FALSE
[18:05:39.356]                       if (inherits(cond, "message")) {
[18:05:39.356]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:39.356]                         if (muffled) 
[18:05:39.356]                           invokeRestart("muffleMessage")
[18:05:39.356]                       }
[18:05:39.356]                       else if (inherits(cond, "warning")) {
[18:05:39.356]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:39.356]                         if (muffled) 
[18:05:39.356]                           invokeRestart("muffleWarning")
[18:05:39.356]                       }
[18:05:39.356]                       else if (inherits(cond, "condition")) {
[18:05:39.356]                         if (!is.null(pattern)) {
[18:05:39.356]                           computeRestarts <- base::computeRestarts
[18:05:39.356]                           grepl <- base::grepl
[18:05:39.356]                           restarts <- computeRestarts(cond)
[18:05:39.356]                           for (restart in restarts) {
[18:05:39.356]                             name <- restart$name
[18:05:39.356]                             if (is.null(name)) 
[18:05:39.356]                               next
[18:05:39.356]                             if (!grepl(pattern, name)) 
[18:05:39.356]                               next
[18:05:39.356]                             invokeRestart(restart)
[18:05:39.356]                             muffled <- TRUE
[18:05:39.356]                             break
[18:05:39.356]                           }
[18:05:39.356]                         }
[18:05:39.356]                       }
[18:05:39.356]                       invisible(muffled)
[18:05:39.356]                     }
[18:05:39.356]                     muffleCondition(cond, pattern = "^muffle")
[18:05:39.356]                   }
[18:05:39.356]                 }
[18:05:39.356]                 else {
[18:05:39.356]                   if (TRUE) {
[18:05:39.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.356]                     {
[18:05:39.356]                       inherits <- base::inherits
[18:05:39.356]                       invokeRestart <- base::invokeRestart
[18:05:39.356]                       is.null <- base::is.null
[18:05:39.356]                       muffled <- FALSE
[18:05:39.356]                       if (inherits(cond, "message")) {
[18:05:39.356]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:39.356]                         if (muffled) 
[18:05:39.356]                           invokeRestart("muffleMessage")
[18:05:39.356]                       }
[18:05:39.356]                       else if (inherits(cond, "warning")) {
[18:05:39.356]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:39.356]                         if (muffled) 
[18:05:39.356]                           invokeRestart("muffleWarning")
[18:05:39.356]                       }
[18:05:39.356]                       else if (inherits(cond, "condition")) {
[18:05:39.356]                         if (!is.null(pattern)) {
[18:05:39.356]                           computeRestarts <- base::computeRestarts
[18:05:39.356]                           grepl <- base::grepl
[18:05:39.356]                           restarts <- computeRestarts(cond)
[18:05:39.356]                           for (restart in restarts) {
[18:05:39.356]                             name <- restart$name
[18:05:39.356]                             if (is.null(name)) 
[18:05:39.356]                               next
[18:05:39.356]                             if (!grepl(pattern, name)) 
[18:05:39.356]                               next
[18:05:39.356]                             invokeRestart(restart)
[18:05:39.356]                             muffled <- TRUE
[18:05:39.356]                             break
[18:05:39.356]                           }
[18:05:39.356]                         }
[18:05:39.356]                       }
[18:05:39.356]                       invisible(muffled)
[18:05:39.356]                     }
[18:05:39.356]                     muffleCondition(cond, pattern = "^muffle")
[18:05:39.356]                   }
[18:05:39.356]                 }
[18:05:39.356]             }
[18:05:39.356]         }))
[18:05:39.356]     }, error = function(ex) {
[18:05:39.356]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:39.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:39.356]                 ...future.rng), started = ...future.startTime, 
[18:05:39.356]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:39.356]             version = "1.8"), class = "FutureResult")
[18:05:39.356]     }, finally = {
[18:05:39.356]         if (!identical(...future.workdir, getwd())) 
[18:05:39.356]             setwd(...future.workdir)
[18:05:39.356]         {
[18:05:39.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:39.356]                 ...future.oldOptions$nwarnings <- NULL
[18:05:39.356]             }
[18:05:39.356]             base::options(...future.oldOptions)
[18:05:39.356]             if (.Platform$OS.type == "windows") {
[18:05:39.356]                 old_names <- names(...future.oldEnvVars)
[18:05:39.356]                 envs <- base::Sys.getenv()
[18:05:39.356]                 names <- names(envs)
[18:05:39.356]                 common <- intersect(names, old_names)
[18:05:39.356]                 added <- setdiff(names, old_names)
[18:05:39.356]                 removed <- setdiff(old_names, names)
[18:05:39.356]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:39.356]                   envs[common]]
[18:05:39.356]                 NAMES <- toupper(changed)
[18:05:39.356]                 args <- list()
[18:05:39.356]                 for (kk in seq_along(NAMES)) {
[18:05:39.356]                   name <- changed[[kk]]
[18:05:39.356]                   NAME <- NAMES[[kk]]
[18:05:39.356]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.356]                     next
[18:05:39.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:39.356]                 }
[18:05:39.356]                 NAMES <- toupper(added)
[18:05:39.356]                 for (kk in seq_along(NAMES)) {
[18:05:39.356]                   name <- added[[kk]]
[18:05:39.356]                   NAME <- NAMES[[kk]]
[18:05:39.356]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.356]                     next
[18:05:39.356]                   args[[name]] <- ""
[18:05:39.356]                 }
[18:05:39.356]                 NAMES <- toupper(removed)
[18:05:39.356]                 for (kk in seq_along(NAMES)) {
[18:05:39.356]                   name <- removed[[kk]]
[18:05:39.356]                   NAME <- NAMES[[kk]]
[18:05:39.356]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.356]                     next
[18:05:39.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:39.356]                 }
[18:05:39.356]                 if (length(args) > 0) 
[18:05:39.356]                   base::do.call(base::Sys.setenv, args = args)
[18:05:39.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:39.356]             }
[18:05:39.356]             else {
[18:05:39.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:39.356]             }
[18:05:39.356]             {
[18:05:39.356]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:39.356]                   0L) {
[18:05:39.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:39.356]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:39.356]                   base::options(opts)
[18:05:39.356]                 }
[18:05:39.356]                 {
[18:05:39.356]                   {
[18:05:39.356]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:39.356]                     NULL
[18:05:39.356]                   }
[18:05:39.356]                   options(future.plan = NULL)
[18:05:39.356]                   if (is.na(NA_character_)) 
[18:05:39.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:39.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:39.356]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:39.356]                     .init = FALSE)
[18:05:39.356]                 }
[18:05:39.356]             }
[18:05:39.356]         }
[18:05:39.356]     })
[18:05:39.356]     if (TRUE) {
[18:05:39.356]         base::sink(type = "output", split = FALSE)
[18:05:39.356]         if (TRUE) {
[18:05:39.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:39.356]         }
[18:05:39.356]         else {
[18:05:39.356]             ...future.result["stdout"] <- base::list(NULL)
[18:05:39.356]         }
[18:05:39.356]         base::close(...future.stdout)
[18:05:39.356]         ...future.stdout <- NULL
[18:05:39.356]     }
[18:05:39.356]     ...future.result$conditions <- ...future.conditions
[18:05:39.356]     ...future.result$finished <- base::Sys.time()
[18:05:39.356]     ...future.result
[18:05:39.356] }
[18:05:39.361] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[18:05:39.362] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[18:05:39.363] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[18:05:39.363] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[18:05:39.364] MultisessionFuture started
[18:05:39.364] - Launch lazy future ... done
[18:05:39.364] run() for ‘MultisessionFuture’ ... done
[18:05:39.365] result() for ClusterFuture ...
[18:05:39.365] receiveMessageFromWorker() for ClusterFuture ...
[18:05:39.365] - Validating connection of MultisessionFuture
[18:05:39.433] - received message: FutureResult
[18:05:39.433] - Received FutureResult
[18:05:39.434] - Erased future from FutureRegistry
[18:05:39.434] result() for ClusterFuture ...
[18:05:39.434] - result already collected: FutureResult
[18:05:39.434] result() for ClusterFuture ... done
[18:05:39.434] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:39.434] result() for ClusterFuture ... done
[18:05:39.435] result() for ClusterFuture ...
[18:05:39.435] - result already collected: FutureResult
[18:05:39.435] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[18:05:39.436] plan(): Setting new future strategy stack:
[18:05:39.436] List of future strategies:
[18:05:39.436] 1. multisession:
[18:05:39.436]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:39.436]    - tweaked: FALSE
[18:05:39.436]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:39.436] 2. multisession:
[18:05:39.436]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:39.436]    - tweaked: FALSE
[18:05:39.436]    - call: plan(list(a = strategy1, b = strategy2))
[18:05:39.437] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:05:39.438] multisession:
[18:05:39.438] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:05:39.438] - tweaked: FALSE
[18:05:39.438] - call: plan(list(a = strategy1, b = strategy2))
[18:05:39.450] getGlobalsAndPackages() ...
[18:05:39.450] Not searching for globals
[18:05:39.451] - globals: [0] <none>
[18:05:39.451] getGlobalsAndPackages() ... DONE
[18:05:39.452] [local output] makeClusterPSOCK() ...
[18:05:39.457] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:05:39.459] [local output] Base port: 11314
[18:05:39.459] [local output] Getting setup options for 2 cluster nodes ...
[18:05:39.459] [local output]  - Node 1 of 2 ...
[18:05:39.460] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:39.461] [local output] Rscript port: 11314

[18:05:39.462] [local output]  - Node 2 of 2 ...
[18:05:39.462] [local output] localMachine=TRUE => revtunnel=FALSE

[18:05:39.464] [local output] Rscript port: 11314

[18:05:39.464] [local output] Getting setup options for 2 cluster nodes ... done
[18:05:39.465] [local output]  - Parallel setup requested for some PSOCK nodes
[18:05:39.465] [local output] Setting up PSOCK nodes in parallel
[18:05:39.465] List of 36
[18:05:39.465]  $ worker          : chr "localhost"
[18:05:39.465]   ..- attr(*, "localhost")= logi TRUE
[18:05:39.465]  $ master          : chr "localhost"
[18:05:39.465]  $ port            : int 11314
[18:05:39.465]  $ connectTimeout  : num 120
[18:05:39.465]  $ timeout         : num 2592000
[18:05:39.465]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:05:39.465]  $ homogeneous     : logi TRUE
[18:05:39.465]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:05:39.465]  $ rscript_envs    : NULL
[18:05:39.465]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:39.465]  $ rscript_startup : NULL
[18:05:39.465]  $ rscript_sh      : chr "sh"
[18:05:39.465]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:39.465]  $ methods         : logi TRUE
[18:05:39.465]  $ socketOptions   : chr "no-delay"
[18:05:39.465]  $ useXDR          : logi FALSE
[18:05:39.465]  $ outfile         : chr "/dev/null"
[18:05:39.465]  $ renice          : int NA
[18:05:39.465]  $ rshcmd          : NULL
[18:05:39.465]  $ user            : chr(0) 
[18:05:39.465]  $ revtunnel       : logi FALSE
[18:05:39.465]  $ rshlogfile      : NULL
[18:05:39.465]  $ rshopts         : chr(0) 
[18:05:39.465]  $ rank            : int 1
[18:05:39.465]  $ manual          : logi FALSE
[18:05:39.465]  $ dryrun          : logi FALSE
[18:05:39.465]  $ quiet           : logi FALSE
[18:05:39.465]  $ setup_strategy  : chr "parallel"
[18:05:39.465]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:39.465]  $ pidfile         : chr "/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e4641d4242.pid"
[18:05:39.465]  $ rshcmd_label    : NULL
[18:05:39.465]  $ rsh_call        : NULL
[18:05:39.465]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:05:39.465]  $ localMachine    : logi TRUE
[18:05:39.465]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:05:39.465]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:05:39.465]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:05:39.465]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:05:39.465]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:05:39.465]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:05:39.465]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:05:39.465]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:05:39.465]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:05:39.465]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:05:39.465]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:05:39.465]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:05:39.465]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:05:39.465]  $ arguments       :List of 28
[18:05:39.465]   ..$ worker          : chr "localhost"
[18:05:39.465]   ..$ master          : NULL
[18:05:39.465]   ..$ port            : int 11314
[18:05:39.465]   ..$ connectTimeout  : num 120
[18:05:39.465]   ..$ timeout         : num 2592000
[18:05:39.465]   ..$ rscript         : NULL
[18:05:39.465]   ..$ homogeneous     : NULL
[18:05:39.465]   ..$ rscript_args    : NULL
[18:05:39.465]   ..$ rscript_envs    : NULL
[18:05:39.465]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:05:39.465]   ..$ rscript_startup : NULL
[18:05:39.465]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:05:39.465]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:05:39.465]   ..$ methods         : logi TRUE
[18:05:39.465]   ..$ socketOptions   : chr "no-delay"
[18:05:39.465]   ..$ useXDR          : logi FALSE
[18:05:39.465]   ..$ outfile         : chr "/dev/null"
[18:05:39.465]   ..$ renice          : int NA
[18:05:39.465]   ..$ rshcmd          : NULL
[18:05:39.465]   ..$ user            : NULL
[18:05:39.465]   ..$ revtunnel       : logi NA
[18:05:39.465]   ..$ rshlogfile      : NULL
[18:05:39.465]   ..$ rshopts         : NULL
[18:05:39.465]   ..$ rank            : int 1
[18:05:39.465]   ..$ manual          : logi FALSE
[18:05:39.465]   ..$ dryrun          : logi FALSE
[18:05:39.465]   ..$ quiet           : logi FALSE
[18:05:39.465]   ..$ setup_strategy  : chr "parallel"
[18:05:39.465]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:05:39.507] [local output] System call to launch all workers:
[18:05:39.507] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp6WFnRS/worker.rank=1.parallelly.parent=327908.500e4641d4242.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11314 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:05:39.508] [local output] Starting PSOCK main server
[18:05:39.509] [local output] Workers launched
[18:05:39.510] [local output] Waiting for workers to connect back
[18:05:39.510]  - [local output] 0 workers out of 2 ready
[18:05:39.934]  - [local output] 0 workers out of 2 ready
[18:05:39.936]  - [local output] 1 workers out of 2 ready
[18:05:39.972]  - [local output] 1 workers out of 2 ready
[18:05:39.973]  - [local output] 2 workers out of 2 ready
[18:05:39.973] [local output] Launching of workers completed
[18:05:39.974] [local output] Collecting session information from workers
[18:05:39.975] [local output]  - Worker #1 of 2
[18:05:39.976] [local output]  - Worker #2 of 2
[18:05:39.976] [local output] makeClusterPSOCK() ... done
[18:05:39.994] Packages needed by the future expression (n = 0): <none>
[18:05:39.994] Packages needed by future strategies (n = 1): ‘future’
[18:05:39.995] {
[18:05:39.995]     {
[18:05:39.995]         {
[18:05:39.995]             ...future.startTime <- base::Sys.time()
[18:05:39.995]             {
[18:05:39.995]                 {
[18:05:39.995]                   {
[18:05:39.995]                     {
[18:05:39.995]                       {
[18:05:39.995]                         base::local({
[18:05:39.995]                           has_future <- base::requireNamespace("future", 
[18:05:39.995]                             quietly = TRUE)
[18:05:39.995]                           if (has_future) {
[18:05:39.995]                             ns <- base::getNamespace("future")
[18:05:39.995]                             version <- ns[[".package"]][["version"]]
[18:05:39.995]                             if (is.null(version)) 
[18:05:39.995]                               version <- utils::packageVersion("future")
[18:05:39.995]                           }
[18:05:39.995]                           else {
[18:05:39.995]                             version <- NULL
[18:05:39.995]                           }
[18:05:39.995]                           if (!has_future || version < "1.8.0") {
[18:05:39.995]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:39.995]                               "", base::R.version$version.string), 
[18:05:39.995]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:39.995]                                 base::R.version$platform, 8 * 
[18:05:39.995]                                   base::.Machine$sizeof.pointer), 
[18:05:39.995]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:39.995]                                 "release", "version")], collapse = " "), 
[18:05:39.995]                               hostname = base::Sys.info()[["nodename"]])
[18:05:39.995]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:39.995]                               info)
[18:05:39.995]                             info <- base::paste(info, collapse = "; ")
[18:05:39.995]                             if (!has_future) {
[18:05:39.995]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:39.995]                                 info)
[18:05:39.995]                             }
[18:05:39.995]                             else {
[18:05:39.995]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:39.995]                                 info, version)
[18:05:39.995]                             }
[18:05:39.995]                             base::stop(msg)
[18:05:39.995]                           }
[18:05:39.995]                         })
[18:05:39.995]                       }
[18:05:39.995]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:39.995]                       base::options(mc.cores = 1L)
[18:05:39.995]                     }
[18:05:39.995]                     base::local({
[18:05:39.995]                       for (pkg in "future") {
[18:05:39.995]                         base::loadNamespace(pkg)
[18:05:39.995]                         base::library(pkg, character.only = TRUE)
[18:05:39.995]                       }
[18:05:39.995]                     })
[18:05:39.995]                   }
[18:05:39.995]                   ...future.strategy.old <- future::plan("list")
[18:05:39.995]                   options(future.plan = NULL)
[18:05:39.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:39.995]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:39.995]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:39.995]                     envir = parent.frame()) 
[18:05:39.995]                   {
[18:05:39.995]                     if (is.function(workers)) 
[18:05:39.995]                       workers <- workers()
[18:05:39.995]                     workers <- structure(as.integer(workers), 
[18:05:39.995]                       class = class(workers))
[18:05:39.995]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:39.995]                       workers >= 1)
[18:05:39.995]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:39.995]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:39.995]                     }
[18:05:39.995]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:39.995]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:39.995]                       envir = envir)
[18:05:39.995]                     if (!future$lazy) 
[18:05:39.995]                       future <- run(future)
[18:05:39.995]                     invisible(future)
[18:05:39.995]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:39.995]                 }
[18:05:39.995]                 ...future.workdir <- getwd()
[18:05:39.995]             }
[18:05:39.995]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:39.995]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:39.995]         }
[18:05:39.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:39.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:39.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:39.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:39.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:39.995]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:39.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:39.995]             base::names(...future.oldOptions))
[18:05:39.995]     }
[18:05:39.995]     if (FALSE) {
[18:05:39.995]     }
[18:05:39.995]     else {
[18:05:39.995]         if (TRUE) {
[18:05:39.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:39.995]                 open = "w")
[18:05:39.995]         }
[18:05:39.995]         else {
[18:05:39.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:39.995]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:39.995]         }
[18:05:39.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:39.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:39.995]             base::sink(type = "output", split = FALSE)
[18:05:39.995]             base::close(...future.stdout)
[18:05:39.995]         }, add = TRUE)
[18:05:39.995]     }
[18:05:39.995]     ...future.frame <- base::sys.nframe()
[18:05:39.995]     ...future.conditions <- base::list()
[18:05:39.995]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:39.995]     if (FALSE) {
[18:05:39.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:39.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:39.995]     }
[18:05:39.995]     ...future.result <- base::tryCatch({
[18:05:39.995]         base::withCallingHandlers({
[18:05:39.995]             ...future.value <- base::withVisible(base::local({
[18:05:39.995]                 ...future.makeSendCondition <- base::local({
[18:05:39.995]                   sendCondition <- NULL
[18:05:39.995]                   function(frame = 1L) {
[18:05:39.995]                     if (is.function(sendCondition)) 
[18:05:39.995]                       return(sendCondition)
[18:05:39.995]                     ns <- getNamespace("parallel")
[18:05:39.995]                     if (exists("sendData", mode = "function", 
[18:05:39.995]                       envir = ns)) {
[18:05:39.995]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:39.995]                         envir = ns)
[18:05:39.995]                       envir <- sys.frame(frame)
[18:05:39.995]                       master <- NULL
[18:05:39.995]                       while (!identical(envir, .GlobalEnv) && 
[18:05:39.995]                         !identical(envir, emptyenv())) {
[18:05:39.995]                         if (exists("master", mode = "list", envir = envir, 
[18:05:39.995]                           inherits = FALSE)) {
[18:05:39.995]                           master <- get("master", mode = "list", 
[18:05:39.995]                             envir = envir, inherits = FALSE)
[18:05:39.995]                           if (inherits(master, c("SOCKnode", 
[18:05:39.995]                             "SOCK0node"))) {
[18:05:39.995]                             sendCondition <<- function(cond) {
[18:05:39.995]                               data <- list(type = "VALUE", value = cond, 
[18:05:39.995]                                 success = TRUE)
[18:05:39.995]                               parallel_sendData(master, data)
[18:05:39.995]                             }
[18:05:39.995]                             return(sendCondition)
[18:05:39.995]                           }
[18:05:39.995]                         }
[18:05:39.995]                         frame <- frame + 1L
[18:05:39.995]                         envir <- sys.frame(frame)
[18:05:39.995]                       }
[18:05:39.995]                     }
[18:05:39.995]                     sendCondition <<- function(cond) NULL
[18:05:39.995]                   }
[18:05:39.995]                 })
[18:05:39.995]                 withCallingHandlers({
[18:05:39.995]                   NA
[18:05:39.995]                 }, immediateCondition = function(cond) {
[18:05:39.995]                   sendCondition <- ...future.makeSendCondition()
[18:05:39.995]                   sendCondition(cond)
[18:05:39.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.995]                   {
[18:05:39.995]                     inherits <- base::inherits
[18:05:39.995]                     invokeRestart <- base::invokeRestart
[18:05:39.995]                     is.null <- base::is.null
[18:05:39.995]                     muffled <- FALSE
[18:05:39.995]                     if (inherits(cond, "message")) {
[18:05:39.995]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:39.995]                       if (muffled) 
[18:05:39.995]                         invokeRestart("muffleMessage")
[18:05:39.995]                     }
[18:05:39.995]                     else if (inherits(cond, "warning")) {
[18:05:39.995]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:39.995]                       if (muffled) 
[18:05:39.995]                         invokeRestart("muffleWarning")
[18:05:39.995]                     }
[18:05:39.995]                     else if (inherits(cond, "condition")) {
[18:05:39.995]                       if (!is.null(pattern)) {
[18:05:39.995]                         computeRestarts <- base::computeRestarts
[18:05:39.995]                         grepl <- base::grepl
[18:05:39.995]                         restarts <- computeRestarts(cond)
[18:05:39.995]                         for (restart in restarts) {
[18:05:39.995]                           name <- restart$name
[18:05:39.995]                           if (is.null(name)) 
[18:05:39.995]                             next
[18:05:39.995]                           if (!grepl(pattern, name)) 
[18:05:39.995]                             next
[18:05:39.995]                           invokeRestart(restart)
[18:05:39.995]                           muffled <- TRUE
[18:05:39.995]                           break
[18:05:39.995]                         }
[18:05:39.995]                       }
[18:05:39.995]                     }
[18:05:39.995]                     invisible(muffled)
[18:05:39.995]                   }
[18:05:39.995]                   muffleCondition(cond)
[18:05:39.995]                 })
[18:05:39.995]             }))
[18:05:39.995]             future::FutureResult(value = ...future.value$value, 
[18:05:39.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:39.995]                   ...future.rng), globalenv = if (FALSE) 
[18:05:39.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:39.995]                     ...future.globalenv.names))
[18:05:39.995]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:39.995]         }, condition = base::local({
[18:05:39.995]             c <- base::c
[18:05:39.995]             inherits <- base::inherits
[18:05:39.995]             invokeRestart <- base::invokeRestart
[18:05:39.995]             length <- base::length
[18:05:39.995]             list <- base::list
[18:05:39.995]             seq.int <- base::seq.int
[18:05:39.995]             signalCondition <- base::signalCondition
[18:05:39.995]             sys.calls <- base::sys.calls
[18:05:39.995]             `[[` <- base::`[[`
[18:05:39.995]             `+` <- base::`+`
[18:05:39.995]             `<<-` <- base::`<<-`
[18:05:39.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:39.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:39.995]                   3L)]
[18:05:39.995]             }
[18:05:39.995]             function(cond) {
[18:05:39.995]                 is_error <- inherits(cond, "error")
[18:05:39.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:39.995]                   NULL)
[18:05:39.995]                 if (is_error) {
[18:05:39.995]                   sessionInformation <- function() {
[18:05:39.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:39.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:39.995]                       search = base::search(), system = base::Sys.info())
[18:05:39.995]                   }
[18:05:39.995]                   ...future.conditions[[length(...future.conditions) + 
[18:05:39.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:39.995]                     cond$call), session = sessionInformation(), 
[18:05:39.995]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:39.995]                   signalCondition(cond)
[18:05:39.995]                 }
[18:05:39.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:39.995]                 "immediateCondition"))) {
[18:05:39.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:39.995]                   ...future.conditions[[length(...future.conditions) + 
[18:05:39.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:39.995]                   if (TRUE && !signal) {
[18:05:39.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.995]                     {
[18:05:39.995]                       inherits <- base::inherits
[18:05:39.995]                       invokeRestart <- base::invokeRestart
[18:05:39.995]                       is.null <- base::is.null
[18:05:39.995]                       muffled <- FALSE
[18:05:39.995]                       if (inherits(cond, "message")) {
[18:05:39.995]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:39.995]                         if (muffled) 
[18:05:39.995]                           invokeRestart("muffleMessage")
[18:05:39.995]                       }
[18:05:39.995]                       else if (inherits(cond, "warning")) {
[18:05:39.995]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:39.995]                         if (muffled) 
[18:05:39.995]                           invokeRestart("muffleWarning")
[18:05:39.995]                       }
[18:05:39.995]                       else if (inherits(cond, "condition")) {
[18:05:39.995]                         if (!is.null(pattern)) {
[18:05:39.995]                           computeRestarts <- base::computeRestarts
[18:05:39.995]                           grepl <- base::grepl
[18:05:39.995]                           restarts <- computeRestarts(cond)
[18:05:39.995]                           for (restart in restarts) {
[18:05:39.995]                             name <- restart$name
[18:05:39.995]                             if (is.null(name)) 
[18:05:39.995]                               next
[18:05:39.995]                             if (!grepl(pattern, name)) 
[18:05:39.995]                               next
[18:05:39.995]                             invokeRestart(restart)
[18:05:39.995]                             muffled <- TRUE
[18:05:39.995]                             break
[18:05:39.995]                           }
[18:05:39.995]                         }
[18:05:39.995]                       }
[18:05:39.995]                       invisible(muffled)
[18:05:39.995]                     }
[18:05:39.995]                     muffleCondition(cond, pattern = "^muffle")
[18:05:39.995]                   }
[18:05:39.995]                 }
[18:05:39.995]                 else {
[18:05:39.995]                   if (TRUE) {
[18:05:39.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:39.995]                     {
[18:05:39.995]                       inherits <- base::inherits
[18:05:39.995]                       invokeRestart <- base::invokeRestart
[18:05:39.995]                       is.null <- base::is.null
[18:05:39.995]                       muffled <- FALSE
[18:05:39.995]                       if (inherits(cond, "message")) {
[18:05:39.995]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:39.995]                         if (muffled) 
[18:05:39.995]                           invokeRestart("muffleMessage")
[18:05:39.995]                       }
[18:05:39.995]                       else if (inherits(cond, "warning")) {
[18:05:39.995]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:39.995]                         if (muffled) 
[18:05:39.995]                           invokeRestart("muffleWarning")
[18:05:39.995]                       }
[18:05:39.995]                       else if (inherits(cond, "condition")) {
[18:05:39.995]                         if (!is.null(pattern)) {
[18:05:39.995]                           computeRestarts <- base::computeRestarts
[18:05:39.995]                           grepl <- base::grepl
[18:05:39.995]                           restarts <- computeRestarts(cond)
[18:05:39.995]                           for (restart in restarts) {
[18:05:39.995]                             name <- restart$name
[18:05:39.995]                             if (is.null(name)) 
[18:05:39.995]                               next
[18:05:39.995]                             if (!grepl(pattern, name)) 
[18:05:39.995]                               next
[18:05:39.995]                             invokeRestart(restart)
[18:05:39.995]                             muffled <- TRUE
[18:05:39.995]                             break
[18:05:39.995]                           }
[18:05:39.995]                         }
[18:05:39.995]                       }
[18:05:39.995]                       invisible(muffled)
[18:05:39.995]                     }
[18:05:39.995]                     muffleCondition(cond, pattern = "^muffle")
[18:05:39.995]                   }
[18:05:39.995]                 }
[18:05:39.995]             }
[18:05:39.995]         }))
[18:05:39.995]     }, error = function(ex) {
[18:05:39.995]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:39.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:39.995]                 ...future.rng), started = ...future.startTime, 
[18:05:39.995]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:39.995]             version = "1.8"), class = "FutureResult")
[18:05:39.995]     }, finally = {
[18:05:39.995]         if (!identical(...future.workdir, getwd())) 
[18:05:39.995]             setwd(...future.workdir)
[18:05:39.995]         {
[18:05:39.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:39.995]                 ...future.oldOptions$nwarnings <- NULL
[18:05:39.995]             }
[18:05:39.995]             base::options(...future.oldOptions)
[18:05:39.995]             if (.Platform$OS.type == "windows") {
[18:05:39.995]                 old_names <- names(...future.oldEnvVars)
[18:05:39.995]                 envs <- base::Sys.getenv()
[18:05:39.995]                 names <- names(envs)
[18:05:39.995]                 common <- intersect(names, old_names)
[18:05:39.995]                 added <- setdiff(names, old_names)
[18:05:39.995]                 removed <- setdiff(old_names, names)
[18:05:39.995]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:39.995]                   envs[common]]
[18:05:39.995]                 NAMES <- toupper(changed)
[18:05:39.995]                 args <- list()
[18:05:39.995]                 for (kk in seq_along(NAMES)) {
[18:05:39.995]                   name <- changed[[kk]]
[18:05:39.995]                   NAME <- NAMES[[kk]]
[18:05:39.995]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.995]                     next
[18:05:39.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:39.995]                 }
[18:05:39.995]                 NAMES <- toupper(added)
[18:05:39.995]                 for (kk in seq_along(NAMES)) {
[18:05:39.995]                   name <- added[[kk]]
[18:05:39.995]                   NAME <- NAMES[[kk]]
[18:05:39.995]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.995]                     next
[18:05:39.995]                   args[[name]] <- ""
[18:05:39.995]                 }
[18:05:39.995]                 NAMES <- toupper(removed)
[18:05:39.995]                 for (kk in seq_along(NAMES)) {
[18:05:39.995]                   name <- removed[[kk]]
[18:05:39.995]                   NAME <- NAMES[[kk]]
[18:05:39.995]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:39.995]                     next
[18:05:39.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:39.995]                 }
[18:05:39.995]                 if (length(args) > 0) 
[18:05:39.995]                   base::do.call(base::Sys.setenv, args = args)
[18:05:39.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:39.995]             }
[18:05:39.995]             else {
[18:05:39.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:39.995]             }
[18:05:39.995]             {
[18:05:39.995]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:39.995]                   0L) {
[18:05:39.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:39.995]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:39.995]                   base::options(opts)
[18:05:39.995]                 }
[18:05:39.995]                 {
[18:05:39.995]                   {
[18:05:39.995]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:39.995]                     NULL
[18:05:39.995]                   }
[18:05:39.995]                   options(future.plan = NULL)
[18:05:39.995]                   if (is.na(NA_character_)) 
[18:05:39.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:39.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:39.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:39.995]                     .init = FALSE)
[18:05:39.995]                 }
[18:05:39.995]             }
[18:05:39.995]         }
[18:05:39.995]     })
[18:05:39.995]     if (TRUE) {
[18:05:39.995]         base::sink(type = "output", split = FALSE)
[18:05:39.995]         if (TRUE) {
[18:05:39.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:39.995]         }
[18:05:39.995]         else {
[18:05:39.995]             ...future.result["stdout"] <- base::list(NULL)
[18:05:39.995]         }
[18:05:39.995]         base::close(...future.stdout)
[18:05:39.995]         ...future.stdout <- NULL
[18:05:39.995]     }
[18:05:39.995]     ...future.result$conditions <- ...future.conditions
[18:05:39.995]     ...future.result$finished <- base::Sys.time()
[18:05:39.995]     ...future.result
[18:05:39.995] }
[18:05:40.099] MultisessionFuture started
[18:05:40.099] result() for ClusterFuture ...
[18:05:40.100] receiveMessageFromWorker() for ClusterFuture ...
[18:05:40.100] - Validating connection of MultisessionFuture
[18:05:40.192] - received message: FutureResult
[18:05:40.193] - Received FutureResult
[18:05:40.193] - Erased future from FutureRegistry
[18:05:40.193] result() for ClusterFuture ...
[18:05:40.194] - result already collected: FutureResult
[18:05:40.194] result() for ClusterFuture ... done
[18:05:40.194] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:40.194] result() for ClusterFuture ... done
[18:05:40.195] result() for ClusterFuture ...
[18:05:40.195] - result already collected: FutureResult
[18:05:40.195] result() for ClusterFuture ... done
[18:05:40.195] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:05:40.201] plan(): nbrOfWorkers() = 2
[18:05:40.202] getGlobalsAndPackages() ...
[18:05:40.203] Searching for globals...
[18:05:40.241] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[18:05:40.242] Searching for globals ... DONE
[18:05:40.242] Resolving globals: FALSE
[18:05:40.244] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[18:05:40.245] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[18:05:40.246] - globals: [2] ‘nested’, ‘strategy2’
[18:05:40.246] - packages: [1] ‘future’
[18:05:40.246] getGlobalsAndPackages() ... DONE
[18:05:40.247] run() for ‘Future’ ...
[18:05:40.247] - state: ‘created’
[18:05:40.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:40.272] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:40.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:40.273]   - Field: ‘node’
[18:05:40.273]   - Field: ‘label’
[18:05:40.273]   - Field: ‘local’
[18:05:40.274]   - Field: ‘owner’
[18:05:40.274]   - Field: ‘envir’
[18:05:40.274]   - Field: ‘workers’
[18:05:40.274]   - Field: ‘packages’
[18:05:40.275]   - Field: ‘gc’
[18:05:40.275]   - Field: ‘conditions’
[18:05:40.275]   - Field: ‘persistent’
[18:05:40.275]   - Field: ‘expr’
[18:05:40.276]   - Field: ‘uuid’
[18:05:40.276]   - Field: ‘seed’
[18:05:40.276]   - Field: ‘version’
[18:05:40.276]   - Field: ‘result’
[18:05:40.276]   - Field: ‘asynchronous’
[18:05:40.277]   - Field: ‘calls’
[18:05:40.277]   - Field: ‘globals’
[18:05:40.277]   - Field: ‘stdout’
[18:05:40.277]   - Field: ‘earlySignal’
[18:05:40.277]   - Field: ‘lazy’
[18:05:40.278]   - Field: ‘state’
[18:05:40.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:40.278] - Launch lazy future ...
[18:05:40.279] Packages needed by the future expression (n = 1): ‘future’
[18:05:40.279] Packages needed by future strategies (n = 1): ‘future’
[18:05:40.280] {
[18:05:40.280]     {
[18:05:40.280]         {
[18:05:40.280]             ...future.startTime <- base::Sys.time()
[18:05:40.280]             {
[18:05:40.280]                 {
[18:05:40.280]                   {
[18:05:40.280]                     {
[18:05:40.280]                       {
[18:05:40.280]                         base::local({
[18:05:40.280]                           has_future <- base::requireNamespace("future", 
[18:05:40.280]                             quietly = TRUE)
[18:05:40.280]                           if (has_future) {
[18:05:40.280]                             ns <- base::getNamespace("future")
[18:05:40.280]                             version <- ns[[".package"]][["version"]]
[18:05:40.280]                             if (is.null(version)) 
[18:05:40.280]                               version <- utils::packageVersion("future")
[18:05:40.280]                           }
[18:05:40.280]                           else {
[18:05:40.280]                             version <- NULL
[18:05:40.280]                           }
[18:05:40.280]                           if (!has_future || version < "1.8.0") {
[18:05:40.280]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:40.280]                               "", base::R.version$version.string), 
[18:05:40.280]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:40.280]                                 base::R.version$platform, 8 * 
[18:05:40.280]                                   base::.Machine$sizeof.pointer), 
[18:05:40.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:40.280]                                 "release", "version")], collapse = " "), 
[18:05:40.280]                               hostname = base::Sys.info()[["nodename"]])
[18:05:40.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:40.280]                               info)
[18:05:40.280]                             info <- base::paste(info, collapse = "; ")
[18:05:40.280]                             if (!has_future) {
[18:05:40.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:40.280]                                 info)
[18:05:40.280]                             }
[18:05:40.280]                             else {
[18:05:40.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:40.280]                                 info, version)
[18:05:40.280]                             }
[18:05:40.280]                             base::stop(msg)
[18:05:40.280]                           }
[18:05:40.280]                         })
[18:05:40.280]                       }
[18:05:40.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:40.280]                       base::options(mc.cores = 1L)
[18:05:40.280]                     }
[18:05:40.280]                     base::local({
[18:05:40.280]                       for (pkg in "future") {
[18:05:40.280]                         base::loadNamespace(pkg)
[18:05:40.280]                         base::library(pkg, character.only = TRUE)
[18:05:40.280]                       }
[18:05:40.280]                     })
[18:05:40.280]                   }
[18:05:40.280]                   ...future.strategy.old <- future::plan("list")
[18:05:40.280]                   options(future.plan = NULL)
[18:05:40.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:40.280]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:40.280]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:40.280]                     envir = parent.frame()) 
[18:05:40.280]                   {
[18:05:40.280]                     if (is.function(workers)) 
[18:05:40.280]                       workers <- workers()
[18:05:40.280]                     workers <- structure(as.integer(workers), 
[18:05:40.280]                       class = class(workers))
[18:05:40.280]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:40.280]                       workers >= 1)
[18:05:40.280]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:40.280]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:40.280]                     }
[18:05:40.280]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:40.280]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:40.280]                       envir = envir)
[18:05:40.280]                     if (!future$lazy) 
[18:05:40.280]                       future <- run(future)
[18:05:40.280]                     invisible(future)
[18:05:40.280]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:40.280]                 }
[18:05:40.280]                 ...future.workdir <- getwd()
[18:05:40.280]             }
[18:05:40.280]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:40.280]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:40.280]         }
[18:05:40.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:40.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:40.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:40.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:40.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:40.280]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:40.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:40.280]             base::names(...future.oldOptions))
[18:05:40.280]     }
[18:05:40.280]     if (FALSE) {
[18:05:40.280]     }
[18:05:40.280]     else {
[18:05:40.280]         if (TRUE) {
[18:05:40.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:40.280]                 open = "w")
[18:05:40.280]         }
[18:05:40.280]         else {
[18:05:40.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:40.280]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:40.280]         }
[18:05:40.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:40.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:40.280]             base::sink(type = "output", split = FALSE)
[18:05:40.280]             base::close(...future.stdout)
[18:05:40.280]         }, add = TRUE)
[18:05:40.280]     }
[18:05:40.280]     ...future.frame <- base::sys.nframe()
[18:05:40.280]     ...future.conditions <- base::list()
[18:05:40.280]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:40.280]     if (FALSE) {
[18:05:40.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:40.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:40.280]     }
[18:05:40.280]     ...future.result <- base::tryCatch({
[18:05:40.280]         base::withCallingHandlers({
[18:05:40.280]             ...future.value <- base::withVisible(base::local({
[18:05:40.280]                 ...future.makeSendCondition <- base::local({
[18:05:40.280]                   sendCondition <- NULL
[18:05:40.280]                   function(frame = 1L) {
[18:05:40.280]                     if (is.function(sendCondition)) 
[18:05:40.280]                       return(sendCondition)
[18:05:40.280]                     ns <- getNamespace("parallel")
[18:05:40.280]                     if (exists("sendData", mode = "function", 
[18:05:40.280]                       envir = ns)) {
[18:05:40.280]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:40.280]                         envir = ns)
[18:05:40.280]                       envir <- sys.frame(frame)
[18:05:40.280]                       master <- NULL
[18:05:40.280]                       while (!identical(envir, .GlobalEnv) && 
[18:05:40.280]                         !identical(envir, emptyenv())) {
[18:05:40.280]                         if (exists("master", mode = "list", envir = envir, 
[18:05:40.280]                           inherits = FALSE)) {
[18:05:40.280]                           master <- get("master", mode = "list", 
[18:05:40.280]                             envir = envir, inherits = FALSE)
[18:05:40.280]                           if (inherits(master, c("SOCKnode", 
[18:05:40.280]                             "SOCK0node"))) {
[18:05:40.280]                             sendCondition <<- function(cond) {
[18:05:40.280]                               data <- list(type = "VALUE", value = cond, 
[18:05:40.280]                                 success = TRUE)
[18:05:40.280]                               parallel_sendData(master, data)
[18:05:40.280]                             }
[18:05:40.280]                             return(sendCondition)
[18:05:40.280]                           }
[18:05:40.280]                         }
[18:05:40.280]                         frame <- frame + 1L
[18:05:40.280]                         envir <- sys.frame(frame)
[18:05:40.280]                       }
[18:05:40.280]                     }
[18:05:40.280]                     sendCondition <<- function(cond) NULL
[18:05:40.280]                   }
[18:05:40.280]                 })
[18:05:40.280]                 withCallingHandlers({
[18:05:40.280]                   {
[18:05:40.280]                     a <- 1L
[18:05:40.280]                     plan_a <- unclass(future::plan("list"))
[18:05:40.280]                     nested_a <- nested[-1]
[18:05:40.280]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[18:05:40.280]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[18:05:40.280]                       strategy2))
[18:05:40.280]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[18:05:40.280]                       "init") <- NULL
[18:05:40.280]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[18:05:40.280]                       "init") <- NULL
[18:05:40.280]                     stopifnot(all.equal(plan_a, nested_a))
[18:05:40.280]                     y %<-% {
[18:05:40.280]                       b <- 2L
[18:05:40.280]                       plan_b <- future::plan("list")
[18:05:40.280]                       nested_b <- nested_a[-1]
[18:05:40.280]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[18:05:40.280]                         1L, inherits(plan_b[[1]], "future"), 
[18:05:40.280]                         inherits(future::plan("next"), "sequential"))
[18:05:40.280]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[18:05:40.280]                         b = b, nested_b = nested_b, plan_b = plan_b)
[18:05:40.280]                     }
[18:05:40.280]                     y
[18:05:40.280]                   }
[18:05:40.280]                 }, immediateCondition = function(cond) {
[18:05:40.280]                   sendCondition <- ...future.makeSendCondition()
[18:05:40.280]                   sendCondition(cond)
[18:05:40.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:40.280]                   {
[18:05:40.280]                     inherits <- base::inherits
[18:05:40.280]                     invokeRestart <- base::invokeRestart
[18:05:40.280]                     is.null <- base::is.null
[18:05:40.280]                     muffled <- FALSE
[18:05:40.280]                     if (inherits(cond, "message")) {
[18:05:40.280]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:40.280]                       if (muffled) 
[18:05:40.280]                         invokeRestart("muffleMessage")
[18:05:40.280]                     }
[18:05:40.280]                     else if (inherits(cond, "warning")) {
[18:05:40.280]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:40.280]                       if (muffled) 
[18:05:40.280]                         invokeRestart("muffleWarning")
[18:05:40.280]                     }
[18:05:40.280]                     else if (inherits(cond, "condition")) {
[18:05:40.280]                       if (!is.null(pattern)) {
[18:05:40.280]                         computeRestarts <- base::computeRestarts
[18:05:40.280]                         grepl <- base::grepl
[18:05:40.280]                         restarts <- computeRestarts(cond)
[18:05:40.280]                         for (restart in restarts) {
[18:05:40.280]                           name <- restart$name
[18:05:40.280]                           if (is.null(name)) 
[18:05:40.280]                             next
[18:05:40.280]                           if (!grepl(pattern, name)) 
[18:05:40.280]                             next
[18:05:40.280]                           invokeRestart(restart)
[18:05:40.280]                           muffled <- TRUE
[18:05:40.280]                           break
[18:05:40.280]                         }
[18:05:40.280]                       }
[18:05:40.280]                     }
[18:05:40.280]                     invisible(muffled)
[18:05:40.280]                   }
[18:05:40.280]                   muffleCondition(cond)
[18:05:40.280]                 })
[18:05:40.280]             }))
[18:05:40.280]             future::FutureResult(value = ...future.value$value, 
[18:05:40.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:40.280]                   ...future.rng), globalenv = if (FALSE) 
[18:05:40.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:40.280]                     ...future.globalenv.names))
[18:05:40.280]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:40.280]         }, condition = base::local({
[18:05:40.280]             c <- base::c
[18:05:40.280]             inherits <- base::inherits
[18:05:40.280]             invokeRestart <- base::invokeRestart
[18:05:40.280]             length <- base::length
[18:05:40.280]             list <- base::list
[18:05:40.280]             seq.int <- base::seq.int
[18:05:40.280]             signalCondition <- base::signalCondition
[18:05:40.280]             sys.calls <- base::sys.calls
[18:05:40.280]             `[[` <- base::`[[`
[18:05:40.280]             `+` <- base::`+`
[18:05:40.280]             `<<-` <- base::`<<-`
[18:05:40.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:40.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:40.280]                   3L)]
[18:05:40.280]             }
[18:05:40.280]             function(cond) {
[18:05:40.280]                 is_error <- inherits(cond, "error")
[18:05:40.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:40.280]                   NULL)
[18:05:40.280]                 if (is_error) {
[18:05:40.280]                   sessionInformation <- function() {
[18:05:40.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:40.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:40.280]                       search = base::search(), system = base::Sys.info())
[18:05:40.280]                   }
[18:05:40.280]                   ...future.conditions[[length(...future.conditions) + 
[18:05:40.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:40.280]                     cond$call), session = sessionInformation(), 
[18:05:40.280]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:40.280]                   signalCondition(cond)
[18:05:40.280]                 }
[18:05:40.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:40.280]                 "immediateCondition"))) {
[18:05:40.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:40.280]                   ...future.conditions[[length(...future.conditions) + 
[18:05:40.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:40.280]                   if (TRUE && !signal) {
[18:05:40.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:40.280]                     {
[18:05:40.280]                       inherits <- base::inherits
[18:05:40.280]                       invokeRestart <- base::invokeRestart
[18:05:40.280]                       is.null <- base::is.null
[18:05:40.280]                       muffled <- FALSE
[18:05:40.280]                       if (inherits(cond, "message")) {
[18:05:40.280]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:40.280]                         if (muffled) 
[18:05:40.280]                           invokeRestart("muffleMessage")
[18:05:40.280]                       }
[18:05:40.280]                       else if (inherits(cond, "warning")) {
[18:05:40.280]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:40.280]                         if (muffled) 
[18:05:40.280]                           invokeRestart("muffleWarning")
[18:05:40.280]                       }
[18:05:40.280]                       else if (inherits(cond, "condition")) {
[18:05:40.280]                         if (!is.null(pattern)) {
[18:05:40.280]                           computeRestarts <- base::computeRestarts
[18:05:40.280]                           grepl <- base::grepl
[18:05:40.280]                           restarts <- computeRestarts(cond)
[18:05:40.280]                           for (restart in restarts) {
[18:05:40.280]                             name <- restart$name
[18:05:40.280]                             if (is.null(name)) 
[18:05:40.280]                               next
[18:05:40.280]                             if (!grepl(pattern, name)) 
[18:05:40.280]                               next
[18:05:40.280]                             invokeRestart(restart)
[18:05:40.280]                             muffled <- TRUE
[18:05:40.280]                             break
[18:05:40.280]                           }
[18:05:40.280]                         }
[18:05:40.280]                       }
[18:05:40.280]                       invisible(muffled)
[18:05:40.280]                     }
[18:05:40.280]                     muffleCondition(cond, pattern = "^muffle")
[18:05:40.280]                   }
[18:05:40.280]                 }
[18:05:40.280]                 else {
[18:05:40.280]                   if (TRUE) {
[18:05:40.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:40.280]                     {
[18:05:40.280]                       inherits <- base::inherits
[18:05:40.280]                       invokeRestart <- base::invokeRestart
[18:05:40.280]                       is.null <- base::is.null
[18:05:40.280]                       muffled <- FALSE
[18:05:40.280]                       if (inherits(cond, "message")) {
[18:05:40.280]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:40.280]                         if (muffled) 
[18:05:40.280]                           invokeRestart("muffleMessage")
[18:05:40.280]                       }
[18:05:40.280]                       else if (inherits(cond, "warning")) {
[18:05:40.280]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:40.280]                         if (muffled) 
[18:05:40.280]                           invokeRestart("muffleWarning")
[18:05:40.280]                       }
[18:05:40.280]                       else if (inherits(cond, "condition")) {
[18:05:40.280]                         if (!is.null(pattern)) {
[18:05:40.280]                           computeRestarts <- base::computeRestarts
[18:05:40.280]                           grepl <- base::grepl
[18:05:40.280]                           restarts <- computeRestarts(cond)
[18:05:40.280]                           for (restart in restarts) {
[18:05:40.280]                             name <- restart$name
[18:05:40.280]                             if (is.null(name)) 
[18:05:40.280]                               next
[18:05:40.280]                             if (!grepl(pattern, name)) 
[18:05:40.280]                               next
[18:05:40.280]                             invokeRestart(restart)
[18:05:40.280]                             muffled <- TRUE
[18:05:40.280]                             break
[18:05:40.280]                           }
[18:05:40.280]                         }
[18:05:40.280]                       }
[18:05:40.280]                       invisible(muffled)
[18:05:40.280]                     }
[18:05:40.280]                     muffleCondition(cond, pattern = "^muffle")
[18:05:40.280]                   }
[18:05:40.280]                 }
[18:05:40.280]             }
[18:05:40.280]         }))
[18:05:40.280]     }, error = function(ex) {
[18:05:40.280]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:40.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:40.280]                 ...future.rng), started = ...future.startTime, 
[18:05:40.280]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:40.280]             version = "1.8"), class = "FutureResult")
[18:05:40.280]     }, finally = {
[18:05:40.280]         if (!identical(...future.workdir, getwd())) 
[18:05:40.280]             setwd(...future.workdir)
[18:05:40.280]         {
[18:05:40.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:40.280]                 ...future.oldOptions$nwarnings <- NULL
[18:05:40.280]             }
[18:05:40.280]             base::options(...future.oldOptions)
[18:05:40.280]             if (.Platform$OS.type == "windows") {
[18:05:40.280]                 old_names <- names(...future.oldEnvVars)
[18:05:40.280]                 envs <- base::Sys.getenv()
[18:05:40.280]                 names <- names(envs)
[18:05:40.280]                 common <- intersect(names, old_names)
[18:05:40.280]                 added <- setdiff(names, old_names)
[18:05:40.280]                 removed <- setdiff(old_names, names)
[18:05:40.280]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:40.280]                   envs[common]]
[18:05:40.280]                 NAMES <- toupper(changed)
[18:05:40.280]                 args <- list()
[18:05:40.280]                 for (kk in seq_along(NAMES)) {
[18:05:40.280]                   name <- changed[[kk]]
[18:05:40.280]                   NAME <- NAMES[[kk]]
[18:05:40.280]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:40.280]                     next
[18:05:40.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:40.280]                 }
[18:05:40.280]                 NAMES <- toupper(added)
[18:05:40.280]                 for (kk in seq_along(NAMES)) {
[18:05:40.280]                   name <- added[[kk]]
[18:05:40.280]                   NAME <- NAMES[[kk]]
[18:05:40.280]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:40.280]                     next
[18:05:40.280]                   args[[name]] <- ""
[18:05:40.280]                 }
[18:05:40.280]                 NAMES <- toupper(removed)
[18:05:40.280]                 for (kk in seq_along(NAMES)) {
[18:05:40.280]                   name <- removed[[kk]]
[18:05:40.280]                   NAME <- NAMES[[kk]]
[18:05:40.280]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:40.280]                     next
[18:05:40.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:40.280]                 }
[18:05:40.280]                 if (length(args) > 0) 
[18:05:40.280]                   base::do.call(base::Sys.setenv, args = args)
[18:05:40.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:40.280]             }
[18:05:40.280]             else {
[18:05:40.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:40.280]             }
[18:05:40.280]             {
[18:05:40.280]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:40.280]                   0L) {
[18:05:40.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:40.280]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:40.280]                   base::options(opts)
[18:05:40.280]                 }
[18:05:40.280]                 {
[18:05:40.280]                   {
[18:05:40.280]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:40.280]                     NULL
[18:05:40.280]                   }
[18:05:40.280]                   options(future.plan = NULL)
[18:05:40.280]                   if (is.na(NA_character_)) 
[18:05:40.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:40.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:40.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:40.280]                     .init = FALSE)
[18:05:40.280]                 }
[18:05:40.280]             }
[18:05:40.280]         }
[18:05:40.280]     })
[18:05:40.280]     if (TRUE) {
[18:05:40.280]         base::sink(type = "output", split = FALSE)
[18:05:40.280]         if (TRUE) {
[18:05:40.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:40.280]         }
[18:05:40.280]         else {
[18:05:40.280]             ...future.result["stdout"] <- base::list(NULL)
[18:05:40.280]         }
[18:05:40.280]         base::close(...future.stdout)
[18:05:40.280]         ...future.stdout <- NULL
[18:05:40.280]     }
[18:05:40.280]     ...future.result$conditions <- ...future.conditions
[18:05:40.280]     ...future.result$finished <- base::Sys.time()
[18:05:40.280]     ...future.result
[18:05:40.280] }
[18:05:40.286] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[18:05:40.287] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[18:05:40.328] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[18:05:40.329] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[18:05:40.330] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[18:05:40.330] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[18:05:40.331] MultisessionFuture started
[18:05:40.331] - Launch lazy future ... done
[18:05:40.332] run() for ‘MultisessionFuture’ ... done
[18:05:40.332] result() for ClusterFuture ...
[18:05:40.332] receiveMessageFromWorker() for ClusterFuture ...
[18:05:40.332] - Validating connection of MultisessionFuture
[18:05:40.433] - received message: FutureResult
[18:05:40.433] - Received FutureResult
[18:05:40.434] - Erased future from FutureRegistry
[18:05:40.434] result() for ClusterFuture ...
[18:05:40.434] - result already collected: FutureResult
[18:05:40.434] result() for ClusterFuture ... done
[18:05:40.434] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:40.435] result() for ClusterFuture ... done
[18:05:40.435] result() for ClusterFuture ...
[18:05:40.435] - result already collected: FutureResult
[18:05:40.435] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[18:05:40.446] getGlobalsAndPackages() ...
[18:05:40.446] Searching for globals...
[18:05:40.449] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[18:05:40.449] Searching for globals ... DONE
[18:05:40.449] Resolving globals: FALSE
[18:05:40.451] The total size of the 1 globals is 128 bytes (128 bytes)
[18:05:40.451] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[18:05:40.452] - globals: [1] ‘data’
[18:05:40.452] - packages: [1] ‘future’
[18:05:40.452] getGlobalsAndPackages() ... DONE
[18:05:40.452] run() for ‘Future’ ...
[18:05:40.453] - state: ‘created’
[18:05:40.453] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:05:40.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:05:40.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:05:40.479]   - Field: ‘node’
[18:05:40.479]   - Field: ‘label’
[18:05:40.479]   - Field: ‘local’
[18:05:40.479]   - Field: ‘owner’
[18:05:40.480]   - Field: ‘envir’
[18:05:40.480]   - Field: ‘workers’
[18:05:40.480]   - Field: ‘packages’
[18:05:40.480]   - Field: ‘gc’
[18:05:40.480]   - Field: ‘conditions’
[18:05:40.481]   - Field: ‘persistent’
[18:05:40.481]   - Field: ‘expr’
[18:05:40.481]   - Field: ‘uuid’
[18:05:40.481]   - Field: ‘seed’
[18:05:40.481]   - Field: ‘version’
[18:05:40.482]   - Field: ‘result’
[18:05:40.482]   - Field: ‘asynchronous’
[18:05:40.482]   - Field: ‘calls’
[18:05:40.482]   - Field: ‘globals’
[18:05:40.482]   - Field: ‘stdout’
[18:05:40.483]   - Field: ‘earlySignal’
[18:05:40.483]   - Field: ‘lazy’
[18:05:40.483]   - Field: ‘state’
[18:05:40.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:05:40.483] - Launch lazy future ...
[18:05:40.484] Packages needed by the future expression (n = 1): ‘future’
[18:05:40.484] Packages needed by future strategies (n = 1): ‘future’
[18:05:40.485] {
[18:05:40.485]     {
[18:05:40.485]         {
[18:05:40.485]             ...future.startTime <- base::Sys.time()
[18:05:40.485]             {
[18:05:40.485]                 {
[18:05:40.485]                   {
[18:05:40.485]                     {
[18:05:40.485]                       {
[18:05:40.485]                         base::local({
[18:05:40.485]                           has_future <- base::requireNamespace("future", 
[18:05:40.485]                             quietly = TRUE)
[18:05:40.485]                           if (has_future) {
[18:05:40.485]                             ns <- base::getNamespace("future")
[18:05:40.485]                             version <- ns[[".package"]][["version"]]
[18:05:40.485]                             if (is.null(version)) 
[18:05:40.485]                               version <- utils::packageVersion("future")
[18:05:40.485]                           }
[18:05:40.485]                           else {
[18:05:40.485]                             version <- NULL
[18:05:40.485]                           }
[18:05:40.485]                           if (!has_future || version < "1.8.0") {
[18:05:40.485]                             info <- base::c(r_version = base::gsub("R version ", 
[18:05:40.485]                               "", base::R.version$version.string), 
[18:05:40.485]                               platform = base::sprintf("%s (%s-bit)", 
[18:05:40.485]                                 base::R.version$platform, 8 * 
[18:05:40.485]                                   base::.Machine$sizeof.pointer), 
[18:05:40.485]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:05:40.485]                                 "release", "version")], collapse = " "), 
[18:05:40.485]                               hostname = base::Sys.info()[["nodename"]])
[18:05:40.485]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:05:40.485]                               info)
[18:05:40.485]                             info <- base::paste(info, collapse = "; ")
[18:05:40.485]                             if (!has_future) {
[18:05:40.485]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:05:40.485]                                 info)
[18:05:40.485]                             }
[18:05:40.485]                             else {
[18:05:40.485]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:05:40.485]                                 info, version)
[18:05:40.485]                             }
[18:05:40.485]                             base::stop(msg)
[18:05:40.485]                           }
[18:05:40.485]                         })
[18:05:40.485]                       }
[18:05:40.485]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:05:40.485]                       base::options(mc.cores = 1L)
[18:05:40.485]                     }
[18:05:40.485]                     base::local({
[18:05:40.485]                       for (pkg in "future") {
[18:05:40.485]                         base::loadNamespace(pkg)
[18:05:40.485]                         base::library(pkg, character.only = TRUE)
[18:05:40.485]                       }
[18:05:40.485]                     })
[18:05:40.485]                   }
[18:05:40.485]                   ...future.strategy.old <- future::plan("list")
[18:05:40.485]                   options(future.plan = NULL)
[18:05:40.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:05:40.485]                   future::plan(list(b = function (..., workers = availableCores(), 
[18:05:40.485]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:05:40.485]                     envir = parent.frame()) 
[18:05:40.485]                   {
[18:05:40.485]                     if (is.function(workers)) 
[18:05:40.485]                       workers <- workers()
[18:05:40.485]                     workers <- structure(as.integer(workers), 
[18:05:40.485]                       class = class(workers))
[18:05:40.485]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:05:40.485]                       workers >= 1)
[18:05:40.485]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:05:40.485]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:05:40.485]                     }
[18:05:40.485]                     future <- MultisessionFuture(..., workers = workers, 
[18:05:40.485]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:05:40.485]                       envir = envir)
[18:05:40.485]                     if (!future$lazy) 
[18:05:40.485]                       future <- run(future)
[18:05:40.485]                     invisible(future)
[18:05:40.485]                   }), .cleanup = FALSE, .init = FALSE)
[18:05:40.485]                 }
[18:05:40.485]                 ...future.workdir <- getwd()
[18:05:40.485]             }
[18:05:40.485]             ...future.oldOptions <- base::as.list(base::.Options)
[18:05:40.485]             ...future.oldEnvVars <- base::Sys.getenv()
[18:05:40.485]         }
[18:05:40.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:05:40.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:05:40.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:05:40.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:05:40.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:05:40.485]             future.stdout.windows.reencode = NULL, width = 80L)
[18:05:40.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:05:40.485]             base::names(...future.oldOptions))
[18:05:40.485]     }
[18:05:40.485]     if (FALSE) {
[18:05:40.485]     }
[18:05:40.485]     else {
[18:05:40.485]         if (TRUE) {
[18:05:40.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:05:40.485]                 open = "w")
[18:05:40.485]         }
[18:05:40.485]         else {
[18:05:40.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:05:40.485]                 windows = "NUL", "/dev/null"), open = "w")
[18:05:40.485]         }
[18:05:40.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:05:40.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:05:40.485]             base::sink(type = "output", split = FALSE)
[18:05:40.485]             base::close(...future.stdout)
[18:05:40.485]         }, add = TRUE)
[18:05:40.485]     }
[18:05:40.485]     ...future.frame <- base::sys.nframe()
[18:05:40.485]     ...future.conditions <- base::list()
[18:05:40.485]     ...future.rng <- base::globalenv()$.Random.seed
[18:05:40.485]     if (FALSE) {
[18:05:40.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:05:40.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:05:40.485]     }
[18:05:40.485]     ...future.result <- base::tryCatch({
[18:05:40.485]         base::withCallingHandlers({
[18:05:40.485]             ...future.value <- base::withVisible(base::local({
[18:05:40.485]                 ...future.makeSendCondition <- base::local({
[18:05:40.485]                   sendCondition <- NULL
[18:05:40.485]                   function(frame = 1L) {
[18:05:40.485]                     if (is.function(sendCondition)) 
[18:05:40.485]                       return(sendCondition)
[18:05:40.485]                     ns <- getNamespace("parallel")
[18:05:40.485]                     if (exists("sendData", mode = "function", 
[18:05:40.485]                       envir = ns)) {
[18:05:40.485]                       parallel_sendData <- get("sendData", mode = "function", 
[18:05:40.485]                         envir = ns)
[18:05:40.485]                       envir <- sys.frame(frame)
[18:05:40.485]                       master <- NULL
[18:05:40.485]                       while (!identical(envir, .GlobalEnv) && 
[18:05:40.485]                         !identical(envir, emptyenv())) {
[18:05:40.485]                         if (exists("master", mode = "list", envir = envir, 
[18:05:40.485]                           inherits = FALSE)) {
[18:05:40.485]                           master <- get("master", mode = "list", 
[18:05:40.485]                             envir = envir, inherits = FALSE)
[18:05:40.485]                           if (inherits(master, c("SOCKnode", 
[18:05:40.485]                             "SOCK0node"))) {
[18:05:40.485]                             sendCondition <<- function(cond) {
[18:05:40.485]                               data <- list(type = "VALUE", value = cond, 
[18:05:40.485]                                 success = TRUE)
[18:05:40.485]                               parallel_sendData(master, data)
[18:05:40.485]                             }
[18:05:40.485]                             return(sendCondition)
[18:05:40.485]                           }
[18:05:40.485]                         }
[18:05:40.485]                         frame <- frame + 1L
[18:05:40.485]                         envir <- sys.frame(frame)
[18:05:40.485]                       }
[18:05:40.485]                     }
[18:05:40.485]                     sendCondition <<- function(cond) NULL
[18:05:40.485]                   }
[18:05:40.485]                 })
[18:05:40.485]                 withCallingHandlers({
[18:05:40.485]                   {
[18:05:40.485]                     value(future(subset(data, a == 2)))
[18:05:40.485]                   }
[18:05:40.485]                 }, immediateCondition = function(cond) {
[18:05:40.485]                   sendCondition <- ...future.makeSendCondition()
[18:05:40.485]                   sendCondition(cond)
[18:05:40.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:40.485]                   {
[18:05:40.485]                     inherits <- base::inherits
[18:05:40.485]                     invokeRestart <- base::invokeRestart
[18:05:40.485]                     is.null <- base::is.null
[18:05:40.485]                     muffled <- FALSE
[18:05:40.485]                     if (inherits(cond, "message")) {
[18:05:40.485]                       muffled <- grepl(pattern, "muffleMessage")
[18:05:40.485]                       if (muffled) 
[18:05:40.485]                         invokeRestart("muffleMessage")
[18:05:40.485]                     }
[18:05:40.485]                     else if (inherits(cond, "warning")) {
[18:05:40.485]                       muffled <- grepl(pattern, "muffleWarning")
[18:05:40.485]                       if (muffled) 
[18:05:40.485]                         invokeRestart("muffleWarning")
[18:05:40.485]                     }
[18:05:40.485]                     else if (inherits(cond, "condition")) {
[18:05:40.485]                       if (!is.null(pattern)) {
[18:05:40.485]                         computeRestarts <- base::computeRestarts
[18:05:40.485]                         grepl <- base::grepl
[18:05:40.485]                         restarts <- computeRestarts(cond)
[18:05:40.485]                         for (restart in restarts) {
[18:05:40.485]                           name <- restart$name
[18:05:40.485]                           if (is.null(name)) 
[18:05:40.485]                             next
[18:05:40.485]                           if (!grepl(pattern, name)) 
[18:05:40.485]                             next
[18:05:40.485]                           invokeRestart(restart)
[18:05:40.485]                           muffled <- TRUE
[18:05:40.485]                           break
[18:05:40.485]                         }
[18:05:40.485]                       }
[18:05:40.485]                     }
[18:05:40.485]                     invisible(muffled)
[18:05:40.485]                   }
[18:05:40.485]                   muffleCondition(cond)
[18:05:40.485]                 })
[18:05:40.485]             }))
[18:05:40.485]             future::FutureResult(value = ...future.value$value, 
[18:05:40.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:40.485]                   ...future.rng), globalenv = if (FALSE) 
[18:05:40.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:05:40.485]                     ...future.globalenv.names))
[18:05:40.485]                 else NULL, started = ...future.startTime, version = "1.8")
[18:05:40.485]         }, condition = base::local({
[18:05:40.485]             c <- base::c
[18:05:40.485]             inherits <- base::inherits
[18:05:40.485]             invokeRestart <- base::invokeRestart
[18:05:40.485]             length <- base::length
[18:05:40.485]             list <- base::list
[18:05:40.485]             seq.int <- base::seq.int
[18:05:40.485]             signalCondition <- base::signalCondition
[18:05:40.485]             sys.calls <- base::sys.calls
[18:05:40.485]             `[[` <- base::`[[`
[18:05:40.485]             `+` <- base::`+`
[18:05:40.485]             `<<-` <- base::`<<-`
[18:05:40.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:05:40.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:05:40.485]                   3L)]
[18:05:40.485]             }
[18:05:40.485]             function(cond) {
[18:05:40.485]                 is_error <- inherits(cond, "error")
[18:05:40.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:05:40.485]                   NULL)
[18:05:40.485]                 if (is_error) {
[18:05:40.485]                   sessionInformation <- function() {
[18:05:40.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:05:40.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:05:40.485]                       search = base::search(), system = base::Sys.info())
[18:05:40.485]                   }
[18:05:40.485]                   ...future.conditions[[length(...future.conditions) + 
[18:05:40.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:05:40.485]                     cond$call), session = sessionInformation(), 
[18:05:40.485]                     timestamp = base::Sys.time(), signaled = 0L)
[18:05:40.485]                   signalCondition(cond)
[18:05:40.485]                 }
[18:05:40.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:05:40.485]                 "immediateCondition"))) {
[18:05:40.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:05:40.485]                   ...future.conditions[[length(...future.conditions) + 
[18:05:40.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:05:40.485]                   if (TRUE && !signal) {
[18:05:40.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:40.485]                     {
[18:05:40.485]                       inherits <- base::inherits
[18:05:40.485]                       invokeRestart <- base::invokeRestart
[18:05:40.485]                       is.null <- base::is.null
[18:05:40.485]                       muffled <- FALSE
[18:05:40.485]                       if (inherits(cond, "message")) {
[18:05:40.485]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:40.485]                         if (muffled) 
[18:05:40.485]                           invokeRestart("muffleMessage")
[18:05:40.485]                       }
[18:05:40.485]                       else if (inherits(cond, "warning")) {
[18:05:40.485]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:40.485]                         if (muffled) 
[18:05:40.485]                           invokeRestart("muffleWarning")
[18:05:40.485]                       }
[18:05:40.485]                       else if (inherits(cond, "condition")) {
[18:05:40.485]                         if (!is.null(pattern)) {
[18:05:40.485]                           computeRestarts <- base::computeRestarts
[18:05:40.485]                           grepl <- base::grepl
[18:05:40.485]                           restarts <- computeRestarts(cond)
[18:05:40.485]                           for (restart in restarts) {
[18:05:40.485]                             name <- restart$name
[18:05:40.485]                             if (is.null(name)) 
[18:05:40.485]                               next
[18:05:40.485]                             if (!grepl(pattern, name)) 
[18:05:40.485]                               next
[18:05:40.485]                             invokeRestart(restart)
[18:05:40.485]                             muffled <- TRUE
[18:05:40.485]                             break
[18:05:40.485]                           }
[18:05:40.485]                         }
[18:05:40.485]                       }
[18:05:40.485]                       invisible(muffled)
[18:05:40.485]                     }
[18:05:40.485]                     muffleCondition(cond, pattern = "^muffle")
[18:05:40.485]                   }
[18:05:40.485]                 }
[18:05:40.485]                 else {
[18:05:40.485]                   if (TRUE) {
[18:05:40.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:05:40.485]                     {
[18:05:40.485]                       inherits <- base::inherits
[18:05:40.485]                       invokeRestart <- base::invokeRestart
[18:05:40.485]                       is.null <- base::is.null
[18:05:40.485]                       muffled <- FALSE
[18:05:40.485]                       if (inherits(cond, "message")) {
[18:05:40.485]                         muffled <- grepl(pattern, "muffleMessage")
[18:05:40.485]                         if (muffled) 
[18:05:40.485]                           invokeRestart("muffleMessage")
[18:05:40.485]                       }
[18:05:40.485]                       else if (inherits(cond, "warning")) {
[18:05:40.485]                         muffled <- grepl(pattern, "muffleWarning")
[18:05:40.485]                         if (muffled) 
[18:05:40.485]                           invokeRestart("muffleWarning")
[18:05:40.485]                       }
[18:05:40.485]                       else if (inherits(cond, "condition")) {
[18:05:40.485]                         if (!is.null(pattern)) {
[18:05:40.485]                           computeRestarts <- base::computeRestarts
[18:05:40.485]                           grepl <- base::grepl
[18:05:40.485]                           restarts <- computeRestarts(cond)
[18:05:40.485]                           for (restart in restarts) {
[18:05:40.485]                             name <- restart$name
[18:05:40.485]                             if (is.null(name)) 
[18:05:40.485]                               next
[18:05:40.485]                             if (!grepl(pattern, name)) 
[18:05:40.485]                               next
[18:05:40.485]                             invokeRestart(restart)
[18:05:40.485]                             muffled <- TRUE
[18:05:40.485]                             break
[18:05:40.485]                           }
[18:05:40.485]                         }
[18:05:40.485]                       }
[18:05:40.485]                       invisible(muffled)
[18:05:40.485]                     }
[18:05:40.485]                     muffleCondition(cond, pattern = "^muffle")
[18:05:40.485]                   }
[18:05:40.485]                 }
[18:05:40.485]             }
[18:05:40.485]         }))
[18:05:40.485]     }, error = function(ex) {
[18:05:40.485]         base::structure(base::list(value = NULL, visible = NULL, 
[18:05:40.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:05:40.485]                 ...future.rng), started = ...future.startTime, 
[18:05:40.485]             finished = Sys.time(), session_uuid = NA_character_, 
[18:05:40.485]             version = "1.8"), class = "FutureResult")
[18:05:40.485]     }, finally = {
[18:05:40.485]         if (!identical(...future.workdir, getwd())) 
[18:05:40.485]             setwd(...future.workdir)
[18:05:40.485]         {
[18:05:40.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:05:40.485]                 ...future.oldOptions$nwarnings <- NULL
[18:05:40.485]             }
[18:05:40.485]             base::options(...future.oldOptions)
[18:05:40.485]             if (.Platform$OS.type == "windows") {
[18:05:40.485]                 old_names <- names(...future.oldEnvVars)
[18:05:40.485]                 envs <- base::Sys.getenv()
[18:05:40.485]                 names <- names(envs)
[18:05:40.485]                 common <- intersect(names, old_names)
[18:05:40.485]                 added <- setdiff(names, old_names)
[18:05:40.485]                 removed <- setdiff(old_names, names)
[18:05:40.485]                 changed <- common[...future.oldEnvVars[common] != 
[18:05:40.485]                   envs[common]]
[18:05:40.485]                 NAMES <- toupper(changed)
[18:05:40.485]                 args <- list()
[18:05:40.485]                 for (kk in seq_along(NAMES)) {
[18:05:40.485]                   name <- changed[[kk]]
[18:05:40.485]                   NAME <- NAMES[[kk]]
[18:05:40.485]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:40.485]                     next
[18:05:40.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:40.485]                 }
[18:05:40.485]                 NAMES <- toupper(added)
[18:05:40.485]                 for (kk in seq_along(NAMES)) {
[18:05:40.485]                   name <- added[[kk]]
[18:05:40.485]                   NAME <- NAMES[[kk]]
[18:05:40.485]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:40.485]                     next
[18:05:40.485]                   args[[name]] <- ""
[18:05:40.485]                 }
[18:05:40.485]                 NAMES <- toupper(removed)
[18:05:40.485]                 for (kk in seq_along(NAMES)) {
[18:05:40.485]                   name <- removed[[kk]]
[18:05:40.485]                   NAME <- NAMES[[kk]]
[18:05:40.485]                   if (name != NAME && is.element(NAME, old_names)) 
[18:05:40.485]                     next
[18:05:40.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:05:40.485]                 }
[18:05:40.485]                 if (length(args) > 0) 
[18:05:40.485]                   base::do.call(base::Sys.setenv, args = args)
[18:05:40.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:05:40.485]             }
[18:05:40.485]             else {
[18:05:40.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:05:40.485]             }
[18:05:40.485]             {
[18:05:40.485]                 if (base::length(...future.futureOptionsAdded) > 
[18:05:40.485]                   0L) {
[18:05:40.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:05:40.485]                   base::names(opts) <- ...future.futureOptionsAdded
[18:05:40.485]                   base::options(opts)
[18:05:40.485]                 }
[18:05:40.485]                 {
[18:05:40.485]                   {
[18:05:40.485]                     base::options(mc.cores = ...future.mc.cores.old)
[18:05:40.485]                     NULL
[18:05:40.485]                   }
[18:05:40.485]                   options(future.plan = NULL)
[18:05:40.485]                   if (is.na(NA_character_)) 
[18:05:40.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:05:40.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:05:40.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:05:40.485]                     .init = FALSE)
[18:05:40.485]                 }
[18:05:40.485]             }
[18:05:40.485]         }
[18:05:40.485]     })
[18:05:40.485]     if (TRUE) {
[18:05:40.485]         base::sink(type = "output", split = FALSE)
[18:05:40.485]         if (TRUE) {
[18:05:40.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:05:40.485]         }
[18:05:40.485]         else {
[18:05:40.485]             ...future.result["stdout"] <- base::list(NULL)
[18:05:40.485]         }
[18:05:40.485]         base::close(...future.stdout)
[18:05:40.485]         ...future.stdout <- NULL
[18:05:40.485]     }
[18:05:40.485]     ...future.result$conditions <- ...future.conditions
[18:05:40.485]     ...future.result$finished <- base::Sys.time()
[18:05:40.485]     ...future.result
[18:05:40.485] }
[18:05:40.490] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[18:05:40.491] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[18:05:40.492] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[18:05:40.492] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[18:05:40.493] MultisessionFuture started
[18:05:40.493] - Launch lazy future ... done
[18:05:40.493] run() for ‘MultisessionFuture’ ... done
[18:05:40.494] result() for ClusterFuture ...
[18:05:40.494] receiveMessageFromWorker() for ClusterFuture ...
[18:05:40.494] - Validating connection of MultisessionFuture
[18:05:40.564] - received message: FutureResult
[18:05:40.564] - Received FutureResult
[18:05:40.565] - Erased future from FutureRegistry
[18:05:40.565] result() for ClusterFuture ...
[18:05:40.565] - result already collected: FutureResult
[18:05:40.565] result() for ClusterFuture ... done
[18:05:40.565] receiveMessageFromWorker() for ClusterFuture ... done
[18:05:40.566] result() for ClusterFuture ... done
[18:05:40.566] result() for ClusterFuture ...
[18:05:40.566] - result already collected: FutureResult
[18:05:40.566] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[18:05:40.568] plan(): Setting new future strategy stack:
[18:05:40.568] List of future strategies:
[18:05:40.568] 1. FutureStrategy:
[18:05:40.568]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:05:40.568]    - tweaked: FALSE
[18:05:40.568]    - call: future::plan(oplan)
[18:05:40.569] plan(): nbrOfWorkers() = 1
> 
