
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:46:20.937] plan(): Setting new future strategy stack:
[17:46:20.938] List of future strategies:
[17:46:20.938] 1. sequential:
[17:46:20.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:20.938]    - tweaked: FALSE
[17:46:20.938]    - call: future::plan("sequential")
[17:46:20.949] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("*** Global argument '...' ...")
+ 
+   sum_fcns <- list()
+ 
+   sum_fcns$A <- function(x, ...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, ...) }
+     y
+   }
+ 
+ 
+   sum_fcns$B <- function(x, ...) {
+     sumt <- function(x) {
+       message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+       y %<-% { sum(x, ...) }
+       y
+     }
+     sumt(x)
+   }
+ 
+   sum_fcns$C <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y) }
+     y
+   }
+ 
+   sum_fcns$D <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y, ...) }
+     y
+   }
+ 
+   ## Issue/PR #400: Emulate how '...' may be used by the 'rlang' package
+   sum_fcns$E <- function(...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+ 
+     ## Grab '...' into a Globals object
+     globals <- globals::globalsByName("...", envir=environment())
+ 
+     ## Evaluate an expression with '...' in an environment that does not
+     ## have an '...' object - hence the parent.frame().  This will produce
+     ## an error unless we pass 'globals' which contains '...'
+     f <- future({
+       fcn <- function() sum(...)
+       fcn()
+     }, envir = parent.frame(), globals = globals)
+     y <- value(f)
+     y
+   }
+ 
+   ## Issue: https://github.com/HenrikBengtsson/globals/issues/72
+   sum_fcns$F <- function(x, y) {
+     message("Using '...' in a formula")
+ 
+     fcn <- function(x, y) {
+       z = ~ list(...)
+       sum(x, y)
+     }
+     
+     f <- future(fcn(x, y))
+     y <- value(f)
+     y
+   }
+ 
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy, substitute = FALSE)
+ 
+     for (name in names(sum_fcns)) {
+       message(sprintf("** Sum function '%s' with plan('%s') ...", name, strategy))
+       sum_fcn <- sum_fcns[[name]]
+       print(sum_fcn)
+       y <- try(sum_fcn(1:2, 3))
+       print(y)
+       if (name %in% c("D")) {
+         stopifnot(inherits(y, "try-error"))
+       } else {
+         stopifnot(y == 6)
+       }
+     }
+   }
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** Global argument '...' ...
- plan('sequential') ...
[17:46:20.999] plan(): Setting new future strategy stack:
[17:46:20.999] List of future strategies:
[17:46:20.999] 1. sequential:
[17:46:20.999]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:20.999]    - tweaked: FALSE
[17:46:20.999]    - call: plan(strategy, substitute = FALSE)
[17:46:21.010] plan(): nbrOfWorkers() = 1
** Sum function 'A' with plan('sequential') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55aa0080c960>
Arguments '...' exists: TRUE
[17:46:21.012] getGlobalsAndPackages() ...
[17:46:21.012] Searching for globals...
[17:46:21.020] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:46:21.021] Searching for globals ... DONE
[17:46:21.021] Resolving globals: FALSE
[17:46:21.021] Tweak future expression to call with '...' arguments ...
[17:46:21.021] {
[17:46:21.021]     do.call(function(...) {
[17:46:21.021]         sum(x, ...)
[17:46:21.021]     }, args = future.call.arguments)
[17:46:21.021] }
[17:46:21.021] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.022] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.023] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:46:21.023] - globals: [2] ‘x’, ‘future.call.arguments’
[17:46:21.023] 
[17:46:21.023] getGlobalsAndPackages() ... DONE
[17:46:21.024] run() for ‘Future’ ...
[17:46:21.024] - state: ‘created’
[17:46:21.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:21.025] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:21.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:21.025]   - Field: ‘label’
[17:46:21.025]   - Field: ‘local’
[17:46:21.025]   - Field: ‘owner’
[17:46:21.025]   - Field: ‘envir’
[17:46:21.025]   - Field: ‘packages’
[17:46:21.025]   - Field: ‘gc’
[17:46:21.025]   - Field: ‘conditions’
[17:46:21.025]   - Field: ‘expr’
[17:46:21.025]   - Field: ‘uuid’
[17:46:21.026]   - Field: ‘seed’
[17:46:21.026]   - Field: ‘version’
[17:46:21.026]   - Field: ‘result’
[17:46:21.026]   - Field: ‘asynchronous’
[17:46:21.026]   - Field: ‘calls’
[17:46:21.026]   - Field: ‘globals’
[17:46:21.026]   - Field: ‘stdout’
[17:46:21.026]   - Field: ‘earlySignal’
[17:46:21.026]   - Field: ‘lazy’
[17:46:21.026]   - Field: ‘state’
[17:46:21.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:21.027] - Launch lazy future ...
[17:46:21.027] Packages needed by the future expression (n = 0): <none>
[17:46:21.027] Packages needed by future strategies (n = 0): <none>
[17:46:21.028] {
[17:46:21.028]     {
[17:46:21.028]         {
[17:46:21.028]             ...future.startTime <- base::Sys.time()
[17:46:21.028]             {
[17:46:21.028]                 {
[17:46:21.028]                   {
[17:46:21.028]                     base::local({
[17:46:21.028]                       has_future <- base::requireNamespace("future", 
[17:46:21.028]                         quietly = TRUE)
[17:46:21.028]                       if (has_future) {
[17:46:21.028]                         ns <- base::getNamespace("future")
[17:46:21.028]                         version <- ns[[".package"]][["version"]]
[17:46:21.028]                         if (is.null(version)) 
[17:46:21.028]                           version <- utils::packageVersion("future")
[17:46:21.028]                       }
[17:46:21.028]                       else {
[17:46:21.028]                         version <- NULL
[17:46:21.028]                       }
[17:46:21.028]                       if (!has_future || version < "1.8.0") {
[17:46:21.028]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.028]                           "", base::R.version$version.string), 
[17:46:21.028]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:21.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.028]                             "release", "version")], collapse = " "), 
[17:46:21.028]                           hostname = base::Sys.info()[["nodename"]])
[17:46:21.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.028]                           info)
[17:46:21.028]                         info <- base::paste(info, collapse = "; ")
[17:46:21.028]                         if (!has_future) {
[17:46:21.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.028]                             info)
[17:46:21.028]                         }
[17:46:21.028]                         else {
[17:46:21.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.028]                             info, version)
[17:46:21.028]                         }
[17:46:21.028]                         base::stop(msg)
[17:46:21.028]                       }
[17:46:21.028]                     })
[17:46:21.028]                   }
[17:46:21.028]                   ...future.strategy.old <- future::plan("list")
[17:46:21.028]                   options(future.plan = NULL)
[17:46:21.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.028]                 }
[17:46:21.028]                 ...future.workdir <- getwd()
[17:46:21.028]             }
[17:46:21.028]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.028]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.028]         }
[17:46:21.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.028]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.028]             base::names(...future.oldOptions))
[17:46:21.028]     }
[17:46:21.028]     if (FALSE) {
[17:46:21.028]     }
[17:46:21.028]     else {
[17:46:21.028]         if (TRUE) {
[17:46:21.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.028]                 open = "w")
[17:46:21.028]         }
[17:46:21.028]         else {
[17:46:21.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.028]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.028]         }
[17:46:21.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.028]             base::sink(type = "output", split = FALSE)
[17:46:21.028]             base::close(...future.stdout)
[17:46:21.028]         }, add = TRUE)
[17:46:21.028]     }
[17:46:21.028]     ...future.frame <- base::sys.nframe()
[17:46:21.028]     ...future.conditions <- base::list()
[17:46:21.028]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.028]     if (FALSE) {
[17:46:21.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.028]     }
[17:46:21.028]     ...future.result <- base::tryCatch({
[17:46:21.028]         base::withCallingHandlers({
[17:46:21.028]             ...future.value <- base::withVisible(base::local({
[17:46:21.028]                 do.call(function(...) {
[17:46:21.028]                   sum(x, ...)
[17:46:21.028]                 }, args = future.call.arguments)
[17:46:21.028]             }))
[17:46:21.028]             future::FutureResult(value = ...future.value$value, 
[17:46:21.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.028]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.028]                     ...future.globalenv.names))
[17:46:21.028]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.028]         }, condition = base::local({
[17:46:21.028]             c <- base::c
[17:46:21.028]             inherits <- base::inherits
[17:46:21.028]             invokeRestart <- base::invokeRestart
[17:46:21.028]             length <- base::length
[17:46:21.028]             list <- base::list
[17:46:21.028]             seq.int <- base::seq.int
[17:46:21.028]             signalCondition <- base::signalCondition
[17:46:21.028]             sys.calls <- base::sys.calls
[17:46:21.028]             `[[` <- base::`[[`
[17:46:21.028]             `+` <- base::`+`
[17:46:21.028]             `<<-` <- base::`<<-`
[17:46:21.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.028]                   3L)]
[17:46:21.028]             }
[17:46:21.028]             function(cond) {
[17:46:21.028]                 is_error <- inherits(cond, "error")
[17:46:21.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.028]                   NULL)
[17:46:21.028]                 if (is_error) {
[17:46:21.028]                   sessionInformation <- function() {
[17:46:21.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.028]                       search = base::search(), system = base::Sys.info())
[17:46:21.028]                   }
[17:46:21.028]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.028]                     cond$call), session = sessionInformation(), 
[17:46:21.028]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.028]                   signalCondition(cond)
[17:46:21.028]                 }
[17:46:21.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.028]                 "immediateCondition"))) {
[17:46:21.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.028]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.028]                   if (TRUE && !signal) {
[17:46:21.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.028]                     {
[17:46:21.028]                       inherits <- base::inherits
[17:46:21.028]                       invokeRestart <- base::invokeRestart
[17:46:21.028]                       is.null <- base::is.null
[17:46:21.028]                       muffled <- FALSE
[17:46:21.028]                       if (inherits(cond, "message")) {
[17:46:21.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.028]                         if (muffled) 
[17:46:21.028]                           invokeRestart("muffleMessage")
[17:46:21.028]                       }
[17:46:21.028]                       else if (inherits(cond, "warning")) {
[17:46:21.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.028]                         if (muffled) 
[17:46:21.028]                           invokeRestart("muffleWarning")
[17:46:21.028]                       }
[17:46:21.028]                       else if (inherits(cond, "condition")) {
[17:46:21.028]                         if (!is.null(pattern)) {
[17:46:21.028]                           computeRestarts <- base::computeRestarts
[17:46:21.028]                           grepl <- base::grepl
[17:46:21.028]                           restarts <- computeRestarts(cond)
[17:46:21.028]                           for (restart in restarts) {
[17:46:21.028]                             name <- restart$name
[17:46:21.028]                             if (is.null(name)) 
[17:46:21.028]                               next
[17:46:21.028]                             if (!grepl(pattern, name)) 
[17:46:21.028]                               next
[17:46:21.028]                             invokeRestart(restart)
[17:46:21.028]                             muffled <- TRUE
[17:46:21.028]                             break
[17:46:21.028]                           }
[17:46:21.028]                         }
[17:46:21.028]                       }
[17:46:21.028]                       invisible(muffled)
[17:46:21.028]                     }
[17:46:21.028]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.028]                   }
[17:46:21.028]                 }
[17:46:21.028]                 else {
[17:46:21.028]                   if (TRUE) {
[17:46:21.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.028]                     {
[17:46:21.028]                       inherits <- base::inherits
[17:46:21.028]                       invokeRestart <- base::invokeRestart
[17:46:21.028]                       is.null <- base::is.null
[17:46:21.028]                       muffled <- FALSE
[17:46:21.028]                       if (inherits(cond, "message")) {
[17:46:21.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.028]                         if (muffled) 
[17:46:21.028]                           invokeRestart("muffleMessage")
[17:46:21.028]                       }
[17:46:21.028]                       else if (inherits(cond, "warning")) {
[17:46:21.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.028]                         if (muffled) 
[17:46:21.028]                           invokeRestart("muffleWarning")
[17:46:21.028]                       }
[17:46:21.028]                       else if (inherits(cond, "condition")) {
[17:46:21.028]                         if (!is.null(pattern)) {
[17:46:21.028]                           computeRestarts <- base::computeRestarts
[17:46:21.028]                           grepl <- base::grepl
[17:46:21.028]                           restarts <- computeRestarts(cond)
[17:46:21.028]                           for (restart in restarts) {
[17:46:21.028]                             name <- restart$name
[17:46:21.028]                             if (is.null(name)) 
[17:46:21.028]                               next
[17:46:21.028]                             if (!grepl(pattern, name)) 
[17:46:21.028]                               next
[17:46:21.028]                             invokeRestart(restart)
[17:46:21.028]                             muffled <- TRUE
[17:46:21.028]                             break
[17:46:21.028]                           }
[17:46:21.028]                         }
[17:46:21.028]                       }
[17:46:21.028]                       invisible(muffled)
[17:46:21.028]                     }
[17:46:21.028]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.028]                   }
[17:46:21.028]                 }
[17:46:21.028]             }
[17:46:21.028]         }))
[17:46:21.028]     }, error = function(ex) {
[17:46:21.028]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.028]                 ...future.rng), started = ...future.startTime, 
[17:46:21.028]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.028]             version = "1.8"), class = "FutureResult")
[17:46:21.028]     }, finally = {
[17:46:21.028]         if (!identical(...future.workdir, getwd())) 
[17:46:21.028]             setwd(...future.workdir)
[17:46:21.028]         {
[17:46:21.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.028]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.028]             }
[17:46:21.028]             base::options(...future.oldOptions)
[17:46:21.028]             if (.Platform$OS.type == "windows") {
[17:46:21.028]                 old_names <- names(...future.oldEnvVars)
[17:46:21.028]                 envs <- base::Sys.getenv()
[17:46:21.028]                 names <- names(envs)
[17:46:21.028]                 common <- intersect(names, old_names)
[17:46:21.028]                 added <- setdiff(names, old_names)
[17:46:21.028]                 removed <- setdiff(old_names, names)
[17:46:21.028]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.028]                   envs[common]]
[17:46:21.028]                 NAMES <- toupper(changed)
[17:46:21.028]                 args <- list()
[17:46:21.028]                 for (kk in seq_along(NAMES)) {
[17:46:21.028]                   name <- changed[[kk]]
[17:46:21.028]                   NAME <- NAMES[[kk]]
[17:46:21.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.028]                     next
[17:46:21.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.028]                 }
[17:46:21.028]                 NAMES <- toupper(added)
[17:46:21.028]                 for (kk in seq_along(NAMES)) {
[17:46:21.028]                   name <- added[[kk]]
[17:46:21.028]                   NAME <- NAMES[[kk]]
[17:46:21.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.028]                     next
[17:46:21.028]                   args[[name]] <- ""
[17:46:21.028]                 }
[17:46:21.028]                 NAMES <- toupper(removed)
[17:46:21.028]                 for (kk in seq_along(NAMES)) {
[17:46:21.028]                   name <- removed[[kk]]
[17:46:21.028]                   NAME <- NAMES[[kk]]
[17:46:21.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.028]                     next
[17:46:21.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.028]                 }
[17:46:21.028]                 if (length(args) > 0) 
[17:46:21.028]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.028]             }
[17:46:21.028]             else {
[17:46:21.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.028]             }
[17:46:21.028]             {
[17:46:21.028]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.028]                   0L) {
[17:46:21.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.028]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.028]                   base::options(opts)
[17:46:21.028]                 }
[17:46:21.028]                 {
[17:46:21.028]                   {
[17:46:21.028]                     NULL
[17:46:21.028]                     RNGkind("Mersenne-Twister")
[17:46:21.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:21.028]                       inherits = FALSE)
[17:46:21.028]                   }
[17:46:21.028]                   options(future.plan = NULL)
[17:46:21.028]                   if (is.na(NA_character_)) 
[17:46:21.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.028]                     .init = FALSE)
[17:46:21.028]                 }
[17:46:21.028]             }
[17:46:21.028]         }
[17:46:21.028]     })
[17:46:21.028]     if (TRUE) {
[17:46:21.028]         base::sink(type = "output", split = FALSE)
[17:46:21.028]         if (TRUE) {
[17:46:21.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.028]         }
[17:46:21.028]         else {
[17:46:21.028]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.028]         }
[17:46:21.028]         base::close(...future.stdout)
[17:46:21.028]         ...future.stdout <- NULL
[17:46:21.028]     }
[17:46:21.028]     ...future.result$conditions <- ...future.conditions
[17:46:21.028]     ...future.result$finished <- base::Sys.time()
[17:46:21.028]     ...future.result
[17:46:21.028] }
[17:46:21.030] assign_globals() ...
[17:46:21.030] List of 2
[17:46:21.030]  $ x                    : int [1:2] 1 2
[17:46:21.030]  $ future.call.arguments:List of 1
[17:46:21.030]   ..$ : num 3
[17:46:21.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:46:21.030]  - attr(*, "where")=List of 2
[17:46:21.030]   ..$ x                    :<environment: R_EmptyEnv> 
[17:46:21.030]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:46:21.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.030]  - attr(*, "resolved")= logi FALSE
[17:46:21.030]  - attr(*, "total_size")= num 112
[17:46:21.030]  - attr(*, "already-done")= logi TRUE
[17:46:21.035] - copied ‘x’ to environment
[17:46:21.036] - copied ‘future.call.arguments’ to environment
[17:46:21.036] assign_globals() ... done
[17:46:21.036] plan(): Setting new future strategy stack:
[17:46:21.036] List of future strategies:
[17:46:21.036] 1. sequential:
[17:46:21.036]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.036]    - tweaked: FALSE
[17:46:21.036]    - call: NULL
[17:46:21.036] plan(): nbrOfWorkers() = 1
[17:46:21.038] plan(): Setting new future strategy stack:
[17:46:21.038] List of future strategies:
[17:46:21.038] 1. sequential:
[17:46:21.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.038]    - tweaked: FALSE
[17:46:21.038]    - call: plan(strategy, substitute = FALSE)
[17:46:21.038] plan(): nbrOfWorkers() = 1
[17:46:21.038] SequentialFuture started (and completed)
[17:46:21.039] - Launch lazy future ... done
[17:46:21.039] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'B' with plan('sequential') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55aa00b943d8>
Arguments '...' exists: TRUE
[17:46:21.040] getGlobalsAndPackages() ...
[17:46:21.040] Searching for globals...
[17:46:21.041] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:46:21.041] Searching for globals ... DONE
[17:46:21.041] Resolving globals: FALSE
[17:46:21.041] Tweak future expression to call with '...' arguments ...
[17:46:21.041] {
[17:46:21.041]     do.call(function(...) {
[17:46:21.041]         sum(x, ...)
[17:46:21.041]     }, args = future.call.arguments)
[17:46:21.041] }
[17:46:21.042] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.042] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.042] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:46:21.043] - globals: [2] ‘x’, ‘future.call.arguments’
[17:46:21.043] 
[17:46:21.043] getGlobalsAndPackages() ... DONE
[17:46:21.043] run() for ‘Future’ ...
[17:46:21.043] - state: ‘created’
[17:46:21.043] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:21.043] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:21.044] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:21.044]   - Field: ‘label’
[17:46:21.044]   - Field: ‘local’
[17:46:21.044]   - Field: ‘owner’
[17:46:21.044]   - Field: ‘envir’
[17:46:21.044]   - Field: ‘packages’
[17:46:21.044]   - Field: ‘gc’
[17:46:21.044]   - Field: ‘conditions’
[17:46:21.044]   - Field: ‘expr’
[17:46:21.044]   - Field: ‘uuid’
[17:46:21.044]   - Field: ‘seed’
[17:46:21.045]   - Field: ‘version’
[17:46:21.045]   - Field: ‘result’
[17:46:21.045]   - Field: ‘asynchronous’
[17:46:21.045]   - Field: ‘calls’
[17:46:21.045]   - Field: ‘globals’
[17:46:21.045]   - Field: ‘stdout’
[17:46:21.045]   - Field: ‘earlySignal’
[17:46:21.045]   - Field: ‘lazy’
[17:46:21.045]   - Field: ‘state’
[17:46:21.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:21.045] - Launch lazy future ...
[17:46:21.046] Packages needed by the future expression (n = 0): <none>
[17:46:21.046] Packages needed by future strategies (n = 0): <none>
[17:46:21.046] {
[17:46:21.046]     {
[17:46:21.046]         {
[17:46:21.046]             ...future.startTime <- base::Sys.time()
[17:46:21.046]             {
[17:46:21.046]                 {
[17:46:21.046]                   {
[17:46:21.046]                     base::local({
[17:46:21.046]                       has_future <- base::requireNamespace("future", 
[17:46:21.046]                         quietly = TRUE)
[17:46:21.046]                       if (has_future) {
[17:46:21.046]                         ns <- base::getNamespace("future")
[17:46:21.046]                         version <- ns[[".package"]][["version"]]
[17:46:21.046]                         if (is.null(version)) 
[17:46:21.046]                           version <- utils::packageVersion("future")
[17:46:21.046]                       }
[17:46:21.046]                       else {
[17:46:21.046]                         version <- NULL
[17:46:21.046]                       }
[17:46:21.046]                       if (!has_future || version < "1.8.0") {
[17:46:21.046]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.046]                           "", base::R.version$version.string), 
[17:46:21.046]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:21.046]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.046]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.046]                             "release", "version")], collapse = " "), 
[17:46:21.046]                           hostname = base::Sys.info()[["nodename"]])
[17:46:21.046]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.046]                           info)
[17:46:21.046]                         info <- base::paste(info, collapse = "; ")
[17:46:21.046]                         if (!has_future) {
[17:46:21.046]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.046]                             info)
[17:46:21.046]                         }
[17:46:21.046]                         else {
[17:46:21.046]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.046]                             info, version)
[17:46:21.046]                         }
[17:46:21.046]                         base::stop(msg)
[17:46:21.046]                       }
[17:46:21.046]                     })
[17:46:21.046]                   }
[17:46:21.046]                   ...future.strategy.old <- future::plan("list")
[17:46:21.046]                   options(future.plan = NULL)
[17:46:21.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.046]                 }
[17:46:21.046]                 ...future.workdir <- getwd()
[17:46:21.046]             }
[17:46:21.046]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.046]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.046]         }
[17:46:21.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.046]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.046]             base::names(...future.oldOptions))
[17:46:21.046]     }
[17:46:21.046]     if (FALSE) {
[17:46:21.046]     }
[17:46:21.046]     else {
[17:46:21.046]         if (TRUE) {
[17:46:21.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.046]                 open = "w")
[17:46:21.046]         }
[17:46:21.046]         else {
[17:46:21.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.046]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.046]         }
[17:46:21.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.046]             base::sink(type = "output", split = FALSE)
[17:46:21.046]             base::close(...future.stdout)
[17:46:21.046]         }, add = TRUE)
[17:46:21.046]     }
[17:46:21.046]     ...future.frame <- base::sys.nframe()
[17:46:21.046]     ...future.conditions <- base::list()
[17:46:21.046]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.046]     if (FALSE) {
[17:46:21.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.046]     }
[17:46:21.046]     ...future.result <- base::tryCatch({
[17:46:21.046]         base::withCallingHandlers({
[17:46:21.046]             ...future.value <- base::withVisible(base::local({
[17:46:21.046]                 do.call(function(...) {
[17:46:21.046]                   sum(x, ...)
[17:46:21.046]                 }, args = future.call.arguments)
[17:46:21.046]             }))
[17:46:21.046]             future::FutureResult(value = ...future.value$value, 
[17:46:21.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.046]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.046]                     ...future.globalenv.names))
[17:46:21.046]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.046]         }, condition = base::local({
[17:46:21.046]             c <- base::c
[17:46:21.046]             inherits <- base::inherits
[17:46:21.046]             invokeRestart <- base::invokeRestart
[17:46:21.046]             length <- base::length
[17:46:21.046]             list <- base::list
[17:46:21.046]             seq.int <- base::seq.int
[17:46:21.046]             signalCondition <- base::signalCondition
[17:46:21.046]             sys.calls <- base::sys.calls
[17:46:21.046]             `[[` <- base::`[[`
[17:46:21.046]             `+` <- base::`+`
[17:46:21.046]             `<<-` <- base::`<<-`
[17:46:21.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.046]                   3L)]
[17:46:21.046]             }
[17:46:21.046]             function(cond) {
[17:46:21.046]                 is_error <- inherits(cond, "error")
[17:46:21.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.046]                   NULL)
[17:46:21.046]                 if (is_error) {
[17:46:21.046]                   sessionInformation <- function() {
[17:46:21.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.046]                       search = base::search(), system = base::Sys.info())
[17:46:21.046]                   }
[17:46:21.046]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.046]                     cond$call), session = sessionInformation(), 
[17:46:21.046]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.046]                   signalCondition(cond)
[17:46:21.046]                 }
[17:46:21.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.046]                 "immediateCondition"))) {
[17:46:21.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.046]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.046]                   if (TRUE && !signal) {
[17:46:21.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.046]                     {
[17:46:21.046]                       inherits <- base::inherits
[17:46:21.046]                       invokeRestart <- base::invokeRestart
[17:46:21.046]                       is.null <- base::is.null
[17:46:21.046]                       muffled <- FALSE
[17:46:21.046]                       if (inherits(cond, "message")) {
[17:46:21.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.046]                         if (muffled) 
[17:46:21.046]                           invokeRestart("muffleMessage")
[17:46:21.046]                       }
[17:46:21.046]                       else if (inherits(cond, "warning")) {
[17:46:21.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.046]                         if (muffled) 
[17:46:21.046]                           invokeRestart("muffleWarning")
[17:46:21.046]                       }
[17:46:21.046]                       else if (inherits(cond, "condition")) {
[17:46:21.046]                         if (!is.null(pattern)) {
[17:46:21.046]                           computeRestarts <- base::computeRestarts
[17:46:21.046]                           grepl <- base::grepl
[17:46:21.046]                           restarts <- computeRestarts(cond)
[17:46:21.046]                           for (restart in restarts) {
[17:46:21.046]                             name <- restart$name
[17:46:21.046]                             if (is.null(name)) 
[17:46:21.046]                               next
[17:46:21.046]                             if (!grepl(pattern, name)) 
[17:46:21.046]                               next
[17:46:21.046]                             invokeRestart(restart)
[17:46:21.046]                             muffled <- TRUE
[17:46:21.046]                             break
[17:46:21.046]                           }
[17:46:21.046]                         }
[17:46:21.046]                       }
[17:46:21.046]                       invisible(muffled)
[17:46:21.046]                     }
[17:46:21.046]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.046]                   }
[17:46:21.046]                 }
[17:46:21.046]                 else {
[17:46:21.046]                   if (TRUE) {
[17:46:21.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.046]                     {
[17:46:21.046]                       inherits <- base::inherits
[17:46:21.046]                       invokeRestart <- base::invokeRestart
[17:46:21.046]                       is.null <- base::is.null
[17:46:21.046]                       muffled <- FALSE
[17:46:21.046]                       if (inherits(cond, "message")) {
[17:46:21.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.046]                         if (muffled) 
[17:46:21.046]                           invokeRestart("muffleMessage")
[17:46:21.046]                       }
[17:46:21.046]                       else if (inherits(cond, "warning")) {
[17:46:21.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.046]                         if (muffled) 
[17:46:21.046]                           invokeRestart("muffleWarning")
[17:46:21.046]                       }
[17:46:21.046]                       else if (inherits(cond, "condition")) {
[17:46:21.046]                         if (!is.null(pattern)) {
[17:46:21.046]                           computeRestarts <- base::computeRestarts
[17:46:21.046]                           grepl <- base::grepl
[17:46:21.046]                           restarts <- computeRestarts(cond)
[17:46:21.046]                           for (restart in restarts) {
[17:46:21.046]                             name <- restart$name
[17:46:21.046]                             if (is.null(name)) 
[17:46:21.046]                               next
[17:46:21.046]                             if (!grepl(pattern, name)) 
[17:46:21.046]                               next
[17:46:21.046]                             invokeRestart(restart)
[17:46:21.046]                             muffled <- TRUE
[17:46:21.046]                             break
[17:46:21.046]                           }
[17:46:21.046]                         }
[17:46:21.046]                       }
[17:46:21.046]                       invisible(muffled)
[17:46:21.046]                     }
[17:46:21.046]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.046]                   }
[17:46:21.046]                 }
[17:46:21.046]             }
[17:46:21.046]         }))
[17:46:21.046]     }, error = function(ex) {
[17:46:21.046]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.046]                 ...future.rng), started = ...future.startTime, 
[17:46:21.046]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.046]             version = "1.8"), class = "FutureResult")
[17:46:21.046]     }, finally = {
[17:46:21.046]         if (!identical(...future.workdir, getwd())) 
[17:46:21.046]             setwd(...future.workdir)
[17:46:21.046]         {
[17:46:21.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.046]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.046]             }
[17:46:21.046]             base::options(...future.oldOptions)
[17:46:21.046]             if (.Platform$OS.type == "windows") {
[17:46:21.046]                 old_names <- names(...future.oldEnvVars)
[17:46:21.046]                 envs <- base::Sys.getenv()
[17:46:21.046]                 names <- names(envs)
[17:46:21.046]                 common <- intersect(names, old_names)
[17:46:21.046]                 added <- setdiff(names, old_names)
[17:46:21.046]                 removed <- setdiff(old_names, names)
[17:46:21.046]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.046]                   envs[common]]
[17:46:21.046]                 NAMES <- toupper(changed)
[17:46:21.046]                 args <- list()
[17:46:21.046]                 for (kk in seq_along(NAMES)) {
[17:46:21.046]                   name <- changed[[kk]]
[17:46:21.046]                   NAME <- NAMES[[kk]]
[17:46:21.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.046]                     next
[17:46:21.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.046]                 }
[17:46:21.046]                 NAMES <- toupper(added)
[17:46:21.046]                 for (kk in seq_along(NAMES)) {
[17:46:21.046]                   name <- added[[kk]]
[17:46:21.046]                   NAME <- NAMES[[kk]]
[17:46:21.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.046]                     next
[17:46:21.046]                   args[[name]] <- ""
[17:46:21.046]                 }
[17:46:21.046]                 NAMES <- toupper(removed)
[17:46:21.046]                 for (kk in seq_along(NAMES)) {
[17:46:21.046]                   name <- removed[[kk]]
[17:46:21.046]                   NAME <- NAMES[[kk]]
[17:46:21.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.046]                     next
[17:46:21.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.046]                 }
[17:46:21.046]                 if (length(args) > 0) 
[17:46:21.046]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.046]             }
[17:46:21.046]             else {
[17:46:21.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.046]             }
[17:46:21.046]             {
[17:46:21.046]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.046]                   0L) {
[17:46:21.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.046]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.046]                   base::options(opts)
[17:46:21.046]                 }
[17:46:21.046]                 {
[17:46:21.046]                   {
[17:46:21.046]                     NULL
[17:46:21.046]                     RNGkind("Mersenne-Twister")
[17:46:21.046]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:21.046]                       inherits = FALSE)
[17:46:21.046]                   }
[17:46:21.046]                   options(future.plan = NULL)
[17:46:21.046]                   if (is.na(NA_character_)) 
[17:46:21.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.046]                     .init = FALSE)
[17:46:21.046]                 }
[17:46:21.046]             }
[17:46:21.046]         }
[17:46:21.046]     })
[17:46:21.046]     if (TRUE) {
[17:46:21.046]         base::sink(type = "output", split = FALSE)
[17:46:21.046]         if (TRUE) {
[17:46:21.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.046]         }
[17:46:21.046]         else {
[17:46:21.046]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.046]         }
[17:46:21.046]         base::close(...future.stdout)
[17:46:21.046]         ...future.stdout <- NULL
[17:46:21.046]     }
[17:46:21.046]     ...future.result$conditions <- ...future.conditions
[17:46:21.046]     ...future.result$finished <- base::Sys.time()
[17:46:21.046]     ...future.result
[17:46:21.046] }
[17:46:21.048] assign_globals() ...
[17:46:21.048] List of 2
[17:46:21.048]  $ x                    : int [1:2] 1 2
[17:46:21.048]  $ future.call.arguments:List of 1
[17:46:21.048]   ..$ : num 3
[17:46:21.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:46:21.048]  - attr(*, "where")=List of 2
[17:46:21.048]   ..$ x                    :<environment: R_EmptyEnv> 
[17:46:21.048]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:46:21.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.048]  - attr(*, "resolved")= logi FALSE
[17:46:21.048]  - attr(*, "total_size")= num 112
[17:46:21.048]  - attr(*, "already-done")= logi TRUE
[17:46:21.051] - copied ‘x’ to environment
[17:46:21.051] - copied ‘future.call.arguments’ to environment
[17:46:21.051] assign_globals() ... done
[17:46:21.052] plan(): Setting new future strategy stack:
[17:46:21.052] List of future strategies:
[17:46:21.052] 1. sequential:
[17:46:21.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.052]    - tweaked: FALSE
[17:46:21.052]    - call: NULL
[17:46:21.052] plan(): nbrOfWorkers() = 1
[17:46:21.053] plan(): Setting new future strategy stack:
[17:46:21.053] List of future strategies:
[17:46:21.053] 1. sequential:
[17:46:21.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.053]    - tweaked: FALSE
[17:46:21.053]    - call: plan(strategy, substitute = FALSE)
[17:46:21.053] plan(): nbrOfWorkers() = 1
[17:46:21.053] SequentialFuture started (and completed)
[17:46:21.054] - Launch lazy future ... done
[17:46:21.054] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'C' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55aa00d62468>
Arguments '...' exists: FALSE
[17:46:21.056] getGlobalsAndPackages() ...
[17:46:21.056] Searching for globals...
[17:46:21.057] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[17:46:21.057] Searching for globals ... DONE
[17:46:21.057] Resolving globals: FALSE
[17:46:21.058] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.058] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:21.058] - globals: [2] ‘x’, ‘y’
[17:46:21.058] 
[17:46:21.058] getGlobalsAndPackages() ... DONE
[17:46:21.059] run() for ‘Future’ ...
[17:46:21.059] - state: ‘created’
[17:46:21.059] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:21.059] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:21.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:21.059]   - Field: ‘label’
[17:46:21.060]   - Field: ‘local’
[17:46:21.060]   - Field: ‘owner’
[17:46:21.060]   - Field: ‘envir’
[17:46:21.060]   - Field: ‘packages’
[17:46:21.060]   - Field: ‘gc’
[17:46:21.060]   - Field: ‘conditions’
[17:46:21.060]   - Field: ‘expr’
[17:46:21.060]   - Field: ‘uuid’
[17:46:21.060]   - Field: ‘seed’
[17:46:21.060]   - Field: ‘version’
[17:46:21.060]   - Field: ‘result’
[17:46:21.060]   - Field: ‘asynchronous’
[17:46:21.061]   - Field: ‘calls’
[17:46:21.061]   - Field: ‘globals’
[17:46:21.061]   - Field: ‘stdout’
[17:46:21.061]   - Field: ‘earlySignal’
[17:46:21.061]   - Field: ‘lazy’
[17:46:21.061]   - Field: ‘state’
[17:46:21.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:21.061] - Launch lazy future ...
[17:46:21.061] Packages needed by the future expression (n = 0): <none>
[17:46:21.061] Packages needed by future strategies (n = 0): <none>
[17:46:21.062] {
[17:46:21.062]     {
[17:46:21.062]         {
[17:46:21.062]             ...future.startTime <- base::Sys.time()
[17:46:21.062]             {
[17:46:21.062]                 {
[17:46:21.062]                   {
[17:46:21.062]                     base::local({
[17:46:21.062]                       has_future <- base::requireNamespace("future", 
[17:46:21.062]                         quietly = TRUE)
[17:46:21.062]                       if (has_future) {
[17:46:21.062]                         ns <- base::getNamespace("future")
[17:46:21.062]                         version <- ns[[".package"]][["version"]]
[17:46:21.062]                         if (is.null(version)) 
[17:46:21.062]                           version <- utils::packageVersion("future")
[17:46:21.062]                       }
[17:46:21.062]                       else {
[17:46:21.062]                         version <- NULL
[17:46:21.062]                       }
[17:46:21.062]                       if (!has_future || version < "1.8.0") {
[17:46:21.062]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.062]                           "", base::R.version$version.string), 
[17:46:21.062]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:21.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.062]                             "release", "version")], collapse = " "), 
[17:46:21.062]                           hostname = base::Sys.info()[["nodename"]])
[17:46:21.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.062]                           info)
[17:46:21.062]                         info <- base::paste(info, collapse = "; ")
[17:46:21.062]                         if (!has_future) {
[17:46:21.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.062]                             info)
[17:46:21.062]                         }
[17:46:21.062]                         else {
[17:46:21.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.062]                             info, version)
[17:46:21.062]                         }
[17:46:21.062]                         base::stop(msg)
[17:46:21.062]                       }
[17:46:21.062]                     })
[17:46:21.062]                   }
[17:46:21.062]                   ...future.strategy.old <- future::plan("list")
[17:46:21.062]                   options(future.plan = NULL)
[17:46:21.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.062]                 }
[17:46:21.062]                 ...future.workdir <- getwd()
[17:46:21.062]             }
[17:46:21.062]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.062]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.062]         }
[17:46:21.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.062]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.062]             base::names(...future.oldOptions))
[17:46:21.062]     }
[17:46:21.062]     if (FALSE) {
[17:46:21.062]     }
[17:46:21.062]     else {
[17:46:21.062]         if (TRUE) {
[17:46:21.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.062]                 open = "w")
[17:46:21.062]         }
[17:46:21.062]         else {
[17:46:21.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.062]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.062]         }
[17:46:21.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.062]             base::sink(type = "output", split = FALSE)
[17:46:21.062]             base::close(...future.stdout)
[17:46:21.062]         }, add = TRUE)
[17:46:21.062]     }
[17:46:21.062]     ...future.frame <- base::sys.nframe()
[17:46:21.062]     ...future.conditions <- base::list()
[17:46:21.062]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.062]     if (FALSE) {
[17:46:21.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.062]     }
[17:46:21.062]     ...future.result <- base::tryCatch({
[17:46:21.062]         base::withCallingHandlers({
[17:46:21.062]             ...future.value <- base::withVisible(base::local({
[17:46:21.062]                 sum(x, y)
[17:46:21.062]             }))
[17:46:21.062]             future::FutureResult(value = ...future.value$value, 
[17:46:21.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.062]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.062]                     ...future.globalenv.names))
[17:46:21.062]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.062]         }, condition = base::local({
[17:46:21.062]             c <- base::c
[17:46:21.062]             inherits <- base::inherits
[17:46:21.062]             invokeRestart <- base::invokeRestart
[17:46:21.062]             length <- base::length
[17:46:21.062]             list <- base::list
[17:46:21.062]             seq.int <- base::seq.int
[17:46:21.062]             signalCondition <- base::signalCondition
[17:46:21.062]             sys.calls <- base::sys.calls
[17:46:21.062]             `[[` <- base::`[[`
[17:46:21.062]             `+` <- base::`+`
[17:46:21.062]             `<<-` <- base::`<<-`
[17:46:21.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.062]                   3L)]
[17:46:21.062]             }
[17:46:21.062]             function(cond) {
[17:46:21.062]                 is_error <- inherits(cond, "error")
[17:46:21.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.062]                   NULL)
[17:46:21.062]                 if (is_error) {
[17:46:21.062]                   sessionInformation <- function() {
[17:46:21.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.062]                       search = base::search(), system = base::Sys.info())
[17:46:21.062]                   }
[17:46:21.062]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.062]                     cond$call), session = sessionInformation(), 
[17:46:21.062]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.062]                   signalCondition(cond)
[17:46:21.062]                 }
[17:46:21.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.062]                 "immediateCondition"))) {
[17:46:21.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.062]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.062]                   if (TRUE && !signal) {
[17:46:21.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.062]                     {
[17:46:21.062]                       inherits <- base::inherits
[17:46:21.062]                       invokeRestart <- base::invokeRestart
[17:46:21.062]                       is.null <- base::is.null
[17:46:21.062]                       muffled <- FALSE
[17:46:21.062]                       if (inherits(cond, "message")) {
[17:46:21.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.062]                         if (muffled) 
[17:46:21.062]                           invokeRestart("muffleMessage")
[17:46:21.062]                       }
[17:46:21.062]                       else if (inherits(cond, "warning")) {
[17:46:21.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.062]                         if (muffled) 
[17:46:21.062]                           invokeRestart("muffleWarning")
[17:46:21.062]                       }
[17:46:21.062]                       else if (inherits(cond, "condition")) {
[17:46:21.062]                         if (!is.null(pattern)) {
[17:46:21.062]                           computeRestarts <- base::computeRestarts
[17:46:21.062]                           grepl <- base::grepl
[17:46:21.062]                           restarts <- computeRestarts(cond)
[17:46:21.062]                           for (restart in restarts) {
[17:46:21.062]                             name <- restart$name
[17:46:21.062]                             if (is.null(name)) 
[17:46:21.062]                               next
[17:46:21.062]                             if (!grepl(pattern, name)) 
[17:46:21.062]                               next
[17:46:21.062]                             invokeRestart(restart)
[17:46:21.062]                             muffled <- TRUE
[17:46:21.062]                             break
[17:46:21.062]                           }
[17:46:21.062]                         }
[17:46:21.062]                       }
[17:46:21.062]                       invisible(muffled)
[17:46:21.062]                     }
[17:46:21.062]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.062]                   }
[17:46:21.062]                 }
[17:46:21.062]                 else {
[17:46:21.062]                   if (TRUE) {
[17:46:21.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.062]                     {
[17:46:21.062]                       inherits <- base::inherits
[17:46:21.062]                       invokeRestart <- base::invokeRestart
[17:46:21.062]                       is.null <- base::is.null
[17:46:21.062]                       muffled <- FALSE
[17:46:21.062]                       if (inherits(cond, "message")) {
[17:46:21.062]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.062]                         if (muffled) 
[17:46:21.062]                           invokeRestart("muffleMessage")
[17:46:21.062]                       }
[17:46:21.062]                       else if (inherits(cond, "warning")) {
[17:46:21.062]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.062]                         if (muffled) 
[17:46:21.062]                           invokeRestart("muffleWarning")
[17:46:21.062]                       }
[17:46:21.062]                       else if (inherits(cond, "condition")) {
[17:46:21.062]                         if (!is.null(pattern)) {
[17:46:21.062]                           computeRestarts <- base::computeRestarts
[17:46:21.062]                           grepl <- base::grepl
[17:46:21.062]                           restarts <- computeRestarts(cond)
[17:46:21.062]                           for (restart in restarts) {
[17:46:21.062]                             name <- restart$name
[17:46:21.062]                             if (is.null(name)) 
[17:46:21.062]                               next
[17:46:21.062]                             if (!grepl(pattern, name)) 
[17:46:21.062]                               next
[17:46:21.062]                             invokeRestart(restart)
[17:46:21.062]                             muffled <- TRUE
[17:46:21.062]                             break
[17:46:21.062]                           }
[17:46:21.062]                         }
[17:46:21.062]                       }
[17:46:21.062]                       invisible(muffled)
[17:46:21.062]                     }
[17:46:21.062]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.062]                   }
[17:46:21.062]                 }
[17:46:21.062]             }
[17:46:21.062]         }))
[17:46:21.062]     }, error = function(ex) {
[17:46:21.062]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.062]                 ...future.rng), started = ...future.startTime, 
[17:46:21.062]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.062]             version = "1.8"), class = "FutureResult")
[17:46:21.062]     }, finally = {
[17:46:21.062]         if (!identical(...future.workdir, getwd())) 
[17:46:21.062]             setwd(...future.workdir)
[17:46:21.062]         {
[17:46:21.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.062]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.062]             }
[17:46:21.062]             base::options(...future.oldOptions)
[17:46:21.062]             if (.Platform$OS.type == "windows") {
[17:46:21.062]                 old_names <- names(...future.oldEnvVars)
[17:46:21.062]                 envs <- base::Sys.getenv()
[17:46:21.062]                 names <- names(envs)
[17:46:21.062]                 common <- intersect(names, old_names)
[17:46:21.062]                 added <- setdiff(names, old_names)
[17:46:21.062]                 removed <- setdiff(old_names, names)
[17:46:21.062]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.062]                   envs[common]]
[17:46:21.062]                 NAMES <- toupper(changed)
[17:46:21.062]                 args <- list()
[17:46:21.062]                 for (kk in seq_along(NAMES)) {
[17:46:21.062]                   name <- changed[[kk]]
[17:46:21.062]                   NAME <- NAMES[[kk]]
[17:46:21.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.062]                     next
[17:46:21.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.062]                 }
[17:46:21.062]                 NAMES <- toupper(added)
[17:46:21.062]                 for (kk in seq_along(NAMES)) {
[17:46:21.062]                   name <- added[[kk]]
[17:46:21.062]                   NAME <- NAMES[[kk]]
[17:46:21.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.062]                     next
[17:46:21.062]                   args[[name]] <- ""
[17:46:21.062]                 }
[17:46:21.062]                 NAMES <- toupper(removed)
[17:46:21.062]                 for (kk in seq_along(NAMES)) {
[17:46:21.062]                   name <- removed[[kk]]
[17:46:21.062]                   NAME <- NAMES[[kk]]
[17:46:21.062]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.062]                     next
[17:46:21.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.062]                 }
[17:46:21.062]                 if (length(args) > 0) 
[17:46:21.062]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.062]             }
[17:46:21.062]             else {
[17:46:21.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.062]             }
[17:46:21.062]             {
[17:46:21.062]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.062]                   0L) {
[17:46:21.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.062]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.062]                   base::options(opts)
[17:46:21.062]                 }
[17:46:21.062]                 {
[17:46:21.062]                   {
[17:46:21.062]                     NULL
[17:46:21.062]                     RNGkind("Mersenne-Twister")
[17:46:21.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:21.062]                       inherits = FALSE)
[17:46:21.062]                   }
[17:46:21.062]                   options(future.plan = NULL)
[17:46:21.062]                   if (is.na(NA_character_)) 
[17:46:21.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.062]                     .init = FALSE)
[17:46:21.062]                 }
[17:46:21.062]             }
[17:46:21.062]         }
[17:46:21.062]     })
[17:46:21.062]     if (TRUE) {
[17:46:21.062]         base::sink(type = "output", split = FALSE)
[17:46:21.062]         if (TRUE) {
[17:46:21.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.062]         }
[17:46:21.062]         else {
[17:46:21.062]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.062]         }
[17:46:21.062]         base::close(...future.stdout)
[17:46:21.062]         ...future.stdout <- NULL
[17:46:21.062]     }
[17:46:21.062]     ...future.result$conditions <- ...future.conditions
[17:46:21.062]     ...future.result$finished <- base::Sys.time()
[17:46:21.062]     ...future.result
[17:46:21.062] }
[17:46:21.063] assign_globals() ...
[17:46:21.063] List of 2
[17:46:21.063]  $ x: int [1:2] 1 2
[17:46:21.063]  $ y: num 3
[17:46:21.063]  - attr(*, "where")=List of 2
[17:46:21.063]   ..$ x:<environment: R_EmptyEnv> 
[17:46:21.063]   ..$ y:<environment: R_EmptyEnv> 
[17:46:21.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.063]  - attr(*, "resolved")= logi FALSE
[17:46:21.063]  - attr(*, "total_size")= num 112
[17:46:21.063]  - attr(*, "already-done")= logi TRUE
[17:46:21.066] - copied ‘x’ to environment
[17:46:21.066] - copied ‘y’ to environment
[17:46:21.066] assign_globals() ... done
[17:46:21.067] plan(): Setting new future strategy stack:
[17:46:21.067] List of future strategies:
[17:46:21.067] 1. sequential:
[17:46:21.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.067]    - tweaked: FALSE
[17:46:21.067]    - call: NULL
[17:46:21.067] plan(): nbrOfWorkers() = 1
[17:46:21.068] plan(): Setting new future strategy stack:
[17:46:21.068] List of future strategies:
[17:46:21.068] 1. sequential:
[17:46:21.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.068]    - tweaked: FALSE
[17:46:21.068]    - call: plan(strategy, substitute = FALSE)
[17:46:21.068] plan(): nbrOfWorkers() = 1
[17:46:21.069] SequentialFuture started (and completed)
[17:46:21.069] - Launch lazy future ... done
[17:46:21.069] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'D' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55aa00efe0c0>
Arguments '...' exists: FALSE
[17:46:21.069] getGlobalsAndPackages() ...
[17:46:21.069] Searching for globals...
[17:46:21.071] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[17:46:21.071] Searching for globals ... DONE
[17:46:21.071] Resolving globals: FALSE
[17:46:21.071] Tweak future expression to call with '...' arguments ...
[17:46:21.072] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.072] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:21.072] - globals: [2] ‘x’, ‘y’
[17:46:21.072] 
[17:46:21.072] getGlobalsAndPackages() ... DONE
[17:46:21.072] run() for ‘Future’ ...
[17:46:21.072] - state: ‘created’
[17:46:21.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:21.073] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:21.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:21.073]   - Field: ‘label’
[17:46:21.073]   - Field: ‘local’
[17:46:21.073]   - Field: ‘owner’
[17:46:21.073]   - Field: ‘envir’
[17:46:21.073]   - Field: ‘packages’
[17:46:21.074]   - Field: ‘gc’
[17:46:21.074]   - Field: ‘conditions’
[17:46:21.074]   - Field: ‘expr’
[17:46:21.074]   - Field: ‘uuid’
[17:46:21.074]   - Field: ‘seed’
[17:46:21.074]   - Field: ‘version’
[17:46:21.074]   - Field: ‘result’
[17:46:21.074]   - Field: ‘asynchronous’
[17:46:21.074]   - Field: ‘calls’
[17:46:21.074]   - Field: ‘globals’
[17:46:21.074]   - Field: ‘stdout’
[17:46:21.074]   - Field: ‘earlySignal’
[17:46:21.075]   - Field: ‘lazy’
[17:46:21.075]   - Field: ‘state’
[17:46:21.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:21.075] - Launch lazy future ...
[17:46:21.075] Packages needed by the future expression (n = 0): <none>
[17:46:21.075] Packages needed by future strategies (n = 0): <none>
[17:46:21.076] {
[17:46:21.076]     {
[17:46:21.076]         {
[17:46:21.076]             ...future.startTime <- base::Sys.time()
[17:46:21.076]             {
[17:46:21.076]                 {
[17:46:21.076]                   {
[17:46:21.076]                     base::local({
[17:46:21.076]                       has_future <- base::requireNamespace("future", 
[17:46:21.076]                         quietly = TRUE)
[17:46:21.076]                       if (has_future) {
[17:46:21.076]                         ns <- base::getNamespace("future")
[17:46:21.076]                         version <- ns[[".package"]][["version"]]
[17:46:21.076]                         if (is.null(version)) 
[17:46:21.076]                           version <- utils::packageVersion("future")
[17:46:21.076]                       }
[17:46:21.076]                       else {
[17:46:21.076]                         version <- NULL
[17:46:21.076]                       }
[17:46:21.076]                       if (!has_future || version < "1.8.0") {
[17:46:21.076]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.076]                           "", base::R.version$version.string), 
[17:46:21.076]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:21.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.076]                             "release", "version")], collapse = " "), 
[17:46:21.076]                           hostname = base::Sys.info()[["nodename"]])
[17:46:21.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.076]                           info)
[17:46:21.076]                         info <- base::paste(info, collapse = "; ")
[17:46:21.076]                         if (!has_future) {
[17:46:21.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.076]                             info)
[17:46:21.076]                         }
[17:46:21.076]                         else {
[17:46:21.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.076]                             info, version)
[17:46:21.076]                         }
[17:46:21.076]                         base::stop(msg)
[17:46:21.076]                       }
[17:46:21.076]                     })
[17:46:21.076]                   }
[17:46:21.076]                   ...future.strategy.old <- future::plan("list")
[17:46:21.076]                   options(future.plan = NULL)
[17:46:21.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.076]                 }
[17:46:21.076]                 ...future.workdir <- getwd()
[17:46:21.076]             }
[17:46:21.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.076]         }
[17:46:21.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.076]             base::names(...future.oldOptions))
[17:46:21.076]     }
[17:46:21.076]     if (FALSE) {
[17:46:21.076]     }
[17:46:21.076]     else {
[17:46:21.076]         if (TRUE) {
[17:46:21.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.076]                 open = "w")
[17:46:21.076]         }
[17:46:21.076]         else {
[17:46:21.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.076]         }
[17:46:21.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.076]             base::sink(type = "output", split = FALSE)
[17:46:21.076]             base::close(...future.stdout)
[17:46:21.076]         }, add = TRUE)
[17:46:21.076]     }
[17:46:21.076]     ...future.frame <- base::sys.nframe()
[17:46:21.076]     ...future.conditions <- base::list()
[17:46:21.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.076]     if (FALSE) {
[17:46:21.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.076]     }
[17:46:21.076]     ...future.result <- base::tryCatch({
[17:46:21.076]         base::withCallingHandlers({
[17:46:21.076]             ...future.value <- base::withVisible(base::local({
[17:46:21.076]                 sum(x, y, ...)
[17:46:21.076]             }))
[17:46:21.076]             future::FutureResult(value = ...future.value$value, 
[17:46:21.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.076]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.076]                     ...future.globalenv.names))
[17:46:21.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.076]         }, condition = base::local({
[17:46:21.076]             c <- base::c
[17:46:21.076]             inherits <- base::inherits
[17:46:21.076]             invokeRestart <- base::invokeRestart
[17:46:21.076]             length <- base::length
[17:46:21.076]             list <- base::list
[17:46:21.076]             seq.int <- base::seq.int
[17:46:21.076]             signalCondition <- base::signalCondition
[17:46:21.076]             sys.calls <- base::sys.calls
[17:46:21.076]             `[[` <- base::`[[`
[17:46:21.076]             `+` <- base::`+`
[17:46:21.076]             `<<-` <- base::`<<-`
[17:46:21.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.076]                   3L)]
[17:46:21.076]             }
[17:46:21.076]             function(cond) {
[17:46:21.076]                 is_error <- inherits(cond, "error")
[17:46:21.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.076]                   NULL)
[17:46:21.076]                 if (is_error) {
[17:46:21.076]                   sessionInformation <- function() {
[17:46:21.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.076]                       search = base::search(), system = base::Sys.info())
[17:46:21.076]                   }
[17:46:21.076]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.076]                     cond$call), session = sessionInformation(), 
[17:46:21.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.076]                   signalCondition(cond)
[17:46:21.076]                 }
[17:46:21.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.076]                 "immediateCondition"))) {
[17:46:21.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.076]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.076]                   if (TRUE && !signal) {
[17:46:21.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.076]                     {
[17:46:21.076]                       inherits <- base::inherits
[17:46:21.076]                       invokeRestart <- base::invokeRestart
[17:46:21.076]                       is.null <- base::is.null
[17:46:21.076]                       muffled <- FALSE
[17:46:21.076]                       if (inherits(cond, "message")) {
[17:46:21.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.076]                         if (muffled) 
[17:46:21.076]                           invokeRestart("muffleMessage")
[17:46:21.076]                       }
[17:46:21.076]                       else if (inherits(cond, "warning")) {
[17:46:21.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.076]                         if (muffled) 
[17:46:21.076]                           invokeRestart("muffleWarning")
[17:46:21.076]                       }
[17:46:21.076]                       else if (inherits(cond, "condition")) {
[17:46:21.076]                         if (!is.null(pattern)) {
[17:46:21.076]                           computeRestarts <- base::computeRestarts
[17:46:21.076]                           grepl <- base::grepl
[17:46:21.076]                           restarts <- computeRestarts(cond)
[17:46:21.076]                           for (restart in restarts) {
[17:46:21.076]                             name <- restart$name
[17:46:21.076]                             if (is.null(name)) 
[17:46:21.076]                               next
[17:46:21.076]                             if (!grepl(pattern, name)) 
[17:46:21.076]                               next
[17:46:21.076]                             invokeRestart(restart)
[17:46:21.076]                             muffled <- TRUE
[17:46:21.076]                             break
[17:46:21.076]                           }
[17:46:21.076]                         }
[17:46:21.076]                       }
[17:46:21.076]                       invisible(muffled)
[17:46:21.076]                     }
[17:46:21.076]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.076]                   }
[17:46:21.076]                 }
[17:46:21.076]                 else {
[17:46:21.076]                   if (TRUE) {
[17:46:21.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.076]                     {
[17:46:21.076]                       inherits <- base::inherits
[17:46:21.076]                       invokeRestart <- base::invokeRestart
[17:46:21.076]                       is.null <- base::is.null
[17:46:21.076]                       muffled <- FALSE
[17:46:21.076]                       if (inherits(cond, "message")) {
[17:46:21.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.076]                         if (muffled) 
[17:46:21.076]                           invokeRestart("muffleMessage")
[17:46:21.076]                       }
[17:46:21.076]                       else if (inherits(cond, "warning")) {
[17:46:21.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.076]                         if (muffled) 
[17:46:21.076]                           invokeRestart("muffleWarning")
[17:46:21.076]                       }
[17:46:21.076]                       else if (inherits(cond, "condition")) {
[17:46:21.076]                         if (!is.null(pattern)) {
[17:46:21.076]                           computeRestarts <- base::computeRestarts
[17:46:21.076]                           grepl <- base::grepl
[17:46:21.076]                           restarts <- computeRestarts(cond)
[17:46:21.076]                           for (restart in restarts) {
[17:46:21.076]                             name <- restart$name
[17:46:21.076]                             if (is.null(name)) 
[17:46:21.076]                               next
[17:46:21.076]                             if (!grepl(pattern, name)) 
[17:46:21.076]                               next
[17:46:21.076]                             invokeRestart(restart)
[17:46:21.076]                             muffled <- TRUE
[17:46:21.076]                             break
[17:46:21.076]                           }
[17:46:21.076]                         }
[17:46:21.076]                       }
[17:46:21.076]                       invisible(muffled)
[17:46:21.076]                     }
[17:46:21.076]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.076]                   }
[17:46:21.076]                 }
[17:46:21.076]             }
[17:46:21.076]         }))
[17:46:21.076]     }, error = function(ex) {
[17:46:21.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.076]                 ...future.rng), started = ...future.startTime, 
[17:46:21.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.076]             version = "1.8"), class = "FutureResult")
[17:46:21.076]     }, finally = {
[17:46:21.076]         if (!identical(...future.workdir, getwd())) 
[17:46:21.076]             setwd(...future.workdir)
[17:46:21.076]         {
[17:46:21.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.076]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.076]             }
[17:46:21.076]             base::options(...future.oldOptions)
[17:46:21.076]             if (.Platform$OS.type == "windows") {
[17:46:21.076]                 old_names <- names(...future.oldEnvVars)
[17:46:21.076]                 envs <- base::Sys.getenv()
[17:46:21.076]                 names <- names(envs)
[17:46:21.076]                 common <- intersect(names, old_names)
[17:46:21.076]                 added <- setdiff(names, old_names)
[17:46:21.076]                 removed <- setdiff(old_names, names)
[17:46:21.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.076]                   envs[common]]
[17:46:21.076]                 NAMES <- toupper(changed)
[17:46:21.076]                 args <- list()
[17:46:21.076]                 for (kk in seq_along(NAMES)) {
[17:46:21.076]                   name <- changed[[kk]]
[17:46:21.076]                   NAME <- NAMES[[kk]]
[17:46:21.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.076]                     next
[17:46:21.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.076]                 }
[17:46:21.076]                 NAMES <- toupper(added)
[17:46:21.076]                 for (kk in seq_along(NAMES)) {
[17:46:21.076]                   name <- added[[kk]]
[17:46:21.076]                   NAME <- NAMES[[kk]]
[17:46:21.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.076]                     next
[17:46:21.076]                   args[[name]] <- ""
[17:46:21.076]                 }
[17:46:21.076]                 NAMES <- toupper(removed)
[17:46:21.076]                 for (kk in seq_along(NAMES)) {
[17:46:21.076]                   name <- removed[[kk]]
[17:46:21.076]                   NAME <- NAMES[[kk]]
[17:46:21.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.076]                     next
[17:46:21.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.076]                 }
[17:46:21.076]                 if (length(args) > 0) 
[17:46:21.076]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.076]             }
[17:46:21.076]             else {
[17:46:21.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.076]             }
[17:46:21.076]             {
[17:46:21.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.076]                   0L) {
[17:46:21.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.076]                   base::options(opts)
[17:46:21.076]                 }
[17:46:21.076]                 {
[17:46:21.076]                   {
[17:46:21.076]                     NULL
[17:46:21.076]                     RNGkind("Mersenne-Twister")
[17:46:21.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:21.076]                       inherits = FALSE)
[17:46:21.076]                   }
[17:46:21.076]                   options(future.plan = NULL)
[17:46:21.076]                   if (is.na(NA_character_)) 
[17:46:21.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.076]                     .init = FALSE)
[17:46:21.076]                 }
[17:46:21.076]             }
[17:46:21.076]         }
[17:46:21.076]     })
[17:46:21.076]     if (TRUE) {
[17:46:21.076]         base::sink(type = "output", split = FALSE)
[17:46:21.076]         if (TRUE) {
[17:46:21.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.076]         }
[17:46:21.076]         else {
[17:46:21.076]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.076]         }
[17:46:21.076]         base::close(...future.stdout)
[17:46:21.076]         ...future.stdout <- NULL
[17:46:21.076]     }
[17:46:21.076]     ...future.result$conditions <- ...future.conditions
[17:46:21.076]     ...future.result$finished <- base::Sys.time()
[17:46:21.076]     ...future.result
[17:46:21.076] }
[17:46:21.077] assign_globals() ...
[17:46:21.077] List of 2
[17:46:21.077]  $ x: int [1:2] 1 2
[17:46:21.077]  $ y: num 3
[17:46:21.077]  - attr(*, "where")=List of 2
[17:46:21.077]   ..$ x:<environment: R_EmptyEnv> 
[17:46:21.077]   ..$ y:<environment: R_EmptyEnv> 
[17:46:21.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.077]  - attr(*, "resolved")= logi FALSE
[17:46:21.077]  - attr(*, "total_size")= num 112
[17:46:21.077]  - attr(*, "already-done")= logi TRUE
[17:46:21.080] - copied ‘x’ to environment
[17:46:21.080] - copied ‘y’ to environment
[17:46:21.080] assign_globals() ... done
[17:46:21.080] plan(): Setting new future strategy stack:
[17:46:21.081] List of future strategies:
[17:46:21.081] 1. sequential:
[17:46:21.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.081]    - tweaked: FALSE
[17:46:21.081]    - call: NULL
[17:46:21.081] plan(): nbrOfWorkers() = 1
[17:46:21.082] plan(): Setting new future strategy stack:
[17:46:21.082] List of future strategies:
[17:46:21.082] 1. sequential:
[17:46:21.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.082]    - tweaked: FALSE
[17:46:21.082]    - call: plan(strategy, substitute = FALSE)
[17:46:21.082] plan(): nbrOfWorkers() = 1
[17:46:21.083] SequentialFuture started (and completed)
[17:46:21.083] signalConditions() ...
[17:46:21.083]  - include = ‘immediateCondition’
[17:46:21.083]  - exclude = 
[17:46:21.083]  - resignal = FALSE
[17:46:21.083]  - Number of conditions: 1
[17:46:21.083] signalConditions() ... done
[17:46:21.083] - Launch lazy future ... done
[17:46:21.083] run() for ‘SequentialFuture’ ... done
[17:46:21.084] signalConditions() ...
[17:46:21.084]  - include = ‘immediateCondition’
[17:46:21.084]  - exclude = 
[17:46:21.084]  - resignal = FALSE
[17:46:21.084]  - Number of conditions: 1
[17:46:21.084] signalConditions() ... done
[17:46:21.085] Future state: ‘finished’
[17:46:21.085] signalConditions() ...
[17:46:21.086]  - include = ‘condition’
[17:46:21.086]  - exclude = ‘immediateCondition’
[17:46:21.086]  - resignal = TRUE
[17:46:21.086]  - Number of conditions: 1
[17:46:21.086]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:21.086] signalConditions() ... done
Error in eval(quote({ : '...' used in an incorrect context
[1] "Error in eval(quote({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    sum(x, y, ...)}), new.env()): '...' used in an incorrect context>
** Sum function 'E' with plan('sequential') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55aa014e9798>
Arguments '...' exists: TRUE
[17:46:21.087] getGlobalsAndPackages() ...
[17:46:21.087] - globals passed as-is: [1] ‘...’
[17:46:21.087] Resolving globals: FALSE
[17:46:21.087] Tweak future expression to call with '...' arguments ...
[17:46:21.087] {
[17:46:21.087]     do.call(function(...) {
[17:46:21.087]         fcn <- function() sum(...)
[17:46:21.087]         fcn()
[17:46:21.087]     }, args = future.call.arguments)
[17:46:21.087] }
[17:46:21.087] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.088] The total size of the 1 globals is 112 bytes (112 bytes)
[17:46:21.088] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[17:46:21.088] - globals: [1] ‘future.call.arguments’
[17:46:21.088] 
[17:46:21.088] getGlobalsAndPackages() ... DONE
[17:46:21.089] run() for ‘Future’ ...
[17:46:21.089] - state: ‘created’
[17:46:21.089] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:21.089] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:21.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:21.089]   - Field: ‘label’
[17:46:21.089]   - Field: ‘local’
[17:46:21.089]   - Field: ‘owner’
[17:46:21.090]   - Field: ‘envir’
[17:46:21.090]   - Field: ‘packages’
[17:46:21.090]   - Field: ‘gc’
[17:46:21.090]   - Field: ‘conditions’
[17:46:21.090]   - Field: ‘expr’
[17:46:21.090]   - Field: ‘uuid’
[17:46:21.090]   - Field: ‘seed’
[17:46:21.090]   - Field: ‘version’
[17:46:21.090]   - Field: ‘result’
[17:46:21.090]   - Field: ‘asynchronous’
[17:46:21.090]   - Field: ‘calls’
[17:46:21.090]   - Field: ‘globals’
[17:46:21.091]   - Field: ‘stdout’
[17:46:21.091]   - Field: ‘earlySignal’
[17:46:21.091]   - Field: ‘lazy’
[17:46:21.091]   - Field: ‘state’
[17:46:21.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:21.091] - Launch lazy future ...
[17:46:21.091] Packages needed by the future expression (n = 0): <none>
[17:46:21.091] Packages needed by future strategies (n = 0): <none>
[17:46:21.092] {
[17:46:21.092]     {
[17:46:21.092]         {
[17:46:21.092]             ...future.startTime <- base::Sys.time()
[17:46:21.092]             {
[17:46:21.092]                 {
[17:46:21.092]                   {
[17:46:21.092]                     base::local({
[17:46:21.092]                       has_future <- base::requireNamespace("future", 
[17:46:21.092]                         quietly = TRUE)
[17:46:21.092]                       if (has_future) {
[17:46:21.092]                         ns <- base::getNamespace("future")
[17:46:21.092]                         version <- ns[[".package"]][["version"]]
[17:46:21.092]                         if (is.null(version)) 
[17:46:21.092]                           version <- utils::packageVersion("future")
[17:46:21.092]                       }
[17:46:21.092]                       else {
[17:46:21.092]                         version <- NULL
[17:46:21.092]                       }
[17:46:21.092]                       if (!has_future || version < "1.8.0") {
[17:46:21.092]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.092]                           "", base::R.version$version.string), 
[17:46:21.092]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:21.092]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.092]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.092]                             "release", "version")], collapse = " "), 
[17:46:21.092]                           hostname = base::Sys.info()[["nodename"]])
[17:46:21.092]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.092]                           info)
[17:46:21.092]                         info <- base::paste(info, collapse = "; ")
[17:46:21.092]                         if (!has_future) {
[17:46:21.092]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.092]                             info)
[17:46:21.092]                         }
[17:46:21.092]                         else {
[17:46:21.092]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.092]                             info, version)
[17:46:21.092]                         }
[17:46:21.092]                         base::stop(msg)
[17:46:21.092]                       }
[17:46:21.092]                     })
[17:46:21.092]                   }
[17:46:21.092]                   ...future.strategy.old <- future::plan("list")
[17:46:21.092]                   options(future.plan = NULL)
[17:46:21.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.092]                 }
[17:46:21.092]                 ...future.workdir <- getwd()
[17:46:21.092]             }
[17:46:21.092]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.092]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.092]         }
[17:46:21.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.092]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.092]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.092]             base::names(...future.oldOptions))
[17:46:21.092]     }
[17:46:21.092]     if (FALSE) {
[17:46:21.092]     }
[17:46:21.092]     else {
[17:46:21.092]         if (TRUE) {
[17:46:21.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.092]                 open = "w")
[17:46:21.092]         }
[17:46:21.092]         else {
[17:46:21.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.092]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.092]         }
[17:46:21.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.092]             base::sink(type = "output", split = FALSE)
[17:46:21.092]             base::close(...future.stdout)
[17:46:21.092]         }, add = TRUE)
[17:46:21.092]     }
[17:46:21.092]     ...future.frame <- base::sys.nframe()
[17:46:21.092]     ...future.conditions <- base::list()
[17:46:21.092]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.092]     if (FALSE) {
[17:46:21.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.092]     }
[17:46:21.092]     ...future.result <- base::tryCatch({
[17:46:21.092]         base::withCallingHandlers({
[17:46:21.092]             ...future.value <- base::withVisible(base::local({
[17:46:21.092]                 do.call(function(...) {
[17:46:21.092]                   fcn <- function() sum(...)
[17:46:21.092]                   fcn()
[17:46:21.092]                 }, args = future.call.arguments)
[17:46:21.092]             }))
[17:46:21.092]             future::FutureResult(value = ...future.value$value, 
[17:46:21.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.092]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.092]                     ...future.globalenv.names))
[17:46:21.092]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.092]         }, condition = base::local({
[17:46:21.092]             c <- base::c
[17:46:21.092]             inherits <- base::inherits
[17:46:21.092]             invokeRestart <- base::invokeRestart
[17:46:21.092]             length <- base::length
[17:46:21.092]             list <- base::list
[17:46:21.092]             seq.int <- base::seq.int
[17:46:21.092]             signalCondition <- base::signalCondition
[17:46:21.092]             sys.calls <- base::sys.calls
[17:46:21.092]             `[[` <- base::`[[`
[17:46:21.092]             `+` <- base::`+`
[17:46:21.092]             `<<-` <- base::`<<-`
[17:46:21.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.092]                   3L)]
[17:46:21.092]             }
[17:46:21.092]             function(cond) {
[17:46:21.092]                 is_error <- inherits(cond, "error")
[17:46:21.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.092]                   NULL)
[17:46:21.092]                 if (is_error) {
[17:46:21.092]                   sessionInformation <- function() {
[17:46:21.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.092]                       search = base::search(), system = base::Sys.info())
[17:46:21.092]                   }
[17:46:21.092]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.092]                     cond$call), session = sessionInformation(), 
[17:46:21.092]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.092]                   signalCondition(cond)
[17:46:21.092]                 }
[17:46:21.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.092]                 "immediateCondition"))) {
[17:46:21.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.092]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.092]                   if (TRUE && !signal) {
[17:46:21.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.092]                     {
[17:46:21.092]                       inherits <- base::inherits
[17:46:21.092]                       invokeRestart <- base::invokeRestart
[17:46:21.092]                       is.null <- base::is.null
[17:46:21.092]                       muffled <- FALSE
[17:46:21.092]                       if (inherits(cond, "message")) {
[17:46:21.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.092]                         if (muffled) 
[17:46:21.092]                           invokeRestart("muffleMessage")
[17:46:21.092]                       }
[17:46:21.092]                       else if (inherits(cond, "warning")) {
[17:46:21.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.092]                         if (muffled) 
[17:46:21.092]                           invokeRestart("muffleWarning")
[17:46:21.092]                       }
[17:46:21.092]                       else if (inherits(cond, "condition")) {
[17:46:21.092]                         if (!is.null(pattern)) {
[17:46:21.092]                           computeRestarts <- base::computeRestarts
[17:46:21.092]                           grepl <- base::grepl
[17:46:21.092]                           restarts <- computeRestarts(cond)
[17:46:21.092]                           for (restart in restarts) {
[17:46:21.092]                             name <- restart$name
[17:46:21.092]                             if (is.null(name)) 
[17:46:21.092]                               next
[17:46:21.092]                             if (!grepl(pattern, name)) 
[17:46:21.092]                               next
[17:46:21.092]                             invokeRestart(restart)
[17:46:21.092]                             muffled <- TRUE
[17:46:21.092]                             break
[17:46:21.092]                           }
[17:46:21.092]                         }
[17:46:21.092]                       }
[17:46:21.092]                       invisible(muffled)
[17:46:21.092]                     }
[17:46:21.092]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.092]                   }
[17:46:21.092]                 }
[17:46:21.092]                 else {
[17:46:21.092]                   if (TRUE) {
[17:46:21.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.092]                     {
[17:46:21.092]                       inherits <- base::inherits
[17:46:21.092]                       invokeRestart <- base::invokeRestart
[17:46:21.092]                       is.null <- base::is.null
[17:46:21.092]                       muffled <- FALSE
[17:46:21.092]                       if (inherits(cond, "message")) {
[17:46:21.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.092]                         if (muffled) 
[17:46:21.092]                           invokeRestart("muffleMessage")
[17:46:21.092]                       }
[17:46:21.092]                       else if (inherits(cond, "warning")) {
[17:46:21.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.092]                         if (muffled) 
[17:46:21.092]                           invokeRestart("muffleWarning")
[17:46:21.092]                       }
[17:46:21.092]                       else if (inherits(cond, "condition")) {
[17:46:21.092]                         if (!is.null(pattern)) {
[17:46:21.092]                           computeRestarts <- base::computeRestarts
[17:46:21.092]                           grepl <- base::grepl
[17:46:21.092]                           restarts <- computeRestarts(cond)
[17:46:21.092]                           for (restart in restarts) {
[17:46:21.092]                             name <- restart$name
[17:46:21.092]                             if (is.null(name)) 
[17:46:21.092]                               next
[17:46:21.092]                             if (!grepl(pattern, name)) 
[17:46:21.092]                               next
[17:46:21.092]                             invokeRestart(restart)
[17:46:21.092]                             muffled <- TRUE
[17:46:21.092]                             break
[17:46:21.092]                           }
[17:46:21.092]                         }
[17:46:21.092]                       }
[17:46:21.092]                       invisible(muffled)
[17:46:21.092]                     }
[17:46:21.092]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.092]                   }
[17:46:21.092]                 }
[17:46:21.092]             }
[17:46:21.092]         }))
[17:46:21.092]     }, error = function(ex) {
[17:46:21.092]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.092]                 ...future.rng), started = ...future.startTime, 
[17:46:21.092]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.092]             version = "1.8"), class = "FutureResult")
[17:46:21.092]     }, finally = {
[17:46:21.092]         if (!identical(...future.workdir, getwd())) 
[17:46:21.092]             setwd(...future.workdir)
[17:46:21.092]         {
[17:46:21.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.092]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.092]             }
[17:46:21.092]             base::options(...future.oldOptions)
[17:46:21.092]             if (.Platform$OS.type == "windows") {
[17:46:21.092]                 old_names <- names(...future.oldEnvVars)
[17:46:21.092]                 envs <- base::Sys.getenv()
[17:46:21.092]                 names <- names(envs)
[17:46:21.092]                 common <- intersect(names, old_names)
[17:46:21.092]                 added <- setdiff(names, old_names)
[17:46:21.092]                 removed <- setdiff(old_names, names)
[17:46:21.092]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.092]                   envs[common]]
[17:46:21.092]                 NAMES <- toupper(changed)
[17:46:21.092]                 args <- list()
[17:46:21.092]                 for (kk in seq_along(NAMES)) {
[17:46:21.092]                   name <- changed[[kk]]
[17:46:21.092]                   NAME <- NAMES[[kk]]
[17:46:21.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.092]                     next
[17:46:21.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.092]                 }
[17:46:21.092]                 NAMES <- toupper(added)
[17:46:21.092]                 for (kk in seq_along(NAMES)) {
[17:46:21.092]                   name <- added[[kk]]
[17:46:21.092]                   NAME <- NAMES[[kk]]
[17:46:21.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.092]                     next
[17:46:21.092]                   args[[name]] <- ""
[17:46:21.092]                 }
[17:46:21.092]                 NAMES <- toupper(removed)
[17:46:21.092]                 for (kk in seq_along(NAMES)) {
[17:46:21.092]                   name <- removed[[kk]]
[17:46:21.092]                   NAME <- NAMES[[kk]]
[17:46:21.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.092]                     next
[17:46:21.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.092]                 }
[17:46:21.092]                 if (length(args) > 0) 
[17:46:21.092]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.092]             }
[17:46:21.092]             else {
[17:46:21.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.092]             }
[17:46:21.092]             {
[17:46:21.092]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.092]                   0L) {
[17:46:21.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.092]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.092]                   base::options(opts)
[17:46:21.092]                 }
[17:46:21.092]                 {
[17:46:21.092]                   {
[17:46:21.092]                     NULL
[17:46:21.092]                     RNGkind("Mersenne-Twister")
[17:46:21.092]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:21.092]                       inherits = FALSE)
[17:46:21.092]                   }
[17:46:21.092]                   options(future.plan = NULL)
[17:46:21.092]                   if (is.na(NA_character_)) 
[17:46:21.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.092]                     .init = FALSE)
[17:46:21.092]                 }
[17:46:21.092]             }
[17:46:21.092]         }
[17:46:21.092]     })
[17:46:21.092]     if (TRUE) {
[17:46:21.092]         base::sink(type = "output", split = FALSE)
[17:46:21.092]         if (TRUE) {
[17:46:21.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.092]         }
[17:46:21.092]         else {
[17:46:21.092]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.092]         }
[17:46:21.092]         base::close(...future.stdout)
[17:46:21.092]         ...future.stdout <- NULL
[17:46:21.092]     }
[17:46:21.092]     ...future.result$conditions <- ...future.conditions
[17:46:21.092]     ...future.result$finished <- base::Sys.time()
[17:46:21.092]     ...future.result
[17:46:21.092] }
[17:46:21.093] assign_globals() ...
[17:46:21.093] List of 1
[17:46:21.093]  $ future.call.arguments:List of 2
[17:46:21.093]   ..$ : int [1:2] 1 2
[17:46:21.093]   ..$ : num 3
[17:46:21.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:46:21.093]  - attr(*, "where")=List of 1
[17:46:21.093]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:46:21.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.093]  - attr(*, "resolved")= logi FALSE
[17:46:21.093]  - attr(*, "total_size")= num 112
[17:46:21.093]  - attr(*, "already-done")= logi TRUE
[17:46:21.096] - copied ‘future.call.arguments’ to environment
[17:46:21.097] assign_globals() ... done
[17:46:21.097] plan(): Setting new future strategy stack:
[17:46:21.097] List of future strategies:
[17:46:21.097] 1. sequential:
[17:46:21.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.097]    - tweaked: FALSE
[17:46:21.097]    - call: NULL
[17:46:21.097] plan(): nbrOfWorkers() = 1
[17:46:21.098] plan(): Setting new future strategy stack:
[17:46:21.098] List of future strategies:
[17:46:21.098] 1. sequential:
[17:46:21.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.098]    - tweaked: FALSE
[17:46:21.098]    - call: plan(strategy, substitute = FALSE)
[17:46:21.098] plan(): nbrOfWorkers() = 1
[17:46:21.099] SequentialFuture started (and completed)
[17:46:21.099] - Launch lazy future ... done
[17:46:21.099] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'F' with plan('sequential') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55a9ff52fd68>
Using '...' in a formula
[17:46:21.099] getGlobalsAndPackages() ...
[17:46:21.099] Searching for globals...
[17:46:21.102] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘...’, ‘sum’
[17:46:21.102] Searching for globals ... DONE
[17:46:21.102] Resolving globals: FALSE
[17:46:21.102] Tweak future expression to call with '...' arguments ...
[17:46:21.103] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[17:46:21.103] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:21.103] - globals: [3] ‘fcn’, ‘x’, ‘y’
[17:46:21.104] 
[17:46:21.104] getGlobalsAndPackages() ... DONE
[17:46:21.104] run() for ‘Future’ ...
[17:46:21.104] - state: ‘created’
[17:46:21.104] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:46:21.104] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:46:21.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:46:21.105]   - Field: ‘label’
[17:46:21.105]   - Field: ‘local’
[17:46:21.105]   - Field: ‘owner’
[17:46:21.105]   - Field: ‘envir’
[17:46:21.105]   - Field: ‘packages’
[17:46:21.105]   - Field: ‘gc’
[17:46:21.105]   - Field: ‘conditions’
[17:46:21.105]   - Field: ‘expr’
[17:46:21.105]   - Field: ‘uuid’
[17:46:21.105]   - Field: ‘seed’
[17:46:21.105]   - Field: ‘version’
[17:46:21.106]   - Field: ‘result’
[17:46:21.106]   - Field: ‘asynchronous’
[17:46:21.106]   - Field: ‘calls’
[17:46:21.106]   - Field: ‘globals’
[17:46:21.106]   - Field: ‘stdout’
[17:46:21.106]   - Field: ‘earlySignal’
[17:46:21.106]   - Field: ‘lazy’
[17:46:21.106]   - Field: ‘state’
[17:46:21.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:46:21.106] - Launch lazy future ...
[17:46:21.106] Packages needed by the future expression (n = 0): <none>
[17:46:21.107] Packages needed by future strategies (n = 0): <none>
[17:46:21.107] {
[17:46:21.107]     {
[17:46:21.107]         {
[17:46:21.107]             ...future.startTime <- base::Sys.time()
[17:46:21.107]             {
[17:46:21.107]                 {
[17:46:21.107]                   {
[17:46:21.107]                     base::local({
[17:46:21.107]                       has_future <- base::requireNamespace("future", 
[17:46:21.107]                         quietly = TRUE)
[17:46:21.107]                       if (has_future) {
[17:46:21.107]                         ns <- base::getNamespace("future")
[17:46:21.107]                         version <- ns[[".package"]][["version"]]
[17:46:21.107]                         if (is.null(version)) 
[17:46:21.107]                           version <- utils::packageVersion("future")
[17:46:21.107]                       }
[17:46:21.107]                       else {
[17:46:21.107]                         version <- NULL
[17:46:21.107]                       }
[17:46:21.107]                       if (!has_future || version < "1.8.0") {
[17:46:21.107]                         info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.107]                           "", base::R.version$version.string), 
[17:46:21.107]                           platform = base::sprintf("%s (%s-bit)", 
[17:46:21.107]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.107]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.107]                             "release", "version")], collapse = " "), 
[17:46:21.107]                           hostname = base::Sys.info()[["nodename"]])
[17:46:21.107]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.107]                           info)
[17:46:21.107]                         info <- base::paste(info, collapse = "; ")
[17:46:21.107]                         if (!has_future) {
[17:46:21.107]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.107]                             info)
[17:46:21.107]                         }
[17:46:21.107]                         else {
[17:46:21.107]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.107]                             info, version)
[17:46:21.107]                         }
[17:46:21.107]                         base::stop(msg)
[17:46:21.107]                       }
[17:46:21.107]                     })
[17:46:21.107]                   }
[17:46:21.107]                   ...future.strategy.old <- future::plan("list")
[17:46:21.107]                   options(future.plan = NULL)
[17:46:21.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.107]                 }
[17:46:21.107]                 ...future.workdir <- getwd()
[17:46:21.107]             }
[17:46:21.107]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.107]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.107]         }
[17:46:21.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.107]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.107]             base::names(...future.oldOptions))
[17:46:21.107]     }
[17:46:21.107]     if (FALSE) {
[17:46:21.107]     }
[17:46:21.107]     else {
[17:46:21.107]         if (TRUE) {
[17:46:21.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.107]                 open = "w")
[17:46:21.107]         }
[17:46:21.107]         else {
[17:46:21.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.107]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.107]         }
[17:46:21.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.107]             base::sink(type = "output", split = FALSE)
[17:46:21.107]             base::close(...future.stdout)
[17:46:21.107]         }, add = TRUE)
[17:46:21.107]     }
[17:46:21.107]     ...future.frame <- base::sys.nframe()
[17:46:21.107]     ...future.conditions <- base::list()
[17:46:21.107]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.107]     if (FALSE) {
[17:46:21.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.107]     }
[17:46:21.107]     ...future.result <- base::tryCatch({
[17:46:21.107]         base::withCallingHandlers({
[17:46:21.107]             ...future.value <- base::withVisible(base::local(fcn(x, 
[17:46:21.107]                 y)))
[17:46:21.107]             future::FutureResult(value = ...future.value$value, 
[17:46:21.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.107]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.107]                     ...future.globalenv.names))
[17:46:21.107]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.107]         }, condition = base::local({
[17:46:21.107]             c <- base::c
[17:46:21.107]             inherits <- base::inherits
[17:46:21.107]             invokeRestart <- base::invokeRestart
[17:46:21.107]             length <- base::length
[17:46:21.107]             list <- base::list
[17:46:21.107]             seq.int <- base::seq.int
[17:46:21.107]             signalCondition <- base::signalCondition
[17:46:21.107]             sys.calls <- base::sys.calls
[17:46:21.107]             `[[` <- base::`[[`
[17:46:21.107]             `+` <- base::`+`
[17:46:21.107]             `<<-` <- base::`<<-`
[17:46:21.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.107]                   3L)]
[17:46:21.107]             }
[17:46:21.107]             function(cond) {
[17:46:21.107]                 is_error <- inherits(cond, "error")
[17:46:21.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.107]                   NULL)
[17:46:21.107]                 if (is_error) {
[17:46:21.107]                   sessionInformation <- function() {
[17:46:21.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.107]                       search = base::search(), system = base::Sys.info())
[17:46:21.107]                   }
[17:46:21.107]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.107]                     cond$call), session = sessionInformation(), 
[17:46:21.107]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.107]                   signalCondition(cond)
[17:46:21.107]                 }
[17:46:21.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.107]                 "immediateCondition"))) {
[17:46:21.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.107]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.107]                   if (TRUE && !signal) {
[17:46:21.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.107]                     {
[17:46:21.107]                       inherits <- base::inherits
[17:46:21.107]                       invokeRestart <- base::invokeRestart
[17:46:21.107]                       is.null <- base::is.null
[17:46:21.107]                       muffled <- FALSE
[17:46:21.107]                       if (inherits(cond, "message")) {
[17:46:21.107]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.107]                         if (muffled) 
[17:46:21.107]                           invokeRestart("muffleMessage")
[17:46:21.107]                       }
[17:46:21.107]                       else if (inherits(cond, "warning")) {
[17:46:21.107]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.107]                         if (muffled) 
[17:46:21.107]                           invokeRestart("muffleWarning")
[17:46:21.107]                       }
[17:46:21.107]                       else if (inherits(cond, "condition")) {
[17:46:21.107]                         if (!is.null(pattern)) {
[17:46:21.107]                           computeRestarts <- base::computeRestarts
[17:46:21.107]                           grepl <- base::grepl
[17:46:21.107]                           restarts <- computeRestarts(cond)
[17:46:21.107]                           for (restart in restarts) {
[17:46:21.107]                             name <- restart$name
[17:46:21.107]                             if (is.null(name)) 
[17:46:21.107]                               next
[17:46:21.107]                             if (!grepl(pattern, name)) 
[17:46:21.107]                               next
[17:46:21.107]                             invokeRestart(restart)
[17:46:21.107]                             muffled <- TRUE
[17:46:21.107]                             break
[17:46:21.107]                           }
[17:46:21.107]                         }
[17:46:21.107]                       }
[17:46:21.107]                       invisible(muffled)
[17:46:21.107]                     }
[17:46:21.107]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.107]                   }
[17:46:21.107]                 }
[17:46:21.107]                 else {
[17:46:21.107]                   if (TRUE) {
[17:46:21.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.107]                     {
[17:46:21.107]                       inherits <- base::inherits
[17:46:21.107]                       invokeRestart <- base::invokeRestart
[17:46:21.107]                       is.null <- base::is.null
[17:46:21.107]                       muffled <- FALSE
[17:46:21.107]                       if (inherits(cond, "message")) {
[17:46:21.107]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.107]                         if (muffled) 
[17:46:21.107]                           invokeRestart("muffleMessage")
[17:46:21.107]                       }
[17:46:21.107]                       else if (inherits(cond, "warning")) {
[17:46:21.107]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.107]                         if (muffled) 
[17:46:21.107]                           invokeRestart("muffleWarning")
[17:46:21.107]                       }
[17:46:21.107]                       else if (inherits(cond, "condition")) {
[17:46:21.107]                         if (!is.null(pattern)) {
[17:46:21.107]                           computeRestarts <- base::computeRestarts
[17:46:21.107]                           grepl <- base::grepl
[17:46:21.107]                           restarts <- computeRestarts(cond)
[17:46:21.107]                           for (restart in restarts) {
[17:46:21.107]                             name <- restart$name
[17:46:21.107]                             if (is.null(name)) 
[17:46:21.107]                               next
[17:46:21.107]                             if (!grepl(pattern, name)) 
[17:46:21.107]                               next
[17:46:21.107]                             invokeRestart(restart)
[17:46:21.107]                             muffled <- TRUE
[17:46:21.107]                             break
[17:46:21.107]                           }
[17:46:21.107]                         }
[17:46:21.107]                       }
[17:46:21.107]                       invisible(muffled)
[17:46:21.107]                     }
[17:46:21.107]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.107]                   }
[17:46:21.107]                 }
[17:46:21.107]             }
[17:46:21.107]         }))
[17:46:21.107]     }, error = function(ex) {
[17:46:21.107]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.107]                 ...future.rng), started = ...future.startTime, 
[17:46:21.107]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.107]             version = "1.8"), class = "FutureResult")
[17:46:21.107]     }, finally = {
[17:46:21.107]         if (!identical(...future.workdir, getwd())) 
[17:46:21.107]             setwd(...future.workdir)
[17:46:21.107]         {
[17:46:21.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.107]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.107]             }
[17:46:21.107]             base::options(...future.oldOptions)
[17:46:21.107]             if (.Platform$OS.type == "windows") {
[17:46:21.107]                 old_names <- names(...future.oldEnvVars)
[17:46:21.107]                 envs <- base::Sys.getenv()
[17:46:21.107]                 names <- names(envs)
[17:46:21.107]                 common <- intersect(names, old_names)
[17:46:21.107]                 added <- setdiff(names, old_names)
[17:46:21.107]                 removed <- setdiff(old_names, names)
[17:46:21.107]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.107]                   envs[common]]
[17:46:21.107]                 NAMES <- toupper(changed)
[17:46:21.107]                 args <- list()
[17:46:21.107]                 for (kk in seq_along(NAMES)) {
[17:46:21.107]                   name <- changed[[kk]]
[17:46:21.107]                   NAME <- NAMES[[kk]]
[17:46:21.107]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.107]                     next
[17:46:21.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.107]                 }
[17:46:21.107]                 NAMES <- toupper(added)
[17:46:21.107]                 for (kk in seq_along(NAMES)) {
[17:46:21.107]                   name <- added[[kk]]
[17:46:21.107]                   NAME <- NAMES[[kk]]
[17:46:21.107]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.107]                     next
[17:46:21.107]                   args[[name]] <- ""
[17:46:21.107]                 }
[17:46:21.107]                 NAMES <- toupper(removed)
[17:46:21.107]                 for (kk in seq_along(NAMES)) {
[17:46:21.107]                   name <- removed[[kk]]
[17:46:21.107]                   NAME <- NAMES[[kk]]
[17:46:21.107]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.107]                     next
[17:46:21.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.107]                 }
[17:46:21.107]                 if (length(args) > 0) 
[17:46:21.107]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.107]             }
[17:46:21.107]             else {
[17:46:21.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.107]             }
[17:46:21.107]             {
[17:46:21.107]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.107]                   0L) {
[17:46:21.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.107]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.107]                   base::options(opts)
[17:46:21.107]                 }
[17:46:21.107]                 {
[17:46:21.107]                   {
[17:46:21.107]                     NULL
[17:46:21.107]                     RNGkind("Mersenne-Twister")
[17:46:21.107]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:46:21.107]                       inherits = FALSE)
[17:46:21.107]                   }
[17:46:21.107]                   options(future.plan = NULL)
[17:46:21.107]                   if (is.na(NA_character_)) 
[17:46:21.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.107]                     .init = FALSE)
[17:46:21.107]                 }
[17:46:21.107]             }
[17:46:21.107]         }
[17:46:21.107]     })
[17:46:21.107]     if (TRUE) {
[17:46:21.107]         base::sink(type = "output", split = FALSE)
[17:46:21.107]         if (TRUE) {
[17:46:21.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.107]         }
[17:46:21.107]         else {
[17:46:21.107]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.107]         }
[17:46:21.107]         base::close(...future.stdout)
[17:46:21.107]         ...future.stdout <- NULL
[17:46:21.107]     }
[17:46:21.107]     ...future.result$conditions <- ...future.conditions
[17:46:21.107]     ...future.result$finished <- base::Sys.time()
[17:46:21.107]     ...future.result
[17:46:21.107] }
[17:46:21.109] assign_globals() ...
[17:46:21.109] List of 3
[17:46:21.109]  $ fcn:function (x, y)  
[17:46:21.109]  $ x  : int [1:2] 1 2
[17:46:21.109]  $ y  : num 3
[17:46:21.109]  - attr(*, "where")=List of 3
[17:46:21.109]   ..$ fcn:<environment: R_EmptyEnv> 
[17:46:21.109]   ..$ x  :<environment: R_EmptyEnv> 
[17:46:21.109]   ..$ y  :<environment: R_EmptyEnv> 
[17:46:21.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.109]  - attr(*, "resolved")= logi FALSE
[17:46:21.109]  - attr(*, "total_size")= num 4280
[17:46:21.109]  - attr(*, "already-done")= logi TRUE
[17:46:21.112] - reassign environment for ‘fcn’
[17:46:21.112] - copied ‘fcn’ to environment
[17:46:21.112] - copied ‘x’ to environment
[17:46:21.112] - copied ‘y’ to environment
[17:46:21.112] assign_globals() ... done
[17:46:21.113] plan(): Setting new future strategy stack:
[17:46:21.113] List of future strategies:
[17:46:21.113] 1. sequential:
[17:46:21.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.113]    - tweaked: FALSE
[17:46:21.113]    - call: NULL
[17:46:21.114] plan(): nbrOfWorkers() = 1
[17:46:21.115] plan(): Setting new future strategy stack:
[17:46:21.115] List of future strategies:
[17:46:21.115] 1. sequential:
[17:46:21.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.115]    - tweaked: FALSE
[17:46:21.115]    - call: plan(strategy, substitute = FALSE)
[17:46:21.116] plan(): nbrOfWorkers() = 1
[17:46:21.116] SequentialFuture started (and completed)
[17:46:21.116] - Launch lazy future ... done
[17:46:21.116] run() for ‘SequentialFuture’ ... done
[1] 6
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** Global argument '...' ...
- plan('multicore') ...
[17:46:21.121] plan(): Setting new future strategy stack:
[17:46:21.121] List of future strategies:
[17:46:21.121] 1. multicore:
[17:46:21.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.121]    - tweaked: FALSE
[17:46:21.121]    - call: plan(strategy, substitute = FALSE)
[17:46:21.125] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multicore') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55aa0080c960>
Arguments '...' exists: TRUE
[17:46:21.126] getGlobalsAndPackages() ...
[17:46:21.126] Searching for globals...
[17:46:21.127] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:46:21.127] Searching for globals ... DONE
[17:46:21.127] Resolving globals: FALSE
[17:46:21.128] Tweak future expression to call with '...' arguments ...
[17:46:21.128] {
[17:46:21.128]     do.call(function(...) {
[17:46:21.128]         sum(x, ...)
[17:46:21.128]     }, args = future.call.arguments)
[17:46:21.128] }
[17:46:21.128] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.128] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.129] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:46:21.129] - globals: [2] ‘x’, ‘future.call.arguments’
[17:46:21.129] 
[17:46:21.129] getGlobalsAndPackages() ... DONE
[17:46:21.129] run() for ‘Future’ ...
[17:46:21.129] - state: ‘created’
[17:46:21.130] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.133] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:21.133]   - Field: ‘label’
[17:46:21.133]   - Field: ‘local’
[17:46:21.133]   - Field: ‘owner’
[17:46:21.133]   - Field: ‘envir’
[17:46:21.134]   - Field: ‘workers’
[17:46:21.134]   - Field: ‘packages’
[17:46:21.134]   - Field: ‘gc’
[17:46:21.134]   - Field: ‘job’
[17:46:21.134]   - Field: ‘conditions’
[17:46:21.134]   - Field: ‘expr’
[17:46:21.134]   - Field: ‘uuid’
[17:46:21.134]   - Field: ‘seed’
[17:46:21.134]   - Field: ‘version’
[17:46:21.134]   - Field: ‘result’
[17:46:21.134]   - Field: ‘asynchronous’
[17:46:21.134]   - Field: ‘calls’
[17:46:21.135]   - Field: ‘globals’
[17:46:21.135]   - Field: ‘stdout’
[17:46:21.135]   - Field: ‘earlySignal’
[17:46:21.135]   - Field: ‘lazy’
[17:46:21.135]   - Field: ‘state’
[17:46:21.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:21.135] - Launch lazy future ...
[17:46:21.136] Packages needed by the future expression (n = 0): <none>
[17:46:21.136] Packages needed by future strategies (n = 0): <none>
[17:46:21.137] {
[17:46:21.137]     {
[17:46:21.137]         {
[17:46:21.137]             ...future.startTime <- base::Sys.time()
[17:46:21.137]             {
[17:46:21.137]                 {
[17:46:21.137]                   {
[17:46:21.137]                     {
[17:46:21.137]                       base::local({
[17:46:21.137]                         has_future <- base::requireNamespace("future", 
[17:46:21.137]                           quietly = TRUE)
[17:46:21.137]                         if (has_future) {
[17:46:21.137]                           ns <- base::getNamespace("future")
[17:46:21.137]                           version <- ns[[".package"]][["version"]]
[17:46:21.137]                           if (is.null(version)) 
[17:46:21.137]                             version <- utils::packageVersion("future")
[17:46:21.137]                         }
[17:46:21.137]                         else {
[17:46:21.137]                           version <- NULL
[17:46:21.137]                         }
[17:46:21.137]                         if (!has_future || version < "1.8.0") {
[17:46:21.137]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.137]                             "", base::R.version$version.string), 
[17:46:21.137]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.137]                               "release", "version")], collapse = " "), 
[17:46:21.137]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.137]                             info)
[17:46:21.137]                           info <- base::paste(info, collapse = "; ")
[17:46:21.137]                           if (!has_future) {
[17:46:21.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.137]                               info)
[17:46:21.137]                           }
[17:46:21.137]                           else {
[17:46:21.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.137]                               info, version)
[17:46:21.137]                           }
[17:46:21.137]                           base::stop(msg)
[17:46:21.137]                         }
[17:46:21.137]                       })
[17:46:21.137]                     }
[17:46:21.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.137]                     base::options(mc.cores = 1L)
[17:46:21.137]                   }
[17:46:21.137]                   ...future.strategy.old <- future::plan("list")
[17:46:21.137]                   options(future.plan = NULL)
[17:46:21.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.137]                 }
[17:46:21.137]                 ...future.workdir <- getwd()
[17:46:21.137]             }
[17:46:21.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.137]         }
[17:46:21.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.137]             base::names(...future.oldOptions))
[17:46:21.137]     }
[17:46:21.137]     if (FALSE) {
[17:46:21.137]     }
[17:46:21.137]     else {
[17:46:21.137]         if (TRUE) {
[17:46:21.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.137]                 open = "w")
[17:46:21.137]         }
[17:46:21.137]         else {
[17:46:21.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.137]         }
[17:46:21.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.137]             base::sink(type = "output", split = FALSE)
[17:46:21.137]             base::close(...future.stdout)
[17:46:21.137]         }, add = TRUE)
[17:46:21.137]     }
[17:46:21.137]     ...future.frame <- base::sys.nframe()
[17:46:21.137]     ...future.conditions <- base::list()
[17:46:21.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.137]     if (FALSE) {
[17:46:21.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.137]     }
[17:46:21.137]     ...future.result <- base::tryCatch({
[17:46:21.137]         base::withCallingHandlers({
[17:46:21.137]             ...future.value <- base::withVisible(base::local({
[17:46:21.137]                 withCallingHandlers({
[17:46:21.137]                   {
[17:46:21.137]                     do.call(function(...) {
[17:46:21.137]                       sum(x, ...)
[17:46:21.137]                     }, args = future.call.arguments)
[17:46:21.137]                   }
[17:46:21.137]                 }, immediateCondition = function(cond) {
[17:46:21.137]                   save_rds <- function (object, pathname, ...) 
[17:46:21.137]                   {
[17:46:21.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:21.137]                     if (file_test("-f", pathname_tmp)) {
[17:46:21.137]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:21.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.137]                         fi_tmp[["mtime"]])
[17:46:21.137]                     }
[17:46:21.137]                     tryCatch({
[17:46:21.137]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:21.137]                     }, error = function(ex) {
[17:46:21.137]                       msg <- conditionMessage(ex)
[17:46:21.137]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:21.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.137]                         fi_tmp[["mtime"]], msg)
[17:46:21.137]                       ex$message <- msg
[17:46:21.137]                       stop(ex)
[17:46:21.137]                     })
[17:46:21.137]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:21.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:21.137]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:21.137]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.137]                       fi <- file.info(pathname)
[17:46:21.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:21.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:21.137]                         fi[["size"]], fi[["mtime"]])
[17:46:21.137]                       stop(msg)
[17:46:21.137]                     }
[17:46:21.137]                     invisible(pathname)
[17:46:21.137]                   }
[17:46:21.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:21.137]                     rootPath = tempdir()) 
[17:46:21.137]                   {
[17:46:21.137]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:21.137]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:21.137]                       tmpdir = path, fileext = ".rds")
[17:46:21.137]                     save_rds(obj, file)
[17:46:21.137]                   }
[17:46:21.137]                   saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")
[17:46:21.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.137]                   {
[17:46:21.137]                     inherits <- base::inherits
[17:46:21.137]                     invokeRestart <- base::invokeRestart
[17:46:21.137]                     is.null <- base::is.null
[17:46:21.137]                     muffled <- FALSE
[17:46:21.137]                     if (inherits(cond, "message")) {
[17:46:21.137]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.137]                       if (muffled) 
[17:46:21.137]                         invokeRestart("muffleMessage")
[17:46:21.137]                     }
[17:46:21.137]                     else if (inherits(cond, "warning")) {
[17:46:21.137]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.137]                       if (muffled) 
[17:46:21.137]                         invokeRestart("muffleWarning")
[17:46:21.137]                     }
[17:46:21.137]                     else if (inherits(cond, "condition")) {
[17:46:21.137]                       if (!is.null(pattern)) {
[17:46:21.137]                         computeRestarts <- base::computeRestarts
[17:46:21.137]                         grepl <- base::grepl
[17:46:21.137]                         restarts <- computeRestarts(cond)
[17:46:21.137]                         for (restart in restarts) {
[17:46:21.137]                           name <- restart$name
[17:46:21.137]                           if (is.null(name)) 
[17:46:21.137]                             next
[17:46:21.137]                           if (!grepl(pattern, name)) 
[17:46:21.137]                             next
[17:46:21.137]                           invokeRestart(restart)
[17:46:21.137]                           muffled <- TRUE
[17:46:21.137]                           break
[17:46:21.137]                         }
[17:46:21.137]                       }
[17:46:21.137]                     }
[17:46:21.137]                     invisible(muffled)
[17:46:21.137]                   }
[17:46:21.137]                   muffleCondition(cond)
[17:46:21.137]                 })
[17:46:21.137]             }))
[17:46:21.137]             future::FutureResult(value = ...future.value$value, 
[17:46:21.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.137]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.137]                     ...future.globalenv.names))
[17:46:21.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.137]         }, condition = base::local({
[17:46:21.137]             c <- base::c
[17:46:21.137]             inherits <- base::inherits
[17:46:21.137]             invokeRestart <- base::invokeRestart
[17:46:21.137]             length <- base::length
[17:46:21.137]             list <- base::list
[17:46:21.137]             seq.int <- base::seq.int
[17:46:21.137]             signalCondition <- base::signalCondition
[17:46:21.137]             sys.calls <- base::sys.calls
[17:46:21.137]             `[[` <- base::`[[`
[17:46:21.137]             `+` <- base::`+`
[17:46:21.137]             `<<-` <- base::`<<-`
[17:46:21.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.137]                   3L)]
[17:46:21.137]             }
[17:46:21.137]             function(cond) {
[17:46:21.137]                 is_error <- inherits(cond, "error")
[17:46:21.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.137]                   NULL)
[17:46:21.137]                 if (is_error) {
[17:46:21.137]                   sessionInformation <- function() {
[17:46:21.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.137]                       search = base::search(), system = base::Sys.info())
[17:46:21.137]                   }
[17:46:21.137]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.137]                     cond$call), session = sessionInformation(), 
[17:46:21.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.137]                   signalCondition(cond)
[17:46:21.137]                 }
[17:46:21.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.137]                 "immediateCondition"))) {
[17:46:21.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.137]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.137]                   if (TRUE && !signal) {
[17:46:21.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.137]                     {
[17:46:21.137]                       inherits <- base::inherits
[17:46:21.137]                       invokeRestart <- base::invokeRestart
[17:46:21.137]                       is.null <- base::is.null
[17:46:21.137]                       muffled <- FALSE
[17:46:21.137]                       if (inherits(cond, "message")) {
[17:46:21.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.137]                         if (muffled) 
[17:46:21.137]                           invokeRestart("muffleMessage")
[17:46:21.137]                       }
[17:46:21.137]                       else if (inherits(cond, "warning")) {
[17:46:21.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.137]                         if (muffled) 
[17:46:21.137]                           invokeRestart("muffleWarning")
[17:46:21.137]                       }
[17:46:21.137]                       else if (inherits(cond, "condition")) {
[17:46:21.137]                         if (!is.null(pattern)) {
[17:46:21.137]                           computeRestarts <- base::computeRestarts
[17:46:21.137]                           grepl <- base::grepl
[17:46:21.137]                           restarts <- computeRestarts(cond)
[17:46:21.137]                           for (restart in restarts) {
[17:46:21.137]                             name <- restart$name
[17:46:21.137]                             if (is.null(name)) 
[17:46:21.137]                               next
[17:46:21.137]                             if (!grepl(pattern, name)) 
[17:46:21.137]                               next
[17:46:21.137]                             invokeRestart(restart)
[17:46:21.137]                             muffled <- TRUE
[17:46:21.137]                             break
[17:46:21.137]                           }
[17:46:21.137]                         }
[17:46:21.137]                       }
[17:46:21.137]                       invisible(muffled)
[17:46:21.137]                     }
[17:46:21.137]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.137]                   }
[17:46:21.137]                 }
[17:46:21.137]                 else {
[17:46:21.137]                   if (TRUE) {
[17:46:21.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.137]                     {
[17:46:21.137]                       inherits <- base::inherits
[17:46:21.137]                       invokeRestart <- base::invokeRestart
[17:46:21.137]                       is.null <- base::is.null
[17:46:21.137]                       muffled <- FALSE
[17:46:21.137]                       if (inherits(cond, "message")) {
[17:46:21.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.137]                         if (muffled) 
[17:46:21.137]                           invokeRestart("muffleMessage")
[17:46:21.137]                       }
[17:46:21.137]                       else if (inherits(cond, "warning")) {
[17:46:21.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.137]                         if (muffled) 
[17:46:21.137]                           invokeRestart("muffleWarning")
[17:46:21.137]                       }
[17:46:21.137]                       else if (inherits(cond, "condition")) {
[17:46:21.137]                         if (!is.null(pattern)) {
[17:46:21.137]                           computeRestarts <- base::computeRestarts
[17:46:21.137]                           grepl <- base::grepl
[17:46:21.137]                           restarts <- computeRestarts(cond)
[17:46:21.137]                           for (restart in restarts) {
[17:46:21.137]                             name <- restart$name
[17:46:21.137]                             if (is.null(name)) 
[17:46:21.137]                               next
[17:46:21.137]                             if (!grepl(pattern, name)) 
[17:46:21.137]                               next
[17:46:21.137]                             invokeRestart(restart)
[17:46:21.137]                             muffled <- TRUE
[17:46:21.137]                             break
[17:46:21.137]                           }
[17:46:21.137]                         }
[17:46:21.137]                       }
[17:46:21.137]                       invisible(muffled)
[17:46:21.137]                     }
[17:46:21.137]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.137]                   }
[17:46:21.137]                 }
[17:46:21.137]             }
[17:46:21.137]         }))
[17:46:21.137]     }, error = function(ex) {
[17:46:21.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.137]                 ...future.rng), started = ...future.startTime, 
[17:46:21.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.137]             version = "1.8"), class = "FutureResult")
[17:46:21.137]     }, finally = {
[17:46:21.137]         if (!identical(...future.workdir, getwd())) 
[17:46:21.137]             setwd(...future.workdir)
[17:46:21.137]         {
[17:46:21.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.137]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.137]             }
[17:46:21.137]             base::options(...future.oldOptions)
[17:46:21.137]             if (.Platform$OS.type == "windows") {
[17:46:21.137]                 old_names <- names(...future.oldEnvVars)
[17:46:21.137]                 envs <- base::Sys.getenv()
[17:46:21.137]                 names <- names(envs)
[17:46:21.137]                 common <- intersect(names, old_names)
[17:46:21.137]                 added <- setdiff(names, old_names)
[17:46:21.137]                 removed <- setdiff(old_names, names)
[17:46:21.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.137]                   envs[common]]
[17:46:21.137]                 NAMES <- toupper(changed)
[17:46:21.137]                 args <- list()
[17:46:21.137]                 for (kk in seq_along(NAMES)) {
[17:46:21.137]                   name <- changed[[kk]]
[17:46:21.137]                   NAME <- NAMES[[kk]]
[17:46:21.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.137]                     next
[17:46:21.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.137]                 }
[17:46:21.137]                 NAMES <- toupper(added)
[17:46:21.137]                 for (kk in seq_along(NAMES)) {
[17:46:21.137]                   name <- added[[kk]]
[17:46:21.137]                   NAME <- NAMES[[kk]]
[17:46:21.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.137]                     next
[17:46:21.137]                   args[[name]] <- ""
[17:46:21.137]                 }
[17:46:21.137]                 NAMES <- toupper(removed)
[17:46:21.137]                 for (kk in seq_along(NAMES)) {
[17:46:21.137]                   name <- removed[[kk]]
[17:46:21.137]                   NAME <- NAMES[[kk]]
[17:46:21.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.137]                     next
[17:46:21.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.137]                 }
[17:46:21.137]                 if (length(args) > 0) 
[17:46:21.137]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.137]             }
[17:46:21.137]             else {
[17:46:21.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.137]             }
[17:46:21.137]             {
[17:46:21.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.137]                   0L) {
[17:46:21.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.137]                   base::options(opts)
[17:46:21.137]                 }
[17:46:21.137]                 {
[17:46:21.137]                   {
[17:46:21.137]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.137]                     NULL
[17:46:21.137]                   }
[17:46:21.137]                   options(future.plan = NULL)
[17:46:21.137]                   if (is.na(NA_character_)) 
[17:46:21.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.137]                     .init = FALSE)
[17:46:21.137]                 }
[17:46:21.137]             }
[17:46:21.137]         }
[17:46:21.137]     })
[17:46:21.137]     if (TRUE) {
[17:46:21.137]         base::sink(type = "output", split = FALSE)
[17:46:21.137]         if (TRUE) {
[17:46:21.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.137]         }
[17:46:21.137]         else {
[17:46:21.137]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.137]         }
[17:46:21.137]         base::close(...future.stdout)
[17:46:21.137]         ...future.stdout <- NULL
[17:46:21.137]     }
[17:46:21.137]     ...future.result$conditions <- ...future.conditions
[17:46:21.137]     ...future.result$finished <- base::Sys.time()
[17:46:21.137]     ...future.result
[17:46:21.137] }
[17:46:21.139] assign_globals() ...
[17:46:21.139] List of 2
[17:46:21.139]  $ x                    : int [1:2] 1 2
[17:46:21.139]  $ future.call.arguments:List of 1
[17:46:21.139]   ..$ : num 3
[17:46:21.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:46:21.139]  - attr(*, "where")=List of 2
[17:46:21.139]   ..$ x                    :<environment: R_EmptyEnv> 
[17:46:21.139]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:46:21.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.139]  - attr(*, "resolved")= logi FALSE
[17:46:21.139]  - attr(*, "total_size")= num 112
[17:46:21.139]  - attr(*, "already-done")= logi TRUE
[17:46:21.142] - copied ‘x’ to environment
[17:46:21.142] - copied ‘future.call.arguments’ to environment
[17:46:21.142] assign_globals() ... done
[17:46:21.142] requestCore(): workers = 2
[17:46:21.145] MulticoreFuture started
[17:46:21.146] - Launch lazy future ... done
[17:46:21.146] plan(): Setting new future strategy stack:
[17:46:21.146] run() for ‘MulticoreFuture’ ... done
[17:46:21.146] List of future strategies:
[17:46:21.146] 1. sequential:
[17:46:21.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.146]    - tweaked: FALSE
[17:46:21.146]    - call: NULL
[17:46:21.147] result() for MulticoreFuture ...
[17:46:21.147] plan(): nbrOfWorkers() = 1
[17:46:21.149] plan(): Setting new future strategy stack:
[17:46:21.149] List of future strategies:
[17:46:21.149] 1. multicore:
[17:46:21.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.149]    - tweaked: FALSE
[17:46:21.149]    - call: plan(strategy, substitute = FALSE)
[17:46:21.158] plan(): nbrOfWorkers() = 2
[17:46:21.165] result() for MulticoreFuture ...
[17:46:21.166] result() for MulticoreFuture ... done
[17:46:21.166] result() for MulticoreFuture ... done
[17:46:21.166] result() for MulticoreFuture ...
[17:46:21.166] result() for MulticoreFuture ... done
[1] 6
** Sum function 'B' with plan('multicore') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55aa00b943d8>
Arguments '...' exists: TRUE
[17:46:21.167] getGlobalsAndPackages() ...
[17:46:21.167] Searching for globals...
[17:46:21.169] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:46:21.169] Searching for globals ... DONE
[17:46:21.169] Resolving globals: FALSE
[17:46:21.169] Tweak future expression to call with '...' arguments ...
[17:46:21.169] {
[17:46:21.169]     do.call(function(...) {
[17:46:21.169]         sum(x, ...)
[17:46:21.169]     }, args = future.call.arguments)
[17:46:21.169] }
[17:46:21.170] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.170] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.171] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:46:21.171] - globals: [2] ‘x’, ‘future.call.arguments’
[17:46:21.171] 
[17:46:21.171] getGlobalsAndPackages() ... DONE
[17:46:21.171] run() for ‘Future’ ...
[17:46:21.172] - state: ‘created’
[17:46:21.172] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.175] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:21.176]   - Field: ‘label’
[17:46:21.176]   - Field: ‘local’
[17:46:21.176]   - Field: ‘owner’
[17:46:21.176]   - Field: ‘envir’
[17:46:21.176]   - Field: ‘workers’
[17:46:21.176]   - Field: ‘packages’
[17:46:21.176]   - Field: ‘gc’
[17:46:21.176]   - Field: ‘job’
[17:46:21.177]   - Field: ‘conditions’
[17:46:21.177]   - Field: ‘expr’
[17:46:21.177]   - Field: ‘uuid’
[17:46:21.177]   - Field: ‘seed’
[17:46:21.177]   - Field: ‘version’
[17:46:21.177]   - Field: ‘result’
[17:46:21.177]   - Field: ‘asynchronous’
[17:46:21.177]   - Field: ‘calls’
[17:46:21.177]   - Field: ‘globals’
[17:46:21.178]   - Field: ‘stdout’
[17:46:21.178]   - Field: ‘earlySignal’
[17:46:21.178]   - Field: ‘lazy’
[17:46:21.178]   - Field: ‘state’
[17:46:21.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:21.178] - Launch lazy future ...
[17:46:21.178] Packages needed by the future expression (n = 0): <none>
[17:46:21.178] Packages needed by future strategies (n = 0): <none>
[17:46:21.179] {
[17:46:21.179]     {
[17:46:21.179]         {
[17:46:21.179]             ...future.startTime <- base::Sys.time()
[17:46:21.179]             {
[17:46:21.179]                 {
[17:46:21.179]                   {
[17:46:21.179]                     {
[17:46:21.179]                       base::local({
[17:46:21.179]                         has_future <- base::requireNamespace("future", 
[17:46:21.179]                           quietly = TRUE)
[17:46:21.179]                         if (has_future) {
[17:46:21.179]                           ns <- base::getNamespace("future")
[17:46:21.179]                           version <- ns[[".package"]][["version"]]
[17:46:21.179]                           if (is.null(version)) 
[17:46:21.179]                             version <- utils::packageVersion("future")
[17:46:21.179]                         }
[17:46:21.179]                         else {
[17:46:21.179]                           version <- NULL
[17:46:21.179]                         }
[17:46:21.179]                         if (!has_future || version < "1.8.0") {
[17:46:21.179]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.179]                             "", base::R.version$version.string), 
[17:46:21.179]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.179]                               "release", "version")], collapse = " "), 
[17:46:21.179]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.179]                             info)
[17:46:21.179]                           info <- base::paste(info, collapse = "; ")
[17:46:21.179]                           if (!has_future) {
[17:46:21.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.179]                               info)
[17:46:21.179]                           }
[17:46:21.179]                           else {
[17:46:21.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.179]                               info, version)
[17:46:21.179]                           }
[17:46:21.179]                           base::stop(msg)
[17:46:21.179]                         }
[17:46:21.179]                       })
[17:46:21.179]                     }
[17:46:21.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.179]                     base::options(mc.cores = 1L)
[17:46:21.179]                   }
[17:46:21.179]                   ...future.strategy.old <- future::plan("list")
[17:46:21.179]                   options(future.plan = NULL)
[17:46:21.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.179]                 }
[17:46:21.179]                 ...future.workdir <- getwd()
[17:46:21.179]             }
[17:46:21.179]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.179]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.179]         }
[17:46:21.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.179]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.179]             base::names(...future.oldOptions))
[17:46:21.179]     }
[17:46:21.179]     if (FALSE) {
[17:46:21.179]     }
[17:46:21.179]     else {
[17:46:21.179]         if (TRUE) {
[17:46:21.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.179]                 open = "w")
[17:46:21.179]         }
[17:46:21.179]         else {
[17:46:21.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.179]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.179]         }
[17:46:21.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.179]             base::sink(type = "output", split = FALSE)
[17:46:21.179]             base::close(...future.stdout)
[17:46:21.179]         }, add = TRUE)
[17:46:21.179]     }
[17:46:21.179]     ...future.frame <- base::sys.nframe()
[17:46:21.179]     ...future.conditions <- base::list()
[17:46:21.179]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.179]     if (FALSE) {
[17:46:21.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.179]     }
[17:46:21.179]     ...future.result <- base::tryCatch({
[17:46:21.179]         base::withCallingHandlers({
[17:46:21.179]             ...future.value <- base::withVisible(base::local({
[17:46:21.179]                 withCallingHandlers({
[17:46:21.179]                   {
[17:46:21.179]                     do.call(function(...) {
[17:46:21.179]                       sum(x, ...)
[17:46:21.179]                     }, args = future.call.arguments)
[17:46:21.179]                   }
[17:46:21.179]                 }, immediateCondition = function(cond) {
[17:46:21.179]                   save_rds <- function (object, pathname, ...) 
[17:46:21.179]                   {
[17:46:21.179]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:21.179]                     if (file_test("-f", pathname_tmp)) {
[17:46:21.179]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.179]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:21.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.179]                         fi_tmp[["mtime"]])
[17:46:21.179]                     }
[17:46:21.179]                     tryCatch({
[17:46:21.179]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:21.179]                     }, error = function(ex) {
[17:46:21.179]                       msg <- conditionMessage(ex)
[17:46:21.179]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.179]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:21.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.179]                         fi_tmp[["mtime"]], msg)
[17:46:21.179]                       ex$message <- msg
[17:46:21.179]                       stop(ex)
[17:46:21.179]                     })
[17:46:21.179]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:21.179]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:21.179]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:21.179]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.179]                       fi <- file.info(pathname)
[17:46:21.179]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:21.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.179]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:21.179]                         fi[["size"]], fi[["mtime"]])
[17:46:21.179]                       stop(msg)
[17:46:21.179]                     }
[17:46:21.179]                     invisible(pathname)
[17:46:21.179]                   }
[17:46:21.179]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:21.179]                     rootPath = tempdir()) 
[17:46:21.179]                   {
[17:46:21.179]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:21.179]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:21.179]                       tmpdir = path, fileext = ".rds")
[17:46:21.179]                     save_rds(obj, file)
[17:46:21.179]                   }
[17:46:21.179]                   saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")
[17:46:21.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.179]                   {
[17:46:21.179]                     inherits <- base::inherits
[17:46:21.179]                     invokeRestart <- base::invokeRestart
[17:46:21.179]                     is.null <- base::is.null
[17:46:21.179]                     muffled <- FALSE
[17:46:21.179]                     if (inherits(cond, "message")) {
[17:46:21.179]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.179]                       if (muffled) 
[17:46:21.179]                         invokeRestart("muffleMessage")
[17:46:21.179]                     }
[17:46:21.179]                     else if (inherits(cond, "warning")) {
[17:46:21.179]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.179]                       if (muffled) 
[17:46:21.179]                         invokeRestart("muffleWarning")
[17:46:21.179]                     }
[17:46:21.179]                     else if (inherits(cond, "condition")) {
[17:46:21.179]                       if (!is.null(pattern)) {
[17:46:21.179]                         computeRestarts <- base::computeRestarts
[17:46:21.179]                         grepl <- base::grepl
[17:46:21.179]                         restarts <- computeRestarts(cond)
[17:46:21.179]                         for (restart in restarts) {
[17:46:21.179]                           name <- restart$name
[17:46:21.179]                           if (is.null(name)) 
[17:46:21.179]                             next
[17:46:21.179]                           if (!grepl(pattern, name)) 
[17:46:21.179]                             next
[17:46:21.179]                           invokeRestart(restart)
[17:46:21.179]                           muffled <- TRUE
[17:46:21.179]                           break
[17:46:21.179]                         }
[17:46:21.179]                       }
[17:46:21.179]                     }
[17:46:21.179]                     invisible(muffled)
[17:46:21.179]                   }
[17:46:21.179]                   muffleCondition(cond)
[17:46:21.179]                 })
[17:46:21.179]             }))
[17:46:21.179]             future::FutureResult(value = ...future.value$value, 
[17:46:21.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.179]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.179]                     ...future.globalenv.names))
[17:46:21.179]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.179]         }, condition = base::local({
[17:46:21.179]             c <- base::c
[17:46:21.179]             inherits <- base::inherits
[17:46:21.179]             invokeRestart <- base::invokeRestart
[17:46:21.179]             length <- base::length
[17:46:21.179]             list <- base::list
[17:46:21.179]             seq.int <- base::seq.int
[17:46:21.179]             signalCondition <- base::signalCondition
[17:46:21.179]             sys.calls <- base::sys.calls
[17:46:21.179]             `[[` <- base::`[[`
[17:46:21.179]             `+` <- base::`+`
[17:46:21.179]             `<<-` <- base::`<<-`
[17:46:21.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.179]                   3L)]
[17:46:21.179]             }
[17:46:21.179]             function(cond) {
[17:46:21.179]                 is_error <- inherits(cond, "error")
[17:46:21.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.179]                   NULL)
[17:46:21.179]                 if (is_error) {
[17:46:21.179]                   sessionInformation <- function() {
[17:46:21.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.179]                       search = base::search(), system = base::Sys.info())
[17:46:21.179]                   }
[17:46:21.179]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.179]                     cond$call), session = sessionInformation(), 
[17:46:21.179]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.179]                   signalCondition(cond)
[17:46:21.179]                 }
[17:46:21.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.179]                 "immediateCondition"))) {
[17:46:21.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.179]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.179]                   if (TRUE && !signal) {
[17:46:21.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.179]                     {
[17:46:21.179]                       inherits <- base::inherits
[17:46:21.179]                       invokeRestart <- base::invokeRestart
[17:46:21.179]                       is.null <- base::is.null
[17:46:21.179]                       muffled <- FALSE
[17:46:21.179]                       if (inherits(cond, "message")) {
[17:46:21.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.179]                         if (muffled) 
[17:46:21.179]                           invokeRestart("muffleMessage")
[17:46:21.179]                       }
[17:46:21.179]                       else if (inherits(cond, "warning")) {
[17:46:21.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.179]                         if (muffled) 
[17:46:21.179]                           invokeRestart("muffleWarning")
[17:46:21.179]                       }
[17:46:21.179]                       else if (inherits(cond, "condition")) {
[17:46:21.179]                         if (!is.null(pattern)) {
[17:46:21.179]                           computeRestarts <- base::computeRestarts
[17:46:21.179]                           grepl <- base::grepl
[17:46:21.179]                           restarts <- computeRestarts(cond)
[17:46:21.179]                           for (restart in restarts) {
[17:46:21.179]                             name <- restart$name
[17:46:21.179]                             if (is.null(name)) 
[17:46:21.179]                               next
[17:46:21.179]                             if (!grepl(pattern, name)) 
[17:46:21.179]                               next
[17:46:21.179]                             invokeRestart(restart)
[17:46:21.179]                             muffled <- TRUE
[17:46:21.179]                             break
[17:46:21.179]                           }
[17:46:21.179]                         }
[17:46:21.179]                       }
[17:46:21.179]                       invisible(muffled)
[17:46:21.179]                     }
[17:46:21.179]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.179]                   }
[17:46:21.179]                 }
[17:46:21.179]                 else {
[17:46:21.179]                   if (TRUE) {
[17:46:21.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.179]                     {
[17:46:21.179]                       inherits <- base::inherits
[17:46:21.179]                       invokeRestart <- base::invokeRestart
[17:46:21.179]                       is.null <- base::is.null
[17:46:21.179]                       muffled <- FALSE
[17:46:21.179]                       if (inherits(cond, "message")) {
[17:46:21.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.179]                         if (muffled) 
[17:46:21.179]                           invokeRestart("muffleMessage")
[17:46:21.179]                       }
[17:46:21.179]                       else if (inherits(cond, "warning")) {
[17:46:21.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.179]                         if (muffled) 
[17:46:21.179]                           invokeRestart("muffleWarning")
[17:46:21.179]                       }
[17:46:21.179]                       else if (inherits(cond, "condition")) {
[17:46:21.179]                         if (!is.null(pattern)) {
[17:46:21.179]                           computeRestarts <- base::computeRestarts
[17:46:21.179]                           grepl <- base::grepl
[17:46:21.179]                           restarts <- computeRestarts(cond)
[17:46:21.179]                           for (restart in restarts) {
[17:46:21.179]                             name <- restart$name
[17:46:21.179]                             if (is.null(name)) 
[17:46:21.179]                               next
[17:46:21.179]                             if (!grepl(pattern, name)) 
[17:46:21.179]                               next
[17:46:21.179]                             invokeRestart(restart)
[17:46:21.179]                             muffled <- TRUE
[17:46:21.179]                             break
[17:46:21.179]                           }
[17:46:21.179]                         }
[17:46:21.179]                       }
[17:46:21.179]                       invisible(muffled)
[17:46:21.179]                     }
[17:46:21.179]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.179]                   }
[17:46:21.179]                 }
[17:46:21.179]             }
[17:46:21.179]         }))
[17:46:21.179]     }, error = function(ex) {
[17:46:21.179]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.179]                 ...future.rng), started = ...future.startTime, 
[17:46:21.179]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.179]             version = "1.8"), class = "FutureResult")
[17:46:21.179]     }, finally = {
[17:46:21.179]         if (!identical(...future.workdir, getwd())) 
[17:46:21.179]             setwd(...future.workdir)
[17:46:21.179]         {
[17:46:21.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.179]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.179]             }
[17:46:21.179]             base::options(...future.oldOptions)
[17:46:21.179]             if (.Platform$OS.type == "windows") {
[17:46:21.179]                 old_names <- names(...future.oldEnvVars)
[17:46:21.179]                 envs <- base::Sys.getenv()
[17:46:21.179]                 names <- names(envs)
[17:46:21.179]                 common <- intersect(names, old_names)
[17:46:21.179]                 added <- setdiff(names, old_names)
[17:46:21.179]                 removed <- setdiff(old_names, names)
[17:46:21.179]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.179]                   envs[common]]
[17:46:21.179]                 NAMES <- toupper(changed)
[17:46:21.179]                 args <- list()
[17:46:21.179]                 for (kk in seq_along(NAMES)) {
[17:46:21.179]                   name <- changed[[kk]]
[17:46:21.179]                   NAME <- NAMES[[kk]]
[17:46:21.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.179]                     next
[17:46:21.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.179]                 }
[17:46:21.179]                 NAMES <- toupper(added)
[17:46:21.179]                 for (kk in seq_along(NAMES)) {
[17:46:21.179]                   name <- added[[kk]]
[17:46:21.179]                   NAME <- NAMES[[kk]]
[17:46:21.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.179]                     next
[17:46:21.179]                   args[[name]] <- ""
[17:46:21.179]                 }
[17:46:21.179]                 NAMES <- toupper(removed)
[17:46:21.179]                 for (kk in seq_along(NAMES)) {
[17:46:21.179]                   name <- removed[[kk]]
[17:46:21.179]                   NAME <- NAMES[[kk]]
[17:46:21.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.179]                     next
[17:46:21.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.179]                 }
[17:46:21.179]                 if (length(args) > 0) 
[17:46:21.179]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.179]             }
[17:46:21.179]             else {
[17:46:21.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.179]             }
[17:46:21.179]             {
[17:46:21.179]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.179]                   0L) {
[17:46:21.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.179]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.179]                   base::options(opts)
[17:46:21.179]                 }
[17:46:21.179]                 {
[17:46:21.179]                   {
[17:46:21.179]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.179]                     NULL
[17:46:21.179]                   }
[17:46:21.179]                   options(future.plan = NULL)
[17:46:21.179]                   if (is.na(NA_character_)) 
[17:46:21.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.179]                     .init = FALSE)
[17:46:21.179]                 }
[17:46:21.179]             }
[17:46:21.179]         }
[17:46:21.179]     })
[17:46:21.179]     if (TRUE) {
[17:46:21.179]         base::sink(type = "output", split = FALSE)
[17:46:21.179]         if (TRUE) {
[17:46:21.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.179]         }
[17:46:21.179]         else {
[17:46:21.179]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.179]         }
[17:46:21.179]         base::close(...future.stdout)
[17:46:21.179]         ...future.stdout <- NULL
[17:46:21.179]     }
[17:46:21.179]     ...future.result$conditions <- ...future.conditions
[17:46:21.179]     ...future.result$finished <- base::Sys.time()
[17:46:21.179]     ...future.result
[17:46:21.179] }
[17:46:21.181] assign_globals() ...
[17:46:21.181] List of 2
[17:46:21.181]  $ x                    : int [1:2] 1 2
[17:46:21.181]  $ future.call.arguments:List of 1
[17:46:21.181]   ..$ : num 3
[17:46:21.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:46:21.181]  - attr(*, "where")=List of 2
[17:46:21.181]   ..$ x                    :<environment: R_EmptyEnv> 
[17:46:21.181]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:46:21.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.181]  - attr(*, "resolved")= logi FALSE
[17:46:21.181]  - attr(*, "total_size")= num 112
[17:46:21.181]  - attr(*, "already-done")= logi TRUE
[17:46:21.185] - copied ‘x’ to environment
[17:46:21.186] - copied ‘future.call.arguments’ to environment
[17:46:21.186] assign_globals() ... done
[17:46:21.186] requestCore(): workers = 2
[17:46:21.188] MulticoreFuture started
[17:46:21.188] - Launch lazy future ... done
[17:46:21.188] run() for ‘MulticoreFuture’ ... done
[17:46:21.189] result() for MulticoreFuture ...
[17:46:21.189] plan(): Setting new future strategy stack:
[17:46:21.189] List of future strategies:
[17:46:21.189] 1. sequential:
[17:46:21.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.189]    - tweaked: FALSE
[17:46:21.189]    - call: NULL
[17:46:21.190] plan(): nbrOfWorkers() = 1
[17:46:21.192] plan(): Setting new future strategy stack:
[17:46:21.192] List of future strategies:
[17:46:21.192] 1. multicore:
[17:46:21.192]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.192]    - tweaked: FALSE
[17:46:21.192]    - call: plan(strategy, substitute = FALSE)
[17:46:21.197] plan(): nbrOfWorkers() = 2
[17:46:21.198] result() for MulticoreFuture ...
[17:46:21.198] result() for MulticoreFuture ... done
[17:46:21.198] result() for MulticoreFuture ... done
[17:46:21.199] result() for MulticoreFuture ...
[17:46:21.199] result() for MulticoreFuture ... done
[1] 6
** Sum function 'C' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55aa00d62468>
Arguments '...' exists: FALSE
[17:46:21.200] getGlobalsAndPackages() ...
[17:46:21.200] Searching for globals...
[17:46:21.201] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[17:46:21.202] Searching for globals ... DONE
[17:46:21.202] Resolving globals: FALSE
[17:46:21.202] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.203] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:21.203] - globals: [2] ‘x’, ‘y’
[17:46:21.203] 
[17:46:21.203] getGlobalsAndPackages() ... DONE
[17:46:21.203] run() for ‘Future’ ...
[17:46:21.204] - state: ‘created’
[17:46:21.204] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.208] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:21.208]   - Field: ‘label’
[17:46:21.208]   - Field: ‘local’
[17:46:21.208]   - Field: ‘owner’
[17:46:21.208]   - Field: ‘envir’
[17:46:21.209]   - Field: ‘workers’
[17:46:21.209]   - Field: ‘packages’
[17:46:21.209]   - Field: ‘gc’
[17:46:21.209]   - Field: ‘job’
[17:46:21.209]   - Field: ‘conditions’
[17:46:21.209]   - Field: ‘expr’
[17:46:21.209]   - Field: ‘uuid’
[17:46:21.209]   - Field: ‘seed’
[17:46:21.209]   - Field: ‘version’
[17:46:21.210]   - Field: ‘result’
[17:46:21.210]   - Field: ‘asynchronous’
[17:46:21.210]   - Field: ‘calls’
[17:46:21.210]   - Field: ‘globals’
[17:46:21.210]   - Field: ‘stdout’
[17:46:21.210]   - Field: ‘earlySignal’
[17:46:21.210]   - Field: ‘lazy’
[17:46:21.210]   - Field: ‘state’
[17:46:21.210] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:21.210] - Launch lazy future ...
[17:46:21.211] Packages needed by the future expression (n = 0): <none>
[17:46:21.211] Packages needed by future strategies (n = 0): <none>
[17:46:21.212] {
[17:46:21.212]     {
[17:46:21.212]         {
[17:46:21.212]             ...future.startTime <- base::Sys.time()
[17:46:21.212]             {
[17:46:21.212]                 {
[17:46:21.212]                   {
[17:46:21.212]                     {
[17:46:21.212]                       base::local({
[17:46:21.212]                         has_future <- base::requireNamespace("future", 
[17:46:21.212]                           quietly = TRUE)
[17:46:21.212]                         if (has_future) {
[17:46:21.212]                           ns <- base::getNamespace("future")
[17:46:21.212]                           version <- ns[[".package"]][["version"]]
[17:46:21.212]                           if (is.null(version)) 
[17:46:21.212]                             version <- utils::packageVersion("future")
[17:46:21.212]                         }
[17:46:21.212]                         else {
[17:46:21.212]                           version <- NULL
[17:46:21.212]                         }
[17:46:21.212]                         if (!has_future || version < "1.8.0") {
[17:46:21.212]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.212]                             "", base::R.version$version.string), 
[17:46:21.212]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.212]                               "release", "version")], collapse = " "), 
[17:46:21.212]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.212]                             info)
[17:46:21.212]                           info <- base::paste(info, collapse = "; ")
[17:46:21.212]                           if (!has_future) {
[17:46:21.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.212]                               info)
[17:46:21.212]                           }
[17:46:21.212]                           else {
[17:46:21.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.212]                               info, version)
[17:46:21.212]                           }
[17:46:21.212]                           base::stop(msg)
[17:46:21.212]                         }
[17:46:21.212]                       })
[17:46:21.212]                     }
[17:46:21.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.212]                     base::options(mc.cores = 1L)
[17:46:21.212]                   }
[17:46:21.212]                   ...future.strategy.old <- future::plan("list")
[17:46:21.212]                   options(future.plan = NULL)
[17:46:21.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.212]                 }
[17:46:21.212]                 ...future.workdir <- getwd()
[17:46:21.212]             }
[17:46:21.212]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.212]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.212]         }
[17:46:21.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.212]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.212]             base::names(...future.oldOptions))
[17:46:21.212]     }
[17:46:21.212]     if (FALSE) {
[17:46:21.212]     }
[17:46:21.212]     else {
[17:46:21.212]         if (TRUE) {
[17:46:21.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.212]                 open = "w")
[17:46:21.212]         }
[17:46:21.212]         else {
[17:46:21.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.212]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.212]         }
[17:46:21.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.212]             base::sink(type = "output", split = FALSE)
[17:46:21.212]             base::close(...future.stdout)
[17:46:21.212]         }, add = TRUE)
[17:46:21.212]     }
[17:46:21.212]     ...future.frame <- base::sys.nframe()
[17:46:21.212]     ...future.conditions <- base::list()
[17:46:21.212]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.212]     if (FALSE) {
[17:46:21.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.212]     }
[17:46:21.212]     ...future.result <- base::tryCatch({
[17:46:21.212]         base::withCallingHandlers({
[17:46:21.212]             ...future.value <- base::withVisible(base::local({
[17:46:21.212]                 withCallingHandlers({
[17:46:21.212]                   {
[17:46:21.212]                     sum(x, y)
[17:46:21.212]                   }
[17:46:21.212]                 }, immediateCondition = function(cond) {
[17:46:21.212]                   save_rds <- function (object, pathname, ...) 
[17:46:21.212]                   {
[17:46:21.212]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:21.212]                     if (file_test("-f", pathname_tmp)) {
[17:46:21.212]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.212]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:21.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.212]                         fi_tmp[["mtime"]])
[17:46:21.212]                     }
[17:46:21.212]                     tryCatch({
[17:46:21.212]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:21.212]                     }, error = function(ex) {
[17:46:21.212]                       msg <- conditionMessage(ex)
[17:46:21.212]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.212]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:21.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.212]                         fi_tmp[["mtime"]], msg)
[17:46:21.212]                       ex$message <- msg
[17:46:21.212]                       stop(ex)
[17:46:21.212]                     })
[17:46:21.212]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:21.212]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:21.212]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:21.212]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.212]                       fi <- file.info(pathname)
[17:46:21.212]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:21.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.212]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:21.212]                         fi[["size"]], fi[["mtime"]])
[17:46:21.212]                       stop(msg)
[17:46:21.212]                     }
[17:46:21.212]                     invisible(pathname)
[17:46:21.212]                   }
[17:46:21.212]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:21.212]                     rootPath = tempdir()) 
[17:46:21.212]                   {
[17:46:21.212]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:21.212]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:21.212]                       tmpdir = path, fileext = ".rds")
[17:46:21.212]                     save_rds(obj, file)
[17:46:21.212]                   }
[17:46:21.212]                   saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")
[17:46:21.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.212]                   {
[17:46:21.212]                     inherits <- base::inherits
[17:46:21.212]                     invokeRestart <- base::invokeRestart
[17:46:21.212]                     is.null <- base::is.null
[17:46:21.212]                     muffled <- FALSE
[17:46:21.212]                     if (inherits(cond, "message")) {
[17:46:21.212]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.212]                       if (muffled) 
[17:46:21.212]                         invokeRestart("muffleMessage")
[17:46:21.212]                     }
[17:46:21.212]                     else if (inherits(cond, "warning")) {
[17:46:21.212]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.212]                       if (muffled) 
[17:46:21.212]                         invokeRestart("muffleWarning")
[17:46:21.212]                     }
[17:46:21.212]                     else if (inherits(cond, "condition")) {
[17:46:21.212]                       if (!is.null(pattern)) {
[17:46:21.212]                         computeRestarts <- base::computeRestarts
[17:46:21.212]                         grepl <- base::grepl
[17:46:21.212]                         restarts <- computeRestarts(cond)
[17:46:21.212]                         for (restart in restarts) {
[17:46:21.212]                           name <- restart$name
[17:46:21.212]                           if (is.null(name)) 
[17:46:21.212]                             next
[17:46:21.212]                           if (!grepl(pattern, name)) 
[17:46:21.212]                             next
[17:46:21.212]                           invokeRestart(restart)
[17:46:21.212]                           muffled <- TRUE
[17:46:21.212]                           break
[17:46:21.212]                         }
[17:46:21.212]                       }
[17:46:21.212]                     }
[17:46:21.212]                     invisible(muffled)
[17:46:21.212]                   }
[17:46:21.212]                   muffleCondition(cond)
[17:46:21.212]                 })
[17:46:21.212]             }))
[17:46:21.212]             future::FutureResult(value = ...future.value$value, 
[17:46:21.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.212]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.212]                     ...future.globalenv.names))
[17:46:21.212]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.212]         }, condition = base::local({
[17:46:21.212]             c <- base::c
[17:46:21.212]             inherits <- base::inherits
[17:46:21.212]             invokeRestart <- base::invokeRestart
[17:46:21.212]             length <- base::length
[17:46:21.212]             list <- base::list
[17:46:21.212]             seq.int <- base::seq.int
[17:46:21.212]             signalCondition <- base::signalCondition
[17:46:21.212]             sys.calls <- base::sys.calls
[17:46:21.212]             `[[` <- base::`[[`
[17:46:21.212]             `+` <- base::`+`
[17:46:21.212]             `<<-` <- base::`<<-`
[17:46:21.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.212]                   3L)]
[17:46:21.212]             }
[17:46:21.212]             function(cond) {
[17:46:21.212]                 is_error <- inherits(cond, "error")
[17:46:21.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.212]                   NULL)
[17:46:21.212]                 if (is_error) {
[17:46:21.212]                   sessionInformation <- function() {
[17:46:21.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.212]                       search = base::search(), system = base::Sys.info())
[17:46:21.212]                   }
[17:46:21.212]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.212]                     cond$call), session = sessionInformation(), 
[17:46:21.212]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.212]                   signalCondition(cond)
[17:46:21.212]                 }
[17:46:21.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.212]                 "immediateCondition"))) {
[17:46:21.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.212]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.212]                   if (TRUE && !signal) {
[17:46:21.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.212]                     {
[17:46:21.212]                       inherits <- base::inherits
[17:46:21.212]                       invokeRestart <- base::invokeRestart
[17:46:21.212]                       is.null <- base::is.null
[17:46:21.212]                       muffled <- FALSE
[17:46:21.212]                       if (inherits(cond, "message")) {
[17:46:21.212]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.212]                         if (muffled) 
[17:46:21.212]                           invokeRestart("muffleMessage")
[17:46:21.212]                       }
[17:46:21.212]                       else if (inherits(cond, "warning")) {
[17:46:21.212]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.212]                         if (muffled) 
[17:46:21.212]                           invokeRestart("muffleWarning")
[17:46:21.212]                       }
[17:46:21.212]                       else if (inherits(cond, "condition")) {
[17:46:21.212]                         if (!is.null(pattern)) {
[17:46:21.212]                           computeRestarts <- base::computeRestarts
[17:46:21.212]                           grepl <- base::grepl
[17:46:21.212]                           restarts <- computeRestarts(cond)
[17:46:21.212]                           for (restart in restarts) {
[17:46:21.212]                             name <- restart$name
[17:46:21.212]                             if (is.null(name)) 
[17:46:21.212]                               next
[17:46:21.212]                             if (!grepl(pattern, name)) 
[17:46:21.212]                               next
[17:46:21.212]                             invokeRestart(restart)
[17:46:21.212]                             muffled <- TRUE
[17:46:21.212]                             break
[17:46:21.212]                           }
[17:46:21.212]                         }
[17:46:21.212]                       }
[17:46:21.212]                       invisible(muffled)
[17:46:21.212]                     }
[17:46:21.212]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.212]                   }
[17:46:21.212]                 }
[17:46:21.212]                 else {
[17:46:21.212]                   if (TRUE) {
[17:46:21.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.212]                     {
[17:46:21.212]                       inherits <- base::inherits
[17:46:21.212]                       invokeRestart <- base::invokeRestart
[17:46:21.212]                       is.null <- base::is.null
[17:46:21.212]                       muffled <- FALSE
[17:46:21.212]                       if (inherits(cond, "message")) {
[17:46:21.212]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.212]                         if (muffled) 
[17:46:21.212]                           invokeRestart("muffleMessage")
[17:46:21.212]                       }
[17:46:21.212]                       else if (inherits(cond, "warning")) {
[17:46:21.212]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.212]                         if (muffled) 
[17:46:21.212]                           invokeRestart("muffleWarning")
[17:46:21.212]                       }
[17:46:21.212]                       else if (inherits(cond, "condition")) {
[17:46:21.212]                         if (!is.null(pattern)) {
[17:46:21.212]                           computeRestarts <- base::computeRestarts
[17:46:21.212]                           grepl <- base::grepl
[17:46:21.212]                           restarts <- computeRestarts(cond)
[17:46:21.212]                           for (restart in restarts) {
[17:46:21.212]                             name <- restart$name
[17:46:21.212]                             if (is.null(name)) 
[17:46:21.212]                               next
[17:46:21.212]                             if (!grepl(pattern, name)) 
[17:46:21.212]                               next
[17:46:21.212]                             invokeRestart(restart)
[17:46:21.212]                             muffled <- TRUE
[17:46:21.212]                             break
[17:46:21.212]                           }
[17:46:21.212]                         }
[17:46:21.212]                       }
[17:46:21.212]                       invisible(muffled)
[17:46:21.212]                     }
[17:46:21.212]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.212]                   }
[17:46:21.212]                 }
[17:46:21.212]             }
[17:46:21.212]         }))
[17:46:21.212]     }, error = function(ex) {
[17:46:21.212]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.212]                 ...future.rng), started = ...future.startTime, 
[17:46:21.212]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.212]             version = "1.8"), class = "FutureResult")
[17:46:21.212]     }, finally = {
[17:46:21.212]         if (!identical(...future.workdir, getwd())) 
[17:46:21.212]             setwd(...future.workdir)
[17:46:21.212]         {
[17:46:21.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.212]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.212]             }
[17:46:21.212]             base::options(...future.oldOptions)
[17:46:21.212]             if (.Platform$OS.type == "windows") {
[17:46:21.212]                 old_names <- names(...future.oldEnvVars)
[17:46:21.212]                 envs <- base::Sys.getenv()
[17:46:21.212]                 names <- names(envs)
[17:46:21.212]                 common <- intersect(names, old_names)
[17:46:21.212]                 added <- setdiff(names, old_names)
[17:46:21.212]                 removed <- setdiff(old_names, names)
[17:46:21.212]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.212]                   envs[common]]
[17:46:21.212]                 NAMES <- toupper(changed)
[17:46:21.212]                 args <- list()
[17:46:21.212]                 for (kk in seq_along(NAMES)) {
[17:46:21.212]                   name <- changed[[kk]]
[17:46:21.212]                   NAME <- NAMES[[kk]]
[17:46:21.212]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.212]                     next
[17:46:21.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.212]                 }
[17:46:21.212]                 NAMES <- toupper(added)
[17:46:21.212]                 for (kk in seq_along(NAMES)) {
[17:46:21.212]                   name <- added[[kk]]
[17:46:21.212]                   NAME <- NAMES[[kk]]
[17:46:21.212]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.212]                     next
[17:46:21.212]                   args[[name]] <- ""
[17:46:21.212]                 }
[17:46:21.212]                 NAMES <- toupper(removed)
[17:46:21.212]                 for (kk in seq_along(NAMES)) {
[17:46:21.212]                   name <- removed[[kk]]
[17:46:21.212]                   NAME <- NAMES[[kk]]
[17:46:21.212]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.212]                     next
[17:46:21.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.212]                 }
[17:46:21.212]                 if (length(args) > 0) 
[17:46:21.212]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.212]             }
[17:46:21.212]             else {
[17:46:21.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.212]             }
[17:46:21.212]             {
[17:46:21.212]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.212]                   0L) {
[17:46:21.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.212]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.212]                   base::options(opts)
[17:46:21.212]                 }
[17:46:21.212]                 {
[17:46:21.212]                   {
[17:46:21.212]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.212]                     NULL
[17:46:21.212]                   }
[17:46:21.212]                   options(future.plan = NULL)
[17:46:21.212]                   if (is.na(NA_character_)) 
[17:46:21.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.212]                     .init = FALSE)
[17:46:21.212]                 }
[17:46:21.212]             }
[17:46:21.212]         }
[17:46:21.212]     })
[17:46:21.212]     if (TRUE) {
[17:46:21.212]         base::sink(type = "output", split = FALSE)
[17:46:21.212]         if (TRUE) {
[17:46:21.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.212]         }
[17:46:21.212]         else {
[17:46:21.212]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.212]         }
[17:46:21.212]         base::close(...future.stdout)
[17:46:21.212]         ...future.stdout <- NULL
[17:46:21.212]     }
[17:46:21.212]     ...future.result$conditions <- ...future.conditions
[17:46:21.212]     ...future.result$finished <- base::Sys.time()
[17:46:21.212]     ...future.result
[17:46:21.212] }
[17:46:21.214] assign_globals() ...
[17:46:21.214] List of 2
[17:46:21.214]  $ x: int [1:2] 1 2
[17:46:21.214]  $ y: num 3
[17:46:21.214]  - attr(*, "where")=List of 2
[17:46:21.214]   ..$ x:<environment: R_EmptyEnv> 
[17:46:21.214]   ..$ y:<environment: R_EmptyEnv> 
[17:46:21.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.214]  - attr(*, "resolved")= logi FALSE
[17:46:21.214]  - attr(*, "total_size")= num 112
[17:46:21.214]  - attr(*, "already-done")= logi TRUE
[17:46:21.220] - copied ‘x’ to environment
[17:46:21.220] - copied ‘y’ to environment
[17:46:21.220] assign_globals() ... done
[17:46:21.221] requestCore(): workers = 2
[17:46:21.222] MulticoreFuture started
[17:46:21.223] - Launch lazy future ... done
[17:46:21.223] run() for ‘MulticoreFuture’ ... done
[17:46:21.224] result() for MulticoreFuture ...
[17:46:21.224] plan(): Setting new future strategy stack:
[17:46:21.224] List of future strategies:
[17:46:21.224] 1. sequential:
[17:46:21.224]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.224]    - tweaked: FALSE
[17:46:21.224]    - call: NULL
[17:46:21.225] plan(): nbrOfWorkers() = 1
[17:46:21.227] plan(): Setting new future strategy stack:
[17:46:21.227] List of future strategies:
[17:46:21.227] 1. multicore:
[17:46:21.227]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.227]    - tweaked: FALSE
[17:46:21.227]    - call: plan(strategy, substitute = FALSE)
[17:46:21.232] plan(): nbrOfWorkers() = 2
[17:46:21.233] result() for MulticoreFuture ...
[17:46:21.233] result() for MulticoreFuture ... done
[17:46:21.233] result() for MulticoreFuture ... done
[17:46:21.233] result() for MulticoreFuture ...
[17:46:21.233] result() for MulticoreFuture ... done
[1] 6
** Sum function 'D' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55aa00efe0c0>
Arguments '...' exists: FALSE
[17:46:21.234] getGlobalsAndPackages() ...
[17:46:21.234] Searching for globals...
[17:46:21.236] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[17:46:21.237] Searching for globals ... DONE
[17:46:21.237] Resolving globals: FALSE
[17:46:21.237] Tweak future expression to call with '...' arguments ...
[17:46:21.238] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.238] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:21.238] - globals: [2] ‘x’, ‘y’
[17:46:21.238] 
[17:46:21.238] getGlobalsAndPackages() ... DONE
[17:46:21.239] run() for ‘Future’ ...
[17:46:21.239] - state: ‘created’
[17:46:21.239] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:21.243]   - Field: ‘label’
[17:46:21.243]   - Field: ‘local’
[17:46:21.243]   - Field: ‘owner’
[17:46:21.243]   - Field: ‘envir’
[17:46:21.244]   - Field: ‘workers’
[17:46:21.244]   - Field: ‘packages’
[17:46:21.244]   - Field: ‘gc’
[17:46:21.244]   - Field: ‘job’
[17:46:21.244]   - Field: ‘conditions’
[17:46:21.244]   - Field: ‘expr’
[17:46:21.244]   - Field: ‘uuid’
[17:46:21.244]   - Field: ‘seed’
[17:46:21.244]   - Field: ‘version’
[17:46:21.245]   - Field: ‘result’
[17:46:21.245]   - Field: ‘asynchronous’
[17:46:21.245]   - Field: ‘calls’
[17:46:21.245]   - Field: ‘globals’
[17:46:21.245]   - Field: ‘stdout’
[17:46:21.245]   - Field: ‘earlySignal’
[17:46:21.245]   - Field: ‘lazy’
[17:46:21.245]   - Field: ‘state’
[17:46:21.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:21.246] - Launch lazy future ...
[17:46:21.246] Packages needed by the future expression (n = 0): <none>
[17:46:21.246] Packages needed by future strategies (n = 0): <none>
[17:46:21.247] {
[17:46:21.247]     {
[17:46:21.247]         {
[17:46:21.247]             ...future.startTime <- base::Sys.time()
[17:46:21.247]             {
[17:46:21.247]                 {
[17:46:21.247]                   {
[17:46:21.247]                     {
[17:46:21.247]                       base::local({
[17:46:21.247]                         has_future <- base::requireNamespace("future", 
[17:46:21.247]                           quietly = TRUE)
[17:46:21.247]                         if (has_future) {
[17:46:21.247]                           ns <- base::getNamespace("future")
[17:46:21.247]                           version <- ns[[".package"]][["version"]]
[17:46:21.247]                           if (is.null(version)) 
[17:46:21.247]                             version <- utils::packageVersion("future")
[17:46:21.247]                         }
[17:46:21.247]                         else {
[17:46:21.247]                           version <- NULL
[17:46:21.247]                         }
[17:46:21.247]                         if (!has_future || version < "1.8.0") {
[17:46:21.247]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.247]                             "", base::R.version$version.string), 
[17:46:21.247]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.247]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.247]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.247]                               "release", "version")], collapse = " "), 
[17:46:21.247]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.247]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.247]                             info)
[17:46:21.247]                           info <- base::paste(info, collapse = "; ")
[17:46:21.247]                           if (!has_future) {
[17:46:21.247]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.247]                               info)
[17:46:21.247]                           }
[17:46:21.247]                           else {
[17:46:21.247]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.247]                               info, version)
[17:46:21.247]                           }
[17:46:21.247]                           base::stop(msg)
[17:46:21.247]                         }
[17:46:21.247]                       })
[17:46:21.247]                     }
[17:46:21.247]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.247]                     base::options(mc.cores = 1L)
[17:46:21.247]                   }
[17:46:21.247]                   ...future.strategy.old <- future::plan("list")
[17:46:21.247]                   options(future.plan = NULL)
[17:46:21.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.247]                 }
[17:46:21.247]                 ...future.workdir <- getwd()
[17:46:21.247]             }
[17:46:21.247]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.247]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.247]         }
[17:46:21.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.247]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.247]             base::names(...future.oldOptions))
[17:46:21.247]     }
[17:46:21.247]     if (FALSE) {
[17:46:21.247]     }
[17:46:21.247]     else {
[17:46:21.247]         if (TRUE) {
[17:46:21.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.247]                 open = "w")
[17:46:21.247]         }
[17:46:21.247]         else {
[17:46:21.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.247]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.247]         }
[17:46:21.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.247]             base::sink(type = "output", split = FALSE)
[17:46:21.247]             base::close(...future.stdout)
[17:46:21.247]         }, add = TRUE)
[17:46:21.247]     }
[17:46:21.247]     ...future.frame <- base::sys.nframe()
[17:46:21.247]     ...future.conditions <- base::list()
[17:46:21.247]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.247]     if (FALSE) {
[17:46:21.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.247]     }
[17:46:21.247]     ...future.result <- base::tryCatch({
[17:46:21.247]         base::withCallingHandlers({
[17:46:21.247]             ...future.value <- base::withVisible(base::local({
[17:46:21.247]                 withCallingHandlers({
[17:46:21.247]                   {
[17:46:21.247]                     sum(x, y, ...)
[17:46:21.247]                   }
[17:46:21.247]                 }, immediateCondition = function(cond) {
[17:46:21.247]                   save_rds <- function (object, pathname, ...) 
[17:46:21.247]                   {
[17:46:21.247]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:21.247]                     if (file_test("-f", pathname_tmp)) {
[17:46:21.247]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.247]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:21.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.247]                         fi_tmp[["mtime"]])
[17:46:21.247]                     }
[17:46:21.247]                     tryCatch({
[17:46:21.247]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:21.247]                     }, error = function(ex) {
[17:46:21.247]                       msg <- conditionMessage(ex)
[17:46:21.247]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.247]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:21.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.247]                         fi_tmp[["mtime"]], msg)
[17:46:21.247]                       ex$message <- msg
[17:46:21.247]                       stop(ex)
[17:46:21.247]                     })
[17:46:21.247]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:21.247]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:21.247]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:21.247]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.247]                       fi <- file.info(pathname)
[17:46:21.247]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:21.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.247]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:21.247]                         fi[["size"]], fi[["mtime"]])
[17:46:21.247]                       stop(msg)
[17:46:21.247]                     }
[17:46:21.247]                     invisible(pathname)
[17:46:21.247]                   }
[17:46:21.247]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:21.247]                     rootPath = tempdir()) 
[17:46:21.247]                   {
[17:46:21.247]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:21.247]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:21.247]                       tmpdir = path, fileext = ".rds")
[17:46:21.247]                     save_rds(obj, file)
[17:46:21.247]                   }
[17:46:21.247]                   saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")
[17:46:21.247]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.247]                   {
[17:46:21.247]                     inherits <- base::inherits
[17:46:21.247]                     invokeRestart <- base::invokeRestart
[17:46:21.247]                     is.null <- base::is.null
[17:46:21.247]                     muffled <- FALSE
[17:46:21.247]                     if (inherits(cond, "message")) {
[17:46:21.247]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.247]                       if (muffled) 
[17:46:21.247]                         invokeRestart("muffleMessage")
[17:46:21.247]                     }
[17:46:21.247]                     else if (inherits(cond, "warning")) {
[17:46:21.247]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.247]                       if (muffled) 
[17:46:21.247]                         invokeRestart("muffleWarning")
[17:46:21.247]                     }
[17:46:21.247]                     else if (inherits(cond, "condition")) {
[17:46:21.247]                       if (!is.null(pattern)) {
[17:46:21.247]                         computeRestarts <- base::computeRestarts
[17:46:21.247]                         grepl <- base::grepl
[17:46:21.247]                         restarts <- computeRestarts(cond)
[17:46:21.247]                         for (restart in restarts) {
[17:46:21.247]                           name <- restart$name
[17:46:21.247]                           if (is.null(name)) 
[17:46:21.247]                             next
[17:46:21.247]                           if (!grepl(pattern, name)) 
[17:46:21.247]                             next
[17:46:21.247]                           invokeRestart(restart)
[17:46:21.247]                           muffled <- TRUE
[17:46:21.247]                           break
[17:46:21.247]                         }
[17:46:21.247]                       }
[17:46:21.247]                     }
[17:46:21.247]                     invisible(muffled)
[17:46:21.247]                   }
[17:46:21.247]                   muffleCondition(cond)
[17:46:21.247]                 })
[17:46:21.247]             }))
[17:46:21.247]             future::FutureResult(value = ...future.value$value, 
[17:46:21.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.247]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.247]                     ...future.globalenv.names))
[17:46:21.247]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.247]         }, condition = base::local({
[17:46:21.247]             c <- base::c
[17:46:21.247]             inherits <- base::inherits
[17:46:21.247]             invokeRestart <- base::invokeRestart
[17:46:21.247]             length <- base::length
[17:46:21.247]             list <- base::list
[17:46:21.247]             seq.int <- base::seq.int
[17:46:21.247]             signalCondition <- base::signalCondition
[17:46:21.247]             sys.calls <- base::sys.calls
[17:46:21.247]             `[[` <- base::`[[`
[17:46:21.247]             `+` <- base::`+`
[17:46:21.247]             `<<-` <- base::`<<-`
[17:46:21.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.247]                   3L)]
[17:46:21.247]             }
[17:46:21.247]             function(cond) {
[17:46:21.247]                 is_error <- inherits(cond, "error")
[17:46:21.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.247]                   NULL)
[17:46:21.247]                 if (is_error) {
[17:46:21.247]                   sessionInformation <- function() {
[17:46:21.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.247]                       search = base::search(), system = base::Sys.info())
[17:46:21.247]                   }
[17:46:21.247]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.247]                     cond$call), session = sessionInformation(), 
[17:46:21.247]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.247]                   signalCondition(cond)
[17:46:21.247]                 }
[17:46:21.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.247]                 "immediateCondition"))) {
[17:46:21.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.247]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.247]                   if (TRUE && !signal) {
[17:46:21.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.247]                     {
[17:46:21.247]                       inherits <- base::inherits
[17:46:21.247]                       invokeRestart <- base::invokeRestart
[17:46:21.247]                       is.null <- base::is.null
[17:46:21.247]                       muffled <- FALSE
[17:46:21.247]                       if (inherits(cond, "message")) {
[17:46:21.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.247]                         if (muffled) 
[17:46:21.247]                           invokeRestart("muffleMessage")
[17:46:21.247]                       }
[17:46:21.247]                       else if (inherits(cond, "warning")) {
[17:46:21.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.247]                         if (muffled) 
[17:46:21.247]                           invokeRestart("muffleWarning")
[17:46:21.247]                       }
[17:46:21.247]                       else if (inherits(cond, "condition")) {
[17:46:21.247]                         if (!is.null(pattern)) {
[17:46:21.247]                           computeRestarts <- base::computeRestarts
[17:46:21.247]                           grepl <- base::grepl
[17:46:21.247]                           restarts <- computeRestarts(cond)
[17:46:21.247]                           for (restart in restarts) {
[17:46:21.247]                             name <- restart$name
[17:46:21.247]                             if (is.null(name)) 
[17:46:21.247]                               next
[17:46:21.247]                             if (!grepl(pattern, name)) 
[17:46:21.247]                               next
[17:46:21.247]                             invokeRestart(restart)
[17:46:21.247]                             muffled <- TRUE
[17:46:21.247]                             break
[17:46:21.247]                           }
[17:46:21.247]                         }
[17:46:21.247]                       }
[17:46:21.247]                       invisible(muffled)
[17:46:21.247]                     }
[17:46:21.247]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.247]                   }
[17:46:21.247]                 }
[17:46:21.247]                 else {
[17:46:21.247]                   if (TRUE) {
[17:46:21.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.247]                     {
[17:46:21.247]                       inherits <- base::inherits
[17:46:21.247]                       invokeRestart <- base::invokeRestart
[17:46:21.247]                       is.null <- base::is.null
[17:46:21.247]                       muffled <- FALSE
[17:46:21.247]                       if (inherits(cond, "message")) {
[17:46:21.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.247]                         if (muffled) 
[17:46:21.247]                           invokeRestart("muffleMessage")
[17:46:21.247]                       }
[17:46:21.247]                       else if (inherits(cond, "warning")) {
[17:46:21.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.247]                         if (muffled) 
[17:46:21.247]                           invokeRestart("muffleWarning")
[17:46:21.247]                       }
[17:46:21.247]                       else if (inherits(cond, "condition")) {
[17:46:21.247]                         if (!is.null(pattern)) {
[17:46:21.247]                           computeRestarts <- base::computeRestarts
[17:46:21.247]                           grepl <- base::grepl
[17:46:21.247]                           restarts <- computeRestarts(cond)
[17:46:21.247]                           for (restart in restarts) {
[17:46:21.247]                             name <- restart$name
[17:46:21.247]                             if (is.null(name)) 
[17:46:21.247]                               next
[17:46:21.247]                             if (!grepl(pattern, name)) 
[17:46:21.247]                               next
[17:46:21.247]                             invokeRestart(restart)
[17:46:21.247]                             muffled <- TRUE
[17:46:21.247]                             break
[17:46:21.247]                           }
[17:46:21.247]                         }
[17:46:21.247]                       }
[17:46:21.247]                       invisible(muffled)
[17:46:21.247]                     }
[17:46:21.247]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.247]                   }
[17:46:21.247]                 }
[17:46:21.247]             }
[17:46:21.247]         }))
[17:46:21.247]     }, error = function(ex) {
[17:46:21.247]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.247]                 ...future.rng), started = ...future.startTime, 
[17:46:21.247]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.247]             version = "1.8"), class = "FutureResult")
[17:46:21.247]     }, finally = {
[17:46:21.247]         if (!identical(...future.workdir, getwd())) 
[17:46:21.247]             setwd(...future.workdir)
[17:46:21.247]         {
[17:46:21.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.247]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.247]             }
[17:46:21.247]             base::options(...future.oldOptions)
[17:46:21.247]             if (.Platform$OS.type == "windows") {
[17:46:21.247]                 old_names <- names(...future.oldEnvVars)
[17:46:21.247]                 envs <- base::Sys.getenv()
[17:46:21.247]                 names <- names(envs)
[17:46:21.247]                 common <- intersect(names, old_names)
[17:46:21.247]                 added <- setdiff(names, old_names)
[17:46:21.247]                 removed <- setdiff(old_names, names)
[17:46:21.247]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.247]                   envs[common]]
[17:46:21.247]                 NAMES <- toupper(changed)
[17:46:21.247]                 args <- list()
[17:46:21.247]                 for (kk in seq_along(NAMES)) {
[17:46:21.247]                   name <- changed[[kk]]
[17:46:21.247]                   NAME <- NAMES[[kk]]
[17:46:21.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.247]                     next
[17:46:21.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.247]                 }
[17:46:21.247]                 NAMES <- toupper(added)
[17:46:21.247]                 for (kk in seq_along(NAMES)) {
[17:46:21.247]                   name <- added[[kk]]
[17:46:21.247]                   NAME <- NAMES[[kk]]
[17:46:21.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.247]                     next
[17:46:21.247]                   args[[name]] <- ""
[17:46:21.247]                 }
[17:46:21.247]                 NAMES <- toupper(removed)
[17:46:21.247]                 for (kk in seq_along(NAMES)) {
[17:46:21.247]                   name <- removed[[kk]]
[17:46:21.247]                   NAME <- NAMES[[kk]]
[17:46:21.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.247]                     next
[17:46:21.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.247]                 }
[17:46:21.247]                 if (length(args) > 0) 
[17:46:21.247]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.247]             }
[17:46:21.247]             else {
[17:46:21.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.247]             }
[17:46:21.247]             {
[17:46:21.247]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.247]                   0L) {
[17:46:21.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.247]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.247]                   base::options(opts)
[17:46:21.247]                 }
[17:46:21.247]                 {
[17:46:21.247]                   {
[17:46:21.247]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.247]                     NULL
[17:46:21.247]                   }
[17:46:21.247]                   options(future.plan = NULL)
[17:46:21.247]                   if (is.na(NA_character_)) 
[17:46:21.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.247]                     .init = FALSE)
[17:46:21.247]                 }
[17:46:21.247]             }
[17:46:21.247]         }
[17:46:21.247]     })
[17:46:21.247]     if (TRUE) {
[17:46:21.247]         base::sink(type = "output", split = FALSE)
[17:46:21.247]         if (TRUE) {
[17:46:21.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.247]         }
[17:46:21.247]         else {
[17:46:21.247]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.247]         }
[17:46:21.247]         base::close(...future.stdout)
[17:46:21.247]         ...future.stdout <- NULL
[17:46:21.247]     }
[17:46:21.247]     ...future.result$conditions <- ...future.conditions
[17:46:21.247]     ...future.result$finished <- base::Sys.time()
[17:46:21.247]     ...future.result
[17:46:21.247] }
[17:46:21.249] assign_globals() ...
[17:46:21.249] List of 2
[17:46:21.249]  $ x: int [1:2] 1 2
[17:46:21.249]  $ y: num 3
[17:46:21.249]  - attr(*, "where")=List of 2
[17:46:21.249]   ..$ x:<environment: R_EmptyEnv> 
[17:46:21.249]   ..$ y:<environment: R_EmptyEnv> 
[17:46:21.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.249]  - attr(*, "resolved")= logi FALSE
[17:46:21.249]  - attr(*, "total_size")= num 112
[17:46:21.249]  - attr(*, "already-done")= logi TRUE
[17:46:21.253] - copied ‘x’ to environment
[17:46:21.253] - copied ‘y’ to environment
[17:46:21.253] assign_globals() ... done
[17:46:21.253] requestCore(): workers = 2
[17:46:21.255] MulticoreFuture started
[17:46:21.255] - Launch lazy future ... done
[17:46:21.255] run() for ‘MulticoreFuture’ ... done
[17:46:21.256] result() for MulticoreFuture ...
[17:46:21.256] plan(): Setting new future strategy stack:
[17:46:21.256] List of future strategies:
[17:46:21.256] 1. sequential:
[17:46:21.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.256]    - tweaked: FALSE
[17:46:21.256]    - call: NULL
[17:46:21.257] plan(): nbrOfWorkers() = 1
[17:46:21.259] plan(): Setting new future strategy stack:
[17:46:21.259] List of future strategies:
[17:46:21.259] 1. multicore:
[17:46:21.259]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.259]    - tweaked: FALSE
[17:46:21.259]    - call: plan(strategy, substitute = FALSE)
[17:46:21.264] plan(): nbrOfWorkers() = 2
[17:46:21.270] result() for MulticoreFuture ...
[17:46:21.270] result() for MulticoreFuture ... done
[17:46:21.270] signalConditions() ...
[17:46:21.270]  - include = ‘immediateCondition’
[17:46:21.270]  - exclude = 
[17:46:21.270]  - resignal = FALSE
[17:46:21.270]  - Number of conditions: 1
[17:46:21.271] signalConditions() ... done
[17:46:21.271] result() for MulticoreFuture ... done
[17:46:21.271] result() for MulticoreFuture ...
[17:46:21.271] result() for MulticoreFuture ... done
[17:46:21.271] signalConditions() ...
[17:46:21.271]  - include = ‘immediateCondition’
[17:46:21.271]  - exclude = 
[17:46:21.271]  - resignal = FALSE
[17:46:21.272]  - Number of conditions: 1
[17:46:21.272] signalConditions() ... done
[17:46:21.272] Future state: ‘finished’
[17:46:21.272] result() for MulticoreFuture ...
[17:46:21.272] result() for MulticoreFuture ... done
[17:46:21.272] signalConditions() ...
[17:46:21.272]  - include = ‘condition’
[17:46:21.272]  - exclude = ‘immediateCondition’
[17:46:21.272]  - resignal = TRUE
[17:46:21.273]  - Number of conditions: 1
[17:46:21.273]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:21.273] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multicore') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55aa014e9798>
Arguments '...' exists: TRUE
[17:46:21.274] getGlobalsAndPackages() ...
[17:46:21.274] - globals passed as-is: [1] ‘...’
[17:46:21.274] Resolving globals: FALSE
[17:46:21.275] Tweak future expression to call with '...' arguments ...
[17:46:21.275] {
[17:46:21.275]     do.call(function(...) {
[17:46:21.275]         fcn <- function() sum(...)
[17:46:21.275]         fcn()
[17:46:21.275]     }, args = future.call.arguments)
[17:46:21.275] }
[17:46:21.275] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.276] The total size of the 1 globals is 112 bytes (112 bytes)
[17:46:21.276] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[17:46:21.276] - globals: [1] ‘future.call.arguments’
[17:46:21.276] 
[17:46:21.276] getGlobalsAndPackages() ... DONE
[17:46:21.277] run() for ‘Future’ ...
[17:46:21.277] - state: ‘created’
[17:46:21.277] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.284] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:21.284]   - Field: ‘label’
[17:46:21.284]   - Field: ‘local’
[17:46:21.284]   - Field: ‘owner’
[17:46:21.284]   - Field: ‘envir’
[17:46:21.284]   - Field: ‘workers’
[17:46:21.285]   - Field: ‘packages’
[17:46:21.285]   - Field: ‘gc’
[17:46:21.285]   - Field: ‘job’
[17:46:21.285]   - Field: ‘conditions’
[17:46:21.285]   - Field: ‘expr’
[17:46:21.285]   - Field: ‘uuid’
[17:46:21.285]   - Field: ‘seed’
[17:46:21.285]   - Field: ‘version’
[17:46:21.286]   - Field: ‘result’
[17:46:21.286]   - Field: ‘asynchronous’
[17:46:21.286]   - Field: ‘calls’
[17:46:21.286]   - Field: ‘globals’
[17:46:21.286]   - Field: ‘stdout’
[17:46:21.286]   - Field: ‘earlySignal’
[17:46:21.286]   - Field: ‘lazy’
[17:46:21.286]   - Field: ‘state’
[17:46:21.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:21.287] - Launch lazy future ...
[17:46:21.287] Packages needed by the future expression (n = 0): <none>
[17:46:21.287] Packages needed by future strategies (n = 0): <none>
[17:46:21.288] {
[17:46:21.288]     {
[17:46:21.288]         {
[17:46:21.288]             ...future.startTime <- base::Sys.time()
[17:46:21.288]             {
[17:46:21.288]                 {
[17:46:21.288]                   {
[17:46:21.288]                     {
[17:46:21.288]                       base::local({
[17:46:21.288]                         has_future <- base::requireNamespace("future", 
[17:46:21.288]                           quietly = TRUE)
[17:46:21.288]                         if (has_future) {
[17:46:21.288]                           ns <- base::getNamespace("future")
[17:46:21.288]                           version <- ns[[".package"]][["version"]]
[17:46:21.288]                           if (is.null(version)) 
[17:46:21.288]                             version <- utils::packageVersion("future")
[17:46:21.288]                         }
[17:46:21.288]                         else {
[17:46:21.288]                           version <- NULL
[17:46:21.288]                         }
[17:46:21.288]                         if (!has_future || version < "1.8.0") {
[17:46:21.288]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.288]                             "", base::R.version$version.string), 
[17:46:21.288]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.288]                               "release", "version")], collapse = " "), 
[17:46:21.288]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.288]                             info)
[17:46:21.288]                           info <- base::paste(info, collapse = "; ")
[17:46:21.288]                           if (!has_future) {
[17:46:21.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.288]                               info)
[17:46:21.288]                           }
[17:46:21.288]                           else {
[17:46:21.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.288]                               info, version)
[17:46:21.288]                           }
[17:46:21.288]                           base::stop(msg)
[17:46:21.288]                         }
[17:46:21.288]                       })
[17:46:21.288]                     }
[17:46:21.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.288]                     base::options(mc.cores = 1L)
[17:46:21.288]                   }
[17:46:21.288]                   ...future.strategy.old <- future::plan("list")
[17:46:21.288]                   options(future.plan = NULL)
[17:46:21.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.288]                 }
[17:46:21.288]                 ...future.workdir <- getwd()
[17:46:21.288]             }
[17:46:21.288]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.288]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.288]         }
[17:46:21.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.288]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.288]             base::names(...future.oldOptions))
[17:46:21.288]     }
[17:46:21.288]     if (FALSE) {
[17:46:21.288]     }
[17:46:21.288]     else {
[17:46:21.288]         if (TRUE) {
[17:46:21.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.288]                 open = "w")
[17:46:21.288]         }
[17:46:21.288]         else {
[17:46:21.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.288]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.288]         }
[17:46:21.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.288]             base::sink(type = "output", split = FALSE)
[17:46:21.288]             base::close(...future.stdout)
[17:46:21.288]         }, add = TRUE)
[17:46:21.288]     }
[17:46:21.288]     ...future.frame <- base::sys.nframe()
[17:46:21.288]     ...future.conditions <- base::list()
[17:46:21.288]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.288]     if (FALSE) {
[17:46:21.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.288]     }
[17:46:21.288]     ...future.result <- base::tryCatch({
[17:46:21.288]         base::withCallingHandlers({
[17:46:21.288]             ...future.value <- base::withVisible(base::local({
[17:46:21.288]                 withCallingHandlers({
[17:46:21.288]                   {
[17:46:21.288]                     do.call(function(...) {
[17:46:21.288]                       fcn <- function() sum(...)
[17:46:21.288]                       fcn()
[17:46:21.288]                     }, args = future.call.arguments)
[17:46:21.288]                   }
[17:46:21.288]                 }, immediateCondition = function(cond) {
[17:46:21.288]                   save_rds <- function (object, pathname, ...) 
[17:46:21.288]                   {
[17:46:21.288]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:21.288]                     if (file_test("-f", pathname_tmp)) {
[17:46:21.288]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.288]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:21.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.288]                         fi_tmp[["mtime"]])
[17:46:21.288]                     }
[17:46:21.288]                     tryCatch({
[17:46:21.288]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:21.288]                     }, error = function(ex) {
[17:46:21.288]                       msg <- conditionMessage(ex)
[17:46:21.288]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.288]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:21.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.288]                         fi_tmp[["mtime"]], msg)
[17:46:21.288]                       ex$message <- msg
[17:46:21.288]                       stop(ex)
[17:46:21.288]                     })
[17:46:21.288]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:21.288]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:21.288]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:21.288]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.288]                       fi <- file.info(pathname)
[17:46:21.288]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:21.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.288]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:21.288]                         fi[["size"]], fi[["mtime"]])
[17:46:21.288]                       stop(msg)
[17:46:21.288]                     }
[17:46:21.288]                     invisible(pathname)
[17:46:21.288]                   }
[17:46:21.288]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:21.288]                     rootPath = tempdir()) 
[17:46:21.288]                   {
[17:46:21.288]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:21.288]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:21.288]                       tmpdir = path, fileext = ".rds")
[17:46:21.288]                     save_rds(obj, file)
[17:46:21.288]                   }
[17:46:21.288]                   saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")
[17:46:21.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.288]                   {
[17:46:21.288]                     inherits <- base::inherits
[17:46:21.288]                     invokeRestart <- base::invokeRestart
[17:46:21.288]                     is.null <- base::is.null
[17:46:21.288]                     muffled <- FALSE
[17:46:21.288]                     if (inherits(cond, "message")) {
[17:46:21.288]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.288]                       if (muffled) 
[17:46:21.288]                         invokeRestart("muffleMessage")
[17:46:21.288]                     }
[17:46:21.288]                     else if (inherits(cond, "warning")) {
[17:46:21.288]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.288]                       if (muffled) 
[17:46:21.288]                         invokeRestart("muffleWarning")
[17:46:21.288]                     }
[17:46:21.288]                     else if (inherits(cond, "condition")) {
[17:46:21.288]                       if (!is.null(pattern)) {
[17:46:21.288]                         computeRestarts <- base::computeRestarts
[17:46:21.288]                         grepl <- base::grepl
[17:46:21.288]                         restarts <- computeRestarts(cond)
[17:46:21.288]                         for (restart in restarts) {
[17:46:21.288]                           name <- restart$name
[17:46:21.288]                           if (is.null(name)) 
[17:46:21.288]                             next
[17:46:21.288]                           if (!grepl(pattern, name)) 
[17:46:21.288]                             next
[17:46:21.288]                           invokeRestart(restart)
[17:46:21.288]                           muffled <- TRUE
[17:46:21.288]                           break
[17:46:21.288]                         }
[17:46:21.288]                       }
[17:46:21.288]                     }
[17:46:21.288]                     invisible(muffled)
[17:46:21.288]                   }
[17:46:21.288]                   muffleCondition(cond)
[17:46:21.288]                 })
[17:46:21.288]             }))
[17:46:21.288]             future::FutureResult(value = ...future.value$value, 
[17:46:21.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.288]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.288]                     ...future.globalenv.names))
[17:46:21.288]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.288]         }, condition = base::local({
[17:46:21.288]             c <- base::c
[17:46:21.288]             inherits <- base::inherits
[17:46:21.288]             invokeRestart <- base::invokeRestart
[17:46:21.288]             length <- base::length
[17:46:21.288]             list <- base::list
[17:46:21.288]             seq.int <- base::seq.int
[17:46:21.288]             signalCondition <- base::signalCondition
[17:46:21.288]             sys.calls <- base::sys.calls
[17:46:21.288]             `[[` <- base::`[[`
[17:46:21.288]             `+` <- base::`+`
[17:46:21.288]             `<<-` <- base::`<<-`
[17:46:21.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.288]                   3L)]
[17:46:21.288]             }
[17:46:21.288]             function(cond) {
[17:46:21.288]                 is_error <- inherits(cond, "error")
[17:46:21.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.288]                   NULL)
[17:46:21.288]                 if (is_error) {
[17:46:21.288]                   sessionInformation <- function() {
[17:46:21.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.288]                       search = base::search(), system = base::Sys.info())
[17:46:21.288]                   }
[17:46:21.288]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.288]                     cond$call), session = sessionInformation(), 
[17:46:21.288]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.288]                   signalCondition(cond)
[17:46:21.288]                 }
[17:46:21.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.288]                 "immediateCondition"))) {
[17:46:21.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.288]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.288]                   if (TRUE && !signal) {
[17:46:21.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.288]                     {
[17:46:21.288]                       inherits <- base::inherits
[17:46:21.288]                       invokeRestart <- base::invokeRestart
[17:46:21.288]                       is.null <- base::is.null
[17:46:21.288]                       muffled <- FALSE
[17:46:21.288]                       if (inherits(cond, "message")) {
[17:46:21.288]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.288]                         if (muffled) 
[17:46:21.288]                           invokeRestart("muffleMessage")
[17:46:21.288]                       }
[17:46:21.288]                       else if (inherits(cond, "warning")) {
[17:46:21.288]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.288]                         if (muffled) 
[17:46:21.288]                           invokeRestart("muffleWarning")
[17:46:21.288]                       }
[17:46:21.288]                       else if (inherits(cond, "condition")) {
[17:46:21.288]                         if (!is.null(pattern)) {
[17:46:21.288]                           computeRestarts <- base::computeRestarts
[17:46:21.288]                           grepl <- base::grepl
[17:46:21.288]                           restarts <- computeRestarts(cond)
[17:46:21.288]                           for (restart in restarts) {
[17:46:21.288]                             name <- restart$name
[17:46:21.288]                             if (is.null(name)) 
[17:46:21.288]                               next
[17:46:21.288]                             if (!grepl(pattern, name)) 
[17:46:21.288]                               next
[17:46:21.288]                             invokeRestart(restart)
[17:46:21.288]                             muffled <- TRUE
[17:46:21.288]                             break
[17:46:21.288]                           }
[17:46:21.288]                         }
[17:46:21.288]                       }
[17:46:21.288]                       invisible(muffled)
[17:46:21.288]                     }
[17:46:21.288]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.288]                   }
[17:46:21.288]                 }
[17:46:21.288]                 else {
[17:46:21.288]                   if (TRUE) {
[17:46:21.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.288]                     {
[17:46:21.288]                       inherits <- base::inherits
[17:46:21.288]                       invokeRestart <- base::invokeRestart
[17:46:21.288]                       is.null <- base::is.null
[17:46:21.288]                       muffled <- FALSE
[17:46:21.288]                       if (inherits(cond, "message")) {
[17:46:21.288]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.288]                         if (muffled) 
[17:46:21.288]                           invokeRestart("muffleMessage")
[17:46:21.288]                       }
[17:46:21.288]                       else if (inherits(cond, "warning")) {
[17:46:21.288]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.288]                         if (muffled) 
[17:46:21.288]                           invokeRestart("muffleWarning")
[17:46:21.288]                       }
[17:46:21.288]                       else if (inherits(cond, "condition")) {
[17:46:21.288]                         if (!is.null(pattern)) {
[17:46:21.288]                           computeRestarts <- base::computeRestarts
[17:46:21.288]                           grepl <- base::grepl
[17:46:21.288]                           restarts <- computeRestarts(cond)
[17:46:21.288]                           for (restart in restarts) {
[17:46:21.288]                             name <- restart$name
[17:46:21.288]                             if (is.null(name)) 
[17:46:21.288]                               next
[17:46:21.288]                             if (!grepl(pattern, name)) 
[17:46:21.288]                               next
[17:46:21.288]                             invokeRestart(restart)
[17:46:21.288]                             muffled <- TRUE
[17:46:21.288]                             break
[17:46:21.288]                           }
[17:46:21.288]                         }
[17:46:21.288]                       }
[17:46:21.288]                       invisible(muffled)
[17:46:21.288]                     }
[17:46:21.288]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.288]                   }
[17:46:21.288]                 }
[17:46:21.288]             }
[17:46:21.288]         }))
[17:46:21.288]     }, error = function(ex) {
[17:46:21.288]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.288]                 ...future.rng), started = ...future.startTime, 
[17:46:21.288]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.288]             version = "1.8"), class = "FutureResult")
[17:46:21.288]     }, finally = {
[17:46:21.288]         if (!identical(...future.workdir, getwd())) 
[17:46:21.288]             setwd(...future.workdir)
[17:46:21.288]         {
[17:46:21.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.288]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.288]             }
[17:46:21.288]             base::options(...future.oldOptions)
[17:46:21.288]             if (.Platform$OS.type == "windows") {
[17:46:21.288]                 old_names <- names(...future.oldEnvVars)
[17:46:21.288]                 envs <- base::Sys.getenv()
[17:46:21.288]                 names <- names(envs)
[17:46:21.288]                 common <- intersect(names, old_names)
[17:46:21.288]                 added <- setdiff(names, old_names)
[17:46:21.288]                 removed <- setdiff(old_names, names)
[17:46:21.288]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.288]                   envs[common]]
[17:46:21.288]                 NAMES <- toupper(changed)
[17:46:21.288]                 args <- list()
[17:46:21.288]                 for (kk in seq_along(NAMES)) {
[17:46:21.288]                   name <- changed[[kk]]
[17:46:21.288]                   NAME <- NAMES[[kk]]
[17:46:21.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.288]                     next
[17:46:21.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.288]                 }
[17:46:21.288]                 NAMES <- toupper(added)
[17:46:21.288]                 for (kk in seq_along(NAMES)) {
[17:46:21.288]                   name <- added[[kk]]
[17:46:21.288]                   NAME <- NAMES[[kk]]
[17:46:21.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.288]                     next
[17:46:21.288]                   args[[name]] <- ""
[17:46:21.288]                 }
[17:46:21.288]                 NAMES <- toupper(removed)
[17:46:21.288]                 for (kk in seq_along(NAMES)) {
[17:46:21.288]                   name <- removed[[kk]]
[17:46:21.288]                   NAME <- NAMES[[kk]]
[17:46:21.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.288]                     next
[17:46:21.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.288]                 }
[17:46:21.288]                 if (length(args) > 0) 
[17:46:21.288]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.288]             }
[17:46:21.288]             else {
[17:46:21.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.288]             }
[17:46:21.288]             {
[17:46:21.288]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.288]                   0L) {
[17:46:21.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.288]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.288]                   base::options(opts)
[17:46:21.288]                 }
[17:46:21.288]                 {
[17:46:21.288]                   {
[17:46:21.288]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.288]                     NULL
[17:46:21.288]                   }
[17:46:21.288]                   options(future.plan = NULL)
[17:46:21.288]                   if (is.na(NA_character_)) 
[17:46:21.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.288]                     .init = FALSE)
[17:46:21.288]                 }
[17:46:21.288]             }
[17:46:21.288]         }
[17:46:21.288]     })
[17:46:21.288]     if (TRUE) {
[17:46:21.288]         base::sink(type = "output", split = FALSE)
[17:46:21.288]         if (TRUE) {
[17:46:21.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.288]         }
[17:46:21.288]         else {
[17:46:21.288]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.288]         }
[17:46:21.288]         base::close(...future.stdout)
[17:46:21.288]         ...future.stdout <- NULL
[17:46:21.288]     }
[17:46:21.288]     ...future.result$conditions <- ...future.conditions
[17:46:21.288]     ...future.result$finished <- base::Sys.time()
[17:46:21.288]     ...future.result
[17:46:21.288] }
[17:46:21.290] assign_globals() ...
[17:46:21.290] List of 1
[17:46:21.290]  $ future.call.arguments:List of 2
[17:46:21.290]   ..$ : int [1:2] 1 2
[17:46:21.290]   ..$ : num 3
[17:46:21.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:46:21.290]  - attr(*, "where")=List of 1
[17:46:21.290]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[17:46:21.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.290]  - attr(*, "resolved")= logi FALSE
[17:46:21.290]  - attr(*, "total_size")= num 112
[17:46:21.290]  - attr(*, "already-done")= logi TRUE
[17:46:21.294] - copied ‘future.call.arguments’ to environment
[17:46:21.294] assign_globals() ... done
[17:46:21.294] requestCore(): workers = 2
[17:46:21.296] MulticoreFuture started
[17:46:21.296] - Launch lazy future ... done
[17:46:21.296] run() for ‘MulticoreFuture’ ... done
[17:46:21.297] result() for MulticoreFuture ...
[17:46:21.297] plan(): Setting new future strategy stack:
[17:46:21.297] List of future strategies:
[17:46:21.297] 1. sequential:
[17:46:21.297]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.297]    - tweaked: FALSE
[17:46:21.297]    - call: NULL
[17:46:21.298] plan(): nbrOfWorkers() = 1
[17:46:21.300] plan(): Setting new future strategy stack:
[17:46:21.300] List of future strategies:
[17:46:21.300] 1. multicore:
[17:46:21.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.300]    - tweaked: FALSE
[17:46:21.300]    - call: plan(strategy, substitute = FALSE)
[17:46:21.305] plan(): nbrOfWorkers() = 2
[17:46:21.306] result() for MulticoreFuture ...
[17:46:21.306] result() for MulticoreFuture ... done
[17:46:21.306] result() for MulticoreFuture ... done
[17:46:21.306] result() for MulticoreFuture ...
[17:46:21.307] result() for MulticoreFuture ... done
[1] 6
** Sum function 'F' with plan('multicore') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55a9ff52fd68>
Using '...' in a formula
[17:46:21.307] getGlobalsAndPackages() ...
[17:46:21.307] Searching for globals...
[17:46:21.311] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘...’, ‘sum’
[17:46:21.311] Searching for globals ... DONE
[17:46:21.311] Resolving globals: FALSE
[17:46:21.311] Tweak future expression to call with '...' arguments ...
[17:46:21.312] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[17:46:21.312] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:21.313] - globals: [3] ‘fcn’, ‘x’, ‘y’
[17:46:21.313] 
[17:46:21.313] getGlobalsAndPackages() ... DONE
[17:46:21.313] run() for ‘Future’ ...
[17:46:21.313] - state: ‘created’
[17:46:21.313] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.318] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:46:21.318]   - Field: ‘label’
[17:46:21.318]   - Field: ‘local’
[17:46:21.318]   - Field: ‘owner’
[17:46:21.318]   - Field: ‘envir’
[17:46:21.319]   - Field: ‘workers’
[17:46:21.319]   - Field: ‘packages’
[17:46:21.319]   - Field: ‘gc’
[17:46:21.319]   - Field: ‘job’
[17:46:21.319]   - Field: ‘conditions’
[17:46:21.319]   - Field: ‘expr’
[17:46:21.319]   - Field: ‘uuid’
[17:46:21.319]   - Field: ‘seed’
[17:46:21.320]   - Field: ‘version’
[17:46:21.320]   - Field: ‘result’
[17:46:21.320]   - Field: ‘asynchronous’
[17:46:21.320]   - Field: ‘calls’
[17:46:21.320]   - Field: ‘globals’
[17:46:21.320]   - Field: ‘stdout’
[17:46:21.320]   - Field: ‘earlySignal’
[17:46:21.320]   - Field: ‘lazy’
[17:46:21.321]   - Field: ‘state’
[17:46:21.321] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:46:21.321] - Launch lazy future ...
[17:46:21.321] Packages needed by the future expression (n = 0): <none>
[17:46:21.321] Packages needed by future strategies (n = 0): <none>
[17:46:21.322] {
[17:46:21.322]     {
[17:46:21.322]         {
[17:46:21.322]             ...future.startTime <- base::Sys.time()
[17:46:21.322]             {
[17:46:21.322]                 {
[17:46:21.322]                   {
[17:46:21.322]                     {
[17:46:21.322]                       base::local({
[17:46:21.322]                         has_future <- base::requireNamespace("future", 
[17:46:21.322]                           quietly = TRUE)
[17:46:21.322]                         if (has_future) {
[17:46:21.322]                           ns <- base::getNamespace("future")
[17:46:21.322]                           version <- ns[[".package"]][["version"]]
[17:46:21.322]                           if (is.null(version)) 
[17:46:21.322]                             version <- utils::packageVersion("future")
[17:46:21.322]                         }
[17:46:21.322]                         else {
[17:46:21.322]                           version <- NULL
[17:46:21.322]                         }
[17:46:21.322]                         if (!has_future || version < "1.8.0") {
[17:46:21.322]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.322]                             "", base::R.version$version.string), 
[17:46:21.322]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.322]                               "release", "version")], collapse = " "), 
[17:46:21.322]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.322]                             info)
[17:46:21.322]                           info <- base::paste(info, collapse = "; ")
[17:46:21.322]                           if (!has_future) {
[17:46:21.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.322]                               info)
[17:46:21.322]                           }
[17:46:21.322]                           else {
[17:46:21.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.322]                               info, version)
[17:46:21.322]                           }
[17:46:21.322]                           base::stop(msg)
[17:46:21.322]                         }
[17:46:21.322]                       })
[17:46:21.322]                     }
[17:46:21.322]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.322]                     base::options(mc.cores = 1L)
[17:46:21.322]                   }
[17:46:21.322]                   ...future.strategy.old <- future::plan("list")
[17:46:21.322]                   options(future.plan = NULL)
[17:46:21.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.322]                 }
[17:46:21.322]                 ...future.workdir <- getwd()
[17:46:21.322]             }
[17:46:21.322]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.322]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.322]         }
[17:46:21.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.322]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.322]             base::names(...future.oldOptions))
[17:46:21.322]     }
[17:46:21.322]     if (FALSE) {
[17:46:21.322]     }
[17:46:21.322]     else {
[17:46:21.322]         if (TRUE) {
[17:46:21.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.322]                 open = "w")
[17:46:21.322]         }
[17:46:21.322]         else {
[17:46:21.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.322]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.322]         }
[17:46:21.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.322]             base::sink(type = "output", split = FALSE)
[17:46:21.322]             base::close(...future.stdout)
[17:46:21.322]         }, add = TRUE)
[17:46:21.322]     }
[17:46:21.322]     ...future.frame <- base::sys.nframe()
[17:46:21.322]     ...future.conditions <- base::list()
[17:46:21.322]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.322]     if (FALSE) {
[17:46:21.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.322]     }
[17:46:21.322]     ...future.result <- base::tryCatch({
[17:46:21.322]         base::withCallingHandlers({
[17:46:21.322]             ...future.value <- base::withVisible(base::local({
[17:46:21.322]                 withCallingHandlers({
[17:46:21.322]                   fcn(x, y)
[17:46:21.322]                 }, immediateCondition = function(cond) {
[17:46:21.322]                   save_rds <- function (object, pathname, ...) 
[17:46:21.322]                   {
[17:46:21.322]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:46:21.322]                     if (file_test("-f", pathname_tmp)) {
[17:46:21.322]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.322]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:46:21.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.322]                         fi_tmp[["mtime"]])
[17:46:21.322]                     }
[17:46:21.322]                     tryCatch({
[17:46:21.322]                       saveRDS(object, file = pathname_tmp, ...)
[17:46:21.322]                     }, error = function(ex) {
[17:46:21.322]                       msg <- conditionMessage(ex)
[17:46:21.322]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.322]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:46:21.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.322]                         fi_tmp[["mtime"]], msg)
[17:46:21.322]                       ex$message <- msg
[17:46:21.322]                       stop(ex)
[17:46:21.322]                     })
[17:46:21.322]                     stopifnot(file_test("-f", pathname_tmp))
[17:46:21.322]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:46:21.322]                     if (!res || file_test("-f", pathname_tmp)) {
[17:46:21.322]                       fi_tmp <- file.info(pathname_tmp)
[17:46:21.322]                       fi <- file.info(pathname)
[17:46:21.322]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:46:21.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:46:21.322]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:46:21.322]                         fi[["size"]], fi[["mtime"]])
[17:46:21.322]                       stop(msg)
[17:46:21.322]                     }
[17:46:21.322]                     invisible(pathname)
[17:46:21.322]                   }
[17:46:21.322]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:46:21.322]                     rootPath = tempdir()) 
[17:46:21.322]                   {
[17:46:21.322]                     obj <- list(time = Sys.time(), condition = cond)
[17:46:21.322]                     file <- tempfile(pattern = class(cond)[1], 
[17:46:21.322]                       tmpdir = path, fileext = ".rds")
[17:46:21.322]                     save_rds(obj, file)
[17:46:21.322]                   }
[17:46:21.322]                   saveImmediateCondition(cond, path = "/tmp/RtmpcinwKS/.future/immediateConditions")
[17:46:21.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.322]                   {
[17:46:21.322]                     inherits <- base::inherits
[17:46:21.322]                     invokeRestart <- base::invokeRestart
[17:46:21.322]                     is.null <- base::is.null
[17:46:21.322]                     muffled <- FALSE
[17:46:21.322]                     if (inherits(cond, "message")) {
[17:46:21.322]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.322]                       if (muffled) 
[17:46:21.322]                         invokeRestart("muffleMessage")
[17:46:21.322]                     }
[17:46:21.322]                     else if (inherits(cond, "warning")) {
[17:46:21.322]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.322]                       if (muffled) 
[17:46:21.322]                         invokeRestart("muffleWarning")
[17:46:21.322]                     }
[17:46:21.322]                     else if (inherits(cond, "condition")) {
[17:46:21.322]                       if (!is.null(pattern)) {
[17:46:21.322]                         computeRestarts <- base::computeRestarts
[17:46:21.322]                         grepl <- base::grepl
[17:46:21.322]                         restarts <- computeRestarts(cond)
[17:46:21.322]                         for (restart in restarts) {
[17:46:21.322]                           name <- restart$name
[17:46:21.322]                           if (is.null(name)) 
[17:46:21.322]                             next
[17:46:21.322]                           if (!grepl(pattern, name)) 
[17:46:21.322]                             next
[17:46:21.322]                           invokeRestart(restart)
[17:46:21.322]                           muffled <- TRUE
[17:46:21.322]                           break
[17:46:21.322]                         }
[17:46:21.322]                       }
[17:46:21.322]                     }
[17:46:21.322]                     invisible(muffled)
[17:46:21.322]                   }
[17:46:21.322]                   muffleCondition(cond)
[17:46:21.322]                 })
[17:46:21.322]             }))
[17:46:21.322]             future::FutureResult(value = ...future.value$value, 
[17:46:21.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.322]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.322]                     ...future.globalenv.names))
[17:46:21.322]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.322]         }, condition = base::local({
[17:46:21.322]             c <- base::c
[17:46:21.322]             inherits <- base::inherits
[17:46:21.322]             invokeRestart <- base::invokeRestart
[17:46:21.322]             length <- base::length
[17:46:21.322]             list <- base::list
[17:46:21.322]             seq.int <- base::seq.int
[17:46:21.322]             signalCondition <- base::signalCondition
[17:46:21.322]             sys.calls <- base::sys.calls
[17:46:21.322]             `[[` <- base::`[[`
[17:46:21.322]             `+` <- base::`+`
[17:46:21.322]             `<<-` <- base::`<<-`
[17:46:21.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.322]                   3L)]
[17:46:21.322]             }
[17:46:21.322]             function(cond) {
[17:46:21.322]                 is_error <- inherits(cond, "error")
[17:46:21.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.322]                   NULL)
[17:46:21.322]                 if (is_error) {
[17:46:21.322]                   sessionInformation <- function() {
[17:46:21.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.322]                       search = base::search(), system = base::Sys.info())
[17:46:21.322]                   }
[17:46:21.322]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.322]                     cond$call), session = sessionInformation(), 
[17:46:21.322]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.322]                   signalCondition(cond)
[17:46:21.322]                 }
[17:46:21.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.322]                 "immediateCondition"))) {
[17:46:21.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.322]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.322]                   if (TRUE && !signal) {
[17:46:21.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.322]                     {
[17:46:21.322]                       inherits <- base::inherits
[17:46:21.322]                       invokeRestart <- base::invokeRestart
[17:46:21.322]                       is.null <- base::is.null
[17:46:21.322]                       muffled <- FALSE
[17:46:21.322]                       if (inherits(cond, "message")) {
[17:46:21.322]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.322]                         if (muffled) 
[17:46:21.322]                           invokeRestart("muffleMessage")
[17:46:21.322]                       }
[17:46:21.322]                       else if (inherits(cond, "warning")) {
[17:46:21.322]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.322]                         if (muffled) 
[17:46:21.322]                           invokeRestart("muffleWarning")
[17:46:21.322]                       }
[17:46:21.322]                       else if (inherits(cond, "condition")) {
[17:46:21.322]                         if (!is.null(pattern)) {
[17:46:21.322]                           computeRestarts <- base::computeRestarts
[17:46:21.322]                           grepl <- base::grepl
[17:46:21.322]                           restarts <- computeRestarts(cond)
[17:46:21.322]                           for (restart in restarts) {
[17:46:21.322]                             name <- restart$name
[17:46:21.322]                             if (is.null(name)) 
[17:46:21.322]                               next
[17:46:21.322]                             if (!grepl(pattern, name)) 
[17:46:21.322]                               next
[17:46:21.322]                             invokeRestart(restart)
[17:46:21.322]                             muffled <- TRUE
[17:46:21.322]                             break
[17:46:21.322]                           }
[17:46:21.322]                         }
[17:46:21.322]                       }
[17:46:21.322]                       invisible(muffled)
[17:46:21.322]                     }
[17:46:21.322]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.322]                   }
[17:46:21.322]                 }
[17:46:21.322]                 else {
[17:46:21.322]                   if (TRUE) {
[17:46:21.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.322]                     {
[17:46:21.322]                       inherits <- base::inherits
[17:46:21.322]                       invokeRestart <- base::invokeRestart
[17:46:21.322]                       is.null <- base::is.null
[17:46:21.322]                       muffled <- FALSE
[17:46:21.322]                       if (inherits(cond, "message")) {
[17:46:21.322]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.322]                         if (muffled) 
[17:46:21.322]                           invokeRestart("muffleMessage")
[17:46:21.322]                       }
[17:46:21.322]                       else if (inherits(cond, "warning")) {
[17:46:21.322]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.322]                         if (muffled) 
[17:46:21.322]                           invokeRestart("muffleWarning")
[17:46:21.322]                       }
[17:46:21.322]                       else if (inherits(cond, "condition")) {
[17:46:21.322]                         if (!is.null(pattern)) {
[17:46:21.322]                           computeRestarts <- base::computeRestarts
[17:46:21.322]                           grepl <- base::grepl
[17:46:21.322]                           restarts <- computeRestarts(cond)
[17:46:21.322]                           for (restart in restarts) {
[17:46:21.322]                             name <- restart$name
[17:46:21.322]                             if (is.null(name)) 
[17:46:21.322]                               next
[17:46:21.322]                             if (!grepl(pattern, name)) 
[17:46:21.322]                               next
[17:46:21.322]                             invokeRestart(restart)
[17:46:21.322]                             muffled <- TRUE
[17:46:21.322]                             break
[17:46:21.322]                           }
[17:46:21.322]                         }
[17:46:21.322]                       }
[17:46:21.322]                       invisible(muffled)
[17:46:21.322]                     }
[17:46:21.322]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.322]                   }
[17:46:21.322]                 }
[17:46:21.322]             }
[17:46:21.322]         }))
[17:46:21.322]     }, error = function(ex) {
[17:46:21.322]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.322]                 ...future.rng), started = ...future.startTime, 
[17:46:21.322]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.322]             version = "1.8"), class = "FutureResult")
[17:46:21.322]     }, finally = {
[17:46:21.322]         if (!identical(...future.workdir, getwd())) 
[17:46:21.322]             setwd(...future.workdir)
[17:46:21.322]         {
[17:46:21.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.322]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.322]             }
[17:46:21.322]             base::options(...future.oldOptions)
[17:46:21.322]             if (.Platform$OS.type == "windows") {
[17:46:21.322]                 old_names <- names(...future.oldEnvVars)
[17:46:21.322]                 envs <- base::Sys.getenv()
[17:46:21.322]                 names <- names(envs)
[17:46:21.322]                 common <- intersect(names, old_names)
[17:46:21.322]                 added <- setdiff(names, old_names)
[17:46:21.322]                 removed <- setdiff(old_names, names)
[17:46:21.322]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.322]                   envs[common]]
[17:46:21.322]                 NAMES <- toupper(changed)
[17:46:21.322]                 args <- list()
[17:46:21.322]                 for (kk in seq_along(NAMES)) {
[17:46:21.322]                   name <- changed[[kk]]
[17:46:21.322]                   NAME <- NAMES[[kk]]
[17:46:21.322]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.322]                     next
[17:46:21.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.322]                 }
[17:46:21.322]                 NAMES <- toupper(added)
[17:46:21.322]                 for (kk in seq_along(NAMES)) {
[17:46:21.322]                   name <- added[[kk]]
[17:46:21.322]                   NAME <- NAMES[[kk]]
[17:46:21.322]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.322]                     next
[17:46:21.322]                   args[[name]] <- ""
[17:46:21.322]                 }
[17:46:21.322]                 NAMES <- toupper(removed)
[17:46:21.322]                 for (kk in seq_along(NAMES)) {
[17:46:21.322]                   name <- removed[[kk]]
[17:46:21.322]                   NAME <- NAMES[[kk]]
[17:46:21.322]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.322]                     next
[17:46:21.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.322]                 }
[17:46:21.322]                 if (length(args) > 0) 
[17:46:21.322]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.322]             }
[17:46:21.322]             else {
[17:46:21.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.322]             }
[17:46:21.322]             {
[17:46:21.322]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.322]                   0L) {
[17:46:21.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.322]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.322]                   base::options(opts)
[17:46:21.322]                 }
[17:46:21.322]                 {
[17:46:21.322]                   {
[17:46:21.322]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.322]                     NULL
[17:46:21.322]                   }
[17:46:21.322]                   options(future.plan = NULL)
[17:46:21.322]                   if (is.na(NA_character_)) 
[17:46:21.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.322]                     .init = FALSE)
[17:46:21.322]                 }
[17:46:21.322]             }
[17:46:21.322]         }
[17:46:21.322]     })
[17:46:21.322]     if (TRUE) {
[17:46:21.322]         base::sink(type = "output", split = FALSE)
[17:46:21.322]         if (TRUE) {
[17:46:21.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.322]         }
[17:46:21.322]         else {
[17:46:21.322]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.322]         }
[17:46:21.322]         base::close(...future.stdout)
[17:46:21.322]         ...future.stdout <- NULL
[17:46:21.322]     }
[17:46:21.322]     ...future.result$conditions <- ...future.conditions
[17:46:21.322]     ...future.result$finished <- base::Sys.time()
[17:46:21.322]     ...future.result
[17:46:21.322] }
[17:46:21.324] assign_globals() ...
[17:46:21.324] List of 3
[17:46:21.324]  $ fcn:function (x, y)  
[17:46:21.324]  $ x  : int [1:2] 1 2
[17:46:21.324]  $ y  : num 3
[17:46:21.324]  - attr(*, "where")=List of 3
[17:46:21.324]   ..$ fcn:<environment: R_EmptyEnv> 
[17:46:21.324]   ..$ x  :<environment: R_EmptyEnv> 
[17:46:21.324]   ..$ y  :<environment: R_EmptyEnv> 
[17:46:21.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:46:21.324]  - attr(*, "resolved")= logi FALSE
[17:46:21.324]  - attr(*, "total_size")= num 4280
[17:46:21.324]  - attr(*, "already-done")= logi TRUE
[17:46:21.328] - reassign environment for ‘fcn’
[17:46:21.329] - copied ‘fcn’ to environment
[17:46:21.331] - copied ‘x’ to environment
[17:46:21.331] - copied ‘y’ to environment
[17:46:21.331] assign_globals() ... done
[17:46:21.331] requestCore(): workers = 2
[17:46:21.333] MulticoreFuture started
[17:46:21.334] - Launch lazy future ... done
[17:46:21.334] run() for ‘MulticoreFuture’ ... done
[17:46:21.334] result() for MulticoreFuture ...
[17:46:21.335] plan(): Setting new future strategy stack:
[17:46:21.335] List of future strategies:
[17:46:21.335] 1. sequential:
[17:46:21.335]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:21.335]    - tweaked: FALSE
[17:46:21.335]    - call: NULL
[17:46:21.336] plan(): nbrOfWorkers() = 1
[17:46:21.338] plan(): Setting new future strategy stack:
[17:46:21.338] List of future strategies:
[17:46:21.338] 1. multicore:
[17:46:21.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:46:21.338]    - tweaked: FALSE
[17:46:21.338]    - call: plan(strategy, substitute = FALSE)
[17:46:21.343] plan(): nbrOfWorkers() = 2
[17:46:21.344] result() for MulticoreFuture ...
[17:46:21.344] result() for MulticoreFuture ... done
[17:46:21.345] result() for MulticoreFuture ... done
[17:46:21.345] result() for MulticoreFuture ...
[17:46:21.345] result() for MulticoreFuture ... done
[1] 6
- plan('multisession') ...
[17:46:21.346] plan(): Setting new future strategy stack:
[17:46:21.346] List of future strategies:
[17:46:21.346] 1. multisession:
[17:46:21.346]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:21.346]    - tweaked: FALSE
[17:46:21.346]    - call: plan(strategy, substitute = FALSE)
[17:46:21.346] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:46:21.346] multisession:
[17:46:21.346] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:46:21.346] - tweaked: FALSE
[17:46:21.346] - call: plan(strategy, substitute = FALSE)
[17:46:21.353] getGlobalsAndPackages() ...
[17:46:21.353] Not searching for globals
[17:46:21.353] - globals: [0] <none>
[17:46:21.353] getGlobalsAndPackages() ... DONE
[17:46:21.354] [local output] makeClusterPSOCK() ...
[17:46:21.398] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:46:21.399] [local output] Base port: 11624
[17:46:21.399] [local output] Getting setup options for 2 cluster nodes ...
[17:46:21.399] [local output]  - Node 1 of 2 ...
[17:46:21.399] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:21.400] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcinwKS/worker.rank=1.parallelly.parent=40159.9cdf71a3a03.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpcinwKS/worker.rank=1.parallelly.parent=40159.9cdf71a3a03.pid")'’
[17:46:21.586] - Possible to infer worker's PID: TRUE
[17:46:21.587] [local output] Rscript port: 11624

[17:46:21.587] [local output]  - Node 2 of 2 ...
[17:46:21.587] [local output] localMachine=TRUE => revtunnel=FALSE

[17:46:21.588] [local output] Rscript port: 11624

[17:46:21.588] [local output] Getting setup options for 2 cluster nodes ... done
[17:46:21.588] [local output]  - Parallel setup requested for some PSOCK nodes
[17:46:21.589] [local output] Setting up PSOCK nodes in parallel
[17:46:21.589] List of 36
[17:46:21.589]  $ worker          : chr "localhost"
[17:46:21.589]   ..- attr(*, "localhost")= logi TRUE
[17:46:21.589]  $ master          : chr "localhost"
[17:46:21.589]  $ port            : int 11624
[17:46:21.589]  $ connectTimeout  : num 120
[17:46:21.589]  $ timeout         : num 2592000
[17:46:21.589]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:46:21.589]  $ homogeneous     : logi TRUE
[17:46:21.589]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:46:21.589]  $ rscript_envs    : NULL
[17:46:21.589]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:21.589]  $ rscript_startup : NULL
[17:46:21.589]  $ rscript_sh      : chr "sh"
[17:46:21.589]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:21.589]  $ methods         : logi TRUE
[17:46:21.589]  $ socketOptions   : chr "no-delay"
[17:46:21.589]  $ useXDR          : logi FALSE
[17:46:21.589]  $ outfile         : chr "/dev/null"
[17:46:21.589]  $ renice          : int NA
[17:46:21.589]  $ rshcmd          : NULL
[17:46:21.589]  $ user            : chr(0) 
[17:46:21.589]  $ revtunnel       : logi FALSE
[17:46:21.589]  $ rshlogfile      : NULL
[17:46:21.589]  $ rshopts         : chr(0) 
[17:46:21.589]  $ rank            : int 1
[17:46:21.589]  $ manual          : logi FALSE
[17:46:21.589]  $ dryrun          : logi FALSE
[17:46:21.589]  $ quiet           : logi FALSE
[17:46:21.589]  $ setup_strategy  : chr "parallel"
[17:46:21.589]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:21.589]  $ pidfile         : chr "/tmp/RtmpcinwKS/worker.rank=1.parallelly.parent=40159.9cdf71a3a03.pid"
[17:46:21.589]  $ rshcmd_label    : NULL
[17:46:21.589]  $ rsh_call        : NULL
[17:46:21.589]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:46:21.589]  $ localMachine    : logi TRUE
[17:46:21.589]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:46:21.589]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:46:21.589]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:46:21.589]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:46:21.589]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:46:21.589]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:46:21.589]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:46:21.589]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:46:21.589]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:46:21.589]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:46:21.589]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:46:21.589]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:46:21.589]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:46:21.589]  $ arguments       :List of 28
[17:46:21.589]   ..$ worker          : chr "localhost"
[17:46:21.589]   ..$ master          : NULL
[17:46:21.589]   ..$ port            : int 11624
[17:46:21.589]   ..$ connectTimeout  : num 120
[17:46:21.589]   ..$ timeout         : num 2592000
[17:46:21.589]   ..$ rscript         : NULL
[17:46:21.589]   ..$ homogeneous     : NULL
[17:46:21.589]   ..$ rscript_args    : NULL
[17:46:21.589]   ..$ rscript_envs    : NULL
[17:46:21.589]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:46:21.589]   ..$ rscript_startup : NULL
[17:46:21.589]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:46:21.589]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:46:21.589]   ..$ methods         : logi TRUE
[17:46:21.589]   ..$ socketOptions   : chr "no-delay"
[17:46:21.589]   ..$ useXDR          : logi FALSE
[17:46:21.589]   ..$ outfile         : chr "/dev/null"
[17:46:21.589]   ..$ renice          : int NA
[17:46:21.589]   ..$ rshcmd          : NULL
[17:46:21.589]   ..$ user            : NULL
[17:46:21.589]   ..$ revtunnel       : logi NA
[17:46:21.589]   ..$ rshlogfile      : NULL
[17:46:21.589]   ..$ rshopts         : NULL
[17:46:21.589]   ..$ rank            : int 1
[17:46:21.589]   ..$ manual          : logi FALSE
[17:46:21.589]   ..$ dryrun          : logi FALSE
[17:46:21.589]   ..$ quiet           : logi FALSE
[17:46:21.589]   ..$ setup_strategy  : chr "parallel"
[17:46:21.589]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:46:21.605] [local output] System call to launch all workers:
[17:46:21.605] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcinwKS/worker.rank=1.parallelly.parent=40159.9cdf71a3a03.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11624 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:46:21.605] [local output] Starting PSOCK main server
[17:46:21.611] [local output] Workers launched
[17:46:21.611] [local output] Waiting for workers to connect back
[17:46:21.611]  - [local output] 0 workers out of 2 ready
[17:46:21.848]  - [local output] 0 workers out of 2 ready
[17:46:21.848]  - [local output] 1 workers out of 2 ready
[17:46:21.857]  - [local output] 1 workers out of 2 ready
[17:46:21.857]  - [local output] 2 workers out of 2 ready
[17:46:21.857] [local output] Launching of workers completed
[17:46:21.857] [local output] Collecting session information from workers
[17:46:21.858] [local output]  - Worker #1 of 2
[17:46:21.859] [local output]  - Worker #2 of 2
[17:46:21.859] [local output] makeClusterPSOCK() ... done
[17:46:21.871] Packages needed by the future expression (n = 0): <none>
[17:46:21.871] Packages needed by future strategies (n = 0): <none>
[17:46:21.871] {
[17:46:21.871]     {
[17:46:21.871]         {
[17:46:21.871]             ...future.startTime <- base::Sys.time()
[17:46:21.871]             {
[17:46:21.871]                 {
[17:46:21.871]                   {
[17:46:21.871]                     {
[17:46:21.871]                       base::local({
[17:46:21.871]                         has_future <- base::requireNamespace("future", 
[17:46:21.871]                           quietly = TRUE)
[17:46:21.871]                         if (has_future) {
[17:46:21.871]                           ns <- base::getNamespace("future")
[17:46:21.871]                           version <- ns[[".package"]][["version"]]
[17:46:21.871]                           if (is.null(version)) 
[17:46:21.871]                             version <- utils::packageVersion("future")
[17:46:21.871]                         }
[17:46:21.871]                         else {
[17:46:21.871]                           version <- NULL
[17:46:21.871]                         }
[17:46:21.871]                         if (!has_future || version < "1.8.0") {
[17:46:21.871]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.871]                             "", base::R.version$version.string), 
[17:46:21.871]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.871]                               "release", "version")], collapse = " "), 
[17:46:21.871]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.871]                             info)
[17:46:21.871]                           info <- base::paste(info, collapse = "; ")
[17:46:21.871]                           if (!has_future) {
[17:46:21.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.871]                               info)
[17:46:21.871]                           }
[17:46:21.871]                           else {
[17:46:21.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.871]                               info, version)
[17:46:21.871]                           }
[17:46:21.871]                           base::stop(msg)
[17:46:21.871]                         }
[17:46:21.871]                       })
[17:46:21.871]                     }
[17:46:21.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.871]                     base::options(mc.cores = 1L)
[17:46:21.871]                   }
[17:46:21.871]                   ...future.strategy.old <- future::plan("list")
[17:46:21.871]                   options(future.plan = NULL)
[17:46:21.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.871]                 }
[17:46:21.871]                 ...future.workdir <- getwd()
[17:46:21.871]             }
[17:46:21.871]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.871]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.871]         }
[17:46:21.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.871]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.871]             base::names(...future.oldOptions))
[17:46:21.871]     }
[17:46:21.871]     if (FALSE) {
[17:46:21.871]     }
[17:46:21.871]     else {
[17:46:21.871]         if (TRUE) {
[17:46:21.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.871]                 open = "w")
[17:46:21.871]         }
[17:46:21.871]         else {
[17:46:21.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.871]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.871]         }
[17:46:21.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.871]             base::sink(type = "output", split = FALSE)
[17:46:21.871]             base::close(...future.stdout)
[17:46:21.871]         }, add = TRUE)
[17:46:21.871]     }
[17:46:21.871]     ...future.frame <- base::sys.nframe()
[17:46:21.871]     ...future.conditions <- base::list()
[17:46:21.871]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.871]     if (FALSE) {
[17:46:21.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.871]     }
[17:46:21.871]     ...future.result <- base::tryCatch({
[17:46:21.871]         base::withCallingHandlers({
[17:46:21.871]             ...future.value <- base::withVisible(base::local({
[17:46:21.871]                 ...future.makeSendCondition <- base::local({
[17:46:21.871]                   sendCondition <- NULL
[17:46:21.871]                   function(frame = 1L) {
[17:46:21.871]                     if (is.function(sendCondition)) 
[17:46:21.871]                       return(sendCondition)
[17:46:21.871]                     ns <- getNamespace("parallel")
[17:46:21.871]                     if (exists("sendData", mode = "function", 
[17:46:21.871]                       envir = ns)) {
[17:46:21.871]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:21.871]                         envir = ns)
[17:46:21.871]                       envir <- sys.frame(frame)
[17:46:21.871]                       master <- NULL
[17:46:21.871]                       while (!identical(envir, .GlobalEnv) && 
[17:46:21.871]                         !identical(envir, emptyenv())) {
[17:46:21.871]                         if (exists("master", mode = "list", envir = envir, 
[17:46:21.871]                           inherits = FALSE)) {
[17:46:21.871]                           master <- get("master", mode = "list", 
[17:46:21.871]                             envir = envir, inherits = FALSE)
[17:46:21.871]                           if (inherits(master, c("SOCKnode", 
[17:46:21.871]                             "SOCK0node"))) {
[17:46:21.871]                             sendCondition <<- function(cond) {
[17:46:21.871]                               data <- list(type = "VALUE", value = cond, 
[17:46:21.871]                                 success = TRUE)
[17:46:21.871]                               parallel_sendData(master, data)
[17:46:21.871]                             }
[17:46:21.871]                             return(sendCondition)
[17:46:21.871]                           }
[17:46:21.871]                         }
[17:46:21.871]                         frame <- frame + 1L
[17:46:21.871]                         envir <- sys.frame(frame)
[17:46:21.871]                       }
[17:46:21.871]                     }
[17:46:21.871]                     sendCondition <<- function(cond) NULL
[17:46:21.871]                   }
[17:46:21.871]                 })
[17:46:21.871]                 withCallingHandlers({
[17:46:21.871]                   NA
[17:46:21.871]                 }, immediateCondition = function(cond) {
[17:46:21.871]                   sendCondition <- ...future.makeSendCondition()
[17:46:21.871]                   sendCondition(cond)
[17:46:21.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.871]                   {
[17:46:21.871]                     inherits <- base::inherits
[17:46:21.871]                     invokeRestart <- base::invokeRestart
[17:46:21.871]                     is.null <- base::is.null
[17:46:21.871]                     muffled <- FALSE
[17:46:21.871]                     if (inherits(cond, "message")) {
[17:46:21.871]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.871]                       if (muffled) 
[17:46:21.871]                         invokeRestart("muffleMessage")
[17:46:21.871]                     }
[17:46:21.871]                     else if (inherits(cond, "warning")) {
[17:46:21.871]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.871]                       if (muffled) 
[17:46:21.871]                         invokeRestart("muffleWarning")
[17:46:21.871]                     }
[17:46:21.871]                     else if (inherits(cond, "condition")) {
[17:46:21.871]                       if (!is.null(pattern)) {
[17:46:21.871]                         computeRestarts <- base::computeRestarts
[17:46:21.871]                         grepl <- base::grepl
[17:46:21.871]                         restarts <- computeRestarts(cond)
[17:46:21.871]                         for (restart in restarts) {
[17:46:21.871]                           name <- restart$name
[17:46:21.871]                           if (is.null(name)) 
[17:46:21.871]                             next
[17:46:21.871]                           if (!grepl(pattern, name)) 
[17:46:21.871]                             next
[17:46:21.871]                           invokeRestart(restart)
[17:46:21.871]                           muffled <- TRUE
[17:46:21.871]                           break
[17:46:21.871]                         }
[17:46:21.871]                       }
[17:46:21.871]                     }
[17:46:21.871]                     invisible(muffled)
[17:46:21.871]                   }
[17:46:21.871]                   muffleCondition(cond)
[17:46:21.871]                 })
[17:46:21.871]             }))
[17:46:21.871]             future::FutureResult(value = ...future.value$value, 
[17:46:21.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.871]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.871]                     ...future.globalenv.names))
[17:46:21.871]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.871]         }, condition = base::local({
[17:46:21.871]             c <- base::c
[17:46:21.871]             inherits <- base::inherits
[17:46:21.871]             invokeRestart <- base::invokeRestart
[17:46:21.871]             length <- base::length
[17:46:21.871]             list <- base::list
[17:46:21.871]             seq.int <- base::seq.int
[17:46:21.871]             signalCondition <- base::signalCondition
[17:46:21.871]             sys.calls <- base::sys.calls
[17:46:21.871]             `[[` <- base::`[[`
[17:46:21.871]             `+` <- base::`+`
[17:46:21.871]             `<<-` <- base::`<<-`
[17:46:21.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.871]                   3L)]
[17:46:21.871]             }
[17:46:21.871]             function(cond) {
[17:46:21.871]                 is_error <- inherits(cond, "error")
[17:46:21.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.871]                   NULL)
[17:46:21.871]                 if (is_error) {
[17:46:21.871]                   sessionInformation <- function() {
[17:46:21.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.871]                       search = base::search(), system = base::Sys.info())
[17:46:21.871]                   }
[17:46:21.871]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.871]                     cond$call), session = sessionInformation(), 
[17:46:21.871]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.871]                   signalCondition(cond)
[17:46:21.871]                 }
[17:46:21.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.871]                 "immediateCondition"))) {
[17:46:21.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.871]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.871]                   if (TRUE && !signal) {
[17:46:21.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.871]                     {
[17:46:21.871]                       inherits <- base::inherits
[17:46:21.871]                       invokeRestart <- base::invokeRestart
[17:46:21.871]                       is.null <- base::is.null
[17:46:21.871]                       muffled <- FALSE
[17:46:21.871]                       if (inherits(cond, "message")) {
[17:46:21.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.871]                         if (muffled) 
[17:46:21.871]                           invokeRestart("muffleMessage")
[17:46:21.871]                       }
[17:46:21.871]                       else if (inherits(cond, "warning")) {
[17:46:21.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.871]                         if (muffled) 
[17:46:21.871]                           invokeRestart("muffleWarning")
[17:46:21.871]                       }
[17:46:21.871]                       else if (inherits(cond, "condition")) {
[17:46:21.871]                         if (!is.null(pattern)) {
[17:46:21.871]                           computeRestarts <- base::computeRestarts
[17:46:21.871]                           grepl <- base::grepl
[17:46:21.871]                           restarts <- computeRestarts(cond)
[17:46:21.871]                           for (restart in restarts) {
[17:46:21.871]                             name <- restart$name
[17:46:21.871]                             if (is.null(name)) 
[17:46:21.871]                               next
[17:46:21.871]                             if (!grepl(pattern, name)) 
[17:46:21.871]                               next
[17:46:21.871]                             invokeRestart(restart)
[17:46:21.871]                             muffled <- TRUE
[17:46:21.871]                             break
[17:46:21.871]                           }
[17:46:21.871]                         }
[17:46:21.871]                       }
[17:46:21.871]                       invisible(muffled)
[17:46:21.871]                     }
[17:46:21.871]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.871]                   }
[17:46:21.871]                 }
[17:46:21.871]                 else {
[17:46:21.871]                   if (TRUE) {
[17:46:21.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.871]                     {
[17:46:21.871]                       inherits <- base::inherits
[17:46:21.871]                       invokeRestart <- base::invokeRestart
[17:46:21.871]                       is.null <- base::is.null
[17:46:21.871]                       muffled <- FALSE
[17:46:21.871]                       if (inherits(cond, "message")) {
[17:46:21.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.871]                         if (muffled) 
[17:46:21.871]                           invokeRestart("muffleMessage")
[17:46:21.871]                       }
[17:46:21.871]                       else if (inherits(cond, "warning")) {
[17:46:21.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.871]                         if (muffled) 
[17:46:21.871]                           invokeRestart("muffleWarning")
[17:46:21.871]                       }
[17:46:21.871]                       else if (inherits(cond, "condition")) {
[17:46:21.871]                         if (!is.null(pattern)) {
[17:46:21.871]                           computeRestarts <- base::computeRestarts
[17:46:21.871]                           grepl <- base::grepl
[17:46:21.871]                           restarts <- computeRestarts(cond)
[17:46:21.871]                           for (restart in restarts) {
[17:46:21.871]                             name <- restart$name
[17:46:21.871]                             if (is.null(name)) 
[17:46:21.871]                               next
[17:46:21.871]                             if (!grepl(pattern, name)) 
[17:46:21.871]                               next
[17:46:21.871]                             invokeRestart(restart)
[17:46:21.871]                             muffled <- TRUE
[17:46:21.871]                             break
[17:46:21.871]                           }
[17:46:21.871]                         }
[17:46:21.871]                       }
[17:46:21.871]                       invisible(muffled)
[17:46:21.871]                     }
[17:46:21.871]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.871]                   }
[17:46:21.871]                 }
[17:46:21.871]             }
[17:46:21.871]         }))
[17:46:21.871]     }, error = function(ex) {
[17:46:21.871]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.871]                 ...future.rng), started = ...future.startTime, 
[17:46:21.871]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.871]             version = "1.8"), class = "FutureResult")
[17:46:21.871]     }, finally = {
[17:46:21.871]         if (!identical(...future.workdir, getwd())) 
[17:46:21.871]             setwd(...future.workdir)
[17:46:21.871]         {
[17:46:21.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.871]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.871]             }
[17:46:21.871]             base::options(...future.oldOptions)
[17:46:21.871]             if (.Platform$OS.type == "windows") {
[17:46:21.871]                 old_names <- names(...future.oldEnvVars)
[17:46:21.871]                 envs <- base::Sys.getenv()
[17:46:21.871]                 names <- names(envs)
[17:46:21.871]                 common <- intersect(names, old_names)
[17:46:21.871]                 added <- setdiff(names, old_names)
[17:46:21.871]                 removed <- setdiff(old_names, names)
[17:46:21.871]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.871]                   envs[common]]
[17:46:21.871]                 NAMES <- toupper(changed)
[17:46:21.871]                 args <- list()
[17:46:21.871]                 for (kk in seq_along(NAMES)) {
[17:46:21.871]                   name <- changed[[kk]]
[17:46:21.871]                   NAME <- NAMES[[kk]]
[17:46:21.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.871]                     next
[17:46:21.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.871]                 }
[17:46:21.871]                 NAMES <- toupper(added)
[17:46:21.871]                 for (kk in seq_along(NAMES)) {
[17:46:21.871]                   name <- added[[kk]]
[17:46:21.871]                   NAME <- NAMES[[kk]]
[17:46:21.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.871]                     next
[17:46:21.871]                   args[[name]] <- ""
[17:46:21.871]                 }
[17:46:21.871]                 NAMES <- toupper(removed)
[17:46:21.871]                 for (kk in seq_along(NAMES)) {
[17:46:21.871]                   name <- removed[[kk]]
[17:46:21.871]                   NAME <- NAMES[[kk]]
[17:46:21.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.871]                     next
[17:46:21.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.871]                 }
[17:46:21.871]                 if (length(args) > 0) 
[17:46:21.871]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.871]             }
[17:46:21.871]             else {
[17:46:21.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.871]             }
[17:46:21.871]             {
[17:46:21.871]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.871]                   0L) {
[17:46:21.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.871]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.871]                   base::options(opts)
[17:46:21.871]                 }
[17:46:21.871]                 {
[17:46:21.871]                   {
[17:46:21.871]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.871]                     NULL
[17:46:21.871]                   }
[17:46:21.871]                   options(future.plan = NULL)
[17:46:21.871]                   if (is.na(NA_character_)) 
[17:46:21.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.871]                     .init = FALSE)
[17:46:21.871]                 }
[17:46:21.871]             }
[17:46:21.871]         }
[17:46:21.871]     })
[17:46:21.871]     if (TRUE) {
[17:46:21.871]         base::sink(type = "output", split = FALSE)
[17:46:21.871]         if (TRUE) {
[17:46:21.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.871]         }
[17:46:21.871]         else {
[17:46:21.871]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.871]         }
[17:46:21.871]         base::close(...future.stdout)
[17:46:21.871]         ...future.stdout <- NULL
[17:46:21.871]     }
[17:46:21.871]     ...future.result$conditions <- ...future.conditions
[17:46:21.871]     ...future.result$finished <- base::Sys.time()
[17:46:21.871]     ...future.result
[17:46:21.871] }
[17:46:21.923] MultisessionFuture started
[17:46:21.923] result() for ClusterFuture ...
[17:46:21.924] receiveMessageFromWorker() for ClusterFuture ...
[17:46:21.924] - Validating connection of MultisessionFuture
[17:46:21.955] - received message: FutureResult
[17:46:21.956] - Received FutureResult
[17:46:21.956] - Erased future from FutureRegistry
[17:46:21.956] result() for ClusterFuture ...
[17:46:21.956] - result already collected: FutureResult
[17:46:21.956] result() for ClusterFuture ... done
[17:46:21.956] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:21.956] result() for ClusterFuture ... done
[17:46:21.956] result() for ClusterFuture ...
[17:46:21.957] - result already collected: FutureResult
[17:46:21.957] result() for ClusterFuture ... done
[17:46:21.957] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:46:21.961] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multisession') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55aa0080c960>
Arguments '...' exists: TRUE
[17:46:21.962] getGlobalsAndPackages() ...
[17:46:21.962] Searching for globals...
[17:46:21.964] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:46:21.964] Searching for globals ... DONE
[17:46:21.964] Resolving globals: FALSE
[17:46:21.964] Tweak future expression to call with '...' arguments ...
[17:46:21.964] {
[17:46:21.964]     do.call(function(...) {
[17:46:21.964]         sum(x, ...)
[17:46:21.964]     }, args = future.call.arguments)
[17:46:21.964] }
[17:46:21.965] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.965] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.966] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:46:21.966] - globals: [2] ‘x’, ‘future.call.arguments’
[17:46:21.966] 
[17:46:21.966] getGlobalsAndPackages() ... DONE
[17:46:21.966] run() for ‘Future’ ...
[17:46:21.966] - state: ‘created’
[17:46:21.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:21.981] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:21.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:21.981]   - Field: ‘node’
[17:46:21.981]   - Field: ‘label’
[17:46:21.981]   - Field: ‘local’
[17:46:21.981]   - Field: ‘owner’
[17:46:21.981]   - Field: ‘envir’
[17:46:21.981]   - Field: ‘workers’
[17:46:21.982]   - Field: ‘packages’
[17:46:21.982]   - Field: ‘gc’
[17:46:21.982]   - Field: ‘conditions’
[17:46:21.982]   - Field: ‘persistent’
[17:46:21.982]   - Field: ‘expr’
[17:46:21.982]   - Field: ‘uuid’
[17:46:21.982]   - Field: ‘seed’
[17:46:21.982]   - Field: ‘version’
[17:46:21.982]   - Field: ‘result’
[17:46:21.983]   - Field: ‘asynchronous’
[17:46:21.983]   - Field: ‘calls’
[17:46:21.983]   - Field: ‘globals’
[17:46:21.983]   - Field: ‘stdout’
[17:46:21.983]   - Field: ‘earlySignal’
[17:46:21.983]   - Field: ‘lazy’
[17:46:21.983]   - Field: ‘state’
[17:46:21.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:21.984] - Launch lazy future ...
[17:46:21.984] Packages needed by the future expression (n = 0): <none>
[17:46:21.984] Packages needed by future strategies (n = 0): <none>
[17:46:21.985] {
[17:46:21.985]     {
[17:46:21.985]         {
[17:46:21.985]             ...future.startTime <- base::Sys.time()
[17:46:21.985]             {
[17:46:21.985]                 {
[17:46:21.985]                   {
[17:46:21.985]                     {
[17:46:21.985]                       base::local({
[17:46:21.985]                         has_future <- base::requireNamespace("future", 
[17:46:21.985]                           quietly = TRUE)
[17:46:21.985]                         if (has_future) {
[17:46:21.985]                           ns <- base::getNamespace("future")
[17:46:21.985]                           version <- ns[[".package"]][["version"]]
[17:46:21.985]                           if (is.null(version)) 
[17:46:21.985]                             version <- utils::packageVersion("future")
[17:46:21.985]                         }
[17:46:21.985]                         else {
[17:46:21.985]                           version <- NULL
[17:46:21.985]                         }
[17:46:21.985]                         if (!has_future || version < "1.8.0") {
[17:46:21.985]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:21.985]                             "", base::R.version$version.string), 
[17:46:21.985]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:21.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:21.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:21.985]                               "release", "version")], collapse = " "), 
[17:46:21.985]                             hostname = base::Sys.info()[["nodename"]])
[17:46:21.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:21.985]                             info)
[17:46:21.985]                           info <- base::paste(info, collapse = "; ")
[17:46:21.985]                           if (!has_future) {
[17:46:21.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:21.985]                               info)
[17:46:21.985]                           }
[17:46:21.985]                           else {
[17:46:21.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:21.985]                               info, version)
[17:46:21.985]                           }
[17:46:21.985]                           base::stop(msg)
[17:46:21.985]                         }
[17:46:21.985]                       })
[17:46:21.985]                     }
[17:46:21.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:21.985]                     base::options(mc.cores = 1L)
[17:46:21.985]                   }
[17:46:21.985]                   ...future.strategy.old <- future::plan("list")
[17:46:21.985]                   options(future.plan = NULL)
[17:46:21.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:21.985]                 }
[17:46:21.985]                 ...future.workdir <- getwd()
[17:46:21.985]             }
[17:46:21.985]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:21.985]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:21.985]         }
[17:46:21.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:21.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:21.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:21.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:21.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:21.985]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:21.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:21.985]             base::names(...future.oldOptions))
[17:46:21.985]     }
[17:46:21.985]     if (FALSE) {
[17:46:21.985]     }
[17:46:21.985]     else {
[17:46:21.985]         if (TRUE) {
[17:46:21.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:21.985]                 open = "w")
[17:46:21.985]         }
[17:46:21.985]         else {
[17:46:21.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:21.985]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:21.985]         }
[17:46:21.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:21.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:21.985]             base::sink(type = "output", split = FALSE)
[17:46:21.985]             base::close(...future.stdout)
[17:46:21.985]         }, add = TRUE)
[17:46:21.985]     }
[17:46:21.985]     ...future.frame <- base::sys.nframe()
[17:46:21.985]     ...future.conditions <- base::list()
[17:46:21.985]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:21.985]     if (FALSE) {
[17:46:21.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:21.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:21.985]     }
[17:46:21.985]     ...future.result <- base::tryCatch({
[17:46:21.985]         base::withCallingHandlers({
[17:46:21.985]             ...future.value <- base::withVisible(base::local({
[17:46:21.985]                 ...future.makeSendCondition <- base::local({
[17:46:21.985]                   sendCondition <- NULL
[17:46:21.985]                   function(frame = 1L) {
[17:46:21.985]                     if (is.function(sendCondition)) 
[17:46:21.985]                       return(sendCondition)
[17:46:21.985]                     ns <- getNamespace("parallel")
[17:46:21.985]                     if (exists("sendData", mode = "function", 
[17:46:21.985]                       envir = ns)) {
[17:46:21.985]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:21.985]                         envir = ns)
[17:46:21.985]                       envir <- sys.frame(frame)
[17:46:21.985]                       master <- NULL
[17:46:21.985]                       while (!identical(envir, .GlobalEnv) && 
[17:46:21.985]                         !identical(envir, emptyenv())) {
[17:46:21.985]                         if (exists("master", mode = "list", envir = envir, 
[17:46:21.985]                           inherits = FALSE)) {
[17:46:21.985]                           master <- get("master", mode = "list", 
[17:46:21.985]                             envir = envir, inherits = FALSE)
[17:46:21.985]                           if (inherits(master, c("SOCKnode", 
[17:46:21.985]                             "SOCK0node"))) {
[17:46:21.985]                             sendCondition <<- function(cond) {
[17:46:21.985]                               data <- list(type = "VALUE", value = cond, 
[17:46:21.985]                                 success = TRUE)
[17:46:21.985]                               parallel_sendData(master, data)
[17:46:21.985]                             }
[17:46:21.985]                             return(sendCondition)
[17:46:21.985]                           }
[17:46:21.985]                         }
[17:46:21.985]                         frame <- frame + 1L
[17:46:21.985]                         envir <- sys.frame(frame)
[17:46:21.985]                       }
[17:46:21.985]                     }
[17:46:21.985]                     sendCondition <<- function(cond) NULL
[17:46:21.985]                   }
[17:46:21.985]                 })
[17:46:21.985]                 withCallingHandlers({
[17:46:21.985]                   {
[17:46:21.985]                     do.call(function(...) {
[17:46:21.985]                       sum(x, ...)
[17:46:21.985]                     }, args = future.call.arguments)
[17:46:21.985]                   }
[17:46:21.985]                 }, immediateCondition = function(cond) {
[17:46:21.985]                   sendCondition <- ...future.makeSendCondition()
[17:46:21.985]                   sendCondition(cond)
[17:46:21.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.985]                   {
[17:46:21.985]                     inherits <- base::inherits
[17:46:21.985]                     invokeRestart <- base::invokeRestart
[17:46:21.985]                     is.null <- base::is.null
[17:46:21.985]                     muffled <- FALSE
[17:46:21.985]                     if (inherits(cond, "message")) {
[17:46:21.985]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:21.985]                       if (muffled) 
[17:46:21.985]                         invokeRestart("muffleMessage")
[17:46:21.985]                     }
[17:46:21.985]                     else if (inherits(cond, "warning")) {
[17:46:21.985]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:21.985]                       if (muffled) 
[17:46:21.985]                         invokeRestart("muffleWarning")
[17:46:21.985]                     }
[17:46:21.985]                     else if (inherits(cond, "condition")) {
[17:46:21.985]                       if (!is.null(pattern)) {
[17:46:21.985]                         computeRestarts <- base::computeRestarts
[17:46:21.985]                         grepl <- base::grepl
[17:46:21.985]                         restarts <- computeRestarts(cond)
[17:46:21.985]                         for (restart in restarts) {
[17:46:21.985]                           name <- restart$name
[17:46:21.985]                           if (is.null(name)) 
[17:46:21.985]                             next
[17:46:21.985]                           if (!grepl(pattern, name)) 
[17:46:21.985]                             next
[17:46:21.985]                           invokeRestart(restart)
[17:46:21.985]                           muffled <- TRUE
[17:46:21.985]                           break
[17:46:21.985]                         }
[17:46:21.985]                       }
[17:46:21.985]                     }
[17:46:21.985]                     invisible(muffled)
[17:46:21.985]                   }
[17:46:21.985]                   muffleCondition(cond)
[17:46:21.985]                 })
[17:46:21.985]             }))
[17:46:21.985]             future::FutureResult(value = ...future.value$value, 
[17:46:21.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.985]                   ...future.rng), globalenv = if (FALSE) 
[17:46:21.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:21.985]                     ...future.globalenv.names))
[17:46:21.985]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:21.985]         }, condition = base::local({
[17:46:21.985]             c <- base::c
[17:46:21.985]             inherits <- base::inherits
[17:46:21.985]             invokeRestart <- base::invokeRestart
[17:46:21.985]             length <- base::length
[17:46:21.985]             list <- base::list
[17:46:21.985]             seq.int <- base::seq.int
[17:46:21.985]             signalCondition <- base::signalCondition
[17:46:21.985]             sys.calls <- base::sys.calls
[17:46:21.985]             `[[` <- base::`[[`
[17:46:21.985]             `+` <- base::`+`
[17:46:21.985]             `<<-` <- base::`<<-`
[17:46:21.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:21.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:21.985]                   3L)]
[17:46:21.985]             }
[17:46:21.985]             function(cond) {
[17:46:21.985]                 is_error <- inherits(cond, "error")
[17:46:21.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:21.985]                   NULL)
[17:46:21.985]                 if (is_error) {
[17:46:21.985]                   sessionInformation <- function() {
[17:46:21.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:21.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:21.985]                       search = base::search(), system = base::Sys.info())
[17:46:21.985]                   }
[17:46:21.985]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:21.985]                     cond$call), session = sessionInformation(), 
[17:46:21.985]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:21.985]                   signalCondition(cond)
[17:46:21.985]                 }
[17:46:21.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:21.985]                 "immediateCondition"))) {
[17:46:21.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:21.985]                   ...future.conditions[[length(...future.conditions) + 
[17:46:21.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:21.985]                   if (TRUE && !signal) {
[17:46:21.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.985]                     {
[17:46:21.985]                       inherits <- base::inherits
[17:46:21.985]                       invokeRestart <- base::invokeRestart
[17:46:21.985]                       is.null <- base::is.null
[17:46:21.985]                       muffled <- FALSE
[17:46:21.985]                       if (inherits(cond, "message")) {
[17:46:21.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.985]                         if (muffled) 
[17:46:21.985]                           invokeRestart("muffleMessage")
[17:46:21.985]                       }
[17:46:21.985]                       else if (inherits(cond, "warning")) {
[17:46:21.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.985]                         if (muffled) 
[17:46:21.985]                           invokeRestart("muffleWarning")
[17:46:21.985]                       }
[17:46:21.985]                       else if (inherits(cond, "condition")) {
[17:46:21.985]                         if (!is.null(pattern)) {
[17:46:21.985]                           computeRestarts <- base::computeRestarts
[17:46:21.985]                           grepl <- base::grepl
[17:46:21.985]                           restarts <- computeRestarts(cond)
[17:46:21.985]                           for (restart in restarts) {
[17:46:21.985]                             name <- restart$name
[17:46:21.985]                             if (is.null(name)) 
[17:46:21.985]                               next
[17:46:21.985]                             if (!grepl(pattern, name)) 
[17:46:21.985]                               next
[17:46:21.985]                             invokeRestart(restart)
[17:46:21.985]                             muffled <- TRUE
[17:46:21.985]                             break
[17:46:21.985]                           }
[17:46:21.985]                         }
[17:46:21.985]                       }
[17:46:21.985]                       invisible(muffled)
[17:46:21.985]                     }
[17:46:21.985]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.985]                   }
[17:46:21.985]                 }
[17:46:21.985]                 else {
[17:46:21.985]                   if (TRUE) {
[17:46:21.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:21.985]                     {
[17:46:21.985]                       inherits <- base::inherits
[17:46:21.985]                       invokeRestart <- base::invokeRestart
[17:46:21.985]                       is.null <- base::is.null
[17:46:21.985]                       muffled <- FALSE
[17:46:21.985]                       if (inherits(cond, "message")) {
[17:46:21.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:21.985]                         if (muffled) 
[17:46:21.985]                           invokeRestart("muffleMessage")
[17:46:21.985]                       }
[17:46:21.985]                       else if (inherits(cond, "warning")) {
[17:46:21.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:21.985]                         if (muffled) 
[17:46:21.985]                           invokeRestart("muffleWarning")
[17:46:21.985]                       }
[17:46:21.985]                       else if (inherits(cond, "condition")) {
[17:46:21.985]                         if (!is.null(pattern)) {
[17:46:21.985]                           computeRestarts <- base::computeRestarts
[17:46:21.985]                           grepl <- base::grepl
[17:46:21.985]                           restarts <- computeRestarts(cond)
[17:46:21.985]                           for (restart in restarts) {
[17:46:21.985]                             name <- restart$name
[17:46:21.985]                             if (is.null(name)) 
[17:46:21.985]                               next
[17:46:21.985]                             if (!grepl(pattern, name)) 
[17:46:21.985]                               next
[17:46:21.985]                             invokeRestart(restart)
[17:46:21.985]                             muffled <- TRUE
[17:46:21.985]                             break
[17:46:21.985]                           }
[17:46:21.985]                         }
[17:46:21.985]                       }
[17:46:21.985]                       invisible(muffled)
[17:46:21.985]                     }
[17:46:21.985]                     muffleCondition(cond, pattern = "^muffle")
[17:46:21.985]                   }
[17:46:21.985]                 }
[17:46:21.985]             }
[17:46:21.985]         }))
[17:46:21.985]     }, error = function(ex) {
[17:46:21.985]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:21.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:21.985]                 ...future.rng), started = ...future.startTime, 
[17:46:21.985]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:21.985]             version = "1.8"), class = "FutureResult")
[17:46:21.985]     }, finally = {
[17:46:21.985]         if (!identical(...future.workdir, getwd())) 
[17:46:21.985]             setwd(...future.workdir)
[17:46:21.985]         {
[17:46:21.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:21.985]                 ...future.oldOptions$nwarnings <- NULL
[17:46:21.985]             }
[17:46:21.985]             base::options(...future.oldOptions)
[17:46:21.985]             if (.Platform$OS.type == "windows") {
[17:46:21.985]                 old_names <- names(...future.oldEnvVars)
[17:46:21.985]                 envs <- base::Sys.getenv()
[17:46:21.985]                 names <- names(envs)
[17:46:21.985]                 common <- intersect(names, old_names)
[17:46:21.985]                 added <- setdiff(names, old_names)
[17:46:21.985]                 removed <- setdiff(old_names, names)
[17:46:21.985]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:21.985]                   envs[common]]
[17:46:21.985]                 NAMES <- toupper(changed)
[17:46:21.985]                 args <- list()
[17:46:21.985]                 for (kk in seq_along(NAMES)) {
[17:46:21.985]                   name <- changed[[kk]]
[17:46:21.985]                   NAME <- NAMES[[kk]]
[17:46:21.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.985]                     next
[17:46:21.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.985]                 }
[17:46:21.985]                 NAMES <- toupper(added)
[17:46:21.985]                 for (kk in seq_along(NAMES)) {
[17:46:21.985]                   name <- added[[kk]]
[17:46:21.985]                   NAME <- NAMES[[kk]]
[17:46:21.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.985]                     next
[17:46:21.985]                   args[[name]] <- ""
[17:46:21.985]                 }
[17:46:21.985]                 NAMES <- toupper(removed)
[17:46:21.985]                 for (kk in seq_along(NAMES)) {
[17:46:21.985]                   name <- removed[[kk]]
[17:46:21.985]                   NAME <- NAMES[[kk]]
[17:46:21.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:21.985]                     next
[17:46:21.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:21.985]                 }
[17:46:21.985]                 if (length(args) > 0) 
[17:46:21.985]                   base::do.call(base::Sys.setenv, args = args)
[17:46:21.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:21.985]             }
[17:46:21.985]             else {
[17:46:21.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:21.985]             }
[17:46:21.985]             {
[17:46:21.985]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:21.985]                   0L) {
[17:46:21.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:21.985]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:21.985]                   base::options(opts)
[17:46:21.985]                 }
[17:46:21.985]                 {
[17:46:21.985]                   {
[17:46:21.985]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:21.985]                     NULL
[17:46:21.985]                   }
[17:46:21.985]                   options(future.plan = NULL)
[17:46:21.985]                   if (is.na(NA_character_)) 
[17:46:21.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:21.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:21.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:21.985]                     .init = FALSE)
[17:46:21.985]                 }
[17:46:21.985]             }
[17:46:21.985]         }
[17:46:21.985]     })
[17:46:21.985]     if (TRUE) {
[17:46:21.985]         base::sink(type = "output", split = FALSE)
[17:46:21.985]         if (TRUE) {
[17:46:21.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:21.985]         }
[17:46:21.985]         else {
[17:46:21.985]             ...future.result["stdout"] <- base::list(NULL)
[17:46:21.985]         }
[17:46:21.985]         base::close(...future.stdout)
[17:46:21.985]         ...future.stdout <- NULL
[17:46:21.985]     }
[17:46:21.985]     ...future.result$conditions <- ...future.conditions
[17:46:21.985]     ...future.result$finished <- base::Sys.time()
[17:46:21.985]     ...future.result
[17:46:21.985] }
[17:46:21.987] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:46:21.988] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:46:21.988] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:46:21.988] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:46:21.989] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:46:21.989] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:46:21.990] MultisessionFuture started
[17:46:21.990] - Launch lazy future ... done
[17:46:21.990] run() for ‘MultisessionFuture’ ... done
[17:46:21.990] result() for ClusterFuture ...
[17:46:21.990] receiveMessageFromWorker() for ClusterFuture ...
[17:46:21.991] - Validating connection of MultisessionFuture
[17:46:21.992] - received message: FutureResult
[17:46:21.992] - Received FutureResult
[17:46:21.992] - Erased future from FutureRegistry
[17:46:21.992] result() for ClusterFuture ...
[17:46:21.992] - result already collected: FutureResult
[17:46:21.992] result() for ClusterFuture ... done
[17:46:21.992] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:21.992] result() for ClusterFuture ... done
[17:46:21.993] result() for ClusterFuture ...
[17:46:21.993] - result already collected: FutureResult
[17:46:21.993] result() for ClusterFuture ... done
[1] 6
** Sum function 'B' with plan('multisession') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55aa00b943d8>
Arguments '...' exists: TRUE
[17:46:21.993] getGlobalsAndPackages() ...
[17:46:21.994] Searching for globals...
[17:46:21.995] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[17:46:21.995] Searching for globals ... DONE
[17:46:21.996] Resolving globals: FALSE
[17:46:21.996] Tweak future expression to call with '...' arguments ...
[17:46:21.996] {
[17:46:21.996]     do.call(function(...) {
[17:46:21.996]         sum(x, ...)
[17:46:21.996]     }, args = future.call.arguments)
[17:46:21.996] }
[17:46:21.996] Tweak future expression to call with '...' arguments ... DONE
[17:46:21.997] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:21.997] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[17:46:21.997] - globals: [2] ‘x’, ‘future.call.arguments’
[17:46:21.997] 
[17:46:21.997] getGlobalsAndPackages() ... DONE
[17:46:21.998] run() for ‘Future’ ...
[17:46:21.998] - state: ‘created’
[17:46:21.998] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:22.013] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:22.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:22.013]   - Field: ‘node’
[17:46:22.013]   - Field: ‘label’
[17:46:22.013]   - Field: ‘local’
[17:46:22.013]   - Field: ‘owner’
[17:46:22.013]   - Field: ‘envir’
[17:46:22.013]   - Field: ‘workers’
[17:46:22.013]   - Field: ‘packages’
[17:46:22.014]   - Field: ‘gc’
[17:46:22.014]   - Field: ‘conditions’
[17:46:22.014]   - Field: ‘persistent’
[17:46:22.014]   - Field: ‘expr’
[17:46:22.014]   - Field: ‘uuid’
[17:46:22.014]   - Field: ‘seed’
[17:46:22.014]   - Field: ‘version’
[17:46:22.014]   - Field: ‘result’
[17:46:22.014]   - Field: ‘asynchronous’
[17:46:22.015]   - Field: ‘calls’
[17:46:22.015]   - Field: ‘globals’
[17:46:22.015]   - Field: ‘stdout’
[17:46:22.015]   - Field: ‘earlySignal’
[17:46:22.015]   - Field: ‘lazy’
[17:46:22.015]   - Field: ‘state’
[17:46:22.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:22.015] - Launch lazy future ...
[17:46:22.016] Packages needed by the future expression (n = 0): <none>
[17:46:22.016] Packages needed by future strategies (n = 0): <none>
[17:46:22.016] {
[17:46:22.016]     {
[17:46:22.016]         {
[17:46:22.016]             ...future.startTime <- base::Sys.time()
[17:46:22.016]             {
[17:46:22.016]                 {
[17:46:22.016]                   {
[17:46:22.016]                     {
[17:46:22.016]                       base::local({
[17:46:22.016]                         has_future <- base::requireNamespace("future", 
[17:46:22.016]                           quietly = TRUE)
[17:46:22.016]                         if (has_future) {
[17:46:22.016]                           ns <- base::getNamespace("future")
[17:46:22.016]                           version <- ns[[".package"]][["version"]]
[17:46:22.016]                           if (is.null(version)) 
[17:46:22.016]                             version <- utils::packageVersion("future")
[17:46:22.016]                         }
[17:46:22.016]                         else {
[17:46:22.016]                           version <- NULL
[17:46:22.016]                         }
[17:46:22.016]                         if (!has_future || version < "1.8.0") {
[17:46:22.016]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:22.016]                             "", base::R.version$version.string), 
[17:46:22.016]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:22.016]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:22.016]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:22.016]                               "release", "version")], collapse = " "), 
[17:46:22.016]                             hostname = base::Sys.info()[["nodename"]])
[17:46:22.016]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:22.016]                             info)
[17:46:22.016]                           info <- base::paste(info, collapse = "; ")
[17:46:22.016]                           if (!has_future) {
[17:46:22.016]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:22.016]                               info)
[17:46:22.016]                           }
[17:46:22.016]                           else {
[17:46:22.016]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:22.016]                               info, version)
[17:46:22.016]                           }
[17:46:22.016]                           base::stop(msg)
[17:46:22.016]                         }
[17:46:22.016]                       })
[17:46:22.016]                     }
[17:46:22.016]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:22.016]                     base::options(mc.cores = 1L)
[17:46:22.016]                   }
[17:46:22.016]                   ...future.strategy.old <- future::plan("list")
[17:46:22.016]                   options(future.plan = NULL)
[17:46:22.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:22.016]                 }
[17:46:22.016]                 ...future.workdir <- getwd()
[17:46:22.016]             }
[17:46:22.016]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:22.016]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:22.016]         }
[17:46:22.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:22.016]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:22.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:22.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:22.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:22.016]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:22.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:22.016]             base::names(...future.oldOptions))
[17:46:22.016]     }
[17:46:22.016]     if (FALSE) {
[17:46:22.016]     }
[17:46:22.016]     else {
[17:46:22.016]         if (TRUE) {
[17:46:22.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:22.016]                 open = "w")
[17:46:22.016]         }
[17:46:22.016]         else {
[17:46:22.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:22.016]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:22.016]         }
[17:46:22.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:22.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:22.016]             base::sink(type = "output", split = FALSE)
[17:46:22.016]             base::close(...future.stdout)
[17:46:22.016]         }, add = TRUE)
[17:46:22.016]     }
[17:46:22.016]     ...future.frame <- base::sys.nframe()
[17:46:22.016]     ...future.conditions <- base::list()
[17:46:22.016]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:22.016]     if (FALSE) {
[17:46:22.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:22.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:22.016]     }
[17:46:22.016]     ...future.result <- base::tryCatch({
[17:46:22.016]         base::withCallingHandlers({
[17:46:22.016]             ...future.value <- base::withVisible(base::local({
[17:46:22.016]                 ...future.makeSendCondition <- base::local({
[17:46:22.016]                   sendCondition <- NULL
[17:46:22.016]                   function(frame = 1L) {
[17:46:22.016]                     if (is.function(sendCondition)) 
[17:46:22.016]                       return(sendCondition)
[17:46:22.016]                     ns <- getNamespace("parallel")
[17:46:22.016]                     if (exists("sendData", mode = "function", 
[17:46:22.016]                       envir = ns)) {
[17:46:22.016]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:22.016]                         envir = ns)
[17:46:22.016]                       envir <- sys.frame(frame)
[17:46:22.016]                       master <- NULL
[17:46:22.016]                       while (!identical(envir, .GlobalEnv) && 
[17:46:22.016]                         !identical(envir, emptyenv())) {
[17:46:22.016]                         if (exists("master", mode = "list", envir = envir, 
[17:46:22.016]                           inherits = FALSE)) {
[17:46:22.016]                           master <- get("master", mode = "list", 
[17:46:22.016]                             envir = envir, inherits = FALSE)
[17:46:22.016]                           if (inherits(master, c("SOCKnode", 
[17:46:22.016]                             "SOCK0node"))) {
[17:46:22.016]                             sendCondition <<- function(cond) {
[17:46:22.016]                               data <- list(type = "VALUE", value = cond, 
[17:46:22.016]                                 success = TRUE)
[17:46:22.016]                               parallel_sendData(master, data)
[17:46:22.016]                             }
[17:46:22.016]                             return(sendCondition)
[17:46:22.016]                           }
[17:46:22.016]                         }
[17:46:22.016]                         frame <- frame + 1L
[17:46:22.016]                         envir <- sys.frame(frame)
[17:46:22.016]                       }
[17:46:22.016]                     }
[17:46:22.016]                     sendCondition <<- function(cond) NULL
[17:46:22.016]                   }
[17:46:22.016]                 })
[17:46:22.016]                 withCallingHandlers({
[17:46:22.016]                   {
[17:46:22.016]                     do.call(function(...) {
[17:46:22.016]                       sum(x, ...)
[17:46:22.016]                     }, args = future.call.arguments)
[17:46:22.016]                   }
[17:46:22.016]                 }, immediateCondition = function(cond) {
[17:46:22.016]                   sendCondition <- ...future.makeSendCondition()
[17:46:22.016]                   sendCondition(cond)
[17:46:22.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.016]                   {
[17:46:22.016]                     inherits <- base::inherits
[17:46:22.016]                     invokeRestart <- base::invokeRestart
[17:46:22.016]                     is.null <- base::is.null
[17:46:22.016]                     muffled <- FALSE
[17:46:22.016]                     if (inherits(cond, "message")) {
[17:46:22.016]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:22.016]                       if (muffled) 
[17:46:22.016]                         invokeRestart("muffleMessage")
[17:46:22.016]                     }
[17:46:22.016]                     else if (inherits(cond, "warning")) {
[17:46:22.016]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:22.016]                       if (muffled) 
[17:46:22.016]                         invokeRestart("muffleWarning")
[17:46:22.016]                     }
[17:46:22.016]                     else if (inherits(cond, "condition")) {
[17:46:22.016]                       if (!is.null(pattern)) {
[17:46:22.016]                         computeRestarts <- base::computeRestarts
[17:46:22.016]                         grepl <- base::grepl
[17:46:22.016]                         restarts <- computeRestarts(cond)
[17:46:22.016]                         for (restart in restarts) {
[17:46:22.016]                           name <- restart$name
[17:46:22.016]                           if (is.null(name)) 
[17:46:22.016]                             next
[17:46:22.016]                           if (!grepl(pattern, name)) 
[17:46:22.016]                             next
[17:46:22.016]                           invokeRestart(restart)
[17:46:22.016]                           muffled <- TRUE
[17:46:22.016]                           break
[17:46:22.016]                         }
[17:46:22.016]                       }
[17:46:22.016]                     }
[17:46:22.016]                     invisible(muffled)
[17:46:22.016]                   }
[17:46:22.016]                   muffleCondition(cond)
[17:46:22.016]                 })
[17:46:22.016]             }))
[17:46:22.016]             future::FutureResult(value = ...future.value$value, 
[17:46:22.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.016]                   ...future.rng), globalenv = if (FALSE) 
[17:46:22.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:22.016]                     ...future.globalenv.names))
[17:46:22.016]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:22.016]         }, condition = base::local({
[17:46:22.016]             c <- base::c
[17:46:22.016]             inherits <- base::inherits
[17:46:22.016]             invokeRestart <- base::invokeRestart
[17:46:22.016]             length <- base::length
[17:46:22.016]             list <- base::list
[17:46:22.016]             seq.int <- base::seq.int
[17:46:22.016]             signalCondition <- base::signalCondition
[17:46:22.016]             sys.calls <- base::sys.calls
[17:46:22.016]             `[[` <- base::`[[`
[17:46:22.016]             `+` <- base::`+`
[17:46:22.016]             `<<-` <- base::`<<-`
[17:46:22.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:22.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:22.016]                   3L)]
[17:46:22.016]             }
[17:46:22.016]             function(cond) {
[17:46:22.016]                 is_error <- inherits(cond, "error")
[17:46:22.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:22.016]                   NULL)
[17:46:22.016]                 if (is_error) {
[17:46:22.016]                   sessionInformation <- function() {
[17:46:22.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:22.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:22.016]                       search = base::search(), system = base::Sys.info())
[17:46:22.016]                   }
[17:46:22.016]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:22.016]                     cond$call), session = sessionInformation(), 
[17:46:22.016]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:22.016]                   signalCondition(cond)
[17:46:22.016]                 }
[17:46:22.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:22.016]                 "immediateCondition"))) {
[17:46:22.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:22.016]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:22.016]                   if (TRUE && !signal) {
[17:46:22.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.016]                     {
[17:46:22.016]                       inherits <- base::inherits
[17:46:22.016]                       invokeRestart <- base::invokeRestart
[17:46:22.016]                       is.null <- base::is.null
[17:46:22.016]                       muffled <- FALSE
[17:46:22.016]                       if (inherits(cond, "message")) {
[17:46:22.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.016]                         if (muffled) 
[17:46:22.016]                           invokeRestart("muffleMessage")
[17:46:22.016]                       }
[17:46:22.016]                       else if (inherits(cond, "warning")) {
[17:46:22.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.016]                         if (muffled) 
[17:46:22.016]                           invokeRestart("muffleWarning")
[17:46:22.016]                       }
[17:46:22.016]                       else if (inherits(cond, "condition")) {
[17:46:22.016]                         if (!is.null(pattern)) {
[17:46:22.016]                           computeRestarts <- base::computeRestarts
[17:46:22.016]                           grepl <- base::grepl
[17:46:22.016]                           restarts <- computeRestarts(cond)
[17:46:22.016]                           for (restart in restarts) {
[17:46:22.016]                             name <- restart$name
[17:46:22.016]                             if (is.null(name)) 
[17:46:22.016]                               next
[17:46:22.016]                             if (!grepl(pattern, name)) 
[17:46:22.016]                               next
[17:46:22.016]                             invokeRestart(restart)
[17:46:22.016]                             muffled <- TRUE
[17:46:22.016]                             break
[17:46:22.016]                           }
[17:46:22.016]                         }
[17:46:22.016]                       }
[17:46:22.016]                       invisible(muffled)
[17:46:22.016]                     }
[17:46:22.016]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.016]                   }
[17:46:22.016]                 }
[17:46:22.016]                 else {
[17:46:22.016]                   if (TRUE) {
[17:46:22.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.016]                     {
[17:46:22.016]                       inherits <- base::inherits
[17:46:22.016]                       invokeRestart <- base::invokeRestart
[17:46:22.016]                       is.null <- base::is.null
[17:46:22.016]                       muffled <- FALSE
[17:46:22.016]                       if (inherits(cond, "message")) {
[17:46:22.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.016]                         if (muffled) 
[17:46:22.016]                           invokeRestart("muffleMessage")
[17:46:22.016]                       }
[17:46:22.016]                       else if (inherits(cond, "warning")) {
[17:46:22.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.016]                         if (muffled) 
[17:46:22.016]                           invokeRestart("muffleWarning")
[17:46:22.016]                       }
[17:46:22.016]                       else if (inherits(cond, "condition")) {
[17:46:22.016]                         if (!is.null(pattern)) {
[17:46:22.016]                           computeRestarts <- base::computeRestarts
[17:46:22.016]                           grepl <- base::grepl
[17:46:22.016]                           restarts <- computeRestarts(cond)
[17:46:22.016]                           for (restart in restarts) {
[17:46:22.016]                             name <- restart$name
[17:46:22.016]                             if (is.null(name)) 
[17:46:22.016]                               next
[17:46:22.016]                             if (!grepl(pattern, name)) 
[17:46:22.016]                               next
[17:46:22.016]                             invokeRestart(restart)
[17:46:22.016]                             muffled <- TRUE
[17:46:22.016]                             break
[17:46:22.016]                           }
[17:46:22.016]                         }
[17:46:22.016]                       }
[17:46:22.016]                       invisible(muffled)
[17:46:22.016]                     }
[17:46:22.016]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.016]                   }
[17:46:22.016]                 }
[17:46:22.016]             }
[17:46:22.016]         }))
[17:46:22.016]     }, error = function(ex) {
[17:46:22.016]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:22.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.016]                 ...future.rng), started = ...future.startTime, 
[17:46:22.016]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:22.016]             version = "1.8"), class = "FutureResult")
[17:46:22.016]     }, finally = {
[17:46:22.016]         if (!identical(...future.workdir, getwd())) 
[17:46:22.016]             setwd(...future.workdir)
[17:46:22.016]         {
[17:46:22.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:22.016]                 ...future.oldOptions$nwarnings <- NULL
[17:46:22.016]             }
[17:46:22.016]             base::options(...future.oldOptions)
[17:46:22.016]             if (.Platform$OS.type == "windows") {
[17:46:22.016]                 old_names <- names(...future.oldEnvVars)
[17:46:22.016]                 envs <- base::Sys.getenv()
[17:46:22.016]                 names <- names(envs)
[17:46:22.016]                 common <- intersect(names, old_names)
[17:46:22.016]                 added <- setdiff(names, old_names)
[17:46:22.016]                 removed <- setdiff(old_names, names)
[17:46:22.016]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:22.016]                   envs[common]]
[17:46:22.016]                 NAMES <- toupper(changed)
[17:46:22.016]                 args <- list()
[17:46:22.016]                 for (kk in seq_along(NAMES)) {
[17:46:22.016]                   name <- changed[[kk]]
[17:46:22.016]                   NAME <- NAMES[[kk]]
[17:46:22.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.016]                     next
[17:46:22.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.016]                 }
[17:46:22.016]                 NAMES <- toupper(added)
[17:46:22.016]                 for (kk in seq_along(NAMES)) {
[17:46:22.016]                   name <- added[[kk]]
[17:46:22.016]                   NAME <- NAMES[[kk]]
[17:46:22.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.016]                     next
[17:46:22.016]                   args[[name]] <- ""
[17:46:22.016]                 }
[17:46:22.016]                 NAMES <- toupper(removed)
[17:46:22.016]                 for (kk in seq_along(NAMES)) {
[17:46:22.016]                   name <- removed[[kk]]
[17:46:22.016]                   NAME <- NAMES[[kk]]
[17:46:22.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.016]                     next
[17:46:22.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.016]                 }
[17:46:22.016]                 if (length(args) > 0) 
[17:46:22.016]                   base::do.call(base::Sys.setenv, args = args)
[17:46:22.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:22.016]             }
[17:46:22.016]             else {
[17:46:22.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:22.016]             }
[17:46:22.016]             {
[17:46:22.016]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:22.016]                   0L) {
[17:46:22.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:22.016]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:22.016]                   base::options(opts)
[17:46:22.016]                 }
[17:46:22.016]                 {
[17:46:22.016]                   {
[17:46:22.016]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:22.016]                     NULL
[17:46:22.016]                   }
[17:46:22.016]                   options(future.plan = NULL)
[17:46:22.016]                   if (is.na(NA_character_)) 
[17:46:22.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:22.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:22.016]                     .init = FALSE)
[17:46:22.016]                 }
[17:46:22.016]             }
[17:46:22.016]         }
[17:46:22.016]     })
[17:46:22.016]     if (TRUE) {
[17:46:22.016]         base::sink(type = "output", split = FALSE)
[17:46:22.016]         if (TRUE) {
[17:46:22.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:22.016]         }
[17:46:22.016]         else {
[17:46:22.016]             ...future.result["stdout"] <- base::list(NULL)
[17:46:22.016]         }
[17:46:22.016]         base::close(...future.stdout)
[17:46:22.016]         ...future.stdout <- NULL
[17:46:22.016]     }
[17:46:22.016]     ...future.result$conditions <- ...future.conditions
[17:46:22.016]     ...future.result$finished <- base::Sys.time()
[17:46:22.016]     ...future.result
[17:46:22.016] }
[17:46:22.019] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:46:22.019] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:46:22.020] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.020] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:46:22.021] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.021] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:46:22.021] MultisessionFuture started
[17:46:22.021] - Launch lazy future ... done
[17:46:22.022] run() for ‘MultisessionFuture’ ... done
[17:46:22.022] result() for ClusterFuture ...
[17:46:22.022] receiveMessageFromWorker() for ClusterFuture ...
[17:46:22.022] - Validating connection of MultisessionFuture
[17:46:22.027] - received message: FutureResult
[17:46:22.027] - Received FutureResult
[17:46:22.027] - Erased future from FutureRegistry
[17:46:22.027] result() for ClusterFuture ...
[17:46:22.027] - result already collected: FutureResult
[17:46:22.027] result() for ClusterFuture ... done
[17:46:22.027] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:22.028] result() for ClusterFuture ... done
[17:46:22.028] result() for ClusterFuture ...
[17:46:22.028] - result already collected: FutureResult
[17:46:22.028] result() for ClusterFuture ... done
[1] 6
** Sum function 'C' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55aa00d62468>
Arguments '...' exists: FALSE
[17:46:22.029] getGlobalsAndPackages() ...
[17:46:22.029] Searching for globals...
[17:46:22.030] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[17:46:22.030] Searching for globals ... DONE
[17:46:22.030] Resolving globals: FALSE
[17:46:22.031] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:22.031] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:22.031] - globals: [2] ‘x’, ‘y’
[17:46:22.032] 
[17:46:22.032] getGlobalsAndPackages() ... DONE
[17:46:22.032] run() for ‘Future’ ...
[17:46:22.032] - state: ‘created’
[17:46:22.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:22.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:22.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:22.047]   - Field: ‘node’
[17:46:22.047]   - Field: ‘label’
[17:46:22.047]   - Field: ‘local’
[17:46:22.047]   - Field: ‘owner’
[17:46:22.047]   - Field: ‘envir’
[17:46:22.048]   - Field: ‘workers’
[17:46:22.048]   - Field: ‘packages’
[17:46:22.048]   - Field: ‘gc’
[17:46:22.048]   - Field: ‘conditions’
[17:46:22.048]   - Field: ‘persistent’
[17:46:22.048]   - Field: ‘expr’
[17:46:22.048]   - Field: ‘uuid’
[17:46:22.048]   - Field: ‘seed’
[17:46:22.048]   - Field: ‘version’
[17:46:22.049]   - Field: ‘result’
[17:46:22.049]   - Field: ‘asynchronous’
[17:46:22.049]   - Field: ‘calls’
[17:46:22.049]   - Field: ‘globals’
[17:46:22.049]   - Field: ‘stdout’
[17:46:22.049]   - Field: ‘earlySignal’
[17:46:22.049]   - Field: ‘lazy’
[17:46:22.049]   - Field: ‘state’
[17:46:22.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:22.050] - Launch lazy future ...
[17:46:22.050] Packages needed by the future expression (n = 0): <none>
[17:46:22.050] Packages needed by future strategies (n = 0): <none>
[17:46:22.051] {
[17:46:22.051]     {
[17:46:22.051]         {
[17:46:22.051]             ...future.startTime <- base::Sys.time()
[17:46:22.051]             {
[17:46:22.051]                 {
[17:46:22.051]                   {
[17:46:22.051]                     {
[17:46:22.051]                       base::local({
[17:46:22.051]                         has_future <- base::requireNamespace("future", 
[17:46:22.051]                           quietly = TRUE)
[17:46:22.051]                         if (has_future) {
[17:46:22.051]                           ns <- base::getNamespace("future")
[17:46:22.051]                           version <- ns[[".package"]][["version"]]
[17:46:22.051]                           if (is.null(version)) 
[17:46:22.051]                             version <- utils::packageVersion("future")
[17:46:22.051]                         }
[17:46:22.051]                         else {
[17:46:22.051]                           version <- NULL
[17:46:22.051]                         }
[17:46:22.051]                         if (!has_future || version < "1.8.0") {
[17:46:22.051]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:22.051]                             "", base::R.version$version.string), 
[17:46:22.051]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:22.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:22.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:22.051]                               "release", "version")], collapse = " "), 
[17:46:22.051]                             hostname = base::Sys.info()[["nodename"]])
[17:46:22.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:22.051]                             info)
[17:46:22.051]                           info <- base::paste(info, collapse = "; ")
[17:46:22.051]                           if (!has_future) {
[17:46:22.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:22.051]                               info)
[17:46:22.051]                           }
[17:46:22.051]                           else {
[17:46:22.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:22.051]                               info, version)
[17:46:22.051]                           }
[17:46:22.051]                           base::stop(msg)
[17:46:22.051]                         }
[17:46:22.051]                       })
[17:46:22.051]                     }
[17:46:22.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:22.051]                     base::options(mc.cores = 1L)
[17:46:22.051]                   }
[17:46:22.051]                   ...future.strategy.old <- future::plan("list")
[17:46:22.051]                   options(future.plan = NULL)
[17:46:22.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:22.051]                 }
[17:46:22.051]                 ...future.workdir <- getwd()
[17:46:22.051]             }
[17:46:22.051]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:22.051]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:22.051]         }
[17:46:22.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:22.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:22.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:22.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:22.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:22.051]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:22.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:22.051]             base::names(...future.oldOptions))
[17:46:22.051]     }
[17:46:22.051]     if (FALSE) {
[17:46:22.051]     }
[17:46:22.051]     else {
[17:46:22.051]         if (TRUE) {
[17:46:22.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:22.051]                 open = "w")
[17:46:22.051]         }
[17:46:22.051]         else {
[17:46:22.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:22.051]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:22.051]         }
[17:46:22.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:22.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:22.051]             base::sink(type = "output", split = FALSE)
[17:46:22.051]             base::close(...future.stdout)
[17:46:22.051]         }, add = TRUE)
[17:46:22.051]     }
[17:46:22.051]     ...future.frame <- base::sys.nframe()
[17:46:22.051]     ...future.conditions <- base::list()
[17:46:22.051]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:22.051]     if (FALSE) {
[17:46:22.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:22.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:22.051]     }
[17:46:22.051]     ...future.result <- base::tryCatch({
[17:46:22.051]         base::withCallingHandlers({
[17:46:22.051]             ...future.value <- base::withVisible(base::local({
[17:46:22.051]                 ...future.makeSendCondition <- base::local({
[17:46:22.051]                   sendCondition <- NULL
[17:46:22.051]                   function(frame = 1L) {
[17:46:22.051]                     if (is.function(sendCondition)) 
[17:46:22.051]                       return(sendCondition)
[17:46:22.051]                     ns <- getNamespace("parallel")
[17:46:22.051]                     if (exists("sendData", mode = "function", 
[17:46:22.051]                       envir = ns)) {
[17:46:22.051]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:22.051]                         envir = ns)
[17:46:22.051]                       envir <- sys.frame(frame)
[17:46:22.051]                       master <- NULL
[17:46:22.051]                       while (!identical(envir, .GlobalEnv) && 
[17:46:22.051]                         !identical(envir, emptyenv())) {
[17:46:22.051]                         if (exists("master", mode = "list", envir = envir, 
[17:46:22.051]                           inherits = FALSE)) {
[17:46:22.051]                           master <- get("master", mode = "list", 
[17:46:22.051]                             envir = envir, inherits = FALSE)
[17:46:22.051]                           if (inherits(master, c("SOCKnode", 
[17:46:22.051]                             "SOCK0node"))) {
[17:46:22.051]                             sendCondition <<- function(cond) {
[17:46:22.051]                               data <- list(type = "VALUE", value = cond, 
[17:46:22.051]                                 success = TRUE)
[17:46:22.051]                               parallel_sendData(master, data)
[17:46:22.051]                             }
[17:46:22.051]                             return(sendCondition)
[17:46:22.051]                           }
[17:46:22.051]                         }
[17:46:22.051]                         frame <- frame + 1L
[17:46:22.051]                         envir <- sys.frame(frame)
[17:46:22.051]                       }
[17:46:22.051]                     }
[17:46:22.051]                     sendCondition <<- function(cond) NULL
[17:46:22.051]                   }
[17:46:22.051]                 })
[17:46:22.051]                 withCallingHandlers({
[17:46:22.051]                   {
[17:46:22.051]                     sum(x, y)
[17:46:22.051]                   }
[17:46:22.051]                 }, immediateCondition = function(cond) {
[17:46:22.051]                   sendCondition <- ...future.makeSendCondition()
[17:46:22.051]                   sendCondition(cond)
[17:46:22.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.051]                   {
[17:46:22.051]                     inherits <- base::inherits
[17:46:22.051]                     invokeRestart <- base::invokeRestart
[17:46:22.051]                     is.null <- base::is.null
[17:46:22.051]                     muffled <- FALSE
[17:46:22.051]                     if (inherits(cond, "message")) {
[17:46:22.051]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:22.051]                       if (muffled) 
[17:46:22.051]                         invokeRestart("muffleMessage")
[17:46:22.051]                     }
[17:46:22.051]                     else if (inherits(cond, "warning")) {
[17:46:22.051]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:22.051]                       if (muffled) 
[17:46:22.051]                         invokeRestart("muffleWarning")
[17:46:22.051]                     }
[17:46:22.051]                     else if (inherits(cond, "condition")) {
[17:46:22.051]                       if (!is.null(pattern)) {
[17:46:22.051]                         computeRestarts <- base::computeRestarts
[17:46:22.051]                         grepl <- base::grepl
[17:46:22.051]                         restarts <- computeRestarts(cond)
[17:46:22.051]                         for (restart in restarts) {
[17:46:22.051]                           name <- restart$name
[17:46:22.051]                           if (is.null(name)) 
[17:46:22.051]                             next
[17:46:22.051]                           if (!grepl(pattern, name)) 
[17:46:22.051]                             next
[17:46:22.051]                           invokeRestart(restart)
[17:46:22.051]                           muffled <- TRUE
[17:46:22.051]                           break
[17:46:22.051]                         }
[17:46:22.051]                       }
[17:46:22.051]                     }
[17:46:22.051]                     invisible(muffled)
[17:46:22.051]                   }
[17:46:22.051]                   muffleCondition(cond)
[17:46:22.051]                 })
[17:46:22.051]             }))
[17:46:22.051]             future::FutureResult(value = ...future.value$value, 
[17:46:22.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.051]                   ...future.rng), globalenv = if (FALSE) 
[17:46:22.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:22.051]                     ...future.globalenv.names))
[17:46:22.051]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:22.051]         }, condition = base::local({
[17:46:22.051]             c <- base::c
[17:46:22.051]             inherits <- base::inherits
[17:46:22.051]             invokeRestart <- base::invokeRestart
[17:46:22.051]             length <- base::length
[17:46:22.051]             list <- base::list
[17:46:22.051]             seq.int <- base::seq.int
[17:46:22.051]             signalCondition <- base::signalCondition
[17:46:22.051]             sys.calls <- base::sys.calls
[17:46:22.051]             `[[` <- base::`[[`
[17:46:22.051]             `+` <- base::`+`
[17:46:22.051]             `<<-` <- base::`<<-`
[17:46:22.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:22.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:22.051]                   3L)]
[17:46:22.051]             }
[17:46:22.051]             function(cond) {
[17:46:22.051]                 is_error <- inherits(cond, "error")
[17:46:22.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:22.051]                   NULL)
[17:46:22.051]                 if (is_error) {
[17:46:22.051]                   sessionInformation <- function() {
[17:46:22.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:22.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:22.051]                       search = base::search(), system = base::Sys.info())
[17:46:22.051]                   }
[17:46:22.051]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:22.051]                     cond$call), session = sessionInformation(), 
[17:46:22.051]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:22.051]                   signalCondition(cond)
[17:46:22.051]                 }
[17:46:22.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:22.051]                 "immediateCondition"))) {
[17:46:22.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:22.051]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:22.051]                   if (TRUE && !signal) {
[17:46:22.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.051]                     {
[17:46:22.051]                       inherits <- base::inherits
[17:46:22.051]                       invokeRestart <- base::invokeRestart
[17:46:22.051]                       is.null <- base::is.null
[17:46:22.051]                       muffled <- FALSE
[17:46:22.051]                       if (inherits(cond, "message")) {
[17:46:22.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.051]                         if (muffled) 
[17:46:22.051]                           invokeRestart("muffleMessage")
[17:46:22.051]                       }
[17:46:22.051]                       else if (inherits(cond, "warning")) {
[17:46:22.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.051]                         if (muffled) 
[17:46:22.051]                           invokeRestart("muffleWarning")
[17:46:22.051]                       }
[17:46:22.051]                       else if (inherits(cond, "condition")) {
[17:46:22.051]                         if (!is.null(pattern)) {
[17:46:22.051]                           computeRestarts <- base::computeRestarts
[17:46:22.051]                           grepl <- base::grepl
[17:46:22.051]                           restarts <- computeRestarts(cond)
[17:46:22.051]                           for (restart in restarts) {
[17:46:22.051]                             name <- restart$name
[17:46:22.051]                             if (is.null(name)) 
[17:46:22.051]                               next
[17:46:22.051]                             if (!grepl(pattern, name)) 
[17:46:22.051]                               next
[17:46:22.051]                             invokeRestart(restart)
[17:46:22.051]                             muffled <- TRUE
[17:46:22.051]                             break
[17:46:22.051]                           }
[17:46:22.051]                         }
[17:46:22.051]                       }
[17:46:22.051]                       invisible(muffled)
[17:46:22.051]                     }
[17:46:22.051]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.051]                   }
[17:46:22.051]                 }
[17:46:22.051]                 else {
[17:46:22.051]                   if (TRUE) {
[17:46:22.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.051]                     {
[17:46:22.051]                       inherits <- base::inherits
[17:46:22.051]                       invokeRestart <- base::invokeRestart
[17:46:22.051]                       is.null <- base::is.null
[17:46:22.051]                       muffled <- FALSE
[17:46:22.051]                       if (inherits(cond, "message")) {
[17:46:22.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.051]                         if (muffled) 
[17:46:22.051]                           invokeRestart("muffleMessage")
[17:46:22.051]                       }
[17:46:22.051]                       else if (inherits(cond, "warning")) {
[17:46:22.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.051]                         if (muffled) 
[17:46:22.051]                           invokeRestart("muffleWarning")
[17:46:22.051]                       }
[17:46:22.051]                       else if (inherits(cond, "condition")) {
[17:46:22.051]                         if (!is.null(pattern)) {
[17:46:22.051]                           computeRestarts <- base::computeRestarts
[17:46:22.051]                           grepl <- base::grepl
[17:46:22.051]                           restarts <- computeRestarts(cond)
[17:46:22.051]                           for (restart in restarts) {
[17:46:22.051]                             name <- restart$name
[17:46:22.051]                             if (is.null(name)) 
[17:46:22.051]                               next
[17:46:22.051]                             if (!grepl(pattern, name)) 
[17:46:22.051]                               next
[17:46:22.051]                             invokeRestart(restart)
[17:46:22.051]                             muffled <- TRUE
[17:46:22.051]                             break
[17:46:22.051]                           }
[17:46:22.051]                         }
[17:46:22.051]                       }
[17:46:22.051]                       invisible(muffled)
[17:46:22.051]                     }
[17:46:22.051]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.051]                   }
[17:46:22.051]                 }
[17:46:22.051]             }
[17:46:22.051]         }))
[17:46:22.051]     }, error = function(ex) {
[17:46:22.051]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:22.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.051]                 ...future.rng), started = ...future.startTime, 
[17:46:22.051]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:22.051]             version = "1.8"), class = "FutureResult")
[17:46:22.051]     }, finally = {
[17:46:22.051]         if (!identical(...future.workdir, getwd())) 
[17:46:22.051]             setwd(...future.workdir)
[17:46:22.051]         {
[17:46:22.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:22.051]                 ...future.oldOptions$nwarnings <- NULL
[17:46:22.051]             }
[17:46:22.051]             base::options(...future.oldOptions)
[17:46:22.051]             if (.Platform$OS.type == "windows") {
[17:46:22.051]                 old_names <- names(...future.oldEnvVars)
[17:46:22.051]                 envs <- base::Sys.getenv()
[17:46:22.051]                 names <- names(envs)
[17:46:22.051]                 common <- intersect(names, old_names)
[17:46:22.051]                 added <- setdiff(names, old_names)
[17:46:22.051]                 removed <- setdiff(old_names, names)
[17:46:22.051]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:22.051]                   envs[common]]
[17:46:22.051]                 NAMES <- toupper(changed)
[17:46:22.051]                 args <- list()
[17:46:22.051]                 for (kk in seq_along(NAMES)) {
[17:46:22.051]                   name <- changed[[kk]]
[17:46:22.051]                   NAME <- NAMES[[kk]]
[17:46:22.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.051]                     next
[17:46:22.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.051]                 }
[17:46:22.051]                 NAMES <- toupper(added)
[17:46:22.051]                 for (kk in seq_along(NAMES)) {
[17:46:22.051]                   name <- added[[kk]]
[17:46:22.051]                   NAME <- NAMES[[kk]]
[17:46:22.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.051]                     next
[17:46:22.051]                   args[[name]] <- ""
[17:46:22.051]                 }
[17:46:22.051]                 NAMES <- toupper(removed)
[17:46:22.051]                 for (kk in seq_along(NAMES)) {
[17:46:22.051]                   name <- removed[[kk]]
[17:46:22.051]                   NAME <- NAMES[[kk]]
[17:46:22.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.051]                     next
[17:46:22.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.051]                 }
[17:46:22.051]                 if (length(args) > 0) 
[17:46:22.051]                   base::do.call(base::Sys.setenv, args = args)
[17:46:22.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:22.051]             }
[17:46:22.051]             else {
[17:46:22.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:22.051]             }
[17:46:22.051]             {
[17:46:22.051]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:22.051]                   0L) {
[17:46:22.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:22.051]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:22.051]                   base::options(opts)
[17:46:22.051]                 }
[17:46:22.051]                 {
[17:46:22.051]                   {
[17:46:22.051]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:22.051]                     NULL
[17:46:22.051]                   }
[17:46:22.051]                   options(future.plan = NULL)
[17:46:22.051]                   if (is.na(NA_character_)) 
[17:46:22.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:22.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:22.051]                     .init = FALSE)
[17:46:22.051]                 }
[17:46:22.051]             }
[17:46:22.051]         }
[17:46:22.051]     })
[17:46:22.051]     if (TRUE) {
[17:46:22.051]         base::sink(type = "output", split = FALSE)
[17:46:22.051]         if (TRUE) {
[17:46:22.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:22.051]         }
[17:46:22.051]         else {
[17:46:22.051]             ...future.result["stdout"] <- base::list(NULL)
[17:46:22.051]         }
[17:46:22.051]         base::close(...future.stdout)
[17:46:22.051]         ...future.stdout <- NULL
[17:46:22.051]     }
[17:46:22.051]     ...future.result$conditions <- ...future.conditions
[17:46:22.051]     ...future.result$finished <- base::Sys.time()
[17:46:22.051]     ...future.result
[17:46:22.051] }
[17:46:22.054] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:46:22.054] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:46:22.054] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.054] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[17:46:22.055] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.055] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:46:22.058] MultisessionFuture started
[17:46:22.058] - Launch lazy future ... done
[17:46:22.058] run() for ‘MultisessionFuture’ ... done
[17:46:22.058] result() for ClusterFuture ...
[17:46:22.059] receiveMessageFromWorker() for ClusterFuture ...
[17:46:22.059] - Validating connection of MultisessionFuture
[17:46:22.060] - received message: FutureResult
[17:46:22.060] - Received FutureResult
[17:46:22.060] - Erased future from FutureRegistry
[17:46:22.060] result() for ClusterFuture ...
[17:46:22.060] - result already collected: FutureResult
[17:46:22.060] result() for ClusterFuture ... done
[17:46:22.060] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:22.060] result() for ClusterFuture ... done
[17:46:22.061] result() for ClusterFuture ...
[17:46:22.061] - result already collected: FutureResult
[17:46:22.061] result() for ClusterFuture ... done
[1] 6
** Sum function 'D' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55aa00efe0c0>
Arguments '...' exists: FALSE
[17:46:22.061] getGlobalsAndPackages() ...
[17:46:22.061] Searching for globals...
[17:46:22.063] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[17:46:22.063] Searching for globals ... DONE
[17:46:22.063] Resolving globals: FALSE
[17:46:22.063] Tweak future expression to call with '...' arguments ...
[17:46:22.064] The total size of the 2 globals is 112 bytes (112 bytes)
[17:46:22.064] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:22.064] - globals: [2] ‘x’, ‘y’
[17:46:22.064] 
[17:46:22.064] getGlobalsAndPackages() ... DONE
[17:46:22.065] run() for ‘Future’ ...
[17:46:22.065] - state: ‘created’
[17:46:22.065] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:22.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:22.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:22.079]   - Field: ‘node’
[17:46:22.079]   - Field: ‘label’
[17:46:22.079]   - Field: ‘local’
[17:46:22.079]   - Field: ‘owner’
[17:46:22.079]   - Field: ‘envir’
[17:46:22.079]   - Field: ‘workers’
[17:46:22.079]   - Field: ‘packages’
[17:46:22.079]   - Field: ‘gc’
[17:46:22.079]   - Field: ‘conditions’
[17:46:22.079]   - Field: ‘persistent’
[17:46:22.080]   - Field: ‘expr’
[17:46:22.080]   - Field: ‘uuid’
[17:46:22.080]   - Field: ‘seed’
[17:46:22.080]   - Field: ‘version’
[17:46:22.080]   - Field: ‘result’
[17:46:22.080]   - Field: ‘asynchronous’
[17:46:22.080]   - Field: ‘calls’
[17:46:22.080]   - Field: ‘globals’
[17:46:22.080]   - Field: ‘stdout’
[17:46:22.080]   - Field: ‘earlySignal’
[17:46:22.080]   - Field: ‘lazy’
[17:46:22.080]   - Field: ‘state’
[17:46:22.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:22.081] - Launch lazy future ...
[17:46:22.081] Packages needed by the future expression (n = 0): <none>
[17:46:22.081] Packages needed by future strategies (n = 0): <none>
[17:46:22.081] {
[17:46:22.081]     {
[17:46:22.081]         {
[17:46:22.081]             ...future.startTime <- base::Sys.time()
[17:46:22.081]             {
[17:46:22.081]                 {
[17:46:22.081]                   {
[17:46:22.081]                     {
[17:46:22.081]                       base::local({
[17:46:22.081]                         has_future <- base::requireNamespace("future", 
[17:46:22.081]                           quietly = TRUE)
[17:46:22.081]                         if (has_future) {
[17:46:22.081]                           ns <- base::getNamespace("future")
[17:46:22.081]                           version <- ns[[".package"]][["version"]]
[17:46:22.081]                           if (is.null(version)) 
[17:46:22.081]                             version <- utils::packageVersion("future")
[17:46:22.081]                         }
[17:46:22.081]                         else {
[17:46:22.081]                           version <- NULL
[17:46:22.081]                         }
[17:46:22.081]                         if (!has_future || version < "1.8.0") {
[17:46:22.081]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:22.081]                             "", base::R.version$version.string), 
[17:46:22.081]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:22.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:22.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:22.081]                               "release", "version")], collapse = " "), 
[17:46:22.081]                             hostname = base::Sys.info()[["nodename"]])
[17:46:22.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:22.081]                             info)
[17:46:22.081]                           info <- base::paste(info, collapse = "; ")
[17:46:22.081]                           if (!has_future) {
[17:46:22.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:22.081]                               info)
[17:46:22.081]                           }
[17:46:22.081]                           else {
[17:46:22.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:22.081]                               info, version)
[17:46:22.081]                           }
[17:46:22.081]                           base::stop(msg)
[17:46:22.081]                         }
[17:46:22.081]                       })
[17:46:22.081]                     }
[17:46:22.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:22.081]                     base::options(mc.cores = 1L)
[17:46:22.081]                   }
[17:46:22.081]                   ...future.strategy.old <- future::plan("list")
[17:46:22.081]                   options(future.plan = NULL)
[17:46:22.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:22.081]                 }
[17:46:22.081]                 ...future.workdir <- getwd()
[17:46:22.081]             }
[17:46:22.081]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:22.081]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:22.081]         }
[17:46:22.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:22.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:22.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:22.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:22.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:22.081]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:22.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:22.081]             base::names(...future.oldOptions))
[17:46:22.081]     }
[17:46:22.081]     if (FALSE) {
[17:46:22.081]     }
[17:46:22.081]     else {
[17:46:22.081]         if (TRUE) {
[17:46:22.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:22.081]                 open = "w")
[17:46:22.081]         }
[17:46:22.081]         else {
[17:46:22.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:22.081]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:22.081]         }
[17:46:22.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:22.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:22.081]             base::sink(type = "output", split = FALSE)
[17:46:22.081]             base::close(...future.stdout)
[17:46:22.081]         }, add = TRUE)
[17:46:22.081]     }
[17:46:22.081]     ...future.frame <- base::sys.nframe()
[17:46:22.081]     ...future.conditions <- base::list()
[17:46:22.081]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:22.081]     if (FALSE) {
[17:46:22.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:22.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:22.081]     }
[17:46:22.081]     ...future.result <- base::tryCatch({
[17:46:22.081]         base::withCallingHandlers({
[17:46:22.081]             ...future.value <- base::withVisible(base::local({
[17:46:22.081]                 ...future.makeSendCondition <- base::local({
[17:46:22.081]                   sendCondition <- NULL
[17:46:22.081]                   function(frame = 1L) {
[17:46:22.081]                     if (is.function(sendCondition)) 
[17:46:22.081]                       return(sendCondition)
[17:46:22.081]                     ns <- getNamespace("parallel")
[17:46:22.081]                     if (exists("sendData", mode = "function", 
[17:46:22.081]                       envir = ns)) {
[17:46:22.081]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:22.081]                         envir = ns)
[17:46:22.081]                       envir <- sys.frame(frame)
[17:46:22.081]                       master <- NULL
[17:46:22.081]                       while (!identical(envir, .GlobalEnv) && 
[17:46:22.081]                         !identical(envir, emptyenv())) {
[17:46:22.081]                         if (exists("master", mode = "list", envir = envir, 
[17:46:22.081]                           inherits = FALSE)) {
[17:46:22.081]                           master <- get("master", mode = "list", 
[17:46:22.081]                             envir = envir, inherits = FALSE)
[17:46:22.081]                           if (inherits(master, c("SOCKnode", 
[17:46:22.081]                             "SOCK0node"))) {
[17:46:22.081]                             sendCondition <<- function(cond) {
[17:46:22.081]                               data <- list(type = "VALUE", value = cond, 
[17:46:22.081]                                 success = TRUE)
[17:46:22.081]                               parallel_sendData(master, data)
[17:46:22.081]                             }
[17:46:22.081]                             return(sendCondition)
[17:46:22.081]                           }
[17:46:22.081]                         }
[17:46:22.081]                         frame <- frame + 1L
[17:46:22.081]                         envir <- sys.frame(frame)
[17:46:22.081]                       }
[17:46:22.081]                     }
[17:46:22.081]                     sendCondition <<- function(cond) NULL
[17:46:22.081]                   }
[17:46:22.081]                 })
[17:46:22.081]                 withCallingHandlers({
[17:46:22.081]                   {
[17:46:22.081]                     sum(x, y, ...)
[17:46:22.081]                   }
[17:46:22.081]                 }, immediateCondition = function(cond) {
[17:46:22.081]                   sendCondition <- ...future.makeSendCondition()
[17:46:22.081]                   sendCondition(cond)
[17:46:22.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.081]                   {
[17:46:22.081]                     inherits <- base::inherits
[17:46:22.081]                     invokeRestart <- base::invokeRestart
[17:46:22.081]                     is.null <- base::is.null
[17:46:22.081]                     muffled <- FALSE
[17:46:22.081]                     if (inherits(cond, "message")) {
[17:46:22.081]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:22.081]                       if (muffled) 
[17:46:22.081]                         invokeRestart("muffleMessage")
[17:46:22.081]                     }
[17:46:22.081]                     else if (inherits(cond, "warning")) {
[17:46:22.081]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:22.081]                       if (muffled) 
[17:46:22.081]                         invokeRestart("muffleWarning")
[17:46:22.081]                     }
[17:46:22.081]                     else if (inherits(cond, "condition")) {
[17:46:22.081]                       if (!is.null(pattern)) {
[17:46:22.081]                         computeRestarts <- base::computeRestarts
[17:46:22.081]                         grepl <- base::grepl
[17:46:22.081]                         restarts <- computeRestarts(cond)
[17:46:22.081]                         for (restart in restarts) {
[17:46:22.081]                           name <- restart$name
[17:46:22.081]                           if (is.null(name)) 
[17:46:22.081]                             next
[17:46:22.081]                           if (!grepl(pattern, name)) 
[17:46:22.081]                             next
[17:46:22.081]                           invokeRestart(restart)
[17:46:22.081]                           muffled <- TRUE
[17:46:22.081]                           break
[17:46:22.081]                         }
[17:46:22.081]                       }
[17:46:22.081]                     }
[17:46:22.081]                     invisible(muffled)
[17:46:22.081]                   }
[17:46:22.081]                   muffleCondition(cond)
[17:46:22.081]                 })
[17:46:22.081]             }))
[17:46:22.081]             future::FutureResult(value = ...future.value$value, 
[17:46:22.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.081]                   ...future.rng), globalenv = if (FALSE) 
[17:46:22.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:22.081]                     ...future.globalenv.names))
[17:46:22.081]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:22.081]         }, condition = base::local({
[17:46:22.081]             c <- base::c
[17:46:22.081]             inherits <- base::inherits
[17:46:22.081]             invokeRestart <- base::invokeRestart
[17:46:22.081]             length <- base::length
[17:46:22.081]             list <- base::list
[17:46:22.081]             seq.int <- base::seq.int
[17:46:22.081]             signalCondition <- base::signalCondition
[17:46:22.081]             sys.calls <- base::sys.calls
[17:46:22.081]             `[[` <- base::`[[`
[17:46:22.081]             `+` <- base::`+`
[17:46:22.081]             `<<-` <- base::`<<-`
[17:46:22.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:22.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:22.081]                   3L)]
[17:46:22.081]             }
[17:46:22.081]             function(cond) {
[17:46:22.081]                 is_error <- inherits(cond, "error")
[17:46:22.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:22.081]                   NULL)
[17:46:22.081]                 if (is_error) {
[17:46:22.081]                   sessionInformation <- function() {
[17:46:22.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:22.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:22.081]                       search = base::search(), system = base::Sys.info())
[17:46:22.081]                   }
[17:46:22.081]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:22.081]                     cond$call), session = sessionInformation(), 
[17:46:22.081]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:22.081]                   signalCondition(cond)
[17:46:22.081]                 }
[17:46:22.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:22.081]                 "immediateCondition"))) {
[17:46:22.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:22.081]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:22.081]                   if (TRUE && !signal) {
[17:46:22.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.081]                     {
[17:46:22.081]                       inherits <- base::inherits
[17:46:22.081]                       invokeRestart <- base::invokeRestart
[17:46:22.081]                       is.null <- base::is.null
[17:46:22.081]                       muffled <- FALSE
[17:46:22.081]                       if (inherits(cond, "message")) {
[17:46:22.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.081]                         if (muffled) 
[17:46:22.081]                           invokeRestart("muffleMessage")
[17:46:22.081]                       }
[17:46:22.081]                       else if (inherits(cond, "warning")) {
[17:46:22.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.081]                         if (muffled) 
[17:46:22.081]                           invokeRestart("muffleWarning")
[17:46:22.081]                       }
[17:46:22.081]                       else if (inherits(cond, "condition")) {
[17:46:22.081]                         if (!is.null(pattern)) {
[17:46:22.081]                           computeRestarts <- base::computeRestarts
[17:46:22.081]                           grepl <- base::grepl
[17:46:22.081]                           restarts <- computeRestarts(cond)
[17:46:22.081]                           for (restart in restarts) {
[17:46:22.081]                             name <- restart$name
[17:46:22.081]                             if (is.null(name)) 
[17:46:22.081]                               next
[17:46:22.081]                             if (!grepl(pattern, name)) 
[17:46:22.081]                               next
[17:46:22.081]                             invokeRestart(restart)
[17:46:22.081]                             muffled <- TRUE
[17:46:22.081]                             break
[17:46:22.081]                           }
[17:46:22.081]                         }
[17:46:22.081]                       }
[17:46:22.081]                       invisible(muffled)
[17:46:22.081]                     }
[17:46:22.081]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.081]                   }
[17:46:22.081]                 }
[17:46:22.081]                 else {
[17:46:22.081]                   if (TRUE) {
[17:46:22.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.081]                     {
[17:46:22.081]                       inherits <- base::inherits
[17:46:22.081]                       invokeRestart <- base::invokeRestart
[17:46:22.081]                       is.null <- base::is.null
[17:46:22.081]                       muffled <- FALSE
[17:46:22.081]                       if (inherits(cond, "message")) {
[17:46:22.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.081]                         if (muffled) 
[17:46:22.081]                           invokeRestart("muffleMessage")
[17:46:22.081]                       }
[17:46:22.081]                       else if (inherits(cond, "warning")) {
[17:46:22.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.081]                         if (muffled) 
[17:46:22.081]                           invokeRestart("muffleWarning")
[17:46:22.081]                       }
[17:46:22.081]                       else if (inherits(cond, "condition")) {
[17:46:22.081]                         if (!is.null(pattern)) {
[17:46:22.081]                           computeRestarts <- base::computeRestarts
[17:46:22.081]                           grepl <- base::grepl
[17:46:22.081]                           restarts <- computeRestarts(cond)
[17:46:22.081]                           for (restart in restarts) {
[17:46:22.081]                             name <- restart$name
[17:46:22.081]                             if (is.null(name)) 
[17:46:22.081]                               next
[17:46:22.081]                             if (!grepl(pattern, name)) 
[17:46:22.081]                               next
[17:46:22.081]                             invokeRestart(restart)
[17:46:22.081]                             muffled <- TRUE
[17:46:22.081]                             break
[17:46:22.081]                           }
[17:46:22.081]                         }
[17:46:22.081]                       }
[17:46:22.081]                       invisible(muffled)
[17:46:22.081]                     }
[17:46:22.081]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.081]                   }
[17:46:22.081]                 }
[17:46:22.081]             }
[17:46:22.081]         }))
[17:46:22.081]     }, error = function(ex) {
[17:46:22.081]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:22.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.081]                 ...future.rng), started = ...future.startTime, 
[17:46:22.081]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:22.081]             version = "1.8"), class = "FutureResult")
[17:46:22.081]     }, finally = {
[17:46:22.081]         if (!identical(...future.workdir, getwd())) 
[17:46:22.081]             setwd(...future.workdir)
[17:46:22.081]         {
[17:46:22.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:22.081]                 ...future.oldOptions$nwarnings <- NULL
[17:46:22.081]             }
[17:46:22.081]             base::options(...future.oldOptions)
[17:46:22.081]             if (.Platform$OS.type == "windows") {
[17:46:22.081]                 old_names <- names(...future.oldEnvVars)
[17:46:22.081]                 envs <- base::Sys.getenv()
[17:46:22.081]                 names <- names(envs)
[17:46:22.081]                 common <- intersect(names, old_names)
[17:46:22.081]                 added <- setdiff(names, old_names)
[17:46:22.081]                 removed <- setdiff(old_names, names)
[17:46:22.081]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:22.081]                   envs[common]]
[17:46:22.081]                 NAMES <- toupper(changed)
[17:46:22.081]                 args <- list()
[17:46:22.081]                 for (kk in seq_along(NAMES)) {
[17:46:22.081]                   name <- changed[[kk]]
[17:46:22.081]                   NAME <- NAMES[[kk]]
[17:46:22.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.081]                     next
[17:46:22.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.081]                 }
[17:46:22.081]                 NAMES <- toupper(added)
[17:46:22.081]                 for (kk in seq_along(NAMES)) {
[17:46:22.081]                   name <- added[[kk]]
[17:46:22.081]                   NAME <- NAMES[[kk]]
[17:46:22.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.081]                     next
[17:46:22.081]                   args[[name]] <- ""
[17:46:22.081]                 }
[17:46:22.081]                 NAMES <- toupper(removed)
[17:46:22.081]                 for (kk in seq_along(NAMES)) {
[17:46:22.081]                   name <- removed[[kk]]
[17:46:22.081]                   NAME <- NAMES[[kk]]
[17:46:22.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.081]                     next
[17:46:22.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.081]                 }
[17:46:22.081]                 if (length(args) > 0) 
[17:46:22.081]                   base::do.call(base::Sys.setenv, args = args)
[17:46:22.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:22.081]             }
[17:46:22.081]             else {
[17:46:22.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:22.081]             }
[17:46:22.081]             {
[17:46:22.081]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:22.081]                   0L) {
[17:46:22.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:22.081]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:22.081]                   base::options(opts)
[17:46:22.081]                 }
[17:46:22.081]                 {
[17:46:22.081]                   {
[17:46:22.081]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:22.081]                     NULL
[17:46:22.081]                   }
[17:46:22.081]                   options(future.plan = NULL)
[17:46:22.081]                   if (is.na(NA_character_)) 
[17:46:22.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:22.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:22.081]                     .init = FALSE)
[17:46:22.081]                 }
[17:46:22.081]             }
[17:46:22.081]         }
[17:46:22.081]     })
[17:46:22.081]     if (TRUE) {
[17:46:22.081]         base::sink(type = "output", split = FALSE)
[17:46:22.081]         if (TRUE) {
[17:46:22.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:22.081]         }
[17:46:22.081]         else {
[17:46:22.081]             ...future.result["stdout"] <- base::list(NULL)
[17:46:22.081]         }
[17:46:22.081]         base::close(...future.stdout)
[17:46:22.081]         ...future.stdout <- NULL
[17:46:22.081]     }
[17:46:22.081]     ...future.result$conditions <- ...future.conditions
[17:46:22.081]     ...future.result$finished <- base::Sys.time()
[17:46:22.081]     ...future.result
[17:46:22.081] }
[17:46:22.084] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:46:22.084] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:46:22.084] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.084] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[17:46:22.085] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.085] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:46:22.085] MultisessionFuture started
[17:46:22.085] - Launch lazy future ... done
[17:46:22.086] run() for ‘MultisessionFuture’ ... done
[17:46:22.086] result() for ClusterFuture ...
[17:46:22.086] receiveMessageFromWorker() for ClusterFuture ...
[17:46:22.086] - Validating connection of MultisessionFuture
[17:46:22.087] - received message: FutureResult
[17:46:22.088] - Received FutureResult
[17:46:22.088] - Erased future from FutureRegistry
[17:46:22.088] result() for ClusterFuture ...
[17:46:22.088] - result already collected: FutureResult
[17:46:22.088] result() for ClusterFuture ... done
[17:46:22.088] signalConditions() ...
[17:46:22.088]  - include = ‘immediateCondition’
[17:46:22.088]  - exclude = 
[17:46:22.088]  - resignal = FALSE
[17:46:22.088]  - Number of conditions: 1
[17:46:22.089] signalConditions() ... done
[17:46:22.089] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:22.089] result() for ClusterFuture ... done
[17:46:22.089] result() for ClusterFuture ...
[17:46:22.089] - result already collected: FutureResult
[17:46:22.089] result() for ClusterFuture ... done
[17:46:22.089] signalConditions() ...
[17:46:22.089]  - include = ‘immediateCondition’
[17:46:22.089]  - exclude = 
[17:46:22.089]  - resignal = FALSE
[17:46:22.089]  - Number of conditions: 1
[17:46:22.089] signalConditions() ... done
[17:46:22.090] Future state: ‘finished’
[17:46:22.090] result() for ClusterFuture ...
[17:46:22.090] - result already collected: FutureResult
[17:46:22.090] result() for ClusterFuture ... done
[17:46:22.090] signalConditions() ...
[17:46:22.090]  - include = ‘condition’
[17:46:22.090]  - exclude = ‘immediateCondition’
[17:46:22.090]  - resignal = TRUE
[17:46:22.090]  - Number of conditions: 1
[17:46:22.090]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:46:22.090] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multisession') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55aa014e9798>
Arguments '...' exists: TRUE
[17:46:22.091] getGlobalsAndPackages() ...
[17:46:22.091] - globals passed as-is: [1] ‘...’
[17:46:22.092] Resolving globals: FALSE
[17:46:22.092] Tweak future expression to call with '...' arguments ...
[17:46:22.092] {
[17:46:22.092]     do.call(function(...) {
[17:46:22.092]         fcn <- function() sum(...)
[17:46:22.092]         fcn()
[17:46:22.092]     }, args = future.call.arguments)
[17:46:22.092] }
[17:46:22.092] Tweak future expression to call with '...' arguments ... DONE
[17:46:22.092] The total size of the 1 globals is 112 bytes (112 bytes)
[17:46:22.093] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[17:46:22.093] - globals: [1] ‘future.call.arguments’
[17:46:22.093] 
[17:46:22.093] getGlobalsAndPackages() ... DONE
[17:46:22.093] run() for ‘Future’ ...
[17:46:22.093] - state: ‘created’
[17:46:22.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:22.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:22.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:22.107]   - Field: ‘node’
[17:46:22.107]   - Field: ‘label’
[17:46:22.107]   - Field: ‘local’
[17:46:22.108]   - Field: ‘owner’
[17:46:22.108]   - Field: ‘envir’
[17:46:22.108]   - Field: ‘workers’
[17:46:22.108]   - Field: ‘packages’
[17:46:22.108]   - Field: ‘gc’
[17:46:22.108]   - Field: ‘conditions’
[17:46:22.108]   - Field: ‘persistent’
[17:46:22.108]   - Field: ‘expr’
[17:46:22.108]   - Field: ‘uuid’
[17:46:22.108]   - Field: ‘seed’
[17:46:22.108]   - Field: ‘version’
[17:46:22.109]   - Field: ‘result’
[17:46:22.109]   - Field: ‘asynchronous’
[17:46:22.109]   - Field: ‘calls’
[17:46:22.109]   - Field: ‘globals’
[17:46:22.109]   - Field: ‘stdout’
[17:46:22.109]   - Field: ‘earlySignal’
[17:46:22.109]   - Field: ‘lazy’
[17:46:22.109]   - Field: ‘state’
[17:46:22.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:22.109] - Launch lazy future ...
[17:46:22.110] Packages needed by the future expression (n = 0): <none>
[17:46:22.110] Packages needed by future strategies (n = 0): <none>
[17:46:22.110] {
[17:46:22.110]     {
[17:46:22.110]         {
[17:46:22.110]             ...future.startTime <- base::Sys.time()
[17:46:22.110]             {
[17:46:22.110]                 {
[17:46:22.110]                   {
[17:46:22.110]                     {
[17:46:22.110]                       base::local({
[17:46:22.110]                         has_future <- base::requireNamespace("future", 
[17:46:22.110]                           quietly = TRUE)
[17:46:22.110]                         if (has_future) {
[17:46:22.110]                           ns <- base::getNamespace("future")
[17:46:22.110]                           version <- ns[[".package"]][["version"]]
[17:46:22.110]                           if (is.null(version)) 
[17:46:22.110]                             version <- utils::packageVersion("future")
[17:46:22.110]                         }
[17:46:22.110]                         else {
[17:46:22.110]                           version <- NULL
[17:46:22.110]                         }
[17:46:22.110]                         if (!has_future || version < "1.8.0") {
[17:46:22.110]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:22.110]                             "", base::R.version$version.string), 
[17:46:22.110]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:22.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:22.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:22.110]                               "release", "version")], collapse = " "), 
[17:46:22.110]                             hostname = base::Sys.info()[["nodename"]])
[17:46:22.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:22.110]                             info)
[17:46:22.110]                           info <- base::paste(info, collapse = "; ")
[17:46:22.110]                           if (!has_future) {
[17:46:22.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:22.110]                               info)
[17:46:22.110]                           }
[17:46:22.110]                           else {
[17:46:22.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:22.110]                               info, version)
[17:46:22.110]                           }
[17:46:22.110]                           base::stop(msg)
[17:46:22.110]                         }
[17:46:22.110]                       })
[17:46:22.110]                     }
[17:46:22.110]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:22.110]                     base::options(mc.cores = 1L)
[17:46:22.110]                   }
[17:46:22.110]                   ...future.strategy.old <- future::plan("list")
[17:46:22.110]                   options(future.plan = NULL)
[17:46:22.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:22.110]                 }
[17:46:22.110]                 ...future.workdir <- getwd()
[17:46:22.110]             }
[17:46:22.110]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:22.110]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:22.110]         }
[17:46:22.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:22.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:22.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:22.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:22.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:22.110]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:22.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:22.110]             base::names(...future.oldOptions))
[17:46:22.110]     }
[17:46:22.110]     if (FALSE) {
[17:46:22.110]     }
[17:46:22.110]     else {
[17:46:22.110]         if (TRUE) {
[17:46:22.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:22.110]                 open = "w")
[17:46:22.110]         }
[17:46:22.110]         else {
[17:46:22.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:22.110]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:22.110]         }
[17:46:22.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:22.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:22.110]             base::sink(type = "output", split = FALSE)
[17:46:22.110]             base::close(...future.stdout)
[17:46:22.110]         }, add = TRUE)
[17:46:22.110]     }
[17:46:22.110]     ...future.frame <- base::sys.nframe()
[17:46:22.110]     ...future.conditions <- base::list()
[17:46:22.110]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:22.110]     if (FALSE) {
[17:46:22.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:22.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:22.110]     }
[17:46:22.110]     ...future.result <- base::tryCatch({
[17:46:22.110]         base::withCallingHandlers({
[17:46:22.110]             ...future.value <- base::withVisible(base::local({
[17:46:22.110]                 ...future.makeSendCondition <- base::local({
[17:46:22.110]                   sendCondition <- NULL
[17:46:22.110]                   function(frame = 1L) {
[17:46:22.110]                     if (is.function(sendCondition)) 
[17:46:22.110]                       return(sendCondition)
[17:46:22.110]                     ns <- getNamespace("parallel")
[17:46:22.110]                     if (exists("sendData", mode = "function", 
[17:46:22.110]                       envir = ns)) {
[17:46:22.110]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:22.110]                         envir = ns)
[17:46:22.110]                       envir <- sys.frame(frame)
[17:46:22.110]                       master <- NULL
[17:46:22.110]                       while (!identical(envir, .GlobalEnv) && 
[17:46:22.110]                         !identical(envir, emptyenv())) {
[17:46:22.110]                         if (exists("master", mode = "list", envir = envir, 
[17:46:22.110]                           inherits = FALSE)) {
[17:46:22.110]                           master <- get("master", mode = "list", 
[17:46:22.110]                             envir = envir, inherits = FALSE)
[17:46:22.110]                           if (inherits(master, c("SOCKnode", 
[17:46:22.110]                             "SOCK0node"))) {
[17:46:22.110]                             sendCondition <<- function(cond) {
[17:46:22.110]                               data <- list(type = "VALUE", value = cond, 
[17:46:22.110]                                 success = TRUE)
[17:46:22.110]                               parallel_sendData(master, data)
[17:46:22.110]                             }
[17:46:22.110]                             return(sendCondition)
[17:46:22.110]                           }
[17:46:22.110]                         }
[17:46:22.110]                         frame <- frame + 1L
[17:46:22.110]                         envir <- sys.frame(frame)
[17:46:22.110]                       }
[17:46:22.110]                     }
[17:46:22.110]                     sendCondition <<- function(cond) NULL
[17:46:22.110]                   }
[17:46:22.110]                 })
[17:46:22.110]                 withCallingHandlers({
[17:46:22.110]                   {
[17:46:22.110]                     do.call(function(...) {
[17:46:22.110]                       fcn <- function() sum(...)
[17:46:22.110]                       fcn()
[17:46:22.110]                     }, args = future.call.arguments)
[17:46:22.110]                   }
[17:46:22.110]                 }, immediateCondition = function(cond) {
[17:46:22.110]                   sendCondition <- ...future.makeSendCondition()
[17:46:22.110]                   sendCondition(cond)
[17:46:22.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.110]                   {
[17:46:22.110]                     inherits <- base::inherits
[17:46:22.110]                     invokeRestart <- base::invokeRestart
[17:46:22.110]                     is.null <- base::is.null
[17:46:22.110]                     muffled <- FALSE
[17:46:22.110]                     if (inherits(cond, "message")) {
[17:46:22.110]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:22.110]                       if (muffled) 
[17:46:22.110]                         invokeRestart("muffleMessage")
[17:46:22.110]                     }
[17:46:22.110]                     else if (inherits(cond, "warning")) {
[17:46:22.110]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:22.110]                       if (muffled) 
[17:46:22.110]                         invokeRestart("muffleWarning")
[17:46:22.110]                     }
[17:46:22.110]                     else if (inherits(cond, "condition")) {
[17:46:22.110]                       if (!is.null(pattern)) {
[17:46:22.110]                         computeRestarts <- base::computeRestarts
[17:46:22.110]                         grepl <- base::grepl
[17:46:22.110]                         restarts <- computeRestarts(cond)
[17:46:22.110]                         for (restart in restarts) {
[17:46:22.110]                           name <- restart$name
[17:46:22.110]                           if (is.null(name)) 
[17:46:22.110]                             next
[17:46:22.110]                           if (!grepl(pattern, name)) 
[17:46:22.110]                             next
[17:46:22.110]                           invokeRestart(restart)
[17:46:22.110]                           muffled <- TRUE
[17:46:22.110]                           break
[17:46:22.110]                         }
[17:46:22.110]                       }
[17:46:22.110]                     }
[17:46:22.110]                     invisible(muffled)
[17:46:22.110]                   }
[17:46:22.110]                   muffleCondition(cond)
[17:46:22.110]                 })
[17:46:22.110]             }))
[17:46:22.110]             future::FutureResult(value = ...future.value$value, 
[17:46:22.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.110]                   ...future.rng), globalenv = if (FALSE) 
[17:46:22.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:22.110]                     ...future.globalenv.names))
[17:46:22.110]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:22.110]         }, condition = base::local({
[17:46:22.110]             c <- base::c
[17:46:22.110]             inherits <- base::inherits
[17:46:22.110]             invokeRestart <- base::invokeRestart
[17:46:22.110]             length <- base::length
[17:46:22.110]             list <- base::list
[17:46:22.110]             seq.int <- base::seq.int
[17:46:22.110]             signalCondition <- base::signalCondition
[17:46:22.110]             sys.calls <- base::sys.calls
[17:46:22.110]             `[[` <- base::`[[`
[17:46:22.110]             `+` <- base::`+`
[17:46:22.110]             `<<-` <- base::`<<-`
[17:46:22.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:22.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:22.110]                   3L)]
[17:46:22.110]             }
[17:46:22.110]             function(cond) {
[17:46:22.110]                 is_error <- inherits(cond, "error")
[17:46:22.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:22.110]                   NULL)
[17:46:22.110]                 if (is_error) {
[17:46:22.110]                   sessionInformation <- function() {
[17:46:22.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:22.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:22.110]                       search = base::search(), system = base::Sys.info())
[17:46:22.110]                   }
[17:46:22.110]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:22.110]                     cond$call), session = sessionInformation(), 
[17:46:22.110]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:22.110]                   signalCondition(cond)
[17:46:22.110]                 }
[17:46:22.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:22.110]                 "immediateCondition"))) {
[17:46:22.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:22.110]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:22.110]                   if (TRUE && !signal) {
[17:46:22.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.110]                     {
[17:46:22.110]                       inherits <- base::inherits
[17:46:22.110]                       invokeRestart <- base::invokeRestart
[17:46:22.110]                       is.null <- base::is.null
[17:46:22.110]                       muffled <- FALSE
[17:46:22.110]                       if (inherits(cond, "message")) {
[17:46:22.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.110]                         if (muffled) 
[17:46:22.110]                           invokeRestart("muffleMessage")
[17:46:22.110]                       }
[17:46:22.110]                       else if (inherits(cond, "warning")) {
[17:46:22.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.110]                         if (muffled) 
[17:46:22.110]                           invokeRestart("muffleWarning")
[17:46:22.110]                       }
[17:46:22.110]                       else if (inherits(cond, "condition")) {
[17:46:22.110]                         if (!is.null(pattern)) {
[17:46:22.110]                           computeRestarts <- base::computeRestarts
[17:46:22.110]                           grepl <- base::grepl
[17:46:22.110]                           restarts <- computeRestarts(cond)
[17:46:22.110]                           for (restart in restarts) {
[17:46:22.110]                             name <- restart$name
[17:46:22.110]                             if (is.null(name)) 
[17:46:22.110]                               next
[17:46:22.110]                             if (!grepl(pattern, name)) 
[17:46:22.110]                               next
[17:46:22.110]                             invokeRestart(restart)
[17:46:22.110]                             muffled <- TRUE
[17:46:22.110]                             break
[17:46:22.110]                           }
[17:46:22.110]                         }
[17:46:22.110]                       }
[17:46:22.110]                       invisible(muffled)
[17:46:22.110]                     }
[17:46:22.110]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.110]                   }
[17:46:22.110]                 }
[17:46:22.110]                 else {
[17:46:22.110]                   if (TRUE) {
[17:46:22.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.110]                     {
[17:46:22.110]                       inherits <- base::inherits
[17:46:22.110]                       invokeRestart <- base::invokeRestart
[17:46:22.110]                       is.null <- base::is.null
[17:46:22.110]                       muffled <- FALSE
[17:46:22.110]                       if (inherits(cond, "message")) {
[17:46:22.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.110]                         if (muffled) 
[17:46:22.110]                           invokeRestart("muffleMessage")
[17:46:22.110]                       }
[17:46:22.110]                       else if (inherits(cond, "warning")) {
[17:46:22.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.110]                         if (muffled) 
[17:46:22.110]                           invokeRestart("muffleWarning")
[17:46:22.110]                       }
[17:46:22.110]                       else if (inherits(cond, "condition")) {
[17:46:22.110]                         if (!is.null(pattern)) {
[17:46:22.110]                           computeRestarts <- base::computeRestarts
[17:46:22.110]                           grepl <- base::grepl
[17:46:22.110]                           restarts <- computeRestarts(cond)
[17:46:22.110]                           for (restart in restarts) {
[17:46:22.110]                             name <- restart$name
[17:46:22.110]                             if (is.null(name)) 
[17:46:22.110]                               next
[17:46:22.110]                             if (!grepl(pattern, name)) 
[17:46:22.110]                               next
[17:46:22.110]                             invokeRestart(restart)
[17:46:22.110]                             muffled <- TRUE
[17:46:22.110]                             break
[17:46:22.110]                           }
[17:46:22.110]                         }
[17:46:22.110]                       }
[17:46:22.110]                       invisible(muffled)
[17:46:22.110]                     }
[17:46:22.110]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.110]                   }
[17:46:22.110]                 }
[17:46:22.110]             }
[17:46:22.110]         }))
[17:46:22.110]     }, error = function(ex) {
[17:46:22.110]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:22.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.110]                 ...future.rng), started = ...future.startTime, 
[17:46:22.110]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:22.110]             version = "1.8"), class = "FutureResult")
[17:46:22.110]     }, finally = {
[17:46:22.110]         if (!identical(...future.workdir, getwd())) 
[17:46:22.110]             setwd(...future.workdir)
[17:46:22.110]         {
[17:46:22.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:22.110]                 ...future.oldOptions$nwarnings <- NULL
[17:46:22.110]             }
[17:46:22.110]             base::options(...future.oldOptions)
[17:46:22.110]             if (.Platform$OS.type == "windows") {
[17:46:22.110]                 old_names <- names(...future.oldEnvVars)
[17:46:22.110]                 envs <- base::Sys.getenv()
[17:46:22.110]                 names <- names(envs)
[17:46:22.110]                 common <- intersect(names, old_names)
[17:46:22.110]                 added <- setdiff(names, old_names)
[17:46:22.110]                 removed <- setdiff(old_names, names)
[17:46:22.110]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:22.110]                   envs[common]]
[17:46:22.110]                 NAMES <- toupper(changed)
[17:46:22.110]                 args <- list()
[17:46:22.110]                 for (kk in seq_along(NAMES)) {
[17:46:22.110]                   name <- changed[[kk]]
[17:46:22.110]                   NAME <- NAMES[[kk]]
[17:46:22.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.110]                     next
[17:46:22.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.110]                 }
[17:46:22.110]                 NAMES <- toupper(added)
[17:46:22.110]                 for (kk in seq_along(NAMES)) {
[17:46:22.110]                   name <- added[[kk]]
[17:46:22.110]                   NAME <- NAMES[[kk]]
[17:46:22.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.110]                     next
[17:46:22.110]                   args[[name]] <- ""
[17:46:22.110]                 }
[17:46:22.110]                 NAMES <- toupper(removed)
[17:46:22.110]                 for (kk in seq_along(NAMES)) {
[17:46:22.110]                   name <- removed[[kk]]
[17:46:22.110]                   NAME <- NAMES[[kk]]
[17:46:22.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.110]                     next
[17:46:22.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.110]                 }
[17:46:22.110]                 if (length(args) > 0) 
[17:46:22.110]                   base::do.call(base::Sys.setenv, args = args)
[17:46:22.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:22.110]             }
[17:46:22.110]             else {
[17:46:22.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:22.110]             }
[17:46:22.110]             {
[17:46:22.110]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:22.110]                   0L) {
[17:46:22.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:22.110]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:22.110]                   base::options(opts)
[17:46:22.110]                 }
[17:46:22.110]                 {
[17:46:22.110]                   {
[17:46:22.110]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:22.110]                     NULL
[17:46:22.110]                   }
[17:46:22.110]                   options(future.plan = NULL)
[17:46:22.110]                   if (is.na(NA_character_)) 
[17:46:22.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:22.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:22.110]                     .init = FALSE)
[17:46:22.110]                 }
[17:46:22.110]             }
[17:46:22.110]         }
[17:46:22.110]     })
[17:46:22.110]     if (TRUE) {
[17:46:22.110]         base::sink(type = "output", split = FALSE)
[17:46:22.110]         if (TRUE) {
[17:46:22.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:22.110]         }
[17:46:22.110]         else {
[17:46:22.110]             ...future.result["stdout"] <- base::list(NULL)
[17:46:22.110]         }
[17:46:22.110]         base::close(...future.stdout)
[17:46:22.110]         ...future.stdout <- NULL
[17:46:22.110]     }
[17:46:22.110]     ...future.result$conditions <- ...future.conditions
[17:46:22.110]     ...future.result$finished <- base::Sys.time()
[17:46:22.110]     ...future.result
[17:46:22.110] }
[17:46:22.113] Exporting 1 global objects (112 bytes) to cluster node #1 ...
[17:46:22.113] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ...
[17:46:22.113] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ... DONE
[17:46:22.113] Exporting 1 global objects (112 bytes) to cluster node #1 ... DONE
[17:46:22.114] MultisessionFuture started
[17:46:22.114] - Launch lazy future ... done
[17:46:22.114] run() for ‘MultisessionFuture’ ... done
[17:46:22.114] result() for ClusterFuture ...
[17:46:22.114] receiveMessageFromWorker() for ClusterFuture ...
[17:46:22.114] - Validating connection of MultisessionFuture
[17:46:22.115] - received message: FutureResult
[17:46:22.115] - Received FutureResult
[17:46:22.115] - Erased future from FutureRegistry
[17:46:22.116] result() for ClusterFuture ...
[17:46:22.116] - result already collected: FutureResult
[17:46:22.116] result() for ClusterFuture ... done
[17:46:22.116] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:22.116] result() for ClusterFuture ... done
[17:46:22.116] result() for ClusterFuture ...
[17:46:22.116] - result already collected: FutureResult
[17:46:22.116] result() for ClusterFuture ... done
[1] 6
** Sum function 'F' with plan('multisession') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55a9ff52fd68>
Using '...' in a formula
[17:46:22.117] getGlobalsAndPackages() ...
[17:46:22.117] Searching for globals...
[17:46:22.119] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘...’, ‘sum’
[17:46:22.119] Searching for globals ... DONE
[17:46:22.119] Resolving globals: FALSE
[17:46:22.119] Tweak future expression to call with '...' arguments ...
[17:46:22.120] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[17:46:22.120] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[17:46:22.120] - globals: [3] ‘fcn’, ‘x’, ‘y’
[17:46:22.121] 
[17:46:22.121] getGlobalsAndPackages() ... DONE
[17:46:22.121] run() for ‘Future’ ...
[17:46:22.121] - state: ‘created’
[17:46:22.121] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:46:22.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:46:22.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:46:22.135]   - Field: ‘node’
[17:46:22.135]   - Field: ‘label’
[17:46:22.135]   - Field: ‘local’
[17:46:22.135]   - Field: ‘owner’
[17:46:22.135]   - Field: ‘envir’
[17:46:22.135]   - Field: ‘workers’
[17:46:22.135]   - Field: ‘packages’
[17:46:22.135]   - Field: ‘gc’
[17:46:22.135]   - Field: ‘conditions’
[17:46:22.135]   - Field: ‘persistent’
[17:46:22.136]   - Field: ‘expr’
[17:46:22.136]   - Field: ‘uuid’
[17:46:22.136]   - Field: ‘seed’
[17:46:22.136]   - Field: ‘version’
[17:46:22.136]   - Field: ‘result’
[17:46:22.136]   - Field: ‘asynchronous’
[17:46:22.136]   - Field: ‘calls’
[17:46:22.136]   - Field: ‘globals’
[17:46:22.136]   - Field: ‘stdout’
[17:46:22.136]   - Field: ‘earlySignal’
[17:46:22.136]   - Field: ‘lazy’
[17:46:22.136]   - Field: ‘state’
[17:46:22.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:46:22.137] - Launch lazy future ...
[17:46:22.137] Packages needed by the future expression (n = 0): <none>
[17:46:22.137] Packages needed by future strategies (n = 0): <none>
[17:46:22.137] {
[17:46:22.137]     {
[17:46:22.137]         {
[17:46:22.137]             ...future.startTime <- base::Sys.time()
[17:46:22.137]             {
[17:46:22.137]                 {
[17:46:22.137]                   {
[17:46:22.137]                     {
[17:46:22.137]                       base::local({
[17:46:22.137]                         has_future <- base::requireNamespace("future", 
[17:46:22.137]                           quietly = TRUE)
[17:46:22.137]                         if (has_future) {
[17:46:22.137]                           ns <- base::getNamespace("future")
[17:46:22.137]                           version <- ns[[".package"]][["version"]]
[17:46:22.137]                           if (is.null(version)) 
[17:46:22.137]                             version <- utils::packageVersion("future")
[17:46:22.137]                         }
[17:46:22.137]                         else {
[17:46:22.137]                           version <- NULL
[17:46:22.137]                         }
[17:46:22.137]                         if (!has_future || version < "1.8.0") {
[17:46:22.137]                           info <- base::c(r_version = base::gsub("R version ", 
[17:46:22.137]                             "", base::R.version$version.string), 
[17:46:22.137]                             platform = base::sprintf("%s (%s-bit)", 
[17:46:22.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:46:22.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:46:22.137]                               "release", "version")], collapse = " "), 
[17:46:22.137]                             hostname = base::Sys.info()[["nodename"]])
[17:46:22.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:46:22.137]                             info)
[17:46:22.137]                           info <- base::paste(info, collapse = "; ")
[17:46:22.137]                           if (!has_future) {
[17:46:22.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:46:22.137]                               info)
[17:46:22.137]                           }
[17:46:22.137]                           else {
[17:46:22.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:46:22.137]                               info, version)
[17:46:22.137]                           }
[17:46:22.137]                           base::stop(msg)
[17:46:22.137]                         }
[17:46:22.137]                       })
[17:46:22.137]                     }
[17:46:22.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:46:22.137]                     base::options(mc.cores = 1L)
[17:46:22.137]                   }
[17:46:22.137]                   ...future.strategy.old <- future::plan("list")
[17:46:22.137]                   options(future.plan = NULL)
[17:46:22.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:46:22.137]                 }
[17:46:22.137]                 ...future.workdir <- getwd()
[17:46:22.137]             }
[17:46:22.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:46:22.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:46:22.137]         }
[17:46:22.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:46:22.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:46:22.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:46:22.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:46:22.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:46:22.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:46:22.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:46:22.137]             base::names(...future.oldOptions))
[17:46:22.137]     }
[17:46:22.137]     if (FALSE) {
[17:46:22.137]     }
[17:46:22.137]     else {
[17:46:22.137]         if (TRUE) {
[17:46:22.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:46:22.137]                 open = "w")
[17:46:22.137]         }
[17:46:22.137]         else {
[17:46:22.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:46:22.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:46:22.137]         }
[17:46:22.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:46:22.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:46:22.137]             base::sink(type = "output", split = FALSE)
[17:46:22.137]             base::close(...future.stdout)
[17:46:22.137]         }, add = TRUE)
[17:46:22.137]     }
[17:46:22.137]     ...future.frame <- base::sys.nframe()
[17:46:22.137]     ...future.conditions <- base::list()
[17:46:22.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:46:22.137]     if (FALSE) {
[17:46:22.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:46:22.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:46:22.137]     }
[17:46:22.137]     ...future.result <- base::tryCatch({
[17:46:22.137]         base::withCallingHandlers({
[17:46:22.137]             ...future.value <- base::withVisible(base::local({
[17:46:22.137]                 ...future.makeSendCondition <- base::local({
[17:46:22.137]                   sendCondition <- NULL
[17:46:22.137]                   function(frame = 1L) {
[17:46:22.137]                     if (is.function(sendCondition)) 
[17:46:22.137]                       return(sendCondition)
[17:46:22.137]                     ns <- getNamespace("parallel")
[17:46:22.137]                     if (exists("sendData", mode = "function", 
[17:46:22.137]                       envir = ns)) {
[17:46:22.137]                       parallel_sendData <- get("sendData", mode = "function", 
[17:46:22.137]                         envir = ns)
[17:46:22.137]                       envir <- sys.frame(frame)
[17:46:22.137]                       master <- NULL
[17:46:22.137]                       while (!identical(envir, .GlobalEnv) && 
[17:46:22.137]                         !identical(envir, emptyenv())) {
[17:46:22.137]                         if (exists("master", mode = "list", envir = envir, 
[17:46:22.137]                           inherits = FALSE)) {
[17:46:22.137]                           master <- get("master", mode = "list", 
[17:46:22.137]                             envir = envir, inherits = FALSE)
[17:46:22.137]                           if (inherits(master, c("SOCKnode", 
[17:46:22.137]                             "SOCK0node"))) {
[17:46:22.137]                             sendCondition <<- function(cond) {
[17:46:22.137]                               data <- list(type = "VALUE", value = cond, 
[17:46:22.137]                                 success = TRUE)
[17:46:22.137]                               parallel_sendData(master, data)
[17:46:22.137]                             }
[17:46:22.137]                             return(sendCondition)
[17:46:22.137]                           }
[17:46:22.137]                         }
[17:46:22.137]                         frame <- frame + 1L
[17:46:22.137]                         envir <- sys.frame(frame)
[17:46:22.137]                       }
[17:46:22.137]                     }
[17:46:22.137]                     sendCondition <<- function(cond) NULL
[17:46:22.137]                   }
[17:46:22.137]                 })
[17:46:22.137]                 withCallingHandlers({
[17:46:22.137]                   fcn(x, y)
[17:46:22.137]                 }, immediateCondition = function(cond) {
[17:46:22.137]                   sendCondition <- ...future.makeSendCondition()
[17:46:22.137]                   sendCondition(cond)
[17:46:22.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.137]                   {
[17:46:22.137]                     inherits <- base::inherits
[17:46:22.137]                     invokeRestart <- base::invokeRestart
[17:46:22.137]                     is.null <- base::is.null
[17:46:22.137]                     muffled <- FALSE
[17:46:22.137]                     if (inherits(cond, "message")) {
[17:46:22.137]                       muffled <- grepl(pattern, "muffleMessage")
[17:46:22.137]                       if (muffled) 
[17:46:22.137]                         invokeRestart("muffleMessage")
[17:46:22.137]                     }
[17:46:22.137]                     else if (inherits(cond, "warning")) {
[17:46:22.137]                       muffled <- grepl(pattern, "muffleWarning")
[17:46:22.137]                       if (muffled) 
[17:46:22.137]                         invokeRestart("muffleWarning")
[17:46:22.137]                     }
[17:46:22.137]                     else if (inherits(cond, "condition")) {
[17:46:22.137]                       if (!is.null(pattern)) {
[17:46:22.137]                         computeRestarts <- base::computeRestarts
[17:46:22.137]                         grepl <- base::grepl
[17:46:22.137]                         restarts <- computeRestarts(cond)
[17:46:22.137]                         for (restart in restarts) {
[17:46:22.137]                           name <- restart$name
[17:46:22.137]                           if (is.null(name)) 
[17:46:22.137]                             next
[17:46:22.137]                           if (!grepl(pattern, name)) 
[17:46:22.137]                             next
[17:46:22.137]                           invokeRestart(restart)
[17:46:22.137]                           muffled <- TRUE
[17:46:22.137]                           break
[17:46:22.137]                         }
[17:46:22.137]                       }
[17:46:22.137]                     }
[17:46:22.137]                     invisible(muffled)
[17:46:22.137]                   }
[17:46:22.137]                   muffleCondition(cond)
[17:46:22.137]                 })
[17:46:22.137]             }))
[17:46:22.137]             future::FutureResult(value = ...future.value$value, 
[17:46:22.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.137]                   ...future.rng), globalenv = if (FALSE) 
[17:46:22.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:46:22.137]                     ...future.globalenv.names))
[17:46:22.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:46:22.137]         }, condition = base::local({
[17:46:22.137]             c <- base::c
[17:46:22.137]             inherits <- base::inherits
[17:46:22.137]             invokeRestart <- base::invokeRestart
[17:46:22.137]             length <- base::length
[17:46:22.137]             list <- base::list
[17:46:22.137]             seq.int <- base::seq.int
[17:46:22.137]             signalCondition <- base::signalCondition
[17:46:22.137]             sys.calls <- base::sys.calls
[17:46:22.137]             `[[` <- base::`[[`
[17:46:22.137]             `+` <- base::`+`
[17:46:22.137]             `<<-` <- base::`<<-`
[17:46:22.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:46:22.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:46:22.137]                   3L)]
[17:46:22.137]             }
[17:46:22.137]             function(cond) {
[17:46:22.137]                 is_error <- inherits(cond, "error")
[17:46:22.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:46:22.137]                   NULL)
[17:46:22.137]                 if (is_error) {
[17:46:22.137]                   sessionInformation <- function() {
[17:46:22.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:46:22.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:46:22.137]                       search = base::search(), system = base::Sys.info())
[17:46:22.137]                   }
[17:46:22.137]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:46:22.137]                     cond$call), session = sessionInformation(), 
[17:46:22.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:46:22.137]                   signalCondition(cond)
[17:46:22.137]                 }
[17:46:22.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:46:22.137]                 "immediateCondition"))) {
[17:46:22.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:46:22.137]                   ...future.conditions[[length(...future.conditions) + 
[17:46:22.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:46:22.137]                   if (TRUE && !signal) {
[17:46:22.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.137]                     {
[17:46:22.137]                       inherits <- base::inherits
[17:46:22.137]                       invokeRestart <- base::invokeRestart
[17:46:22.137]                       is.null <- base::is.null
[17:46:22.137]                       muffled <- FALSE
[17:46:22.137]                       if (inherits(cond, "message")) {
[17:46:22.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.137]                         if (muffled) 
[17:46:22.137]                           invokeRestart("muffleMessage")
[17:46:22.137]                       }
[17:46:22.137]                       else if (inherits(cond, "warning")) {
[17:46:22.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.137]                         if (muffled) 
[17:46:22.137]                           invokeRestart("muffleWarning")
[17:46:22.137]                       }
[17:46:22.137]                       else if (inherits(cond, "condition")) {
[17:46:22.137]                         if (!is.null(pattern)) {
[17:46:22.137]                           computeRestarts <- base::computeRestarts
[17:46:22.137]                           grepl <- base::grepl
[17:46:22.137]                           restarts <- computeRestarts(cond)
[17:46:22.137]                           for (restart in restarts) {
[17:46:22.137]                             name <- restart$name
[17:46:22.137]                             if (is.null(name)) 
[17:46:22.137]                               next
[17:46:22.137]                             if (!grepl(pattern, name)) 
[17:46:22.137]                               next
[17:46:22.137]                             invokeRestart(restart)
[17:46:22.137]                             muffled <- TRUE
[17:46:22.137]                             break
[17:46:22.137]                           }
[17:46:22.137]                         }
[17:46:22.137]                       }
[17:46:22.137]                       invisible(muffled)
[17:46:22.137]                     }
[17:46:22.137]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.137]                   }
[17:46:22.137]                 }
[17:46:22.137]                 else {
[17:46:22.137]                   if (TRUE) {
[17:46:22.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:46:22.137]                     {
[17:46:22.137]                       inherits <- base::inherits
[17:46:22.137]                       invokeRestart <- base::invokeRestart
[17:46:22.137]                       is.null <- base::is.null
[17:46:22.137]                       muffled <- FALSE
[17:46:22.137]                       if (inherits(cond, "message")) {
[17:46:22.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:46:22.137]                         if (muffled) 
[17:46:22.137]                           invokeRestart("muffleMessage")
[17:46:22.137]                       }
[17:46:22.137]                       else if (inherits(cond, "warning")) {
[17:46:22.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:46:22.137]                         if (muffled) 
[17:46:22.137]                           invokeRestart("muffleWarning")
[17:46:22.137]                       }
[17:46:22.137]                       else if (inherits(cond, "condition")) {
[17:46:22.137]                         if (!is.null(pattern)) {
[17:46:22.137]                           computeRestarts <- base::computeRestarts
[17:46:22.137]                           grepl <- base::grepl
[17:46:22.137]                           restarts <- computeRestarts(cond)
[17:46:22.137]                           for (restart in restarts) {
[17:46:22.137]                             name <- restart$name
[17:46:22.137]                             if (is.null(name)) 
[17:46:22.137]                               next
[17:46:22.137]                             if (!grepl(pattern, name)) 
[17:46:22.137]                               next
[17:46:22.137]                             invokeRestart(restart)
[17:46:22.137]                             muffled <- TRUE
[17:46:22.137]                             break
[17:46:22.137]                           }
[17:46:22.137]                         }
[17:46:22.137]                       }
[17:46:22.137]                       invisible(muffled)
[17:46:22.137]                     }
[17:46:22.137]                     muffleCondition(cond, pattern = "^muffle")
[17:46:22.137]                   }
[17:46:22.137]                 }
[17:46:22.137]             }
[17:46:22.137]         }))
[17:46:22.137]     }, error = function(ex) {
[17:46:22.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:46:22.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:46:22.137]                 ...future.rng), started = ...future.startTime, 
[17:46:22.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:46:22.137]             version = "1.8"), class = "FutureResult")
[17:46:22.137]     }, finally = {
[17:46:22.137]         if (!identical(...future.workdir, getwd())) 
[17:46:22.137]             setwd(...future.workdir)
[17:46:22.137]         {
[17:46:22.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:46:22.137]                 ...future.oldOptions$nwarnings <- NULL
[17:46:22.137]             }
[17:46:22.137]             base::options(...future.oldOptions)
[17:46:22.137]             if (.Platform$OS.type == "windows") {
[17:46:22.137]                 old_names <- names(...future.oldEnvVars)
[17:46:22.137]                 envs <- base::Sys.getenv()
[17:46:22.137]                 names <- names(envs)
[17:46:22.137]                 common <- intersect(names, old_names)
[17:46:22.137]                 added <- setdiff(names, old_names)
[17:46:22.137]                 removed <- setdiff(old_names, names)
[17:46:22.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:46:22.137]                   envs[common]]
[17:46:22.137]                 NAMES <- toupper(changed)
[17:46:22.137]                 args <- list()
[17:46:22.137]                 for (kk in seq_along(NAMES)) {
[17:46:22.137]                   name <- changed[[kk]]
[17:46:22.137]                   NAME <- NAMES[[kk]]
[17:46:22.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.137]                     next
[17:46:22.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.137]                 }
[17:46:22.137]                 NAMES <- toupper(added)
[17:46:22.137]                 for (kk in seq_along(NAMES)) {
[17:46:22.137]                   name <- added[[kk]]
[17:46:22.137]                   NAME <- NAMES[[kk]]
[17:46:22.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.137]                     next
[17:46:22.137]                   args[[name]] <- ""
[17:46:22.137]                 }
[17:46:22.137]                 NAMES <- toupper(removed)
[17:46:22.137]                 for (kk in seq_along(NAMES)) {
[17:46:22.137]                   name <- removed[[kk]]
[17:46:22.137]                   NAME <- NAMES[[kk]]
[17:46:22.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:46:22.137]                     next
[17:46:22.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:46:22.137]                 }
[17:46:22.137]                 if (length(args) > 0) 
[17:46:22.137]                   base::do.call(base::Sys.setenv, args = args)
[17:46:22.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:46:22.137]             }
[17:46:22.137]             else {
[17:46:22.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:46:22.137]             }
[17:46:22.137]             {
[17:46:22.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:46:22.137]                   0L) {
[17:46:22.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:46:22.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:46:22.137]                   base::options(opts)
[17:46:22.137]                 }
[17:46:22.137]                 {
[17:46:22.137]                   {
[17:46:22.137]                     base::options(mc.cores = ...future.mc.cores.old)
[17:46:22.137]                     NULL
[17:46:22.137]                   }
[17:46:22.137]                   options(future.plan = NULL)
[17:46:22.137]                   if (is.na(NA_character_)) 
[17:46:22.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:46:22.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:46:22.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:46:22.137]                     .init = FALSE)
[17:46:22.137]                 }
[17:46:22.137]             }
[17:46:22.137]         }
[17:46:22.137]     })
[17:46:22.137]     if (TRUE) {
[17:46:22.137]         base::sink(type = "output", split = FALSE)
[17:46:22.137]         if (TRUE) {
[17:46:22.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:46:22.137]         }
[17:46:22.137]         else {
[17:46:22.137]             ...future.result["stdout"] <- base::list(NULL)
[17:46:22.137]         }
[17:46:22.137]         base::close(...future.stdout)
[17:46:22.137]         ...future.stdout <- NULL
[17:46:22.137]     }
[17:46:22.137]     ...future.result$conditions <- ...future.conditions
[17:46:22.137]     ...future.result$finished <- base::Sys.time()
[17:46:22.137]     ...future.result
[17:46:22.137] }
[17:46:22.140] Exporting 3 global objects (4.18 KiB) to cluster node #1 ...
[17:46:22.140] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ...
[17:46:22.140] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ... DONE
[17:46:22.141] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:46:22.141] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.141] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[17:46:22.141] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[17:46:22.141] Exporting 3 global objects (4.18 KiB) to cluster node #1 ... DONE
[17:46:22.142] MultisessionFuture started
[17:46:22.142] - Launch lazy future ... done
[17:46:22.142] run() for ‘MultisessionFuture’ ... done
[17:46:22.142] result() for ClusterFuture ...
[17:46:22.143] receiveMessageFromWorker() for ClusterFuture ...
[17:46:22.143] - Validating connection of MultisessionFuture
[17:46:22.144] - received message: FutureResult
[17:46:22.144] - Received FutureResult
[17:46:22.144] - Erased future from FutureRegistry
[17:46:22.144] result() for ClusterFuture ...
[17:46:22.144] - result already collected: FutureResult
[17:46:22.144] result() for ClusterFuture ... done
[17:46:22.144] receiveMessageFromWorker() for ClusterFuture ... done
[17:46:22.145] result() for ClusterFuture ... done
[17:46:22.145] result() for ClusterFuture ...
[17:46:22.145] - result already collected: FutureResult
[17:46:22.145] result() for ClusterFuture ... done
[1] 6
Testing with 2 cores ... DONE
> 
> message("*** Global argument '...' ... DONE")
*** Global argument '...' ... DONE
> 
> source("incl/end.R")
[17:46:22.146] plan(): Setting new future strategy stack:
[17:46:22.146] List of future strategies:
[17:46:22.146] 1. FutureStrategy:
[17:46:22.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:46:22.146]    - tweaked: FALSE
[17:46:22.146]    - call: future::plan(oplan)
[17:46:22.147] plan(): nbrOfWorkers() = 1
> 
